---
name: Fish
slug: fish~3.7
text_format: markdown
generator: src:devdocs
version: '3.7'
copyright: |-
  © 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors
  Licensed under the GNU General Public License, version 2.
  https://fishshell.com/docs/3.7/index.html
homepage: https://fishshell.com/

---
- name: 1. Help
  summary: Fish prides itself on being really nice to use interactively
  description: "# Interactive use\n\nFish prides itself on being really nice to use interactively. That’s down to a few features we’ll explain in the next few sections.\n\nFish is used by giving commands in the fish language, see [The Fish Language](language#language) for information on that.\n\n## Help\n\nFish has an extensive help system. Use the [help](cmds/help) command to obtain help on a specific subject or command. For instance, writing `help syntax` displays the [syntax section](language#syntax) of this documentation.\n\nFish also has man pages for its commands, and translates the help pages to man pages. For example, `man set` will show the documentation for `set` as a man page.\n\nHelp on a specific builtin can also be obtained with the `-h` parameter. For instance, to obtain help on the [fg](cmds/fg) builtin, either type `fg -h` or `help fg`.\n\nThe main page can be viewed via `help index` (or just `help`) or `man fish-doc`. The tutorial can be viewed with `help tutorial` or `man fish-tutorial`.\n\n## Autosuggestions\n\nfish suggests commands as you type, based on [command history](#history-search), completions, and valid file paths. As you type commands, you will see a suggestion offered after the cursor, in a muted gray color (which can be changed with the `fish_color_autosuggestion` variable).\n\nTo accept the autosuggestion (replacing the command line contents), press → or Control+F. To accept the first suggested word, press Alt+→ or Alt+F. If the autosuggestion is not what you want, just ignore it: it won’t execute unless you accept it.\n\nAutosuggestions are a powerful way to quickly summon frequently entered commands, by typing the first few characters. They are also an efficient technique for navigating through directory hierarchies.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completion\n\nTab completion is a time saving feature of any modern shell. When you type Tab, fish tries to guess the rest of the word under the cursor. If it finds just one possibility, it inserts it. If it finds more, it inserts the longest unambiguous part and then opens a menu (the “pager”) that you can navigate to find what you’re looking for.\n\nThe pager can be navigated with the arrow keys, Page Up / Page Down, Tab or Shift+Tab. Pressing Control+S (the `pager-toggle-search` binding - / in vi-mode) opens up a search menu that you can use to filter the list.\n\nFish provides some general purpose completions, like for commands, variable names, usernames or files.\n\nIt also provides a large number of program specific scripted completions. Most of these completions are simple options like the `-l` option for `ls`, but a lot are more advanced. For example:\n\n- `man` and `whatis` show the installed manual pages as completions.\n- `make` uses targets in the Makefile in the current directory as completions.\n- `mount` uses mount points specified in fstab as completions.\n- `apt`, `rpm` and `yum` show installed or installable packages\n\nYou can also write your own completions or install some you got from someone else. For that, see [Writing your own completions](completions#completion-own).\n\nCompletion scripts are loaded on demand, just like [functions are](language#syntax-function-autoloading). The difference is the `$fish_complete_path` [list](language#variables-lists) is used instead of `$fish_function_path`. Typically you can drop new completions in ~/.config/fish/completions/name-of-command.fish and fish will find them automatically.\n\n## Syntax highlighting\n\nFish interprets the command line as it is typed and uses syntax highlighting to provide feedback. The most important feedback is the detection of potential errors. By default, errors are marked red.\n\nDetected errors include:\n\n- Non-existing commands.\n- Reading from or appending to a non-existing file.\n- Incorrect use of output redirects\n- Mismatched parenthesis\n\nTo customize the syntax highlighting, you can set the environment variables listed in the [Variables for changing highlighting colors](#variables-color) section.\n\nFish also provides pre-made color themes you can pick with [fish_config](cmds/fish_config). Running just `fish_config` opens a browser interface, or you can use `fish_config theme` in the terminal.\n\nFor example, to disable nearly all coloring:\n\n```\nfish_config theme choose none\n```\n\nOr, to see all themes, right in your terminal:\n\n```\nfish_config theme show\n```\n\n### Syntax highlighting variables\n\nThe colors used by fish for syntax highlighting can be configured by changing the values of various variables. The value of these variables can be one of the colors accepted by the [set_color](cmds/set_color) command. The modifier switches accepted by `set_color` like `--bold`, `--dim`, `--italics`, `--reverse` and `--underline` are also accepted.\n\nExample: to make errors highlighted and red, use:\n\n```\nset fish_color_error red --bold\n```\n\nThe following variables are available to change the highlighting colors in fish:\n\n| Variable                     | Meaning                                                                |\n|------------------------------|------------------------------------------------------------------------|\n| `fish_color_normal`          | default color                                                          |\n| `fish_color_command`         | commands like echo                                                     |\n| `fish_color_keyword`         | keywords like if - this falls back on the command color if unset       |\n| `fish_color_quote`           | quoted text like `\"abc\"`                                               |\n| `fish_color_redirection`     | IO redirections like \\>/dev/null                                       |\n| `fish_color_end`             | process separators like `;` and `&`                                    |\n| `fish_color_error`           | syntax errors                                                          |\n| `fish_color_param`           | ordinary command parameters                                            |\n| `fish_color_valid_path`      | parameters that are filenames (if the file exists)                     |\n| `fish_color_option`          | options starting with “-”, up to the first “--” parameter              |\n| `fish_color_comment`         | comments like ‘# important’                                            |\n| `fish_color_selection`       | selected text in vi visual mode                                        |\n| `fish_color_operator`        | parameter expansion operators like `*` and `~`                         |\n| `fish_color_escape`          | character escapes like `\\n` and `\\x70`                                 |\n| `fish_color_autosuggestion`  | autosuggestions (the proposed rest of a command)                       |\n| `fish_color_cwd`             | the current working directory in the default prompt                    |\n| `fish_color_cwd_root`        | the current working directory in the default prompt for the root user  |\n| `fish_color_user`            | the username in the default prompt                                     |\n| `fish_color_host`            | the hostname in the default prompt                                     |\n| `fish_color_host_remote`     | the hostname in the default prompt for remote sessions (like ssh)      |\n| `fish_color_status`          | the last command’s nonzero exit code in the default prompt             |\n| `fish_color_cancel`          | the ‘^C’ indicator on a canceled command                               |\n| `fish_color_search_match`    | history search matches and selected pager items (background only)      |\n| `fish_color_history_current` | the current position in the history for commands like `dirh` and `cdh` |\n\nIf a variable isn’t set or is empty, fish usually tries `$fish_color_normal`, except for:\n\n- `$fish_color_keyword`, where it tries `$fish_color_command` first.\n- `$fish_color_option`, where it tries `$fish_color_param` first.\n- For `$fish_color_valid_path`, if that doesn’t have a color, but only modifiers, it adds those to the color that would otherwise be used, like `$fish_color_param`. But if valid paths have a color, it uses that and adds in modifiers from the other color.\n\n### Pager color variables\n\nfish will sometimes present a list of choices in a table, called the pager.\n\nExample: to set the background of each pager row, use:\n\n```\nset fish_pager_color_background --background=white\n```\n\nTo have black text on alternating white and gray backgrounds:\n\n```\nset fish_pager_color_prefix black\nset fish_pager_color_completion black\nset fish_pager_color_description black\nset fish_pager_color_background --background=white\nset fish_pager_color_secondary_background --background=brwhite\n```\n\nVariables affecting the pager colors:\n\n| Variable                                 | Meaning                                                     |\n|------------------------------------------|-------------------------------------------------------------|\n| `fish_pager_color_progress`              | the progress bar at the bottom left corner                  |\n| `fish_pager_color_background`            | the background color of a line                              |\n| `fish_pager_color_prefix`                | the prefix string, i.e. the string that is to be completed  |\n| `fish_pager_color_completion`            | the completion itself, i.e. the proposed rest of the string |\n| `fish_pager_color_description`           | the completion description                                  |\n| `fish_pager_color_selected_background`   | background of the selected completion                       |\n| `fish_pager_color_selected_prefix`       | prefix of the selected completion                           |\n| `fish_pager_color_selected_completion`   | suffix of the selected completion                           |\n| `fish_pager_color_selected_description`  | description of the selected completion                      |\n| `fish_pager_color_secondary_background`  | background of every second unselected completion            |\n| `fish_pager_color_secondary_prefix`      | prefix of every second unselected completion                |\n| `fish_pager_color_secondary_completion`  | suffix of every second unselected completion                |\n| `fish_pager_color_secondary_description` | description of every second unselected completion           |\n\nWhen the secondary or selected variables aren’t set or are empty, the normal variables are used, except for `$fish_pager_color_selected_background`, where the background of `$fish_color_search_match` is tried first.\n\n## Abbreviations\n\nTo avoid needless typing, a frequently-run command like `git checkout` can be abbreviated to `gco` using the [abbr](cmds/abbr) command.\n\n```\nabbr -a gco git checkout\n```\n\nAfter entering `gco` and pressing Space or Enter, a `gco` in command position will turn into `git checkout` in the command line. If you want to use a literal `gco` sometimes, use Control+Space [\\[1\\]](#id5).\n\nThis is a lot more powerful, for example you can make going up a number of directories easier with this:\n\n```\nfunction multicd\n    echo cd (string repeat -n (math (string length -- $argv[1]) - 1) ../)\nend\nabbr --add dotdot --regex '^\\.\\.+$' --function multicd\n```\n\nNow, `..` transforms to `cd ../`, while `...` turns into `cd ../../` and `....` expands to `cd ../../../`.\n\nThe advantage over aliases is that you can see the actual command before using it, add to it or change it, and the actual command will be stored in history.\n\n\\[[1](#id4)\\]\n\nAny binding that executes the `expand-abbr` or `execute` [bind function](cmds/bind) will expand abbreviations. By default Control+Space is bound to just inserting a space.\n\n## Programmable title\n\nWhen using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window. This can be done automatically in fish by defining the [fish_title](cmds/fish_title) function. The [fish_title](cmds/fish_title) function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message. The [status current-command](cmds/status) builtin will always return the name of the job to be put into the foreground (or `fish` if control is returning to the shell) when the [fish_prompt](cmds/fish_prompt) function is called. The first argument to fish_title will contain the most recently executed foreground command as a string.\n\nThe default fish title shows the hostname if connected via ssh, the currently running command (unless it is fish) and the current working directory. All of this is shortened to not make the tab too wide.\n\nExamples:\n\nTo show the last command and working directory in the title:\n\n```\nfunction fish_title\n    # `prompt_pwd` shortens the title. This helps prevent tabs from becoming very wide.\n    echo $argv[1] (prompt_pwd)\n    pwd\nend\n```\n\n## Programmable prompt\n\nWhen it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt. It does this by running the [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) functions.\n\nThe output of the former is displayed on the left and the latter’s output on the right side of the terminal. The output of [fish_mode_prompt](cmds/fish_mode_prompt) will be prepended on the left, though the default function only does this when in [vi-mode](#vi-mode).\n\n## Configurable greeting\n\nWhen it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):\n\n```\nset -U fish_greeting\n```\n\nor you can set it [globally](language#variables-scope) in [config.fish](language#configuration):\n\n```\nset -g fish_greeting 'Hey, stranger!'\n```\n\nor you can script it by changing the function:\n\n```\nfunction fish_greeting\n    random choice \"Hello!\" \"Hi\" \"G'day\" \"Howdy\"\nend\n```\n\nsave this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.\n\n## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 1. Syntax overview
  summary: Shells like fish are used by giving them commands
  belongs_to: 7. Combining pipes and redirections
  description: |-
    ## Syntax overview

    Shells like fish are used by giving them commands. A command is executed by writing the name of the command followed by any arguments. For example:

    ```
    echo hello world
    ```

    [echo](cmds/echo) command writes its arguments to the screen. In this example the output is `hello world`.

    Everything in fish is done with commands. There are commands for repeating other commands, commands for assigning variables, commands for treating a group of commands as a single command, etc. All of these commands follow the same basic syntax.

    Every program on your computer can be used as a command in fish. If the program file is located in one of the
- name: 1. Why fish?
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 2. Autosuggestions
  summary: fish suggests commands as you type, based on command history, completions, and valid file paths
  belongs_to: 1. Help
  description: "## Autosuggestions\n\nfish suggests commands as you type, based on [command history](#history-search), completions, and valid file paths. As you type commands, you will see a suggestion offered after the cursor, in a muted gray color (which can be changed with the `fish_color_autosuggestion` variable).\n\nTo accept the autosuggestion (replacing the command line contents), press → or Control+F. To accept the first suggested word, press Alt+→ or Alt+F. If the autosuggestion is not what you want, just ignore it: it won’t execute unless you accept it.\n\nAutosuggestions are a powerful way to quickly summon frequently entered commands, by typing the first few characters. They are also an efficient technique for navigating through directory hierarchies.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completion\n\nTab completion is a time saving feature of any modern shell. When you type Tab, fish tries to guess the rest of the word under the cursor. If it finds just one possibility, it inserts it. If it finds more, it inserts the longest unambiguous part and then opens a menu (the “pager”) that you can navigate to find what you’re looking for.\n\nThe pager can be navigated with the arrow keys, Page Up / Page Down, Tab or Shift+Tab. Pressing Control+S (the `pager-toggle-search` binding - / in vi-mode) opens up a search menu that you can use to filter the list.\n\nFish provides some general purpose completions, like for commands, variable names, usernames or files.\n\nIt also provides a large number of program specific scripted completions. Most of these completions are simple options like the `-l` option for `ls`, but a lot are more advanced. For example:\n\n- `man` and `whatis` show the installed manual pages as completions.\n- `make` uses targets in the Makefile in the current directory as completions.\n- `mount` uses mount points specified in fstab as completions.\n- `apt`, `rpm` and `yum` show installed or installable packages\n\nYou can also write your own completions or install some you got from someone else. For that, see [Writing your own completions](completions#completion-own).\n\nCompletion scripts are loaded on demand, just like [functions are](language#syntax-function-autoloading). The difference is the `$fish_complete_path` [list](language#variables-lists) is used instead of `$fish_function_path`. Typically you can drop new completions in ~/.config/fish/completions/name-of-command.fish and fish will find them automatically.\n\n## Syntax highlighting\n\nFish interprets the command line as it is typed and uses syntax highlighting to provide feedback. The most important feedback is the detection of potential errors. By default, errors are marked red.\n\nDetected errors include:\n\n- Non-existing commands.\n- Reading from or appending to a non-existing file.\n- Incorrect use of output redirects\n- Mismatched parenthesis\n\nTo customize the syntax highlighting, you can set the environment variables listed in the [Variables for changing highlighting colors](#variables-color) section.\n\nFish also provides pre-made color themes you can pick with [fish_config](cmds/fish_config). Running just `fish_config` opens a browser interface, or you can use `fish_config theme` in the terminal.\n\nFor example, to disable nearly all coloring:\n\n```\nfish_config theme choose none\n```\n\nOr, to see all themes, right in your terminal:\n\n```\nfish_config theme show\n```\n\n### Syntax highlighting variables\n\nThe colors used by fish for syntax highlighting can be configured by changing the values of various variables. The value of these variables can be one of the colors accepted by the [set_color](cmds/set_color) command. The modifier switches accepted by `set_color` like `--bold`, `--dim`, `--italics`, `--reverse` and `--underline` are also accepted.\n\nExample: to make errors highlighted and red, use:\n\n```\nset fish_color_error red --bold\n```\n\nThe following variables are available to change the highlighting colors in fish:\n\n| Variable                     | Meaning                                                                |\n|------------------------------|------------------------------------------------------------------------|\n| `fish_color_normal`          | default color                                                          |\n| `fish_color_command`         | commands like echo                                                     |\n| `fish_color_keyword`         | keywords like if - this falls back on the command color if unset       |\n| `fish_color_quote`           | quoted text like `\"abc\"`                                               |\n| `fish_color_redirection`     | IO redirections like \\>/dev/null                                       |\n| `fish_color_end`             | process separators like `;` and `&`                                    |\n| `fish_color_error`           | syntax errors                                                          |\n| `fish_color_param`           | ordinary command parameters                                            |\n| `fish_color_valid_path`      | parameters that are filenames (if the file exists)                     |\n| `fish_color_option`          | options starting with “-”, up to the first “--” parameter              |\n| `fish_color_comment`         | comments like ‘# important’                                            |\n| `fish_color_selection`       | selected text in vi visual mode                                        |\n| `fish_color_operator`        | parameter expansion operators like `*` and `~`                         |\n| `fish_color_escape`          | character escapes like `\\n` and `\\x70`                                 |\n| `fish_color_autosuggestion`  | autosuggestions (the proposed rest of a command)                       |\n| `fish_color_cwd`             | the current working directory in the default prompt                    |\n| `fish_color_cwd_root`        | the current working directory in the default prompt for the root user  |\n| `fish_color_user`            | the username in the default prompt                                     |\n| `fish_color_host`            | the hostname in the default prompt                                     |\n| `fish_color_host_remote`     | the hostname in the default prompt for remote sessions (like ssh)      |\n| `fish_color_status`          | the last command’s nonzero exit code in the default prompt             |\n| `fish_color_cancel`          | the ‘^C’ indicator on a canceled command                               |\n| `fish_color_search_match`    | history search matches and selected pager items (background only)      |\n| `fish_color_history_current` | the current position in the history for commands like `dirh` and `cdh` |\n\nIf a variable isn’t set or is empty, fish usually tries `$fish_color_normal`, except for:\n\n- `$fish_color_keyword`, where it tries `$fish_color_command` first.\n- `$fish_color_option`, where it tries `$fish_color_param` first.\n- For `$fish_color_valid_path`, if that doesn’t have a color, but only modifiers, it adds those to the color that would otherwise be used, like `$fish_color_param`. But if valid paths have a color, it uses that and adds in modifiers from the other color.\n\n### Pager color variables\n\nfish will sometimes present a list of choices in a table, called the pager.\n\nExample: to set the background of each pager row, use:\n\n```\nset fish_pager_color_background --background=white\n```\n\nTo have black text on alternating white and gray backgrounds:\n\n```\nset fish_pager_color_prefix black\nset fish_pager_color_completion black\nset fish_pager_color_description black\nset fish_pager_color_background --background=white\nset fish_pager_color_secondary_background --background=brwhite\n```\n\nVariables affecting the pager colors:\n\n| Variable                                 | Meaning                                                     |\n|------------------------------------------|-------------------------------------------------------------|\n| `fish_pager_color_progress`              | the progress bar at the bottom left corner                  |\n| `fish_pager_color_background`            | the background color of a line                              |\n| `fish_pager_color_prefix`                | the prefix string, i.e. the string that is to be completed  |\n| `fish_pager_color_completion`            | the completion itself, i.e. the proposed rest of the string |\n| `fish_pager_color_description`           | the completion description                                  |\n| `fish_pager_color_selected_background`   | background of the selected completion                       |\n| `fish_pager_color_selected_prefix`       | prefix of the selected completion                           |\n| `fish_pager_color_selected_completion`   | suffix of the selected completion                           |\n| `fish_pager_color_selected_description`  | description of the selected completion                      |\n| `fish_pager_color_secondary_background`  | background of every second unselected completion            |\n| `fish_pager_color_secondary_prefix`      | prefix of every second unselected completion                |\n| `fish_pager_color_secondary_completion`  | suffix of every second unselected completion                |\n| `fish_pager_color_secondary_description` | description of every second unselected completion           |\n\nWhen the secondary or selected variables aren’t set or are empty, the normal variables are used, except for `$fish_pager_color_selected_background`, where the background of `$fish_color_search_match` is tried first.\n\n## Abbreviations\n\nTo avoid needless typing, a frequently-run command like `git checkout` can be abbreviated to `gco` using the [abbr](cmds/abbr) command.\n\n```\nabbr -a gco git checkout\n```\n\nAfter entering `gco` and pressing Space or Enter, a `gco` in command position will turn into `git checkout` in the command line. If you want to use a literal `gco` sometimes, use Control+Space [\\[1\\]](#id5).\n\nThis is a lot more powerful, for example you can make going up a number of directories easier with this:\n\n```\nfunction multicd\n    echo cd (string repeat -n (math (string length -- $argv[1]) - 1) ../)\nend\nabbr --add dotdot --regex '^\\.\\.+$' --function multicd\n```\n\nNow, `..` transforms to `cd ../`, while `...` turns into `cd ../../` and `....` expands to `cd ../../../`.\n\nThe advantage over aliases is that you can see the actual command before using it, add to it or change it, and the actual command will be stored in history.\n\n\\[[1](#id4)\\]\n\nAny binding that executes the `expand-abbr` or `execute` [bind function](cmds/bind) will expand abbreviations. By default Control+Space is bound to just inserting a space.\n\n## Programmable title\n\nWhen using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window. This can be done automatically in fish by defining the [fish_title](cmds/fish_title) function. The [fish_title](cmds/fish_title) function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message. The [status current-command](cmds/status) builtin will always return the name of the job to be put into the foreground (or `fish` if control is returning to the shell) when the [fish_prompt](cmds/fish_prompt) function is called. The first argument to fish_title will contain the most recently executed foreground command as a string.\n\nThe default fish title shows the hostname if connected via ssh, the currently running command (unless it is fish) and the current working directory. All of this is shortened to not make the tab too wide.\n\nExamples:\n\nTo show the last command and working directory in the title:\n\n```\nfunction fish_title\n    # `prompt_pwd` shortens the title. This helps prevent tabs from becoming very wide.\n    echo $argv[1] (prompt_pwd)\n    pwd\nend\n```\n\n## Programmable prompt\n\nWhen it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt. It does this by running the [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) functions.\n\nThe output of the former is displayed on the left and the latter’s output on the right side of the terminal. The output of [fish_mode_prompt](cmds/fish_mode_prompt) will be prepended on the left, though the default function only does this when in [vi-mode](#vi-mode).\n\n## Configurable greeting\n\nWhen it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):\n\n```\nset -U fish_greeting\n```\n\nor you can set it [globally](language#variables-scope) in [config.fish](language#configuration):\n\n```\nset -g fish_greeting 'Hey, stranger!'\n```\n\nor you can script it by changing the function:\n\n```\nfunction fish_greeting\n    random choice \"Hello!\" \"Hi\" \"G'day\" \"Howdy\"\nend\n```\n\nsave this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.\n\n## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 2. Getting started
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 2. Terminology
  summary: 'Here we define some of the terms used on this page and throughout the rest of the fish documentation:'
  belongs_to: 7. Combining pipes and redirections
  description: |-
    ## Terminology

    Here we define some of the terms used on this page and throughout the rest of the fish documentation:

    - **Argument**: A parameter given to a command. In `echo foo`, the “foo” is an argument.
    - **Builtin**: A command that is implemented by the shell. Builtins are so closely tied to the operation of the shell that it is impossible to implement them as external commands. In `echo foo`, the “echo” is a builtin.
    - **Command**: A program that the shell can run, or more specifically an external program that the shell runs in another process. External commands are provided on your system, as executable files. In `echo foo` the “echo” is a builtin command, in `command echo foo` the “echo” is an external command, provided by a file like /bin/echo.
    - **Function**: A block of commands that can be called as if they were a single command. By using functions, it is possible to string together multiple simple commands into one more advanced command.
    - **Job**: A running pipeline or command.
    - **Pipeline**: A set of commands strung together so that the output of one command is the input of the next command. `echo foo | grep foo` is a pipeline.
    - **Redirection**: An operation that changes one of the input or output streams associated with a job.
    - **Switch** or **Option**: A special kind of argument that alters the behavior of a command. A switch almost always begins with one or two hyphens. In `echo -n foo` the “-n” is an option.
- name: 3. Learning fish
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 3. Quotes
  summary: Sometimes you want to give a command an argument that contains characters special to fish, like spaces or $ or *
  belongs_to: 7. Combining pipes and redirections
  description: "## Quotes\n\nSometimes you want to give a command an argument that contains characters special to fish, like spaces or `$` or `*`. To do that, you can use quotes:\n\n```\nrm \"my file.txt\"\n```\n\nto remove a file called `my file.txt` instead of trying to remove two files, `my` and `file.txt`.\n\nFish understands two kinds of quotes: Single (`'`) and double (`\"`), and both work slightly differently.\n\nBetween single quotes, fish performs no expansions. Between double quotes, fish only performs [variable expansion](#expand-variable) and [command substitution](#expand-command-substitution) in the `$(command)`. No other kind of expansion (including [brace expansion](#expand-brace) or parameter expansion) is performed, and escape sequences (for example, `\\n`) are ignored. Within quotes, whitespace is not used to separate arguments, allowing quoted arguments to contain spaces.\n\nThe only meaningful escape sequences in single quotes are `\\'`, which escapes a single quote and `\\\\`, which escapes the backslash symbol. The only meaningful escapes in double quotes are `\\\"`, which escapes a double quote, `\\$`, which escapes a dollar character, `\\` followed by a newline, which deletes the backslash and the newline, and `\\\\`, which escapes the backslash symbol.\n\nSingle quotes have no special meaning within double quotes and vice versa.\n\nMore examples:\n\n```\ngrep 'enabled)$' foo.txt\n```\n\nsearches for lines ending in `enabled)` in `foo.txt` (the `$` is special to `grep`: it matches the end of the line).\n\n```\napt install \"postgres-*\"\n```\n\ninstalls all packages with a name starting with “postgres-”, instead of looking through the current directory for files named “postgres-something”.\n\n## Escaping Characters\n\nSome characters cannot be written directly on the command line. For these characters, so-called escape sequences are provided. These are:\n\n- `\\a` represents the alert character.\n- `\\e` represents the escape character.\n- `\\f` represents the form feed character.\n- `\\n` represents a newline character.\n- `\\r` represents the carriage return character.\n- `\\t` represents the tab character.\n- `\\v` represents the vertical tab character.\n- `\\xHH` or `\\XHH`, where `HH` is a hexadecimal number, represents a byte of data with the specified value. For example, `\\x9` is the tab character. If you are using a multibyte encoding, this can be used to enter invalid strings. Typically fish is run with the ASCII or UTF-8 encoding, so anything up to `\\X7f` is an ASCII character.\n- `\\ooo`, where `ooo` is an octal number, represents the ASCII character with the specified value. For example, `\\011` is the tab character. The highest allowed value is `\\177`.\n- `\\uXXXX`, where `XXXX` is a hexadecimal number, represents the 16-bit Unicode character with the specified value. For example, `\\u9` is the tab character.\n- `\\UXXXXXXXX`, where `XXXXXXXX` is a hexadecimal number, represents the 32-bit Unicode character with the specified value. For example, `\\U9` is the tab character. The highest allowed value is U10FFFF.\n- `\\cX`, where `X` is a letter of the alphabet, represents the control sequence generated by pressing the control key and the specified letter. For example, `\\ci` is the tab character\n\nSome characters have special meaning to the shell. For example, an apostrophe `'` disables expansion (see [Quotes](#quotes)). To tell the shell to treat these characters literally, escape them with a backslash. For example, the command:\n\n```\necho \\'hello world\\'\n```\n\noutputs `'hello world'` (including the apostrophes), while the command:\n\n```\necho 'hello world'\n```\n\noutputs `hello world` (without the apostrophes). In the former case the shell treats the apostrophes as literal `'` characters, while in the latter case it treats them as special expansion modifiers.\n\nThe special characters and their escape sequences are:\n\n- `\\ ` (backslash space) escapes the space character. This keeps the shell from splitting arguments on the escaped space.\n- `\\$` escapes the dollar character.\n- `\\\\` escapes the backslash character.\n- `\\*` escapes the star character.\n- `\\?` escapes the question mark character (this is not necessary if the `qmark-noglob` [feature flag](#featureflags) is enabled).\n- `\\~` escapes the tilde character.\n- `\\#` escapes the hash character.\n- `\\(` escapes the left parenthesis character.\n- `\\)` escapes the right parenthesis character.\n- `\\{` escapes the left curly bracket character.\n- `\\}` escapes the right curly bracket character.\n- `\\[` escapes the left bracket character.\n- `\\]` escapes the right bracket character.\n- `\\<` escapes the less than character.\n- `\\>` escapes the more than character.\n- `\\&` escapes the ampersand character.\n- `\\|` escapes the vertical bar character.\n- `\\;` escapes the semicolon character.\n- `\\\"` escapes the quote character.\n- `\\'` escapes the apostrophe character.\n\nAs a special case, `\\` immediately followed by a literal new line is a “continuation” and tells fish to ignore the line break and resume input at the start of the next line (without introducing any whitespace or terminating a token).\n\n## Input/Output Redirection\n\nMost programs use three input/output (I/O) streams:\n\n- Standard input (stdin) for reading. Defaults to reading from the keyboard.\n- Standard output (stdout) for writing output. Defaults to writing to the screen.\n- Standard error (stderr) for writing errors and warnings. Defaults to writing to the screen.\n\nEach stream has a number called the file descriptor (FD): 0 for stdin, 1 for stdout, and 2 for stderr.\n\nThe destination of a stream can be changed using something called *redirection*. For example, `echo hello > output.txt`, redirects the standard output of the `echo` command to a text file.\n\n- To read standard input from a file, use `<SOURCE_FILE`.\n- To write standard output to a file, use `>DESTINATION`.\n- To write standard error to a file, use `2>DESTINATION`. [\\[1\\]](#id4)\n- To append standard output to a file, use `>>DESTINATION_FILE`.\n- To append standard error to a file, use `2>>DESTINATION_FILE`.\n- To not overwrite (“clobber”) an existing file, use `>?DESTINATION` or `2>?DESTINATION`. This is known as the “noclobber” redirection.\n\n`DESTINATION` can be one of the following:\n\n- A filename to write the output to. Often `>/dev/null` to silence output by writing it to the special “sinkhole” file.\n- An ampersand (`&`) followed by the number of another file descriptor like `&2` for standard error. The output will be written to the destination descriptor.\n- An ampersand followed by a minus sign (`&-`). The file descriptor will be closed. Note: This may cause the program to fail because its writes will be unsuccessful.\n\nAs a convenience, the redirection `&>` can be used to direct both stdout and stderr to the same destination. For example, `echo hello &> all_output.txt` redirects both stdout and stderr to the file `all_output.txt`. This is equivalent to `echo hello > all_output.txt 2>&1`.\n\nAny arbitrary file descriptor can be used in a redirection by prefixing the redirection with the FD number.\n\n- To redirect the input of descriptor N, use `N<DESTINATION`.\n- To redirect the output of descriptor N, use `N>DESTINATION`.\n- To append the output of descriptor N to a file, use `N>>DESTINATION_FILE`.\n\nFor example:\n\n```\n# Write `foo`'s standard error (file descriptor 2)\n# to a file called \"output.stderr\":\nfoo 2> output.stderr\n\n# if $num doesn't contain a number,\n# this test will be false and print an error,\n# so by ignoring the error we can be sure that we're dealing\n# with a number in the \"if\" block:\nif test \"$num\" -gt 2 2>/dev/null\n    # do things with $num as a number greater than 2\nelse\n    # do things if $num is <= 2 or not a number\nend\n\n# Save `make`s output in a file:\nmake &>/log\n\n# Redirections stack and can be used with blocks:\nbegin\n    echo stdout\n    echo stderr >&2 # <- this goes to stderr!\nend >/dev/null # ignore stdout, so this prints \"stderr\"\n```\n\nIt is an error to redirect a builtin, function, or block to a file descriptor above 2. However this is supported for external commands.\n\n\\[[1](#id3)\\]\n\nPrevious versions of fish also allowed specifying this as `^DESTINATION`, but that made another character special so it was deprecated and removed. See [feature flags](#featureflags).\n\n## Piping\n\nAnother way to redirect streams is a *pipe*. A pipe connects streams with each other. Usually the standard output of one command is connected with the standard input of another. This is done by separating commands with the pipe character `|`. For example:\n\n```\ncat foo.txt | head\n```\n\nThe command `cat foo.txt` sends the contents of `foo.txt` to stdout. This output is provided as input for the `head` program, which prints the first 10 lines of its input.\n\nIt is possible to pipe a different output file descriptor by prepending its FD number and the output redirect symbol to the pipe. For example:\n\n```\nmake fish 2>| less\n```\n\nwill attempt to build `fish`, and any errors will be shown using the `less` pager. [\\[2\\]](#id6)\n\nAs a convenience, the pipe `&|` redirects both stdout and stderr to the same process. This is different from bash, which uses `|&`.\n\n\\[[2](#id5)\\]\n\nA “pager” here is a program that takes output and “paginates” it. `less` doesn’t just do pages, it allows arbitrary scrolling (even back!).\n\n## Combining pipes and redirections\n\nIt is possible to use multiple redirections and a pipe at the same time. In that case, they are read in this order:\n\n1.  First the pipe is set up.\n2.  Then the redirections are evaluated from left-to-right.\n\nThis is important when any redirections reference other file descriptors with the `&N` syntax. When you say `>&2`, that will redirect stdout to where stderr is pointing to *at that time*.\n\nConsider this helper function:\n\n```\n# Just make a function that prints something to stdout and stderr\nfunction print\n    echo out\n    echo err >&2\nend\n```\n\nNow let’s see a few cases:\n\n```\n# Redirect both stderr and stdout to less\n# (can also be spelt as `&|`)\nprint 2>&1 | less\n\n# Show the \"out\" on stderr, silence the \"err\"\nprint >&2 2>/dev/null\n\n# Silence both\nprint >/dev/null 2>&1\n```\n\n## Job control\n\nWhen you start a job in fish, fish itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an `&` (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.\n\nExample:\n\n```\nemacs &\n```\n\nwill start the emacs text editor in the background. [fg](cmds/fg) can be used to bring it into the foreground again when needed.\n\nMost programs allow you to suspend the program’s execution and return control to fish by pressing Control+Z (also referred to as `^Z`). Once back at the fish commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the [fg](cmds/fg) (foreground) command.\n\nIf you instead want to put a suspended job into the background, use the [bg](cmds/bg) command.\n\nTo get a listing of all currently started jobs, use the [jobs](cmds/jobs) command. These listed jobs can be removed with the [disown](cmds/disown) command.\n\nAt the moment, functions cannot be started in the background. Functions that are stopped and then restarted in the background using the [bg](cmds/bg) command will not execute correctly.\n\nIf the `&` character is followed by a non-separating character, it is not interpreted as background operator. Separating characters are whitespace and the characters `;<>&|`.\n\n## Functions\n\nFunctions are programs written in the fish syntax. They group together various commands and their arguments using a single name.\n\nFor example, here’s a simple function to list directories:\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nThe first line tells fish to define a function by the name of `ll`, so it can be used by simply writing `ll` on the commandline. The second line tells fish that the command `ls -l $argv` should be called when `ll` is invoked. [\\$argv](#variables-argv) is a [list variable](#variables-lists), which always contains all arguments sent to the function. In the example above, these are simply passed on to the `ls` command. The `end` on the third line ends the definition.\n\nCalling this as `ll /tmp/` will end up running `ls -l /tmp/`, which will list the contents of /tmp.\n\nThis is a kind of function known as an [alias](#syntax-aliases).\n\nFish’s prompt is also defined in a function, called [fish_prompt](cmds/fish_prompt). It is run when the prompt is about to be displayed and its output forms the prompt:\n\n```\nfunction fish_prompt\n    # A simple prompt. Displays the current directory\n    # (which fish stores in the $PWD variable)\n    # and then a user symbol - a '►' for a normal user and a '#' for root.\n    set -l user_char '►'\n    if fish_is_root_user\n        set user_char '#'\n    end\n\n    echo (set_color yellow)$PWD (set_color purple)$user_char\nend\n```\n\nTo edit a function, you can use [funced](cmds/funced), and to save a function [funcsave](cmds/funcsave). This will store it in a function file that fish will [autoload](#syntax-function-autoloading) when needed.\n\nThe [functions](cmds/functions) builtin can show a function’s current definition (and [type](cmds/type) will also do if given a function).\n\nFor more information on functions, see the documentation for the [function](cmds/function) builtin.\n\n### Defining aliases\n\nOne of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the `ls` command to display colors. The switch for turning on colors on GNU systems is `--color=auto`. An alias around `ls` might look like this:\n\n```\nfunction ls\n    command ls --color=auto $argv\nend\n```\n\nThere are a few important things that need to be noted about aliases:\n\n- Always take care to add the [\\$argv](#variables-argv) variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.\n- If the alias has the same name as the aliased command, you need to prefix the call to the program with `command` to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).\n\nTo easily create a function of this form, you can use the [alias](cmds/alias) command. Unlike other shells, this just makes functions - fish has no separate concept of an “alias”, we just use the word for a simple wrapping function like this. [alias](cmds/alias) immediately creates a function. Consider using `alias --save` or [funcsave](cmds/funcsave) to save the created function into an autoload file instead of recreating the alias each time.\n\nFor an alternative, try [abbreviations](interactive#abbreviations). These are words that are expanded while you type, instead of being actual functions inside the shell.\n\n### Autoloading functions\n\nFunctions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:\n\n- An autoloaded function becomes available automatically to all running shells.\n- If the function definition is changed, all running shells will automatically reload the altered version, after a while.\n- Startup time and memory usage is improved, etc.\n\nWhen fish needs to load a function, it searches through any directories in the [list variable](#variables-lists) `$fish_function_path` for a file with a name consisting of the name of the function plus the suffix `.fish` and loads the first it finds.\n\nFor example if you try to execute something called `banana`, fish will go through all directories in \\$fish_function_path looking for a file called `banana.fish` and load the first one it finds.\n\nBy default `$fish_function_path` contains the following:\n\n- A directory for users to keep their own functions, usually `~/.config/fish/functions` (controlled by the `XDG_CONFIG_HOME` environment variable).\n- A directory for functions for all users on the system, usually `/etc/fish/functions` (really `$__fish_sysconfdir/functions`).\n- Directories for other software to put their own functions. These are in the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable) and in the `XDG_DATA_DIRS` environment variable, in a subdirectory called `fish/vendor_functions.d`. The default value for `XDG_DATA_DIRS` is usually `/usr/share/fish/vendor_functions.d` and `/usr/local/share/fish/vendor_functions.d`.\n- The functions shipped with fish, usually installed in `/usr/share/fish/functions` (really `$__fish_data_dir/functions`).\n\nIf you are unsure, your functions probably belong in `~/.config/fish/functions`.\n\nAs we’ve explained, autoload files are loaded *by name*, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.\n\nAutoloading also won’t work for [event handlers](#event), since fish cannot know that a function is supposed to be executed when an event occurs when it hasn’t yet loaded the function. See the [event handlers](#event) section for more information.\n\nIf a file of the right name doesn’t define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in \\$fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.\n\nIf you are developing another program and want to install fish functions for it, install them to the “vendor” functions directory. As this path varies from system to system, you can use `pkgconfig` to discover it with the output of `pkg-config --variable functionsdir fish`. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.\n\n## Comments\n\nAnything after a `#` until the end of the line is a comment. That means it’s purely for the reader’s benefit, fish ignores it.\n\nThis is useful to explain what and why you are doing something:\n\n```\nfunction ls\n    # The function is called ls,\n    # so we have to explicitly call `command ls` to avoid calling ourselves.\n    command ls --color=auto $argv\nend\n```\n\nThere are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a `#`.\n\nComments can also appear after a line like so:\n\n```\nset -gx EDITOR emacs # I don't like vim.\n```\n\n## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 3. Tab Completion
  summary: Tab completion is a time saving feature of any modern shell
  belongs_to: 1. Help
  description: "## Tab Completion\n\nTab completion is a time saving feature of any modern shell. When you type Tab, fish tries to guess the rest of the word under the cursor. If it finds just one possibility, it inserts it. If it finds more, it inserts the longest unambiguous part and then opens a menu (the “pager”) that you can navigate to find what you’re looking for.\n\nThe pager can be navigated with the arrow keys, Page Up / Page Down, Tab or Shift+Tab. Pressing Control+S (the `pager-toggle-search` binding - / in vi-mode) opens up a search menu that you can use to filter the list.\n\nFish provides some general purpose completions, like for commands, variable names, usernames or files.\n\nIt also provides a large number of program specific scripted completions. Most of these completions are simple options like the `-l` option for `ls`, but a lot are more advanced. For example:\n\n- `man` and `whatis` show the installed manual pages as completions.\n- `make` uses targets in the Makefile in the current directory as completions.\n- `mount` uses mount points specified in fstab as completions.\n- `apt`, `rpm` and `yum` show installed or installable packages\n\nYou can also write your own completions or install some you got from someone else. For that, see [Writing your own completions](completions#completion-own).\n\nCompletion scripts are loaded on demand, just like [functions are](language#syntax-function-autoloading). The difference is the `$fish_complete_path` [list](language#variables-lists) is used instead of `$fish_function_path`. Typically you can drop new completions in ~/.config/fish/completions/name-of-command.fish and fish will find them automatically.\n\n## Syntax highlighting\n\nFish interprets the command line as it is typed and uses syntax highlighting to provide feedback. The most important feedback is the detection of potential errors. By default, errors are marked red.\n\nDetected errors include:\n\n- Non-existing commands.\n- Reading from or appending to a non-existing file.\n- Incorrect use of output redirects\n- Mismatched parenthesis\n\nTo customize the syntax highlighting, you can set the environment variables listed in the [Variables for changing highlighting colors](#variables-color) section.\n\nFish also provides pre-made color themes you can pick with [fish_config](cmds/fish_config). Running just `fish_config` opens a browser interface, or you can use `fish_config theme` in the terminal.\n\nFor example, to disable nearly all coloring:\n\n```\nfish_config theme choose none\n```\n\nOr, to see all themes, right in your terminal:\n\n```\nfish_config theme show\n```\n\n### Syntax highlighting variables\n\nThe colors used by fish for syntax highlighting can be configured by changing the values of various variables. The value of these variables can be one of the colors accepted by the [set_color](cmds/set_color) command. The modifier switches accepted by `set_color` like `--bold`, `--dim`, `--italics`, `--reverse` and `--underline` are also accepted.\n\nExample: to make errors highlighted and red, use:\n\n```\nset fish_color_error red --bold\n```\n\nThe following variables are available to change the highlighting colors in fish:\n\n| Variable                     | Meaning                                                                |\n|------------------------------|------------------------------------------------------------------------|\n| `fish_color_normal`          | default color                                                          |\n| `fish_color_command`         | commands like echo                                                     |\n| `fish_color_keyword`         | keywords like if - this falls back on the command color if unset       |\n| `fish_color_quote`           | quoted text like `\"abc\"`                                               |\n| `fish_color_redirection`     | IO redirections like \\>/dev/null                                       |\n| `fish_color_end`             | process separators like `;` and `&`                                    |\n| `fish_color_error`           | syntax errors                                                          |\n| `fish_color_param`           | ordinary command parameters                                            |\n| `fish_color_valid_path`      | parameters that are filenames (if the file exists)                     |\n| `fish_color_option`          | options starting with “-”, up to the first “--” parameter              |\n| `fish_color_comment`         | comments like ‘# important’                                            |\n| `fish_color_selection`       | selected text in vi visual mode                                        |\n| `fish_color_operator`        | parameter expansion operators like `*` and `~`                         |\n| `fish_color_escape`          | character escapes like `\\n` and `\\x70`                                 |\n| `fish_color_autosuggestion`  | autosuggestions (the proposed rest of a command)                       |\n| `fish_color_cwd`             | the current working directory in the default prompt                    |\n| `fish_color_cwd_root`        | the current working directory in the default prompt for the root user  |\n| `fish_color_user`            | the username in the default prompt                                     |\n| `fish_color_host`            | the hostname in the default prompt                                     |\n| `fish_color_host_remote`     | the hostname in the default prompt for remote sessions (like ssh)      |\n| `fish_color_status`          | the last command’s nonzero exit code in the default prompt             |\n| `fish_color_cancel`          | the ‘^C’ indicator on a canceled command                               |\n| `fish_color_search_match`    | history search matches and selected pager items (background only)      |\n| `fish_color_history_current` | the current position in the history for commands like `dirh` and `cdh` |\n\nIf a variable isn’t set or is empty, fish usually tries `$fish_color_normal`, except for:\n\n- `$fish_color_keyword`, where it tries `$fish_color_command` first.\n- `$fish_color_option`, where it tries `$fish_color_param` first.\n- For `$fish_color_valid_path`, if that doesn’t have a color, but only modifiers, it adds those to the color that would otherwise be used, like `$fish_color_param`. But if valid paths have a color, it uses that and adds in modifiers from the other color.\n\n### Pager color variables\n\nfish will sometimes present a list of choices in a table, called the pager.\n\nExample: to set the background of each pager row, use:\n\n```\nset fish_pager_color_background --background=white\n```\n\nTo have black text on alternating white and gray backgrounds:\n\n```\nset fish_pager_color_prefix black\nset fish_pager_color_completion black\nset fish_pager_color_description black\nset fish_pager_color_background --background=white\nset fish_pager_color_secondary_background --background=brwhite\n```\n\nVariables affecting the pager colors:\n\n| Variable                                 | Meaning                                                     |\n|------------------------------------------|-------------------------------------------------------------|\n| `fish_pager_color_progress`              | the progress bar at the bottom left corner                  |\n| `fish_pager_color_background`            | the background color of a line                              |\n| `fish_pager_color_prefix`                | the prefix string, i.e. the string that is to be completed  |\n| `fish_pager_color_completion`            | the completion itself, i.e. the proposed rest of the string |\n| `fish_pager_color_description`           | the completion description                                  |\n| `fish_pager_color_selected_background`   | background of the selected completion                       |\n| `fish_pager_color_selected_prefix`       | prefix of the selected completion                           |\n| `fish_pager_color_selected_completion`   | suffix of the selected completion                           |\n| `fish_pager_color_selected_description`  | description of the selected completion                      |\n| `fish_pager_color_secondary_background`  | background of every second unselected completion            |\n| `fish_pager_color_secondary_prefix`      | prefix of every second unselected completion                |\n| `fish_pager_color_secondary_completion`  | suffix of every second unselected completion                |\n| `fish_pager_color_secondary_description` | description of every second unselected completion           |\n\nWhen the secondary or selected variables aren’t set or are empty, the normal variables are used, except for `$fish_pager_color_selected_background`, where the background of `$fish_color_search_match` is tried first.\n\n## Abbreviations\n\nTo avoid needless typing, a frequently-run command like `git checkout` can be abbreviated to `gco` using the [abbr](cmds/abbr) command.\n\n```\nabbr -a gco git checkout\n```\n\nAfter entering `gco` and pressing Space or Enter, a `gco` in command position will turn into `git checkout` in the command line. If you want to use a literal `gco` sometimes, use Control+Space [\\[1\\]](#id5).\n\nThis is a lot more powerful, for example you can make going up a number of directories easier with this:\n\n```\nfunction multicd\n    echo cd (string repeat -n (math (string length -- $argv[1]) - 1) ../)\nend\nabbr --add dotdot --regex '^\\.\\.+$' --function multicd\n```\n\nNow, `..` transforms to `cd ../`, while `...` turns into `cd ../../` and `....` expands to `cd ../../../`.\n\nThe advantage over aliases is that you can see the actual command before using it, add to it or change it, and the actual command will be stored in history.\n\n\\[[1](#id4)\\]\n\nAny binding that executes the `expand-abbr` or `execute` [bind function](cmds/bind) will expand abbreviations. By default Control+Space is bound to just inserting a space.\n\n## Programmable title\n\nWhen using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window. This can be done automatically in fish by defining the [fish_title](cmds/fish_title) function. The [fish_title](cmds/fish_title) function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message. The [status current-command](cmds/status) builtin will always return the name of the job to be put into the foreground (or `fish` if control is returning to the shell) when the [fish_prompt](cmds/fish_prompt) function is called. The first argument to fish_title will contain the most recently executed foreground command as a string.\n\nThe default fish title shows the hostname if connected via ssh, the currently running command (unless it is fish) and the current working directory. All of this is shortened to not make the tab too wide.\n\nExamples:\n\nTo show the last command and working directory in the title:\n\n```\nfunction fish_title\n    # `prompt_pwd` shortens the title. This helps prevent tabs from becoming very wide.\n    echo $argv[1] (prompt_pwd)\n    pwd\nend\n```\n\n## Programmable prompt\n\nWhen it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt. It does this by running the [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) functions.\n\nThe output of the former is displayed on the left and the latter’s output on the right side of the terminal. The output of [fish_mode_prompt](cmds/fish_mode_prompt) will be prepended on the left, though the default function only does this when in [vi-mode](#vi-mode).\n\n## Configurable greeting\n\nWhen it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):\n\n```\nset -U fish_greeting\n```\n\nor you can set it [globally](language#variables-scope) in [config.fish](language#configuration):\n\n```\nset -g fish_greeting 'Hey, stranger!'\n```\n\nor you can script it by changing the function:\n\n```\nfunction fish_greeting\n    random choice \"Hello!\" \"Hi\" \"G'day\" \"Howdy\"\nend\n```\n\nsave this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.\n\n## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 4. Escaping Characters
  summary: Some characters cannot be written directly on the command line
  belongs_to: 7. Combining pipes and redirections
  description: "## Escaping Characters\n\nSome characters cannot be written directly on the command line. For these characters, so-called escape sequences are provided. These are:\n\n- `\\a` represents the alert character.\n- `\\e` represents the escape character.\n- `\\f` represents the form feed character.\n- `\\n` represents a newline character.\n- `\\r` represents the carriage return character.\n- `\\t` represents the tab character.\n- `\\v` represents the vertical tab character.\n- `\\xHH` or `\\XHH`, where `HH` is a hexadecimal number, represents a byte of data with the specified value. For example, `\\x9` is the tab character. If you are using a multibyte encoding, this can be used to enter invalid strings. Typically fish is run with the ASCII or UTF-8 encoding, so anything up to `\\X7f` is an ASCII character.\n- `\\ooo`, where `ooo` is an octal number, represents the ASCII character with the specified value. For example, `\\011` is the tab character. The highest allowed value is `\\177`.\n- `\\uXXXX`, where `XXXX` is a hexadecimal number, represents the 16-bit Unicode character with the specified value. For example, `\\u9` is the tab character.\n- `\\UXXXXXXXX`, where `XXXXXXXX` is a hexadecimal number, represents the 32-bit Unicode character with the specified value. For example, `\\U9` is the tab character. The highest allowed value is U10FFFF.\n- `\\cX`, where `X` is a letter of the alphabet, represents the control sequence generated by pressing the control key and the specified letter. For example, `\\ci` is the tab character\n\nSome characters have special meaning to the shell. For example, an apostrophe `'` disables expansion (see [Quotes](#quotes)). To tell the shell to treat these characters literally, escape them with a backslash. For example, the command:\n\n```\necho \\'hello world\\'\n```\n\noutputs `'hello world'` (including the apostrophes), while the command:\n\n```\necho 'hello world'\n```\n\noutputs `hello world` (without the apostrophes). In the former case the shell treats the apostrophes as literal `'` characters, while in the latter case it treats them as special expansion modifiers.\n\nThe special characters and their escape sequences are:\n\n- `\\ ` (backslash space) escapes the space character. This keeps the shell from splitting arguments on the escaped space.\n- `\\$` escapes the dollar character.\n- `\\\\` escapes the backslash character.\n- `\\*` escapes the star character.\n- `\\?` escapes the question mark character (this is not necessary if the `qmark-noglob` [feature flag](#featureflags) is enabled).\n- `\\~` escapes the tilde character.\n- `\\#` escapes the hash character.\n- `\\(` escapes the left parenthesis character.\n- `\\)` escapes the right parenthesis character.\n- `\\{` escapes the left curly bracket character.\n- `\\}` escapes the right curly bracket character.\n- `\\[` escapes the left bracket character.\n- `\\]` escapes the right bracket character.\n- `\\<` escapes the less than character.\n- `\\>` escapes the more than character.\n- `\\&` escapes the ampersand character.\n- `\\|` escapes the vertical bar character.\n- `\\;` escapes the semicolon character.\n- `\\\"` escapes the quote character.\n- `\\'` escapes the apostrophe character.\n\nAs a special case, `\\` immediately followed by a literal new line is a “continuation” and tells fish to ignore the line break and resume input at the start of the next line (without introducing any whitespace or terminating a token).\n\n## Input/Output Redirection\n\nMost programs use three input/output (I/O) streams:\n\n- Standard input (stdin) for reading. Defaults to reading from the keyboard.\n- Standard output (stdout) for writing output. Defaults to writing to the screen.\n- Standard error (stderr) for writing errors and warnings. Defaults to writing to the screen.\n\nEach stream has a number called the file descriptor (FD): 0 for stdin, 1 for stdout, and 2 for stderr.\n\nThe destination of a stream can be changed using something called *redirection*. For example, `echo hello > output.txt`, redirects the standard output of the `echo` command to a text file.\n\n- To read standard input from a file, use `<SOURCE_FILE`.\n- To write standard output to a file, use `>DESTINATION`.\n- To write standard error to a file, use `2>DESTINATION`. [\\[1\\]](#id4)\n- To append standard output to a file, use `>>DESTINATION_FILE`.\n- To append standard error to a file, use `2>>DESTINATION_FILE`.\n- To not overwrite (“clobber”) an existing file, use `>?DESTINATION` or `2>?DESTINATION`. This is known as the “noclobber” redirection.\n\n`DESTINATION` can be one of the following:\n\n- A filename to write the output to. Often `>/dev/null` to silence output by writing it to the special “sinkhole” file.\n- An ampersand (`&`) followed by the number of another file descriptor like `&2` for standard error. The output will be written to the destination descriptor.\n- An ampersand followed by a minus sign (`&-`). The file descriptor will be closed. Note: This may cause the program to fail because its writes will be unsuccessful.\n\nAs a convenience, the redirection `&>` can be used to direct both stdout and stderr to the same destination. For example, `echo hello &> all_output.txt` redirects both stdout and stderr to the file `all_output.txt`. This is equivalent to `echo hello > all_output.txt 2>&1`.\n\nAny arbitrary file descriptor can be used in a redirection by prefixing the redirection with the FD number.\n\n- To redirect the input of descriptor N, use `N<DESTINATION`.\n- To redirect the output of descriptor N, use `N>DESTINATION`.\n- To append the output of descriptor N to a file, use `N>>DESTINATION_FILE`.\n\nFor example:\n\n```\n# Write `foo`'s standard error (file descriptor 2)\n# to a file called \"output.stderr\":\nfoo 2> output.stderr\n\n# if $num doesn't contain a number,\n# this test will be false and print an error,\n# so by ignoring the error we can be sure that we're dealing\n# with a number in the \"if\" block:\nif test \"$num\" -gt 2 2>/dev/null\n    # do things with $num as a number greater than 2\nelse\n    # do things if $num is <= 2 or not a number\nend\n\n# Save `make`s output in a file:\nmake &>/log\n\n# Redirections stack and can be used with blocks:\nbegin\n    echo stdout\n    echo stderr >&2 # <- this goes to stderr!\nend >/dev/null # ignore stdout, so this prints \"stderr\"\n```\n\nIt is an error to redirect a builtin, function, or block to a file descriptor above 2. However this is supported for external commands.\n\n\\[[1](#id3)\\]\n\nPrevious versions of fish also allowed specifying this as `^DESTINATION`, but that made another character special so it was deprecated and removed. See [feature flags](#featureflags).\n\n## Piping\n\nAnother way to redirect streams is a *pipe*. A pipe connects streams with each other. Usually the standard output of one command is connected with the standard input of another. This is done by separating commands with the pipe character `|`. For example:\n\n```\ncat foo.txt | head\n```\n\nThe command `cat foo.txt` sends the contents of `foo.txt` to stdout. This output is provided as input for the `head` program, which prints the first 10 lines of its input.\n\nIt is possible to pipe a different output file descriptor by prepending its FD number and the output redirect symbol to the pipe. For example:\n\n```\nmake fish 2>| less\n```\n\nwill attempt to build `fish`, and any errors will be shown using the `less` pager. [\\[2\\]](#id6)\n\nAs a convenience, the pipe `&|` redirects both stdout and stderr to the same process. This is different from bash, which uses `|&`.\n\n\\[[2](#id5)\\]\n\nA “pager” here is a program that takes output and “paginates” it. `less` doesn’t just do pages, it allows arbitrary scrolling (even back!).\n\n## Combining pipes and redirections\n\nIt is possible to use multiple redirections and a pipe at the same time. In that case, they are read in this order:\n\n1.  First the pipe is set up.\n2.  Then the redirections are evaluated from left-to-right.\n\nThis is important when any redirections reference other file descriptors with the `&N` syntax. When you say `>&2`, that will redirect stdout to where stderr is pointing to *at that time*.\n\nConsider this helper function:\n\n```\n# Just make a function that prints something to stdout and stderr\nfunction print\n    echo out\n    echo err >&2\nend\n```\n\nNow let’s see a few cases:\n\n```\n# Redirect both stderr and stdout to less\n# (can also be spelt as `&|`)\nprint 2>&1 | less\n\n# Show the \"out\" on stderr, silence the \"err\"\nprint >&2 2>/dev/null\n\n# Silence both\nprint >/dev/null 2>&1\n```\n\n## Job control\n\nWhen you start a job in fish, fish itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an `&` (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.\n\nExample:\n\n```\nemacs &\n```\n\nwill start the emacs text editor in the background. [fg](cmds/fg) can be used to bring it into the foreground again when needed.\n\nMost programs allow you to suspend the program’s execution and return control to fish by pressing Control+Z (also referred to as `^Z`). Once back at the fish commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the [fg](cmds/fg) (foreground) command.\n\nIf you instead want to put a suspended job into the background, use the [bg](cmds/bg) command.\n\nTo get a listing of all currently started jobs, use the [jobs](cmds/jobs) command. These listed jobs can be removed with the [disown](cmds/disown) command.\n\nAt the moment, functions cannot be started in the background. Functions that are stopped and then restarted in the background using the [bg](cmds/bg) command will not execute correctly.\n\nIf the `&` character is followed by a non-separating character, it is not interpreted as background operator. Separating characters are whitespace and the characters `;<>&|`.\n\n## Functions\n\nFunctions are programs written in the fish syntax. They group together various commands and their arguments using a single name.\n\nFor example, here’s a simple function to list directories:\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nThe first line tells fish to define a function by the name of `ll`, so it can be used by simply writing `ll` on the commandline. The second line tells fish that the command `ls -l $argv` should be called when `ll` is invoked. [\\$argv](#variables-argv) is a [list variable](#variables-lists), which always contains all arguments sent to the function. In the example above, these are simply passed on to the `ls` command. The `end` on the third line ends the definition.\n\nCalling this as `ll /tmp/` will end up running `ls -l /tmp/`, which will list the contents of /tmp.\n\nThis is a kind of function known as an [alias](#syntax-aliases).\n\nFish’s prompt is also defined in a function, called [fish_prompt](cmds/fish_prompt). It is run when the prompt is about to be displayed and its output forms the prompt:\n\n```\nfunction fish_prompt\n    # A simple prompt. Displays the current directory\n    # (which fish stores in the $PWD variable)\n    # and then a user symbol - a '►' for a normal user and a '#' for root.\n    set -l user_char '►'\n    if fish_is_root_user\n        set user_char '#'\n    end\n\n    echo (set_color yellow)$PWD (set_color purple)$user_char\nend\n```\n\nTo edit a function, you can use [funced](cmds/funced), and to save a function [funcsave](cmds/funcsave). This will store it in a function file that fish will [autoload](#syntax-function-autoloading) when needed.\n\nThe [functions](cmds/functions) builtin can show a function’s current definition (and [type](cmds/type) will also do if given a function).\n\nFor more information on functions, see the documentation for the [function](cmds/function) builtin.\n\n### Defining aliases\n\nOne of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the `ls` command to display colors. The switch for turning on colors on GNU systems is `--color=auto`. An alias around `ls` might look like this:\n\n```\nfunction ls\n    command ls --color=auto $argv\nend\n```\n\nThere are a few important things that need to be noted about aliases:\n\n- Always take care to add the [\\$argv](#variables-argv) variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.\n- If the alias has the same name as the aliased command, you need to prefix the call to the program with `command` to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).\n\nTo easily create a function of this form, you can use the [alias](cmds/alias) command. Unlike other shells, this just makes functions - fish has no separate concept of an “alias”, we just use the word for a simple wrapping function like this. [alias](cmds/alias) immediately creates a function. Consider using `alias --save` or [funcsave](cmds/funcsave) to save the created function into an autoload file instead of recreating the alias each time.\n\nFor an alternative, try [abbreviations](interactive#abbreviations). These are words that are expanded while you type, instead of being actual functions inside the shell.\n\n### Autoloading functions\n\nFunctions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:\n\n- An autoloaded function becomes available automatically to all running shells.\n- If the function definition is changed, all running shells will automatically reload the altered version, after a while.\n- Startup time and memory usage is improved, etc.\n\nWhen fish needs to load a function, it searches through any directories in the [list variable](#variables-lists) `$fish_function_path` for a file with a name consisting of the name of the function plus the suffix `.fish` and loads the first it finds.\n\nFor example if you try to execute something called `banana`, fish will go through all directories in \\$fish_function_path looking for a file called `banana.fish` and load the first one it finds.\n\nBy default `$fish_function_path` contains the following:\n\n- A directory for users to keep their own functions, usually `~/.config/fish/functions` (controlled by the `XDG_CONFIG_HOME` environment variable).\n- A directory for functions for all users on the system, usually `/etc/fish/functions` (really `$__fish_sysconfdir/functions`).\n- Directories for other software to put their own functions. These are in the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable) and in the `XDG_DATA_DIRS` environment variable, in a subdirectory called `fish/vendor_functions.d`. The default value for `XDG_DATA_DIRS` is usually `/usr/share/fish/vendor_functions.d` and `/usr/local/share/fish/vendor_functions.d`.\n- The functions shipped with fish, usually installed in `/usr/share/fish/functions` (really `$__fish_data_dir/functions`).\n\nIf you are unsure, your functions probably belong in `~/.config/fish/functions`.\n\nAs we’ve explained, autoload files are loaded *by name*, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.\n\nAutoloading also won’t work for [event handlers](#event), since fish cannot know that a function is supposed to be executed when an event occurs when it hasn’t yet loaded the function. See the [event handlers](#event) section for more information.\n\nIf a file of the right name doesn’t define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in \\$fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.\n\nIf you are developing another program and want to install fish functions for it, install them to the “vendor” functions directory. As this path varies from system to system, you can use `pkgconfig` to discover it with the output of `pkg-config --variable functionsdir fish`. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.\n\n## Comments\n\nAnything after a `#` until the end of the line is a comment. That means it’s purely for the reader’s benefit, fish ignores it.\n\nThis is useful to explain what and why you are doing something:\n\n```\nfunction ls\n    # The function is called ls,\n    # so we have to explicitly call `command ls` to avoid calling ourselves.\n    command ls --color=auto $argv\nend\n```\n\nThere are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a `#`.\n\nComments can also appear after a line like so:\n\n```\nset -gx EDITOR emacs # I don't like vim.\n```\n\n## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 4. Resources
  summary: If you have an improvement for fish, you can submit it via the GitHub page
  description: "## Resources\n\n- The [GitHub page](https://github.com/fish-shell/fish-shell/)\n- The official [Gitter channel](https://gitter.im/fish-shell/fish-shell)\n- The official mailing list at [fish-users@lists.sourceforge.net](https://lists.sourceforge.net/lists/listinfo/fish-users)\n\nIf you have an improvement for fish, you can submit it via the GitHub page.\n\n## Other help pages\n\n- [Introduction](#)\n- [Frequently asked questions](faq)\n- [Interactive use](interactive)\n- [The fish language](language)\n- [Commands](commands)\n- [Fish for bash users](fish_for_bash_users)\n- [Tutorial](tutorial)\n- [Writing your own completions](completions)\n- [Writing your own prompt](prompt)\n- [Design](https://fishshell.com/docs/3.7/design.html)\n- [Release notes](https://fishshell.com/docs/3.7/relnotes.html)\n- [License](https://fishshell.com/docs/3.7/license.html)\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/index.html](https://fishshell.com/docs/3.7/index.html)"
- name: 4. Running Commands
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 4. Syntax highlighting
  summary: Fish interprets the command line as it is typed and uses syntax highlighting to provide feedback
  belongs_to: 1. Help
  description: "## Syntax highlighting\n\nFish interprets the command line as it is typed and uses syntax highlighting to provide feedback. The most important feedback is the detection of potential errors. By default, errors are marked red.\n\nDetected errors include:\n\n- Non-existing commands.\n- Reading from or appending to a non-existing file.\n- Incorrect use of output redirects\n- Mismatched parenthesis\n\nTo customize the syntax highlighting, you can set the environment variables listed in the [Variables for changing highlighting colors](#variables-color) section.\n\nFish also provides pre-made color themes you can pick with [fish_config](cmds/fish_config). Running just `fish_config` opens a browser interface, or you can use `fish_config theme` in the terminal.\n\nFor example, to disable nearly all coloring:\n\n```\nfish_config theme choose none\n```\n\nOr, to see all themes, right in your terminal:\n\n```\nfish_config theme show\n```\n\n### Syntax highlighting variables\n\nThe colors used by fish for syntax highlighting can be configured by changing the values of various variables. The value of these variables can be one of the colors accepted by the [set_color](cmds/set_color) command. The modifier switches accepted by `set_color` like `--bold`, `--dim`, `--italics`, `--reverse` and `--underline` are also accepted.\n\nExample: to make errors highlighted and red, use:\n\n```\nset fish_color_error red --bold\n```\n\nThe following variables are available to change the highlighting colors in fish:\n\n| Variable                     | Meaning                                                                |\n|------------------------------|------------------------------------------------------------------------|\n| `fish_color_normal`          | default color                                                          |\n| `fish_color_command`         | commands like echo                                                     |\n| `fish_color_keyword`         | keywords like if - this falls back on the command color if unset       |\n| `fish_color_quote`           | quoted text like `\"abc\"`                                               |\n| `fish_color_redirection`     | IO redirections like \\>/dev/null                                       |\n| `fish_color_end`             | process separators like `;` and `&`                                    |\n| `fish_color_error`           | syntax errors                                                          |\n| `fish_color_param`           | ordinary command parameters                                            |\n| `fish_color_valid_path`      | parameters that are filenames (if the file exists)                     |\n| `fish_color_option`          | options starting with “-”, up to the first “--” parameter              |\n| `fish_color_comment`         | comments like ‘# important’                                            |\n| `fish_color_selection`       | selected text in vi visual mode                                        |\n| `fish_color_operator`        | parameter expansion operators like `*` and `~`                         |\n| `fish_color_escape`          | character escapes like `\\n` and `\\x70`                                 |\n| `fish_color_autosuggestion`  | autosuggestions (the proposed rest of a command)                       |\n| `fish_color_cwd`             | the current working directory in the default prompt                    |\n| `fish_color_cwd_root`        | the current working directory in the default prompt for the root user  |\n| `fish_color_user`            | the username in the default prompt                                     |\n| `fish_color_host`            | the hostname in the default prompt                                     |\n| `fish_color_host_remote`     | the hostname in the default prompt for remote sessions (like ssh)      |\n| `fish_color_status`          | the last command’s nonzero exit code in the default prompt             |\n| `fish_color_cancel`          | the ‘^C’ indicator on a canceled command                               |\n| `fish_color_search_match`    | history search matches and selected pager items (background only)      |\n| `fish_color_history_current` | the current position in the history for commands like `dirh` and `cdh` |\n\nIf a variable isn’t set or is empty, fish usually tries `$fish_color_normal`, except for:\n\n- `$fish_color_keyword`, where it tries `$fish_color_command` first.\n- `$fish_color_option`, where it tries `$fish_color_param` first.\n- For `$fish_color_valid_path`, if that doesn’t have a color, but only modifiers, it adds those to the color that would otherwise be used, like `$fish_color_param`. But if valid paths have a color, it uses that and adds in modifiers from the other color.\n\n### Pager color variables\n\nfish will sometimes present a list of choices in a table, called the pager.\n\nExample: to set the background of each pager row, use:\n\n```\nset fish_pager_color_background --background=white\n```\n\nTo have black text on alternating white and gray backgrounds:\n\n```\nset fish_pager_color_prefix black\nset fish_pager_color_completion black\nset fish_pager_color_description black\nset fish_pager_color_background --background=white\nset fish_pager_color_secondary_background --background=brwhite\n```\n\nVariables affecting the pager colors:\n\n| Variable                                 | Meaning                                                     |\n|------------------------------------------|-------------------------------------------------------------|\n| `fish_pager_color_progress`              | the progress bar at the bottom left corner                  |\n| `fish_pager_color_background`            | the background color of a line                              |\n| `fish_pager_color_prefix`                | the prefix string, i.e. the string that is to be completed  |\n| `fish_pager_color_completion`            | the completion itself, i.e. the proposed rest of the string |\n| `fish_pager_color_description`           | the completion description                                  |\n| `fish_pager_color_selected_background`   | background of the selected completion                       |\n| `fish_pager_color_selected_prefix`       | prefix of the selected completion                           |\n| `fish_pager_color_selected_completion`   | suffix of the selected completion                           |\n| `fish_pager_color_selected_description`  | description of the selected completion                      |\n| `fish_pager_color_secondary_background`  | background of every second unselected completion            |\n| `fish_pager_color_secondary_prefix`      | prefix of every second unselected completion                |\n| `fish_pager_color_secondary_completion`  | suffix of every second unselected completion                |\n| `fish_pager_color_secondary_description` | description of every second unselected completion           |\n\nWhen the secondary or selected variables aren’t set or are empty, the normal variables are used, except for `$fish_pager_color_selected_background`, where the background of `$fish_color_search_match` is tried first.\n\n## Abbreviations\n\nTo avoid needless typing, a frequently-run command like `git checkout` can be abbreviated to `gco` using the [abbr](cmds/abbr) command.\n\n```\nabbr -a gco git checkout\n```\n\nAfter entering `gco` and pressing Space or Enter, a `gco` in command position will turn into `git checkout` in the command line. If you want to use a literal `gco` sometimes, use Control+Space [\\[1\\]](#id5).\n\nThis is a lot more powerful, for example you can make going up a number of directories easier with this:\n\n```\nfunction multicd\n    echo cd (string repeat -n (math (string length -- $argv[1]) - 1) ../)\nend\nabbr --add dotdot --regex '^\\.\\.+$' --function multicd\n```\n\nNow, `..` transforms to `cd ../`, while `...` turns into `cd ../../` and `....` expands to `cd ../../../`.\n\nThe advantage over aliases is that you can see the actual command before using it, add to it or change it, and the actual command will be stored in history.\n\n\\[[1](#id4)\\]\n\nAny binding that executes the `expand-abbr` or `execute` [bind function](cmds/bind) will expand abbreviations. By default Control+Space is bound to just inserting a space.\n\n## Programmable title\n\nWhen using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window. This can be done automatically in fish by defining the [fish_title](cmds/fish_title) function. The [fish_title](cmds/fish_title) function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message. The [status current-command](cmds/status) builtin will always return the name of the job to be put into the foreground (or `fish` if control is returning to the shell) when the [fish_prompt](cmds/fish_prompt) function is called. The first argument to fish_title will contain the most recently executed foreground command as a string.\n\nThe default fish title shows the hostname if connected via ssh, the currently running command (unless it is fish) and the current working directory. All of this is shortened to not make the tab too wide.\n\nExamples:\n\nTo show the last command and working directory in the title:\n\n```\nfunction fish_title\n    # `prompt_pwd` shortens the title. This helps prevent tabs from becoming very wide.\n    echo $argv[1] (prompt_pwd)\n    pwd\nend\n```\n\n## Programmable prompt\n\nWhen it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt. It does this by running the [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) functions.\n\nThe output of the former is displayed on the left and the latter’s output on the right side of the terminal. The output of [fish_mode_prompt](cmds/fish_mode_prompt) will be prepended on the left, though the default function only does this when in [vi-mode](#vi-mode).\n\n## Configurable greeting\n\nWhen it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):\n\n```\nset -U fish_greeting\n```\n\nor you can set it [globally](language#variables-scope) in [config.fish](language#configuration):\n\n```\nset -g fish_greeting 'Hey, stranger!'\n```\n\nor you can script it by changing the function:\n\n```\nfunction fish_greeting\n    random choice \"Hello!\" \"Hi\" \"G'day\" \"Howdy\"\nend\n```\n\nsave this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.\n\n## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 5. Abbreviations
  summary: To avoid needless typing, a frequently-run command like git checkout can be abbreviated to gco using the abbr command
  belongs_to: 1. Help
  description: "## Abbreviations\n\nTo avoid needless typing, a frequently-run command like `git checkout` can be abbreviated to `gco` using the [abbr](cmds/abbr) command.\n\n```\nabbr -a gco git checkout\n```\n\nAfter entering `gco` and pressing Space or Enter, a `gco` in command position will turn into `git checkout` in the command line. If you want to use a literal `gco` sometimes, use Control+Space [\\[1\\]](#id5).\n\nThis is a lot more powerful, for example you can make going up a number of directories easier with this:\n\n```\nfunction multicd\n    echo cd (string repeat -n (math (string length -- $argv[1]) - 1) ../)\nend\nabbr --add dotdot --regex '^\\.\\.+$' --function multicd\n```\n\nNow, `..` transforms to `cd ../`, while `...` turns into `cd ../../` and `....` expands to `cd ../../../`.\n\nThe advantage over aliases is that you can see the actual command before using it, add to it or change it, and the actual command will be stored in history.\n\n\\[[1](#id4)\\]\n\nAny binding that executes the `expand-abbr` or `execute` [bind function](cmds/bind) will expand abbreviations. By default Control+Space is bound to just inserting a space.\n\n## Programmable title\n\nWhen using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window. This can be done automatically in fish by defining the [fish_title](cmds/fish_title) function. The [fish_title](cmds/fish_title) function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message. The [status current-command](cmds/status) builtin will always return the name of the job to be put into the foreground (or `fish` if control is returning to the shell) when the [fish_prompt](cmds/fish_prompt) function is called. The first argument to fish_title will contain the most recently executed foreground command as a string.\n\nThe default fish title shows the hostname if connected via ssh, the currently running command (unless it is fish) and the current working directory. All of this is shortened to not make the tab too wide.\n\nExamples:\n\nTo show the last command and working directory in the title:\n\n```\nfunction fish_title\n    # `prompt_pwd` shortens the title. This helps prevent tabs from becoming very wide.\n    echo $argv[1] (prompt_pwd)\n    pwd\nend\n```\n\n## Programmable prompt\n\nWhen it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt. It does this by running the [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) functions.\n\nThe output of the former is displayed on the left and the latter’s output on the right side of the terminal. The output of [fish_mode_prompt](cmds/fish_mode_prompt) will be prepended on the left, though the default function only does this when in [vi-mode](#vi-mode).\n\n## Configurable greeting\n\nWhen it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):\n\n```\nset -U fish_greeting\n```\n\nor you can set it [globally](language#variables-scope) in [config.fish](language#configuration):\n\n```\nset -g fish_greeting 'Hey, stranger!'\n```\n\nor you can script it by changing the function:\n\n```\nfunction fish_greeting\n    random choice \"Hello!\" \"Hi\" \"G'day\" \"Howdy\"\nend\n```\n\nsave this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.\n\n## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 5. Getting Help
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 5. Input/Output Redirection
  summary: 'Most programs use three input/output (I/O) streams:'
  belongs_to: 7. Combining pipes and redirections
  description: "## Input/Output Redirection\n\nMost programs use three input/output (I/O) streams:\n\n- Standard input (stdin) for reading. Defaults to reading from the keyboard.\n- Standard output (stdout) for writing output. Defaults to writing to the screen.\n- Standard error (stderr) for writing errors and warnings. Defaults to writing to the screen.\n\nEach stream has a number called the file descriptor (FD): 0 for stdin, 1 for stdout, and 2 for stderr.\n\nThe destination of a stream can be changed using something called *redirection*. For example, `echo hello > output.txt`, redirects the standard output of the `echo` command to a text file.\n\n- To read standard input from a file, use `<SOURCE_FILE`.\n- To write standard output to a file, use `>DESTINATION`.\n- To write standard error to a file, use `2>DESTINATION`. [\\[1\\]](#id4)\n- To append standard output to a file, use `>>DESTINATION_FILE`.\n- To append standard error to a file, use `2>>DESTINATION_FILE`.\n- To not overwrite (“clobber”) an existing file, use `>?DESTINATION` or `2>?DESTINATION`. This is known as the “noclobber” redirection.\n\n`DESTINATION` can be one of the following:\n\n- A filename to write the output to. Often `>/dev/null` to silence output by writing it to the special “sinkhole” file.\n- An ampersand (`&`) followed by the number of another file descriptor like `&2` for standard error. The output will be written to the destination descriptor.\n- An ampersand followed by a minus sign (`&-`). The file descriptor will be closed. Note: This may cause the program to fail because its writes will be unsuccessful.\n\nAs a convenience, the redirection `&>` can be used to direct both stdout and stderr to the same destination. For example, `echo hello &> all_output.txt` redirects both stdout and stderr to the file `all_output.txt`. This is equivalent to `echo hello > all_output.txt 2>&1`.\n\nAny arbitrary file descriptor can be used in a redirection by prefixing the redirection with the FD number.\n\n- To redirect the input of descriptor N, use `N<DESTINATION`.\n- To redirect the output of descriptor N, use `N>DESTINATION`.\n- To append the output of descriptor N to a file, use `N>>DESTINATION_FILE`.\n\nFor example:\n\n```\n# Write `foo`'s standard error (file descriptor 2)\n# to a file called \"output.stderr\":\nfoo 2> output.stderr\n\n# if $num doesn't contain a number,\n# this test will be false and print an error,\n# so by ignoring the error we can be sure that we're dealing\n# with a number in the \"if\" block:\nif test \"$num\" -gt 2 2>/dev/null\n    # do things with $num as a number greater than 2\nelse\n    # do things if $num is <= 2 or not a number\nend\n\n# Save `make`s output in a file:\nmake &>/log\n\n# Redirections stack and can be used with blocks:\nbegin\n    echo stdout\n    echo stderr >&2 # <- this goes to stderr!\nend >/dev/null # ignore stdout, so this prints \"stderr\"\n```\n\nIt is an error to redirect a builtin, function, or block to a file descriptor above 2. However this is supported for external commands.\n\n\\[[1](#id3)\\]\n\nPrevious versions of fish also allowed specifying this as `^DESTINATION`, but that made another character special so it was deprecated and removed. See [feature flags](#featureflags).\n\n## Piping\n\nAnother way to redirect streams is a *pipe*. A pipe connects streams with each other. Usually the standard output of one command is connected with the standard input of another. This is done by separating commands with the pipe character `|`. For example:\n\n```\ncat foo.txt | head\n```\n\nThe command `cat foo.txt` sends the contents of `foo.txt` to stdout. This output is provided as input for the `head` program, which prints the first 10 lines of its input.\n\nIt is possible to pipe a different output file descriptor by prepending its FD number and the output redirect symbol to the pipe. For example:\n\n```\nmake fish 2>| less\n```\n\nwill attempt to build `fish`, and any errors will be shown using the `less` pager. [\\[2\\]](#id6)\n\nAs a convenience, the pipe `&|` redirects both stdout and stderr to the same process. This is different from bash, which uses `|&`.\n\n\\[[2](#id5)\\]\n\nA “pager” here is a program that takes output and “paginates” it. `less` doesn’t just do pages, it allows arbitrary scrolling (even back!).\n\n## Combining pipes and redirections\n\nIt is possible to use multiple redirections and a pipe at the same time. In that case, they are read in this order:\n\n1.  First the pipe is set up.\n2.  Then the redirections are evaluated from left-to-right.\n\nThis is important when any redirections reference other file descriptors with the `&N` syntax. When you say `>&2`, that will redirect stdout to where stderr is pointing to *at that time*.\n\nConsider this helper function:\n\n```\n# Just make a function that prints something to stdout and stderr\nfunction print\n    echo out\n    echo err >&2\nend\n```\n\nNow let’s see a few cases:\n\n```\n# Redirect both stderr and stdout to less\n# (can also be spelt as `&|`)\nprint 2>&1 | less\n\n# Show the \"out\" on stderr, silence the \"err\"\nprint >&2 2>/dev/null\n\n# Silence both\nprint >/dev/null 2>&1\n```\n\n## Job control\n\nWhen you start a job in fish, fish itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an `&` (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.\n\nExample:\n\n```\nemacs &\n```\n\nwill start the emacs text editor in the background. [fg](cmds/fg) can be used to bring it into the foreground again when needed.\n\nMost programs allow you to suspend the program’s execution and return control to fish by pressing Control+Z (also referred to as `^Z`). Once back at the fish commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the [fg](cmds/fg) (foreground) command.\n\nIf you instead want to put a suspended job into the background, use the [bg](cmds/bg) command.\n\nTo get a listing of all currently started jobs, use the [jobs](cmds/jobs) command. These listed jobs can be removed with the [disown](cmds/disown) command.\n\nAt the moment, functions cannot be started in the background. Functions that are stopped and then restarted in the background using the [bg](cmds/bg) command will not execute correctly.\n\nIf the `&` character is followed by a non-separating character, it is not interpreted as background operator. Separating characters are whitespace and the characters `;<>&|`.\n\n## Functions\n\nFunctions are programs written in the fish syntax. They group together various commands and their arguments using a single name.\n\nFor example, here’s a simple function to list directories:\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nThe first line tells fish to define a function by the name of `ll`, so it can be used by simply writing `ll` on the commandline. The second line tells fish that the command `ls -l $argv` should be called when `ll` is invoked. [\\$argv](#variables-argv) is a [list variable](#variables-lists), which always contains all arguments sent to the function. In the example above, these are simply passed on to the `ls` command. The `end` on the third line ends the definition.\n\nCalling this as `ll /tmp/` will end up running `ls -l /tmp/`, which will list the contents of /tmp.\n\nThis is a kind of function known as an [alias](#syntax-aliases).\n\nFish’s prompt is also defined in a function, called [fish_prompt](cmds/fish_prompt). It is run when the prompt is about to be displayed and its output forms the prompt:\n\n```\nfunction fish_prompt\n    # A simple prompt. Displays the current directory\n    # (which fish stores in the $PWD variable)\n    # and then a user symbol - a '►' for a normal user and a '#' for root.\n    set -l user_char '►'\n    if fish_is_root_user\n        set user_char '#'\n    end\n\n    echo (set_color yellow)$PWD (set_color purple)$user_char\nend\n```\n\nTo edit a function, you can use [funced](cmds/funced), and to save a function [funcsave](cmds/funcsave). This will store it in a function file that fish will [autoload](#syntax-function-autoloading) when needed.\n\nThe [functions](cmds/functions) builtin can show a function’s current definition (and [type](cmds/type) will also do if given a function).\n\nFor more information on functions, see the documentation for the [function](cmds/function) builtin.\n\n### Defining aliases\n\nOne of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the `ls` command to display colors. The switch for turning on colors on GNU systems is `--color=auto`. An alias around `ls` might look like this:\n\n```\nfunction ls\n    command ls --color=auto $argv\nend\n```\n\nThere are a few important things that need to be noted about aliases:\n\n- Always take care to add the [\\$argv](#variables-argv) variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.\n- If the alias has the same name as the aliased command, you need to prefix the call to the program with `command` to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).\n\nTo easily create a function of this form, you can use the [alias](cmds/alias) command. Unlike other shells, this just makes functions - fish has no separate concept of an “alias”, we just use the word for a simple wrapping function like this. [alias](cmds/alias) immediately creates a function. Consider using `alias --save` or [funcsave](cmds/funcsave) to save the created function into an autoload file instead of recreating the alias each time.\n\nFor an alternative, try [abbreviations](interactive#abbreviations). These are words that are expanded while you type, instead of being actual functions inside the shell.\n\n### Autoloading functions\n\nFunctions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:\n\n- An autoloaded function becomes available automatically to all running shells.\n- If the function definition is changed, all running shells will automatically reload the altered version, after a while.\n- Startup time and memory usage is improved, etc.\n\nWhen fish needs to load a function, it searches through any directories in the [list variable](#variables-lists) `$fish_function_path` for a file with a name consisting of the name of the function plus the suffix `.fish` and loads the first it finds.\n\nFor example if you try to execute something called `banana`, fish will go through all directories in \\$fish_function_path looking for a file called `banana.fish` and load the first one it finds.\n\nBy default `$fish_function_path` contains the following:\n\n- A directory for users to keep their own functions, usually `~/.config/fish/functions` (controlled by the `XDG_CONFIG_HOME` environment variable).\n- A directory for functions for all users on the system, usually `/etc/fish/functions` (really `$__fish_sysconfdir/functions`).\n- Directories for other software to put their own functions. These are in the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable) and in the `XDG_DATA_DIRS` environment variable, in a subdirectory called `fish/vendor_functions.d`. The default value for `XDG_DATA_DIRS` is usually `/usr/share/fish/vendor_functions.d` and `/usr/local/share/fish/vendor_functions.d`.\n- The functions shipped with fish, usually installed in `/usr/share/fish/functions` (really `$__fish_data_dir/functions`).\n\nIf you are unsure, your functions probably belong in `~/.config/fish/functions`.\n\nAs we’ve explained, autoload files are loaded *by name*, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.\n\nAutoloading also won’t work for [event handlers](#event), since fish cannot know that a function is supposed to be executed when an event occurs when it hasn’t yet loaded the function. See the [event handlers](#event) section for more information.\n\nIf a file of the right name doesn’t define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in \\$fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.\n\nIf you are developing another program and want to install fish functions for it, install them to the “vendor” functions directory. As this path varies from system to system, you can use `pkgconfig` to discover it with the output of `pkg-config --variable functionsdir fish`. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.\n\n## Comments\n\nAnything after a `#` until the end of the line is a comment. That means it’s purely for the reader’s benefit, fish ignores it.\n\nThis is useful to explain what and why you are doing something:\n\n```\nfunction ls\n    # The function is called ls,\n    # so we have to explicitly call `command ls` to avoid calling ourselves.\n    command ls --color=auto $argv\nend\n```\n\nThere are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a `#`.\n\nComments can also appear after a line like so:\n\n```\nset -gx EDITOR emacs # I don't like vim.\n```\n\n## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 5. Other help pages
  summary: ''
  description: "## Other help pages\n\n- [Introduction](#)\n- [Frequently asked questions](faq)\n- [Interactive use](interactive)\n- [The fish language](language)\n- [Commands](commands)\n- [Fish for bash users](fish_for_bash_users)\n- [Tutorial](tutorial)\n- [Writing your own completions](completions)\n- [Writing your own prompt](prompt)\n- [Design](https://fishshell.com/docs/3.7/design.html)\n- [Release notes](https://fishshell.com/docs/3.7/relnotes.html)\n- [License](https://fishshell.com/docs/3.7/license.html)\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/index.html](https://fishshell.com/docs/3.7/index.html)"
- name: 6. Piping
  summary: Another way to redirect streams is a pipe
  belongs_to: 7. Combining pipes and redirections
  description: "## Piping\n\nAnother way to redirect streams is a *pipe*. A pipe connects streams with each other. Usually the standard output of one command is connected with the standard input of another. This is done by separating commands with the pipe character `|`. For example:\n\n```\ncat foo.txt | head\n```\n\nThe command `cat foo.txt` sends the contents of `foo.txt` to stdout. This output is provided as input for the `head` program, which prints the first 10 lines of its input.\n\nIt is possible to pipe a different output file descriptor by prepending its FD number and the output redirect symbol to the pipe. For example:\n\n```\nmake fish 2>| less\n```\n\nwill attempt to build `fish`, and any errors will be shown using the `less` pager. [\\[2\\]](#id6)\n\nAs a convenience, the pipe `&|` redirects both stdout and stderr to the same process. This is different from bash, which uses `|&`.\n\n\\[[2](#id5)\\]\n\nA “pager” here is a program that takes output and “paginates” it. `less` doesn’t just do pages, it allows arbitrary scrolling (even back!).\n\n## Combining pipes and redirections\n\nIt is possible to use multiple redirections and a pipe at the same time. In that case, they are read in this order:\n\n1.  First the pipe is set up.\n2.  Then the redirections are evaluated from left-to-right.\n\nThis is important when any redirections reference other file descriptors with the `&N` syntax. When you say `>&2`, that will redirect stdout to where stderr is pointing to *at that time*.\n\nConsider this helper function:\n\n```\n# Just make a function that prints something to stdout and stderr\nfunction print\n    echo out\n    echo err >&2\nend\n```\n\nNow let’s see a few cases:\n\n```\n# Redirect both stderr and stdout to less\n# (can also be spelt as `&|`)\nprint 2>&1 | less\n\n# Show the \"out\" on stderr, silence the \"err\"\nprint >&2 2>/dev/null\n\n# Silence both\nprint >/dev/null 2>&1\n```\n\n## Job control\n\nWhen you start a job in fish, fish itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an `&` (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.\n\nExample:\n\n```\nemacs &\n```\n\nwill start the emacs text editor in the background. [fg](cmds/fg) can be used to bring it into the foreground again when needed.\n\nMost programs allow you to suspend the program’s execution and return control to fish by pressing Control+Z (also referred to as `^Z`). Once back at the fish commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the [fg](cmds/fg) (foreground) command.\n\nIf you instead want to put a suspended job into the background, use the [bg](cmds/bg) command.\n\nTo get a listing of all currently started jobs, use the [jobs](cmds/jobs) command. These listed jobs can be removed with the [disown](cmds/disown) command.\n\nAt the moment, functions cannot be started in the background. Functions that are stopped and then restarted in the background using the [bg](cmds/bg) command will not execute correctly.\n\nIf the `&` character is followed by a non-separating character, it is not interpreted as background operator. Separating characters are whitespace and the characters `;<>&|`.\n\n## Functions\n\nFunctions are programs written in the fish syntax. They group together various commands and their arguments using a single name.\n\nFor example, here’s a simple function to list directories:\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nThe first line tells fish to define a function by the name of `ll`, so it can be used by simply writing `ll` on the commandline. The second line tells fish that the command `ls -l $argv` should be called when `ll` is invoked. [\\$argv](#variables-argv) is a [list variable](#variables-lists), which always contains all arguments sent to the function. In the example above, these are simply passed on to the `ls` command. The `end` on the third line ends the definition.\n\nCalling this as `ll /tmp/` will end up running `ls -l /tmp/`, which will list the contents of /tmp.\n\nThis is a kind of function known as an [alias](#syntax-aliases).\n\nFish’s prompt is also defined in a function, called [fish_prompt](cmds/fish_prompt). It is run when the prompt is about to be displayed and its output forms the prompt:\n\n```\nfunction fish_prompt\n    # A simple prompt. Displays the current directory\n    # (which fish stores in the $PWD variable)\n    # and then a user symbol - a '►' for a normal user and a '#' for root.\n    set -l user_char '►'\n    if fish_is_root_user\n        set user_char '#'\n    end\n\n    echo (set_color yellow)$PWD (set_color purple)$user_char\nend\n```\n\nTo edit a function, you can use [funced](cmds/funced), and to save a function [funcsave](cmds/funcsave). This will store it in a function file that fish will [autoload](#syntax-function-autoloading) when needed.\n\nThe [functions](cmds/functions) builtin can show a function’s current definition (and [type](cmds/type) will also do if given a function).\n\nFor more information on functions, see the documentation for the [function](cmds/function) builtin.\n\n### Defining aliases\n\nOne of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the `ls` command to display colors. The switch for turning on colors on GNU systems is `--color=auto`. An alias around `ls` might look like this:\n\n```\nfunction ls\n    command ls --color=auto $argv\nend\n```\n\nThere are a few important things that need to be noted about aliases:\n\n- Always take care to add the [\\$argv](#variables-argv) variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.\n- If the alias has the same name as the aliased command, you need to prefix the call to the program with `command` to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).\n\nTo easily create a function of this form, you can use the [alias](cmds/alias) command. Unlike other shells, this just makes functions - fish has no separate concept of an “alias”, we just use the word for a simple wrapping function like this. [alias](cmds/alias) immediately creates a function. Consider using `alias --save` or [funcsave](cmds/funcsave) to save the created function into an autoload file instead of recreating the alias each time.\n\nFor an alternative, try [abbreviations](interactive#abbreviations). These are words that are expanded while you type, instead of being actual functions inside the shell.\n\n### Autoloading functions\n\nFunctions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:\n\n- An autoloaded function becomes available automatically to all running shells.\n- If the function definition is changed, all running shells will automatically reload the altered version, after a while.\n- Startup time and memory usage is improved, etc.\n\nWhen fish needs to load a function, it searches through any directories in the [list variable](#variables-lists) `$fish_function_path` for a file with a name consisting of the name of the function plus the suffix `.fish` and loads the first it finds.\n\nFor example if you try to execute something called `banana`, fish will go through all directories in \\$fish_function_path looking for a file called `banana.fish` and load the first one it finds.\n\nBy default `$fish_function_path` contains the following:\n\n- A directory for users to keep their own functions, usually `~/.config/fish/functions` (controlled by the `XDG_CONFIG_HOME` environment variable).\n- A directory for functions for all users on the system, usually `/etc/fish/functions` (really `$__fish_sysconfdir/functions`).\n- Directories for other software to put their own functions. These are in the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable) and in the `XDG_DATA_DIRS` environment variable, in a subdirectory called `fish/vendor_functions.d`. The default value for `XDG_DATA_DIRS` is usually `/usr/share/fish/vendor_functions.d` and `/usr/local/share/fish/vendor_functions.d`.\n- The functions shipped with fish, usually installed in `/usr/share/fish/functions` (really `$__fish_data_dir/functions`).\n\nIf you are unsure, your functions probably belong in `~/.config/fish/functions`.\n\nAs we’ve explained, autoload files are loaded *by name*, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.\n\nAutoloading also won’t work for [event handlers](#event), since fish cannot know that a function is supposed to be executed when an event occurs when it hasn’t yet loaded the function. See the [event handlers](#event) section for more information.\n\nIf a file of the right name doesn’t define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in \\$fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.\n\nIf you are developing another program and want to install fish functions for it, install them to the “vendor” functions directory. As this path varies from system to system, you can use `pkgconfig` to discover it with the output of `pkg-config --variable functionsdir fish`. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.\n\n## Comments\n\nAnything after a `#` until the end of the line is a comment. That means it’s purely for the reader’s benefit, fish ignores it.\n\nThis is useful to explain what and why you are doing something:\n\n```\nfunction ls\n    # The function is called ls,\n    # so we have to explicitly call `command ls` to avoid calling ourselves.\n    command ls --color=auto $argv\nend\n```\n\nThere are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a `#`.\n\nComments can also appear after a line like so:\n\n```\nset -gx EDITOR emacs # I don't like vim.\n```\n\n## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 6. Programmable title
  summary: When using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window
  belongs_to: 1. Help
  description: "## Programmable title\n\nWhen using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window. This can be done automatically in fish by defining the [fish_title](cmds/fish_title) function. The [fish_title](cmds/fish_title) function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message. The [status current-command](cmds/status) builtin will always return the name of the job to be put into the foreground (or `fish` if control is returning to the shell) when the [fish_prompt](cmds/fish_prompt) function is called. The first argument to fish_title will contain the most recently executed foreground command as a string.\n\nThe default fish title shows the hostname if connected via ssh, the currently running command (unless it is fish) and the current working directory. All of this is shortened to not make the tab too wide.\n\nExamples:\n\nTo show the last command and working directory in the title:\n\n```\nfunction fish_title\n    # `prompt_pwd` shortens the title. This helps prevent tabs from becoming very wide.\n    echo $argv[1] (prompt_pwd)\n    pwd\nend\n```\n\n## Programmable prompt\n\nWhen it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt. It does this by running the [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) functions.\n\nThe output of the former is displayed on the left and the latter’s output on the right side of the terminal. The output of [fish_mode_prompt](cmds/fish_mode_prompt) will be prepended on the left, though the default function only does this when in [vi-mode](#vi-mode).\n\n## Configurable greeting\n\nWhen it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):\n\n```\nset -U fish_greeting\n```\n\nor you can set it [globally](language#variables-scope) in [config.fish](language#configuration):\n\n```\nset -g fish_greeting 'Hey, stranger!'\n```\n\nor you can script it by changing the function:\n\n```\nfunction fish_greeting\n    random choice \"Hello!\" \"Hi\" \"G'day\" \"Howdy\"\nend\n```\n\nsave this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.\n\n## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 6. Syntax Highlighting
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 7. Combining pipes and redirections
  summary: This document is a comprehensive overview of fish’s scripting language
  description: "# The fish language\n\nThis document is a comprehensive overview of fish’s scripting language.\n\nFor interactive features see [Interactive use](interactive#interactive).\n\n## Syntax overview\n\nShells like fish are used by giving them commands. A command is executed by writing the name of the command followed by any arguments. For example:\n\n```\necho hello world\n```\n\n[echo](cmds/echo) command writes its arguments to the screen. In this example the output is `hello world`.\n\nEverything in fish is done with commands. There are commands for repeating other commands, commands for assigning variables, commands for treating a group of commands as a single command, etc. All of these commands follow the same basic syntax.\n\nEvery program on your computer can be used as a command in fish. If the program file is located in one of the [`PATH`](#envvar-PATH) directories, you can just type the name of the program to use it. Otherwise the whole filename, including the directory (like `/home/me/code/checkers/checkers` or `../checkers`) is required.\n\nHere is a list of some useful commands:\n\n- [cd](cmds/cd): Change the current directory\n- `ls`: List files and directories\n- `man`: Display a manual page - try `man ls` to get help on your “ls” command, or `man mv` to get information about “mv”.\n- `mv`: Move (rename) files\n- `cp`: Copy files\n- [open](cmds/open): Open files with the default application associated with each filetype\n- `less`: Display the contents of files\n\nCommands and arguments are separated by the space character `' '`. Every command ends with either a newline (by pressing the return key) or a semicolon `;`. Multiple commands can be written on the same line by separating them with semicolons.\n\nA switch is a very common special type of argument. Switches almost always start with one or more hyphens `-` and alter the way a command operates. For example, the `ls` command usually lists the names of all files and directories in the current working directory. By using the `-l` switch, the behavior of `ls` is changed to not only display the filename, but also the size, permissions, owner, and modification time of each file.\n\nSwitches differ between commands and are usually documented on a command’s manual page. There are some switches, however, that are common to most commands. For example, `--help` will usually display a help text, `--version` will usually display the command version, and `-i` will often turn on interactive prompting before taking action. Try `man your-command-here` to get information on your command’s switches.\n\nSo the basic idea of fish is the same as with other unix shells: It gets a commandline, runs [expansions](#expand), and the result is then run as a command.\n\n## Terminology\n\nHere we define some of the terms used on this page and throughout the rest of the fish documentation:\n\n- **Argument**: A parameter given to a command. In `echo foo`, the “foo” is an argument.\n- **Builtin**: A command that is implemented by the shell. Builtins are so closely tied to the operation of the shell that it is impossible to implement them as external commands. In `echo foo`, the “echo” is a builtin.\n- **Command**: A program that the shell can run, or more specifically an external program that the shell runs in another process. External commands are provided on your system, as executable files. In `echo foo` the “echo” is a builtin command, in `command echo foo` the “echo” is an external command, provided by a file like /bin/echo.\n- **Function**: A block of commands that can be called as if they were a single command. By using functions, it is possible to string together multiple simple commands into one more advanced command.\n- **Job**: A running pipeline or command.\n- **Pipeline**: A set of commands strung together so that the output of one command is the input of the next command. `echo foo | grep foo` is a pipeline.\n- **Redirection**: An operation that changes one of the input or output streams associated with a job.\n- **Switch** or **Option**: A special kind of argument that alters the behavior of a command. A switch almost always begins with one or two hyphens. In `echo -n foo` the “-n” is an option.\n\n## Quotes\n\nSometimes you want to give a command an argument that contains characters special to fish, like spaces or `$` or `*`. To do that, you can use quotes:\n\n```\nrm \"my file.txt\"\n```\n\nto remove a file called `my file.txt` instead of trying to remove two files, `my` and `file.txt`.\n\nFish understands two kinds of quotes: Single (`'`) and double (`\"`), and both work slightly differently.\n\nBetween single quotes, fish performs no expansions. Between double quotes, fish only performs [variable expansion](#expand-variable) and [command substitution](#expand-command-substitution) in the `$(command)`. No other kind of expansion (including [brace expansion](#expand-brace) or parameter expansion) is performed, and escape sequences (for example, `\\n`) are ignored. Within quotes, whitespace is not used to separate arguments, allowing quoted arguments to contain spaces.\n\nThe only meaningful escape sequences in single quotes are `\\'`, which escapes a single quote and `\\\\`, which escapes the backslash symbol. The only meaningful escapes in double quotes are `\\\"`, which escapes a double quote, `\\$`, which escapes a dollar character, `\\` followed by a newline, which deletes the backslash and the newline, and `\\\\`, which escapes the backslash symbol.\n\nSingle quotes have no special meaning within double quotes and vice versa.\n\nMore examples:\n\n```\ngrep 'enabled)$' foo.txt\n```\n\nsearches for lines ending in `enabled)` in `foo.txt` (the `$` is special to `grep`: it matches the end of the line).\n\n```\napt install \"postgres-*\"\n```\n\ninstalls all packages with a name starting with “postgres-”, instead of looking through the current directory for files named “postgres-something”.\n\n## Escaping Characters\n\nSome characters cannot be written directly on the command line. For these characters, so-called escape sequences are provided. These are:\n\n- `\\a` represents the alert character.\n- `\\e` represents the escape character.\n- `\\f` represents the form feed character.\n- `\\n` represents a newline character.\n- `\\r` represents the carriage return character.\n- `\\t` represents the tab character.\n- `\\v` represents the vertical tab character.\n- `\\xHH` or `\\XHH`, where `HH` is a hexadecimal number, represents a byte of data with the specified value. For example, `\\x9` is the tab character. If you are using a multibyte encoding, this can be used to enter invalid strings. Typically fish is run with the ASCII or UTF-8 encoding, so anything up to `\\X7f` is an ASCII character.\n- `\\ooo`, where `ooo` is an octal number, represents the ASCII character with the specified value. For example, `\\011` is the tab character. The highest allowed value is `\\177`.\n- `\\uXXXX`, where `XXXX` is a hexadecimal number, represents the 16-bit Unicode character with the specified value. For example, `\\u9` is the tab character.\n- `\\UXXXXXXXX`, where `XXXXXXXX` is a hexadecimal number, represents the 32-bit Unicode character with the specified value. For example, `\\U9` is the tab character. The highest allowed value is U10FFFF.\n- `\\cX`, where `X` is a letter of the alphabet, represents the control sequence generated by pressing the control key and the specified letter. For example, `\\ci` is the tab character\n\nSome characters have special meaning to the shell. For example, an apostrophe `'` disables expansion (see [Quotes](#quotes)). To tell the shell to treat these characters literally, escape them with a backslash. For example, the command:\n\n```\necho \\'hello world\\'\n```\n\noutputs `'hello world'` (including the apostrophes), while the command:\n\n```\necho 'hello world'\n```\n\noutputs `hello world` (without the apostrophes). In the former case the shell treats the apostrophes as literal `'` characters, while in the latter case it treats them as special expansion modifiers.\n\nThe special characters and their escape sequences are:\n\n- `\\ ` (backslash space) escapes the space character. This keeps the shell from splitting arguments on the escaped space.\n- `\\$` escapes the dollar character.\n- `\\\\` escapes the backslash character.\n- `\\*` escapes the star character.\n- `\\?` escapes the question mark character (this is not necessary if the `qmark-noglob` [feature flag](#featureflags) is enabled).\n- `\\~` escapes the tilde character.\n- `\\#` escapes the hash character.\n- `\\(` escapes the left parenthesis character.\n- `\\)` escapes the right parenthesis character.\n- `\\{` escapes the left curly bracket character.\n- `\\}` escapes the right curly bracket character.\n- `\\[` escapes the left bracket character.\n- `\\]` escapes the right bracket character.\n- `\\<` escapes the less than character.\n- `\\>` escapes the more than character.\n- `\\&` escapes the ampersand character.\n- `\\|` escapes the vertical bar character.\n- `\\;` escapes the semicolon character.\n- `\\\"` escapes the quote character.\n- `\\'` escapes the apostrophe character.\n\nAs a special case, `\\` immediately followed by a literal new line is a “continuation” and tells fish to ignore the line break and resume input at the start of the next line (without introducing any whitespace or terminating a token).\n\n## Input/Output Redirection\n\nMost programs use three input/output (I/O) streams:\n\n- Standard input (stdin) for reading. Defaults to reading from the keyboard.\n- Standard output (stdout) for writing output. Defaults to writing to the screen.\n- Standard error (stderr) for writing errors and warnings. Defaults to writing to the screen.\n\nEach stream has a number called the file descriptor (FD): 0 for stdin, 1 for stdout, and 2 for stderr.\n\nThe destination of a stream can be changed using something called *redirection*. For example, `echo hello > output.txt`, redirects the standard output of the `echo` command to a text file.\n\n- To read standard input from a file, use `<SOURCE_FILE`.\n- To write standard output to a file, use `>DESTINATION`.\n- To write standard error to a file, use `2>DESTINATION`. [\\[1\\]](#id4)\n- To append standard output to a file, use `>>DESTINATION_FILE`.\n- To append standard error to a file, use `2>>DESTINATION_FILE`.\n- To not overwrite (“clobber”) an existing file, use `>?DESTINATION` or `2>?DESTINATION`. This is known as the “noclobber” redirection.\n\n`DESTINATION` can be one of the following:\n\n- A filename to write the output to. Often `>/dev/null` to silence output by writing it to the special “sinkhole” file.\n- An ampersand (`&`) followed by the number of another file descriptor like `&2` for standard error. The output will be written to the destination descriptor.\n- An ampersand followed by a minus sign (`&-`). The file descriptor will be closed. Note: This may cause the program to fail because its writes will be unsuccessful.\n\nAs a convenience, the redirection `&>` can be used to direct both stdout and stderr to the same destination. For example, `echo hello &> all_output.txt` redirects both stdout and stderr to the file `all_output.txt`. This is equivalent to `echo hello > all_output.txt 2>&1`.\n\nAny arbitrary file descriptor can be used in a redirection by prefixing the redirection with the FD number.\n\n- To redirect the input of descriptor N, use `N<DESTINATION`.\n- To redirect the output of descriptor N, use `N>DESTINATION`.\n- To append the output of descriptor N to a file, use `N>>DESTINATION_FILE`.\n\nFor example:\n\n```\n# Write `foo`'s standard error (file descriptor 2)\n# to a file called \"output.stderr\":\nfoo 2> output.stderr\n\n# if $num doesn't contain a number,\n# this test will be false and print an error,\n# so by ignoring the error we can be sure that we're dealing\n# with a number in the \"if\" block:\nif test \"$num\" -gt 2 2>/dev/null\n    # do things with $num as a number greater than 2\nelse\n    # do things if $num is <= 2 or not a number\nend\n\n# Save `make`s output in a file:\nmake &>/log\n\n# Redirections stack and can be used with blocks:\nbegin\n    echo stdout\n    echo stderr >&2 # <- this goes to stderr!\nend >/dev/null # ignore stdout, so this prints \"stderr\"\n```\n\nIt is an error to redirect a builtin, function, or block to a file descriptor above 2. However this is supported for external commands.\n\n\\[[1](#id3)\\]\n\nPrevious versions of fish also allowed specifying this as `^DESTINATION`, but that made another character special so it was deprecated and removed. See [feature flags](#featureflags).\n\n## Piping\n\nAnother way to redirect streams is a *pipe*. A pipe connects streams with each other. Usually the standard output of one command is connected with the standard input of another. This is done by separating commands with the pipe character `|`. For example:\n\n```\ncat foo.txt | head\n```\n\nThe command `cat foo.txt` sends the contents of `foo.txt` to stdout. This output is provided as input for the `head` program, which prints the first 10 lines of its input.\n\nIt is possible to pipe a different output file descriptor by prepending its FD number and the output redirect symbol to the pipe. For example:\n\n```\nmake fish 2>| less\n```\n\nwill attempt to build `fish`, and any errors will be shown using the `less` pager. [\\[2\\]](#id6)\n\nAs a convenience, the pipe `&|` redirects both stdout and stderr to the same process. This is different from bash, which uses `|&`.\n\n\\[[2](#id5)\\]\n\nA “pager” here is a program that takes output and “paginates” it. `less` doesn’t just do pages, it allows arbitrary scrolling (even back!).\n\n## Combining pipes and redirections\n\nIt is possible to use multiple redirections and a pipe at the same time. In that case, they are read in this order:\n\n1.  First the pipe is set up.\n2.  Then the redirections are evaluated from left-to-right.\n\nThis is important when any redirections reference other file descriptors with the `&N` syntax. When you say `>&2`, that will redirect stdout to where stderr is pointing to *at that time*.\n\nConsider this helper function:\n\n```\n# Just make a function that prints something to stdout and stderr\nfunction print\n    echo out\n    echo err >&2\nend\n```\n\nNow let’s see a few cases:\n\n```\n# Redirect both stderr and stdout to less\n# (can also be spelt as `&|`)\nprint 2>&1 | less\n\n# Show the \"out\" on stderr, silence the \"err\"\nprint >&2 2>/dev/null\n\n# Silence both\nprint >/dev/null 2>&1\n```\n\n## Job control\n\nWhen you start a job in fish, fish itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an `&` (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.\n\nExample:\n\n```\nemacs &\n```\n\nwill start the emacs text editor in the background. [fg](cmds/fg) can be used to bring it into the foreground again when needed.\n\nMost programs allow you to suspend the program’s execution and return control to fish by pressing Control+Z (also referred to as `^Z`). Once back at the fish commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the [fg](cmds/fg) (foreground) command.\n\nIf you instead want to put a suspended job into the background, use the [bg](cmds/bg) command.\n\nTo get a listing of all currently started jobs, use the [jobs](cmds/jobs) command. These listed jobs can be removed with the [disown](cmds/disown) command.\n\nAt the moment, functions cannot be started in the background. Functions that are stopped and then restarted in the background using the [bg](cmds/bg) command will not execute correctly.\n\nIf the `&` character is followed by a non-separating character, it is not interpreted as background operator. Separating characters are whitespace and the characters `;<>&|`.\n\n## Functions\n\nFunctions are programs written in the fish syntax. They group together various commands and their arguments using a single name.\n\nFor example, here’s a simple function to list directories:\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nThe first line tells fish to define a function by the name of `ll`, so it can be used by simply writing `ll` on the commandline. The second line tells fish that the command `ls -l $argv` should be called when `ll` is invoked. [\\$argv](#variables-argv) is a [list variable](#variables-lists), which always contains all arguments sent to the function. In the example above, these are simply passed on to the `ls` command. The `end` on the third line ends the definition.\n\nCalling this as `ll /tmp/` will end up running `ls -l /tmp/`, which will list the contents of /tmp.\n\nThis is a kind of function known as an [alias](#syntax-aliases).\n\nFish’s prompt is also defined in a function, called [fish_prompt](cmds/fish_prompt). It is run when the prompt is about to be displayed and its output forms the prompt:\n\n```\nfunction fish_prompt\n    # A simple prompt. Displays the current directory\n    # (which fish stores in the $PWD variable)\n    # and then a user symbol - a '►' for a normal user and a '#' for root.\n    set -l user_char '►'\n    if fish_is_root_user\n        set user_char '#'\n    end\n\n    echo (set_color yellow)$PWD (set_color purple)$user_char\nend\n```\n\nTo edit a function, you can use [funced](cmds/funced), and to save a function [funcsave](cmds/funcsave). This will store it in a function file that fish will [autoload](#syntax-function-autoloading) when needed.\n\nThe [functions](cmds/functions) builtin can show a function’s current definition (and [type](cmds/type) will also do if given a function).\n\nFor more information on functions, see the documentation for the [function](cmds/function) builtin.\n\n### Defining aliases\n\nOne of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the `ls` command to display colors. The switch for turning on colors on GNU systems is `--color=auto`. An alias around `ls` might look like this:\n\n```\nfunction ls\n    command ls --color=auto $argv\nend\n```\n\nThere are a few important things that need to be noted about aliases:\n\n- Always take care to add the [\\$argv](#variables-argv) variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.\n- If the alias has the same name as the aliased command, you need to prefix the call to the program with `command` to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).\n\nTo easily create a function of this form, you can use the [alias](cmds/alias) command. Unlike other shells, this just makes functions - fish has no separate concept of an “alias”, we just use the word for a simple wrapping function like this. [alias](cmds/alias) immediately creates a function. Consider using `alias --save` or [funcsave](cmds/funcsave) to save the created function into an autoload file instead of recreating the alias each time.\n\nFor an alternative, try [abbreviations](interactive#abbreviations). These are words that are expanded while you type, instead of being actual functions inside the shell.\n\n### Autoloading functions\n\nFunctions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:\n\n- An autoloaded function becomes available automatically to all running shells.\n- If the function definition is changed, all running shells will automatically reload the altered version, after a while.\n- Startup time and memory usage is improved, etc.\n\nWhen fish needs to load a function, it searches through any directories in the [list variable](#variables-lists) `$fish_function_path` for a file with a name consisting of the name of the function plus the suffix `.fish` and loads the first it finds.\n\nFor example if you try to execute something called `banana`, fish will go through all directories in \\$fish_function_path looking for a file called `banana.fish` and load the first one it finds.\n\nBy default `$fish_function_path` contains the following:\n\n- A directory for users to keep their own functions, usually `~/.config/fish/functions` (controlled by the `XDG_CONFIG_HOME` environment variable).\n- A directory for functions for all users on the system, usually `/etc/fish/functions` (really `$__fish_sysconfdir/functions`).\n- Directories for other software to put their own functions. These are in the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable) and in the `XDG_DATA_DIRS` environment variable, in a subdirectory called `fish/vendor_functions.d`. The default value for `XDG_DATA_DIRS` is usually `/usr/share/fish/vendor_functions.d` and `/usr/local/share/fish/vendor_functions.d`.\n- The functions shipped with fish, usually installed in `/usr/share/fish/functions` (really `$__fish_data_dir/functions`).\n\nIf you are unsure, your functions probably belong in `~/.config/fish/functions`.\n\nAs we’ve explained, autoload files are loaded *by name*, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.\n\nAutoloading also won’t work for [event handlers](#event), since fish cannot know that a function is supposed to be executed when an event occurs when it hasn’t yet loaded the function. See the [event handlers](#event) section for more information.\n\nIf a file of the right name doesn’t define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in \\$fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.\n\nIf you are developing another program and want to install fish functions for it, install them to the “vendor” functions directory. As this path varies from system to system, you can use `pkgconfig` to discover it with the output of `pkg-config --variable functionsdir fish`. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.\n\n## Comments\n\nAnything after a `#` until the end of the line is a comment. That means it’s purely for the reader’s benefit, fish ignores it.\n\nThis is useful to explain what and why you are doing something:\n\n```\nfunction ls\n    # The function is called ls,\n    # so we have to explicitly call `command ls` to avoid calling ourselves.\n    command ls --color=auto $argv\nend\n```\n\nThere are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a `#`.\n\nComments can also appear after a line like so:\n\n```\nset -gx EDITOR emacs # I don't like vim.\n```\n\n## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 7. Programmable prompt
  summary: When it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt
  belongs_to: 1. Help
  description: "## Programmable prompt\n\nWhen it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt. It does this by running the [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) functions.\n\nThe output of the former is displayed on the left and the latter’s output on the right side of the terminal. The output of [fish_mode_prompt](cmds/fish_mode_prompt) will be prepended on the left, though the default function only does this when in [vi-mode](#vi-mode).\n\n## Configurable greeting\n\nWhen it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):\n\n```\nset -U fish_greeting\n```\n\nor you can set it [globally](language#variables-scope) in [config.fish](language#configuration):\n\n```\nset -g fish_greeting 'Hey, stranger!'\n```\n\nor you can script it by changing the function:\n\n```\nfunction fish_greeting\n    random choice \"Hello!\" \"Hi\" \"G'day\" \"Howdy\"\nend\n```\n\nsave this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.\n\n## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 7. Wildcards
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 8. Configurable greeting
  summary: When it is started interactively, fish tries to run the fish_greeting function
  belongs_to: 1. Help
  description: |-
    ## Configurable greeting

    When it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):

    ```
    set -U fish_greeting
    ```

    or you can set it [globally](language#variables-scope) in [config.fish](language#configuration):

    ```
    set -g fish_greeting 'Hey, stranger!'
    ```

    or you can script it by changing the function:

    ```
    function fish_greeting
        random choice "Hello!" "Hi" "G'day" "Howdy"
    end
    ```

    save this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.
- name: 8. Job control
  summary: When you start a job in fish, fish itself will pause, and give control of the terminal to the program just started
  belongs_to: 7. Combining pipes and redirections
  description: "## Job control\n\nWhen you start a job in fish, fish itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an `&` (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.\n\nExample:\n\n```\nemacs &\n```\n\nwill start the emacs text editor in the background. [fg](cmds/fg) can be used to bring it into the foreground again when needed.\n\nMost programs allow you to suspend the program’s execution and return control to fish by pressing Control+Z (also referred to as `^Z`). Once back at the fish commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the [fg](cmds/fg) (foreground) command.\n\nIf you instead want to put a suspended job into the background, use the [bg](cmds/bg) command.\n\nTo get a listing of all currently started jobs, use the [jobs](cmds/jobs) command. These listed jobs can be removed with the [disown](cmds/disown) command.\n\nAt the moment, functions cannot be started in the background. Functions that are stopped and then restarted in the background using the [bg](cmds/bg) command will not execute correctly.\n\nIf the `&` character is followed by a non-separating character, it is not interpreted as background operator. Separating characters are whitespace and the characters `;<>&|`.\n\n## Functions\n\nFunctions are programs written in the fish syntax. They group together various commands and their arguments using a single name.\n\nFor example, here’s a simple function to list directories:\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nThe first line tells fish to define a function by the name of `ll`, so it can be used by simply writing `ll` on the commandline. The second line tells fish that the command `ls -l $argv` should be called when `ll` is invoked. [\\$argv](#variables-argv) is a [list variable](#variables-lists), which always contains all arguments sent to the function. In the example above, these are simply passed on to the `ls` command. The `end` on the third line ends the definition.\n\nCalling this as `ll /tmp/` will end up running `ls -l /tmp/`, which will list the contents of /tmp.\n\nThis is a kind of function known as an [alias](#syntax-aliases).\n\nFish’s prompt is also defined in a function, called [fish_prompt](cmds/fish_prompt). It is run when the prompt is about to be displayed and its output forms the prompt:\n\n```\nfunction fish_prompt\n    # A simple prompt. Displays the current directory\n    # (which fish stores in the $PWD variable)\n    # and then a user symbol - a '►' for a normal user and a '#' for root.\n    set -l user_char '►'\n    if fish_is_root_user\n        set user_char '#'\n    end\n\n    echo (set_color yellow)$PWD (set_color purple)$user_char\nend\n```\n\nTo edit a function, you can use [funced](cmds/funced), and to save a function [funcsave](cmds/funcsave). This will store it in a function file that fish will [autoload](#syntax-function-autoloading) when needed.\n\nThe [functions](cmds/functions) builtin can show a function’s current definition (and [type](cmds/type) will also do if given a function).\n\nFor more information on functions, see the documentation for the [function](cmds/function) builtin.\n\n### Defining aliases\n\nOne of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the `ls` command to display colors. The switch for turning on colors on GNU systems is `--color=auto`. An alias around `ls` might look like this:\n\n```\nfunction ls\n    command ls --color=auto $argv\nend\n```\n\nThere are a few important things that need to be noted about aliases:\n\n- Always take care to add the [\\$argv](#variables-argv) variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.\n- If the alias has the same name as the aliased command, you need to prefix the call to the program with `command` to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).\n\nTo easily create a function of this form, you can use the [alias](cmds/alias) command. Unlike other shells, this just makes functions - fish has no separate concept of an “alias”, we just use the word for a simple wrapping function like this. [alias](cmds/alias) immediately creates a function. Consider using `alias --save` or [funcsave](cmds/funcsave) to save the created function into an autoload file instead of recreating the alias each time.\n\nFor an alternative, try [abbreviations](interactive#abbreviations). These are words that are expanded while you type, instead of being actual functions inside the shell.\n\n### Autoloading functions\n\nFunctions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:\n\n- An autoloaded function becomes available automatically to all running shells.\n- If the function definition is changed, all running shells will automatically reload the altered version, after a while.\n- Startup time and memory usage is improved, etc.\n\nWhen fish needs to load a function, it searches through any directories in the [list variable](#variables-lists) `$fish_function_path` for a file with a name consisting of the name of the function plus the suffix `.fish` and loads the first it finds.\n\nFor example if you try to execute something called `banana`, fish will go through all directories in \\$fish_function_path looking for a file called `banana.fish` and load the first one it finds.\n\nBy default `$fish_function_path` contains the following:\n\n- A directory for users to keep their own functions, usually `~/.config/fish/functions` (controlled by the `XDG_CONFIG_HOME` environment variable).\n- A directory for functions for all users on the system, usually `/etc/fish/functions` (really `$__fish_sysconfdir/functions`).\n- Directories for other software to put their own functions. These are in the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable) and in the `XDG_DATA_DIRS` environment variable, in a subdirectory called `fish/vendor_functions.d`. The default value for `XDG_DATA_DIRS` is usually `/usr/share/fish/vendor_functions.d` and `/usr/local/share/fish/vendor_functions.d`.\n- The functions shipped with fish, usually installed in `/usr/share/fish/functions` (really `$__fish_data_dir/functions`).\n\nIf you are unsure, your functions probably belong in `~/.config/fish/functions`.\n\nAs we’ve explained, autoload files are loaded *by name*, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.\n\nAutoloading also won’t work for [event handlers](#event), since fish cannot know that a function is supposed to be executed when an event occurs when it hasn’t yet loaded the function. See the [event handlers](#event) section for more information.\n\nIf a file of the right name doesn’t define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in \\$fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.\n\nIf you are developing another program and want to install fish functions for it, install them to the “vendor” functions directory. As this path varies from system to system, you can use `pkgconfig` to discover it with the output of `pkg-config --variable functionsdir fish`. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.\n\n## Comments\n\nAnything after a `#` until the end of the line is a comment. That means it’s purely for the reader’s benefit, fish ignores it.\n\nThis is useful to explain what and why you are doing something:\n\n```\nfunction ls\n    # The function is called ls,\n    # so we have to explicitly call `command ls` to avoid calling ourselves.\n    command ls --color=auto $argv\nend\n```\n\nThere are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a `#`.\n\nComments can also appear after a line like so:\n\n```\nset -gx EDITOR emacs # I don't like vim.\n```\n\n## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 8. Pipes and Redirections
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 9. Autosuggestions
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 9. Functions
  summary: Functions are programs written in the fish syntax
  belongs_to: 7. Combining pipes and redirections
  description: "## Functions\n\nFunctions are programs written in the fish syntax. They group together various commands and their arguments using a single name.\n\nFor example, here’s a simple function to list directories:\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nThe first line tells fish to define a function by the name of `ll`, so it can be used by simply writing `ll` on the commandline. The second line tells fish that the command `ls -l $argv` should be called when `ll` is invoked. [\\$argv](#variables-argv) is a [list variable](#variables-lists), which always contains all arguments sent to the function. In the example above, these are simply passed on to the `ls` command. The `end` on the third line ends the definition.\n\nCalling this as `ll /tmp/` will end up running `ls -l /tmp/`, which will list the contents of /tmp.\n\nThis is a kind of function known as an [alias](#syntax-aliases).\n\nFish’s prompt is also defined in a function, called [fish_prompt](cmds/fish_prompt). It is run when the prompt is about to be displayed and its output forms the prompt:\n\n```\nfunction fish_prompt\n    # A simple prompt. Displays the current directory\n    # (which fish stores in the $PWD variable)\n    # and then a user symbol - a '►' for a normal user and a '#' for root.\n    set -l user_char '►'\n    if fish_is_root_user\n        set user_char '#'\n    end\n\n    echo (set_color yellow)$PWD (set_color purple)$user_char\nend\n```\n\nTo edit a function, you can use [funced](cmds/funced), and to save a function [funcsave](cmds/funcsave). This will store it in a function file that fish will [autoload](#syntax-function-autoloading) when needed.\n\nThe [functions](cmds/functions) builtin can show a function’s current definition (and [type](cmds/type) will also do if given a function).\n\nFor more information on functions, see the documentation for the [function](cmds/function) builtin.\n\n### Defining aliases\n\nOne of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the `ls` command to display colors. The switch for turning on colors on GNU systems is `--color=auto`. An alias around `ls` might look like this:\n\n```\nfunction ls\n    command ls --color=auto $argv\nend\n```\n\nThere are a few important things that need to be noted about aliases:\n\n- Always take care to add the [\\$argv](#variables-argv) variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.\n- If the alias has the same name as the aliased command, you need to prefix the call to the program with `command` to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).\n\nTo easily create a function of this form, you can use the [alias](cmds/alias) command. Unlike other shells, this just makes functions - fish has no separate concept of an “alias”, we just use the word for a simple wrapping function like this. [alias](cmds/alias) immediately creates a function. Consider using `alias --save` or [funcsave](cmds/funcsave) to save the created function into an autoload file instead of recreating the alias each time.\n\nFor an alternative, try [abbreviations](interactive#abbreviations). These are words that are expanded while you type, instead of being actual functions inside the shell.\n\n### Autoloading functions\n\nFunctions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:\n\n- An autoloaded function becomes available automatically to all running shells.\n- If the function definition is changed, all running shells will automatically reload the altered version, after a while.\n- Startup time and memory usage is improved, etc.\n\nWhen fish needs to load a function, it searches through any directories in the [list variable](#variables-lists) `$fish_function_path` for a file with a name consisting of the name of the function plus the suffix `.fish` and loads the first it finds.\n\nFor example if you try to execute something called `banana`, fish will go through all directories in \\$fish_function_path looking for a file called `banana.fish` and load the first one it finds.\n\nBy default `$fish_function_path` contains the following:\n\n- A directory for users to keep their own functions, usually `~/.config/fish/functions` (controlled by the `XDG_CONFIG_HOME` environment variable).\n- A directory for functions for all users on the system, usually `/etc/fish/functions` (really `$__fish_sysconfdir/functions`).\n- Directories for other software to put their own functions. These are in the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable) and in the `XDG_DATA_DIRS` environment variable, in a subdirectory called `fish/vendor_functions.d`. The default value for `XDG_DATA_DIRS` is usually `/usr/share/fish/vendor_functions.d` and `/usr/local/share/fish/vendor_functions.d`.\n- The functions shipped with fish, usually installed in `/usr/share/fish/functions` (really `$__fish_data_dir/functions`).\n\nIf you are unsure, your functions probably belong in `~/.config/fish/functions`.\n\nAs we’ve explained, autoload files are loaded *by name*, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.\n\nAutoloading also won’t work for [event handlers](#event), since fish cannot know that a function is supposed to be executed when an event occurs when it hasn’t yet loaded the function. See the [event handlers](#event) section for more information.\n\nIf a file of the right name doesn’t define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in \\$fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.\n\nIf you are developing another program and want to install fish functions for it, install them to the “vendor” functions directory. As this path varies from system to system, you can use `pkgconfig` to discover it with the output of `pkg-config --variable functionsdir fish`. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.\n\n## Comments\n\nAnything after a `#` until the end of the line is a comment. That means it’s purely for the reader’s benefit, fish ignores it.\n\nThis is useful to explain what and why you are doing something:\n\n```\nfunction ls\n    # The function is called ls,\n    # so we have to explicitly call `command ls` to avoid calling ourselves.\n    command ls --color=auto $argv\nend\n```\n\nThere are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a `#`.\n\nComments can also appear after a line like so:\n\n```\nset -gx EDITOR emacs # I don't like vim.\n```\n\n## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 9. Private mode
  summary: If $fish_private_mode is set to a non-empty value, commands will not be written to the history file on disk
  belongs_to: 1. Help
  description: "## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 10. Command line editor
  summary: The fish editor features copy and paste, a searchable history and many editor functions that can be bound to special keyboard shortcuts
  belongs_to: 1. Help
  description: "## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 10. Comments
  summary: This document is a comprehensive overview of fish’s scripting language
  description: "# The fish language\n\nThis document is a comprehensive overview of fish’s scripting language.\n\nFor interactive features see [Interactive use](interactive#interactive).\n\n## Syntax overview\n\nShells like fish are used by giving them commands. A command is executed by writing the name of the command followed by any arguments. For example:\n\n```\necho hello world\n```\n\n[echo](cmds/echo) command writes its arguments to the screen. In this example the output is `hello world`.\n\nEverything in fish is done with commands. There are commands for repeating other commands, commands for assigning variables, commands for treating a group of commands as a single command, etc. All of these commands follow the same basic syntax.\n\nEvery program on your computer can be used as a command in fish. If the program file is located in one of the [`PATH`](#envvar-PATH) directories, you can just type the name of the program to use it. Otherwise the whole filename, including the directory (like `/home/me/code/checkers/checkers` or `../checkers`) is required.\n\nHere is a list of some useful commands:\n\n- [cd](cmds/cd): Change the current directory\n- `ls`: List files and directories\n- `man`: Display a manual page - try `man ls` to get help on your “ls” command, or `man mv` to get information about “mv”.\n- `mv`: Move (rename) files\n- `cp`: Copy files\n- [open](cmds/open): Open files with the default application associated with each filetype\n- `less`: Display the contents of files\n\nCommands and arguments are separated by the space character `' '`. Every command ends with either a newline (by pressing the return key) or a semicolon `;`. Multiple commands can be written on the same line by separating them with semicolons.\n\nA switch is a very common special type of argument. Switches almost always start with one or more hyphens `-` and alter the way a command operates. For example, the `ls` command usually lists the names of all files and directories in the current working directory. By using the `-l` switch, the behavior of `ls` is changed to not only display the filename, but also the size, permissions, owner, and modification time of each file.\n\nSwitches differ between commands and are usually documented on a command’s manual page. There are some switches, however, that are common to most commands. For example, `--help` will usually display a help text, `--version` will usually display the command version, and `-i` will often turn on interactive prompting before taking action. Try `man your-command-here` to get information on your command’s switches.\n\nSo the basic idea of fish is the same as with other unix shells: It gets a commandline, runs [expansions](#expand), and the result is then run as a command.\n\n## Terminology\n\nHere we define some of the terms used on this page and throughout the rest of the fish documentation:\n\n- **Argument**: A parameter given to a command. In `echo foo`, the “foo” is an argument.\n- **Builtin**: A command that is implemented by the shell. Builtins are so closely tied to the operation of the shell that it is impossible to implement them as external commands. In `echo foo`, the “echo” is a builtin.\n- **Command**: A program that the shell can run, or more specifically an external program that the shell runs in another process. External commands are provided on your system, as executable files. In `echo foo` the “echo” is a builtin command, in `command echo foo` the “echo” is an external command, provided by a file like /bin/echo.\n- **Function**: A block of commands that can be called as if they were a single command. By using functions, it is possible to string together multiple simple commands into one more advanced command.\n- **Job**: A running pipeline or command.\n- **Pipeline**: A set of commands strung together so that the output of one command is the input of the next command. `echo foo | grep foo` is a pipeline.\n- **Redirection**: An operation that changes one of the input or output streams associated with a job.\n- **Switch** or **Option**: A special kind of argument that alters the behavior of a command. A switch almost always begins with one or two hyphens. In `echo -n foo` the “-n” is an option.\n\n## Quotes\n\nSometimes you want to give a command an argument that contains characters special to fish, like spaces or `$` or `*`. To do that, you can use quotes:\n\n```\nrm \"my file.txt\"\n```\n\nto remove a file called `my file.txt` instead of trying to remove two files, `my` and `file.txt`.\n\nFish understands two kinds of quotes: Single (`'`) and double (`\"`), and both work slightly differently.\n\nBetween single quotes, fish performs no expansions. Between double quotes, fish only performs [variable expansion](#expand-variable) and [command substitution](#expand-command-substitution) in the `$(command)`. No other kind of expansion (including [brace expansion](#expand-brace) or parameter expansion) is performed, and escape sequences (for example, `\\n`) are ignored. Within quotes, whitespace is not used to separate arguments, allowing quoted arguments to contain spaces.\n\nThe only meaningful escape sequences in single quotes are `\\'`, which escapes a single quote and `\\\\`, which escapes the backslash symbol. The only meaningful escapes in double quotes are `\\\"`, which escapes a double quote, `\\$`, which escapes a dollar character, `\\` followed by a newline, which deletes the backslash and the newline, and `\\\\`, which escapes the backslash symbol.\n\nSingle quotes have no special meaning within double quotes and vice versa.\n\nMore examples:\n\n```\ngrep 'enabled)$' foo.txt\n```\n\nsearches for lines ending in `enabled)` in `foo.txt` (the `$` is special to `grep`: it matches the end of the line).\n\n```\napt install \"postgres-*\"\n```\n\ninstalls all packages with a name starting with “postgres-”, instead of looking through the current directory for files named “postgres-something”.\n\n## Escaping Characters\n\nSome characters cannot be written directly on the command line. For these characters, so-called escape sequences are provided. These are:\n\n- `\\a` represents the alert character.\n- `\\e` represents the escape character.\n- `\\f` represents the form feed character.\n- `\\n` represents a newline character.\n- `\\r` represents the carriage return character.\n- `\\t` represents the tab character.\n- `\\v` represents the vertical tab character.\n- `\\xHH` or `\\XHH`, where `HH` is a hexadecimal number, represents a byte of data with the specified value. For example, `\\x9` is the tab character. If you are using a multibyte encoding, this can be used to enter invalid strings. Typically fish is run with the ASCII or UTF-8 encoding, so anything up to `\\X7f` is an ASCII character.\n- `\\ooo`, where `ooo` is an octal number, represents the ASCII character with the specified value. For example, `\\011` is the tab character. The highest allowed value is `\\177`.\n- `\\uXXXX`, where `XXXX` is a hexadecimal number, represents the 16-bit Unicode character with the specified value. For example, `\\u9` is the tab character.\n- `\\UXXXXXXXX`, where `XXXXXXXX` is a hexadecimal number, represents the 32-bit Unicode character with the specified value. For example, `\\U9` is the tab character. The highest allowed value is U10FFFF.\n- `\\cX`, where `X` is a letter of the alphabet, represents the control sequence generated by pressing the control key and the specified letter. For example, `\\ci` is the tab character\n\nSome characters have special meaning to the shell. For example, an apostrophe `'` disables expansion (see [Quotes](#quotes)). To tell the shell to treat these characters literally, escape them with a backslash. For example, the command:\n\n```\necho \\'hello world\\'\n```\n\noutputs `'hello world'` (including the apostrophes), while the command:\n\n```\necho 'hello world'\n```\n\noutputs `hello world` (without the apostrophes). In the former case the shell treats the apostrophes as literal `'` characters, while in the latter case it treats them as special expansion modifiers.\n\nThe special characters and their escape sequences are:\n\n- `\\ ` (backslash space) escapes the space character. This keeps the shell from splitting arguments on the escaped space.\n- `\\$` escapes the dollar character.\n- `\\\\` escapes the backslash character.\n- `\\*` escapes the star character.\n- `\\?` escapes the question mark character (this is not necessary if the `qmark-noglob` [feature flag](#featureflags) is enabled).\n- `\\~` escapes the tilde character.\n- `\\#` escapes the hash character.\n- `\\(` escapes the left parenthesis character.\n- `\\)` escapes the right parenthesis character.\n- `\\{` escapes the left curly bracket character.\n- `\\}` escapes the right curly bracket character.\n- `\\[` escapes the left bracket character.\n- `\\]` escapes the right bracket character.\n- `\\<` escapes the less than character.\n- `\\>` escapes the more than character.\n- `\\&` escapes the ampersand character.\n- `\\|` escapes the vertical bar character.\n- `\\;` escapes the semicolon character.\n- `\\\"` escapes the quote character.\n- `\\'` escapes the apostrophe character.\n\nAs a special case, `\\` immediately followed by a literal new line is a “continuation” and tells fish to ignore the line break and resume input at the start of the next line (without introducing any whitespace or terminating a token).\n\n## Input/Output Redirection\n\nMost programs use three input/output (I/O) streams:\n\n- Standard input (stdin) for reading. Defaults to reading from the keyboard.\n- Standard output (stdout) for writing output. Defaults to writing to the screen.\n- Standard error (stderr) for writing errors and warnings. Defaults to writing to the screen.\n\nEach stream has a number called the file descriptor (FD): 0 for stdin, 1 for stdout, and 2 for stderr.\n\nThe destination of a stream can be changed using something called *redirection*. For example, `echo hello > output.txt`, redirects the standard output of the `echo` command to a text file.\n\n- To read standard input from a file, use `<SOURCE_FILE`.\n- To write standard output to a file, use `>DESTINATION`.\n- To write standard error to a file, use `2>DESTINATION`. [\\[1\\]](#id4)\n- To append standard output to a file, use `>>DESTINATION_FILE`.\n- To append standard error to a file, use `2>>DESTINATION_FILE`.\n- To not overwrite (“clobber”) an existing file, use `>?DESTINATION` or `2>?DESTINATION`. This is known as the “noclobber” redirection.\n\n`DESTINATION` can be one of the following:\n\n- A filename to write the output to. Often `>/dev/null` to silence output by writing it to the special “sinkhole” file.\n- An ampersand (`&`) followed by the number of another file descriptor like `&2` for standard error. The output will be written to the destination descriptor.\n- An ampersand followed by a minus sign (`&-`). The file descriptor will be closed. Note: This may cause the program to fail because its writes will be unsuccessful.\n\nAs a convenience, the redirection `&>` can be used to direct both stdout and stderr to the same destination. For example, `echo hello &> all_output.txt` redirects both stdout and stderr to the file `all_output.txt`. This is equivalent to `echo hello > all_output.txt 2>&1`.\n\nAny arbitrary file descriptor can be used in a redirection by prefixing the redirection with the FD number.\n\n- To redirect the input of descriptor N, use `N<DESTINATION`.\n- To redirect the output of descriptor N, use `N>DESTINATION`.\n- To append the output of descriptor N to a file, use `N>>DESTINATION_FILE`.\n\nFor example:\n\n```\n# Write `foo`'s standard error (file descriptor 2)\n# to a file called \"output.stderr\":\nfoo 2> output.stderr\n\n# if $num doesn't contain a number,\n# this test will be false and print an error,\n# so by ignoring the error we can be sure that we're dealing\n# with a number in the \"if\" block:\nif test \"$num\" -gt 2 2>/dev/null\n    # do things with $num as a number greater than 2\nelse\n    # do things if $num is <= 2 or not a number\nend\n\n# Save `make`s output in a file:\nmake &>/log\n\n# Redirections stack and can be used with blocks:\nbegin\n    echo stdout\n    echo stderr >&2 # <- this goes to stderr!\nend >/dev/null # ignore stdout, so this prints \"stderr\"\n```\n\nIt is an error to redirect a builtin, function, or block to a file descriptor above 2. However this is supported for external commands.\n\n\\[[1](#id3)\\]\n\nPrevious versions of fish also allowed specifying this as `^DESTINATION`, but that made another character special so it was deprecated and removed. See [feature flags](#featureflags).\n\n## Piping\n\nAnother way to redirect streams is a *pipe*. A pipe connects streams with each other. Usually the standard output of one command is connected with the standard input of another. This is done by separating commands with the pipe character `|`. For example:\n\n```\ncat foo.txt | head\n```\n\nThe command `cat foo.txt` sends the contents of `foo.txt` to stdout. This output is provided as input for the `head` program, which prints the first 10 lines of its input.\n\nIt is possible to pipe a different output file descriptor by prepending its FD number and the output redirect symbol to the pipe. For example:\n\n```\nmake fish 2>| less\n```\n\nwill attempt to build `fish`, and any errors will be shown using the `less` pager. [\\[2\\]](#id6)\n\nAs a convenience, the pipe `&|` redirects both stdout and stderr to the same process. This is different from bash, which uses `|&`.\n\n\\[[2](#id5)\\]\n\nA “pager” here is a program that takes output and “paginates” it. `less` doesn’t just do pages, it allows arbitrary scrolling (even back!).\n\n## Combining pipes and redirections\n\nIt is possible to use multiple redirections and a pipe at the same time. In that case, they are read in this order:\n\n1.  First the pipe is set up.\n2.  Then the redirections are evaluated from left-to-right.\n\nThis is important when any redirections reference other file descriptors with the `&N` syntax. When you say `>&2`, that will redirect stdout to where stderr is pointing to *at that time*.\n\nConsider this helper function:\n\n```\n# Just make a function that prints something to stdout and stderr\nfunction print\n    echo out\n    echo err >&2\nend\n```\n\nNow let’s see a few cases:\n\n```\n# Redirect both stderr and stdout to less\n# (can also be spelt as `&|`)\nprint 2>&1 | less\n\n# Show the \"out\" on stderr, silence the \"err\"\nprint >&2 2>/dev/null\n\n# Silence both\nprint >/dev/null 2>&1\n```\n\n## Job control\n\nWhen you start a job in fish, fish itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an `&` (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.\n\nExample:\n\n```\nemacs &\n```\n\nwill start the emacs text editor in the background. [fg](cmds/fg) can be used to bring it into the foreground again when needed.\n\nMost programs allow you to suspend the program’s execution and return control to fish by pressing Control+Z (also referred to as `^Z`). Once back at the fish commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the [fg](cmds/fg) (foreground) command.\n\nIf you instead want to put a suspended job into the background, use the [bg](cmds/bg) command.\n\nTo get a listing of all currently started jobs, use the [jobs](cmds/jobs) command. These listed jobs can be removed with the [disown](cmds/disown) command.\n\nAt the moment, functions cannot be started in the background. Functions that are stopped and then restarted in the background using the [bg](cmds/bg) command will not execute correctly.\n\nIf the `&` character is followed by a non-separating character, it is not interpreted as background operator. Separating characters are whitespace and the characters `;<>&|`.\n\n## Functions\n\nFunctions are programs written in the fish syntax. They group together various commands and their arguments using a single name.\n\nFor example, here’s a simple function to list directories:\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nThe first line tells fish to define a function by the name of `ll`, so it can be used by simply writing `ll` on the commandline. The second line tells fish that the command `ls -l $argv` should be called when `ll` is invoked. [\\$argv](#variables-argv) is a [list variable](#variables-lists), which always contains all arguments sent to the function. In the example above, these are simply passed on to the `ls` command. The `end` on the third line ends the definition.\n\nCalling this as `ll /tmp/` will end up running `ls -l /tmp/`, which will list the contents of /tmp.\n\nThis is a kind of function known as an [alias](#syntax-aliases).\n\nFish’s prompt is also defined in a function, called [fish_prompt](cmds/fish_prompt). It is run when the prompt is about to be displayed and its output forms the prompt:\n\n```\nfunction fish_prompt\n    # A simple prompt. Displays the current directory\n    # (which fish stores in the $PWD variable)\n    # and then a user symbol - a '►' for a normal user and a '#' for root.\n    set -l user_char '►'\n    if fish_is_root_user\n        set user_char '#'\n    end\n\n    echo (set_color yellow)$PWD (set_color purple)$user_char\nend\n```\n\nTo edit a function, you can use [funced](cmds/funced), and to save a function [funcsave](cmds/funcsave). This will store it in a function file that fish will [autoload](#syntax-function-autoloading) when needed.\n\nThe [functions](cmds/functions) builtin can show a function’s current definition (and [type](cmds/type) will also do if given a function).\n\nFor more information on functions, see the documentation for the [function](cmds/function) builtin.\n\n### Defining aliases\n\nOne of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the `ls` command to display colors. The switch for turning on colors on GNU systems is `--color=auto`. An alias around `ls` might look like this:\n\n```\nfunction ls\n    command ls --color=auto $argv\nend\n```\n\nThere are a few important things that need to be noted about aliases:\n\n- Always take care to add the [\\$argv](#variables-argv) variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.\n- If the alias has the same name as the aliased command, you need to prefix the call to the program with `command` to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).\n\nTo easily create a function of this form, you can use the [alias](cmds/alias) command. Unlike other shells, this just makes functions - fish has no separate concept of an “alias”, we just use the word for a simple wrapping function like this. [alias](cmds/alias) immediately creates a function. Consider using `alias --save` or [funcsave](cmds/funcsave) to save the created function into an autoload file instead of recreating the alias each time.\n\nFor an alternative, try [abbreviations](interactive#abbreviations). These are words that are expanded while you type, instead of being actual functions inside the shell.\n\n### Autoloading functions\n\nFunctions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:\n\n- An autoloaded function becomes available automatically to all running shells.\n- If the function definition is changed, all running shells will automatically reload the altered version, after a while.\n- Startup time and memory usage is improved, etc.\n\nWhen fish needs to load a function, it searches through any directories in the [list variable](#variables-lists) `$fish_function_path` for a file with a name consisting of the name of the function plus the suffix `.fish` and loads the first it finds.\n\nFor example if you try to execute something called `banana`, fish will go through all directories in \\$fish_function_path looking for a file called `banana.fish` and load the first one it finds.\n\nBy default `$fish_function_path` contains the following:\n\n- A directory for users to keep their own functions, usually `~/.config/fish/functions` (controlled by the `XDG_CONFIG_HOME` environment variable).\n- A directory for functions for all users on the system, usually `/etc/fish/functions` (really `$__fish_sysconfdir/functions`).\n- Directories for other software to put their own functions. These are in the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable) and in the `XDG_DATA_DIRS` environment variable, in a subdirectory called `fish/vendor_functions.d`. The default value for `XDG_DATA_DIRS` is usually `/usr/share/fish/vendor_functions.d` and `/usr/local/share/fish/vendor_functions.d`.\n- The functions shipped with fish, usually installed in `/usr/share/fish/functions` (really `$__fish_data_dir/functions`).\n\nIf you are unsure, your functions probably belong in `~/.config/fish/functions`.\n\nAs we’ve explained, autoload files are loaded *by name*, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.\n\nAutoloading also won’t work for [event handlers](#event), since fish cannot know that a function is supposed to be executed when an event occurs when it hasn’t yet loaded the function. See the [event handlers](#event) section for more information.\n\nIf a file of the right name doesn’t define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in \\$fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.\n\nIf you are developing another program and want to install fish functions for it, install them to the “vendor” functions directory. As this path varies from system to system, you can use `pkgconfig` to discover it with the output of `pkg-config --variable functionsdir fish`. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.\n\n## Comments\n\nAnything after a `#` until the end of the line is a comment. That means it’s purely for the reader’s benefit, fish ignores it.\n\nThis is useful to explain what and why you are doing something:\n\n```\nfunction ls\n    # The function is called ls,\n    # so we have to explicitly call `command ls` to avoid calling ourselves.\n    command ls --color=auto $argv\nend\n```\n\nThere are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a `#`.\n\nComments can also appear after a line like so:\n\n```\nset -gx EDITOR emacs # I don't like vim.\n```\n\n## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 10. Tab Completions
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 11. Conditions
  summary: 'Fish has some builtins that let you execute commands only if a specific criterion is met: if, switch, and and or, and also the familiar &&/|| syntax'
  belongs_to: 7. Combining pipes and redirections
  description: "## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 11. Navigating directories
  summary: Fish prides itself on being really nice to use interactively
  description: "# Interactive use\n\nFish prides itself on being really nice to use interactively. That’s down to a few features we’ll explain in the next few sections.\n\nFish is used by giving commands in the fish language, see [The Fish Language](language#language) for information on that.\n\n## Help\n\nFish has an extensive help system. Use the [help](cmds/help) command to obtain help on a specific subject or command. For instance, writing `help syntax` displays the [syntax section](language#syntax) of this documentation.\n\nFish also has man pages for its commands, and translates the help pages to man pages. For example, `man set` will show the documentation for `set` as a man page.\n\nHelp on a specific builtin can also be obtained with the `-h` parameter. For instance, to obtain help on the [fg](cmds/fg) builtin, either type `fg -h` or `help fg`.\n\nThe main page can be viewed via `help index` (or just `help`) or `man fish-doc`. The tutorial can be viewed with `help tutorial` or `man fish-tutorial`.\n\n## Autosuggestions\n\nfish suggests commands as you type, based on [command history](#history-search), completions, and valid file paths. As you type commands, you will see a suggestion offered after the cursor, in a muted gray color (which can be changed with the `fish_color_autosuggestion` variable).\n\nTo accept the autosuggestion (replacing the command line contents), press → or Control+F. To accept the first suggested word, press Alt+→ or Alt+F. If the autosuggestion is not what you want, just ignore it: it won’t execute unless you accept it.\n\nAutosuggestions are a powerful way to quickly summon frequently entered commands, by typing the first few characters. They are also an efficient technique for navigating through directory hierarchies.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completion\n\nTab completion is a time saving feature of any modern shell. When you type Tab, fish tries to guess the rest of the word under the cursor. If it finds just one possibility, it inserts it. If it finds more, it inserts the longest unambiguous part and then opens a menu (the “pager”) that you can navigate to find what you’re looking for.\n\nThe pager can be navigated with the arrow keys, Page Up / Page Down, Tab or Shift+Tab. Pressing Control+S (the `pager-toggle-search` binding - / in vi-mode) opens up a search menu that you can use to filter the list.\n\nFish provides some general purpose completions, like for commands, variable names, usernames or files.\n\nIt also provides a large number of program specific scripted completions. Most of these completions are simple options like the `-l` option for `ls`, but a lot are more advanced. For example:\n\n- `man` and `whatis` show the installed manual pages as completions.\n- `make` uses targets in the Makefile in the current directory as completions.\n- `mount` uses mount points specified in fstab as completions.\n- `apt`, `rpm` and `yum` show installed or installable packages\n\nYou can also write your own completions or install some you got from someone else. For that, see [Writing your own completions](completions#completion-own).\n\nCompletion scripts are loaded on demand, just like [functions are](language#syntax-function-autoloading). The difference is the `$fish_complete_path` [list](language#variables-lists) is used instead of `$fish_function_path`. Typically you can drop new completions in ~/.config/fish/completions/name-of-command.fish and fish will find them automatically.\n\n## Syntax highlighting\n\nFish interprets the command line as it is typed and uses syntax highlighting to provide feedback. The most important feedback is the detection of potential errors. By default, errors are marked red.\n\nDetected errors include:\n\n- Non-existing commands.\n- Reading from or appending to a non-existing file.\n- Incorrect use of output redirects\n- Mismatched parenthesis\n\nTo customize the syntax highlighting, you can set the environment variables listed in the [Variables for changing highlighting colors](#variables-color) section.\n\nFish also provides pre-made color themes you can pick with [fish_config](cmds/fish_config). Running just `fish_config` opens a browser interface, or you can use `fish_config theme` in the terminal.\n\nFor example, to disable nearly all coloring:\n\n```\nfish_config theme choose none\n```\n\nOr, to see all themes, right in your terminal:\n\n```\nfish_config theme show\n```\n\n### Syntax highlighting variables\n\nThe colors used by fish for syntax highlighting can be configured by changing the values of various variables. The value of these variables can be one of the colors accepted by the [set_color](cmds/set_color) command. The modifier switches accepted by `set_color` like `--bold`, `--dim`, `--italics`, `--reverse` and `--underline` are also accepted.\n\nExample: to make errors highlighted and red, use:\n\n```\nset fish_color_error red --bold\n```\n\nThe following variables are available to change the highlighting colors in fish:\n\n| Variable                     | Meaning                                                                |\n|------------------------------|------------------------------------------------------------------------|\n| `fish_color_normal`          | default color                                                          |\n| `fish_color_command`         | commands like echo                                                     |\n| `fish_color_keyword`         | keywords like if - this falls back on the command color if unset       |\n| `fish_color_quote`           | quoted text like `\"abc\"`                                               |\n| `fish_color_redirection`     | IO redirections like \\>/dev/null                                       |\n| `fish_color_end`             | process separators like `;` and `&`                                    |\n| `fish_color_error`           | syntax errors                                                          |\n| `fish_color_param`           | ordinary command parameters                                            |\n| `fish_color_valid_path`      | parameters that are filenames (if the file exists)                     |\n| `fish_color_option`          | options starting with “-”, up to the first “--” parameter              |\n| `fish_color_comment`         | comments like ‘# important’                                            |\n| `fish_color_selection`       | selected text in vi visual mode                                        |\n| `fish_color_operator`        | parameter expansion operators like `*` and `~`                         |\n| `fish_color_escape`          | character escapes like `\\n` and `\\x70`                                 |\n| `fish_color_autosuggestion`  | autosuggestions (the proposed rest of a command)                       |\n| `fish_color_cwd`             | the current working directory in the default prompt                    |\n| `fish_color_cwd_root`        | the current working directory in the default prompt for the root user  |\n| `fish_color_user`            | the username in the default prompt                                     |\n| `fish_color_host`            | the hostname in the default prompt                                     |\n| `fish_color_host_remote`     | the hostname in the default prompt for remote sessions (like ssh)      |\n| `fish_color_status`          | the last command’s nonzero exit code in the default prompt             |\n| `fish_color_cancel`          | the ‘^C’ indicator on a canceled command                               |\n| `fish_color_search_match`    | history search matches and selected pager items (background only)      |\n| `fish_color_history_current` | the current position in the history for commands like `dirh` and `cdh` |\n\nIf a variable isn’t set or is empty, fish usually tries `$fish_color_normal`, except for:\n\n- `$fish_color_keyword`, where it tries `$fish_color_command` first.\n- `$fish_color_option`, where it tries `$fish_color_param` first.\n- For `$fish_color_valid_path`, if that doesn’t have a color, but only modifiers, it adds those to the color that would otherwise be used, like `$fish_color_param`. But if valid paths have a color, it uses that and adds in modifiers from the other color.\n\n### Pager color variables\n\nfish will sometimes present a list of choices in a table, called the pager.\n\nExample: to set the background of each pager row, use:\n\n```\nset fish_pager_color_background --background=white\n```\n\nTo have black text on alternating white and gray backgrounds:\n\n```\nset fish_pager_color_prefix black\nset fish_pager_color_completion black\nset fish_pager_color_description black\nset fish_pager_color_background --background=white\nset fish_pager_color_secondary_background --background=brwhite\n```\n\nVariables affecting the pager colors:\n\n| Variable                                 | Meaning                                                     |\n|------------------------------------------|-------------------------------------------------------------|\n| `fish_pager_color_progress`              | the progress bar at the bottom left corner                  |\n| `fish_pager_color_background`            | the background color of a line                              |\n| `fish_pager_color_prefix`                | the prefix string, i.e. the string that is to be completed  |\n| `fish_pager_color_completion`            | the completion itself, i.e. the proposed rest of the string |\n| `fish_pager_color_description`           | the completion description                                  |\n| `fish_pager_color_selected_background`   | background of the selected completion                       |\n| `fish_pager_color_selected_prefix`       | prefix of the selected completion                           |\n| `fish_pager_color_selected_completion`   | suffix of the selected completion                           |\n| `fish_pager_color_selected_description`  | description of the selected completion                      |\n| `fish_pager_color_secondary_background`  | background of every second unselected completion            |\n| `fish_pager_color_secondary_prefix`      | prefix of every second unselected completion                |\n| `fish_pager_color_secondary_completion`  | suffix of every second unselected completion                |\n| `fish_pager_color_secondary_description` | description of every second unselected completion           |\n\nWhen the secondary or selected variables aren’t set or are empty, the normal variables are used, except for `$fish_pager_color_selected_background`, where the background of `$fish_color_search_match` is tried first.\n\n## Abbreviations\n\nTo avoid needless typing, a frequently-run command like `git checkout` can be abbreviated to `gco` using the [abbr](cmds/abbr) command.\n\n```\nabbr -a gco git checkout\n```\n\nAfter entering `gco` and pressing Space or Enter, a `gco` in command position will turn into `git checkout` in the command line. If you want to use a literal `gco` sometimes, use Control+Space [\\[1\\]](#id5).\n\nThis is a lot more powerful, for example you can make going up a number of directories easier with this:\n\n```\nfunction multicd\n    echo cd (string repeat -n (math (string length -- $argv[1]) - 1) ../)\nend\nabbr --add dotdot --regex '^\\.\\.+$' --function multicd\n```\n\nNow, `..` transforms to `cd ../`, while `...` turns into `cd ../../` and `....` expands to `cd ../../../`.\n\nThe advantage over aliases is that you can see the actual command before using it, add to it or change it, and the actual command will be stored in history.\n\n\\[[1](#id4)\\]\n\nAny binding that executes the `expand-abbr` or `execute` [bind function](cmds/bind) will expand abbreviations. By default Control+Space is bound to just inserting a space.\n\n## Programmable title\n\nWhen using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window. This can be done automatically in fish by defining the [fish_title](cmds/fish_title) function. The [fish_title](cmds/fish_title) function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message. The [status current-command](cmds/status) builtin will always return the name of the job to be put into the foreground (or `fish` if control is returning to the shell) when the [fish_prompt](cmds/fish_prompt) function is called. The first argument to fish_title will contain the most recently executed foreground command as a string.\n\nThe default fish title shows the hostname if connected via ssh, the currently running command (unless it is fish) and the current working directory. All of this is shortened to not make the tab too wide.\n\nExamples:\n\nTo show the last command and working directory in the title:\n\n```\nfunction fish_title\n    # `prompt_pwd` shortens the title. This helps prevent tabs from becoming very wide.\n    echo $argv[1] (prompt_pwd)\n    pwd\nend\n```\n\n## Programmable prompt\n\nWhen it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt. It does this by running the [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) functions.\n\nThe output of the former is displayed on the left and the latter’s output on the right side of the terminal. The output of [fish_mode_prompt](cmds/fish_mode_prompt) will be prepended on the left, though the default function only does this when in [vi-mode](#vi-mode).\n\n## Configurable greeting\n\nWhen it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):\n\n```\nset -U fish_greeting\n```\n\nor you can set it [globally](language#variables-scope) in [config.fish](language#configuration):\n\n```\nset -g fish_greeting 'Hey, stranger!'\n```\n\nor you can script it by changing the function:\n\n```\nfunction fish_greeting\n    random choice \"Hello!\" \"Hi\" \"G'day\" \"Howdy\"\nend\n```\n\nsave this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.\n\n## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: 11. Variables
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 12. Exports (Shell Variables)
  summary: Sometimes you need to have a variable available to an external command, often as a setting
  belongs_to: 1. Why fish?
  description: "## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 12. Loops and blocks
  summary: Like most programming language, fish also has the familiar while and for loops
  belongs_to: 7. Combining pipes and redirections
  description: "## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 13. Lists
  summary: The set command above used quotes to ensure that Mister Noodle was one argument
  belongs_to: 1. Why fish?
  description: "## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 13. Parameter expansion
  summary: When fish is given a commandline, it expands the parameters before sending them to the command
  belongs_to: 7. Combining pipes and redirections
  description: "## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 14. Command Substitutions
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 14. Shell variables
  summary: Variables are a way to save data and pass it around
  belongs_to: 7. Combining pipes and redirections
  description: |-
    ## Shell variables

    Variables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.

    To set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.

    Example:

    To set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.

    After a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).

    Example:

    ```
    set smurf_color blue
    echo Smurfs are usually $smurf_color
    set pants_color red
    echo Papa smurf, who is $smurf_color, wears $pants_color pants
    ```

    So you set a variable with `set`, and use it with a `$` and the name.
- name: 15. Builtin commands
  summary: Fish includes a number of commands in the shell directly
  belongs_to: 7. Combining pipes and redirections
  description: "## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 15. Separating Commands (Semicolon)
  summary: Like other shells, fish allows multiple commands either on separate lines or the same line
  belongs_to: 1. Why fish?
  description: "## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 16. Command lookup
  summary: When fish is told to run something, it goes through multiple steps to find it
  belongs_to: 7. Combining pipes and redirections
  description: "## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 16. Exit Status
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 17. Combiners (And, Or, Not)
  summary: 'fish supports the familiar && and || to combine commands, and ! to negate them:'
  belongs_to: 1. Why fish?
  description: "## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 17. Querying for user input
  summary: Sometimes, you want to ask the user for input, for instance to confirm something
  belongs_to: 7. Combining pipes and redirections
  description: |-
    ## Querying for user input

    Sometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.

    Let’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:

    ```
    function show_files
        # This will glob on all arguments. Any non-directories will be ignored.
        set -l files $argv/*

        # If there are more than 5 files
        if test (count $files) -gt 5
            # and both stdin (for reading input) and stdout (for writing the prompt)
            # are terminals
            and isatty stdin
            and isatty stdout
            # Keep asking until we get a valid response
            while read --nchars 1 -l response --prompt-str="Are you sure? (y/n)"
                  or return 1 # if the read was aborted with ctrl-c/ctrl-d
                switch $response
                    case y Y
                        echo Okay
                        # We break out of the while and go on with the function
                        break
                    case n N
                        # We return from the function without printing
                        echo Not showing
                        return 1
                    case '*'
                        # We go through the while loop and ask again
                        echo Not valid input
                        continue
                end
            end
        end

        # And now we print the files
        printf '%s\n' $files
    end
    ```

    If you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.
- name: 18. Conditionals (If, Else, Switch)
  summary: Use if and else to conditionally execute code, based on the exit status of a command
  belongs_to: 1. Why fish?
  description: "## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 18. Shell variable and function names
  summary: 'The names given to variables and functions (so-called “identifiers”) have to follow certain rules:'
  belongs_to: 7. Combining pipes and redirections
  description: |-
    ## Shell variable and function names

    The names given to variables and functions (so-called “identifiers”) have to follow certain rules:

    - A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.
    - A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.
    - A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.

    Other things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).
- name: 19. Configuration files
  summary: When fish is started, it reads and runs its configuration files
  belongs_to: 7. Combining pipes and redirections
  description: |-
    ## Configuration files

    When fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.

    The main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).

    Configuration files are run in the following order:

    - Configuration snippets (named `*.fish`) in the directories:

      - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)

      - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)

      - Directories for others to ship configuration snippets for their software:

        - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)
        - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)

        These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.

      If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).

    - System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).

    - User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).

    `~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.

    These files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.

    If you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.

    For system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.
- name: 19. Functions
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 20. Future feature flags
  summary: Feature flags are how fish stages changes that might break scripts
  belongs_to: 7. Combining pipes and redirections
  description: "## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 20. Loops
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 21. Event handlers
  summary: When defining a new function in fish, it is possible to make it into an event handler, i.e
  belongs_to: 7. Combining pipes and redirections
  description: "## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 21. Prompt
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 22. $PATH
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 22. Debugging fish scripts
  summary: Fish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point
  belongs_to: 7. Combining pipes and redirections
  description: "## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: 23. Startup (Where’s .bashrc?)
  summary: Fish starts by executing commands in ~/.config/fish/config.fish
  belongs_to: 1. Why fish?
  description: "## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 24. Autoloading Functions
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 25. Universal Variables
  summary: A universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot
  belongs_to: 1. Why fish?
  description: "## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: 26. Ready for more?
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: _
  summary: _ translates its arguments into the current language, if possible
  description: "# \\_ - call fish’s translations\n\n## Synopsis\n\n```\n_ STRING\n```\n\n## Description\n\n`_` translates its arguments into the current language, if possible.\n\nIt is equivalent to `gettext fish STRING`, meaning it can only be used to look up fish’s own translations.\n\nIt requires fish to be built with gettext support. If that support is disabled, or there is no translation it will simply echo the argument back.\n\nThe language depends on the current locale, set with [`LANG`](../language#envvar-LANG) and [`LC_MESSAGES`](../language#envvar-LC_MESSAGES).\n\n## Options\n\n`_` takes no options.\n\n## Examples\n\n```\n> _ File\nDatei\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/\\_.html](https://fishshell.com/docs/3.7/cmds/_.html)"
- name: abbr
  summary: abbr manages abbreviations - user-defined words that are replaced with longer phrases when entered
  description: "# abbr - manage fish abbreviations\n\n## Synopsis\n\n```\nabbr --add NAME [--position command | anywhere] [-r | --regex PATTERN]\n                [--set-cursor[=MARKER]] ([-f | --function FUNCTION] | EXPANSION)\nabbr --erase NAME ...\nabbr --rename OLD_WORD NEW_WORD\nabbr --show\nabbr --list\nabbr --query NAME ...\n```\n\n## Description\n\n`abbr` manages abbreviations - user-defined words that are replaced with longer phrases when entered.\n\nNote\n\nOnly typed-in commands use abbreviations. Abbreviations are not expanded in scripts.\n\nFor example, a frequently-run command like `git checkout` can be abbreviated to `gco`. After entering `gco` and pressing Space or Enter, the full text `git checkout` will appear in the command line. To avoid expanding something that looks like an abbreviation, the default Control+Space binding inserts a space without expanding.\n\nAn abbreviation may match a literal word, or it may match a pattern given by a regular expression. When an abbreviation matches a word, that word is replaced by new text, called its *expansion*. This expansion may be a fixed new phrase, or it can be dynamically created via a fish function. This expansion occurs after pressing space or enter.\n\nCombining these features, it is possible to create custom syntaxes, where a regular expression recognizes matching tokens, and the expansion function interprets them. See the [Examples](#examples) section.\n\nChanged in version 3.6.0: Previous versions of this allowed saving abbreviations in universal variables. That’s no longer possible. Existing variables will still be imported and `abbr --erase` will also erase the variables. We recommend adding abbreviations to [config.fish](../language#configuration) by just adding the `abbr --add` command. When you run `abbr`, you will see output like this\n\n```\n> abbr\nabbr -a -- foo bar # imported from a universal variable, see `help abbr`\n```\n\nIn that case you should take the part before the `#` comment and save it in [config.fish](../language#configuration), then you can run `abbr --erase` to remove the universal variable:\n\n```\n> abbr >> ~/.config/fish/config.fish\n> abbr --erase (abbr --list)\n```\n\n## “add” subcommand\n\n```\nabbr [-a | --add] NAME [--position command | anywhere] [-r | --regex PATTERN]\n     [--set-cursor[=MARKER]] ([-f | --function FUNCTION] | EXPANSION)\n```\n\n`abbr --add` creates a new abbreviation. With no other options, the string **NAME** is replaced by **EXPANSION**.\n\nWith **--position command**, the abbreviation will only expand when it is positioned as a command, not as an argument to another command. With **--position anywhere** the abbreviation may expand anywhere in the command line. The default is **command**.\n\nWith **--regex**, the abbreviation matches using the regular expression given by **PATTERN**, instead of the literal **NAME**. The pattern is interpreted using PCRE2 syntax and must match the entire token. If multiple abbreviations match the same token, the last abbreviation added is used.\n\nWith **--set-cursor=MARKER**, the cursor is moved to the first occurrence of **MARKER** in the expansion. The **MARKER** value is erased. The **MARKER** may be omitted (i.e. simply `--set-cursor`), in which case it defaults to `%`.\n\nWith **-f FUNCTION** or **--function FUNCTION**, **FUNCTION** is treated as the name of a fish function instead of a literal replacement. When the abbreviation matches, the function will be called with the matching token as an argument. If the function’s exit status is 0 (success), the token will be replaced by the function’s output; otherwise the token will be left unchanged. No **EXPANSION** may be given separately.\n\n### Examples\n\n```\nabbr --add gco git checkout\n```\n\nAdd a new abbreviation where `gco` will be replaced with `git checkout`.\n\n```\nabbr -a --position anywhere -- -C --color\n```\n\nAdd a new abbreviation where `-C` will be replaced with `--color`. The `--` allows `-C` to be treated as the name of the abbreviation, instead of an option.\n\n```\nabbr -a L --position anywhere --set-cursor \"% | less\"\n```\n\nAdd a new abbreviation where `L` will be replaced with `| less`, placing the cursor before the pipe.\n\n```\nfunction last_history_item\n    echo $history[1]\nend\nabbr -a !! --position anywhere --function last_history_item\n```\n\nThis first creates a function `last_history_item` which outputs the last entered command. It then adds an abbreviation which replaces `!!` with the result of calling this function. Taken together, this is similar to the `!!` history expansion feature of bash.\n\n```\nfunction vim_edit\n    echo vim $argv\nend\nabbr -a vim_edit_texts --position command --regex \".+\\.txt\" --function vim_edit\n```\n\nThis first creates a function `vim_edit` which prepends `vim` before its argument. It then adds an abbreviation which matches commands ending in `.txt`, and replaces the command with the result of calling this function. This allows text files to be “executed” as a command to open them in vim, similar to the “suffix alias” feature in zsh.\n\n```\nabbr 4DIRS --set-cursor=! \"$(string join \\n -- 'for dir in */' 'cd $dir' '!' 'cd ..' 'end')\"\n```\n\nThis creates an abbreviation “4DIRS” which expands to a multi-line loop “template.” The template enters each directory and then leaves it. The cursor is positioned ready to enter the command to run in each directory, at the location of the `!`, which is itself erased.\n\n## Other subcommands\n\n```\nabbr --rename OLD_NAME NEW_NAME\n```\n\nRenames an abbreviation, from *OLD_NAME* to *NEW_NAME*\n\n```\nabbr [-s | --show]\n```\n\nShow all abbreviations in a manner suitable for import and export\n\n```\nabbr [-l | --list]\n```\n\nPrints the names of all abbreviation\n\n```\nabbr [-e | --erase] NAME\n```\n\nErases the abbreviation with the given name\n\n```\nabbr -q or --query [NAME...]\n```\n\nReturn 0 (true) if one of the *NAME* is an abbreviation.\n\n```\nabbr -h or --help\n```\n\nDisplays help for the `abbr` command.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/abbr.html](https://fishshell.com/docs/3.7/cmds/abbr.html)"
- name: alias
  summary: alias is a simple wrapper for the function builtin, which creates a function wrapping a command
  description: "# alias - create a function\n\n## Synopsis\n\n```\nalias\nalias [--save] NAME DEFINITION\nalias [--save] NAME=DEFINITION\n```\n\n## Description\n\n`alias` is a simple wrapper for the `function` builtin, which creates a function wrapping a command. It has similar syntax to POSIX shell `alias`. For other uses, it is recommended to define a [function](function).\n\nIf you want to ease your interactive use, to save typing, consider using an [abbreviation](abbr) instead.\n\n`fish` marks functions that have been created by `alias` by including the command used to create them in the function description. You can list `alias`-created functions by running `alias` without arguments. They must be erased using `functions -e`.\n\n- `NAME` is the name of the alias\n- `DEFINITION` is the actual command to execute. `alias` automatically appends `$argv`, so that all parameters used with the alias are passed to the actual command.\n\nYou cannot create an alias to a function with the same name. Note that spaces need to be escaped in the call to `alias` just like at the command line, *even inside quoted parts*.\n\nThe following options are available:\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n**-s** or **--save**  \nSaves the function created by the alias into your fish configuration directory using [funcsave](funcsave).\n\n## Example\n\nThe following code will create `rmi`, which runs `rm` with additional arguments on every invocation.\n\n```\nalias rmi=\"rm -i\"\n\n# This is equivalent to entering the following function:\nfunction rmi --wraps rm --description 'alias rmi=rm -i'\n    rm -i $argv\nend\n\n# This needs to have the spaces escaped or \"Chrome.app...\"\n# will be seen as an argument to \"/Applications/Google\":\nalias chrome='/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome banana'\n```\n\n## See more\n\n1.  The [function](function) command this builds on.\n2.  [Functions](../language#syntax-function).\n3.  [Defining aliases](../language#syntax-aliases).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/alias.html](https://fishshell.com/docs/3.7/cmds/alias.html)"
- name: and
  summary: and is used to execute a command if the previous command was successful (returned a status of 0)
  description: "# and - conditionally execute a command\n\n## Synopsis\n\n```\nPREVIOUS; and COMMAND\n```\n\n## Description\n\n`and` is used to execute a command if the previous command was successful (returned a status of 0).\n\n`and` statements may be used as part of the condition in an [while](while) or [if](if) block.\n\n`and` does not change the current exit status itself, but the command it runs most likely will. The exit status of the last foreground command to exit can always be accessed using the [\\$status](../language#variables-status) variable.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\nThe following code runs the `make` command to build a program. If the build succeeds, `make`’s exit status is 0, and the program is installed. If either step fails, the exit status is 1, and `make clean` is run, which removes the files created by the build process.\n\n```\nmake; and make install; or make clean\n```\n\n## See Also\n\n- [or](or) command\n- [not](not) command\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/and.html](https://fishshell.com/docs/3.7/cmds/and.html)"
- name: argparse
  summary: This command makes it easy for fish scripts and functions to handle arguments
  description: "# argparse - parse options passed to a fish script or function\n\n## Synopsis\n\n```\nargparse [OPTIONS] OPTION_SPEC ... -- [ARG ...]\n```\n\n## Description\n\nThis command makes it easy for fish scripts and functions to handle arguments. You pass arguments that define the known options, followed by a literal **--**, then the arguments to be parsed (which might also include a literal **--**). `argparse` then sets variables to indicate the passed options with their values, and sets `$argv` to the remaining arguments. See the [usage](#cmd-argparse-usage) section below.\n\nEach option specification (`OPTION_SPEC`) is written in the [domain specific language](#cmd-argparse-option-specification) described below. All OPTION_SPECs must appear after any argparse flags and before the `--` that separates them from the arguments to be parsed.\n\nEach option that is seen in the ARG list will result in variables named `_flag_X`, where **X** is the short flag letter and the long flag name (if they are defined). For example a **--help** option could cause argparse to define one variable called `_flag_h` and another called `_flag_help`.\n\nThe variables will be set with local scope (i.e., as if the script had done `set -l _flag_X`). If the flag is a boolean (that is, it just is passed or not, it doesn’t have a value) the values are the short and long flags seen. If the option is not a boolean the values will be zero or more values corresponding to the values collected when the ARG list is processed. If the flag was not seen the flag variable will not be set.\n\n## Options\n\nThe following `argparse` options are available. They must appear before all *OPTION_SPEC*s:\n\n**-n** or **--name**  \nThe command name for use in error messages. By default the current function name will be used, or `argparse` if run outside of a function.\n\n**-x** or **--exclusive** *OPTIONS*  \nA comma separated list of options that are mutually exclusive. You can use this more than once to define multiple sets of mutually exclusive options.\n\n**-N** or **--min-args** *NUMBER*  \nThe minimum number of acceptable non-option arguments. The default is zero.\n\n**-X** or **--max-args** *NUMBER*  \nThe maximum number of acceptable non-option arguments. The default is infinity.\n\n**-i** or **--ignore-unknown**  \nIgnores unknown options, keeping them and their arguments in \\$argv instead.\n\n**-s** or **--stop-nonopt**  \nCauses scanning the arguments to stop as soon as the first non-option argument is seen. Among other things, this is useful to implement subcommands that have their own options.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## Usage\n\nTo use this command, pass the option specifications (**OPTION_SPEC**), a mandatory **--**, and then the arguments to be parsed.\n\nA simple example:\n\n```\nargparse --name=my_function 'h/help' 'n/name=' -- $argv\nor return\n```\n\nIf `$argv` is empty then there is nothing to parse and `argparse` returns zero to indicate success. If `$argv` is not empty then it is checked for flags `-h`, `--help`, `-n` and `--name`. If they are found they are removed from the arguments and local variables called `_flag_OPTION` are set so the script can determine which options were seen. If `$argv` doesn’t have any errors, like a missing mandatory value for an option, then `argparse` exits with a status of zero. Otherwise it writes appropriate error messages to stderr and exits with a status of one.\n\nThe `or return` means that the function returns `argparse`’s status if it failed, so if it goes on `argparse` succeeded.\n\nThe `--` argument is required. You do not have to include any option specifications or arguments after the `--` but you must include the `--`. For example, this is acceptable:\n\n```\nset -l argv foo\nargparse 'h/help' 'n/name' -- $argv\nargparse --min-args=1 -- $argv\n```\n\nBut this is not:\n\n```\nset -l argv\nargparse 'h/help' 'n/name' $argv\n```\n\nThe first `--` seen is what allows the `argparse` command to reliably separate the option specifications and options to `argparse` itself (like `--ignore-unknown`) from the command arguments, so it is required.\n\n## Option Specifications\n\nEach option specification consists of:\n\n- An optional alphanumeric short flag character, followed by a `/` if the short flag can be used by someone invoking your command or, for backwards compatibility, a `-` if it should not be exposed as a valid short flag (in which case it will also not be exposed as a flag variable).\n\n- An optional long flag name, which if not present the short flag can be used, and if that is also not present, an error is reported\n\n- Nothing if the flag is a boolean that takes no argument or is an integer flag, or\n\n  - **=** if it requires a value and only the last instance of the flag is saved, or\n  - **=?** if it takes an optional value and only the last instance of the flag is saved, or\n  - **=+** if it requires a value and each instance of the flag is saved.\n\n- Optionally a `!` followed by fish script to validate the value. Typically this will be a function to run. If the exit status is zero the value for the flag is valid. If non-zero the value is invalid. Any error messages should be written to stdout (not stderr). See the section on [Flag Value Validation](#flag-value-validation) for more information.\n\nSee the [fish_opt](fish_opt) command for a friendlier but more verbose way to create option specifications.\n\nIf a flag is not seen when parsing the arguments then the corresponding \\_flag_X var(s) will not be set.\n\n## Integer flag\n\nSometimes commands take numbers directly as options, like `foo -55`. To allow this one option spec can have the `#` modifier so that any integer will be understood as this flag, and the last number will be given as its value (as if `=` was used).\n\nThe `#` must follow the short flag letter (if any), and other modifiers like `=` are not allowed, except for `-` (for backwards compatibility):\n\n```\nm#maximum\n```\n\nThis does not read numbers given as `+NNN`, only those that look like flags - `-NNN`.\n\n## Note: Optional arguments\n\nAn option defined with `=?` can take optional arguments. Optional arguments have to be *directly attached* to the option they belong to.\n\nThat means the argument will only be used for the option if you use it like:\n\n```\ncmd --flag=value\n# or\ncmd  -fvalue\n```\n\nbut not if used like:\n\n```\ncmd --flag value\n# \"value\" here will be used as a positional argument\n# and \"--flag\" won't have an argument.\n```\n\nIf this weren’t the case, using an option without an optional argument would be difficult if you also wanted to use positional arguments.\n\nFor example:\n\n```\ngrep --color auto\n# Here \"auto\" will be used as the search string,\n# \"color\" will not have an argument and will fall back to the default,\n# which also *happens to be* auto.\ngrep --color always\n# Here grep will still only use color \"auto\"matically\n# and search for the string \"always\".\n```\n\nThis isn’t specific to argparse but common to all things using `getopt(3)` (if they have optional arguments at all). That `grep` example is how GNU grep actually behaves.\n\n## Flag Value Validation\n\nSometimes you need to validate the option values. For example, that it is a valid integer within a specific range, or an ip address, or something entirely different. You can always do this after `argparse` returns but you can also request that `argparse` perform the validation by executing arbitrary fish script. To do so simply append an `!` (exclamation-mark) then the fish script to be run. When that code is executed three vars will be defined:\n\n- `_argparse_cmd` will be set to the value of the value of the `argparse --name` value.\n- `_flag_name` will be set to the short or long flag that being processed.\n- `_flag_value` will be set to the value associated with the flag being processed.\n\nThese variables are passed to the function as local exported variables.\n\nThe script should write any error messages to stdout, not stderr. It should return a status of zero if the flag value is valid otherwise a non-zero status to indicate it is invalid.\n\nFish ships with a `_validate_int` function that accepts a `--min` and `--max` flag. Let’s say your command accepts a `-m` or `--max` flag and the minimum allowable value is zero and the maximum is 5. You would define the option like this: `m/max=!_validate_int --min 0 --max 5`. The default if you just call `_validate_int` without those flags is to simply check that the value is a valid integer with no limits on the min or max value allowed.\n\nHere are some examples of flag validations:\n\n```\n# validate that a path is a directory\nargparse 'p/path=!test -d \"$_flag_value\"' -- --path $__fish_config_dir\n# validate that a function does not exist\nargparse 'f/func=!not functions -q \"$_flag_value\"' -- -f alias\n# validate that a string matches a regex\nargparse 'c/color=!string match -rq \\'^#?[0-9a-fA-F]{6}$\\' \"$_flag_value\"' -- -c 'c0ffee'\n# validate with a validator function\nargparse 'n/num=!_validate_int --min 0 --max 99' -- --num 42\n```\n\n## Example OPTION_SPECs\n\nSome *OPTION_SPEC* examples:\n\n- `h/help` means that both `-h` and `--help` are valid. The flag is a boolean and can be used more than once. If either flag is used then `_flag_h` and `_flag_help` will be set to however either flag was seen, as many times as it was seen. So it could be set to `-h`, `-h` and `--help`, and `count $_flag_h` would yield “3”.\n- `help` means that only `--help` is valid. The flag is a boolean and can be used more than once. If it is used then `_flag_help` will be set as above. Also `h-help` (with an arbitrary short letter) for backwards compatibility.\n- `longonly=` is a flag `--longonly` that requires an option, there is no short flag or even short flag variable.\n- `n/name=` means that both `-n` and `--name` are valid. It requires a value and can be used at most once. If the flag is seen then `_flag_n` and `_flag_name` will be set with the single mandatory value associated with the flag.\n- `n/name=?` means that both `-n` and `--name` are valid. It accepts an optional value and can be used at most once. If the flag is seen then `_flag_n` and `_flag_name` will be set with the value associated with the flag if one was provided else it will be set with no values.\n- `name=+` means that only `--name` is valid. It requires a value and can be used more than once. If the flag is seen then `_flag_name` will be set with the values associated with each occurrence.\n- `x` means that only `-x` is valid. It is a boolean that can be used more than once. If it is seen then `_flag_x` will be set as above.\n- `x=`, `x=?`, and `x=+` are similar to the n/name examples above but there is no long flag alternative to the short flag `-x`.\n- `#max` (or `#-max`) means that flags matching the regex “^--?\\d+\\$” are valid. When seen they are assigned to the variable `_flag_max`. This allows any valid positive or negative integer to be specified by prefixing it with a single “-”. Many commands support this idiom. For example `head -3 /a/file` to emit only the first three lines of /a/file.\n- `n#max` means that flags matching the regex “^--?\\d+\\$” are valid. When seen they are assigned to the variables `_flag_n` and `_flag_max`. This allows any valid positive or negative integer to be specified by prefixing it with a single “-”. Many commands support this idiom. For example `head -3 /a/file` to emit only the first three lines of /a/file. You can also specify the value using either flag: `-n NNN` or `--max NNN` in this example.\n- `#longonly` causes the last integer option to be stored in `_flag_longonly`.\n\nAfter parsing the arguments the `argv` variable is set with local scope to any values not already consumed during flag processing. If there are no unbound values the variable is set but `count $argv` will be zero.\n\nIf an error occurs during argparse processing it will exit with a non-zero status and print error messages to stderr.\n\n## Limitations\n\nOne limitation with **--ignore-unknown** is that, if an unknown option is given in a group with known options, the entire group will be kept in \\$argv. `argparse` will not do any permutations here.\n\nFor instance:\n\n```\nargparse --ignore-unknown h -- -ho\necho $_flag_h # is -h, because -h was given\necho $argv # is still -ho\n```\n\nThis limitation may be lifted in future.\n\nAdditionally, it can only parse known options up to the first unknown option in the group - the unknown option could take options, so it isn’t clear what any character after an unknown option means.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/argparse.html](https://fishshell.com/docs/3.7/cmds/argparse.html)"
- name: begin
  summary: begin is used to create a new block of code
  description: "# begin - start a new block of code\n\n## Synopsis\n\n```\nbegin; [COMMANDS ...]; end\n```\n\n## Description\n\n`begin` is used to create a new block of code.\n\nA block allows the introduction of a new [variable scope](../language#variables-scope), redirection of the input or output of a set of commands as a group, or to specify precedence when using the conditional commands like `and`.\n\nThe block is unconditionally executed. `begin; ...; end` is equivalent to `if true; ...; end`.\n\n`begin` does not change the current exit status itself. After the block has completed, `$status` will be set to the status returned by the most recent command.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\nThe following code sets a number of variables inside of a block scope. Since the variables are set inside the block and have local scope, they will be automatically deleted when the block ends.\n\n```\nbegin\n    set -l PIRATE Yarrr\n\n    ...\nend\n\necho $PIRATE\n# This will not output anything, since the PIRATE variable\n# went out of scope at the end of the block\n```\n\nIn the following code, all output is redirected to the file out.html.\n\n```\nbegin\n    echo $xml_header\n    echo $html_header\n    if test -e $file\n        ...\n    end\n    ...\nend > out.html\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/begin.html](https://fishshell.com/docs/3.7/cmds/begin.html)"
- name: bg
  summary: bg sends jobs to the background, resuming them if they are stopped
  description: "# bg - send jobs to background\n\n## Synopsis\n\n```\nbg [PID ...]\n```\n\n## Description\n\n`bg` sends [jobs](../language#syntax-job-control) to the background, resuming them if they are stopped.\n\nA background job is executed simultaneously with fish, and does not have access to the keyboard. If no job is specified, the last job to be used is put in the background. If `PID` is specified, the jobs containing the specified process IDs are put in the background.\n\nFor compatibility with other shells, job expansion syntax is supported for `bg`. A PID of the format `%1` will be interpreted as the PID of job 1. Job numbers can be seen in the output of [jobs](jobs).\n\nWhen at least one of the arguments isn’t a valid job specifier, `bg` will print an error without backgrounding anything.\n\nWhen all arguments are valid job specifiers, `bg` will background all matching jobs that exist.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n`bg 123 456 789` will background the jobs that contain processes 123, 456 and 789.\n\nIf only 123 and 789 exist, it will still background them and print an error about 456.\n\n`bg 123 banana` or `bg banana 123` will complain that “banana” is not a valid job specifier.\n\n`bg %1` will background job 1.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/bg.html](https://fishshell.com/docs/3.7/cmds/bg.html)"
- name: bind
  summary: bind manages bindings
  description: "# bind - handle fish key bindings\n\n## Synopsis\n\n```\nbind [(-M | --mode) MODE] [(-m | --sets-mode) NEW_MODE] [--preset | --user] [-s | --silent] [-k | --key] SEQUENCE COMMAND ...\nbind [(-M | --mode) MODE] [-k | --key] [--preset] [--user] SEQUENCE\nbind (-K | --key-names) [-a | --all] [--preset] [--user]\nbind (-f | --function-names)\nbind (-L | --list-modes)\nbind (-e | --erase) [(-M | --mode) MODE] [--preset] [--user] [-a | --all] | [-k | --key] SEQUENCE ...\n```\n\n## Description\n\n`bind` manages bindings.\n\nIt can add bindings if given a SEQUENCE of characters to bind to. These should be written as [fish escape sequences](../language#escapes). The most important of these are `\\c` for the control key, and `\\e` for escape, and because of historical reasons also the Alt key (sometimes also called “Meta”).\n\nFor example, Alt+W can be written as `\\ew`, and Control+X (^X) can be written as `\\cx`. Note that Alt-based key bindings are case sensitive and Control-based key bindings are not. This is a constraint of text-based terminals, not `fish`.\n\nThe generic key binding that matches if no other binding does can be set by specifying a `SEQUENCE` of the empty string (that is, `''` ). For most key bindings, it makes sense to bind this to the `self-insert` function (i.e. `bind '' self-insert`). This will insert any keystrokes not specifically bound to into the editor. Non-printable characters are ignored by the editor, so this will not result in control sequences being inserted.\n\nIf the `-k` switch is used, the name of a key (such as ‘down’, ‘up’ or ‘backspace’) is used instead of a sequence. The names used are the same as the corresponding curses variables, but without the ‘key\\_’ prefix. (See `terminfo(5)` for more information, or use `bind --key-names` for a list of all available named keys). Normally this will print an error if the current `$TERM` entry doesn’t have a given key, unless the `-s` switch is given.\n\nTo find out what sequence a key combination sends, you can use [fish_key_reader](fish_key_reader).\n\n`COMMAND` can be any fish command, but it can also be one of a set of special input functions. These include functions for moving the cursor, operating on the kill-ring, performing tab completion, etc. Use `bind --function-names` for a complete list of these input functions.\n\nWhen `COMMAND` is a shellscript command, it is a good practice to put the actual code into a [function](../language#syntax-function) and simply bind to the function name. This way it becomes significantly easier to test the function while editing, and the result is usually more readable as well.\n\nNote\n\nSpecial input functions cannot be combined with ordinary shell script commands. The commands must be entirely a sequence of special input functions (from `bind -f`) or all shell script commands (i.e., valid fish script). To run special input functions from regular fish script, use `commandline -f` (see also [commandline](commandline)). If a script produces output, it should finish by calling `commandline -f repaint` to tell fish that a repaint is in order.\n\nIf no `SEQUENCE` is provided, all bindings (or just the bindings in the given `MODE`) are printed. If `SEQUENCE` is provided but no `COMMAND`, just the binding matching that sequence is printed.\n\nTo save custom key bindings, put the `bind` statements into [config.fish](../language#configuration). Alternatively, fish also automatically executes a function called `fish_user_key_bindings` if it exists.\n\nKey bindings may use “modes”, which mimics Vi’s modal input behavior. The default mode is “default”. Every key binding applies to a single mode; you can specify which one with `-M MODE`. If the key binding should change the mode, you can specify the new mode with `-m NEW_MODE`. The mode can be viewed and changed via the `$fish_bind_mode` variable. If you want to change the mode from inside a fish function, use `set fish_bind_mode MODE`.\n\n## Options\n\nThe following options are available:\n\n**-k** or **--key**  \nSpecify a key name, such as ‘left’ or ‘backspace’ instead of a character sequence\n\n**-K** or **--key-names**  \nDisplay a list of available key names. Specifying **-a** or **--all** includes keys that don’t have a known mapping\n\n**-f** or **--function-names**  \nDisplay a list of available input functions\n\n**-L** or **--list-modes**  \nDisplay a list of defined bind modes\n\n**-M MODE** or **--mode** *MODE*  \nSpecify a bind mode that the bind is used in. Defaults to “default”\n\n**-m NEW_MODE** or **--sets-mode** *NEW_MODE*  \nChange the current mode to *NEW_MODE* after this binding is executed\n\n**-e** or **--erase**  \nErase the binding with the given sequence and mode instead of defining a new one. Multiple sequences can be specified with this flag. Specifying **-a** or **--all** with **-M** or **--mode** erases all binds in the given mode regardless of sequence. Specifying **-a** or **--all** without **-M** or **--mode** erases all binds in all modes regardless of sequence.\n\n**-a** or **--all**  \nSee **--erase** and **--key-names**\n\n**--preset** and **--user**  \nSpecify if bind should operate on user or preset bindings. User bindings take precedence over preset bindings when fish looks up mappings. By default, all `bind` invocations work on the “user” level except for listing, which will show both levels. All invocations except for inserting new bindings can operate on both levels at the same time (if both **--preset** and **--user** are given). **--preset** should only be used in full binding sets (like when working on `fish_vi_key_bindings`).\n\n**-s** or **--silent**  \nSilences some of the error messages, including for unknown key names and unbound sequences.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## Special input functions\n\nThe following special input functions are available:\n\n`and`  \nonly execute the next function if the previous succeeded (note: only some functions report success)\n\n`accept-autosuggestion`  \naccept the current autosuggestion\n\n`backward-char`  \nmove one character to the left. If the completion pager is active, select the previous completion instead.\n\n`backward-bigword`  \nmove one whitespace-delimited word to the left\n\n`backward-delete-char`  \ndeletes one character of input to the left of the cursor\n\n`backward-kill-bigword`  \nmove the whitespace-delimited word to the left of the cursor to the killring\n\n`backward-kill-line`  \nmove everything from the beginning of the line to the cursor to the killring\n\n`backward-kill-path-component`  \nmove one path component to the left of the cursor to the killring. A path component is everything likely to belong to a path component, i.e. not any of the following: `/={,}’\":@ |;<>&`, plus newlines and tabs.\n\n`backward-kill-word`  \nmove the word to the left of the cursor to the killring. The “word” here is everything up to punctuation or whitespace.\n\n`backward-word`  \nmove one word to the left\n\n`beginning-of-buffer`  \nmoves to the beginning of the buffer, i.e. the start of the first line\n\n`beginning-of-history`  \nmove to the beginning of the history\n\n`beginning-of-line`  \nmove to the beginning of the line\n\n`begin-selection`  \nstart selecting text\n\n`cancel`  \ncancel the current commandline and replace it with a new empty one\n\n`cancel-commandline`  \ncancel the current commandline and replace it with a new empty one, leaving the old one in place with a marker to show that it was cancelled\n\n`capitalize-word`  \nmake the current word begin with a capital letter\n\n`clear-screen`  \nclears the screen and redraws the prompt. if the terminal doesn’t support clearing the screen it is the same as `repaint`.\n\n`complete`  \nguess the remainder of the current token\n\n`complete-and-search`  \ninvoke the searchable pager on completion options (for convenience, this also moves backwards in the completion pager)\n\n`delete-char`  \ndelete one character to the right of the cursor\n\n`delete-or-exit`  \ndelete one character to the right of the cursor, or exit the shell if the commandline is empty\n\n`down-line`  \nmove down one line\n\n`downcase-word`  \nmake the current word lowercase\n\n`end-of-buffer`  \nmoves to the end of the buffer, i.e. the end of the first line\n\n`end-of-history`  \nmove to the end of the history\n\n`end-of-line`  \nmove to the end of the line\n\n`end-selection`  \nend selecting text\n\n`expand-abbr`  \nexpands any abbreviation currently under the cursor\n\n`execute`  \nrun the current commandline\n\n`exit`  \nexit the shell\n\n`forward-bigword`  \nmove one whitespace-delimited word to the right\n\n`forward-char`  \nmove one character to the right; or if at the end of the commandline, accept the current autosuggestion. If the completion pager is active, select the next completion instead.\n\n`forward-single-char`  \nmove one character to the right; or if at the end of the commandline, accept a single char from the current autosuggestion.\n\n`forward-word`  \nmove one word to the right; or if at the end of the commandline, accept one word from the current autosuggestion.\n\n`history-pager`  \ninvoke the searchable pager on history (incremental search); or if the history pager is already active, search further backwards in time.\n\n`history-pager-delete`  \npermanently delete the history item selected in the history pager\n\n`history-search-backward`  \nsearch the history for the previous match\n\n`history-search-forward`  \nsearch the history for the next match\n\n`history-prefix-search-backward`  \nsearch the history for the previous prefix match\n\n`history-prefix-search-forward`  \nsearch the history for the next prefix match\n\n`history-token-search-backward`  \nsearch the history for the previous matching argument\n\n`history-token-search-forward`  \nsearch the history for the next matching argument\n\n`forward-jump and backward-jump`  \nread another character and jump to its next occurence after/before the cursor\n\n`forward-jump-till and backward-jump-till`  \njump to right *before* the next occurence\n\n`repeat-jump and repeat-jump-reverse`  \nredo the last jump in the same/opposite direction\n\n`kill-bigword`  \nmove the next whitespace-delimited word to the killring\n\n`kill-line`  \nmove everything from the cursor to the end of the line to the killring\n\n`kill-selection`  \nmove the selected text to the killring\n\n`kill-whole-line`  \nmove the line (including the following newline) to the killring. If the line is the last line, its preceeding newline is also removed\n\n`kill-inner-line`  \nmove the line (without the following newline) to the killring\n\n`kill-word`  \nmove the next word to the killring\n\n`nextd-or-forward-word`  \nif the commandline is empty, then move forward in the directory history, otherwise move one word to the right; or if at the end of the commandline, accept one word from the current autosuggestion.\n\n`or`  \nonly execute the next function if the previous did not succeed (note: only some functions report failure)\n\n`pager-toggle-search`  \ntoggles the search field if the completions pager is visible; or if used after `history-pager`, search forwards in time.\n\n`prevd-or-backward-word`  \nif the commandline is empty, then move backward in the directory history, otherwise move one word to the left\n\n`repaint`  \nreexecutes the prompt functions and redraws the prompt (also `force-repaint` for backwards-compatibility)\n\n`repaint-mode`  \nreexecutes the [fish_mode_prompt](fish_mode_prompt) and redraws the prompt. This is useful for vi-mode. If no `fish_mode_prompt` exists or it prints nothing, it acts like a normal repaint.\n\n`self-insert`  \ninserts the matching sequence into the command line\n\n`self-insert-notfirst`  \ninserts the matching sequence into the command line, unless the cursor is at the beginning\n\n`suppress-autosuggestion`  \nremove the current autosuggestion. Returns true if there was a suggestion to remove.\n\n`swap-selection-start-stop`  \ngo to the other end of the highlighted text without changing the selection\n\n`transpose-chars`  \ntranspose two characters to the left of the cursor\n\n`transpose-words`  \ntranspose two words to the left of the cursor\n\n`togglecase-char`  \ntoggle the capitalisation (case) of the character under the cursor\n\n`togglecase-selection`  \ntoggle the capitalisation (case) of the selection\n\n`insert-line-under`  \nadd a new line under the current line\n\n`insert-line-over`  \nadd a new line over the current line\n\n`up-line`  \nmove up one line\n\n`undo and redo`  \nrevert or redo the most recent edits on the command line\n\n`upcase-word`  \nmake the current word uppercase\n\n`yank`  \ninsert the latest entry of the killring into the buffer\n\n`yank-pop`  \nrotate to the previous entry of the killring\n\n## Additional functions\n\nThe following functions are included as normal functions, but are particularly useful for input editing:\n\n`up-or-search and down-or-search`  \nmove the cursor or search the history depending on the cursor position and current mode\n\n`edit_command_buffer`  \nopen the visual editor (controlled by the `VISUAL` or `EDITOR` environment variables) with the current command-line contents\n\n`fish_clipboard_copy`  \ncopy the current selection to the system clipboard\n\n`fish_clipboard_paste`  \npaste the current selection from the system clipboard before the cursor\n\n`fish_commandline_append`  \nappend the argument to the command-line. If the command-line already ends with the argument, this removes the suffix instead. Starts with the last command from history if the command-line is empty.\n\n`fish_commandline_prepend`  \nprepend the argument to the command-line. If the command-line already starts with the argument, this removes the prefix instead. Starts with the last command from history if the command-line is empty.\n\n## Examples\n\nExit the shell when Control+D is pressed:\n\n```\nbind \\cd 'exit'\n```\n\nPerform a history search when Page Up is pressed:\n\n```\nbind -k ppage history-search-backward\n```\n\nTurn on [Vi key bindings](../interactive#vi-mode) and rebind Control+C to clear the input line:\n\n```\nset -g fish_key_bindings fish_vi_key_bindings\nbind -M insert \\cc kill-whole-line repaint\n```\n\nLaunch `git diff` and repaint the commandline afterwards when Control+G is pressed:\n\n```\nbind \\cg 'git diff; commandline -f repaint'\n```\n\n## Terminal Limitations\n\nUnix terminals, like the ones fish operates in, are at heart 70s technology. They have some limitations that applications running inside them can’t workaround.\n\nFor instance, the control key modifies a character by setting the top three bits to 0. This means:\n\n- Many characters + control are indistinguishable from other keys. Control+I *is* tab, Control+J *is* newline (`\\n`).\n- Control and shift don’t work simultaneously\n\nOther keys don’t have a direct encoding, and are sent as escape sequences. For example → (Right) often sends `\\e\\[C`. These can differ from terminal to terminal, and the mapping is typically available in `terminfo(5)`. Sometimes however a terminal identifies as e.g. `xterm-256color` for compatibility, but then implements xterm’s sequences incorrectly.\n\n## Special Case: The Escape Character\n\nThe escape key can be used standalone, for example, to switch from insertion mode to normal mode when using Vi keybindings. Escape can also be used as a “meta” key, to indicate the start of an escape sequence, like for function or arrow keys. Custom bindings can also be defined that begin with an escape character.\n\nHolding alt and something else also typically sends escape, for example holding alt+a will send an escape character and then an “a”.\n\nfish waits for a period after receiving the escape character, to determine whether it is standalone or part of an escape sequence. While waiting, additional key presses make the escape key behave as a meta key. If no other key presses come in, it is handled as a standalone escape. The waiting period is set to 30 milliseconds (0.03 seconds). It can be configured by setting the `fish_escape_delay_ms` variable to a value between 10 and 5000 ms. This can be a universal variable that you set once from an interactive session. So the escape character has its own timeout configured with [`fish_escape_delay_ms`](../language#envvar-fish_escape_delay_ms).\n\nSee also [Key sequences](../interactive#interactive-key-sequences).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/bind.html](https://fishshell.com/docs/3.7/cmds/bind.html)"
- name: block
  summary: block prevents events triggered by fish or the emit command from being delivered and acted upon while the block is in place
  description: "# block - temporarily block delivery of events\n\n## Synopsis\n\n```\nblock [(--local | --global)]\nblock --erase\n```\n\n## Description\n\n`block` prevents events triggered by `fish` or the [emit](emit) command from being delivered and acted upon while the block is in place.\n\nIn functions, `block` can be useful while performing work that should not be interrupted by the shell.\n\nThe block can be removed. Any events which triggered while the block was in place will then be delivered.\n\nEvent blocks should not be confused with code blocks, which are created with `begin`, `if`, `while` or `for`\n\nWithout options, the `block` command acts with function scope.\n\nThe following options are available:\n\n**-l** or **--local**  \nRelease the block automatically at the end of the current innermost code block scope.\n\n**-g** or **--global**  \nNever automatically release the lock.\n\n**-e** or **--erase**  \nRelease global block.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## Example\n\n```\n# Create a function that listens for events\nfunction --on-event foo foo; echo 'foo fired'; end\n\n# Block the delivery of events\nblock -g\n\nemit foo\n# No output will be produced\n\nblock -e\n# 'foo fired' will now be printed\n```\n\n## Notes\n\nEvents are only received from the current fish process as there is no way to send events from one fish process to another (yet).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/block.html](https://fishshell.com/docs/3.7/cmds/block.html)"
- name: break
  summary: break halts a currently running loop (LOOP_CONSTRUCT), such as a for or while loop
  description: "# break - stop the current inner loop\n\n## Synopsis\n\n```\nLOOP_CONSTRUCT\n   [COMMANDS ...]\n   break\n   [COMMANDS ...]\nend\n```\n\n## Description\n\n`break` halts a currently running loop (*LOOP_CONSTRUCT*), such as a [for](for) or [while](while) loop. It is usually added inside of a conditional block such as an [if](if) block.\n\nThere are no parameters for `break`.\n\n## Example\n\nThe following code searches all .c files for “smurf”, and halts at the first occurrence.\n\n```\nfor i in *.c\n    if grep smurf $i\n        echo Smurfs are present in $i\n        break\n    end\nend\n```\n\n## See Also\n\n- the [continue](continue) command, to skip the remainder of the current iteration of the current inner loop\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/break.html](https://fishshell.com/docs/3.7/cmds/break.html)"
- name: breakpoint
  summary: breakpoint is used to halt a running script and launch an interactive debugging prompt
  description: "# breakpoint - launch debug mode\n\n## Synopsis\n\n```\nbreakpoint\n```\n\n## Description\n\n`breakpoint` is used to halt a running script and launch an interactive debugging prompt.\n\nFor more details, see [Debugging fish scripts](../language#debugging) in the `fish` manual.\n\nThere are no parameters for `breakpoint`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/breakpoint.html](https://fishshell.com/docs/3.7/cmds/breakpoint.html)"
- name: builtin
  summary: builtin forces the shell to use a builtin command named BUILTIN, rather than a function or external program
  description: "# builtin - run a builtin command\n\n## Synopsis\n\n```\nbuiltin [OPTIONS] BUILTINNAME\nbuiltin --query BUILTINNAME ...\nbuiltin --names\n```\n\n## Description\n\n`builtin` forces the shell to use a builtin command named *BUILTIN*, rather than a function or external program.\n\nThe following options are available:\n\n**-n** or **--names**  \nLists the names of all defined builtins.\n\n**-q** or **--query** *BUILTIN*  \nTests if any of the specified builtins exist. If any exist, it returns 0, 1 otherwise.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## Example\n\n```\nbuiltin jobs\n# executes the jobs builtin, even if a function named jobs exists\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/builtin.html](https://fishshell.com/docs/3.7/cmds/builtin.html)"
- name: case
  summary: switch executes one of several blocks of commands, depending on whether a specified value matches one of several values
  description: "# case - conditionally execute a block of commands\n\n## Synopsis\n\n```\nswitch VALUE\n   [case [GLOB ...]\n       [COMMAND ...]]\nend\n```\n\n## Description\n\n`switch` executes one of several blocks of commands, depending on whether a specified value matches one of several values. `case` is used together with the `switch` statement in order to determine which block should be executed.\n\nEach `case` command is given one or more parameters. The first `case` command with a parameter that matches the string specified in the switch command will be evaluated. `case` parameters may contain wildcards. These need to be escaped or quoted in order to avoid regular wildcard expansion using filenames.\n\nNote that fish does not fall through on case statements. Only the first matching case is executed.\n\nNote that command substitutions in a case statement will be evaluated even if its body is not taken. All substitutions, including command substitutions, must be performed before the value can be compared against the parameter.\n\n## Example\n\nSay \\$animal contains the name of an animal. Then this code would classify it:\n\n```\nswitch $animal\n    case cat\n        echo evil\n    case wolf dog human moose dolphin whale\n        echo mammal\n    case duck goose albatross\n        echo bird\n    case shark trout stingray\n        echo fish\n    # Note that the next case has a wildcard which is quoted\n    case '*'\n        echo I have no idea what a $animal is\nend\n```\n\nIf the above code was run with `$animal` set to `whale`, the output would be `mammal`.\n\nIf `$animal` was set to “banana”, it would print “I have no idea what a banana is”.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/case.html](https://fishshell.com/docs/3.7/cmds/case.html)"
- name: cd
  summary: cd changes the current working directory
  description: "# cd - change directory\n\n## Synopsis\n\n```\ncd [DIRECTORY]\n```\n\n## Description\n\n`cd` changes the current working directory.\n\nIf *DIRECTORY* is given, it will become the new directory. If no parameter is given, the [`HOME`](../language#envvar-HOME) environment variable will be used.\n\nIf *DIRECTORY* is a relative path, all the paths in the [`CDPATH`](../language#envvar-CDPATH) will be tried as prefixes for it, in addition to [`PWD`](../language#envvar-PWD). It is recommended to keep **.** as the first element of [`CDPATH`](../language#envvar-CDPATH), or [`PWD`](../language#envvar-PWD) will be tried last.\n\nFish will also try to change directory if given a command that looks like a directory (starting with **.**, **/** or **~**, or ending with **/**), without explicitly requiring **cd**.\n\nFish also ships a wrapper function around the builtin **cd** that understands `cd -` as changing to the previous directory. See also [prevd](prevd). This wrapper function maintains a history of the 25 most recently visited directories in the `$dirprev` and `$dirnext` global variables. If you make those universal variables your **cd** history is shared among all fish instances.\n\nAs a special case, `cd .` is equivalent to `cd $PWD`, which is useful in cases where a mountpoint has been recycled or a directory has been removed and recreated.\n\nThe **--help** or **-h** option displays help about using this command, and does not change the directory.\n\n## Examples\n\n```\ncd\n# changes the working directory to your home directory.\n\ncd /usr/src/fish-shell\n# changes the working directory to /usr/src/fish-shell\n```\n\n## See Also\n\nNavigate directories using the [directory history](../interactive#directory-history) or the [directory stack](../interactive#directory-stack)\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/cd.html](https://fishshell.com/docs/3.7/cmds/cd.html)"
- name: cdh
  summary: cdh with no arguments presents a list of recently visited directories
  description: "# cdh - change to a recently visited directory\n\n## Synopsis\n\n```\ncdh [DIRECTORY]\n```\n\n## Description\n\n`cdh` with no arguments presents a list of [recently visited directories](../interactive#directory-history). You can then select one of the entries by letter or number. You can also press Tab to use the completion pager to select an item from the list. If you give it a single argument it is equivalent to `cd DIRECTORY`.\n\nNote that the `cd` command limits directory history to the 25 most recently visited directories. The history is stored in the `dirprev` and `dirnext` variables, which this command manipulates. If you make those universal variables, your `cd` history is shared among all fish instances.\n\n## See Also\n\n- the [dirh](dirh) command to print the directory history\n- the [prevd](prevd) command to move backward\n- the [nextd](nextd) command to move forward\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/cdh.html](https://fishshell.com/docs/3.7/cmds/cdh.html)"
- name: command
  summary: command forces the shell to execute the program COMMANDNAME and ignore any functions or builtins with the same name
  description: "# command - run a program\n\n## Synopsis\n\n```\ncommand [OPTIONS] [COMMANDNAME [ARG ...]]\n```\n\n## Description\n\n**command** forces the shell to execute the program *COMMANDNAME* and ignore any functions or builtins with the same name.\n\nThe following options are available:\n\n**-a** or **--all**  \nPrints all *COMMAND* found in [`PATH`](../language#envvar-PATH), in the order found.\n\n**-q** or **--query**  \nSilence output and print nothing, setting only exit status. Implies **--search**. For compatibility, this is also **--quiet** (deprecated).\n\n**-v** (or **-s** or **--search**)  \nPrints the external command that would be executed, or prints nothing if no file with the specified name could be found in [`PATH`](../language#envvar-PATH).\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nWith the **-v** option, `command` treats every argument as a separate command to look up and sets the exit status to 0 if any of the specified commands were found, or 127 if no commands could be found. **--quiet** used with **-v** prevents commands being printed, like `type -q`.\n\n## Examples\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/command.html](https://fishshell.com/docs/3.7/cmds/command.html)"
- name: commandline
  summary: commandline can be used to set or get the current contents of the command line buffer
  description: "# commandline - set or get the current command line buffer\n\n## Synopsis\n\n```\ncommandline [OPTIONS] [CMD]\n```\n\n## Description\n\n`commandline` can be used to set or get the current contents of the command line buffer.\n\nWith no parameters, `commandline` returns the current value of the command line.\n\nWith **CMD** specified, the command line buffer is erased and replaced with the contents of **CMD**.\n\nThe following options are available:\n\n**-C** or **--cursor**  \nSet or get the current cursor position, not the contents of the buffer. If no argument is given, the current cursor position is printed, otherwise the argument is interpreted as the new cursor position. If one of the options **-j**, **-p** or **-t** is given, the position is relative to the respective substring instead of the entire command line buffer.\n\n**-B** or **--selection-start**  \nGet current position of the selection start in the buffer.\n\n**-E** or **--selection-end**  \nGet current position of the selection end in the buffer.\n\n**-f** or **--function**  \nCauses any additional arguments to be interpreted as input functions, and puts them into the queue, so that they will be read before any additional actual key presses are. This option cannot be combined with any other option. See [bind](bind) for a list of input functions.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nThe following options change the way `commandline` updates the command line buffer:\n\n**-a** or **--append**  \nDo not remove the current commandline, append the specified string at the end of it.\n\n**-i** or **--insert**  \nDo not remove the current commandline, insert the specified string at the current cursor position\n\n**-r** or **--replace**  \nRemove the current commandline and replace it with the specified string (default)\n\nThe following options change what part of the commandline is printed or updated:\n\n**-b** or **--current-buffer**  \nSelect the entire commandline, not including any displayed autosuggestion (default).\n\n**-j** or **--current-job**  \nSelect the current job - a **job** here is one pipeline. Stops at logical operators or terminators (**;**, **&**, and newlines).\n\n**-p** or **--current-process**  \nSelect the current process - a **process** here is one command. Stops at logical operators, terminators, and pipes.\n\n**-s** or **--current-selection**  \nSelects the current selection\n\n**-t** or **--current-token**  \nSelects the current token\n\nThe following options change the way `commandline` prints the current commandline buffer:\n\n**-c** or **--cut-at-cursor**  \nOnly print selection up until the current cursor position. If combined with `--tokenize`, this will print up until the last completed token - excluding the token the cursor is in. This is typically what you would want for instance in completions. To get both, use both `commandline --cut-at-cursor --tokenize; commandline --cut-at-cursor --current-token`, or `commandline -co; commandline -ct` for short.\n\n**-o** or **--tokenize**  \nTokenize the selection and print one string-type token per line.\n\nIf `commandline` is called during a call to complete a given string using `complete -C STRING`, `commandline` will consider the specified string to be the current contents of the command line.\n\nThe following options output metadata about the commandline state:\n\n**-L** or **--line**  \nPrint the line that the cursor is on, with the topmost line starting at 1.\n\n**-S** or **--search-mode**  \nEvaluates to true if the commandline is performing a history search.\n\n**-P** or **--paging-mode**  \nEvaluates to true if the commandline is showing pager contents, such as tab completions.\n\n**--paging-full-mode**  \nEvaluates to true if the commandline is showing pager contents, such as tab completions and all lines are shown (no “\\<n\\> more rows” message).\n\n**--is-valid**  \nReturns true when the commandline is syntactically valid and complete. If it is, it would be executed when the `execute` bind function is called. If the commandline is incomplete, return 2, if erroneus, return 1.\n\n## Example\n\n`commandline -j $history[3]` replaces the job under the cursor with the third item from the command line history.\n\nIf the commandline contains\n\n```\n>_ echo $flounder >&2 | less; and echo $catfish\n```\n\n(with the cursor on the “o” of “flounder”)\n\nThe `echo $flounder >&` is the first process, `less` the second and `and echo $catfish` the third.\n\n`echo $flounder >&2 | less` is the first job, `and echo $catfish` the second.\n\n**\\$flounder** is the current token.\n\nThe most common use for something like completions is\n\n```\nset -l tokens (commandline -opc)\n```\n\nwhich gives the current *process* (what is being completed), tokenized into separate entries, up to but excluding the currently being completed token\n\nIf you are then also interested in the in-progress token, add\n\n::  \nset -l current (commandline -ct)\n\nNote that this makes it easy to render fish’s infix matching moot - if possible it’s best if the completions just print all possibilities and leave the matching to the current token up to fish’s logic.\n\nMore examples:\n\n```\n>_ commandline -t\n$flounder\n>_ commandline -ct\n$fl\n>_ commandline -b # or just commandline\necho $flounder >&2 | less; and echo $catfish\n>_ commandline -p\necho $flounder >&2\n>_ commandline -j\necho $flounder >&2 | less\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/commandline.html](https://fishshell.com/docs/3.7/cmds/commandline.html)"
- name: Commands
  summary: This is a list of all the commands fish ships with
  description: "# Commands\n\nThis is a list of all the commands fish ships with.\n\nBroadly speaking, these fall into a few categories:\n\n## Keywords\n\nCore language keywords that make up the syntax, like\n\n- [if](cmds/if) for conditions.\n- [for](cmds/for) and [while](cmds/while) for loops.\n- [break](cmds/break) and [continue](cmds/continue) to control loops.\n- [function](cmds/function) to define functions.\n- [return](cmds/return) to return a status from a function.\n- [begin](cmds/begin) to begin a block and [end](cmds/end) to end any block (including ifs and loops).\n- [and](cmds/and), [or](cmds/or) and [not](cmds/not) to combine commands logically.\n- [switch](cmds/switch) and [case](cmds/case) to make multiple blocks depending on the value of a variable.\n- [command](cmds/command) or [builtin](cmds/builtin) to tell fish what sort of thing to execute\n- [time](cmds/time) to time execution\n- [exec](cmds/exec) tells fish to replace itself with a command.\n\n## Tools\n\nBuiltins to do a task, like\n\n- [cd](cmds/cd) to change the current directory.\n- [echo](cmds/echo) or [printf](cmds/printf) to produce output.\n- [set_color](cmds/set_color) to colorize output.\n- [set](cmds/set) to set, query or erase variables.\n- [read](cmds/read) to read input.\n- [string](cmds/string) for string manipulation.\n- [math](cmds/math) does arithmetic.\n- [argparse](cmds/argparse) to make arguments easier to handle.\n- [count](cmds/count) to count arguments.\n- [type](cmds/type) to find out what sort of thing (command, builtin or function) fish would call, or if it exists at all.\n- [test](cmds/test) checks conditions like if a file exists or a string is empty.\n- [contains](cmds/contains) to see if a list contains an entry.\n- [eval](cmds/eval) and [source](cmds/source) to run fish code from a string or file.\n- [status](cmds/status) to get shell information, like whether it’s interactive or a login shell, or which file it is currently running.\n- [abbr](cmds/abbr) manages [Abbreviations](interactive#abbreviations).\n- [bind](cmds/bind) to change bindings.\n- [complete](cmds/complete) manages [completions](interactive#tab-completion).\n- [commandline](cmds/commandline) to get or change the commandline contents.\n- [fish_config](cmds/fish_config) to easily change fish’s configuration, like the prompt or colorscheme.\n- [random](cmds/random) to generate random numbers or pick from a list.\n\n## Known functions\n\nKnown functions are a customization point. You can change them to change how your fish behaves. This includes:\n\n- [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) and [fish_mode_prompt](cmds/fish_mode_prompt) to print your prompt.\n- [fish_command_not_found](cmds/fish_command_not_found) to tell fish what to do when a command is not found.\n- [fish_title](cmds/fish_title) to change the terminal’s title.\n- [fish_greeting](cmds/fish_greeting) to show a greeting when fish starts.\n\n## Helper functions\n\nSome helper functions, often to give you information for use in your prompt:\n\n- [fish_git_prompt](cmds/fish_git_prompt) and [fish_hg_prompt](cmds/fish_hg_prompt) to print information about the current git or mercurial repository.\n- [fish_vcs_prompt](cmds/fish_vcs_prompt) to print information for either.\n- [fish_svn_prompt](cmds/fish_svn_prompt) to print information about the current svn repository.\n- [fish_status_to_signal](cmds/fish_status_to_signal) to give a signal name from a return status.\n- [prompt_pwd](cmds/prompt_pwd) to give the current directory in a nicely formatted and shortened way.\n- [prompt_login](cmds/prompt_login) to describe the current login, with user and hostname, and to explain if you are in a chroot or connected via ssh.\n- [prompt_hostname](cmds/prompt_hostname) to give the hostname, shortened for use in the prompt.\n- [fish_is_root_user](cmds/fish_is_root_user) to check if the current user is an administrator user like root.\n- [fish_add_path](cmds/fish_add_path) to easily add a path to \\$PATH.\n- [alias](cmds/alias) to quickly define wrapper functions (“aliases”).\n- [fish_delta](cmds/fish_delta) to show what you have changed from the default configuration.\n\n## Helper commands\n\nfish also ships some things as external commands so they can be easily called from elsewhere.\n\nThis includes [fish_indent](cmds/fish_indent) to format fish code and [fish_key_reader](cmds/fish_key_reader) to show you what escape sequence a keypress produces.\n\n## The full list\n\nAnd here is the full list:\n\n- [\\_ - call fish’s translations](cmds/_)\n- [abbr - manage fish abbreviations](cmds/abbr)\n- [alias - create a function](cmds/alias)\n- [and - conditionally execute a command](cmds/and)\n- [argparse - parse options passed to a fish script or function](cmds/argparse)\n- [begin - start a new block of code](cmds/begin)\n- [bg - send jobs to background](cmds/bg)\n- [bind - handle fish key bindings](cmds/bind)\n- [block - temporarily block delivery of events](cmds/block)\n- [break - stop the current inner loop](cmds/break)\n- [breakpoint - launch debug mode](cmds/breakpoint)\n- [builtin - run a builtin command](cmds/builtin)\n- [case - conditionally execute a block of commands](cmds/case)\n- [cd - change directory](cmds/cd)\n- [cdh - change to a recently visited directory](cmds/cdh)\n- [command - run a program](cmds/command)\n- [commandline - set or get the current command line buffer](cmds/commandline)\n- [complete - edit command-specific tab-completions](cmds/complete)\n- [contains - test if a word is present in a list](cmds/contains)\n- [continue - skip the remainder of the current iteration of the current inner loop](cmds/continue)\n- [count - count the number of elements of a list](cmds/count)\n- [dirh - print directory history](cmds/dirh)\n- [dirs - print directory stack](cmds/dirs)\n- [disown - remove a process from the list of jobs](cmds/disown)\n- [echo - display a line of text](cmds/echo)\n- [else - execute command if a condition is not met](cmds/else)\n- [emit - emit a generic event](cmds/emit)\n- [end - end a block of commands](cmds/end)\n- [eval - evaluate the specified commands](cmds/eval)\n- [exec - execute command in current process](cmds/exec)\n- [exit - exit the shell](cmds/exit)\n- [false - return an unsuccessful result](cmds/false)\n- [fg - bring job to foreground](cmds/fg)\n- [fish - the friendly interactive shell](cmds/fish)\n- [fish_add_path - add to the path](cmds/fish_add_path)\n- [fish_breakpoint_prompt - define the prompt when stopped at a breakpoint](cmds/fish_breakpoint_prompt)\n- [fish_clipboard_copy - copy text to the system’s clipboard](cmds/fish_clipboard_copy)\n- [fish_clipboard_paste - get text from the system’s clipboard](cmds/fish_clipboard_paste)\n- [fish_command_not_found - what to do when a command wasn’t found](cmds/fish_command_not_found)\n- [fish_config - start the web-based configuration interface](cmds/fish_config)\n- [fish_default_key_bindings - set emacs key bindings for fish](cmds/fish_default_key_bindings)\n- [fish_delta - compare functions and completions to the default](cmds/fish_delta)\n- [fish_git_prompt - output git information for use in a prompt](cmds/fish_git_prompt)\n- [fish_greeting - display a welcome message in interactive shells](cmds/fish_greeting)\n- [fish_hg_prompt - output Mercurial information for use in a prompt](cmds/fish_hg_prompt)\n- [fish_indent - indenter and prettifier](cmds/fish_indent)\n- [fish_is_root_user - check if the current user is root](cmds/fish_is_root_user)\n- [fish_key_reader - explore what characters keyboard keys send](cmds/fish_key_reader)\n- [fish_mode_prompt - define the appearance of the mode indicator](cmds/fish_mode_prompt)\n- [fish_opt - create an option specification for the argparse command](cmds/fish_opt)\n- [fish_prompt - define the appearance of the command line prompt](cmds/fish_prompt)\n- [fish_right_prompt - define the appearance of the right-side command line prompt](cmds/fish_right_prompt)\n- [fish_status_to_signal - convert exit codes to human-friendly signals](cmds/fish_status_to_signal)\n- [fish_svn_prompt - output Subversion information for use in a prompt](cmds/fish_svn_prompt)\n- [fish_title - define the terminal’s title](cmds/fish_title)\n- [fish_update_completions - update completions using manual pages](cmds/fish_update_completions)\n- [fish_vcs_prompt - output version control system information for use in a prompt](cmds/fish_vcs_prompt)\n- [fish_vi_key_bindings - set vi key bindings for fish](cmds/fish_vi_key_bindings)\n- [for - perform a set of commands multiple times](cmds/for)\n- [funced - edit a function interactively](cmds/funced)\n- [funcsave - save the definition of a function to the user’s autoload directory](cmds/funcsave)\n- [function - create a function](cmds/function)\n- [functions - print or erase functions](cmds/functions)\n- [help - display fish documentation](cmds/help)\n- [history - show and manipulate command history](cmds/history)\n- [if - conditionally execute a command](cmds/if)\n- [isatty - test if a file descriptor is a terminal](cmds/isatty)\n- [jobs - print currently running jobs](cmds/jobs)\n- [math - perform mathematics calculations](cmds/math)\n- [nextd - move forward through directory history](cmds/nextd)\n- [not - negate the exit status of a job](cmds/not)\n- [open - open file in its default application](cmds/open)\n- [or - conditionally execute a command](cmds/or)\n- [path - manipulate and check paths](cmds/path)\n- [popd - move through directory stack](cmds/popd)\n- [prevd - move backward through directory history](cmds/prevd)\n- [printf - display text according to a format string](cmds/printf)\n- [prompt_hostname - print the hostname, shortened for use in the prompt](cmds/prompt_hostname)\n- [prompt_login - describe the login suitable for prompt](cmds/prompt_login)\n- [prompt_pwd - print pwd suitable for prompt](cmds/prompt_pwd)\n- [psub - perform process substitution](cmds/psub)\n- [pushd - push directory to directory stack](cmds/pushd)\n- [pwd - output the current working directory](cmds/pwd)\n- [random - generate random number](cmds/random)\n- [read - read line of input into variables](cmds/read)\n- [realpath - convert a path to an absolute path without symlinks](cmds/realpath)\n- [return - stop the current inner function](cmds/return)\n- [set - display and change shell variables](cmds/set)\n- [set_color - set the terminal color](cmds/set_color)\n- [source - evaluate contents of file](cmds/source)\n- [status - query fish runtime information](cmds/status)\n- [string - manipulate strings](cmds/string)\n- [string-collect - join strings into one](cmds/string-collect)\n- [string-escape - escape special characters](cmds/string-escape)\n- [string-join - join strings with delimiter](cmds/string-join)\n- [string-join0 - join strings with zero bytes](cmds/string-join0)\n- [string-length - print string lengths](cmds/string-length)\n- [string-lower - convert strings to lowercase](cmds/string-lower)\n- [string-match - match substrings](cmds/string-match)\n- [string-pad - pad strings to a fixed width](cmds/string-pad)\n- [string-repeat - multiply a string](cmds/string-repeat)\n- [string-replace - replace substrings](cmds/string-replace)\n- [string-shorten - shorten strings to a width, with an ellipsis](cmds/string-shorten)\n- [string-split - split strings by delimiter](cmds/string-split)\n- [string-split0 - split on zero bytes](cmds/string-split0)\n- [string-sub - extract substrings](cmds/string-sub)\n- [string-trim - remove trailing whitespace](cmds/string-trim)\n- [string-unescape - expand escape sequences](cmds/string-unescape)\n- [string-upper - convert strings to uppercase](cmds/string-upper)\n- [suspend - suspend the current shell](cmds/suspend)\n- [switch - conditionally execute a block of commands](cmds/switch)\n- [test - perform tests on files and text](cmds/test)\n- [time - measure how long a command or block takes](cmds/time)\n- [trap - perform an action when the shell receives a signal](cmds/trap)\n- [true - return a successful result](cmds/true)\n- [type - locate a command and describe its type](cmds/type)\n- [ulimit - set or get resource usage limits](cmds/ulimit)\n- [umask - set or get the file creation mode mask](cmds/umask)\n- [vared - interactively edit the value of an environment variable](cmds/vared)\n- [wait - wait for jobs to complete](cmds/wait)\n- [while - perform a set of commands multiple times](cmds/while)\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/commands.html](https://fishshell.com/docs/3.7/commands.html)"
- name: complete
  summary: complete defines, removes or lists completions for a command
  description: "# complete - edit command-specific tab-completions\n\n## Synopsis\n\n```\ncomplete ((-c | --command) | (-p | --path)) COMMAND [OPTIONS]\ncomplete (-C | --do-complete) [--escape] STRING\n```\n\n## Description\n\n`complete` defines, removes or lists completions for a command.\n\nFor an introduction to writing your own completions, see [Writing your own completions](../completions#completion-own) in the fish manual.\n\nThe following options are available:\n\n**-c** or **--command** *COMMAND*  \nSpecifies that *COMMAND* is the name of the command. If there is no **-c** or **-p**, one non-option argument will be used as the command.\n\n**-p** or **--path** *COMMAND*  \nSpecifies that *COMMAND* is the absolute path of the command (optionally containing wildcards).\n\n**-e** or **--erase**  \nDeletes the specified completion.\n\n**-s** or **--short-option** *SHORT_OPTION*  \nAdds a short option to the completions list.\n\n**-l** or **--long-option** *LONG_OPTION*  \nAdds a GNU-style long option to the completions list.\n\n**-o** or **--old-option** *OPTION*  \nAdds an old-style short or long option (see below for details).\n\n**-a** or **--arguments** *ARGUMENTS*  \nAdds the specified option arguments to the completions list.\n\n**-k** or **--keep-order**  \nKeeps the order of *ARGUMENTS* instead of sorting alphabetically. Multiple `complete` calls with **-k** result in arguments of the later ones displayed first.\n\n**-f** or **--no-files**  \nThis completion may not be followed by a filename.\n\n**-F** or **--force-files**  \nThis completion may be followed by a filename, even if another applicable `complete` specified **--no-files**.\n\n**-r** or **--require-parameter**  \nThis completion must have an option argument, i.e. may not be followed by another option.\n\n**-x** or **--exclusive**  \nShort for **-r** and **-f**.\n\n**-w** or **--wraps** *WRAPPED_COMMAND*  \nCauses the specified command to inherit completions from *WRAPPED_COMMAND* (see below for details).\n\n**-n** or **--condition** *CONDITION*  \nThis completion should only be used if the *CONDITION* (a shell command) returns 0. This makes it possible to specify completions that should only be used in some cases. If multiple conditions are specified, fish will try them in the order they are specified until one fails or all succeeded.\n\n**-C** or **--do-complete** *STRING*  \nMakes `complete` try to find all possible completions for the specified string. If there is no *STRING*, the current commandline is used instead.\n\n**--escape**  \nWhen used with `-C`, escape special characters in completions.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nCommand-specific tab-completions in `fish` are based on the notion of options and arguments. An option is a parameter which begins with a hyphen, such as `-h`, `-help` or `--help`. Arguments are parameters that do not begin with a hyphen. Fish recognizes three styles of options, the same styles as the GNU getopt library. These styles are:\n\n- Short options, like `-a`. Short options are a single character long, are preceded by a single hyphen and can be grouped together (like `-la`, which is equivalent to `-l -a`). Option arguments may be specified by appending the option with the value (`-w32`), or, if `--require-parameter` is given, in the following parameter (`-w 32`).\n- Old-style options, long like `-Wall` or `-name` or even short like `-a`. Old-style options can be more than one character long, are preceded by a single hyphen and may not be grouped together. Option arguments are specified by default following a space (`-foo null`) or after `=` (`-foo=null`).\n- GNU-style long options, like `--colors`. GNU-style long options can be more than one character long, are preceded by two hyphens, and can’t be grouped together. Option arguments may be specified after a `=` (`--quoting-style=shell`), or, if `--require-parameter` is given, in the following parameter (`--quoting-style shell`).\n\nMultiple commands and paths can be given in one call to define the same completions for multiple commands.\n\nMultiple command switches and wrapped commands can also be given to define multiple completions in one call.\n\nInvoking `complete` multiple times for the same command adds the new definitions on top of any existing completions defined for the command.\n\nWhen `-a` or `--arguments` is specified in conjunction with long, short, or old-style options, the specified arguments are only completed as arguments for any of the specified options. If `-a` or `--arguments` is specified without any long, short, or old-style options, the specified arguments are used when completing non-option arguments to the command (except when completing an option argument that was specified with `-r` or `--require-parameter`).\n\nCommand substitutions found in `ARGUMENTS` should return a newline-separated list of arguments, and each argument may optionally have a tab character followed by the argument description. Description given this way override a description given with `-d` or `--description`.\n\nDescriptions given with `--description` are also used to group options given with `-s`, `-o` or `-l`. Options with the same (non-empty) description will be listed as one candidate, and one of them will be picked. If the description is empty or no description was given this is skipped.\n\nThe `-w` or `--wraps` options causes the specified command to inherit completions from another command, “wrapping” the other command. The wrapping command can also have additional completions. A command can wrap multiple commands, and wrapping is transitive: if A wraps B, and B wraps C, then A automatically inherits all of C’s completions. Wrapping can be removed using the `-e` or `--erase` options. Wrapping only works for completions specified with `-c` or `--command` and are ignored when specifying completions with `-p` or `--path`.\n\nWhen erasing completions, it is possible to either erase all completions for a specific command by specifying `complete -c COMMAND -e`, or by specifying a specific completion option to delete.\n\nWhen `complete` is called without anything that would define or erase completions (options, arguments, wrapping, …), it shows matching completions instead. So `complete` without any arguments shows all loaded completions, `complete -c foo` shows all loaded completions for `foo`. Since completions are [autoloaded](../language#syntax-function-autoloading), you will have to trigger them first.\n\n## Examples\n\nThe short-style option `-o` for the `gcc` command needs a file argument:\n\n```\ncomplete -c gcc -s o -r\n```\n\nThe short-style option `-d` for the `grep` command requires one of `read`, `skip` or `recurse`:\n\n```\ncomplete -c grep -s d -x -a \"read skip recurse\"\n```\n\nThe `su` command takes any username as an argument. Usernames are given as the first colon-separated field in the file /etc/passwd. This can be specified as:\n\n```\ncomplete -x -c su -d \"Username\" -a \"(cat /etc/passwd | cut -d : -f 1)\"\n```\n\nThe `rpm` command has several different modes. If the `-e` or `--erase` flag has been specified, `rpm` should delete one or more packages, in which case several switches related to deleting packages are valid, like the `nodeps` switch.\n\nThis can be written as:\n\n```\ncomplete -c rpm -n \"__fish_contains_opt -s e erase\" -l nodeps -d \"Don't check dependencies\"\n```\n\nwhere `__fish_contains_opt` is a function that checks the command line buffer for the presence of a specified set of options.\n\nTo implement an alias, use the `-w` or `--wraps` option:\n\n```\ncomplete -c hub -w git\n```\n\nNow hub inherits all of the completions from git. Note this can also be specified in a function declaration (`function thing -w otherthing`).\n\n```\ncomplete -c git\n```\n\nShows all completions for `git`.\n\nAny command `foo` that doesn’t support grouping multiple short options in one string (not supporting `-xf` as short for `-x -f`) or a short option and its value in one string (not supporting `-d9` instead of `-d 9`) should be specified as a single-character old-style option instead of as a short-style option; for example, `complete -c foo -o s; complete -c foo -o v` would never suggest `foo -ov` but rather `foo -o -v`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/complete.html](https://fishshell.com/docs/3.7/cmds/complete.html)"
- name: Completions
  summary: To specify a completion, use the complete command
  description: "# Writing your own completions\n\nTo specify a completion, use the `complete` command. `complete` takes as a parameter the name of the command to specify a completion for. For example, to add a completion for the program `myprog`, one would start the completion command with `complete -c myprog ...`\n\nTo provide a list of possible completions for myprog, use the `-a` switch. If `myprog` accepts the arguments start and stop, this can be specified as `complete -c myprog -a 'start stop'`. The argument to the `-a` switch is always a single string. At completion time, it will be tokenized on spaces and tabs, and variable expansion, command substitution and other forms of parameter expansion will take place.\n\n`fish` has a special syntax to support specifying switches accepted by a command. The switches `-s`, `-l` and `-o` are used to specify a short switch (single character, such as `-l`), a gnu style long switch (such as `--color`) and an old-style long switch (like `-shuffle`), respectively. If the command ‘myprog’ has an option ‘-o’ which can also be written as `--output`, and which can take an additional value of either ‘yes’ or ‘no’, this can be specified by writing:\n\n```\ncomplete -c myprog -s o -l output -a \"yes no\"\n```\n\nIn the complete call above, the `-a` arguments apply when the option -o/--output has been given, so this offers them for:\n\n```\n> myprog -o<TAB>\n> myprog --output=<TAB>\n```\n\nBy default, option arguments are *optional*, so the candidates are only offered directly attached like that, so they aren’t given in this case:\n\n```\n> myprog -o <TAB>\n```\n\nUsually options *require* a parameter, so you would give `--require-parameter` / `-r`:\n\n```\ncomplete -c myprog -s o -l output -ra \"yes no\"\n```\n\nwhich offers yes/no in these cases:\n\n```\n> myprog -o<TAB>\n> myprog --output=<TAB>\n> myprog -o <TAB>\n> myprog --output <TAB>\n```\n\nIn the latter two cases, files will also be offered because file completion is enabled by default.\n\nYou would either inhibit file completion for a single option:\n\n```\ncomplete -c myprog -s o -l output --no-files -ra \"yes no\"\n```\n\nor with a specific condition:\n\n```\ncomplete -c myprog -f --condition '__fish_seen_subcommand_from somesubcommand'\n```\n\nor you can disable file completions globally for the command:\n\n```\ncomplete -c myprog -f\n```\n\nIf you have disabled them globally, you can enable them just for a specific condition or option with the `--force-files` / `-F` option:\n\n```\n# Disable files by default\ncomplete -c myprog -f\n# but reenable them for --config-file\ncomplete -c myprog -l config-file --force-files -r\n```\n\nIn the complete call above, the `-a` arguments apply when the option -o/--output has been given, so this offers them for:\n\n```\n> myprog -o<TAB>\n> myprog --output=<TAB>\n```\n\nBy default, option arguments are *optional*, so the candidates are only offered directly attached like that, so they aren’t given in this case:\n\n```\n> myprog -o <TAB>\n```\n\nUsually options *require* a parameter, so you would give `--require-parameter` / `-r`:\n\n```\ncomplete -c myprog -s o -l output -ra \"yes no\"\n```\n\nwhich offers yes/no in these cases:\n\n```\n> myprog -o<TAB>\n> myprog --output=<TAB>\n> myprog -o <TAB>\n> myprog --output <TAB>\n```\n\nIn the latter two cases, files will also be offered because file completion is enabled by default.\n\nYou would either inhibit file completion for a single option:\n\n```\ncomplete -c myprog -s o -l output --no-files -ra \"yes no\"\n```\n\nor with a specific condition:\n\n```\ncomplete -c myprog -f --condition '__fish_seen_subcommand_from somesubcommand'\n```\n\nor you can disable file completions globally for the command:\n\n```\ncomplete -c myprog -f\n```\n\nIf you have disabled them globally, you can enable them just for a specific condition or option with the `--force-files` / `-F` option:\n\n```\n# Disable files by default\ncomplete -c myprog -f\n# but reenable them for --config-file\ncomplete -c myprog -l config-file --force-files -r\n```\n\nAs a more comprehensive example, here’s a commented excerpt of the completions for systemd’s `timedatectl`:\n\n```\n# All subcommands that timedatectl knows - this is useful for later.\nset -l commands status set-time set-timezone list-timezones set-local-rtc set-ntp\n\n# Disable file completions for the entire command\n# because it does not take files anywhere\n# Note that this can be undone by using \"-F\".\n#\n# File completions also need to be disabled\n# if you want to have more control over what files are offered\n# (e.g. just directories, or just files ending in \".mp3\").\ncomplete -c timedatectl -f\n\n# This line offers the subcommands\n# -\"status\",\n# -\"set-timezone\",\n# -\"set-time\"\n# -\"list-timezones\"\n# if no subcommand has been given so far.\n#\n# The `-n`/`--condition` option takes script as a string, which it executes.\n# If it returns true, the completion is offered.\n# Here the condition is the `__fish_seen_subcommands_from` helper function.\n# If returns true if any of the given commands is used on the commandline,\n# as determined by a simple heuristic.\n# For more complex uses, you can write your own function.\n# See e.g. the git completions for an example.\n#\ncomplete -c timedatectl -n \"not __fish_seen_subcommand_from $commands\" \\\n    -a \"status set-time set-timezone list-timezones\"\n\n# If the \"set-timezone\" subcommand is used,\n# offer the output of `timedatectl list-timezones` as completions.\n# Each line of output is used as a separate candidate,\n# and anything after a tab is taken as the description.\n# It's often useful to transform command output with `string` into that form.\ncomplete -c timedatectl -n \"__fish_seen_subcommand_from set-timezone\" \\\n    -a \"(timedatectl list-timezones)\"\n\n# Completion candidates can also be described via `-d`,\n# which is useful if the description is constant.\n# Try to keep these short, because that means the user gets to see more at once.\ncomplete -c timedatectl -n \"not __fish_seen_subcommand_from $commands\" \\\n    -a \"set-local-rtc\" -d \"Maintain RTC in local time\"\n\n# We can also limit options to certain subcommands by using conditions.\ncomplete -c timedatectl -n \"__fish_seen_subcommand_from set-local-rtc\" \\\n    -l adjust-system-clock -d 'Synchronize system clock from the RTC'\n\n# These are simple options that can be used everywhere.\ncomplete -c timedatectl -s h -l help -d 'Print a short help text and exit'\ncomplete -c timedatectl -l version -d 'Print a short version string and exit'\ncomplete -c timedatectl -l no-pager -d 'Do not pipe output into a pager'\n```\n\nFor examples of how to write your own complex completions, study the completions in `/usr/share/fish/completions`. (The exact path depends on your chosen installation prefix and may be slightly different)\n\n## Useful functions for writing completions\n\n`fish` ships with several functions that may be useful when writing command-specific completions. Most of these function names begin with the string `__fish_`. Such functions are internal to `fish` and their name and interface may change in future fish versions. A few of these functions are described here.\n\nFunctions beginning with the string `__fish_print_` print a newline separated list of strings. For example, `__fish_print_filesystems` prints a list of all known file systems. Functions beginning with `__fish_complete_` print out a newline separated list of completions with descriptions. The description is separated from the completion by a tab character.\n\n- `__fish_complete_directories STRING DESCRIPTION` performs path completion on STRING, allowing only directories, and giving them the description DESCRIPTION.\n- `__fish_complete_path STRING DESCRIPTION` performs path completion on STRING, giving them the description DESCRIPTION.\n- `__fish_complete_groups` prints a list of all user groups with the groups members as description.\n- `__fish_complete_pids` prints a list of all processes IDs with the command name as description.\n- `__fish_complete_suffix SUFFIX` performs file completion but sorts files ending in SUFFIX first. This is useful in conjunction with `complete --keep-order`.\n- `__fish_complete_users` prints a list of all users with their full name as description.\n- `__fish_print_filesystems` prints a list of all known file systems. Currently, this is a static list, and not dependent on what file systems the host operating system actually understands.\n- `__fish_print_hostnames` prints a list of all known hostnames. This function searches the fstab for nfs servers, ssh for known hosts and checks the `/etc/hosts` file.\n- `__fish_print_interfaces` prints a list of all known network interfaces.\n- `__fish_print_packages` prints a list of all installed packages. This function currently handles Debian, rpm and Gentoo packages.\n\n## Where to put completions\n\nCompletions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. Fish automatically searches through any directories in the list variable `$fish_complete_path`, and any completions defined are automatically loaded when needed. A completion file must have a filename consisting of the name of the command to complete and the suffix `.fish`.\n\nBy default, Fish searches the following for completions, using the first available file that it finds:\n\n- A directory for end-users to keep their own completions, usually `~/.config/fish/completions` (controlled by the `XDG_CONFIG_HOME` environment variable);\n- A directory for systems administrators to install completions for all users on the system, usually `/etc/fish/completions`;\n- A user-specified directory for third-party vendor completions, usually `~/.local/share/fish/vendor_completions.d` (controlled by the `XDG_DATA_HOME` environment variable);\n- A directory for third-party software vendors to ship their own completions for their software, usually `/usr/share/fish/vendor_completions.d`;\n- The completions shipped with fish, usually installed in `/usr/share/fish/completions`; and\n- Completions automatically generated from the operating system’s manual, usually stored in `~/.local/share/fish/generated_completions`.\n\nThese paths are controlled by parameters set at build, install, or run time, and may vary from the defaults listed above.\n\nThis wide search may be confusing. If you are unsure, your completions probably belong in `~/.config/fish/completions`.\n\nIf you have written new completions for a common Unix command, please consider sharing your work by submitting it via the instructions in [Further help and development](index#more-help).\n\nIf you are developing another program and would like to ship completions with your program, install them to the “vendor” completions directory. As this path may vary from system to system, the `pkgconfig` framework should be used to discover this path with the output of `pkg-config --variable completionsdir fish`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/completions.html](https://fishshell.com/docs/3.7/completions.html)"
- name: contains
  summary: contains tests whether the set VALUES contains the string KEY
  description: "# contains - test if a word is present in a list\n\n## Synopsis\n\n```\ncontains [OPTIONS] KEY [VALUES ...]\n```\n\n## Description\n\n`contains` tests whether the set *VALUES* contains the string *KEY*. If so, `contains` exits with code 0; if not, it exits with code 1.\n\nThe following options are available:\n\n**-i** or **--index**  \nPrint the index (number of the element in the set) of the first matching element.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nNote that `contains` interprets all arguments starting with a **-** as an option to `contains`, until an **--** argument is reached.\n\nSee the examples below.\n\n## Example\n\nIf *animals* is a list of animals, the following will test if *animals* contains “cat”:\n\n```\nif contains cat $animals\n   echo Your animal list is evil!\nend\n```\n\nThis code will add some directories to [`PATH`](../language#envvar-PATH) if they aren’t yet included:\n\n```\nfor i in ~/bin /usr/local/bin\n    if not contains $i $PATH\n        set PATH $PATH $i\n    end\nend\n```\n\nWhile this will check if function `hasargs` is being ran with the **-q** option:\n\n```\nfunction hasargs\n    if contains -- -q $argv\n        echo '$argv contains a -q option'\n    end\nend\n```\n\nThe **--** here stops `contains` from treating **-q** to an option to itself. Instead it treats it as a normal string to check.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/contains.html](https://fishshell.com/docs/3.7/cmds/contains.html)"
- name: continue
  summary: continue skips the remainder of the current iteration of the current inner loop, such as a for loop or a while loop
  description: "# continue - skip the remainder of the current iteration of the current inner loop\n\n## Synopsis\n\n```\nLOOP_CONSTRUCT; [COMMANDS ...;] continue; [COMMANDS ...;] end\n```\n\n## Description\n\n`continue` skips the remainder of the current iteration of the current inner loop, such as a [for](for) loop or a [while](while) loop. It is usually added inside of a conditional block such as an [if](if) statement or a [switch](switch) statement.\n\n## Example\n\nThe following code removes all tmp files that do not contain the word smurf.\n\n```\nfor i in *.tmp\n    if grep smurf $i\n        continue\n    end\n    # This \"rm\" is skipped over if \"continue\" is executed.\n    rm $i\n    # As is this \"echo\"\n    echo $i\nend\n```\n\n## See Also\n\n- the [break](break) command, to stop the current inner loop\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/continue.html](https://fishshell.com/docs/3.7/cmds/continue.html)"
- name: count
  summary: count prints the number of arguments that were passed to it, plus the number of newlines passed to it via stdin
  description: "# count - count the number of elements of a list\n\n## Synopsis\n\n```\ncount STRING1 STRING2 ...\nCOMMAND | count\ncount [...] < FILE\n```\n\n## Description\n\n`count` prints the number of arguments that were passed to it, plus the number of newlines passed to it via stdin. This is usually used to find out how many elements an environment variable list contains, or how many lines there are in a text file.\n\n`count` does not accept any options, not even `-h` or `--help`.\n\n`count` exits with a non-zero exit status if no arguments were passed to it, and with zero if at least one argument was passed.\n\nNote that, like `wc -l`, reading from stdin counts newlines, so `echo -n foo | count` will print 0.\n\n## Example\n\n```\ncount $PATH\n# Returns the number of directories in the users PATH variable.\n\ncount *.txt\n# Returns the number of files in the current working directory\n# ending with the suffix '.txt'.\n\ngit ls-files --others --exclude-standard | count\n# Returns the number of untracked files in a git repository\n\nprintf '%s\\n' foo bar | count baz\n# Returns 3 (2 lines from stdin plus 1 argument)\n\ncount < /etc/hosts\n# Counts the number of entries in the hosts file\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/count.html](https://fishshell.com/docs/3.7/cmds/count.html)"
- name: dirh
  summary: dirh prints the current directory history
  description: "# dirh - print directory history\n\n## Synopsis\n\n```\ndirh\n```\n\n## Description\n\n`dirh` prints the current [directory history](../interactive#directory-history). The current position in the history is highlighted using the color defined in the `fish_color_history_current` environment variable.\n\n`dirh` does not accept any parameters.\n\nNote that the [cd](cd) command limits directory history to the 25 most recently visited directories. The history is stored in the `$dirprev` and `$dirnext` variables.\n\n## See Also\n\n- the [cdh](cdh) command to display a prompt to quickly navigate the history\n- the [prevd](prevd) command to move backward\n- the [nextd](nextd) command to move forward\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/dirh.html](https://fishshell.com/docs/3.7/cmds/dirh.html)"
- name: dirs
  summary: dirs prints the current directory stack, as created by pushd and modified by popd
  description: "# dirs - print directory stack\n\n## Synopsis\n\n```\ndirs [-c]\n```\n\n## Description\n\n`dirs` prints the current [directory stack](../interactive#directory-stack), as created by [pushd](pushd) and modified by [popd](popd).\n\nThe following options are available:\n\n**-c**:  \nClear the directory stack instead of printing it.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n`dirs` does not accept any arguments.\n\n## See Also\n\n- the [cdh](cdh) command, which provides a more intuitive way to navigate to recently visited directories.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/dirs.html](https://fishshell.com/docs/3.7/cmds/dirs.html)"
- name: disown
  summary: disown removes the specified job from the list of jobs
  description: "# disown - remove a process from the list of jobs\n\n## Synopsis\n\n```\ndisown [PID ...]\n```\n\n## Description\n\n`disown` removes the specified [job](../language#syntax-job-control) from the list of jobs. The job itself continues to exist, but fish does not keep track of it any longer.\n\nJobs in the list of jobs are sent a hang-up signal when fish terminates, which usually causes the job to terminate; `disown` allows these processes to continue regardless.\n\nIf no process is specified, the most recently-used job is removed (like [bg](bg) and [fg](fg)). If one or more PIDs are specified, jobs with the specified process IDs are removed from the job list. Invalid jobs are ignored and a warning is printed.\n\nIf a job is stopped, it is sent a signal to continue running, and a warning is printed. It is not possible to use the [bg](bg) builtin to continue a job once it has been disowned.\n\n`disown` returns 0 if all specified jobs were disowned successfully, and 1 if any problems were encountered.\n\nThe **--help** or **-h** option displays help about using this command.\n\n## Example\n\n`firefox &; disown` will start the Firefox web browser in the background and remove it from the job list, meaning it will not be closed when the fish process is closed.\n\n`disown (jobs -p)` removes all [jobs](jobs) from the job list without terminating them.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/disown.html](https://fishshell.com/docs/3.7/cmds/disown.html)"
- name: echo
  summary: echo displays STRING of text
  description: "# echo - display a line of text\n\n## Synopsis\n\n```\necho [OPTIONS] [STRING]\n```\n\n## Description\n\n`echo` displays *STRING* of text.\n\nThe following options are available:\n\n**-n**  \nDo not output a newline.\n\n**-s**  \nDo not separate arguments with spaces.\n\n**-E**  \nDisable interpretation of backslash escapes (default).\n\n**-e**  \nEnable interpretation of backslash escapes.\n\nUnlike other shells, this echo accepts `--` to signal the end of the options.\n\n## Escape Sequences\n\nIf `-e` is used, the following sequences are recognized:\n\n- `\\` backslash\n- `\\a` alert (BEL)\n- `\\b` backspace\n- `\\c` produce no further output\n- `\\e` escape\n- `\\f` form feed\n- `\\n` new line\n- `\\r` carriage return\n- `\\t` horizontal tab\n- `\\v` vertical tab\n- `\\0NNN` byte with octal value NNN (1 to 3 digits)\n- `\\xHH` byte with hexadecimal value HH (1 to 2 digits)\n\n## Example\n\n```\n> echo 'Hello World'\nHello World\n\n> echo -e 'Top\\nBottom'\nTop\nBottom\n\n> echo -- -n\n-n\n```\n\n## See Also\n\n- the [printf](printf) command, for more control over output formatting\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/echo.html](https://fishshell.com/docs/3.7/cmds/echo.html)"
- name: else
  summary: if will execute the command CONDITION*
  description: "# else - execute command if a condition is not met\n\n## Synopsis\n\n```\nif CONDITION; COMMANDS_TRUE ...; [else; COMMANDS_FALSE ...;] end\n```\n\n## Description\n\n[if](if) will execute the command *CONDITION\\**. If the condition’s exit status is 0, the commands *COMMANDS_TRUE* will execute. If it is not 0 and **else** is given, *COMMANDS_FALSE* will be executed.\n\n## Example\n\nThe following code tests whether a file *foo.txt* exists as a regular file.\n\n```\nif test -f foo.txt\n    echo foo.txt exists\nelse\n    echo foo.txt does not exist\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/else.html](https://fishshell.com/docs/3.7/cmds/else.html)"
- name: emit
  summary: emit emits, or fires, an event
  description: "# emit - emit a generic event\n\n## Synopsis\n\n```\nemit EVENT_NAME [ARGUMENTS ...]\n```\n\n## Description\n\n`emit` emits, or fires, an event. Events are delivered to, or caught by, special functions called [event handlers](../language#event). The arguments are passed to the event handlers as function arguments.\n\nThe **--help** or **-h** option displays help about using this command.\n\n## Example\n\nThe following code first defines an event handler for the generic event named ‘test_event’, and then emits an event of that type.\n\n```\nfunction event_test --on-event test_event\n    echo event test: $argv\nend\n\nemit test_event something\n```\n\n## Notes\n\nNote that events are only sent to the current fish process as there is no way to send events from one fish process to another.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/emit.html](https://fishshell.com/docs/3.7/cmds/emit.html)"
- name: end
  summary: 'The end keyword ends a block of commands started by one of the following commands:'
  description: "# end - end a block of commands\n\n## Synopsis\n\n```\nbegin\n    [COMMANDS ...]\nend\n```\n\n```\nfunction NAME [OPTIONS]; COMMANDS ...; end\nif CONDITION; COMMANDS_TRUE ...; [else; COMMANDS_FALSE ...;] end\nswitch VALUE; [case [WILDCARD ...]; [COMMANDS ...]; ...] end\nwhile CONDITION; COMMANDS ...; end\nfor VARNAME in [VALUES ...]; COMMANDS ...; end\n```\n\n## Description\n\nThe **end** keyword ends a block of commands started by one of the following commands:\n\n- [begin](begin) to start a block of commands\n- [function](function) to define a function\n- [if](if), [switch](switch) to conditionally execute commands\n- [while](while), [for](for) to perform commands multiple times\n\nThe **end** keyword does not change the current exit status. Instead, the status after it will be the status returned by the most recent command.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/end.html](https://fishshell.com/docs/3.7/cmds/end.html)"
- name: eval
  summary: eval evaluates the specified parameters as a command
  description: "# eval - evaluate the specified commands\n\n## Synopsis\n\n```\neval [COMMANDS ...]\n```\n\n## Description\n\n**eval** evaluates the specified parameters as a command. If more than one parameter is specified, all parameters will be joined using a space character as a separator.\n\nIf the command does not need access to stdin, consider using [source](source) instead.\n\nIf no piping or other compound shell constructs are required, variable-expansion-as-command, as in `set cmd ls -la; $cmd`, is also an option.\n\n## Example\n\nThe following code will call the ls command and truncate each filename to the first 12 characters.\n\n```\nset cmd ls \\| cut -c 1-12\neval $cmd\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/eval.html](https://fishshell.com/docs/3.7/cmds/eval.html)"
- name: exec
  summary: exec replaces the currently running shell with a new command
  description: "# exec - execute command in current process\n\n## Synopsis\n\n```\nexec COMMAND\n```\n\n## Description\n\n`exec` replaces the currently running shell with a new command. On successful completion, `exec` never returns. `exec` cannot be used inside a pipeline.\n\nThe **--help** or **-h** option displays help about using this command.\n\n## Example\n\n`exec emacs` starts up the emacs text editor, and exits `fish`. When emacs exits, the session will terminate.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/exec.html](https://fishshell.com/docs/3.7/cmds/exec.html)"
- name: exit
  summary: exit is a special builtin that causes the shell to exit
  description: "# exit - exit the shell\n\n## Synopsis\n\n```\nexit [CODE]\n```\n\n## Description\n\n**exit** is a special builtin that causes the shell to exit. Either 255 or the *CODE* supplied is used, whichever is lesser. Otherwise, the exit status will be that of the last command executed.\n\nIf exit is called while sourcing a file (using the [source](source) builtin) the rest of the file will be skipped, but the shell itself will not exit.\n\nThe **--help** or **-h** option displays help about using this command.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/exit.html](https://fishshell.com/docs/3.7/cmds/exit.html)"
- name: 'false'
  summary: false sets the exit status to 1
  description: "# false - return an unsuccessful result\n\n## Synopsis\n\n```\nfalse\n```\n\n## Description\n\n`false` sets the exit status to 1.\n\n## See Also\n\n- [true](true) command\n- [\\$status](../language#variables-status) variable\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/false.html](https://fishshell.com/docs/3.7/cmds/false.html)"
- name: FAQ
  summary: See Fish for bash users
  description: "# Frequently asked questions\n\n## What is the equivalent to this thing from bash (or other shells)?\n\nSee [Fish for bash users](fish_for_bash_users#fish-for-bash-users)\n\n## How do I set or clear an environment variable?\n\nUse the [set](cmds/set) command:\n\n```\nset -x key value # typically set -gx key value\nset -e key\n```\n\nSince fish 3.1 you can set an environment variable for just one command using the `key=value some command` syntax, like in other shells. The two lines below behave identically - unlike other shells, fish will output `value` both times:\n\n```\nkey=value echo $key\nbegin; set -lx key value; echo $key; end\n```\n\nNote that “exported” is not a [scope](language#variables-scope), but an additional bit of state. A variable can be global and exported or local and exported or even universal and exported. Typically it makes sense to make an exported variable global.\n\n## How do I check whether a variable is defined?\n\nUse `set -q var`. For example, `if set -q var; echo variable defined; end`. To check multiple variables you can combine with `and` and `or` like so:\n\n```\nif set -q var1; or set -q var2\n    echo either variable defined\nend\n```\n\nKeep in mind that a defined variable could also be empty, either by having no elements (if set like `set var`) or only empty elements (if set like `set var \"\"`). Read on for how to deal with those.\n\n## How do I check whether a variable is not empty?\n\nUse `string length -q -- $var`. For example, `if string length -q -- $var; echo not empty; end`. Note that `string length` will interpret a list of multiple variables as a disjunction (meaning any/or):\n\n```\nif string length -q -- $var1 $var2 $var3\n    echo at least one of these variables is not empty\nend\n```\n\nAlternatively, use `test -n \"$var\"`, but remember that **the variable must be double-quoted**. For example, `if test -n \"$var\"; echo not empty; end`. The `test` command provides its own and (-a) and or (-o):\n\n```\nif test -n \"$var1\" -o -n \"$var2\" -o -n \"$var3\"\n    echo at least one of these variables is not empty\nend\n```\n\nIf you want to know if a variable has *no elements*, use `set -q var[1]`.\n\n## Why doesn’t `set -Ux` (exported universal variables) seem to work?\n\nA global variable of the same name already exists.\n\nEnvironment variables such as `EDITOR` or `TZ` can be set universally using `set -Ux`. However, if there is an environment variable already set before fish starts (such as by login scripts or system administrators), it is imported into fish as a global variable. The [variable scopes](language#variables-scope) are searched from the “inside out”, which means that local variables are checked first, followed by global variables, and finally universal variables.\n\nThis means that the global value takes precedence over the universal value.\n\nTo avoid this problem, consider changing the setting which fish inherits. If this is not possible, add a statement to your [configuration file](language#configuration) (usually `~/.config/fish/config.fish`):\n\n```\nset -gx EDITOR vim\n```\n\n## How do I run a command every login? What’s fish’s equivalent to .bashrc or .profile?\n\nEdit the file `~/.config/fish/config.fish` [\\[1\\]](#id2), creating it if it does not exist (Note the leading period).\n\nUnlike .bashrc and .profile, this file is always read, even in non-interactive or login shells.\n\nTo do something only in interactive shells, check `status is-interactive` like:\n\n```\nif status is-interactive\n    # use the coolbeans theme\n    fish_config theme choose coolbeans\nend\n```\n\n\\[[1](#id1)\\]\n\nThe “~/.config” part of this can be set via \\$XDG_CONFIG_HOME, that’s just the default.\n\n## How do I set my prompt?\n\nThe prompt is the output of the `fish_prompt` function. Put it in `~/.config/fish/functions/fish_prompt.fish`. For example, a simple prompt is:\n\n```\nfunction fish_prompt\n    set_color $fish_color_cwd\n    echo -n (prompt_pwd)\n    set_color normal\n    echo -n ' > '\nend\n```\n\nYou can also use the Web configuration tool, [fish_config](cmds/fish_config), to preview and choose from a gallery of sample prompts.\n\nOr you can use fish_config from the commandline:\n\n```\n> fish_config prompt show\n# displays all the prompts fish ships with\n> fish_config prompt choose disco\n# loads the disco prompt in the current shell\n> fish_config prompt save\n# makes the change permanent\n```\n\nIf you want to modify your existing prompt, you can use [funced](cmds/funced) and [funcsave](cmds/funcsave) like:\n\n```\n>_ funced fish_prompt\n# This opens up your editor (set in $EDITOR).\n# Modify the function,\n# save the file and repeat to your liking.\n# Once you are happy with it:\n>_ funcsave fish_prompt\n```\n\nThis also applies to [fish_right_prompt](cmds/fish_right_prompt) and [fish_mode_prompt](cmds/fish_mode_prompt).\n\n## Why does my prompt show a `[I]`?\n\nThat’s the [fish_mode_prompt](cmds/fish_mode_prompt). It is displayed by default when you’ve activated vi mode using `fish_vi_key_bindings`.\n\nIf you haven’t activated vi mode on purpose, you might have installed a third-party theme or plugin that does it.\n\nIf you want to change or disable this display, modify the `fish_mode_prompt` function, for instance via [funced](cmds/funced).\n\n## How do I customize my syntax highlighting colors?\n\nUse the web configuration tool, [fish_config](cmds/fish_config), or alter the [fish_color family of environment variables](interactive#variables-color).\n\nYou can also use `fish_config` on the commandline, like:\n\n```\n> fish_config theme show\n# to demonstrate all the colorschemes\n> fish_config theme choose coolbeans\n# to load the \"coolbeans\" theme\n> fish_config theme save\n# to make the change permanent\n```\n\n## How do I change the greeting message?\n\nChange the value of the variable `fish_greeting` or create a [fish_greeting](cmds/fish_greeting) function. For example, to remove the greeting use:\n\n```\nset -U fish_greeting\n```\n\nOr if you prefer not to use a universal variable, use:\n\n```\nset -g fish_greeting\n```\n\nin [config.fish](language#configuration).\n\n## How do I run a command from history?\n\nType some part of the command, and then hit the ↑ (up) or ↓ (down) arrow keys to navigate through history matches, or press Control+R to open the history in a searchable pager. In this pager you can press Control+R or Control+S to move to older or younger history respectively.\n\nAdditional default key bindings include Control+P (up) and Control+N (down). See [Searchable command history](interactive#history-search) for more information.\n\n## Why doesn’t history substitution (“!\\$” etc.) work?\n\nBecause history substitution is an awkward interface that was invented before interactive line editing was even possible. Instead of adding this pseudo-syntax, fish opts for nice history searching and recall features. Switching requires a small change of habits: if you want to modify an old line/word, first recall it, then edit.\n\nAs a special case, most of the time history substitution is used as `sudo !!`. In that case just press Alt+S, and it will recall your last commandline with `sudo` prefixed (or toggle a `sudo` prefix on the current commandline if there is anything).\n\nIn general, fish’s history recall works like this:\n\n- Like other shells, the Up arrow, ↑ recalls whole lines, starting from the last executed line. A single press replaces “!!”, later presses replace “!-3” and the like.\n- If the line you want is far back in the history, type any part of the line and then press Up one or more times. This will filter the recalled lines to ones that include this text, and you will get to the line you want much faster. This replaces “!vi”, “!?bar.c” and the like.\n- Alt+↑ recalls individual arguments, starting from the last argument in the last executed line. A single press replaces “!\\$”, later presses replace “!!:4” and such. As an alternate key binding, Alt+. can be used.\n- If the argument you want is far back in history (e.g. 2 lines back - that’s a lot of words!), type any part of it and then press Alt+↑. This will show only arguments containing that part and you will get what you want much faster. Try it out, this is very convenient!\n- If you want to reuse several arguments from the same line (“!!:3\\*” and the like), consider recalling the whole line and removing what you don’t need (Alt+D and Alt+Backspace are your friends).\n\nSee [documentation](interactive#editor) for more details about line editing in fish.\n\n## How do I run a subcommand? The backtick doesn’t work!\n\n`fish` uses parentheses for subcommands. For example:\n\n```\nfor i in (ls)\n    echo $i\nend\n```\n\nIt also supports the familiar `$()` syntax, even in quotes. Backticks are not supported because they are discouraged even in POSIX shells. They nest poorly and are hard to tell from single quotes (`''`).\n\n## My command (pkg-config) gives its output as a single long string?\n\nUnlike other shells, fish splits command substitutions only on newlines, not spaces or tabs or the characters in \\$IFS.\n\nThat means if you run\n\n```\ncount (printf '%s ' a b c)\n```\n\nIt will print `1`, because the “a b c “ is used in one piece. But if you do\n\n```\ncount (printf '%s\\n' a b c)\n```\n\nit will print `3`, because it gave `count` the arguments “a”, “b” and “c” separately.\n\nIn the overwhelming majority of cases, splitting on spaces is unwanted, so this is an improvement. This is why you hear about problems with filenames with spaces, after all.\n\nHowever sometimes, especially with `pkg-config` and related tools, splitting on spaces is needed.\n\nIn these cases use `string split -n \" \"` like:\n\n```\ng++ example_01.cpp (pkg-config --cflags --libs gtk+-2.0 | string split -n \" \")\n```\n\nThe `-n` is so empty elements are removed like POSIX shells would do.\n\n## How do I get the exit status of a command?\n\nUse the `$status` variable. This replaces the `$?` variable used in other shells.\n\n```\nsomecommand\nif test $status -eq 7\n    echo \"That's my lucky number!\"\nend\n```\n\nIf you are just interested in success or failure, you can run the command directly as the if-condition:\n\n```\nif somecommand\n    echo \"Command succeeded\"\nelse\n    echo \"Command failed\"\nend\n```\n\nOr if you just want to do one command in case the first succeeded or failed, use `and` or `or`:\n\n```\nsomecommand\nor someothercommand\n```\n\nSee the [Conditions](language#syntax-conditional) and the documentation for [test](cmds/test) and [if](cmds/if) for more information.\n\n## My command prints “No matches for wildcard” but works in bash\n\nIn short: [quote](language#quotes) or [escape](language#escapes) the wildcard:\n\n```\nscp user@ip:/dir/\"string-*\"\n```\n\nWhen fish sees an unquoted `*`, it performs [wildcard expansion](language#expand-wildcard). That means it tries to match filenames to the given string.\n\nIf the wildcard doesn’t match any files, fish prints an error instead of running the command:\n\n```\n> echo *this*does*not*exist\nfish: No matches for wildcard '*this*does*not*exist'. See `help expand`.\necho *this*does*not*exist\n     ^\n```\n\nNow, bash also tries to match files in this case, but when it doesn’t find a match, it passes along the literal wildcard string instead.\n\nThat means that commands like the above\n\n```\nscp user@ip:/dir/string-*\n```\n\nor\n\n```\napt install postgres-*\n```\n\nappear to work, because most of the time the string doesn’t match and so it passes along the `string-*`, which is then interpreted by the receiving program.\n\nBut it also means that these commands can stop working at any moment once a matching file is encountered (because it has been created or the command is executed in a different working directory), and to deal with that bash needs workarounds like\n\n```\nfor f in ./*.mpg; do\n      # We need to test if the file really exists because\n      # the wildcard might have failed to match.\n      test -f \"$f\" || continue\n      mympgviewer \"$f\"\ndone\n```\n\n(from [http://mywiki.wooledge.org/BashFAQ/004](http://mywiki.wooledge.org/BashFAQ/004))\n\nFor these reasons, fish does not do this, and instead expects asterisks to be quoted or escaped if they aren’t supposed to be expanded.\n\nThis is similar to bash’s “failglob” option.\n\n## I accidentally entered a directory path and fish changed directory. What happened?\n\nIf fish is unable to locate a command with a given name, and it starts with `.`, `/` or `~`, fish will test if a directory of that name exists. If it does, it assumes that you want to change your directory. For example, the fastest way to switch to your home directory is to simply press `~` and enter.\n\n## The open command doesn’t work.\n\nThe `open` command uses the MIME type database and the `.desktop` files used by Gnome and KDE to identify filetypes and default actions. If at least one of these environments is installed, but the open command is not working, this probably means that the relevant files are installed in a non-standard location. Consider [asking for more help](index#more-help).\n\n## Why won’t SSH/SCP/rsync connect properly when fish is my login shell?\n\nThis problem may show up as messages like “`Received message too long`”, “`open terminal failed: not a terminal`”, “`Bad packet length`”, or “`Connection refused`” with strange output in `ssh_exchange_identification` messages in the debug log.\n\nThis usually happens because fish reads the [user configuration file](language#configuration) (`~/.config/fish/config.fish`) *always*, whether it’s in an interactive or login or non-interactive or non-login shell.\n\nThis simplifies matters, but it also means when config.fish generates output, it will do that even in non-interactive shells like the one ssh/scp/rsync start when they connect.\n\nAnything in config.fish that produces output should be guarded with `status is-interactive` (or `status is-login` if you prefer):\n\n```\nif status is-interactive\n  ...\nend\n```\n\nThe same applies for example when you start `tmux` in config.fish without guards, which will cause a message like `sessions should be nested with care, unset $TMUX to force`.\n\n## I’m getting weird graphical glitches (a staircase effect, ghost characters, cursor in the wrong position,…)?\n\nIn a terminal, the application running inside it and the terminal itself need to agree on the width of characters in order to handle cursor movement.\n\nThis is more important to fish than other shells because features like syntax highlighting and autosuggestions are implemented by moving the cursor.\n\nSometimes, there is disagreement on the width. There are numerous causes and fixes for this:\n\n- It is possible the character is simply too new for your system to know - in this case you need to refrain from using it.\n- Fish or your terminal might not know about the character or handle it wrong - in this case fish or your terminal needs to be fixed, or you need to update to a fixed version.\n- The character has an “ambiguous” width and fish thinks that means a width of X while your terminal thinks it’s Y. In this case you either need to change your terminal’s configuration or set \\$fish_ambiguous_width to the correct value.\n- The character is an emoji and the host system only supports Unicode 8, while you are running the terminal on a system that uses Unicode \\>= 9. In this case set \\$fish_emoji_width to 2.\n\nThis also means that a few things are unsupportable:\n\n- Non-monospace fonts - there is *no way* for fish to figure out what width a specific character has as it has no influence on the terminal’s font rendering.\n- Different widths for multiple ambiguous width characters - there is no way for fish to know which width you assign to each character.\n\n## Uninstalling fish\n\nIf you want to uninstall fish, first make sure fish is not set as your shell. Run `chsh -s /bin/bash` if you are not sure.\n\nIf you installed it with a package manager, just use that package manager’s uninstall function. If you built fish yourself, assuming you installed it to /usr/local, do this:\n\n```\nrm -Rf /usr/local/etc/fish /usr/local/share/fish ~/.config/fish\nrm /usr/local/share/man/man1/fish*.1\ncd /usr/local/bin\nrm -f fish fish_indent\n```\n\n## Where can I find extra tools for fish?\n\nThe fish user community extends fish in unique and useful ways via scripts that aren’t always appropriate for bundling with the fish package. Typically because they solve a niche problem unlikely to appeal to a broad audience. You can find those extensions, including prompts, themes and useful functions, in various third-party repositories. These include:\n\n- [Fisher](https://github.com/jorgebucaran/fisher)\n- [Fundle](https://github.com/tuvistavie/fundle)\n- [Oh My Fish](https://github.com/oh-my-fish/oh-my-fish)\n- [Tacklebox](https://github.com/justinmayer/tacklebox)\n\nThis is not an exhaustive list and the fish project has no opinion regarding the merits of the repositories listed above or the scripts found therein.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/faq.html](https://fishshell.com/docs/3.7/faq.html)"
- name: fg
  summary: The fg builtin brings the specified job to the foreground, resuming it if it is stopped
  description: "# fg - bring job to foreground\n\n## Synopsis\n\n```\nfg [PID]\n```\n\n## Description\n\nThe **fg** builtin brings the specified [job](../language#syntax-job-control) to the foreground, resuming it if it is stopped. While a foreground job is executed, fish is suspended. If no job is specified, the last job to be used is put in the foreground. If `PID` is specified, the job containing a process with the specified process ID is put in the foreground.\n\nFor compatibility with other shells, job expansion syntax is supported for `fg`. A *PID* of the format **%1** will foreground job 1. Job numbers can be seen in the output of [jobs](jobs).\n\nThe **--help** or **-h** option displays help about using this command.\n\n## Example\n\n`fg` will put the last job in the foreground.\n\n`fg %3` will put job 3 into the foreground.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fg.html](https://fishshell.com/docs/3.7/cmds/fg.html)"
- name: fish
  summary: fish is a command-line shell written mainly with interactive use in mind
  description: "# fish - the friendly interactive shell\n\n## Synopsis\n\n```\nfish [OPTIONS] [FILE [ARG ...]]\nfish [OPTIONS] [-c COMMAND [ARG ...]]\n```\n\n## Description\n\n**fish** is a command-line shell written mainly with interactive use in mind. This page briefly describes the options for invoking **fish**. The [full manual](../index#intro) is available in HTML by using the **help** command from inside fish, and in the `fish-doc(1)` man page. The [tutorial](../tutorial#tutorial) is available as HTML via `help tutorial` or in `man fish-tutorial`.\n\nThe following options are available:\n\n**-c** or **--command=COMMAND**  \nEvaluate the specified commands instead of reading from the commandline, passing additional positional arguments through `$argv`.\n\n**-C** or **--init-command=COMMANDS**  \nEvaluate specified commands after reading the configuration but before executing command specified by **-c** or reading interactive input.\n\n**-d** or **--debug=DEBUG_CATEGORIES**  \nEnables debug output and specify a pattern for matching debug categories. See [Debugging](#debugging-fish) below for details.\n\n**-o** or **--debug-output=DEBUG_FILE**  \nSpecifies a file path to receive the debug output, including categories and [`fish_trace`](../language#envvar-fish_trace). The default is stderr.\n\n**-i** or **--interactive**  \nThe shell is interactive.\n\n**-l** or **--login**  \nAct as if invoked as a login shell.\n\n**-N** or **--no-config**  \nDo not read configuration files.\n\n**-n** or **--no-execute**  \nDo not execute any commands, only perform syntax checking.\n\n**-p** or **--profile=PROFILE_FILE**  \nwhen **fish** exits, output timing information on all executed commands to the specified file. This excludes time spent starting up and reading the configuration.\n\n**--profile-startup=PROFILE_FILE**  \nWill write timing for `fish` startup to specified file.\n\n**-P** or **--private**  \nEnables [private mode](../interactive#private-mode): **fish** will not access old or store new history.\n\n**--print-rusage-self**  \nWhen **fish** exits, output stats from getrusage.\n\n**--print-debug-categories**  \nPrint all debug categories, and then exit.\n\n**-v** or **--version**  \nPrint version and exit.\n\n**-f** or **--features=FEATURES**  \nEnables one or more comma-separated [feature flags](../language#featureflags).\n\nThe `fish` exit status is generally the [exit status of the last foreground command](../language#variables-status).\n\n## Debugging\n\nWhile fish provides extensive support for [debugging fish scripts](../language#debugging), it is also possible to debug and instrument its internals. Debugging can be enabled by passing the **--debug** option. For example, the following command turns on debugging for background IO thread events, in addition to the default categories, i.e. *debug*, *error*, *warning*, and *warning-path*:\n\n```\n> fish --debug=iothread\n```\n\nAvailable categories are listed by `fish --print-debug-categories`. The **--debug** option accepts a comma-separated list of categories, and supports glob syntax. The following command turns on debugging for *complete*, *history*, *history-file*, and *profile-history*, as well as the default categories:\n\n```\n> fish --debug='complete,*history*'\n```\n\nDebug messages output to stderr by default. Note that if [`fish_trace`](../language#envvar-fish_trace) is set, execution tracing also outputs to stderr by default. You can output to a file using the **--debug-output** option:\n\n```\n> fish --debug='complete,*history*' --debug-output=/tmp/fish.log --init-command='set fish_trace on'\n```\n\nThese options can also be changed via the [`FISH_DEBUG`](../language#envvar-FISH_DEBUG) and [`FISH_DEBUG_OUTPUT`](../language#envvar-FISH_DEBUG_OUTPUT) variables. The categories enabled via **--debug** are *added* to the ones enabled by \\$FISH_DEBUG, so they can be disabled by prefixing them with **-** (**reader-\\*,-ast\\*** enables reader debugging and disables ast debugging).\n\nThe file given in **--debug-output** takes precedence over the file in [`FISH_DEBUG_OUTPUT`](../language#envvar-FISH_DEBUG_OUTPUT).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish.html](https://fishshell.com/docs/3.7/cmds/fish.html)"
- name: Fish for Bash Users
  summary: This is to give you a quick overview if you come from bash (or to a lesser extent other shells like zsh or ksh) and want to know how fish differs
  description: "# Fish for bash users\n\nThis is to give you a quick overview if you come from bash (or to a lesser extent other shells like zsh or ksh) and want to know how fish differs. Fish is intentionally not POSIX-compatible and as such some of the things you are used to work differently.\n\nMany things are similar - they both fundamentally expand commandlines to execute commands, have pipes, redirections, variables, globs, use command output in various ways. This document is there to quickly show you the differences.\n\n## Command substitutions\n\nFish spells command substitutions as `$(command)` or `(command)`, but not `` `command` ``.\n\nIn addition, it only splits them on newlines instead of \\$IFS. If you want to split on something else, use [string split](cmds/string-split), [string split0](cmds/string-split) or [string collect](cmds/string-collect). If those are used as the last command in a command substitution the splits they create are carried over. So:\n\n```\nfor i in (find . -print0 | string split0)\n```\n\nwill correctly handle all possible filenames.\n\n## Variables\n\nFish sets and erases variables with [set](cmds/set) instead of `VAR=VAL` and a variety of separate builtins like `declare` and `unset` and `export`. `set` takes options to determine the scope and exportedness of a variable:\n\n```\n# Define $PAGER *g*lobal and e*x*ported,\n# so this is like ``export PAGER=less``\nset -gx PAGER less\n\n# Define $alocalvariable only locally,\n# like ``local alocalvariable=foo``\nset -l alocalvariable foo\n```\n\nor to erase variables:\n\n```\nset -e PAGER\n```\n\n`VAR=VAL` statements are available as environment overrides:\n\n```\nPAGER=cat git log\n```\n\nFish does not perform word splitting. Once a variable has been set to a value, that value stays as it is, so double-quoting variable expansions isn’t the necessity it is in bash. [\\[1\\]](#id3)\n\nFor instance, here’s bash\n\n```\n> foo=\"bar baz\"\n> printf '\"%s\"\\n' $foo\n# will print two lines, because we didn't double-quote\n# this is word splitting\n\"bar\"\n\"baz\"\n```\n\nAnd here is fish:\n\n```\n> set foo \"bar baz\"\n> printf '\"%s\"\\n' $foo\n# foo was set as one element, so it will be passed as one element, so this is one line\n\"bar baz\"\n```\n\nAll variables are “arrays” (we use the term “lists”), and expanding a variable expands to all its elements, with each element as its own argument (like bash’s `\"${var[@]}\"`:\n\n```\n> set var \"foo bar\" banana\n> printf %s\\n $var\nfoo bar\nbanana\n```\n\nSpecific elements of a list can be selected:\n\n```\necho $list[5..7]\n```\n\nThe arguments to `set` are ordinary, so you can also set a variable to the output of a command:\n\n```\n# Set lines to all the lines in file, one element per line\nset lines (cat file)\n```\n\nor a mixture of literal values and output:\n\n```\n> set numbers 1 2 3 (seq 5 8) 9\n> printf '%s\\n' $numbers\n1\n2\n3\n5\n6\n7\n8\n9\n```\n\nA `=` is unnecessary and unhelpful with `set` - `set foo = bar` will set the variable “foo” to two values: “=” and “bar”. `set foo=bar` will print an error.\n\nSee [Shell variables](language#variables) for more.\n\n\\[[1](#id2)\\]\n\nzsh also does not perform word splitting by default (the SH_WORD_SPLIT option controls this)\n\n## Wildcards (globs)\n\nFish only supports the `*` and `**` glob (and the deprecated `?` glob) as syntax. If a glob doesn’t match it fails the command (like with bash’s `failglob`) unless the command is `for`, `set` or `count` or the glob is used with an environment override (`VAR=* command`), in which case it expands to nothing (like with bash’s `nullglob` option).\n\nGlobbing doesn’t happen on expanded variables, so:\n\n```\nset foo \"*\"\necho $foo\n```\n\nwill not match any files.\n\nThere are no options to control globbing so it always behaves like that.\n\nSee [Wildcards](language#expand-wildcard) for more.\n\n## Quoting\n\nFish has two quoting styles: `\"\"` and `''`. Variables are expanded in double-quotes, nothing is expanded in single-quotes.\n\nThere is no `$''`, instead the sequences that would transform are transformed *when unquoted*:\n\n```\n> echo a\\nb\na\nb\n```\n\nSee [Quotes](language#quotes) for more.\n\n## String manipulation\n\nFish does not have `${foo%bar}`, `${foo#bar}` and `${foo/bar/baz}`. Instead string manipulation is done by the [string](cmds/string) builtin.\n\nFor example, to replace “bar” with “baz”:\n\n```\n> string replace bar baz \"bar luhrmann\"\nbaz luhrmann\n```\n\nIt can also split strings:\n\n```\n> string split \",\" \"foo,bar\"\nfoo\nbar\n```\n\nMatch regular expressions as a replacement for `grep`:\n\n```\n> echo bababa | string match -r 'aba$'\naba\n```\n\nPad strings to a given width, with arbitrary characters:\n\n```\n> string pad -c x -w 20 \"foo\"\nxxxxxxxxxxxxxxxxxfoo\n```\n\nMake strings lower/uppercase:\n\n```\n> string lower Foo\nfoo\n\n> string upper Foo\nFOO\n```\n\nrepeat strings, trim strings, escape strings or print a string’s length or width (in terminal cells).\n\n## Special variables\n\nSome bash variables and their closest fish equivalent:\n\n- `$*`, `$@`, `$1` and so on: `$argv`\n- `$?`: `$status`\n- `$$`: `$fish_pid`\n- `$#`: No variable, instead use `count $argv`\n- `$!`: `$last_pid`\n- `$0`: `status filename`\n- `$-`: Mostly `status is-interactive` and `status is-login`\n\n## Process substitution\n\nInstead of `<(command)` fish uses `(command | psub)`. There is no equivalent to `>(command)`.\n\nNote that both of these are bashisms, and most things can easily be expressed without. E.g. instead of:\n\n```\nsource (command | psub)\n```\n\njust use:\n\n```\ncommand | source\n```\n\nas fish’s [source](cmds/source) can read from stdin.\n\n## Heredocs\n\nFish does not have `<<EOF` “heredocs”. Instead of\n\n```\ncat <<EOF\nsome string\nsome more string\nEOF\n```\n\nuse:\n\n```\nprintf %s\\n \"some string\" \"some more string\"\n```\n\nor:\n\n```\necho \"some string\nsome more string\"\n\n# or if you want the quotes on separate lines:\n\necho \"\\\nsome string\nsome more string\\\n\"\n```\n\nQuotes are followed across newlines.\n\nWhat “heredocs” do is:\n\n1.  Read/interpret the string, with special rules, up to the terminator. [\\[2\\]](#id5)\n2.  Write the resulting string to a temporary file.\n3.  Start the command the heredoc is attached to with that file as stdin.\n\nThis means it is essentially the same as just reading from a pipe, so:\n\n```\necho \"foo\" | cat\n```\n\nis mostly the same as\n\n```\ncat <<EOF\nfoo\nEOF\n```\n\nJust like with heredocs, the command has to be prepared to read from stdin. Sometimes this requires special options to be used, often giving a filename of `-` turns it on.\n\nFor example:\n\n```\necho \"xterm\nrxvt-unicode\" | pacman --remove -\n\n# is the same as (the `-` makes pacman read arguments from stdin)\npacman --remove xterm rxvt-unicode\n```\n\nand could be written in other shells as\n\n```\n# This \"-\" is still necessary - the heredoc is *also* passed over stdin!\npacman --remove - << EOF\nxterm\nrxvt-unicode\nEOF\n```\n\nSo heredocs really are just minor syntactical sugar that introduces a lot of special rules, which is why fish doesn’t have them. Pipes are a core concept, and are simpler and compose nicer.\n\n\\[[2](#id4)\\]\n\nFor example, the “EOF” is just a convention, the terminator can be an arbitrary string, something like “THISISTHEEND” also works. And using `<<-` trims leading *tab* characters (but not other whitespace), so you can indent the lines, but only with tabs. Substitutions (variables, commands) are done on the heredoc by default, but not if the terminator is quoted: `cat << \"EOF\"`.\n\n## Test (`test`, `[`, `[[`)\n\nFish has a POSIX-compatible `test` or `[` builtin. There is no `[[` and `test` does not accept `==` as a synonym for `=`. It can compare floating point numbers, however.\n\n`set -q` can be used to determine if a variable exists or has a certain number of elements (`set -q foo[2]`).\n\n## Arithmetic Expansion\n\nFish does not have `$((i+1))` arithmetic expansion, computation is handled by [math](cmds/math):\n\n```\nmath $i + 1\n```\n\nUnlike bash’s arithmetic, it can handle floating point numbers:\n\n```\n> math 5 / 2\n2.5\n```\n\nAnd also has some functions, like for trigonometry:\n\n```\n> math cos 2 x pi\n1\n```\n\nYou can pass arguments to `math` separately like above or in quotes. Because fish uses `()` parentheses for [command substitutions](#bash-command-substitutions), quoting is needed if you want to use them in your expression:\n\n```\n> math '(5 + 2) * 4'\n```\n\nBoth `*` and `x` are valid ways to spell multiplication, but `*` needs to be quoted because it looks like a [glob](#bash-globs).\n\n## Prompts\n\nFish does not use the `$PS1`, `$PS2` and so on variables. Instead the prompt is the output of the [fish_prompt](cmds/fish_prompt) function, plus the [fish_mode_prompt](cmds/fish_mode_prompt) function if vi-mode is enabled and the [fish_right_prompt](cmds/fish_right_prompt) function for the right prompt.\n\nAs an example, here’s a relatively simple bash prompt:\n\n```\n# <$HOSTNAME> <$PWD in blue> <Prompt Sign in Yellow> <Rest in default light white>\nPS1='\\h\\[\\e[1;34m\\]\\w\\[\\e[m\\] \\[\\e[1;32m\\]\\$\\[\\e[m\\] '\n```\n\nand a rough fish equivalent:\n\n```\nfunction fish_prompt\n    set -l prompt_symbol '$'\n    fish_is_root_user; and set prompt_symbol '#'\n\n    echo -s (prompt_hostname) \\\n    (set_color blue) (prompt_pwd) \\\n    (set_color yellow) $prompt_symbol (set_color normal)\nend\n```\n\nThis shows a few differences:\n\n- Fish provides [set_color](cmds/set_color) to color text. It can use the 16 named colors and also RGB sequences (so you could also use `set_color 5555FF`)\n- Instead of introducing specific escapes like `\\h` for the hostname, the prompt is simply a function. To achieve the effect of `\\h`, fish provides helper functions like [prompt_hostname](cmds/prompt_hostname), which prints a shortened version of the hostname.\n- Fish offers other helper functions for adding things to the prompt, like [fish_vcs_prompt](cmds/fish_vcs_prompt) for adding a display for common version control systems (git, mercurial, svn), and [prompt_pwd](cmds/prompt_pwd) for showing a shortened `$PWD` (the user’s home directory becomes `~` and any path component is shortened).\n\nThe default prompt is reasonably full-featured and its code can be read via `type fish_prompt`.\n\nFish does not have `$PS2` for continuation lines, instead it leaves the lines indented to show that the commandline isn’t complete yet.\n\n## Blocks and loops\n\nFish’s blocking constructs look a little different. They all start with a word, end in `end` and don’t have a second starting word:\n\n```\nfor i in 1 2 3; do\n   echo $i\ndone\n\n# becomes\n\nfor i in 1 2 3\n   echo $i\nend\n\nwhile true; do\n   echo Weeee\ndone\n\n# becomes\n\nwhile true\n   echo Weeeeeee\nend\n\n{\n   echo Hello\n}\n\n# becomes\n\nbegin\n   echo Hello\nend\n\nif true; then\n   echo Yes I am true\nelse\n   echo \"How is true not true?\"\nfi\n\n# becomes\n\nif true\n   echo Yes I am true\nelse\n   echo \"How is true not true?\"\nend\n\nfoo() {\n   echo foo\n}\n\n# becomes\n\nfunction foo\n    echo foo\nend\n\n# (bash allows the word \"function\",\n#  but this is an extension)\n```\n\nFish does not have an `until`. Use `while not` or `while !`.\n\n## Subshells\n\nBash has a feature called “subshells”, where it will start another shell process for certain things. That shell will then be independent and e.g. any changes it makes to variables won’t be visible in the main shell.\n\nThis includes things like:\n\n```\n# A list of commands in `()` parentheses\n(foo; bar) | baz\n\n# Both sides of a pipe\nfoo | while read -r bar; do\n    # This will not be visible outside of the loop.\n    VAR=VAL\n    # This background process will not be, either\n    baz &\ndone\n```\n\n`()` subshells are often confused with `{}` grouping, which does *not* use a subshell. When you just need to group, you can use `begin; end` in fish:\n\n```\n(foo; bar) | baz\n# when it should really have been:\n{ foo; bar; } | baz\n# becomes\nbegin; foo; bar; end | baz\n```\n\nThe pipe will simply be run in the same process, so `while read` loops can set variables outside:\n\n```\nfoo | while read bar\n    set -g VAR VAL\n    baz &\nend\n\necho $VAR # will print VAL\njobs # will show \"baz\"\n```\n\nSubshells are also frequently confused with [command substitutions](#bash-command-substitutions), which bash writes as `` `command` `` or `$(command)` and fish writes as `$(command)` or `(command)`. Bash also *uses* subshells to implement them.\n\nThe isolation can usually be achieved by just scoping variables (with `set -l`), but if you really do need to run your code in a new shell environment you can always use `fish -c 'your code here'` to do so explicitly.\n\n## Builtins and other commands\n\nBy now it has become apparent that fish puts much more of a focus on its builtins and external commands rather than its syntax. So here are some helpful builtins and their rough equivalent in bash:\n\n- [string](cmds/string) - this replaces most of the string transformation (`${i%foo}` et al) and can also be used instead of `grep` and `sed` and such.\n- [math](cmds/math) - this replaces `$((i + 1))` arithmetic and can also do floats and some simple functions (sine and friends).\n- [argparse](cmds/argparse) - this can handle a script’s option parsing, for which bash would probably use `getopt` (zsh provides `zparseopts`).\n- [count](cmds/count) can be used to count things and therefore replaces `$#` and can be used instead of `wc`.\n- [status](cmds/status) provides information about the shell status, e.g. if it’s interactive or what the current linenumber is. This replaces `$-` and `$BASH_LINENO` and other variables.\n- `seq(1)` can be used as a replacement for `{1..10}` range expansion. If your OS doesn’t ship a `seq` fish includes a replacement function.\n\n## Other facilities\n\nBash has `set -x` or `set -o xtrace` to print all commands that are being executed. In fish, this would be enabled by setting [`fish_trace`](language#envvar-fish_trace).\n\nOr, if your intention is to *profile* how long each line of a script takes, you can use `fish --profile` - see the [page for the fish command](cmds/fish).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/fish_for_bash_users.html](https://fishshell.com/docs/3.7/fish_for_bash_users.html)"
- name: fish_add_path
  summary: fish_add_path is a simple way to add more components to fish’s PATH
  description: "# fish_add_path - add to the path\n\n## Synopsis\n\n```\nfish_add_path path ...\nfish_add_path [(-g | --global) | (-U | --universal) | (-P | --path)] [(-m | --move)] [(-a | --append) | (-p | --prepend)] [(-v | --verbose) | (-n | --dry-run)] PATHS ...\n```\n\n## Description\n\n**fish_add_path** is a simple way to add more components to fish’s [`PATH`](../language#envvar-PATH). It does this by adding the components either to \\$fish_user_paths or directly to [`PATH`](../language#envvar-PATH) (if the `--path` switch is given).\n\nIt is (by default) safe to use **fish_add_path** in config.fish, or it can be used once, interactively, and the paths will stay in future because of [universal variables](../language#variables-universal). This is a “do what I mean” style command, if you need more control, consider modifying the variable yourself.\n\nComponents are normalized by [realpath](realpath). Trailing slashes are ignored and relative paths are made absolute (but symlinks are not resolved). If a component already exists, it is not added again and stays in the same place unless the `--move` switch is given.\n\nComponents are added in the order they are given, and they are prepended to the path unless `--append` is given (if \\$fish_user_paths is used, that means they are last in \\$fish_user_paths, which is itself prepended to [`PATH`](../language#envvar-PATH), so they still stay ahead of the system paths).\n\nIf no component is new, the variable ([`fish_user_paths`](../language#envvar-fish_user_paths) or [`PATH`](../language#envvar-PATH)) is not set again or otherwise modified, so variable handlers are not triggered.\n\nIf a component is not an existing directory, `fish_add_path` ignores it.\n\n## Options\n\n**-a** or **--append**  \nAdd components to the *end* of the variable.\n\n**-p** or **--prepend**  \nAdd components to the *front* of the variable (this is the default).\n\n**-g** or **--global**  \nUse a global [`fish_user_paths`](../language#envvar-fish_user_paths).\n\n**-U** or **--universal**  \nUse a universal [`fish_user_paths`](../language#envvar-fish_user_paths) - this is the default if it doesn’t already exist.\n\n**-P** or **--path**  \nManipulate [`PATH`](../language#envvar-PATH) directly.\n\n**-m** or **--move**  \nMove already-existing components to the place they would be added - by default they would be left in place and not added again.\n\n**-v** or **--verbose**  \nPrint the [set](set) command used.\n\n**-n** or **--dry-run**  \nPrint the `set` command that would be used without executing it.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nIf `--move` is used, it may of course lead to the path swapping order, so you should be careful doing that in config.fish.\n\n## Example\n\n```\n# I just installed mycoolthing and need to add it to the path to use it.\n> fish_add_path /opt/mycoolthing/bin\n\n# I want my ~/.local/bin to be checked first.\n> fish_add_path -m ~/.local/bin\n\n# I prefer using a global fish_user_paths\n> fish_add_path -g ~/.local/bin ~/.otherbin /usr/local/sbin\n\n# I want to append to the entire $PATH because this directory contains fallbacks\n> fish_add_path -aP /opt/fallback/bin\n\n# I want to add the bin/ directory of my current $PWD (say /home/nemo/)\n> fish_add_path -v bin/\nset fish_user_paths /home/nemo/bin /usr/bin /home/nemo/.local/bin\n\n# I have installed ruby via homebrew\n> fish_add_path /usr/local/opt/ruby/bin\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_add_path.html](https://fishshell.com/docs/3.7/cmds/fish_add_path.html)"
- name: fish_breakpoint_prompt
  summary: fish_breakpoint_prompt is the prompt function when asking for input in response to a breakpoint command
  description: "# fish_breakpoint_prompt - define the prompt when stopped at a breakpoint\n\n## Synopsis\n\n```\nfish_breakpoint_prompt\n```\n\n```\nfunction fish_breakpoint_prompt\n    ...\nend\n```\n\n## Description\n\n`fish_breakpoint_prompt` is the prompt function when asking for input in response to a [breakpoint](breakpoint) command.\n\nThe exit status of commands within `fish_breakpoint_prompt` will not modify the value of [\\$status](../language#variables-status) outside of the `fish_breakpoint_prompt` function.\n\n`fish` ships with a default version of this function that displays the function name and line number of the current execution context.\n\n## Example\n\nA simple prompt that is a simplified version of the default debugging prompt:\n\n```\nfunction fish_breakpoint_prompt -d \"Write out the debug prompt\"\n    set -l function (status current-function)\n    set -l line (status current-line-number)\n    set -l prompt \"$function:$line >\"\n    echo -ns (set_color $fish_color_status) \"BP $prompt\" (set_color normal) ' '\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_breakpoint_prompt.html](https://fishshell.com/docs/3.7/cmds/fish_breakpoint_prompt.html)"
- name: fish_clipboard_copy
  summary: The fish_clipboard_copy function copies text to the system clipboard
  description: "# fish_clipboard_copy - copy text to the system’s clipboard\n\n## Synopsis\n\n```\nfish_clipboard_copy\n\nfoo | fish_clipboard_copy\n```\n\n## Description\n\nThe `fish_clipboard_copy` function copies text to the system clipboard.\n\nIf stdin is not a terminal (see [isatty](isatty)), it will read all input from there and copy it. If it is, it will use the current commandline, or the current selection if there is one.\n\nIt is bound to Control+X by default.\n\n`fish_clipboard_copy` works by calling a system-specific backend. If it doesn’t appear to work you may need to install yours.\n\nCurrently supported are:\n\n- `pbcopy`\n- `wl-copy` using wayland\n- `xsel` and `xclip` for X11\n- `clip.exe` on Windows.\n\n## See also\n\n- [fish_clipboard_paste - get text from the system’s clipboard](fish_clipboard_paste) which does the inverse.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_clipboard_copy.html](https://fishshell.com/docs/3.7/cmds/fish_clipboard_copy.html)"
- name: fish_clipboard_paste
  summary: The fish_clipboard_paste function copies text from the system clipboard
  description: "# fish_clipboard_paste - get text from the system’s clipboard\n\n## Synopsis\n\n```\nfish_clipboard_paste\n\nfish_clipboard_paste | foo\n```\n\n## Description\n\nThe `fish_clipboard_paste` function copies text from the system clipboard.\n\nIf its stdout is not a terminal (see [isatty](isatty)), it will output everything there, as-is, without any additional newlines. If it is, it will put the text in the commandline instead.\n\nIf it outputs to the commandline, it will automatically escape the output if the cursor is currently inside single-quotes so it is suitable for single-quotes (meaning it escapes `'` and `\\\\`).\n\nIt is bound to Control+V by default.\n\n`fish_clipboard_paste` works by calling a system-specific backend. If it doesn’t appear to work you may need to install yours.\n\nCurrently supported are:\n\n- `pbpaste`\n- `wl-paste` using wayland\n- `xsel` and `xclip` for X11\n- `powershell.exe` on Windows (this backend has encoding limitations and uses windows line endings that `fish_clipboard_paste` undoes)\n\n## See also\n\n- [fish_clipboard_copy - copy text to the system’s clipboard](fish_clipboard_copy) which does the inverse.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_clipboard_paste.html](https://fishshell.com/docs/3.7/cmds/fish_clipboard_paste.html)"
- name: fish_command_not_found
  summary: When fish tries to execute a command and can’t find it, it invokes this function
  description: "# fish_command_not_found - what to do when a command wasn’t found\n\n## Synopsis\n\n```\nfunction fish_command_not_found\n   ...\nend\n```\n\n## Description\n\nWhen fish tries to execute a command and can’t find it, it invokes this function.\n\nIt can print a message to tell you about it, and it often also checks for a missing package that would include the command.\n\nFish ships multiple handlers for various operating systems and chooses from them when this function is loaded, or you can define your own.\n\nIt receives the full commandline as one argument per token, so \\$argv\\[1\\] contains the missing command.\n\nWhen you leave `fish_command_not_found` undefined (e.g. by adding an empty function file) or explicitly call `__fish_default_command_not_found_handler`, fish will just print a simple error.\n\n## Example\n\nA simple handler:\n\n```\nfunction fish_command_not_found\n    echo Did not find command $argv[1]\nend\n\n> flounder\nDid not find command flounder\n```\n\nOr the handler for OpenSUSE’s command-not-found:\n\n```\nfunction fish_command_not_found\n    /usr/bin/command-not-found $argv[1]\nend\n```\n\nOr the simple default handler:\n\n```\nfunction fish_command_not_found\n    __fish_default_command_not_found_handler $argv\nend\n```\n\n## Backwards compatibility\n\nThis command was introduced in fish 3.2.0. Previous versions of fish used the “fish_command_not_found” [event](../language#event) instead.\n\nTo define a handler that works in older versions of fish as well, define it the old way:\n\n```\nfunction __fish_command_not_found_handler --on-event fish_command_not_found\n     echo COMMAND WAS NOT FOUND MY FRIEND $argv[1]\nend\n```\n\nin which case fish will define a `fish_command_not_found` that calls it, or define a wrapper:\n\n```\nfunction fish_command_not_found\n     echo \"G'day mate, could not find your command: $argv\"\nend\n\nfunction __fish_command_not_found_handler --on-event fish_command_not_found\n     fish_command_not_found $argv\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_command_not_found.html](https://fishshell.com/docs/3.7/cmds/fish_command_not_found.html)"
- name: fish_config
  summary: fish_config is used to configure fish
  description: "# fish_config - start the web-based configuration interface\n\n## Synopsis\n\n```\nfish_config [browse]\nfish_config prompt (choose | list | save | show)\nfish_config theme (choose | demo | dump | list | save | show)\n```\n\n## Description\n\n`fish_config` is used to configure fish.\n\nWithout arguments or with the `browse` command it starts the web-based configuration interface. The web interface allows you to view your functions, variables and history, and to make changes to your prompt and color configuration. It starts a local web server and opens a browser window. When you are finished, close the browser window and press the Enter key to terminate the configuration session.\n\nIf the `BROWSER` environment variable is set, it will be used as the name of the web browser to open instead of the system default.\n\nWith the `prompt` command `fish_config` can be used to view and choose a prompt from fish’s sample prompts inside the terminal directly.\n\nAvailable subcommands for the `prompt` command:\n\n- `choose` loads a sample prompt in the current session.\n- `list` lists the names of the available sample prompts.\n- `save` saves the current prompt to a file (via [funcsave](funcsave)).\n- `show` shows what the given sample prompts (or all) would look like.\n\nWith the `theme` command `fish_config` can be used to view and choose a theme (meaning a color scheme) inside the terminal.\n\nAvailable subcommands for the `theme` command:\n\n- `choose` loads a sample theme in the current session.\n- `demo` displays some sample text in the current theme.\n- `dump` prints the current theme in a loadable format.\n- `list` lists the names of the available sample themes.\n- `save` saves the given theme to [universal variables](../language#variables-universal).\n- `show` shows what the given sample theme (or all) would look like.\n\nThe themes are loaded from the theme directory shipped with fish or a `themes` directory in the fish configuration directory (typically `~/.config/fish/themes`).\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n`fish_config` or `fish_config browse` opens a new web browser window and allows you to configure certain fish settings.\n\n`fish_config prompt show` demos the available sample prompts.\n\n`fish_config prompt choose disco` makes the disco prompt the prompt for the current session. This can also be used in [config.fish](../language#configuration) to set the prompt.\n\n`fish_config prompt save` saves the current prompt to an [autoloaded](../language#syntax-function-autoloading) file.\n\n`fish_config prompt save default` chooses the default prompt and saves it.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_config.html](https://fishshell.com/docs/3.7/cmds/fish_config.html)"
- name: fish_default_key_bindings
  summary: fish_default_key_bindings sets the emacs key bindings for fish shell
  description: "# fish_default_key_bindings - set emacs key bindings for fish\n\n## Synopsis\n\n```\nfish_default_key_bindings\n```\n\n## Description\n\n`fish_default_key_bindings` sets the emacs key bindings for `fish` shell.\n\nSome of the Emacs key bindings are defined [here](../interactive#emacs-mode).\n\nThere are no parameters for `fish_default_key_bindings`.\n\n## Examples\n\nTo start using vi key bindings:\n\n```\nfish_default_key_bindings\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_default_key_bindings.html](https://fishshell.com/docs/3.7/cmds/fish_default_key_bindings.html)"
- name: fish_delta
  summary: The fish_delta function tells you, at a glance, which of your functions and completions differ from the set that fish ships
  description: "# fish_delta - compare functions and completions to the default\n\n## Synopsis\n\n```\nfish_delta name ...\nfish_delta [-f | --no-functions] [-c | --no-completions] [-C | --no-config] [-d | --no-diff] [-n | --new] [-V | --vendor=]\nfish_delta [-h | --help]\n```\n\n## Description\n\nThe `fish_delta` function tells you, at a glance, which of your functions and completions differ from the set that fish ships.\n\nIt does this by going through the relevant variables ([`fish_function_path`](../language#envvar-fish_function_path) for functions and [`fish_complete_path`](../language#envvar-fish_complete_path) for completions) and comparing the files against fish’s default directories.\n\nIf any names are given, it will only compare files by those names (plus a “.fish” extension).\n\nBy default, it will also use `diff` to display the difference between the files. If `diff` is unavailable, it will skip it, but in that case it also cannot figure out if the files really differ.\n\nThe exit status is 1 if there was a difference and 2 for other errors, otherwise 0.\n\n## Options\n\nThe following options are available:\n\n**-f** or **--no-functions**  \nStops checking functions\n\n**-c** or **--no-completions**  \nStops checking completions\n\n**-C** or **--no-config**  \nStops checking configuration files like config.fish or snippets in the conf.d directories.\n\n**-d** or **--no-diff**  \nRemoves the diff display (this happens automatically if `diff` can’t be found)\n\n**-n** or **--new**  \nAlso prints new files (i.e. those that can’t be found in fish’s default directories).\n\n**-Vvalue** or **--vendor=value**  \nDetermines how the vendor directories are counted. Valid values are:\n\n- “default” - counts vendor files as belonging to the defaults. Any changes in other directories will be counted as changes over them. This is the default.\n- “user” - counts vendor files as belonging to the user files. Any changes in them will be counted as new or changed files.\n- “ignore” - ignores vendor directories. Files of the same name will be counted as “new” if no file of the same name in fish’s default directories exists.\n\n**-h** or **--help**  \nPrints `fish_delta`’s help (this).\n\n## Example\n\nRunning just:\n\n```\nfish_delta\n```\n\nwill give you a list of all your changed functions and completions, including diffs (if you have the `diff` command).\n\nIt might look like this:\n\n```\n> fish_delta\nNew: /home/alfa/.config/fish/functions/battery.fish\nChanged: /home/alfa/.config/fish/test/completions/cargo.fish\n--- /home/alfa/.config/fish/test/completions/cargo.fish 2022-09-02 12:57:55.579229959 +0200\n+++ /usr/share/fish/completions/cargo.fish      2022-09-25 17:51:53.000000000 +0200\n# the output of `diff` follows\n```\n\nThe options are there to select which parts of the output you want. With `--no-completions` you can compare just functions, and with `--no-diff` you can turn off the `diff` display.\n\nTo only compare your `fish_git_prompt`, you might use:\n\n```\nfish_delta --no-completions fish_git_prompt\n```\n\nwhich will only compare files called “fish_git_prompt.fish”.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_delta.html](https://fishshell.com/docs/3.7/cmds/fish_delta.html)"
- name: fish_git_prompt
  summary: The fish_git_prompt function displays information about the current git repository, if any
  description: "# fish_git_prompt - output git information for use in a prompt\n\n## Synopsis\n\n```\nfish_git_prompt\n```\n\n```\nfunction fish_prompt\n     printf '%s' $PWD (fish_git_prompt) ' $ '\nend\n```\n\n## Description\n\nThe `fish_git_prompt` function displays information about the current git repository, if any.\n\n[Git](https://git-scm.com) must be installed.\n\nThere are numerous customization options, which can be controlled with git options or fish variables. git options, where available, take precedence over the fish variable with the same function. git options can be set on a per-repository or global basis. git options can be set with the `git config` command, while fish variables can be set as usual with the [set](set) command.\n\nBoolean options (those which enable or disable something) understand “1”, “yes” or “true” to mean true and every other value to mean false.\n\n- `$__fish_git_prompt_show_informative_status` or the git option `bash.showInformativeStatus` can be set to 1, true or yes to enable the “informative” display, which will show a large amount of information - the number of dirty files, unpushed/unpulled commits, and more. In large repositories, this can take a lot of time, so you may wish to disable it in these repositories with `git config --local bash.showInformativeStatus false`. It also changes the characters the prompt uses to less plain ones (`✚` instead of `*` for the dirty state for example) , and if you are only interested in that, set `$__fish_git_prompt_use_informative_chars` instead.\n\n  Because counting untracked files requires a lot of time, the number of untracked files is only shown if enabled via `$__fish_git_prompt_showuntrackedfiles` or the git option `bash.showUntrackedFiles`.\n\n- `$__fish_git_prompt_showdirtystate` or the git option `bash.showDirtyState` can be set to 1, true or yes to show if the repository is “dirty”, i.e. has uncommitted changes.\n\n- `$__fish_git_prompt_showuntrackedfiles` or the git option `bash.showUntrackedFiles` can be set to 1, true or yes to show if the repository has untracked files (that aren’t ignored).\n\n- `$__fish_git_prompt_showupstream` can be set to a list of values to determine how changes between HEAD and upstream are shown:\n\n  `auto`  \n  summarize the difference between HEAD and its upstream\n\n  `verbose`  \n  show number of commits ahead/behind (+/-) upstream\n\n  `name`  \n  if verbose, then also show the upstream abbrev name\n\n  `informative`  \n  similar to verbose, but shows nothing when equal - this is the default if informative status is enabled.\n\n  `git`  \n  always compare HEAD to @{upstream}\n\n  `svn`  \n  always compare HEAD to your SVN upstream\n\n  `none`  \n  disables (useful with informative status)\n\n- `$__fish_git_prompt_showstashstate` can be set to 1, true or yes to display the state of the stash.\n\n- `$__fish_git_prompt_shorten_branch_len` can be set to the number of characters that the branch name will be shortened to.\n\n- `$__fish_git_prompt_describe_style` can be set to one of the following styles to describe the current HEAD:\n\n  `contains`  \n  relative to newer annotated tag, such as `(v1.6.3.2~35)`\n\n  `branch`  \n  relative to newer tag or branch, such as `(master~4)`\n\n  `describe`  \n  relative to older annotated tag, such as `(v1.6.3.1-13-gdd42c2f)`\n\n  `default`  \n  an exactly matching tag (`(develop)`)\n\n  If none of these apply, the commit SHA shortened to 8 characters is used.\n\n- `$__fish_git_prompt_showcolorhints` can be set to 1, true or yes to enable coloring for the branch name and status symbols.\n\nA number of variables set characters and color used as indicators. Many of these have a different default if used with informative status enabled, or `$__fish_git_prompt_use_informative_chars` set. The usual default is given first, then the informative default (if it is different). If no default for the colors is given, they default to `$__fish_git_prompt_color`.\n\n- `$__fish_git_prompt_char_stateseparator` (’ ‘, `|`) - the character to be used between the state characters\n- `$__fish_git_prompt_color` (no default)\n- `$__fish_git_prompt_color_prefix` - the color of the `(` prefix\n- `$__fish_git_prompt_color_suffix` - the color of the `)` suffix\n- `$__fish_git_prompt_color_bare` - the color to use for a bare repository - one without a working tree\n- `$__fish_git_prompt_color_merging` - the color when a merge/rebase/revert/bisect or cherry-pick is in progress\n- `$__fish_git_prompt_char_cleanstate` (✔ in informative mode) - the character to be used when nothing else applies\n- `$__fish_git_prompt_color_cleanstate` (no default)\n\nVariables used with `showdirtystate`:\n\n- `$__fish_git_prompt_char_dirtystate` (`*`, ✚) - the number of “dirty” changes, i.e. unstaged files with changes\n- `$__fish_git_prompt_char_invalidstate` (#, ✖) - the number of “unmerged” changes, e.g. additional changes to already added files\n- `$__fish_git_prompt_char_stagedstate` (+, ●) - the number of staged files without additional changes\n- `$__fish_git_prompt_color_dirtystate` (red with showcolorhints, same as color_flags otherwise)\n- `$__fish_git_prompt_color_invalidstate`\n- `$__fish_git_prompt_color_stagedstate` (green with showcolorhints, color_flags otherwise)\n\nVariables used with `showstashstate`:\n\n- `$__fish_git_prompt_char_stashstate` (`$`, ⚑)\n- `$__fish_git_prompt_color_stashstate` (same as color_flags)\n\nVariables used with `showuntrackedfiles`:\n\n- `$__fish_git_prompt_char_untrackedfiles` (%, …) - the symbol for untracked files\n- `$__fish_git_prompt_color_untrackedfiles` (same as color_flags)\n\nVariables used with `showupstream` (also implied by informative status):\n\n- `$__fish_git_prompt_char_upstream_ahead` (\\>, ↑) - the character for the commits this repository is ahead of upstream\n- `$__fish_git_prompt_char_upstream_behind` (\\<, ↓) - the character for the commits this repository is behind upstream\n- `$__fish_git_prompt_char_upstream_diverged` (\\<\\>) - the symbol if this repository is both ahead and behind upstream\n- `$__fish_git_prompt_char_upstream_equal` (=) - the symbol if this repo is equal to upstream\n- `$__fish_git_prompt_char_upstream_prefix` (‘’)\n- `$__fish_git_prompt_color_upstream`\n\nColors used with `showcolorhints`:\n\n- `$__fish_git_prompt_color_branch` (green) - the color of the branch if nothing else applies\n- `$__fish_git_prompt_color_branch_detached` (red) the color of the branch if it’s detached (e.g. a commit is checked out)\n- `$__fish_git_prompt_color_branch_dirty` (no default) the color of the branch if it’s dirty and not detached\n- `$__fish_git_prompt_color_branch_staged` (no default) the color of the branch if it just has something staged and is otherwise clean\n- `$__fish_git_prompt_color_flags` (--bold blue) - the default color for dirty/staged/stashed/untracked state\n\nNote that all colors can also have a corresponding `_done` color. For example, the contents of `$__fish_git_prompt_color_upstream_done` is printed right \\_after\\_ the upstream.\n\nSee also [fish_vcs_prompt](fish_vcs_prompt), which will call all supported version control prompt functions, including git, Mercurial and Subversion.\n\n## Example\n\nA simple prompt that displays git info:\n\n```\nfunction fish_prompt\n    # ...\n    set -g __fish_git_prompt_showupstream auto\n    printf '%s %s$' $PWD (fish_git_prompt)\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_git_prompt.html](https://fishshell.com/docs/3.7/cmds/fish_git_prompt.html)"
- name: fish_greeting
  summary: When an interactive fish starts, it executes fish_greeting and displays its output
  description: "# fish_greeting - display a welcome message in interactive shells\n\n## Synopsis\n\n```\nfish_greeting\n```\n\n```\nfunction fish_greeting\n    ...\nend\n```\n\n## Description\n\nWhen an interactive fish starts, it executes fish_greeting and displays its output.\n\nThe default fish_greeting is a function that prints a variable of the same name (`$fish_greeting`), so you can also just change that if you just want to change the text.\n\nWhile you could also just put `echo` calls into config.fish, fish_greeting takes care of only being used in interactive shells, so it won’t be used e.g. with `scp` (which executes a shell), which prevents some errors.\n\n## Example\n\nTo just empty the text, with the default greeting function:\n\n```\nset -U fish_greeting\n```\n\nor `set -g fish_greeting` in [config.fish](../language#configuration).\n\nA simple greeting:\n\n```\nfunction fish_greeting\n    echo Hello friend!\n    echo The time is (set_color yellow; date +%T; set_color normal) and this machine is called $hostname\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_greeting.html](https://fishshell.com/docs/3.7/cmds/fish_greeting.html)"
- name: fish_hg_prompt
  summary: The fish_hg_prompt function displays information about the current Mercurial repository, if any
  description: "# fish_hg_prompt - output Mercurial information for use in a prompt\n\n## Synopsis\n\n```\nfish_hg_prompt\n```\n\n```\nfunction fish_prompt\n     printf '%s' $PWD (fish_hg_prompt) ' $ '\nend\n```\n\n## Description\n\nThe fish_hg_prompt function displays information about the current Mercurial repository, if any.\n\n[Mercurial](https://www.mercurial-scm.org/) (`hg`) must be installed.\n\nBy default, only the current branch is shown because `hg status` can be slow on a large repository. You can enable a more informative prompt by setting the variable `$fish_prompt_hg_show_informative_status`, for example:\n\n```\nset --universal fish_prompt_hg_show_informative_status\n```\n\nIf you enabled the informative status, there are numerous customization options, which can be controlled with fish variables.\n\n- `$fish_color_hg_clean`, `$fish_color_hg_modified` and `$fish_color_hg_dirty` are colors used when the repository has the respective status.\n\nSome colors for status symbols:\n\n- `$fish_color_hg_added`\n- `$fish_color_hg_renamed`\n- `$fish_color_hg_copied`\n- `$fish_color_hg_deleted`\n- `$fish_color_hg_untracked`\n- `$fish_color_hg_unmerged`\n\nThe status symbols themselves:\n\n- `$fish_prompt_hg_status_added`, default ‘✚’\n- `$fish_prompt_hg_status_modified`, default ‘\\*’\n- `$fish_prompt_hg_status_copied`, default ‘⇒’\n- `$fish_prompt_hg_status_deleted`, default ‘✖’\n- `$fish_prompt_hg_status_untracked`, default ‘?’\n- `$fish_prompt_hg_status_unmerged`, default ‘!’\n\nFinally, `$fish_prompt_hg_status_order`, which can be used to change the order the status symbols appear in. It defaults to `added modified copied deleted untracked unmerged`.\n\nSee also [fish_vcs_prompt](fish_vcs_prompt), which will call all supported version control prompt functions, including git, Mercurial and Subversion.\n\n## Example\n\nA simple prompt that displays hg info:\n\n```\nfunction fish_prompt\n    ...\n    set -g fish_prompt_hg_show_informative_status\n    printf '%s %s$' $PWD (fish_hg_prompt)\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_hg_prompt.html](https://fishshell.com/docs/3.7/cmds/fish_hg_prompt.html)"
- name: fish_indent
  summary: fish_indent is used to indent a piece of fish code
  description: "# fish_indent - indenter and prettifier\n\n## Synopsis\n\n```\nfish_indent [OPTIONS] [FILE ...]\n```\n\n## Description\n\n**fish_indent** is used to indent a piece of fish code. **fish_indent** reads commands from standard input or the given filenames and outputs them to standard output or a specified file (if `-w` is given).\n\nThe following options are available:\n\n**-w** or **--write**  \nIndents a specified file and immediately writes to that file.\n\n**-i** or **--no-indent**  \nDo not indent commands; only reformat to one job per line.\n\n**-c** or **--check**  \nDo not indent, only return 0 if the code is already indented as fish_indent would, the number of failed files otherwise. Also print the failed filenames if not reading from standard input.\n\n**-v** or **--version**  \nDisplays the current **fish** version and then exits.\n\n**--ansi**  \nColorizes the output using ANSI escape sequences, appropriate for the current [`TERM`](../language#envvar-TERM), using the colors defined in the environment (such as [`fish_color_command`](../interactive#envvar-fish_color_command)).\n\n**--html**  \nOutputs HTML, which supports syntax highlighting if the appropriate CSS is defined. The CSS class names are the same as the variable names, such as `fish_color_command`.\n\n**-d** or **--debug=DEBUG_CATEGORIES**  \nEnable debug output and specify a pattern for matching debug categories. See [Debugging](fish#debugging-fish) in [fish](fish) (1) for details.\n\n**-o** or **--debug-output=DEBUG_FILE**  \nSpecify a file path to receive the debug output, including categories and `fish_trace`. The default is standard error.\n\n**--dump-parse-tree**  \nDumps information about the parsed statements to standard error. This is likely to be of interest only to people working on the fish source code.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_indent.html](https://fishshell.com/docs/3.7/cmds/fish_indent.html)"
- name: fish_is_root_user
  summary: fish_is_root_user will check if the current user is root
  description: "# fish_is_root_user - check if the current user is root\n\n## Synopsis\n\n```\nfish_is_root_user\n```\n\n## Description\n\n`fish_is_root_user` will check if the current user is root. It can be useful for the prompt to display something different if the user is root, for example.\n\n## Example\n\nA simple example:\n\n```\nfunction example --description 'Just an example'\n    if fish_is_root_user\n        do_something_different\n    end\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_is_root_user.html](https://fishshell.com/docs/3.7/cmds/fish_is_root_user.html)"
- name: fish_key_reader
  summary: fish_key_reader is used to explain how you would bind a certain key sequence
  description: "# fish_key_reader - explore what characters keyboard keys send\n\n## Synopsis\n\n```\nfish_key_reader [OPTIONS]\n```\n\n## Description\n\n**fish_key_reader** is used to explain how you would bind a certain key sequence. By default, it prints the [bind](bind) command for one key sequence read interactively over standard input.\n\nIf the character sequence matches a special key name (see `bind --key-names`), both `bind CHARS ...` and `bind -k KEYNAME ...` usage will be shown. In verbose mode (enabled by passing `--verbose`), additional details about the characters received, such as the delay between chars, are written to standard error.\n\nThe following options are available:\n\n**-c** or **--continuous**  \nBegins a session where multiple key sequences can be inspected. By default the program exits after capturing a single key sequence.\n\n**-V** or **--verbose**  \nTells fish_key_reader to output timing information and explain the sequence in more detail.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n**-v** or **--version**  \nDisplays the current **fish** version and then exits.\n\n## Usage Notes\n\nIn verbose mode, the delay in milliseconds since the previous character was received is included in the diagnostic information written to standard error. This information may be useful to determine the optimal `fish_escape_delay_ms` setting or learn the amount of lag introduced by tools like `ssh`, `mosh` or `tmux`.\n\n`fish_key_reader` intentionally disables handling of many signals. To terminate `fish_key_reader` in `--continuous` mode do:\n\n- press Control+C twice, or\n- press Control+D twice, or\n- type `exit`, or\n- type `quit`\n\n## Example\n\n```\n> fish_key_reader\nPress a key:\n# press up-arrow\nbind \\e\\[A 'do something'\n\n> fish_key_reader --verbose\nPress a key:\n# press alt+enter\n           hex:   1B  char: \\e\n(  0.027 ms)  hex:    D  char: \\cM  (or \\r)\nbind \\e\\r 'do something'\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_key_reader.html](https://fishshell.com/docs/3.7/cmds/fish_key_reader.html)"
- name: fish_mode_prompt
  summary: The fish_mode_prompt function outputs the mode indicator for use in vi-mode
  description: "# fish_mode_prompt - define the appearance of the mode indicator\n\n## Synopsis\n\n```\nfish_mode_prompt\n```\n\n```\nfunction fish_mode_prompt\n     echo -n \"$fish_bind_mode \"\nend\n```\n\n## Description\n\nThe `fish_mode_prompt` function outputs the mode indicator for use in vi-mode.\n\nThe default `fish_mode_prompt` function will output indicators about the current Vi editor mode displayed to the left of the regular prompt. Define your own function to customize the appearance of the mode indicator. The `$fish_bind_mode variable` can be used to determine the current mode. It will be one of `default`, `insert`, `replace_one`, or `visual`.\n\nYou can also define an empty `fish_mode_prompt` function to remove the Vi mode indicators:\n\n```\nfunction fish_mode_prompt; end\nfuncsave fish_mode_prompt\n```\n\n`fish_mode_prompt` will be executed when the vi mode changes. If it produces any output, it is displayed and used. If it does not, the other prompt functions ([fish_prompt](fish_prompt) and [fish_right_prompt](fish_right_prompt)) will be executed as well in case they contain a mode display.\n\n## Example\n\n```\nfunction fish_mode_prompt\n  switch $fish_bind_mode\n    case default\n      set_color --bold red\n      echo 'N'\n    case insert\n      set_color --bold green\n      echo 'I'\n    case replace_one\n      set_color --bold green\n      echo 'R'\n    case visual\n      set_color --bold brmagenta\n      echo 'V'\n    case '*'\n      set_color --bold red\n      echo '?'\n  end\n  set_color normal\nend\n```\n\nOutputting multiple lines is not supported in `fish_mode_prompt`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_mode_prompt.html](https://fishshell.com/docs/3.7/cmds/fish_mode_prompt.html)"
- name: fish_opt
  summary: This command provides a way to produce option specifications suitable for use with the argparse command
  description: "# fish_opt - create an option specification for the argparse command\n\n## Synopsis\n\n```\nfish_opt [(-slor | --multiple-vals=) OPTNAME]\nfish_opt --help\n```\n\n## Description\n\nThis command provides a way to produce option specifications suitable for use with the [argparse](argparse) command. You can, of course, write the option specifications by hand without using this command. But you might prefer to use this for the clarity it provides.\n\nThe following `argparse` options are available:\n\n**-s** or **--short**  \nTakes a single letter that is used as the short flag in the option being defined. This option is mandatory.\n\n**-l** or **--long**  \nTakes a string that is used as the long flag in the option being defined. This option is optional and has no default. If no long flag is defined then only the short flag will be allowed when parsing arguments using the option specification.\n\n**--long-only**  \nThe option being defined will only allow the long flag name to be used. The short flag name must still be defined (i.e., **--short** must be specified) but it cannot be used when parsing arguments using this option specification.\n\n**-o** or **--optional-val**  \nTthe option being defined can take a value, but it is optional rather than required. If the option is seen more than once when parsing arguments, only the last value seen is saved. This means the resulting flag variable created by `argparse` will zero elements if no value was given with the option else it will have exactly one element.\n\n**-r** or **--required-val**  \nThe option being defined requires a value. If the option is seen more than once when parsing arguments, only the last value seen is saved. This means the resulting flag variable created by `argparse` will have exactly one element.\n\n**--multiple-vals**  \nThe option being defined requires a value each time it is seen. Each instance is stored. This means the resulting flag variable created by `argparse` will have one element for each instance of this option in the arguments.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## Examples\n\nDefine a single option specification for the boolean help flag:\n\n```\nset -l options (fish_opt -s h -l help)\nargparse $options -- $argv\n```\n\nSame as above but with a second flag that requires a value:\n\n```\nset -l options (fish_opt -s h -l help)\nset options $options (fish_opt -s m -l max --required-val)\nargparse $options -- $argv\n```\n\nSame as above but with a third flag that can be given multiple times saving the value of each instance seen and only the long flag name (`--token`) can be used:\n\n```\nset -l options (fish_opt --short=h --long=help)\nset options $options (fish_opt --short=m --long=max --required-val)\nset options $options (fish_opt --short=t --long=token --multiple-vals --long-only)\nargparse $options -- $argv\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_opt.html](https://fishshell.com/docs/3.7/cmds/fish_opt.html)"
- name: fish_prompt
  summary: The fish_prompt function is executed when the prompt is to be shown, and the output is used as a prompt
  description: "# fish_prompt - define the appearance of the command line prompt\n\n## Synopsis\n\n```\nfish_prompt\n```\n\n```\nfunction fish_prompt\n    ...\nend\n```\n\n## Description\n\nThe `fish_prompt` function is executed when the prompt is to be shown, and the output is used as a prompt.\n\nThe exit status of commands within `fish_prompt` will not modify the value of [\\$status](../language#variables-status) outside of the `fish_prompt` function.\n\n`fish` ships with a number of example prompts that can be chosen with the `fish_config` command.\n\n## Example\n\nA simple prompt:\n\n```\nfunction fish_prompt -d \"Write out the prompt\"\n    # This shows up as USER@HOST /home/user/ >, with the directory colored\n    # $USER and $hostname are set by fish, so you can just use them\n    # instead of using `whoami` and `hostname`\n    printf '%s@%s %s%s%s > ' $USER $hostname \\\n        (set_color $fish_color_cwd) (prompt_pwd) (set_color normal)\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_prompt.html](https://fishshell.com/docs/3.7/cmds/fish_prompt.html)"
- name: fish_right_prompt
  summary: fish_right_prompt is similar to fish_prompt, except that it appears on the right side of the terminal window
  description: "# fish_right_prompt - define the appearance of the right-side command line prompt\n\n## Synopsis\n\n```\nfunction fish_right_prompt\n    ...\nend\n```\n\n## Description\n\n`fish_right_prompt` is similar to `fish_prompt`, except that it appears on the right side of the terminal window.\n\nMultiple lines are not supported in `fish_right_prompt`.\n\n## Example\n\nA simple right prompt:\n\n```\nfunction fish_right_prompt -d \"Write out the right prompt\"\n    date '+%m/%d/%y'\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_right_prompt.html](https://fishshell.com/docs/3.7/cmds/fish_right_prompt.html)"
- name: fish_status_to_signal
  summary: fish_status_to_signal converts exit codes to their corresponding human-friendly signals if one exists
  description: "# fish_status_to_signal - convert exit codes to human-friendly signals\n\n## Synopsis\n\n```\nfish_status_to_signal NUM\n```\n\n```\nfunction fish_prompt\n    echo -n (fish_status_to_signal $pipestatus | string join '|') (prompt_pwd) '$ '\nend\n```\n\n## Description\n\n`fish_status_to_signal` converts exit codes to their corresponding human-friendly signals if one exists. This is likely to be useful for prompts in conjunction with the `$status` and `$pipestatus` variables.\n\n## Example\n\n```\n>_ sleep 5\n^C⏎\n>_ fish_status_to_signal $status\nSIGINT\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_status_to_signal.html](https://fishshell.com/docs/3.7/cmds/fish_status_to_signal.html)"
- name: fish_svn_prompt
  summary: The fish_svn_prompt function displays information about the current Subversion repository, if any
  description: "# fish_svn_prompt - output Subversion information for use in a prompt\n\n## Synopsis\n\n```\nfish_svn_prompt\n```\n\n```\nfunction fish_prompt\n     printf '%s' $PWD (fish_svn_prompt) ' $ '\nend\n```\n\n## Description\n\nThe fish_svn_prompt function displays information about the current Subversion repository, if any.\n\n[Subversion](https://subversion.apache.org/) (`svn`) must be installed.\n\nThere are numerous customization options, which can be controlled with fish variables.\n\n- `__fish_svn_prompt_color_revision`  \n  the colour of the revision number to display in the prompt\n\n- `__fish_svn_prompt_char_separator`  \n  the separator between status characters\n\nA number of variables control the symbol (“display”) and color (“color”) for the different status indicators:\n\n- `__fish_svn_prompt_char_added_display`\n- `__fish_svn_prompt_char_added_color`\n- `__fish_svn_prompt_char_conflicted_display`\n- `__fish_svn_prompt_char_conflicted_color`\n- `__fish_svn_prompt_char_deleted_display`\n- `__fish_svn_prompt_char_deleted_color`\n- `__fish_svn_prompt_char_ignored_display`\n- `__fish_svn_prompt_char_ignored_color`\n- `__fish_svn_prompt_char_modified_display`\n- `__fish_svn_prompt_char_modified_color`\n- `__fish_svn_prompt_char_replaced_display`\n- `__fish_svn_prompt_char_replaced_color`\n- `__fish_svn_prompt_char_unversioned_external_display`\n- `__fish_svn_prompt_char_unversioned_external_color`\n- `__fish_svn_prompt_char_unversioned_display`\n- `__fish_svn_prompt_char_unversioned_color`\n- `__fish_svn_prompt_char_missing_display`\n- `__fish_svn_prompt_char_missing_color`\n- `__fish_svn_prompt_char_versioned_obstructed_display`\n- `__fish_svn_prompt_char_versioned_obstructed_color`\n- `__fish_svn_prompt_char_locked_display`\n- `__fish_svn_prompt_char_locked_color`\n- `__fish_svn_prompt_char_scheduled_display`\n- `__fish_svn_prompt_char_scheduled_color`\n- `__fish_svn_prompt_char_switched_display`\n- `__fish_svn_prompt_char_switched_color`\n- `__fish_svn_prompt_char_token_present_display`\n- `__fish_svn_prompt_char_token_present_color`\n- `__fish_svn_prompt_char_token_other_display`\n- `__fish_svn_prompt_char_token_other_color`\n- `__fish_svn_prompt_char_token_stolen_display`\n- `__fish_svn_prompt_char_token_stolen_color`\n- `__fish_svn_prompt_char_token_broken_display`\n- `__fish_svn_prompt_char_token_broken_color`\n\nSee also [fish_vcs_prompt](fish_vcs_prompt), which will call all supported version control prompt functions, including git, Mercurial and Subversion.\n\n## Example\n\nA simple prompt that displays svn info:\n\n```\nfunction fish_prompt\n    ...\n    printf '%s %s$' $PWD (fish_svn_prompt)\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_svn_prompt.html](https://fishshell.com/docs/3.7/cmds/fish_svn_prompt.html)"
- name: fish_title
  summary: The fish_title function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message
  description: "# fish_title - define the terminal’s title\n\n## Synopsis\n\n```\nfish_title\n```\n\n```\nfunction fish_title\n    ...\nend\n```\n\n## Description\n\nThe `fish_title` function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message.\n\nThe first argument to fish_title contains the most recently executed foreground command as a string, if any.\n\nThis requires that your terminal supports programmable titles and the feature is turned on.\n\n## Example\n\nA simple title:\n\n```\nfunction fish_title\n    set -q argv[1]; or set argv fish\n    # Looks like ~/d/fish: git log\n    # or /e/apt: fish\n    echo (fish_prompt_pwd_dir_length=1 prompt_pwd): $argv;\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_title.html](https://fishshell.com/docs/3.7/cmds/fish_title.html)"
- name: fish_update_completions
  summary: fish_update_completions parses manual pages installed on the system, and attempts to create completion files in the fish configuration directory
  description: "# fish_update_completions - update completions using manual pages\n\n## Synopsis\n\n```\nfish_update_completions\n```\n\n## Description\n\n`fish_update_completions` parses manual pages installed on the system, and attempts to create completion files in the `fish` configuration directory.\n\nThis does not overwrite custom completions.\n\nThere are no parameters for `fish_update_completions`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_update_completions.html](https://fishshell.com/docs/3.7/cmds/fish_update_completions.html)"
- name: fish_vcs_prompt
  summary: The fish_vcs_prompt function displays information about the current version control system (VCS) repository, if any
  description: "# fish_vcs_prompt - output version control system information for use in a prompt\n\n## Synopsis\n\n```\nfish_vcs_prompt\n```\n\n```\nfunction fish_prompt\n     printf '%s' $PWD (fish_vcs_prompt) ' $ '\nend\n```\n\n## Description\n\nThe `fish_vcs_prompt` function displays information about the current version control system (VCS) repository, if any.\n\nIt calls out to VCS-specific functions. The currently supported systems are:\n\n- [fish_git_prompt](fish_git_prompt)\n- [fish_hg_prompt](fish_hg_prompt)\n- [fish_svn_prompt](fish_svn_prompt)\n\nIf a VCS isn’t installed, the respective function does nothing.\n\nThe Subversion prompt is disabled by default, because it’s slow on large repositories. To enable it, modify `fish_vcs_prompt` to uncomment it. See [funced](funced).\n\nFor more information, see the documentation for each of the functions above.\n\n## Example\n\nA simple prompt that displays all known VCS info:\n\n```\nfunction fish_prompt\n    ...\n    set -g __fish_git_prompt_showupstream auto\n    printf '%s %s$' $PWD (fish_vcs_prompt)\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_vcs_prompt.html](https://fishshell.com/docs/3.7/cmds/fish_vcs_prompt.html)"
- name: fish_vi_key_bindings
  summary: fish_vi_key_bindings sets the vi key bindings for fish shell
  description: "# fish_vi_key_bindings - set vi key bindings for fish\n\n## Synopsis\n\n```\nfish_vi_key_bindings\nfish_vi_key_bindings [--no-erase] [INIT_MODE]\n```\n\n## Description\n\n`fish_vi_key_bindings` sets the vi key bindings for `fish` shell.\n\nIf a valid *INIT_MODE* is provided (insert, default, visual), then that mode will become the default . If no *INIT_MODE* is given, the mode defaults to insert mode.\n\nThe following parameters are available:\n\n**--no-erase**  \nDoes not clear previous set bindings\n\nFurther information on how to use [vi-mode](../interactive#vi-mode).\n\n## Examples\n\nTo start using vi key bindings:\n\n```\nfish_vi_key_bindings\n```\n\nor `set -g fish_key_bindings fish_vi_key_bindings` in [config.fish](../language#configuration).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/fish_vi_key_bindings.html](https://fishshell.com/docs/3.7/cmds/fish_vi_key_bindings.html)"
- name: for
  summary: for is a loop construct
  description: "# for - perform a set of commands multiple times\n\n## Synopsis\n\n```\nfor VARNAME in [VALUES ...]; COMMANDS ...; end\n```\n\n## Description\n\n**for** is a loop construct. It will perform the commands specified by *COMMANDS* multiple times. On each iteration, the local variable specified by *VARNAME* is assigned a new value from *VALUES*. If *VALUES* is empty, *COMMANDS* will not be executed at all. The *VARNAME* is visible when the loop terminates and will contain the last value assigned to it. If *VARNAME* does not already exist it will be set in the local scope. For our purposes if the **for** block is inside a function there must be a local variable with the same name. If the **for** block is not nested inside a function then global and universal variables of the same name will be used if they exist.\n\nMuch like [set](set), **for** does not modify \\$status, but the evaluation of its subordinate commands can.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n```\nfor i in foo bar baz; echo $i; end\n\n# would output:\nfoo\nbar\nbaz\n```\n\n## Notes\n\nThe `VARNAME` was local to the for block in releases prior to 3.0.0. This means that if you did something like this:\n\n```\nfor var in a b c\n    if break_from_loop\n        break\n    end\nend\necho $var\n```\n\nThe last value assigned to `var` when the loop terminated would not be available outside the loop. What `echo $var` would write depended on what it was set to before the loop was run. Likely nothing.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/for.html](https://fishshell.com/docs/3.7/cmds/for.html)"
- name: funced
  summary: funced provides an interface to edit the definition of the function NAME
  description: "# funced - edit a function interactively\n\n## Synopsis\n\n```\nfunced [OPTIONS] NAME\n```\n\n## Description\n\n`funced` provides an interface to edit the definition of the function *NAME*.\n\nIf the `$VISUAL` environment variable is set, it will be used as the program to edit the function. If `$VISUAL` is unset but `$EDITOR` is set, that will be used. Otherwise, a built-in editor will be used. Note that to enter a literal newline using the built-in editor you should press Alt+Enter. Pressing Enter signals that you are done editing the function. This does not apply to an external editor like emacs or vim.\n\n`funced` will try to edit the original file that a function is defined in, which might include variable definitions or helper functions as well. If changes cannot be saved to the original file, a copy will be created in the user’s function directory.\n\nIf there is no function called *NAME*, a new function will be created with the specified name.\n\n**-e command** or **--editor command**  \nOpen the function body inside the text editor given by the command (for example, **-e vi**). The special command `fish` will use the built-in editor (same as specifying **-i**).\n\n**-i** or **--interactive**  \nForce opening the function body in the built-in editor even if `$VISUAL` or `$EDITOR` is defined.\n\n**-s** or **--save**  \nAutomatically save the function after successfully editing it.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## Example\n\nSay you want to modify your prompt.\n\nRun:\n\n```\n>_ funced fish_prompt\n```\n\nThis will open up your editor, allowing you to modify the function. When you’re done, save and quit. Fish will reload the function, so you should see the changes right away.\n\nWhen you’re done, use:\n\n```\n>_ funcsave fish_prompt\n```\n\nFor more, see [funcsave](funcsave).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/funced.html](https://fishshell.com/docs/3.7/cmds/funced.html)"
- name: funcsave
  summary: funcsave saves a function to a file in the fish configuration directory
  description: "# funcsave - save the definition of a function to the user’s autoload directory\n\n## Synopsis\n\n```\nfuncsave FUNCTION_NAME\nfuncsave [-q | --quiet] [(-d | --directory) DIR] FUNCTION_NAME\n```\n\n## Description\n\n`funcsave` saves a function to a file in the fish configuration directory. This function will be [automatically loaded](../language#syntax-function-autoloading) by current and future fish sessions. This can be useful to commit functions created interactively for permanent use.\n\nIf you have erased a function using [functions](functions)’s `--erase` option, `funcsave` will remove the saved function definition.\n\nBecause fish loads functions on-demand, saved functions cannot serve as [event handlers](../language#event) until they are run or otherwise sourced. To activate an event handler for every new shell, add the function to the [configuration file](../language#configuration) instead of using `funcsave`.\n\nThis is often used after [funced](funced), which opens the function in `$EDITOR` or `$VISUAL` and loads it into the current session afterwards.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/funcsave.html](https://fishshell.com/docs/3.7/cmds/funcsave.html)"
- name: function
  summary: function creates a new function NAME with the body BODY
  description: "# function - create a function\n\n## Synopsis\n\n```\nfunction NAME [OPTIONS]; BODY; end\n```\n\n## Description\n\n`function` creates a new function *NAME* with the body *BODY*.\n\nA function is a list of commands that will be executed when the name of the function is given as a command.\n\nThe following options are available:\n\n**-a** *NAMES* or **--argument-names** *NAMES*  \nAssigns the value of successive command-line arguments to the names given in *NAMES*. These are the same arguments given in [`argv`](../language#envvar-argv), and are still available there. See also [Argument Handling](../language#variables-argv).\n\n**-d** *DESCRIPTION* or **--description** *DESCRIPTION*  \nA description of what the function does, suitable as a completion description.\n\n**-w** *WRAPPED_COMMAND* or **--wraps** *WRAPPED_COMMAND*  \nInherit completions from the given *WRAPPED_COMMAND*. See the documentation for [complete](complete) for more information.\n\n**-e** *EVENT_NAME* or **--on-event** *EVENT_NAME*  \nRun this function when the specified named event is emitted. Fish internally generates named events, for example, when showing the prompt. Custom events can be emitted using the [emit](emit) command.\n\n**-v** *VARIABLE_NAME* or **--on-variable** *VARIABLE_NAME*  \nRun this function when the variable *VARIABLE_NAME* changes value. Note that **fish** makes no guarantees on any particular timing or even that the function will be run for every single `set`. Rather it will be run when the variable has been set at least once, possibly skipping some values or being run when the variable has been set to the same value (except for universal variables set in other shells - only changes in the value will be picked up for those).\n\n**-j** *PID* or **--on-job-exit** *PID*  \nRun this function when the job containing a child process with the given process identifier *PID* exits. Instead of a PID, the string ‘caller’ can be specified. This is only allowed when in a command substitution, and will result in the handler being triggered by the exit of the job which created this command substitution.\n\n**-p** *PID* or **--on-process-exit** *PID*  \nRun this function when the fish child process with process ID PID exits. Instead of a PID, for backward compatibility, “`%self`” can be specified as an alias for `$fish_pid`, and the function will be run when the current fish instance exits.\n\n**-s** *SIGSPEC* or **--on-signal** *SIGSPEC*  \nRun this function when the signal `SIGSPEC` is delivered. `SIGSPEC` can be a signal number, or the signal name, such as `SIGHUP` (or just `HUP`). Note that the signal must have been delivered to **fish**; for example, Ctrl-C sends `SIGINT` to the foreground process group, which will not be **fish** if you are running another command at the time. Observing a signal will prevent fish from exiting in response to that signal.\n\n**-S** or **--no-scope-shadowing**  \nAllows the function to access the variables of calling functions. Normally, any variables inside the function that have the same name as variables from the calling function are “shadowed”, and their contents are independent of the calling function.\n\nIt’s important to note that this does not capture referenced variables or the scope at the time of function declaration! At this time, fish does not have any concept of closures, and variable lifetimes are never extended. In other words, by using **--no-scope-shadowing** the scope of the function each time it is run is shared with the scope it was *called* from rather than the scope it was *defined* in.\n\n**-V** or **--inherit-variable NAME**  \nSnapshots the value of the variable `NAME` and defines a local variable with that same name and value when the function is defined. This is similar to a closure in other languages like Python but a bit different. Note the word “snapshot” in the first sentence. If you change the value of the variable after defining the function, even if you do so in the same scope (typically another function) the new value will not be used by the function you just created using this option. See the `function notify` example below for how this might be used.\n\nThe event handler switches (`on-event`, `on-variable`, `on-job-exit`, `on-process-exit` and `on-signal`) cause a function to run automatically at specific events. New named events for `--on-event` can be fired using the [emit](emit) builtin. Fish already generates a few events, see [Event handlers](../language#event) for more.\n\nFunctions may not be named the same as a reserved keyword. These are elements of fish syntax or builtin commands which are essential for the operations of the shell. Current reserved words are `[`, `_`, `and`, `argparse`, `begin`, `break`, `builtin`, `case`, `command`, `continue`, `else`, `end`, `eval`, `exec`, `for`, `function`, `if`, `not`, `or`, `read`, `return`, `set`, `status`, `string`, `switch`, `test`, `time`, and `while`.\n\n## Example\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nwill run the `ls` command, using the `-l` option, while passing on any additional files and switches to `ls`.\n\n```\nfunction mkdir -d \"Create a directory and set CWD\"\n    command mkdir $argv\n    if test $status = 0\n        switch $argv[(count $argv)]\n            case '-*'\n\n            case '*'\n                cd $argv[(count $argv)]\n                return\n        end\n    end\nend\n```\n\nThis will run the `mkdir` command, and if it is successful, change the current working directory to the one just created.\n\n```\nfunction notify\n    set -l job (jobs -l -g)\n    or begin; echo \"There are no jobs\" >&2; return 1; end\n\n    function _notify_job_$job --on-job-exit $job --inherit-variable job\n        echo -n \\a # beep\n        functions -e _notify_job_$job\n    end\nend\n```\n\nThis will beep when the most recent job completes.\n\n## Notes\n\nEvents are only received from the current fish process as there is no way to send events from one fish process to another.\n\n## See more\n\nFor more explanation of how functions fit into fish, see [Functions](../language#syntax-function).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/function.html](https://fishshell.com/docs/3.7/cmds/function.html)"
- name: functions
  summary: functions prints or erases functions
  description: "# functions - print or erase functions\n\n## Synopsis\n\n```\nfunctions [-a | --all] [-n | --names]\nfunctions [-D | --details] [-v] FUNCTION\nfunctions -c OLDNAME NEWNAME\nfunctions -d DESCRIPTION FUNCTION\nfunctions [-e | -q] FUNCTION ...\n```\n\n## Description\n\n`functions` prints or erases functions.\n\nThe following options are available:\n\n**-a** or **--all**  \nLists all functions, even those whose name starts with an underscore.\n\n**-c** or **--copy** *OLDNAME* *NEWNAME*  \nCreates a new function named *NEWNAME*, using the definition of the *OLDNAME* function.\n\n**-d** or **--description** *DESCRIPTION*  \nChanges the description of this function.\n\n**-e** or **--erase**  \nCauses the specified functions to be erased. This also means that it is prevented from autoloading in the current session. Use [funcsave](funcsave) to remove the saved copy.\n\n**-D** or **--details**  \nReports the path name where the specified function is defined or could be autoloaded, `stdin` if the function was defined interactively or on the command line or by reading standard input, **-** if the function was created via [source](source), and `n/a` if the function isn’t available. (Functions created via [alias](alias) will return **-**, because `alias` uses `source` internally.) If the **--verbose** option is also specified then five lines are written:\n\n- the pathname as already described,\n- `autoloaded`, `not-autoloaded` or `n/a`,\n- the line number within the file or zero if not applicable,\n- `scope-shadowing` if the function shadows the vars in the calling function (the normal case if it wasn’t defined with **--no-scope-shadowing**), else `no-scope-shadowing`, or `n/a` if the function isn’t defined,\n- the function description minimally escaped so it is a single line, or `n/a` if the function isn’t defined or has no description.\n\nYou should not assume that only five lines will be written since we may add additional information to the output in the future.\n\n**--no-details**  \nTurns off function path reporting, so just the definition will be printed.\n\n**-n** or **--names**  \nLists the names of all defined functions.\n\n**-q** or **--query**  \nTests if the specified functions exist.\n\n**-v** or **--verbose**  \nMake some output more verbose.\n\n**-H** or **--handlers**  \nShow all event handlers.\n\n**-t** or **--handlers-type** *TYPE*  \nShow all event handlers matching the given *TYPE*.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nThe default behavior of `functions`, when called with no arguments, is to print the names of all defined functions. Unless the `-a` option is given, no functions starting with underscores are included in the output.\n\nIf any non-option parameters are given, the definition of the specified functions are printed.\n\nCopying a function using `-c` copies only the body of the function, and does not attach any event notifications from the original function.\n\nOnly one function’s description can be changed in a single invocation of `functions -d`.\n\nThe exit status of `functions` is the number of functions specified in the argument list that do not exist, which can be used in concert with the `-q` option.\n\n## Examples\n\n```\nfunctions -n\n# Displays a list of currently-defined functions\n\nfunctions -c foo bar\n# Copies the 'foo' function to a new function called 'bar'\n\nfunctions -e bar\n# Erases the function ``bar``\n```\n\n## See more\n\nFor more explanation of how functions fit into fish, see [Functions](../language#syntax-function).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/functions.html](https://fishshell.com/docs/3.7/cmds/functions.html)"
- name: help
  summary: help displays the fish help documentation
  description: "# help - display fish documentation\n\n## Synopsis\n\n```\nhelp [SECTION]\n```\n\n## Description\n\n`help` displays the fish help documentation.\n\nIf a *SECTION* is specified, the help for that command is shown.\n\nThe **-h** or **--help** option displays help about using this command.\n\nIf the [`BROWSER`](../language#envvar-BROWSER) environment variable is set, it will be used to display the documentation. Otherwise, fish will search for a suitable browser. To use a different browser than as described above, you can set `$fish_help_browser` This variable may be set as a list, where the first element is the browser command and the rest are browser options.\n\n## Example\n\n`help fg` shows the documentation for the [fg](fg) builtin.\n\n## Notes\n\nMost builtin commands, including this one, display their help in the terminal when given the **--help** option.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/help.html](https://fishshell.com/docs/3.7/cmds/help.html)"
- name: history
  summary: history is used to search, delete, and otherwise manipulate the history of interactive commands
  description: "# history - show and manipulate command history\n\n## Synopsis\n\n```\nhistory [search] [--show-time] [--case-sensitive]\n                 [--exact | --prefix | --contains] [--max N] [--null] [--reverse]\n                 [SEARCH_STRING ...]\nhistory delete [--case-sensitive]\n               [--exact | --prefix | --contains] SEARCH_STRING ...\nhistory merge\nhistory save\nhistory clear\nhistory clear-session\n```\n\n## Description\n\n`history` is used to search, delete, and otherwise manipulate the [history of interactive commands](../interactive#history-search).\n\nThe following operations (sub-commands) are available:\n\n**search**  \nReturns history items matching the search string. If no search string is provided it returns all history items. This is the default operation if no other operation is specified. You only have to explicitly say `history search` if you wish to search for one of the subcommands. The `--contains` search option will be used if you don’t specify a different search option. Entries are ordered newest to oldest unless you use the `--reverse` flag. If stdout is attached to a tty the output will be piped through your pager by the history function. The history builtin simply writes the results to stdout.\n\n**delete**  \nDeletes history items. The `--contains` search option will be used if you don’t specify a different search option. If you don’t specify `--exact` a prompt will be displayed before any items are deleted asking you which entries are to be deleted. You can enter the word “all” to delete all matching entries. You can enter a single ID (the number in square brackets) to delete just that single entry. You can enter more than one ID, or an ID range separated by a space to delete multiple entries. Just press \\[enter\\] to not delete anything. Note that the interactive delete behavior is a feature of the history function. The history builtin only supports `--exact --case-sensitive` deletion.\n\n**merge**  \nImmediately incorporates history changes from other sessions. Ordinarily `fish` ignores history changes from sessions started after the current one. This command applies those changes immediately.\n\n**save**  \nImmediately writes all changes to the history file. The shell automatically saves the history file; this option is provided for internal use and should not normally need to be used by the user.\n\n**clear**  \nClears the history file. A prompt is displayed before the history is erased asking you to confirm you really want to clear all history unless `builtin history` is used.\n\n**clear-session**  \nClears the history file from all activity of the current session. Note: If `history merge` or `builtin history merge` is run in a session, only the history after this will be erased.\n\nThe following options are available:\n\nThese flags can appear before or immediately after one of the sub-commands listed above.\n\n**-C** or **--case-sensitive**  \nDoes a case-sensitive search. The default is case-insensitive. Note that prior to fish 2.4.0 the default was case-sensitive.\n\n**-c** or **--contains**  \nSearches items in the history that contain the specified text string. This is the default for the **--search** flag. This is not currently supported by the **delete** subcommand.\n\n**-e** or **--exact**  \nSearches or deletes items in the history that exactly match the specified text string. This is the default for the **delete** subcommand. Note that the match is case-insensitive by default. If you really want an exact match, including letter case, you must use the **-C** or **--case-sensitive** flag.\n\n**-p** or **--prefix**  \nSearches items in the history that begin with the specified text string. This is not currently supported by the **delete** subcommand.\n\n**-t** or **--show-time**  \nPrepends each history entry with the date and time the entry was recorded. By default it uses the strftime format `# %c%n`. You can specify another format; e.g., `--show-time=\"%Y-%m-%d %H:%M:%S \"` or `--show-time=\"%a%I%p\"`. The short option, **-t**, doesn’t accept a strftime format string; it only uses the default format. Any strftime format is allowed, including `%s` to get the raw UNIX seconds since the epoch.\n\n**-z** or **--null**  \nCauses history entries written by the search operations to be terminated by a NUL character rather than a newline. This allows the output to be processed by `read -z` to correctly handle multiline history entries.\n\n**-**\\*NUMBER\\* **-n** *NUMBER* or **--max** *NUMBER*  \nLimits the matched history items to the first *NUMBER* matching entries. This is only valid for `history search`.\n\n**-R** or **--reverse**  \nCauses the history search results to be ordered oldest to newest. Which is the order used by most shells. The default is newest to oldest.\n\n**-h** or **--help**  \nDisplays help for this command.\n\n## Example\n\n```\nhistory clear\n# Deletes all history items\n\nhistory search --contains \"foo\"\n# Outputs a list of all previous commands containing the string \"foo\".\n\nhistory delete --prefix \"foo\"\n# Interactively deletes commands which start with \"foo\" from the history.\n# You can select more than one entry by entering their IDs separated by a space.\n```\n\n## Customizing the name of the history file\n\nBy default interactive commands are logged to `$XDG_DATA_HOME/fish/fish_history` (typically `~/.local/share/fish/fish_history`).\n\nYou can set the `fish_history` variable to another name for the current shell session. The default value (when the variable is unset) is `fish` which corresponds to `$XDG_DATA_HOME/fish/fish_history`. If you set it to e.g. `fun`, the history would be written to `$XDG_DATA_HOME/fish/fun_history`. An empty string means history will not be stored at all. This is similar to the private session features in web browsers.\n\nYou can change `fish_history` at any time (by using `set -x fish_history \"session_name\"`) and it will take effect right away. If you set it to `\"default\"`, it will use the default session name (which is `\"fish\"`).\n\nOther shells such as bash and zsh use a variable named `HISTFILE` for a similar purpose. Fish uses a different name to avoid conflicts and signal that the behavior is different (session name instead of a file path). Also, if you set the var to anything other than `fish` or `default` it will inhibit importing the bash history. That’s because the most common use case for this feature is to avoid leaking private or sensitive history when giving a presentation.\n\n## Notes\n\nIf you specify both **--prefix** and **--contains** the last flag seen is used.\n\nNote that for backwards compatibility each subcommand can also be specified as a long option. For example, rather than `history search` you can type `history --search`. Those long options are deprecated and will be removed in a future release.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/history.html](https://fishshell.com/docs/3.7/cmds/history.html)"
- name: if
  summary: if will execute the command CONDITION
  description: "# if - conditionally execute a command\n\n## Synopsis\n\n```\nif CONDITION; COMMANDS_TRUE ...;\n[else if CONDITION2; COMMANDS_TRUE2 ...;]\n[else; COMMANDS_FALSE ...;]\nend\n```\n\n## Description\n\n`if` will execute the command `CONDITION`. If the condition’s exit status is 0, the commands `COMMANDS_TRUE` will execute. If the exit status is not 0 and [else](else) is given, `COMMANDS_FALSE` will be executed.\n\nYou can use [and](and) or [or](or) in the condition. See the second example below.\n\nThe exit status of the last foreground command to exit can always be accessed using the [\\$status](../language#variables-status) variable.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\nThe following code will print `foo.txt exists` if the file foo.txt exists and is a regular file, otherwise it will print `bar.txt exists` if the file bar.txt exists and is a regular file, otherwise it will print `foo.txt and bar.txt do not exist`.\n\n```\nif test -f foo.txt\n    echo foo.txt exists\nelse if test -f bar.txt\n    echo bar.txt exists\nelse\n    echo foo.txt and bar.txt do not exist\nend\n```\n\nThe following code will print “foo.txt exists and is readable” if foo.txt is a regular file and readable\n\n```\nif test -f foo.txt\n   and test -r foo.txt\n   echo \"foo.txt exists and is readable\"\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/if.html](https://fishshell.com/docs/3.7/cmds/if.html)"
- name: Interactive
  summary: Fish prides itself on being really nice to use interactively
  description: "# Interactive use\n\nFish prides itself on being really nice to use interactively. That’s down to a few features we’ll explain in the next few sections.\n\nFish is used by giving commands in the fish language, see [The Fish Language](language#language) for information on that.\n\n## Help\n\nFish has an extensive help system. Use the [help](cmds/help) command to obtain help on a specific subject or command. For instance, writing `help syntax` displays the [syntax section](language#syntax) of this documentation.\n\nFish also has man pages for its commands, and translates the help pages to man pages. For example, `man set` will show the documentation for `set` as a man page.\n\nHelp on a specific builtin can also be obtained with the `-h` parameter. For instance, to obtain help on the [fg](cmds/fg) builtin, either type `fg -h` or `help fg`.\n\nThe main page can be viewed via `help index` (or just `help`) or `man fish-doc`. The tutorial can be viewed with `help tutorial` or `man fish-tutorial`.\n\n## Autosuggestions\n\nfish suggests commands as you type, based on [command history](#history-search), completions, and valid file paths. As you type commands, you will see a suggestion offered after the cursor, in a muted gray color (which can be changed with the `fish_color_autosuggestion` variable).\n\nTo accept the autosuggestion (replacing the command line contents), press → or Control+F. To accept the first suggested word, press Alt+→ or Alt+F. If the autosuggestion is not what you want, just ignore it: it won’t execute unless you accept it.\n\nAutosuggestions are a powerful way to quickly summon frequently entered commands, by typing the first few characters. They are also an efficient technique for navigating through directory hierarchies.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completion\n\nTab completion is a time saving feature of any modern shell. When you type Tab, fish tries to guess the rest of the word under the cursor. If it finds just one possibility, it inserts it. If it finds more, it inserts the longest unambiguous part and then opens a menu (the “pager”) that you can navigate to find what you’re looking for.\n\nThe pager can be navigated with the arrow keys, Page Up / Page Down, Tab or Shift+Tab. Pressing Control+S (the `pager-toggle-search` binding - / in vi-mode) opens up a search menu that you can use to filter the list.\n\nFish provides some general purpose completions, like for commands, variable names, usernames or files.\n\nIt also provides a large number of program specific scripted completions. Most of these completions are simple options like the `-l` option for `ls`, but a lot are more advanced. For example:\n\n- `man` and `whatis` show the installed manual pages as completions.\n- `make` uses targets in the Makefile in the current directory as completions.\n- `mount` uses mount points specified in fstab as completions.\n- `apt`, `rpm` and `yum` show installed or installable packages\n\nYou can also write your own completions or install some you got from someone else. For that, see [Writing your own completions](completions#completion-own).\n\nCompletion scripts are loaded on demand, just like [functions are](language#syntax-function-autoloading). The difference is the `$fish_complete_path` [list](language#variables-lists) is used instead of `$fish_function_path`. Typically you can drop new completions in ~/.config/fish/completions/name-of-command.fish and fish will find them automatically.\n\n## Syntax highlighting\n\nFish interprets the command line as it is typed and uses syntax highlighting to provide feedback. The most important feedback is the detection of potential errors. By default, errors are marked red.\n\nDetected errors include:\n\n- Non-existing commands.\n- Reading from or appending to a non-existing file.\n- Incorrect use of output redirects\n- Mismatched parenthesis\n\nTo customize the syntax highlighting, you can set the environment variables listed in the [Variables for changing highlighting colors](#variables-color) section.\n\nFish also provides pre-made color themes you can pick with [fish_config](cmds/fish_config). Running just `fish_config` opens a browser interface, or you can use `fish_config theme` in the terminal.\n\nFor example, to disable nearly all coloring:\n\n```\nfish_config theme choose none\n```\n\nOr, to see all themes, right in your terminal:\n\n```\nfish_config theme show\n```\n\n### Syntax highlighting variables\n\nThe colors used by fish for syntax highlighting can be configured by changing the values of various variables. The value of these variables can be one of the colors accepted by the [set_color](cmds/set_color) command. The modifier switches accepted by `set_color` like `--bold`, `--dim`, `--italics`, `--reverse` and `--underline` are also accepted.\n\nExample: to make errors highlighted and red, use:\n\n```\nset fish_color_error red --bold\n```\n\nThe following variables are available to change the highlighting colors in fish:\n\n| Variable                     | Meaning                                                                |\n|------------------------------|------------------------------------------------------------------------|\n| `fish_color_normal`          | default color                                                          |\n| `fish_color_command`         | commands like echo                                                     |\n| `fish_color_keyword`         | keywords like if - this falls back on the command color if unset       |\n| `fish_color_quote`           | quoted text like `\"abc\"`                                               |\n| `fish_color_redirection`     | IO redirections like \\>/dev/null                                       |\n| `fish_color_end`             | process separators like `;` and `&`                                    |\n| `fish_color_error`           | syntax errors                                                          |\n| `fish_color_param`           | ordinary command parameters                                            |\n| `fish_color_valid_path`      | parameters that are filenames (if the file exists)                     |\n| `fish_color_option`          | options starting with “-”, up to the first “--” parameter              |\n| `fish_color_comment`         | comments like ‘# important’                                            |\n| `fish_color_selection`       | selected text in vi visual mode                                        |\n| `fish_color_operator`        | parameter expansion operators like `*` and `~`                         |\n| `fish_color_escape`          | character escapes like `\\n` and `\\x70`                                 |\n| `fish_color_autosuggestion`  | autosuggestions (the proposed rest of a command)                       |\n| `fish_color_cwd`             | the current working directory in the default prompt                    |\n| `fish_color_cwd_root`        | the current working directory in the default prompt for the root user  |\n| `fish_color_user`            | the username in the default prompt                                     |\n| `fish_color_host`            | the hostname in the default prompt                                     |\n| `fish_color_host_remote`     | the hostname in the default prompt for remote sessions (like ssh)      |\n| `fish_color_status`          | the last command’s nonzero exit code in the default prompt             |\n| `fish_color_cancel`          | the ‘^C’ indicator on a canceled command                               |\n| `fish_color_search_match`    | history search matches and selected pager items (background only)      |\n| `fish_color_history_current` | the current position in the history for commands like `dirh` and `cdh` |\n\nIf a variable isn’t set or is empty, fish usually tries `$fish_color_normal`, except for:\n\n- `$fish_color_keyword`, where it tries `$fish_color_command` first.\n- `$fish_color_option`, where it tries `$fish_color_param` first.\n- For `$fish_color_valid_path`, if that doesn’t have a color, but only modifiers, it adds those to the color that would otherwise be used, like `$fish_color_param`. But if valid paths have a color, it uses that and adds in modifiers from the other color.\n\n### Pager color variables\n\nfish will sometimes present a list of choices in a table, called the pager.\n\nExample: to set the background of each pager row, use:\n\n```\nset fish_pager_color_background --background=white\n```\n\nTo have black text on alternating white and gray backgrounds:\n\n```\nset fish_pager_color_prefix black\nset fish_pager_color_completion black\nset fish_pager_color_description black\nset fish_pager_color_background --background=white\nset fish_pager_color_secondary_background --background=brwhite\n```\n\nVariables affecting the pager colors:\n\n| Variable                                 | Meaning                                                     |\n|------------------------------------------|-------------------------------------------------------------|\n| `fish_pager_color_progress`              | the progress bar at the bottom left corner                  |\n| `fish_pager_color_background`            | the background color of a line                              |\n| `fish_pager_color_prefix`                | the prefix string, i.e. the string that is to be completed  |\n| `fish_pager_color_completion`            | the completion itself, i.e. the proposed rest of the string |\n| `fish_pager_color_description`           | the completion description                                  |\n| `fish_pager_color_selected_background`   | background of the selected completion                       |\n| `fish_pager_color_selected_prefix`       | prefix of the selected completion                           |\n| `fish_pager_color_selected_completion`   | suffix of the selected completion                           |\n| `fish_pager_color_selected_description`  | description of the selected completion                      |\n| `fish_pager_color_secondary_background`  | background of every second unselected completion            |\n| `fish_pager_color_secondary_prefix`      | prefix of every second unselected completion                |\n| `fish_pager_color_secondary_completion`  | suffix of every second unselected completion                |\n| `fish_pager_color_secondary_description` | description of every second unselected completion           |\n\nWhen the secondary or selected variables aren’t set or are empty, the normal variables are used, except for `$fish_pager_color_selected_background`, where the background of `$fish_color_search_match` is tried first.\n\n## Abbreviations\n\nTo avoid needless typing, a frequently-run command like `git checkout` can be abbreviated to `gco` using the [abbr](cmds/abbr) command.\n\n```\nabbr -a gco git checkout\n```\n\nAfter entering `gco` and pressing Space or Enter, a `gco` in command position will turn into `git checkout` in the command line. If you want to use a literal `gco` sometimes, use Control+Space [\\[1\\]](#id5).\n\nThis is a lot more powerful, for example you can make going up a number of directories easier with this:\n\n```\nfunction multicd\n    echo cd (string repeat -n (math (string length -- $argv[1]) - 1) ../)\nend\nabbr --add dotdot --regex '^\\.\\.+$' --function multicd\n```\n\nNow, `..` transforms to `cd ../`, while `...` turns into `cd ../../` and `....` expands to `cd ../../../`.\n\nThe advantage over aliases is that you can see the actual command before using it, add to it or change it, and the actual command will be stored in history.\n\n\\[[1](#id4)\\]\n\nAny binding that executes the `expand-abbr` or `execute` [bind function](cmds/bind) will expand abbreviations. By default Control+Space is bound to just inserting a space.\n\n## Programmable title\n\nWhen using most virtual terminals, it is possible to set the message displayed in the titlebar of the terminal window. This can be done automatically in fish by defining the [fish_title](cmds/fish_title) function. The [fish_title](cmds/fish_title) function is executed before and after a new command is executed or put into the foreground and the output is used as a titlebar message. The [status current-command](cmds/status) builtin will always return the name of the job to be put into the foreground (or `fish` if control is returning to the shell) when the [fish_prompt](cmds/fish_prompt) function is called. The first argument to fish_title will contain the most recently executed foreground command as a string.\n\nThe default fish title shows the hostname if connected via ssh, the currently running command (unless it is fish) and the current working directory. All of this is shortened to not make the tab too wide.\n\nExamples:\n\nTo show the last command and working directory in the title:\n\n```\nfunction fish_title\n    # `prompt_pwd` shortens the title. This helps prevent tabs from becoming very wide.\n    echo $argv[1] (prompt_pwd)\n    pwd\nend\n```\n\n## Programmable prompt\n\nWhen it is fish’s turn to ask for input (like after it started or the command ended), it will show a prompt. It does this by running the [fish_prompt](cmds/fish_prompt) and [fish_right_prompt](cmds/fish_right_prompt) functions.\n\nThe output of the former is displayed on the left and the latter’s output on the right side of the terminal. The output of [fish_mode_prompt](cmds/fish_mode_prompt) will be prepended on the left, though the default function only does this when in [vi-mode](#vi-mode).\n\n## Configurable greeting\n\nWhen it is started interactively, fish tries to run the [fish_greeting](cmds/fish_greeting) function. The default fish_greeting prints a simple greeting. You can change its text by changing the `$fish_greeting` variable, for instance using a [universal variable](language#variables-universal):\n\n```\nset -U fish_greeting\n```\n\nor you can set it [globally](language#variables-scope) in [config.fish](language#configuration):\n\n```\nset -g fish_greeting 'Hey, stranger!'\n```\n\nor you can script it by changing the function:\n\n```\nfunction fish_greeting\n    random choice \"Hello!\" \"Hi\" \"G'day\" \"Howdy\"\nend\n```\n\nsave this in config.fish or [a function file](language#syntax-function-autoloading). You can also use [funced](cmds/funced) and [funcsave](cmds/funcsave) to edit it easily.\n\n## Private mode\n\nIf `$fish_private_mode` is set to a non-empty value, commands will not be written to the history file on disk.\n\nYou can also launch with `fish --private` (or `fish -P` for short). This both hides old history and prevents writing history to disk. This is useful to avoid leaking personal information (e.g. for screencasts) or when dealing with sensitive information.\n\nYou can query the variable `fish_private_mode` (`if test -n \"$fish_private_mode\" ...`) if you would like to respect the user’s wish for privacy and alter the behavior of your own fish scripts.\n\n## Command line editor\n\nThe fish editor features copy and paste, a [searchable history](#history-search) and many editor functions that can be bound to special keyboard shortcuts.\n\nLike bash and other shells, fish includes two sets of keyboard shortcuts (or key bindings): one inspired by the Emacs text editor, and one by the Vi text editor. The default editing mode is Emacs. You can switch to Vi mode by running [fish_vi_key_bindings](cmds/fish_vi_key_bindings) and switch back with [fish_default_key_bindings](cmds/fish_default_key_bindings). You can also make your own key bindings by creating a function and setting the `fish_key_bindings` variable to its name. For example:\n\n```\nfunction fish_hybrid_key_bindings --description \\\n\"Vi-style bindings that inherit emacs-style bindings in all modes\"\n    for mode in default insert visual\n        fish_default_key_bindings -M $mode\n    end\n    fish_vi_key_bindings --no-erase\nend\nset -g fish_key_bindings fish_hybrid_key_bindings\n```\n\nWhile the key bindings included with fish include many of the shortcuts popular from the respective text editors, they are not a complete implementation. They include a shortcut to open the current command line in your preferred editor (Alt+E by default) if you need the full power of your editor.\n\n### Shared bindings\n\nSome bindings are common across Emacs and Vi mode, because they aren’t text editing bindings, or because what Vi/Vim does for a particular key doesn’t make sense for a shell.\n\n- Tab [completes](#tab-completion) the current token. Shift+Tab completes the current token and starts the pager’s search mode. Tab is the same as Control+I.\n- ← (Left) and → (Right) move the cursor left or right by one character. If the cursor is already at the end of the line, and an autosuggestion is available, → accepts the autosuggestion.\n- Enter executes the current commandline or inserts a newline if it’s not complete yet (e.g. a `)` or `end` is missing).\n- Alt+Enter inserts a newline at the cursor position.\n- Alt+← and Alt+→ move the cursor one word left or right (to the next space or punctuation mark), or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, Alt+→ (or Alt+F) accepts the first word in the suggestion.\n- Control+← and Control+→ move the cursor one word left or right. These accept one word of the autosuggestion - the part they’d move over.\n- Shift+← and Shift+→ move the cursor one word left or right, without stopping on punctuation. These accept one big word of the autosuggestion.\n- ↑ (Up) and ↓ (Down) (or Control+P and Control+N for emacs aficionados) search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching.\n- Alt+↑ and Alt+↓ search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the [history](#history-search) section for more information on history searching.\n- Control+C interrupt/kill whatever is running (SIGINT).\n- Control+D delete one character to the right of the cursor. If the command line is empty, Control+D will exit fish.\n- Control+U removes contents from the beginning of line to the cursor (moving it to the [killring](#killring)).\n- Control+L clears and repaints the screen.\n- Control+W removes the previous path component (everything up to the previous “/”, “:” or “@”) (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Control+X copies the current buffer to the system’s clipboard, Control+V inserts the clipboard contents. (see [fish_clipboard_copy](cmds/fish_clipboard_copy) and [fish_clipboard_paste](cmds/fish_clipboard_paste))\n- Alt+D moves the next word to the [Copy and paste (Kill Ring)](#killring).\n- Alt+H (or F1) shows the manual page for the current command, if one exists.\n- Alt+L lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.\n- Alt+O opens the file at the cursor in a pager.\n- Alt+P adds the string `&| less;` to the end of the job under the cursor. The result is that the output of the command will be paged.\n- Alt+W prints a short description of the command under the cursor.\n- Alt+E edit the current command line in an external editor. The editor is chosen from the first available of the `$VISUAL` or `$EDITOR` variables.\n- Alt+V Same as Alt+E.\n- Alt+S Prepends `sudo` to the current commandline. If the commandline is empty, prepend `sudo` to the last commandline.\n- Control+Space Inserts a space without expanding an [abbreviation](#abbreviations). For vi-mode this only applies to insert-mode.\n\n### Emacs mode commands\n\nTo enable emacs mode, use [fish_default_key_bindings](cmds/fish_default_key_bindings). This is also the default.\n\n- Home or Control+A moves the cursor to the beginning of the line.\n- End or Control+E moves to the end of line. If the cursor is already at the end of the line, and an autosuggestion is available, End or Control+E accepts the autosuggestion.\n- Control+B, Control+F move the cursor one character left or right or accept the autosuggestion just like the ← (Left) and → (Right) shared bindings (which are available as well).\n- Control+N, Control+P move the cursor up/down or through history, like the up and down arrow shared bindings.\n- Delete or Backspace removes one character forwards or backwards respectively. This also goes for Control+H, which is indistinguishable from backspace.\n- Alt+Backspace removes one word backwards.\n- Alt+\\< moves to the beginning of the commandline, Alt+\\> moves to the end.\n- Control+K deletes from the cursor to the end of line (moving it to the [Copy and paste (Kill Ring)](#killring)).\n- Escape and Control+G cancel the current operation. Immediately after an unambiguous completion this undoes it.\n- Alt+C capitalizes the current word.\n- Alt+U makes the current word uppercase.\n- Control+T transposes the last two characters.\n- Alt+T transposes the last two words.\n- Control+Z, Control+\\_ (Control+/ on some terminals) undo the most recent edit of the line.\n- Alt+/ reverts the most recent undo.\n- Control+R opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing Control+R again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n\nYou can change these key bindings using the [bind](cmds/bind) builtin.\n\n### Vi mode commands\n\nVi mode allows for the use of Vi-like commands at the prompt. Initially, [insert mode](#vi-mode-insert) is active. Escape enters [command mode](#vi-mode-command). The commands available in command, insert and visual mode are described below. Vi mode shares [some bindings](#shared-binds) with [Emacs mode](#emacs-mode).\n\nTo enable vi mode, use [fish_vi_key_bindings](cmds/fish_vi_key_bindings). It is also possible to add all emacs-mode bindings to vi-mode by using something like:\n\n```\nfunction fish_user_key_bindings\n    # Execute this once per mode that emacs bindings should be used in\n    fish_default_key_bindings -M insert\n\n    # Then execute the vi-bindings so they take precedence when there's a conflict.\n    # Without --no-erase fish_vi_key_bindings will default to\n    # resetting all bindings.\n    # The argument specifies the initial mode (insert, \"default\" or visual).\n    fish_vi_key_bindings --no-erase insert\nend\n```\n\nWhen in vi-mode, the [fish_mode_prompt](cmds/fish_mode_prompt) function will display a mode indicator to the left of the prompt. To disable this feature, override it with an empty function. To display the mode elsewhere (like in your right prompt), use the output of the `fish_default_mode_prompt` function.\n\nWhen a binding switches the mode, it will repaint the mode-prompt if it exists, and the rest of the prompt only if it doesn’t. So if you want a mode-indicator in your `fish_prompt`, you need to erase `fish_mode_prompt` e.g. by adding an empty file at `~/.config/fish/functions/fish_mode_prompt.fish`. (Bindings that change the mode are supposed to call the `repaint-mode` bind function, see [bind](cmds/bind))\n\nThe `fish_vi_cursor` function will be used to change the cursor’s shape depending on the mode in supported terminals. The following snippet can be used to manually configure cursors after enabling vi-mode:\n\n```\n# Emulates vim's cursor shape behavior\n# Set the normal and visual mode cursors to a block\nset fish_cursor_default block\n# Set the insert mode cursor to a line\nset fish_cursor_insert line\n# Set the replace mode cursors to an underscore\nset fish_cursor_replace_one underscore\nset fish_cursor_replace underscore\n# Set the external cursor to a line. The external cursor appears when a command is started.\n# The cursor shape takes the value of fish_cursor_default when fish_cursor_external is not specified.\nset fish_cursor_external line\n# The following variable can be used to configure cursor shape in\n# visual mode, but due to fish_cursor_default, is redundant here\nset fish_cursor_visual block\n```\n\nAdditionally, `blink` can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.\n\nFish knows the shapes “block”, “line” and “underscore”, other values will be ignored.\n\nIf the cursor shape does not appear to be changing after setting the above variables, it’s likely your terminal emulator does not support the capabilities necessary to do this. It may also be the case, however, that `fish_vi_cursor` has not detected your terminal’s features correctly (for example, if you are using `tmux`). If this is the case, you can force `fish_vi_cursor` to set the cursor shape by setting `$fish_vi_force_cursor` in `config.fish`. You’ll have to restart fish for any changes to take effect. If cursor shape setting remains broken after this, it’s almost certainly an issue with your terminal emulator, and not fish.\n\n#### Command mode\n\nCommand mode is also known as normal mode.\n\n- h moves the cursor left.\n- l moves the cursor right.\n- k and j search the command history for the previous/next command containing the string that was specified on the commandline before the search was started. If the commandline was empty when the search started, all commands match. See the [history](#history-search) section for more information on history searching. In multi-line commands, they move the cursor up and down respectively.\n- i enters [insert mode](#vi-mode-insert) at the current cursor position.\n- Shift+I enters [insert mode](#vi-mode-insert) at the beginning of the line.\n- v enters [visual mode](#vi-mode-visual) at the current cursor position.\n- a enters [insert mode](#vi-mode-insert) after the current cursor position.\n- Shift+A enters [insert mode](#vi-mode-insert) at the end of the line.\n- o inserts a new line under the current one and enters [insert mode](#vi-mode-insert)\n- O (capital-“o”) inserts a new line above the current one and enters [insert mode](#vi-mode-insert)\n- 0 (zero) moves the cursor to beginning of line (remaining in command mode).\n- d+d deletes the current line and moves it to the [Copy and paste (Kill Ring)](#killring).\n- Shift+D deletes text after the current cursor position and moves it to the [Copy and paste (Kill Ring)](#killring).\n- p pastes text from the [Copy and paste (Kill Ring)](#killring).\n- u undoes the most recent edit of the command line.\n- Control+R redoes the most recent edit.\n- \\[ and \\] search the command history for the previous/next token containing the token under the cursor before the search was started. See the [history](#history-search) section for more information on history searching.\n- / opens the history in a pager. This will show history entries matching the search, a few at a time. Pressing it again will search older entries, pressing Control+S (that otherwise toggles pager search) will go to newer entries. The search bar will always be selected.\n- Backspace moves the cursor left.\n- g / G moves the cursor to the beginning/end of the commandline, respectively.\n- :q exits fish.\n\n#### Insert mode\n\n- Escape enters [command mode](#vi-mode-command).\n- Backspace removes one character to the left.\n\n#### Visual mode\n\n- ← (Left) and → (Right) extend the selection backward/forward by one character.\n- h moves the cursor left.\n- l moves the cursor right.\n- k moves the cursor up.\n- j moves the cursor down.\n- b and w extend the selection backward/forward by one word.\n- d and x move the selection to the [Copy and paste (Kill Ring)](#killring) and enter [command mode](#vi-mode-command).\n- Escape and Control+C enter [command mode](#vi-mode-command).\n- c and s remove the selection and switch to insert mode.\n- X moves the entire line to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- y copies the selection to the [Copy and paste (Kill Ring)](#killring), and enters [command mode](#vi-mode-command).\n- ~ toggles the case (upper/lower) on the selection, and enters [command mode](#vi-mode-command).\n- \"\\*y copies the selection to the clipboard, and enters [command mode](#vi-mode-command).\n\n### Custom bindings\n\nIn addition to the standard bindings listed here, you can also define your own with [bind](cmds/bind):\n\n```\n# Just clear the commandline on control-c\nbind \\cc 'commandline -r \"\"'\n```\n\nPut `bind` statements into [config.fish](language#configuration) or a function called `fish_user_key_bindings`.\n\nIf you change your mind on a binding and want to go back to fish’s default, you can simply erase it again:\n\n```\nbind --erase \\cc\n```\n\nFish remembers its preset bindings and so it will take effect again. This saves you from having to remember what it was before and add it again yourself.\n\nIf you use [vi bindings](#vi-mode), note that `bind` will by default bind keys in [command mode](#vi-mode-command). To bind something in [insert mode](#vi-mode-insert):\n\n```\nbind --mode insert \\cc 'commandline -r \"\"'\n```\n\n#### Key sequences\n\nThe terminal tells fish which keys you pressed by sending some sequences of bytes to describe that key. For some keys, this is easy - pressing a simply means the terminal sends “a”. In others it’s more complicated and terminals disagree on which they send.\n\nIn these cases, [fish_key_reader](cmds/fish_key_reader) can tell you how to write the key sequence for your terminal. Just start it and press the keys you are interested in:\n\n```\n> fish_key_reader # pressing control-c\nPress a key:\nPress [ctrl-C] again to exit\nbind \\cC 'do something'\n\n> fish_key_reader # pressing the right-arrow\nPress a key:\nbind \\e\\[C 'do something'\n```\n\nNote that some key combinations are indistinguishable or unbindable. For instance control-i *is the same* as the tab key. This is a terminal limitation that fish can’t do anything about. When `fish_key_reader` prints the same sequence for two different keys, then that is because your terminal sends the same sequence for them.\n\nAlso, Escape is the same thing as Alt in a terminal. To distinguish between pressing Escape and then another key, and pressing Alt and that key (or an escape sequence the key sends), fish waits for a certain time after seeing an escape character. This is configurable via the [`fish_escape_delay_ms`](language#envvar-fish_escape_delay_ms) variable.\n\nIf you want to be able to press Escape and then a character and have it count as Alt+that character, set it to a higher value, e.g.:\n\n```\nset -g fish_escape_delay_ms 100\n```\n\nSimilarly, to disambiguate *other* keypresses where you’ve bound a subsequence and a longer sequence, fish has [`fish_sequence_key_delay_ms`](language#envvar-fish_sequence_key_delay_ms):\n\n```\n# This binds \"jk\" to switch to normal mode in vi-mode.\n# If you kept it like that, every time you press \"j\",\n# fish would wait for a \"k\" or other key to disambiguate\nbind -M insert -m default jk cancel repaint-mode\n\n# After setting this, fish only waits 200ms for the \"k\",\n# or decides to treat the \"j\" as a separate sequence, inserting it.\nset -g fish_sequence_key_delay_ms 200\n```\n\n### Copy and paste (Kill Ring)\n\nFish uses an Emacs-style kill ring for copy and paste functionality. For example, use Control+K (`kill-line`) to cut from the current cursor position to the end of the line. The string that is cut (a.k.a. killed in emacs-ese) is inserted into a list of kills, called the kill ring. To paste the latest value from the kill ring (emacs calls this “yanking”) use Control+Y (the `yank` input function). After pasting, use Alt+Y (`yank-pop`) to rotate to the previous kill.\n\nCopy and paste from outside are also supported, both via the Control+X / Control+V bindings (the `fish_clipboard_copy` and `fish_clipboard_paste` functions [\\[2\\]](#id8)) and via the terminal’s paste function, for which fish enables “Bracketed Paste Mode”, so it can tell a paste from manually entered text. In addition, when pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after. Kill ring entries are stored in `fish_killring` variable.\n\nThe commands `begin-selection` and `end-selection` (unbound by default; used for selection in vi visual mode) control text selection together with cursor movement commands that extend the current selection. The variable [`fish_cursor_selection_mode`](language#envvar-fish_cursor_selection_mode) can be used to configure if that selection should include the character under the cursor (`inclusive`) or not (`exclusive`). The default is `exclusive`, which works well with any cursor shape. For vi mode, and particularly for the `block` or `underscore` cursor shapes you may prefer `inclusive`.\n\n\\[[2](#id7)\\]\n\nThese rely on external tools. Currently xsel, xclip, wl-copy/wl-paste and pbcopy/pbpaste are supported.\n\n### Multiline editing\n\nThe fish commandline editor can be used to work on commands that are several lines long. There are three ways to make a command span more than a single line:\n\n- Pressing the Enter key while a block of commands is unclosed, such as when one or more block commands such as `for`, `begin` or `if` do not have a corresponding [end](cmds/end) command.\n- Pressing Alt+Enter instead of pressing the Enter key.\n- By inserting a backslash (`\\`) character before pressing the Enter key, escaping the newline.\n\nThe fish commandline editor works exactly the same in single line mode and in multiline mode. To move between lines use the left and right arrow keys and other such keyboard shortcuts.\n\n### Searchable command history\n\nAfter a command has been executed, it is remembered in the history list. Any duplicate history items are automatically removed. By pressing the up and down keys, you can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.\n\nBy pressing Alt+↑ and Alt+↓, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.\n\nFor more complicated searches, you can press Ctrl+R to open a pager that allows you to search the history. It shows a limited number of entries in one page, press Ctrl+R [\\[3\\]](#id11) again to move to the next page and Ctrl+S [\\[4\\]](#id12) to move to the previous page. You can change the text to refine your search.\n\nHistory searches are case-insensitive unless the search string contains an uppercase character. You can stop a search to edit your search string by pressing Esc or Page Down.\n\nPrefixing the commandline with a space will prevent the entire line from being stored in the history. It will still be available for recall until the next command is executed, but will not be stored on disk. This is to allow you to fix misspellings and such.\n\nThe command history is stored in the file `~/.local/share/fish/fish_history` (or `$XDG_DATA_HOME/fish/fish_history` if that variable is set) by default. However, you can set the `fish_history` environment variable to change the name of the history session (resulting in a `<session>_history` file); both before starting the shell and while the shell is running.\n\nSee the [history](cmds/history) command for other manipulations.\n\nExamples:\n\nTo search for previous entries containing the word ‘make’, type `make` in the console and press the up key.\n\nIf the commandline reads `cd m`, place the cursor over the `m` character and press Alt+↑ to search for previously typed words containing ‘m’.\n\n\\[[3](#id9)\\]\n\nOr another binding that triggers the `history-pager` input function. See [bind](cmds/bind) for a list.\n\n\\[[4](#id10)\\]\n\nOr another binding that triggers the `pager-toggle-search` input function.\n\n## Navigating directories\n\nNavigating directories is usually done with the [cd](cmds/cd) command, but fish offers some advanced features as well.\n\nThe current working directory can be displayed with the [pwd](cmds/pwd) command, or the `$PWD` [special variable](language#variables-special). Usually your prompt already does this.\n\n### Directory history\n\nFish automatically keeps a trail of the recent visited directories with [cd](cmds/cd) by storing this history in the `dirprev` and `dirnext` variables.\n\nSeveral commands are provided to interact with this directory history:\n\n- [dirh](cmds/dirh) prints the history\n- [cdh](cmds/cdh) displays a prompt to quickly navigate the history\n- [prevd](cmds/prevd) moves backward through the history. It is bound to Alt+←\n- [nextd](cmds/nextd) moves forward through the history. It is bound to Alt+→\n\n### Directory stack\n\nAnother set of commands, usually also available in other shells like bash, deal with the directory stack. Stack handling is not automatic and needs explicit calls of the following commands:\n\n- [dirs](cmds/dirs) prints the stack\n- [pushd](cmds/pushd) adds a directory on top of the stack and makes it the current working directory\n- [popd](cmds/popd) removes the directory on top of the stack and changes the current working directory\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/interactive.html](https://fishshell.com/docs/3.7/interactive.html)"
- name: isatty
  summary: isatty tests if a file descriptor is a terminal (as opposed to a file)
  description: "# isatty - test if a file descriptor is a terminal\n\n## Synopsis\n\n```\nisatty [FILE_DESCRIPTOR]\n```\n\n## Description\n\n`isatty` tests if a file descriptor is a terminal (as opposed to a file). The name is derived from the system call of the same name, which for historical reasons refers to a teletypewriter (TTY).\n\n`FILE DESCRIPTOR` may be either the number of a file descriptor, or one of the strings `stdin`, `stdout`, or `stderr`. If not specified, zero is assumed.\n\nIf the specified file descriptor is a terminal device, the exit status of the command is zero. Otherwise, the exit status is non-zero. No messages are printed to standard error.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Examples\n\nFrom an interactive shell, the commands below exit with a return value of zero:\n\n```\nisatty\nisatty stdout\nisatty 2\necho | isatty 1\n```\n\nAnd these will exit non-zero:\n\n```\necho | isatty\nisatty 9\nisatty stdout > file\nisatty 2 2> file\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/isatty.html](https://fishshell.com/docs/3.7/cmds/isatty.html)"
- name: jobs
  summary: jobs prints a list of the currently running jobs and their status
  description: "# jobs - print currently running jobs\n\n## Synopsis\n\n```\njobs [OPTIONS] [PID | %JOBID]\n```\n\n## Description\n\n`jobs` prints a list of the currently running [jobs](../language#syntax-job-control) and their status.\n\n`jobs` accepts the following options:\n\n**-c** or **--command**  \nPrints the command name for each process in jobs.\n\n**-g** or **--group**  \nOnly prints the group ID of each job.\n\n**-l** or **--last**  \nPrints only the last job to be started.\n\n**-p** or **--pid**  \nPrints the process ID for each process in all jobs.\n\n**-q** or **--query**  \nPrints no output for evaluation of jobs by exit status only. For compatibility with old fish versions this is also **--quiet** (but this is deprecated).\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nOn systems that support this feature, jobs will print the CPU usage of each job since the last command was executed. The CPU usage is expressed as a percentage of full CPU activity. Note that on multiprocessor systems, the total activity may be more than 100%.\n\nArguments of the form *PID* or *%JOBID* restrict the output to jobs with the selected process identifiers or job numbers respectively.\n\nIf the output of `jobs` is redirected or if it is part of a command substitution, the column header that is usually printed is omitted, making it easier to parse.\n\nThe exit status of `jobs` is `0` if there are running background jobs and `1` otherwise.\n\n## Example\n\n`jobs` outputs a summary of the current jobs, such as two long-running tasks in this example:\n\n```\nJob Group   State   Command\n2   26012   running nc -l 55232 < /dev/random &\n1   26011   running python tests/test_11.py &\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/jobs.html](https://fishshell.com/docs/3.7/cmds/jobs.html)"
- name: Language
  summary: This document is a comprehensive overview of fish’s scripting language
  description: "# The fish language\n\nThis document is a comprehensive overview of fish’s scripting language.\n\nFor interactive features see [Interactive use](interactive#interactive).\n\n## Syntax overview\n\nShells like fish are used by giving them commands. A command is executed by writing the name of the command followed by any arguments. For example:\n\n```\necho hello world\n```\n\n[echo](cmds/echo) command writes its arguments to the screen. In this example the output is `hello world`.\n\nEverything in fish is done with commands. There are commands for repeating other commands, commands for assigning variables, commands for treating a group of commands as a single command, etc. All of these commands follow the same basic syntax.\n\nEvery program on your computer can be used as a command in fish. If the program file is located in one of the [`PATH`](#envvar-PATH) directories, you can just type the name of the program to use it. Otherwise the whole filename, including the directory (like `/home/me/code/checkers/checkers` or `../checkers`) is required.\n\nHere is a list of some useful commands:\n\n- [cd](cmds/cd): Change the current directory\n- `ls`: List files and directories\n- `man`: Display a manual page - try `man ls` to get help on your “ls” command, or `man mv` to get information about “mv”.\n- `mv`: Move (rename) files\n- `cp`: Copy files\n- [open](cmds/open): Open files with the default application associated with each filetype\n- `less`: Display the contents of files\n\nCommands and arguments are separated by the space character `' '`. Every command ends with either a newline (by pressing the return key) or a semicolon `;`. Multiple commands can be written on the same line by separating them with semicolons.\n\nA switch is a very common special type of argument. Switches almost always start with one or more hyphens `-` and alter the way a command operates. For example, the `ls` command usually lists the names of all files and directories in the current working directory. By using the `-l` switch, the behavior of `ls` is changed to not only display the filename, but also the size, permissions, owner, and modification time of each file.\n\nSwitches differ between commands and are usually documented on a command’s manual page. There are some switches, however, that are common to most commands. For example, `--help` will usually display a help text, `--version` will usually display the command version, and `-i` will often turn on interactive prompting before taking action. Try `man your-command-here` to get information on your command’s switches.\n\nSo the basic idea of fish is the same as with other unix shells: It gets a commandline, runs [expansions](#expand), and the result is then run as a command.\n\n## Terminology\n\nHere we define some of the terms used on this page and throughout the rest of the fish documentation:\n\n- **Argument**: A parameter given to a command. In `echo foo`, the “foo” is an argument.\n- **Builtin**: A command that is implemented by the shell. Builtins are so closely tied to the operation of the shell that it is impossible to implement them as external commands. In `echo foo`, the “echo” is a builtin.\n- **Command**: A program that the shell can run, or more specifically an external program that the shell runs in another process. External commands are provided on your system, as executable files. In `echo foo` the “echo” is a builtin command, in `command echo foo` the “echo” is an external command, provided by a file like /bin/echo.\n- **Function**: A block of commands that can be called as if they were a single command. By using functions, it is possible to string together multiple simple commands into one more advanced command.\n- **Job**: A running pipeline or command.\n- **Pipeline**: A set of commands strung together so that the output of one command is the input of the next command. `echo foo | grep foo` is a pipeline.\n- **Redirection**: An operation that changes one of the input or output streams associated with a job.\n- **Switch** or **Option**: A special kind of argument that alters the behavior of a command. A switch almost always begins with one or two hyphens. In `echo -n foo` the “-n” is an option.\n\n## Quotes\n\nSometimes you want to give a command an argument that contains characters special to fish, like spaces or `$` or `*`. To do that, you can use quotes:\n\n```\nrm \"my file.txt\"\n```\n\nto remove a file called `my file.txt` instead of trying to remove two files, `my` and `file.txt`.\n\nFish understands two kinds of quotes: Single (`'`) and double (`\"`), and both work slightly differently.\n\nBetween single quotes, fish performs no expansions. Between double quotes, fish only performs [variable expansion](#expand-variable) and [command substitution](#expand-command-substitution) in the `$(command)`. No other kind of expansion (including [brace expansion](#expand-brace) or parameter expansion) is performed, and escape sequences (for example, `\\n`) are ignored. Within quotes, whitespace is not used to separate arguments, allowing quoted arguments to contain spaces.\n\nThe only meaningful escape sequences in single quotes are `\\'`, which escapes a single quote and `\\\\`, which escapes the backslash symbol. The only meaningful escapes in double quotes are `\\\"`, which escapes a double quote, `\\$`, which escapes a dollar character, `\\` followed by a newline, which deletes the backslash and the newline, and `\\\\`, which escapes the backslash symbol.\n\nSingle quotes have no special meaning within double quotes and vice versa.\n\nMore examples:\n\n```\ngrep 'enabled)$' foo.txt\n```\n\nsearches for lines ending in `enabled)` in `foo.txt` (the `$` is special to `grep`: it matches the end of the line).\n\n```\napt install \"postgres-*\"\n```\n\ninstalls all packages with a name starting with “postgres-”, instead of looking through the current directory for files named “postgres-something”.\n\n## Escaping Characters\n\nSome characters cannot be written directly on the command line. For these characters, so-called escape sequences are provided. These are:\n\n- `\\a` represents the alert character.\n- `\\e` represents the escape character.\n- `\\f` represents the form feed character.\n- `\\n` represents a newline character.\n- `\\r` represents the carriage return character.\n- `\\t` represents the tab character.\n- `\\v` represents the vertical tab character.\n- `\\xHH` or `\\XHH`, where `HH` is a hexadecimal number, represents a byte of data with the specified value. For example, `\\x9` is the tab character. If you are using a multibyte encoding, this can be used to enter invalid strings. Typically fish is run with the ASCII or UTF-8 encoding, so anything up to `\\X7f` is an ASCII character.\n- `\\ooo`, where `ooo` is an octal number, represents the ASCII character with the specified value. For example, `\\011` is the tab character. The highest allowed value is `\\177`.\n- `\\uXXXX`, where `XXXX` is a hexadecimal number, represents the 16-bit Unicode character with the specified value. For example, `\\u9` is the tab character.\n- `\\UXXXXXXXX`, where `XXXXXXXX` is a hexadecimal number, represents the 32-bit Unicode character with the specified value. For example, `\\U9` is the tab character. The highest allowed value is U10FFFF.\n- `\\cX`, where `X` is a letter of the alphabet, represents the control sequence generated by pressing the control key and the specified letter. For example, `\\ci` is the tab character\n\nSome characters have special meaning to the shell. For example, an apostrophe `'` disables expansion (see [Quotes](#quotes)). To tell the shell to treat these characters literally, escape them with a backslash. For example, the command:\n\n```\necho \\'hello world\\'\n```\n\noutputs `'hello world'` (including the apostrophes), while the command:\n\n```\necho 'hello world'\n```\n\noutputs `hello world` (without the apostrophes). In the former case the shell treats the apostrophes as literal `'` characters, while in the latter case it treats them as special expansion modifiers.\n\nThe special characters and their escape sequences are:\n\n- `\\ ` (backslash space) escapes the space character. This keeps the shell from splitting arguments on the escaped space.\n- `\\$` escapes the dollar character.\n- `\\\\` escapes the backslash character.\n- `\\*` escapes the star character.\n- `\\?` escapes the question mark character (this is not necessary if the `qmark-noglob` [feature flag](#featureflags) is enabled).\n- `\\~` escapes the tilde character.\n- `\\#` escapes the hash character.\n- `\\(` escapes the left parenthesis character.\n- `\\)` escapes the right parenthesis character.\n- `\\{` escapes the left curly bracket character.\n- `\\}` escapes the right curly bracket character.\n- `\\[` escapes the left bracket character.\n- `\\]` escapes the right bracket character.\n- `\\<` escapes the less than character.\n- `\\>` escapes the more than character.\n- `\\&` escapes the ampersand character.\n- `\\|` escapes the vertical bar character.\n- `\\;` escapes the semicolon character.\n- `\\\"` escapes the quote character.\n- `\\'` escapes the apostrophe character.\n\nAs a special case, `\\` immediately followed by a literal new line is a “continuation” and tells fish to ignore the line break and resume input at the start of the next line (without introducing any whitespace or terminating a token).\n\n## Input/Output Redirection\n\nMost programs use three input/output (I/O) streams:\n\n- Standard input (stdin) for reading. Defaults to reading from the keyboard.\n- Standard output (stdout) for writing output. Defaults to writing to the screen.\n- Standard error (stderr) for writing errors and warnings. Defaults to writing to the screen.\n\nEach stream has a number called the file descriptor (FD): 0 for stdin, 1 for stdout, and 2 for stderr.\n\nThe destination of a stream can be changed using something called *redirection*. For example, `echo hello > output.txt`, redirects the standard output of the `echo` command to a text file.\n\n- To read standard input from a file, use `<SOURCE_FILE`.\n- To write standard output to a file, use `>DESTINATION`.\n- To write standard error to a file, use `2>DESTINATION`. [\\[1\\]](#id4)\n- To append standard output to a file, use `>>DESTINATION_FILE`.\n- To append standard error to a file, use `2>>DESTINATION_FILE`.\n- To not overwrite (“clobber”) an existing file, use `>?DESTINATION` or `2>?DESTINATION`. This is known as the “noclobber” redirection.\n\n`DESTINATION` can be one of the following:\n\n- A filename to write the output to. Often `>/dev/null` to silence output by writing it to the special “sinkhole” file.\n- An ampersand (`&`) followed by the number of another file descriptor like `&2` for standard error. The output will be written to the destination descriptor.\n- An ampersand followed by a minus sign (`&-`). The file descriptor will be closed. Note: This may cause the program to fail because its writes will be unsuccessful.\n\nAs a convenience, the redirection `&>` can be used to direct both stdout and stderr to the same destination. For example, `echo hello &> all_output.txt` redirects both stdout and stderr to the file `all_output.txt`. This is equivalent to `echo hello > all_output.txt 2>&1`.\n\nAny arbitrary file descriptor can be used in a redirection by prefixing the redirection with the FD number.\n\n- To redirect the input of descriptor N, use `N<DESTINATION`.\n- To redirect the output of descriptor N, use `N>DESTINATION`.\n- To append the output of descriptor N to a file, use `N>>DESTINATION_FILE`.\n\nFor example:\n\n```\n# Write `foo`'s standard error (file descriptor 2)\n# to a file called \"output.stderr\":\nfoo 2> output.stderr\n\n# if $num doesn't contain a number,\n# this test will be false and print an error,\n# so by ignoring the error we can be sure that we're dealing\n# with a number in the \"if\" block:\nif test \"$num\" -gt 2 2>/dev/null\n    # do things with $num as a number greater than 2\nelse\n    # do things if $num is <= 2 or not a number\nend\n\n# Save `make`s output in a file:\nmake &>/log\n\n# Redirections stack and can be used with blocks:\nbegin\n    echo stdout\n    echo stderr >&2 # <- this goes to stderr!\nend >/dev/null # ignore stdout, so this prints \"stderr\"\n```\n\nIt is an error to redirect a builtin, function, or block to a file descriptor above 2. However this is supported for external commands.\n\n\\[[1](#id3)\\]\n\nPrevious versions of fish also allowed specifying this as `^DESTINATION`, but that made another character special so it was deprecated and removed. See [feature flags](#featureflags).\n\n## Piping\n\nAnother way to redirect streams is a *pipe*. A pipe connects streams with each other. Usually the standard output of one command is connected with the standard input of another. This is done by separating commands with the pipe character `|`. For example:\n\n```\ncat foo.txt | head\n```\n\nThe command `cat foo.txt` sends the contents of `foo.txt` to stdout. This output is provided as input for the `head` program, which prints the first 10 lines of its input.\n\nIt is possible to pipe a different output file descriptor by prepending its FD number and the output redirect symbol to the pipe. For example:\n\n```\nmake fish 2>| less\n```\n\nwill attempt to build `fish`, and any errors will be shown using the `less` pager. [\\[2\\]](#id6)\n\nAs a convenience, the pipe `&|` redirects both stdout and stderr to the same process. This is different from bash, which uses `|&`.\n\n\\[[2](#id5)\\]\n\nA “pager” here is a program that takes output and “paginates” it. `less` doesn’t just do pages, it allows arbitrary scrolling (even back!).\n\n## Combining pipes and redirections\n\nIt is possible to use multiple redirections and a pipe at the same time. In that case, they are read in this order:\n\n1.  First the pipe is set up.\n2.  Then the redirections are evaluated from left-to-right.\n\nThis is important when any redirections reference other file descriptors with the `&N` syntax. When you say `>&2`, that will redirect stdout to where stderr is pointing to *at that time*.\n\nConsider this helper function:\n\n```\n# Just make a function that prints something to stdout and stderr\nfunction print\n    echo out\n    echo err >&2\nend\n```\n\nNow let’s see a few cases:\n\n```\n# Redirect both stderr and stdout to less\n# (can also be spelt as `&|`)\nprint 2>&1 | less\n\n# Show the \"out\" on stderr, silence the \"err\"\nprint >&2 2>/dev/null\n\n# Silence both\nprint >/dev/null 2>&1\n```\n\n## Job control\n\nWhen you start a job in fish, fish itself will pause, and give control of the terminal to the program just started. Sometimes, you want to continue using the commandline, and have the job run in the background. To create a background job, append an `&` (ampersand) to your command. This will tell fish to run the job in the background. Background jobs are very useful when running programs that have a graphical user interface.\n\nExample:\n\n```\nemacs &\n```\n\nwill start the emacs text editor in the background. [fg](cmds/fg) can be used to bring it into the foreground again when needed.\n\nMost programs allow you to suspend the program’s execution and return control to fish by pressing Control+Z (also referred to as `^Z`). Once back at the fish commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the [fg](cmds/fg) (foreground) command.\n\nIf you instead want to put a suspended job into the background, use the [bg](cmds/bg) command.\n\nTo get a listing of all currently started jobs, use the [jobs](cmds/jobs) command. These listed jobs can be removed with the [disown](cmds/disown) command.\n\nAt the moment, functions cannot be started in the background. Functions that are stopped and then restarted in the background using the [bg](cmds/bg) command will not execute correctly.\n\nIf the `&` character is followed by a non-separating character, it is not interpreted as background operator. Separating characters are whitespace and the characters `;<>&|`.\n\n## Functions\n\nFunctions are programs written in the fish syntax. They group together various commands and their arguments using a single name.\n\nFor example, here’s a simple function to list directories:\n\n```\nfunction ll\n    ls -l $argv\nend\n```\n\nThe first line tells fish to define a function by the name of `ll`, so it can be used by simply writing `ll` on the commandline. The second line tells fish that the command `ls -l $argv` should be called when `ll` is invoked. [\\$argv](#variables-argv) is a [list variable](#variables-lists), which always contains all arguments sent to the function. In the example above, these are simply passed on to the `ls` command. The `end` on the third line ends the definition.\n\nCalling this as `ll /tmp/` will end up running `ls -l /tmp/`, which will list the contents of /tmp.\n\nThis is a kind of function known as an [alias](#syntax-aliases).\n\nFish’s prompt is also defined in a function, called [fish_prompt](cmds/fish_prompt). It is run when the prompt is about to be displayed and its output forms the prompt:\n\n```\nfunction fish_prompt\n    # A simple prompt. Displays the current directory\n    # (which fish stores in the $PWD variable)\n    # and then a user symbol - a '►' for a normal user and a '#' for root.\n    set -l user_char '►'\n    if fish_is_root_user\n        set user_char '#'\n    end\n\n    echo (set_color yellow)$PWD (set_color purple)$user_char\nend\n```\n\nTo edit a function, you can use [funced](cmds/funced), and to save a function [funcsave](cmds/funcsave). This will store it in a function file that fish will [autoload](#syntax-function-autoloading) when needed.\n\nThe [functions](cmds/functions) builtin can show a function’s current definition (and [type](cmds/type) will also do if given a function).\n\nFor more information on functions, see the documentation for the [function](cmds/function) builtin.\n\n### Defining aliases\n\nOne of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the `ls` command to display colors. The switch for turning on colors on GNU systems is `--color=auto`. An alias around `ls` might look like this:\n\n```\nfunction ls\n    command ls --color=auto $argv\nend\n```\n\nThere are a few important things that need to be noted about aliases:\n\n- Always take care to add the [\\$argv](#variables-argv) variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.\n- If the alias has the same name as the aliased command, you need to prefix the call to the program with `command` to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).\n\nTo easily create a function of this form, you can use the [alias](cmds/alias) command. Unlike other shells, this just makes functions - fish has no separate concept of an “alias”, we just use the word for a simple wrapping function like this. [alias](cmds/alias) immediately creates a function. Consider using `alias --save` or [funcsave](cmds/funcsave) to save the created function into an autoload file instead of recreating the alias each time.\n\nFor an alternative, try [abbreviations](interactive#abbreviations). These are words that are expanded while you type, instead of being actual functions inside the shell.\n\n### Autoloading functions\n\nFunctions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:\n\n- An autoloaded function becomes available automatically to all running shells.\n- If the function definition is changed, all running shells will automatically reload the altered version, after a while.\n- Startup time and memory usage is improved, etc.\n\nWhen fish needs to load a function, it searches through any directories in the [list variable](#variables-lists) `$fish_function_path` for a file with a name consisting of the name of the function plus the suffix `.fish` and loads the first it finds.\n\nFor example if you try to execute something called `banana`, fish will go through all directories in \\$fish_function_path looking for a file called `banana.fish` and load the first one it finds.\n\nBy default `$fish_function_path` contains the following:\n\n- A directory for users to keep their own functions, usually `~/.config/fish/functions` (controlled by the `XDG_CONFIG_HOME` environment variable).\n- A directory for functions for all users on the system, usually `/etc/fish/functions` (really `$__fish_sysconfdir/functions`).\n- Directories for other software to put their own functions. These are in the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable) and in the `XDG_DATA_DIRS` environment variable, in a subdirectory called `fish/vendor_functions.d`. The default value for `XDG_DATA_DIRS` is usually `/usr/share/fish/vendor_functions.d` and `/usr/local/share/fish/vendor_functions.d`.\n- The functions shipped with fish, usually installed in `/usr/share/fish/functions` (really `$__fish_data_dir/functions`).\n\nIf you are unsure, your functions probably belong in `~/.config/fish/functions`.\n\nAs we’ve explained, autoload files are loaded *by name*, so, while you can put multiple functions into one file, the file will only be loaded automatically once you try to execute the one that shares the name.\n\nAutoloading also won’t work for [event handlers](#event), since fish cannot know that a function is supposed to be executed when an event occurs when it hasn’t yet loaded the function. See the [event handlers](#event) section for more information.\n\nIf a file of the right name doesn’t define the function, fish will not read other autoload files, instead it will go on to try builtins and finally commands. This allows masking a function defined later in \\$fish_function_path, e.g. if your administrator has put something into /etc/fish/functions that you want to skip.\n\nIf you are developing another program and want to install fish functions for it, install them to the “vendor” functions directory. As this path varies from system to system, you can use `pkgconfig` to discover it with the output of `pkg-config --variable functionsdir fish`. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.\n\n## Comments\n\nAnything after a `#` until the end of the line is a comment. That means it’s purely for the reader’s benefit, fish ignores it.\n\nThis is useful to explain what and why you are doing something:\n\n```\nfunction ls\n    # The function is called ls,\n    # so we have to explicitly call `command ls` to avoid calling ourselves.\n    command ls --color=auto $argv\nend\n```\n\nThere are no multiline comments. If you want to make a comment span multiple lines, simply start each line with a `#`.\n\nComments can also appear after a line like so:\n\n```\nset -gx EDITOR emacs # I don't like vim.\n```\n\n## Conditions\n\nFish has some builtins that let you execute commands only if a specific criterion is met: [if](cmds/if), [switch](cmds/switch), [and](cmds/and) and [or](cmds/or), and also the familiar [&&/\\|\\|](#syntax-combiners) syntax.\n\n### The `if` statement\n\nThe [if](cmds/if) statement runs a block of commands if the condition was true.\n\nLike other shells, but unlike typical programming languages you might know, the condition here is a *command*. Fish runs it, and if it returns a true [exit status](#variables-status) (that’s 0), the if-block is run. For example:\n\n```\nif test -e /etc/os-release\n    cat /etc/os-release\nend\n```\n\nThis uses the [test](cmds/test) command to see if the file /etc/os-release exists. If it does, it runs `cat`, which prints it on the screen.\n\nUnlike other shells, the condition command just ends after the first job, there is no `then` here. Combiners like `and` and `or` extend the condition.\n\n`if` is commonly used with the [test](cmds/test) command that can check conditions.:\n\n```\nif test 5 -gt 2\n    echo \"Yes, 5 is greater than 2\"\nend\n```\n\n`if` can also take `else if` clauses with additional conditions and an [else](cmds/else) clause that is executed when everything else was false:\n\n```\nif test \"$number\" -gt 10\n   echo Your number was greater than 10\nelse if test \"$number\" -gt 5\n   echo Your number was greater than 5\nelse if test \"$number\" -gt 1\n   echo Your number was greater than 1\nelse\n   echo Your number was smaller or equal to 1\nend\n```\n\nThe [not](cmds/not) keyword can be used to invert the status:\n\n```\n# Just see if the file contains the string \"fish\" anywhere.\n# This executes the `grep` command, which searches for a string,\n# and if it finds it returns a status of 0.\n# The `not` then turns 0 into 1 or anything else into 0.\n# The `-q` switch stops it from printing any matches.\nif not grep -q fish myanimals\n    echo \"You don't have fish!\"\nelse\n    echo \"You have fish!\"\nend\n```\n\n### The `switch` statement\n\nThe [switch](cmds/switch) command is used to execute one of possibly many blocks of commands depending on the value of a string. It can take multiple [case](cmds/case) blocks that are executed when the string matches. They can take [wildcards](#expand-wildcard). For example:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase DragonFly '*BSD'\n    echo Hi Beastie! # this also works for FreeBSD and NetBSD\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nUnlike other shells or programming languages, there is no fallthrough - the first matching `case` block is executed and then control jumps out of the `switch`.\n\n### Combiners (`and` / `or` / `&&` / `||`)\n\nFor simple checks, you can use combiners. [and](cmds/and) or `&&` run the second command if the first succeeded, while [or](cmds/or) or `||` run it if the first failed. For example:\n\n```\n# $XDG_CONFIG_HOME is a standard place to store configuration.\n# If it's not set applications should use ~/.config.\nset -q XDG_CONFIG_HOME; and set -l configdir $XDG_CONFIG_HOME\nor set -l configdir ~/.config\n```\n\nNote that combiners are *lazy* - only the part that is necessary to determine the final status is run.\n\nCompare:\n\n```\nif sleep 2; and false\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nand:\n\n```\nif false; and sleep 2\n    echo 'How did I get here? This should be impossible'\nend\n```\n\nThese do essentially the same thing, but the former takes 2 seconds longer because the `sleep` always needs to run.\n\nOr you can have a case where it is necessary to stop early:\n\n```\nif command -sq foo; and foo\n```\n\nIf this went on after seeing that the command “foo” doesn’t exist, it would try to run `foo` and error because it wasn’t found!\n\nCombiners really just execute step-by-step, so it isn’t recommended to build longer chains of them because they might do something you don’t want. Consider:\n\n```\ntest -e /etc/my.config\nor echo \"OH NO WE NEED A CONFIG FILE\"\nand return 1\n```\n\nThis will execute `return 1` also if the `test` succeeded. This is because fish runs `test -e /etc/my.config`, sets \\$status to 0, then skips the `echo`, keeps \\$status at 0, and then executes the `return 1` because \\$status is still 0.\n\nSo if you have more complex conditions or want to run multiple things after something failed, consider using an [if](#syntax-if). Here that would be:\n\n```\nif not test -e /etc/my.config\n    echo \"OH NO WE NEED A CONFIG FILE\"\n    return 1\nend\n```\n\n## Loops and blocks\n\nLike most programming language, fish also has the familiar [while](cmds/while) and [for](cmds/for) loops.\n\n`while` works like a repeated [if](cmds/if):\n\n```\nwhile true\n    echo Still running\n    sleep 1\nend\n```\n\nwill print “Still running” once a second. You can abort it with ctrl-c.\n\n`for` loops work like in other shells, which is more like python’s for-loops than e.g. C’s:\n\n```\nfor file in *\n    echo file: $file\nend\n```\n\nwill print each file in the current directory. The part after the `in` is just a list of arguments, so you can use any [expansions](#expand) there:\n\n```\nset moreanimals bird fox\nfor animal in {cat,}fish dog $moreanimals\n   echo I like the $animal\nend\n```\n\nIf you need a list of numbers, you can use the `seq` command to create one:\n\n```\nfor i in (seq 1 5)\n    echo $i\nend\n```\n\n[break](cmds/break) is available to break out of a loop, and [continue](cmds/continue) to jump to the next iteration.\n\n[Input and output redirections](#redirects) (including [pipes](#pipes)) can also be applied to loops:\n\n```\nwhile read -l line\n    echo line: $line\nend < file\n```\n\nIn addition there’s a [begin](cmds/begin) block that just groups commands together so you can redirect to a block or use a new [variable scope](#variables-scope) without any repetition:\n\n```\nbegin\n   set -l foo bar # this variable will only be available in this block!\nend\n```\n\n## Parameter expansion\n\nWhen fish is given a commandline, it expands the parameters before sending them to the command. There are multiple different kinds of expansions:\n\n- [Wildcards](#expand-wildcard), to create filenames from patterns - `*.jpg`\n- [Variable expansion](#expand-variable), to use the value of a variable - `$HOME`\n- [Command substitution](#expand-command-substitution), to use the output of another command - `$(cat /path/to/file)`\n- [Brace expansion](#expand-brace), to write lists with common pre- or suffixes in a shorter way `{/usr,}/bin`\n- [Tilde expansion](#expand-home), to turn the `~` at the beginning of paths into the path to the home directory `~/bin`\n\nParameter expansion is limited to 524288 items. There is a limit to how many arguments the operating system allows for any command, and 524288 is far above it. This is a measure to stop the shell from hanging doing useless computation.\n\n### Wildcards (“Globbing”)\n\nWhen a parameter includes an [unquoted](#quotes) `*` star (or “asterisk”) or a `?` question mark, fish uses it as a wildcard to match files.\n\n- `*` matches any number of characters (including zero) in a file name, not including `/`.\n- `**` matches any number of characters (including zero), and also descends into subdirectories. If `**` is a segment by itself, that segment may match zero times, for compatibility with other shells.\n- `?` can match any single character except `/`. This is deprecated and can be disabled via the `qmark-noglob` [feature flag](#featureflags), so `?` will just be an ordinary character.\n\nWildcard matches are sorted case insensitively. When sorting matches containing numbers, they are naturally sorted, so that the strings ‘1’ ‘5’ and ‘12’ would be sorted like 1, 5, 12.\n\nHidden files (where the name begins with a dot) are not considered when wildcarding unless the wildcard string has a dot in that place.\n\nExamples:\n\n- `a*` matches any files beginning with an ‘a’ in the current directory.\n- `**` matches any files and directories in the current directory and all of its subdirectories.\n- `~/.*` matches all hidden files (also known as “dotfiles”) and directories in your home directory.\n\nFor most commands, if any wildcard fails to expand, the command is not executed, [\\$status](#variables-status) is set to nonzero, and a warning is printed. This behavior is like what bash does with `shopt -s failglob`. There are exceptions, namely [set](cmds/set) and [path](cmds/path), overriding variables in [overrides](#variables-override), [count](cmds/count) and [for](cmds/for). Their globs will instead expand to zero arguments (so the command won’t see them at all), like with `shopt -s nullglob` in bash.\n\nExamples:\n\n```\n# List the .foo files, or warns if there aren't any.\nls *.foo\n\n# List the .foo files, if any.\nset foos *.foo\nif count $foos >/dev/null\n    ls $foos\nend\n```\n\nUnlike bash (by default), fish will not pass on the literal glob character if no match was found, so for a command like `apt install` that does the matching itself, you need to add quotes:\n\n```\napt install \"ncurses-*\"\n```\n\n### Variable expansion\n\nOne of the most important expansions in fish is the “variable expansion”. This is the replacing of a dollar sign (`$`) followed by a variable name with the \\_value\\_ of that variable.\n\nIn the simplest case, this is just something like:\n\n```\necho $HOME\n```\n\nwhich will replace `$HOME` with the home directory of the current user, and pass it to [echo](cmds/echo), which will then print it.\n\nSome variables like `$HOME` are already set because fish sets them by default or because fish’s parent process passed them to fish when it started it. You can define your own variables by setting them with [set](cmds/set):\n\n```\nset my_directory /home/cooluser/mystuff\nls $my_directory\n# shows the contents of /home/cooluser/mystuff\n```\n\nFor more on how setting variables works, see [Shell variables](#variables) and the following sections.\n\nSometimes a variable has no value because it is undefined or empty, and it expands to nothing:\n\n```\necho $nonexistentvariable\n# Prints no output.\n```\n\nTo separate a variable name from text you can encase the variable within double-quotes or braces:\n\n```\nset WORD cat\necho The plural of $WORD is \"$WORD\"s\n# Prints \"The plural of cat is cats\" because $WORD is set to \"cat\".\necho The plural of $WORD is {$WORD}s\n# ditto\n```\n\nWithout the quotes or braces, fish will try to expand a variable called `$WORDs`, which may not exist.\n\nThe latter syntax `{$WORD}` is a special case of [brace expansion](#expand-brace).\n\nIf \\$WORD here is undefined or an empty list, the “s” is not printed. However, it is printed if \\$WORD is the empty string (like after `set WORD \"\"`).\n\nFor more on shell variables, read the [Shell variables](#variables) section.\n\n#### Quoting variables\n\nUnlike all the other expansions, variable expansion also happens in double quoted strings. Inside double quotes (`\"these\"`), variables will always expand to exactly one argument. If they are empty or undefined, it will result in an empty string. If they have one element, they’ll expand to that element. If they have more than that, the elements will be joined with spaces, unless the variable is a [path variable](#variables-path) - in that case it will use a colon (`:`) instead [\\[3\\]](#id8).\n\nOutside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.\n\nIf a variable expands to nothing, it will cancel out any other strings attached to it. See the [cartesian product](#cartesian-product) section for more information.\n\nUnlike other shells, fish doesn’t do what is known as “Word Splitting”. Once a variable is set to a particular set of elements, those elements expand as themselves. They aren’t split on spaces or newlines or anything:\n\n```\n> set foo one\\nthing\n> echo $foo\none\nthing\n> printf '|%s|\\n' $foo\n|one\nthing|\n```\n\nThat means quoting isn’t the absolute necessity it is in other shells. Most of the time, not quoting a variable is correct. The exception is when you need to ensure that the variable is passed as one element, even if it might be unset or have multiple elements. This happens often with [test](cmds/test):\n\n```\nset -l foo one two three\ntest -n $foo\n# prints an error that it got too many arguments, because it was executed like\ntest -n one two three\n\ntest -n \"$foo\"\n# works, because it was executed like\ntest -n \"one two three\"\n```\n\n\\[[3](#id7)\\]\n\nUnlike bash or zsh, which will join with the first character of \\$IFS (which usually is space).\n\n#### Dereferencing variables\n\nThe `$` symbol can also be used multiple times, as a kind of “dereference” operator (the `*` in C or C++), like in the following code:\n\n```\nset foo a b c\nset a 10; set b 20; set c 30\nfor i in (seq (count $$foo))\n    echo $$foo[$i]\nend\n\n# Output is:\n# 10\n# 20\n# 30\n```\n\n`$$foo[$i]` is “the value of the variable named by `$foo[$i]`.\n\nWhen using this feature together with list brackets, the brackets will be used from the inside out. `$$foo[5]` will use the fifth element of `$foo` as a variable name, instead of giving the fifth element of all the variables \\$foo refers to. That would instead be expressed as `$$foo[1..-1][5]` (take all elements of `$foo`, use them as variable names, then give the fifth element of those).\n\n### Command substitution\n\nA `command substitution` is an expansion that uses the *output* of a command as the arguments to another. For example:\n\n```\necho (pwd)\n```\n\nThis executes the [pwd](cmds/pwd) command, takes its output (more specifically what it wrote to the standard output “stdout” stream) and uses it as arguments to [echo](cmds/echo). So the inner command (the `pwd`) is run first and has to complete before the outer command can even be started.\n\nIf the inner command prints multiple lines, fish will use each separate line as a separate argument to the outer command. Unlike other shells, the value of `$IFS` is not used [\\[4\\]](#id10), fish splits on newlines.\n\nA command substitution can also be spelled with a dollar sign like `outercommand $(innercommand)`. This variant is also allowed inside double quotes. When using double quotes, the command output is not split up by lines, but trailing empty lines are still removed.\n\nIf the output is piped to [string split or string split0](cmds/string-split) as the last step, those splits are used as they appear instead of splitting lines.\n\nThe exit status of the last run command substitution is available in the [status](#variables-status) variable if the substitution happens in the context of a [set](cmds/set) command (so `if set -l (something)` checks if `something` returned true).\n\nTo use only some lines of the output, refer to [slices](#expand-slices).\n\nExamples:\n\n```\n# Outputs 'image.png'.\necho (basename image.jpg .jpg).png\n\n# Convert all JPEG files in the current directory to the\n# PNG format using the 'convert' program.\nfor i in *.jpg; convert $i (basename $i .jpg).png; end\n\n# Set the ``data`` variable to the contents of 'data.txt'\n# without splitting it into a list.\nset data \"$(cat data.txt)\"\n\n# Set ``$data`` to the contents of data, splitting on NUL-bytes.\nset data (cat data | string split0)\n```\n\nSometimes you want to pass the output of a command to another command that only accepts files. If it’s just one file, you can usually just pass it via a pipe, like:\n\n```\ngrep fish myanimallist1 | wc -l\n```\n\nbut if you need multiple or the command doesn’t read from standard input, “process substitution” is useful. Other shells allow this via `foo <(bar) <(baz)`, and fish uses the [psub](cmds/psub) command:\n\n```\n# Compare just the lines containing \"fish\" in two files:\ndiff -u (grep fish myanimallist1 | psub) (grep fish myanimallist2 | psub)\n```\n\nThis creates a temporary file, stores the output of the command in that file and prints the filename, so it is given to the outer command.\n\nFish has a default limit of 100 MiB on the data it will read in a command sustitution. If that limit is reached the command (all of it, not just the command substitution - the outer command won’t be executed at all) fails and `$status` is set to 122. This is so command substitutions can’t cause the system to go out of memory, because typically your operating system has a much lower limit, so reading more than that would be useless and harmful. This limit can be adjusted with the `fish_read_limit` variable (`0` meaning no limit). This limit also affects the [read](cmds/read) command.\n\n\\[[4](#id9)\\]\n\nOne exception: Setting `$IFS` to empty will disable line splitting. This is deprecated, use [string split](cmds/string-split) instead.\n\n### Brace expansion\n\nCurly braces can be used to write comma-separated lists. They will be expanded with each element becoming a new parameter, with the surrounding string attached. This is useful to save on typing, and to separate a variable name from surrounding text.\n\nExamples:\n\n```\n> echo input.{c,h,txt}\ninput.c input.h input.txt\n\n# Move all files with the suffix '.c' or '.h' to the subdirectory src.\n> mv *.{c,h} src/\n\n# Make a copy of `file` at `file.bak`.\n> cp file{,.bak}\n\n> set -l dogs hot cool cute \"good \"\n> echo {$dogs}dog\nhotdog cooldog cutedog good dog\n```\n\nIf there is no “,” or variable expansion between the curly braces, they will not be expanded:\n\n```\n# This {} isn't special\n> echo foo-{}\nfoo-{}\n# This passes \"HEAD@{2}\" to git\n> git reset --hard HEAD@{2}\n> echo {{a,b}}\n{a} {b} # because the inner brace pair is expanded, but the outer isn't.\n```\n\nIf after expansion there is nothing between the braces, the argument will be removed (see [the cartesian product section](#cartesian-product)):\n\n```\n> echo foo-{$undefinedvar}\n# Output is an empty line, just like a bare `echo`.\n```\n\nIf there is nothing between a brace and a comma or two commas, it’s interpreted as an empty element:\n\n```\n> echo {,,/usr}/bin\n/bin /bin /usr/bin\n```\n\nTo use a “,” as an element, [quote](#quotes) or [escape](#escapes) it.\n\n### Combining lists (Cartesian Product)\n\nWhen lists are expanded with other parts attached, they are expanded with these parts still attached. Even if two lists are attached to each other, they are expanded in all combinations. This is referred to as the “cartesian product” (like in mathematics), and works basically like [brace expansion](#expand-brace).\n\nExamples:\n\n```\n# Brace expansion is the most familiar:\n# All elements in the brace combine with the parts outside of the braces\n>_ echo {good,bad}\" apples\"\ngood apples bad apples\n\n# The same thing happens with variable expansion.\n>_ set -l a x y z\n>_ set -l b 1 2 3\n\n# $a is {x,y,z}, $b is {1,2,3},\n# so this is `echo {x,y,z}{1,2,3}`\n>_ echo $a$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# Same thing if something is between the lists\n>_ echo $a\"-\"$b\nx-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3\n\n# Or a brace expansion and a variable\n>_ echo {x,y,z}$b\nx1 y1 z1 x2 y2 z2 x3 y3 z3\n\n# A combined brace-variable expansion\n>_ echo {$b}word\n1word 2word 3word\n\n# Special case: If $c has no elements, this expands to nothing\n>_ echo {$c}word\n# Output is an empty line\n```\n\nSometimes this may be unwanted, especially that tokens can disappear after expansion. In those cases, you should double-quote variables - `echo \"$c\"word`.\n\nThis also happens after [command substitution](#expand-command-substitution). To avoid tokens disappearing there, make the inner command return a trailing newline, or store the output in a variable and double-quote it.\n\nE.g.\n\n```\n>_ set b 1 2 3\n>_ echo (echo x)$b\nx1 x2 x3\n>_ echo (printf '%s' '')banana\n# the printf prints nothing, so this is nothing times \"banana\",\n# which is nothing.\n>_ echo (printf '%s\\n' '')banana\n# the printf prints a newline,\n# so the command substitution expands to an empty string,\n# so this is `''banana`\nbanana\n```\n\nThis can be quite useful. For example, if you want to go through all the files in all the directories in [`PATH`](#envvar-PATH), use\n\n```\nfor file in $PATH/*\n```\n\nBecause [`PATH`](#envvar-PATH) is a list, this expands to all the files in all the directories in it. And if there are no directories in [`PATH`](#envvar-PATH), the right answer here is to expand to no files.\n\n### Slices\n\nSometimes it’s necessary to access only some of the elements of a [list](#variables-lists) (all fish variables are lists), or some of the lines a [command substitution](#expand-command-substitution) outputs. Both are possible in fish by writing a set of indices in brackets, like:\n\n```\n# Make $var a list of four elements\nset var one two three four\n# Print the second:\necho $var[2]\n# prints \"two\"\n# or print the first three:\necho $var[1..3]\n# prints \"one two three\"\n```\n\nIn index brackets, fish understands ranges written like `a..b` (‘a’ and ‘b’ being indices). They are expanded into a sequence of indices from a to b (so `a a+1 a+2 ... b`), going up if b is larger and going down if a is larger. Negative indices can also be used - they are taken from the end of the list, so `-1` is the last element, and `-2` the one before it. If an index doesn’t exist the range is clamped to the next possible index.\n\nIf a list has 5 elements the indices go from 1 to 5, so a range of `2..16` will only go from element 2 to element 5.\n\nIf the end is negative the range always goes up, so `2..-2` will go from element 2 to 4, and `2..-16` won’t go anywhere because there is no way to go from the second element to one that doesn’t exist, while going up. If the start is negative the range always goes down, so `-2..1` will go from element 4 to 1, and `-16..2` won’t go anywhere because there is no way to go from an element that doesn’t exist to the second element, while going down.\n\nA missing starting index in a range defaults to 1. This is allowed if the range is the first index expression of the sequence. Similarly, a missing ending index, defaulting to -1 is allowed for the last index in the sequence.\n\nMultiple ranges are also possible, separated with a space.\n\nSome examples:\n\n```\necho (seq 10)[1 2 3]\n# Prints: 1 2 3\n\n# Limit the command substitution output\necho (seq 10)[2..5]\n# Uses elements from 2 to 5\n# Output is: 2 3 4 5\n\necho (seq 10)[7..]\n# Prints: 7 8 9 10\n\n# Use overlapping ranges:\necho (seq 10)[2..5 1..3]\n# Takes elements from 2 to 5 and then elements from 1 to 3\n# Output is: 2 3 4 5 1 2 3\n\n# Reverse output\necho (seq 10)[-1..1]\n# Uses elements from the last output line to\n# the first one in reverse direction\n# Output is: 10 9 8 7 6 5 4 3 2 1\n\n# The command substitution has only one line,\n# so these will result in empty output:\necho (echo one)[2..-1]\necho (echo one)[-3..1]\n```\n\nThe same works when setting or expanding variables:\n\n```\n# Reverse path variable\nset PATH $PATH[-1..1]\n# or\nset PATH[-1..1] $PATH\n\n# Use only n last items of the PATH\nset n -3\necho $PATH[$n..-1]\n```\n\nVariables can be used as indices for expansion of variables, like so:\n\n```\nset index 2\nset letters a b c d\necho $letters[$index] # returns 'b'\n```\n\nHowever using variables as indices for command substitution is currently not supported, so:\n\n```\necho (seq 5)[$index] # This won't work\n\nset sequence (seq 5) # It needs to be written on two lines like this.\necho $sequence[$index] # returns '2'\n```\n\nWhen using indirect variable expansion with multiple `$` (`$$name`), you have to give all indices up to the variable you want to slice:\n\n```\n> set -l list 1 2 3 4 5\n> set -l name list\n> echo $$name[1]\n1 2 3 4 5\n> echo $$name[1..-1][1..3] # or $$name[1][1..3], since $name only has one element.\n1 2 3\n```\n\n### Home directory expansion\n\nThe `~` (tilde) character at the beginning of a parameter, followed by a username, is expanded into the home directory of the specified user. A lone `~`, or a `~` followed by a slash, is expanded into the home directory of the process owner:\n\n```\nls ~/Music # lists my music directory\n\necho ~root # prints root's home directory, probably \"/root\"\n```\n\n### Combining different expansions\n\nAll of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.\n\nWhen combining multiple parameter expansions, expansions are performed in the following order:\n\n- Command substitutions\n- Variable expansions\n- Bracket expansion\n- Wildcard expansion\n\nExpansions are performed from right to left, nested bracket expansions are performed from the inside and out.\n\nExample:\n\nIf the current directory contains the files ‘foo’ and ‘bar’, the command `echo a(ls){1,2,3}` will output `abar1 abar2 abar3 afoo1 afoo2 afoo3`.\n\n## Shell variables\n\nVariables are a way to save data and pass it around. They can be used just by the shell, or they can be “[exported](#variables-export)”, so that a copy of the variable is available to any external command the shell starts. An exported variable is referred to as an “environment variable”.\n\nTo set a variable value, use the [set](cmds/set) command. A variable name can not be empty and can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n\nExample:\n\nTo set the variable `smurf_color` to the value `blue`, use the command `set smurf_color blue`.\n\nAfter a variable has been set, you can use the value of a variable in the shell through [variable expansion](#expand-variable).\n\nExample:\n\n```\nset smurf_color blue\necho Smurfs are usually $smurf_color\nset pants_color red\necho Papa smurf, who is $smurf_color, wears $pants_color pants\n```\n\nSo you set a variable with `set`, and use it with a `$` and the name.\n\n### Variable Scope\n\nThere are four kinds of variables in fish: universal, global, function and local variables.\n\n- Universal variables are shared between all fish sessions a user is running on one computer. They are stored on disk and persist even after reboot.\n- Global variables are specific to the current fish session. They can be erased by explicitly requesting `set -e`.\n- Function variables are specific to the currently executing function. They are erased (“go out of scope”) when the current function ends. Outside of a function, they don’t go out of scope.\n- Local variables are specific to the current block of commands, and automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands `for`, `while` , `if`, `function`, `begin` or `switch`, and ends with the command `end`. Outside of a block, this is the same as the function scope.\n\nVariables can be explicitly set to be universal with the `-U` or `--universal` switch, global with `-g` or `--global`, function-scoped with `-f` or `--function` and local to the current block with `-l` or `--local`. The scoping rules when creating or updating a variable are:\n\n- When a scope is explicitly given, it will be used. If a variable of the same name exists in a different scope, that variable will not be changed.\n- When no scope is given, but a variable of that name exists, the variable of the smallest scope will be modified. The scope will not be changed.\n- When no scope is given and no variable of that name exists, the variable is created in function scope if inside a function, or global scope if no function is executing.\n\nThere can be many variables with the same name, but different scopes. When you [use a variable](#expand-variable), the smallest scoped variable of that name will be used. If a local variable exists, it will be used instead of the global or universal variable of the same name.\n\nExample:\n\nThere are a few possible uses for different scopes.\n\nTypically inside functions you should use local scope:\n\n```\nfunction something\n    set -l file /path/to/my/file\n    if not test -e \"$file\"\n        set file /path/to/my/otherfile\n    end\nend\n\n# or\n\nfunction something\n    if test -e /path/to/my/file\n        set -f file /path/to/my/file\n    else\n        set -f file /path/to/my/otherfile\n    end\nend\n```\n\nIf you want to set something in config.fish, or set something in a function and have it available for the rest of the session, global scope is a good choice:\n\n```\n# Don't shorten the working directory in the prompt\nset -g fish_prompt_pwd_dir_length 0\n\n# Set my preferred cursor style:\nfunction setcursors\n   set -g fish_cursor_default block\n   set -g fish_cursor_insert line\n   set -g fish_cursor_visual underscore\nend\n\n# Set my language\nset -gx LANG de_DE.UTF-8\n```\n\nIf you want to set some personal customization, universal variables are nice:\n\n```\n# Typically you'd run this interactively, fish takes care of keeping it.\nset -U fish_color_autosuggestion 555\n```\n\nHere is an example of local vs function-scoped variables:\n\n```\nfunction test-scopes\n    begin\n        # This is a nice local scope where all variables will die\n        set -l pirate 'There be treasure in them thar hills'\n        set -f captain Space, the final frontier\n        # If no variable of that name was defined, it is function-local.\n        set gnu \"In the beginning there was nothing, which exploded\"\n    end\n\n    echo $pirate\n    # This will not output anything, since the pirate was local\n    echo $captain\n    # This will output the good Captain's speech since $captain had function-scope.\n    echo $gnu\n    # Will output Sir Terry's wisdom.\nend\n```\n\nWhen a function calls another, local variables aren’t visible:\n\n```\nfunction shiver\n    set phrase 'Shiver me timbers'\nend\n\nfunction avast\n    set --local phrase 'Avast, mateys'\n    # Calling the shiver function here can not\n    # change any variables in the local scope\n    # so phrase remains as we set it here.\n    shiver\n    echo $phrase\nend\navast\n\n# Outputs \"Avast, mateys\"\n```\n\nWhen in doubt, use function-scoped variables. When you need to make a variable accessible everywhere, make it global. When you need to persistently store configuration, make it universal. When you want to use a variable only in a short block, make it local.\n\n### Overriding variables for a single command\n\nIf you want to override a variable for a single command, you can use “var=val” statements before the command:\n\n```\n# Call git status on another directory\n# (can also be done via `git -C somerepo status`)\nGIT_DIR=somerepo git status\n```\n\nUnlike other shells, fish will first set the variable and then perform other expansions on the line, so:\n\n```\nset foo banana\nfoo=gagaga echo $foo # prints gagaga, while in other shells it might print \"banana\"\n```\n\nMultiple elements can be given in a [brace expansion](#expand-brace):\n\n```\n# Call bash with a reasonable default path.\nPATH={/usr,}/{s,}bin bash\n```\n\nOr with a [glob](#expand-wildcard):\n\n```\n# Run vlc on all mp3 files in the current directory\n# If no file exists it will still be run with no arguments\nmp3s=*.mp3 vlc $mp3s\n```\n\nUnlike other shells, this does *not* inhibit any lookup (aliases or similar). Calling a command after setting a variable override will result in the exact same command being run.\n\nThis syntax is supported since fish 3.1.\n\n### Universal Variables\n\nUniversal variables are variables that are shared between all the user’s fish sessions on the computer. Fish stores many of its configuration options as universal variables. This means that in order to change fish settings, all you have to do is change the variable value once, and it will be automatically updated for all sessions, and preserved across computer reboots and login/logout.\n\nTo see universal variables in action, start two fish sessions side by side, and issue the following command in one of them `set fish_color_cwd blue`. Since `fish_color_cwd` is a universal variable, the color of the current working directory listing in the prompt will instantly change to blue on both terminals.\n\n[Universal variables](#variables-universal) are stored in the file `.config/fish/fish_variables`. Do not edit this file directly, as your edits may be overwritten. Edit the variables through fish scripts or by using fish interactively instead.\n\nDo not append to universal variables in [config.fish](#configuration), because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.\n\n### Exporting variables\n\nVariables in fish can be exported, so they will be inherited by any commands started by fish. In particular, this is necessary for variables used to configure external commands like `PAGER` or `GOPATH`, but also for variables that contain general system settings like `PATH` or `LANGUAGE`. If an external command needs to know a variable, it needs to be exported. Exported variables are also often called “environment variables”.\n\nThis also applies to fish - when it starts up, it receives environment variables from its parent (usually the terminal). These typically include system configuration like [`PATH`](#envvar-PATH) and [locale variables](#variables-locale).\n\nVariables can be explicitly set to be exported with the `-x` or `--export` switch, or not exported with the `-u` or `--unexport` switch. The exporting rules when setting a variable are similar to the scoping rules for variables - when an option is passed it is respected, otherwise the variable’s existing state is used. If no option is passed and the variable didn’t exist yet it is not exported.\n\nAs a naming convention, exported variables are in uppercase and unexported variables are in lowercase.\n\nFor example:\n\n```\nset -gx ANDROID_HOME ~/.android # /opt/android-sdk\nset -gx CDPATH . ~ (test -e ~/Videos; and echo ~/Videos)\nset -gx EDITOR emacs -nw\nset -gx GOPATH ~/dev/go\nset -gx GTK2_RC_FILES \"$XDG_CONFIG_HOME/gtk-2.0/gtkrc\"\nset -gx LESSHISTFILE \"-\"\n```\n\nNote: Exporting is not a [scope](#variables-scope), but an additional state. It typically makes sense to make exported variables global as well, but local-exported variables can be useful if you need something more specific than [Overrides](#variables-override). They are *copied* to functions so the function can’t alter them outside, and still available to commands. Global variables are accessible to functions whether they are exported or not.\n\n### Lists\n\nFish can store a list (or an “array” if you wish) of multiple strings inside of a variable:\n\n```\n> set mylist first second third\n> printf '%s\\n' $mylist # prints each element on its own line\nfirst\nsecond\nthird\n```\n\nTo access one element of a list, use the index of the element inside of square brackets, like this:\n\n```\necho $PATH[3]\n```\n\nList indices start at 1 in fish, not 0 like in other languages. This is because it requires less subtracting of 1 and many common Unix tools like `seq` work better with it (`seq 5` prints 1 to 5, not 0 to 5). An invalid index is silently ignored resulting in no value (not even an empty string, just no argument at all).\n\nIf you don’t use any brackets, all the elements of the list will be passed to the command as separate items. This means you can iterate over a list with `for`:\n\n```\nfor i in $PATH\n    echo $i is in the path\nend\n```\n\nThis goes over every directory in [`PATH`](#envvar-PATH) separately and prints a line saying it is in the path.\n\nTo create a variable `smurf`, containing the items `blue` and `small`, simply write:\n\n```\nset smurf blue small\n```\n\nIt is also possible to set or erase individual elements of a list:\n\n```\n# Set smurf to be a list with the elements 'blue' and 'small'\nset smurf blue small\n\n# Change the second element of smurf to 'evil'\nset smurf[2] evil\n\n# Erase the first element\nset -e smurf[1]\n\n# Output 'evil'\necho $smurf\n```\n\nIf you specify a negative index when expanding or assigning to a list variable, the index will be taken from the *end* of the list. For example, the index -1 is the last element of the list:\n\n```\n> set fruit apple orange banana\n> echo $fruit[-1]\nbanana\n\n> echo $fruit[-2..-1]\norange\nbanana\n\n> echo $fruit[-1..1] # reverses the list\nbanana\norange\napple\n```\n\nAs you see, you can use a range of indices, see [slices](#expand-slices) for details.\n\nAll lists are one-dimensional and can’t contain other lists, although it is possible to fake nested lists using dereferencing - see [variable expansion](#expand-variable).\n\nWhen a list is exported as an environment variable, it is either space or colon delimited, depending on whether it is a [path variable](#variables-path):\n\n```\n> set -x smurf blue small\n> set -x smurf_PATH forest mushroom\n> env | grep smurf\nsmurf=blue small\nsmurf_PATH=forest:mushroom\n```\n\nFish automatically creates lists from all environment variables whose name ends in `PATH` (like [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH) or `MANPATH`), by splitting them on colons. Other variables are not automatically split.\n\nLists can be inspected with the [count](cmds/count) or the [contains](cmds/contains) commands:\n\n```\n> count $smurf\n2\n\n> contains blue $smurf\n# blue was found, so it exits with status 0\n# (without printing anything)\n\n> echo $status\n0\n\n> contains -i blue $smurf\n1\n```\n\nA nice thing about lists is that they are passed to commands one element as one argument, so once you’ve set your list, you can just pass it:\n\n```\nset -l grep_args -r \"my string\"\ngrep $grep_args . # will run the same as `grep -r \"my string\"` .\n```\n\nUnlike other shells, fish does not do “word splitting” - elements in a list stay as they are, even if they contain spaces or tabs.\n\n### Argument Handling\n\nAn important list is `$argv`, which contains the arguments to a function or script. For example:\n\n```\nfunction myfunction\n    echo $argv[1]\n    echo $argv[3]\nend\n```\n\nThis function takes whatever arguments it gets and prints the first and third:\n\n```\n> myfunction first second third\nfirst\nthird\n\n> myfunction apple cucumber banana\napple\nbanana\n```\n\nThat covers the positional arguments, but commandline tools often get various options and flags, and \\$argv would contain them intermingled with the positional arguments. Typical unix argument handling allows short options (`-h`, also grouped like in `ls -lah`), long options (`--help`) and allows those options to take arguments (`--color=auto` or `--position anywhere` or `complete -C\"git \"`) as well as a `--` separator to signal the end of options. Handling all of these manually is tricky and error-prone.\n\nA more robust approach to option handling is [argparse](cmds/argparse), which checks the defined options and puts them into various variables, leaving only the positional arguments in \\$argv. Here’s a simple example:\n\n```\nfunction mybetterfunction\n    # We tell argparse about -h/--help and -s/--second - these are short and long forms of the same option.\n    # The \"--\" here is mandatory, it tells it from where to read the arguments.\n    argparse h/help s/second -- $argv\n    # exit if argparse failed because it found an option it didn't recognize - it will print an error\n    or return\n\n    # If -h or --help is given, we print a little help text and return\n    if set -ql _flag_help\n        echo \"mybetterfunction [-h|--help] [-s|--second] [ARGUMENT ...]\"\n        return 0\n    end\n\n    # If -s or --second is given, we print the second argument,\n    # not the first and third.\n    # (this is also available as _flag_s because of the short version)\n    if set -ql _flag_second\n        echo $argv[2]\n    else\n        echo $argv[1]\n        echo $argv[3]\n    end\nend\n```\n\nThe options will be *removed* from \\$argv, so \\$argv\\[2\\] is the second *positional* argument now:\n\n```\n> mybetterfunction first -s second third\nsecond\n```\n\nFor more information on argparse, like how to handle option arguments, see [the argparse documentation](cmds/argparse).\n\n### PATH variables\n\nPath variables are a special kind of variable used to support colon-delimited path lists including [`PATH`](#envvar-PATH), [`CDPATH`](#envvar-CDPATH), `MANPATH`, `PYTHONPATH`, etc. All variables that end in “PATH” (case-sensitive) become PATH variables by default.\n\nPATH variables act as normal lists, except they are implicitly joined and split on colons.\n\n```\nset MYPATH 1 2 3\necho \"$MYPATH\"\n# 1:2:3\nset MYPATH \"$MYPATH:4:5\"\necho $MYPATH\n# 1 2 3 4 5\necho \"$MYPATH\"\n# 1:2:3:4:5\n```\n\nPath variables will also be exported in the colon form, so `set -x MYPATH 1 2 3` will have external commands see it as `1:2:3`.\n\n```\n> set -gx MYPATH /bin /usr/bin /sbin\n> env | grep MYPATH\nMYPATH=/bin:/usr/bin:/sbin\n```\n\nThis is for compatibility with other tools. Unix doesn’t have variables with multiple elements, the closest thing it has are colon-lists like [`PATH`](#envvar-PATH). For obvious reasons this means no element can contain a `:`.\n\nVariables can be marked or unmarked as PATH variables via the `--path` and `--unpath` options to `set`.\n\n### Special variables\n\nYou can change the settings of fish by changing the values of certain variables.\n\n`PATH`  \nA list of directories in which to search for commands. This is a common unix variable also used by other tools.\n\n&nbsp;\n\n`CDPATH`  \nA list of directories in which the [cd](cmds/cd) builtin looks for a new directory.\n\n&nbsp;\n\nLocale Variables  \nThe locale variables [`LANG`](#envvar-LANG), [`LC_ALL`](#envvar-LC_ALL), [`LC_COLLATE`](#envvar-LC_COLLATE), [`LC_CTYPE`](#envvar-LC_CTYPE), [`LC_MESSAGES`](#envvar-LC_MESSAGES), [`LC_MONETARY`](#envvar-LC_MONETARY), [`LC_NUMERIC`](#envvar-LC_NUMERIC), and [`LANG`](#envvar-LANG) set the language option for the shell and subprograms. See the section [Locale variables](#variables-locale) for more information.\n\n&nbsp;\n\nColor variables  \nA number of variable starting with the prefixes `fish_color` and `fish_pager_color`. See [Variables for changing highlighting colors](interactive#variables-color) for more information.\n\n&nbsp;\n\n`fish_term24bit`  \nIf this is set to 1, fish will assume the terminal understands 24-bit RGB color sequences, and won’t translate them to the 256 or 16 color palette. This is often detected automatically.\n\n&nbsp;\n\n`fish_term256`  \nIf this is set to 1, fish will assume the terminal understands 256 colors, and won’t translate matching colors down to the 16 color palette. This is usually autodetected.\n\n&nbsp;\n\n`fish_ambiguous_width`  \ncontrols the computed width of ambiguous-width characters. This should be set to 1 if your terminal renders these characters as single-width (typical), or 2 if double-width.\n\n&nbsp;\n\n`fish_emoji_width`  \ncontrols whether fish assumes emoji render as 2 cells or 1 cell wide. This is necessary because the correct value changed from 1 to 2 in Unicode 9, and some terminals may not be aware. Set this if you see graphical glitching related to emoji (or other “special” characters). It should usually be auto-detected.\n\n&nbsp;\n\n`fish_autosuggestion_enabled`  \ncontrols if [Autosuggestions](interactive#autosuggestions) are enabled. Set it to 0 to disable, anything else to enable. By default they are on.\n\n&nbsp;\n\n`fish_handle_reflow`  \ndetermines whether fish should try to repaint the commandline when the terminal resizes. In terminals that reflow text this should be disabled. Set it to 1 to enable, anything else to disable.\n\n&nbsp;\n\n`fish_key_bindings`  \nthe name of the function that sets up the keyboard shortcuts for the [command-line editor](interactive#editor).\n\n&nbsp;\n\n`fish_escape_delay_ms`  \nsets how long fish waits for another key after seeing an escape, to distinguish pressing the escape key from the start of an escape sequence. The default is 30ms. Increasing it increases the latency but allows pressing escape instead of alt for alt+character bindings. For more information, see [the chapter in the bind documentation](cmds/bind#cmd-bind-escape).\n\n&nbsp;\n\n`fish_sequence_key_delay_ms`  \nsets how long fish waits for another key after seeing a key that is part of a longer sequence, to disambiguate. For instance if you had bound `\\cx\\ce` to open an editor, fish would wait for this long in milliseconds to see a ctrl-e after a ctrl-x. If the time elapses, it will handle it as a ctrl-x (by default this would copy the current commandline to the clipboard). See also [Key sequences](interactive#interactive-key-sequences).\n\n&nbsp;\n\n`fish_complete_path`  \ndetermines where fish looks for completion. When trying to complete for a command, fish looks for files in the directories in this variable.\n\n&nbsp;\n\n`fish_cursor_selection_mode`  \ncontrols whether the selection is inclusive or exclusive of the character under the cursor (see [Copy and Paste](interactive#killring)).\n\n&nbsp;\n\n`fish_function_path`  \ndetermines where fish looks for functions. When fish [autoloads](#syntax-function-autoloading) a function, it will look for files in these directories.\n\n&nbsp;\n\n`fish_greeting`  \nthe greeting message printed on startup. This is printed by a function of the same name that can be overridden for more complicated changes (see [funced](cmds/funced))\n\n&nbsp;\n\n`fish_history`  \nthe current history session name. If set, all subsequent commands within an interactive fish session will be logged to a separate file identified by the value of the variable. If unset, the default session name “fish” is used. If set to an empty string, history is not saved to disk (but is still available within the interactive session).\n\n&nbsp;\n\n`fish_trace`  \nif set and not empty, will cause fish to print commands before they execute, similar to `set -x` in bash. The trace is printed to the path given by the `--debug-output` option to fish or the [`FISH_DEBUG_OUTPUT`](#envvar-FISH_DEBUG_OUTPUT) variable. It goes to stderr by default.\n\n&nbsp;\n\n`FISH_DEBUG`  \nControls which debug categories **fish** enables for output, analogous to the `--debug` option.\n\n&nbsp;\n\n`FISH_DEBUG_OUTPUT`  \nSpecifies a file to direct debug output to.\n\n&nbsp;\n\n`fish_user_paths`  \na list of directories that are prepended to [`PATH`](#envvar-PATH). This can be a universal variable.\n\n&nbsp;\n\n`umask`  \nthe current file creation mask. The preferred way to change the umask variable is through the [umask](cmds/umask) function. An attempt to set umask to an invalid value will always fail.\n\n&nbsp;\n\n`BROWSER`  \nyour preferred web browser. If this variable is set, fish will use the specified browser instead of the system default browser to display the fish documentation.\n\nFish also provides additional information through the values of certain environment variables. Most of these variables are read-only and their value can’t be changed with `set`.\n\n`_`  \nthe name of the currently running command (though this is deprecated, and the use of `status current-command` is preferred).\n\n&nbsp;\n\n`argv`  \na list of arguments to the shell or function. `argv` is only defined when inside a function call, or if fish was invoked with a list of arguments, like `fish myscript.fish foo bar`. This variable can be changed.\n\n&nbsp;\n\n`CMD_DURATION`  \nthe runtime of the last command in milliseconds.\n\n&nbsp;\n\nCOLUMNS and LINES  \nthe current size of the terminal in height and width. These values are only used by fish if the operating system does not report the size of the terminal. Both variables must be set in that case otherwise a default of 80x24 will be used. They are updated when the window size changes.\n\n&nbsp;\n\n`fish_kill_signal`  \nthe signal that terminated the last foreground job, or 0 if the job exited normally.\n\n&nbsp;\n\n`fish_killring`  \na list of entries in fish’s [kill ring](interactive#killring) of cut text.\n\n&nbsp;\n\n`fish_read_limit`  \nhow many bytes fish will process with [read](cmds/read) or in a [command substitution](#expand-command-substitution).\n\n&nbsp;\n\n`fish_pid`  \nthe process ID (PID) of the shell.\n\n&nbsp;\n\n`history`  \na list containing the last commands that were entered.\n\n&nbsp;\n\n`HOME`  \nthe user’s home directory. This variable can be changed.\n\n&nbsp;\n\n`hostname`  \nthe machine’s hostname.\n\n&nbsp;\n\n`IFS`  \nthe internal field separator that is used for word splitting with the [read](cmds/read) builtin. Setting this to the empty string will also disable line splitting in [command substitution](#expand-command-substitution). This variable can be changed.\n\n&nbsp;\n\n`last_pid`  \nthe process ID (PID) of the last background process.\n\n&nbsp;\n\n`PWD`  \nthe current working directory.\n\n&nbsp;\n\n`pipestatus`  \na list of exit statuses of all processes that made up the last executed pipe. See [exit status](#variables-status).\n\n&nbsp;\n\n`SHLVL`  \nthe level of nesting of shells. Fish increments this in interactive shells, otherwise it simply passes it along.\n\n&nbsp;\n\n`status`  \nthe [exit status](#variables-status) of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.\n\n&nbsp;\n\n`status_generation`  \nthe “generation” count of `$status`. This will be incremented only when the previous command produced an explicit status. (For example, background jobs will not increment this).\n\n&nbsp;\n\n`TERM`  \nthe type of the current terminal. When fish tries to determine how the terminal works - how many colors it supports, what sequences it sends for keys and other things - it looks at this variable and the corresponding information in the terminfo database (see `man terminfo`).\n\nNote: Typically this should not be changed as the terminal sets it to the correct value.\n\n&nbsp;\n\n`USER`  \nthe current username. This variable can be changed.\n\n&nbsp;\n\n`EUID`  \nthe current effective user id, set by fish at startup. This variable can be changed.\n\n&nbsp;\n\n`version`  \nthe version of the currently running fish (also available as `FISH_VERSION` for backward compatibility).\n\nAs a convention, an uppercase name is usually used for exported variables, while lowercase variables are not exported. (`CMD_DURATION` is an exception for historical reasons). This rule is not enforced by fish, but it is good coding practice to use casing to distinguish between exported and unexported variables.\n\nFish also uses some variables internally, their name usually starting with `__fish`. These are internal and should not typically be modified directly.\n\n### The status variable\n\nWhenever a process exits, an exit status is returned to the program that started it (usually the shell). This exit status is an integer number, which tells the calling application how the execution of the command went. In general, a zero exit status means that the command executed without problem, but a non-zero exit status means there was some form of problem.\n\nFish stores the exit status of the last process in the last job to exit in the `status` variable.\n\nIf fish encounters a problem while executing a command, the status variable may also be set to a specific value:\n\n- 0 is generally the exit status of commands if they successfully performed the requested operation.\n- 1 is generally the exit status of commands if they failed to perform the requested operation.\n- 121 is generally the exit status of commands if they were supplied with invalid arguments.\n- 123 means that the command was not executed because the command name contained invalid characters.\n- 124 means that the command was not executed because none of the wildcards in the command produced any matches.\n- 125 means that while an executable with the specified name was located, the operating system could not actually execute the command.\n- 126 means that while a file with the specified name was located, it was not executable.\n- 127 means that no function, builtin or command with the given name could be located.\n\nIf a process exits through a signal, the exit status will be 128 plus the number of the signal.\n\nThe status can be negated with [not](cmds/not) (or `!`), which is useful in a [condition](#syntax-conditional). This turns a status of 0 into 1 and any non-zero status into 0.\n\nThere is also `$pipestatus`, which is a list of all `status` values of processes in a pipe. One difference is that [not](cmds/not) applies to `$status`, but not `$pipestatus`, because it loses information.\n\nFor example:\n\n```\nnot cat file | grep -q fish\necho status is: $status pipestatus is $pipestatus\n```\n\nHere `$status` reflects the status of `grep`, which returns 0 if it found something, negated with `not` (so 1 if it found something, 0 otherwise). `$pipestatus` reflects the status of `cat` (which returns non-zero for example when it couldn’t find the file) and `grep`, without the negation.\n\nSo if both `cat` and `grep` succeeded, `$status` would be 1 because of the `not`, and `$pipestatus` would be 0 and 0.\n\nIt’s possible for the first command to fail while the second succeeds. One common example is when the second program quits early.\n\nFor example, if you have a pipeline like:\n\n```\ncat file1 file2 | head -n 50\n```\n\nThis will tell `cat` to print two files, “file1” and “file2”, one after the other, and the `head` will then only print the first 50 lines. In this case you might often see this constellation:\n\n```\n> cat file1 file2 | head -n 50\n# 50 lines of output\n> echo $pipestatus\n141 0\n```\n\nHere, the “141” signifies that `cat` was killed by signal number 13 (128 + 13 == 141) - a `SIGPIPE`. You can also use [`fish_kill_signal`](#envvar-fish_kill_signal) to see the signal number. This happens because it was still working, and then `head` closed the pipe, so `cat` received a signal that it didn’t ignore and so it died.\n\nWhether `cat` here will see a SIGPIPE depends on how long the file is and how much it writes at once, so you might see a pipestatus of “0 0”, depending on the implementation. This is a general unix issue and not specific to fish. Some shells feature a “pipefail” feature that will call a pipeline failed if one of the processes in it failed, and this is a big problem with it.\n\n### Locale Variables\n\nThe “locale” of a program is its set of language and regional settings that depend on language and cultural convention. In UNIX, these are made up of several categories. The categories are:\n\n`LANG`  \nThis is the typical environment variable for specifying a locale. A user may set this variable to express the language they speak, their region, and a character encoding. The actual values are specific to their platform, except for special values like `C` or `POSIX`.\n\nThe value of LANG is used for each category unless the variable for that category was set or LC_ALL is set. So typically you only need to set LANG.\n\nAn example value might be `en_US.UTF-8` for the american version of english and the UTF-8 encoding, or `de_AT.UTF-8` for the austrian version of german and the UTF-8 encoding. Your operating system might have a `locale` command that you can call as `locale -a` to see a list of defined locales.\n\nA UTF-8 encoding is recommended.\n\n&nbsp;\n\n`LC_ALL`  \nOverrides the [`LANG`](#envvar-LANG) environment variable and the values of the other `LC_*` variables. If this is set, none of the other variables are used for anything.\n\nUsually the other variables should be used instead. Use LC_ALL only when you need to override something.\n\n&nbsp;\n\n`LC_COLLATE`  \nThis determines the rules about equivalence of cases and alphabetical ordering: collation.\n\n&nbsp;\n\n`LC_CTYPE`  \nThis determines classification rules, like if the type of character is an alpha, digit, and so on. Most importantly, it defines the text *encoding* - which numbers map to which characters. On modern systems, this should typically be something ending in “UTF-8”.\n\n&nbsp;\n\n`LC_MESSAGES`  \n`LC_MESSAGES` determines the language in which messages are diisplayed.\n\n&nbsp;\n\n`LC_MONETARY`  \nDetermines currency, how it is formated, and the symbols used.\n\n&nbsp;\n\n`LC_NUMERIC`  \nSets the locale for formatting numbers.\n\n&nbsp;\n\n`LC_TIME`  \nSets the locale for formatting dates and times.\n\n## Builtin commands\n\nFish includes a number of commands in the shell directly. We call these “builtins”. These include:\n\n- Builtins that manipulate the shell state - [cd](cmds/cd) changes directory, [set](cmds/set) sets variables\n- Builtins for dealing with data, like [string](cmds/string) for strings and [math](cmds/math) for numbers, [count](cmds/count) for counting lines or arguments, [path](cmds/path) for dealing with path\n- [status](cmds/status) for asking about the shell’s status\n- [printf](cmds/printf) and [echo](cmds/echo) for creating output\n- [test](cmds/test) for checking conditions\n- [argparse](cmds/argparse) for parsing function arguments\n- [source](cmds/source) to read a script in the current shell (so changes to variables stay) and [eval](cmds/eval) to execute a string as script\n- [random](cmds/random) to get random numbers or pick a random element from a list\n- [read](cmds/read) for reading from a pipe or the terminal\n\nFor a list of all builtins, use `builtin -n`.\n\nFor a list of all builtins, functions and commands shipped with fish, see the [list of commands](commands#commands). The documentation is also available by using the `--help` switch.\n\n## Command lookup\n\nWhen fish is told to run something, it goes through multiple steps to find it.\n\nIf it contains a `/`, fish tries to execute the given file, from the current directory on.\n\nIf it doesn’t contain a `/`, it could be a function, builtin, or external command, and so fish goes through the full lookup.\n\nIn order:\n\n1.  It tries to resolve it as a [function](#syntax-function).\n\n    - If the function is already known, it uses that\n    - If there is a file of the name with a “.fish” suffix in [`fish_function_path`](#envvar-fish_function_path), it [loads that](#syntax-function-autoloading). (If there is more than one file only the first is used)\n    - If the function is now defined it uses that\n\n2.  It tries to resolve it as a [builtin](#builtin-overview).\n\n3.  It tries to find an executable file in [`PATH`](#envvar-PATH).\n\n    - If it finds a file, it tells the kernel to run it.\n    - If the kernel knows how to run the file (e.g. via a `#!` line - `#!/bin/sh` or `#!/usr/bin/python`), it does it.\n    - If the kernel reports that it couldn’t run it because of a missing interpreter, and the file passes a rudimentary check, fish tells `/bin/sh` to run it.\n\nIf none of these work, fish runs the function [fish_command_not_found](cmds/fish_command_not_found) and sets [`status`](#envvar-status) to 127.\n\nYou can use [type](cmds/type) to see how fish resolved something:\n\n```\n> type --short --all echo\necho is a builtin\necho is /usr/bin/echo\n```\n\n## Querying for user input\n\nSometimes, you want to ask the user for input, for instance to confirm something. This can be done with the [read](cmds/read) builtin.\n\nLet’s make up an example. This function will [glob](#expand-wildcard) the files in all the directories it gets as [arguments](#variables-argv), and [if](#syntax-conditional) there are [more than five](cmds/test) it will ask the user if it is supposed to show them, but only if it is connected to a terminal:\n\n```\nfunction show_files\n    # This will glob on all arguments. Any non-directories will be ignored.\n    set -l files $argv/*\n\n    # If there are more than 5 files\n    if test (count $files) -gt 5\n        # and both stdin (for reading input) and stdout (for writing the prompt)\n        # are terminals\n        and isatty stdin\n        and isatty stdout\n        # Keep asking until we get a valid response\n        while read --nchars 1 -l response --prompt-str=\"Are you sure? (y/n)\"\n              or return 1 # if the read was aborted with ctrl-c/ctrl-d\n            switch $response\n                case y Y\n                    echo Okay\n                    # We break out of the while and go on with the function\n                    break\n                case n N\n                    # We return from the function without printing\n                    echo Not showing\n                    return 1\n                case '*'\n                    # We go through the while loop and ask again\n                    echo Not valid input\n                    continue\n            end\n        end\n    end\n\n    # And now we print the files\n    printf '%s\\n' $files\nend\n```\n\nIf you run this as `show_files /`, it will most likely ask you until you press Y/y or N/n. If you run this as `show_files / | cat`, it will print the files without asking. If you run this as `show_files .`, it might just print something without asking because there are fewer than five files.\n\n## Shell variable and function names\n\nThe names given to variables and functions (so-called “identifiers”) have to follow certain rules:\n\n- A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.\n- A function name cannot be empty. It may not begin with a hyphen (“-”) and may not contain a slash (“/”). All other characters, including a space, are valid. A function name also can’t be the same as a reserved keyword or essential builtin like `if` or `set`.\n- A bind mode name (e.g., `bind -m abc ...`) must be a valid variable name.\n\nOther things have other restrictions. For instance what is allowed for file names depends on your system, but at the very least they cannot contain a “/” (because that is the path separator) or NULL byte (because that is how UNIX ends strings).\n\n## Configuration files\n\nWhen fish is started, it reads and runs its configuration files. Where these are depends on build configuration and environment variables.\n\nThe main file is `~/.config/fish/config.fish` (or more precisely `$XDG_CONFIG_HOME/fish/config.fish`).\n\nConfiguration files are run in the following order:\n\n- Configuration snippets (named `*.fish`) in the directories:\n\n  - `$__fish_config_dir/conf.d` (by default, `~/.config/fish/conf.d/`)\n\n  - `$__fish_sysconf_dir/conf.d` (by default, `/etc/fish/conf.d/`)\n\n  - Directories for others to ship configuration snippets for their software:\n\n    - the directories under `$__fish_user_data_dir` (usually `~/.local/share/fish`, controlled by the `XDG_DATA_HOME` environment variable)\n    - a `fish/vendor_conf.d` directory in the directories listed in `$XDG_DATA_DIRS` (default `/usr/share/fish/vendor_conf.d` and `/usr/local/share/fish/vendor_conf.d`)\n\n    These directories are also accessible in `$__fish_vendor_confdirs`. Note that changing that in a running fish won’t do anything as by that point the directories have already been read.\n\n  If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. “01” sorts before “2”).\n\n- System-wide configuration files, where administrators can include initialization for all users on the system - similar to `/etc/profile` for POSIX-style shells - in `$__fish_sysconf_dir` (usually `/etc/fish/config.fish`).\n\n- User configuration, usually in `~/.config/fish/config.fish` (controlled by the `XDG_CONFIG_HOME` environment variable, and accessible as `$__fish_config_dir`).\n\n`~/.config/fish/config.fish` is sourced *after* the snippets. This is so you can copy snippets and override some of their behavior.\n\nThese files are all executed on the startup of every shell. If you want to run a command only on starting an interactive shell, use the exit status of the command `status --is-interactive` to determine if the shell is interactive. If you want to run a command only when using a login shell, use `status --is-login` instead. This will speed up the starting of non-interactive or non-login shells.\n\nIf you are developing another program, you may want to add configuration for all users of fish on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells won’t benefit from the fish-specific configuration. However, if they are required, you can install them to the “vendor” configuration directory. As this path may vary from system to system, `pkg-config` should be used to discover it: `pkg-config --variable confdir fish`.\n\nFor system integration, fish also ships a file called `__fish_build_paths.fish`. This can be customized during build, for instance because your system requires special paths to be used.\n\n## Future feature flags\n\nFeature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.\n\nYou can see the current list of features via `status features`:\n\n```\n> status features\nstderr-nocaret          on  3.0 ^ no longer redirects stderr\nqmark-noglob            off 3.0 ? no longer globs\nregex-easyesc           on  3.1 string replace -r needs fewer \\\\'s\nampersand-nobg-in-token on  3.4 & only backgrounds if followed by a separating character\n```\n\nHere is what they mean:\n\n- `stderr-nocaret` was introduced in fish 3.0 (and made the default in 3.3). It makes `^` an ordinary character instead of denoting an stderr redirection, to make dealing with quoting and such easier. Use `2>` instead. This can no longer be turned off since fish 3.5. The flag can still be tested for compatibility, but a `no-stderr-nocaret` value will simply be ignored.\n- `qmark-noglob` was also introduced in fish 3.0. It makes `?` an ordinary character instead of a single-character glob. Use a `*` instead (which will match multiple characters) or find other ways to match files like `find`.\n- `regex-easyesc` was introduced in 3.1. It makes it so the replacement expression in `string replace -r` does one fewer round of escaping. Before, to escape a backslash you would have to use `string replace -ra '([ab])' '\\\\\\\\\\\\\\\\$1'`. After, just `'\\\\\\\\$1'` is enough. Check your `string replace` calls if you use this anywhere.\n- `ampersand-nobg-in-token` was introduced in fish 3.4. It makes it so a `&` i no longer interpreted as the backgrounding operator in the middle of a token, so dealing with URLs becomes easier. Either put spaces or a semicolon after the `&`. This is recommended formatting anyway, and `fish_indent` will have done it for you already.\n\nThese changes are introduced off by default. They can be enabled on a per session basis:\n\n```\n> fish --features qmark-noglob,regex-easyesc\n```\n\nor opted into globally for a user:\n\n```\n> set -U fish_features regex-easyesc qmark-noglob\n```\n\nFeatures will only be set on startup, so this variable will only take effect if it is universal or exported.\n\nYou can also use the version as a group, so `3.0` is equivalent to “stderr-nocaret” and “qmark-noglob”. Instead of a version, the special group `all` enables all features.\n\nPrefixing a feature with `no-` turns it off instead. E.g. to reenable the `?` single-character glob:\n\n```\nset -Ua fish_features no-qmark-noglob\n```\n\nCurrently, the following features are enabled by default:\n\n- stderr-nocaret - `^` no longer redirects stderr, use `2>`. Enabled by default in fish 3.3.0. No longer changeable since fish 3.5.0.\n- regex-easyesc - `string replace -r` requires fewer backslashes in the replacement part. Enabled by default in fish 3.5.0.\n- ampersand-nobg-in-token - `&` in the middle of a word is a normal character instead of backgrounding. Enabled by default in fish 3.5.0.\n\n## Event handlers\n\nWhen defining a new function in fish, it is possible to make it into an event handler, i.e. a function that is automatically run when a specific event takes place. Events that can trigger a handler currently are:\n\n- When a signal is delivered\n- When a job exits\n- When the value of a variable is updated\n- When the prompt is about to be shown\n\nExample:\n\nTo specify a signal handler for the WINCH signal, write:\n\n```\nfunction my_signal_handler --on-signal WINCH\n    echo Got WINCH signal!\nend\n```\n\nFish already has the following named events for the `--on-event` switch:\n\n- `fish_prompt` is emitted whenever a new fish prompt is about to be displayed.\n- `fish_preexec` is emitted right before executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_posterror` is emitted right after executing a command with syntax errors. The commandline is passed as the first parameter.\n- `fish_postexec` is emitted right after executing an interactive command. The commandline is passed as the first parameter. Not emitted if command is empty.\n- `fish_exit` is emitted right before fish exits.\n- `fish_cancel` is emitted when a commandline is cleared.\n\nEvents can be fired with the [emit](cmds/emit) command, and do not have to be defined before. The names just need to match. For example:\n\n```\nfunction handler --on-event imdone\n    echo generator is done $argv\nend\n\nfunction generator\n    sleep 1\n    # The \"imdone\" is the name of the event\n    # the rest is the arguments to pass to the handler\n    emit imdone with $argv\nend\n```\n\nIf there are multiple handlers for an event, they will all be run, but the order might change between fish releases, so you should not rely on it.\n\nPlease note that event handlers only become active when a function is loaded, which means you need to otherwise [source](cmds/source) or execute a function instead of relying on [autoloading](#syntax-function-autoloading). One approach is to put it into your [configuration file](#configuration).\n\nFor more information on how to define new event handlers, see the documentation for the [function](cmds/function) command.\n\n## Debugging fish scripts\n\nFish includes basic built-in debugging facilities that allow you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt where you can execute any fish command to inspect or change state (there are no debug commands as such). For example, you can check or change the value of any variables using [printf](cmds/printf) and [set](cmds/set). As another example, you can run [status print-stack-trace](cmds/status) to see how the current breakpoint was reached. To resume normal execution of the script, simply type [exit](cmds/exit) or Control+D.\n\nTo start a debug session simply insert the [builtin command](cmds/breakpoint) `breakpoint` at the point in a function or script where you wish to gain control, then run the function or script. Also, the default action of the `TRAP` signal is to call this builtin, meaning a running script can be actively debugged by sending it the `TRAP` signal (`kill -s TRAP <PID>`). There is limited support for interactively setting or modifying breakpoints from this debug prompt: it is possible to insert new breakpoints in (or remove old ones from) other functions by using the `funced` function to edit the definition of a function, but it is not possible to add or remove a breakpoint from the function/script currently loaded and being executed.\n\nAnother way to debug script issues is to set the [`fish_trace`](#envvar-fish_trace) variable, e.g. `fish_trace=1 fish_prompt` to see which commands fish executes when running the [fish_prompt](cmds/fish_prompt) function.\n\nIf you specifically want to debug performance issues, **fish** can be run with the `--profile /path/to/profile.log` option to save a profile to the specified path. This profile log includes a breakdown of how long each step in the execution took. See [fish](cmds/fish) for more information.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/language.html](https://fishshell.com/docs/3.7/language.html)"
- name: math
  summary: math performs mathematical calculations
  description: "# math - perform mathematics calculations\n\n## Synopsis\n\n```\nmath [(-s | --scale) N] [(-b | --base) BASE] EXPRESSION ...\n```\n\n## Description\n\n`math` performs mathematical calculations. It supports simple operations such as addition, subtraction, and so on, as well as functions like `abs()`, `sqrt()` and `ln()`.\n\nBy default, the output shows up to 6 decimal places. To change the number of decimal places, use the `--scale` option, including `--scale=0` for integer output. Trailing zeroes will always be trimmed.\n\nKeep in mind that parameter expansion happens before expressions are evaluated. This can be very useful in order to perform calculations involving shell variables or the output of command substitutions, but it also means that parenthesis (`()`) and the asterisk (`*`) glob character have to be escaped or quoted. `x` can also be used to denote multiplication, but it needs to be followed by whitespace to distinguish it from hexadecimal numbers.\n\nParentheses for functions are optional - `math sin pi` prints `0`. However, a comma will bind to the inner function, so `math pow sin 3, 5` is an error because it tries to give `sin` the arguments `3` and `5`. When in doubt, use parentheses.\n\n`math` ignores whitespace between arguments and takes its input as multiple arguments (internally joined with a space), so `math 2 +2` and `math \"2 +    2\"` work the same. `math 2 2` is an error.\n\nThe following options are available:\n\n**-s** *N* or **--scale** *N*  \nSets the scale of the result. `N` must be an integer or the word “max” for the maximum scale. A scale of zero causes results to be truncated, not rounded. Any non-integer component is thrown away. So `3/2` returns `1` rather than `2` which `1.5` would normally round to. This is for compatibility with `bc` which was the basis for this command prior to fish 3.0.0. Scale values greater than zero causes the result to be rounded using the usual rules to the specified number of decimal places.\n\n**-b** *BASE* or **--base** *BASE*  \nSets the numeric base used for output (`math` always understands hexadecimal numbers as input). It currently understands “hex” or “16” for hexadecimal and “octal” or “8” for octal and implies a scale of 0 (other scales cause an error), so it will truncate the result down to an integer. This might change in the future. Hex numbers will be printed with a `0x` prefix. Octal numbers will have a prefix of `0` but aren’t understood by `math` as input.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## Return Values\n\nIf the expression is successfully evaluated and doesn’t over/underflow or return NaN the return `status` is zero (success) else one.\n\n## Syntax\n\n`math` knows some operators, constants, functions and can (obviously) read numbers.\n\nFor numbers, `.` is always the radix character regardless of locale - `2.5`, not `2,5`. Scientific notation (`10e5`) and hexadecimal (`0xFF`) are also available.\n\n`math` allows you to use underscores as visual separators for digit grouping. For example, you can write `1_000_000`, `0x_89_AB_CD_EF`, and `1.234_567_e89`.\n\n## Operators\n\n`math` knows the following operators:\n\n`+`  \nfor addition\n\n`-`  \nfor subtraction\n\n`* or x`  \nfor multiplication. `*` is the glob character and needs to be quoted or escaped, `x` needs to be followed by whitespace or it looks like `0x` hexadecimal notation.\n\n`/`  \nfor division\n\n`^`  \nfor exponentiation\n\n`%`  \nfor modulo\n\n`( or )`  \nfor grouping. These need to be quoted or escaped because `()` denotes a command substitution.\n\nThey are all used in an infix manner - `5 + 2`, not `+ 5 2`.\n\n## Constants\n\n`math` knows the following constants:\n\n`e`  \nEuler’s number\n\n`pi`  \nπ, you know this one. Half of Tau\n\n`tau`  \nEquivalent to 2π, or the number of radians in a circle\n\nUse them without a leading `$` - `pi - 3` should be about 0.\n\n## Functions\n\n`math` supports the following functions:\n\n`abs`  \nthe absolute value, with positive sign\n\n`acos`  \narc cosine\n\n`asin`  \narc sine\n\n`atan`  \narc tangent\n\n`atan2`  \narc tangent of two variables\n\n`bitand, bitor and bitxor`  \nperform bitwise operations. These will throw away any non-integer parts and interpret the rest as an int.\n\nNote: `bitnot` and `bitnand` don’t exist. This is because numbers in math don’t really have a *width* in terms of bits, and these operations necessarily care about leading zeroes.\n\nIf you need to negate a specific number you can do it with an xor with a mask, e.g.:\n\n```\n> math --base=hex bitxor 0x0F, 0xFF\n0xF0\n\n> math --base=hex bitxor 0x2, 0x3\n# Here we mask with 0x3 == 0b111, so our number is 3 bits wide\n# Only the 1 bit isn't set.\n0x1\n```\n\n`ceil`  \nround number up to the nearest integer\n\n`cos`  \nthe cosine\n\n`cosh`  \nhyperbolic cosine\n\n`exp`  \nthe base-e exponential function\n\n`fac`  \nfactorial - also known as `x!` (`x * (x - 1) * (x - 2) * ... * 1`)\n\n`floor`  \nround number down to the nearest integer\n\n`ln`  \nthe base-e logarithm\n\n`log or log10`  \nthe base-10 logarithm\n\n`log2`  \nthe base-2 logarithm\n\n`max`  \nreturns the largest of the given numbers - this takes an arbitrary number of arguments (but at least one)\n\n`min`  \nreturns the smallest of the given numbers - this takes an arbitrary number of arguments (but at least one)\n\n`ncr`  \n“from n choose r” combination function - how many subsets of size r can be taken from n (order doesn’t matter)\n\n`npr`  \nthe number of subsets of size r that can be taken from a set of n elements (including different order)\n\n`pow(x,y)`  \nreturns x to the y (and can be written as `x ^ y`)\n\n`round`  \nrounds to the nearest integer, away from 0\n\n`sin`  \nthe sine function\n\n`sinh`  \nthe hyperbolic sine\n\n`sqrt`  \nthe square root - (can also be written as `x ^ 0.5`)\n\n`tan`  \nthe tangent\n\n`tanh`  \nthe hyperbolic tangent\n\nAll of the trigonometric functions use radians (the pi-based scale, not 360°).\n\n## Examples\n\n`math 1+1` outputs 2.\n\n`math $status - 128` outputs the numerical exit status of the last command minus 128.\n\n`math 10 / 6` outputs `1.666667`.\n\n`math -s0 10.0 / 6.0` outputs `1`.\n\n`math -s3 10 / 6` outputs `1.666`.\n\n`math \"sin(pi)\"` outputs `0`.\n\n`math 5 \\* 2` or `math \"5 * 2\"` or `math 5 \"*\" 2` all output `10`.\n\n`math 0xFF` outputs 255, `math 0 x 3` outputs 0 (because it computes 0 multiplied by 3).\n\n`math bitand 0xFE, 0x2e` outputs 46.\n\n`math \"bitor(9,2)\"` outputs 11.\n\n`math --base=hex 192` prints `0xc0`.\n\n`math 'ncr(49,6)'` prints 13983816 - that’s the number of possible picks in 6-from-49 lotto.\n\n`math max 5,2,3,1` prints 5.\n\n## Compatibility notes\n\nFish 1.x and 2.x releases relied on the `bc` command for handling `math` expressions. Starting with fish 3.0.0 fish uses the tinyexpr library and evaluates the expression without the involvement of any external commands.\n\nYou don’t need to use `--` before the expression, even if it begins with a minus sign which might otherwise be interpreted as an invalid option. If you do insert `--` before the expression, it will cause option scanning to stop just like for every other command and it won’t be part of the expression.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/math.html](https://fishshell.com/docs/3.7/cmds/math.html)"
- name: nextd
  summary: nextd moves forwards POS positions in the history of visited directories; if the end of the history has been hit, a warning is printed
  description: "# nextd - move forward through directory history\n\n## Synopsis\n\n```\nnextd [-l | --list] [POS]\n```\n\n## Description\n\n`nextd` moves forwards *POS* positions in the [history of visited directories](../interactive#directory-history); if the end of the history has been hit, a warning is printed.\n\nIf the **-l** or **--list** option is specified, the current directory history is also displayed.\n\nThe **-h** or **--help** option displays help about using this command.\n\nNote that the `cd` command limits directory history to the 25 most recently visited directories. The history is stored in the `dirprev` and `dirnext` variables which this command manipulates.\n\n## Example\n\n```\ncd /usr/src\n# Working directory is now /usr/src\n\ncd /usr/src/fish-shell\n# Working directory is now /usr/src/fish-shell\n\nprevd\n# Working directory is now /usr/src\n\nnextd\n# Working directory is now /usr/src/fish-shell\n```\n\n## See Also\n\n- the [cdh](cdh) command to display a prompt to quickly navigate the history\n- the [dirh](dirh) command to print the directory history\n- the [prevd](prevd) command to move backward\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/nextd.html](https://fishshell.com/docs/3.7/cmds/nextd.html)"
- name: not
  summary: not negates the exit status of another command
  description: "# not - negate the exit status of a job\n\n## Synopsis\n\n```\nnot COMMAND [OPTIONS ...]\n```\n\n## Description\n\n`not` negates the exit status of another command. If the exit status is zero, `not` returns 1. Otherwise, `not` returns 0.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\nThe following code reports an error and exits if no file named spoon can be found.\n\n```\nif not test -f spoon\n    echo There is no spoon\n    exit 1\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/not.html](https://fishshell.com/docs/3.7/cmds/not.html)"
- name: open
  summary: open opens a file in its default application, using the appropriate tool for the operating system
  description: "# open - open file in its default application\n\n## Synopsis\n\n```\nopen FILES ...\n```\n\n## Description\n\n`open` opens a file in its default application, using the appropriate tool for the operating system. On GNU/Linux, this requires the common but optional `xdg-open` utility, from the `xdg-utils` package.\n\nNote that this function will not be used if a command by this name exists (which is the case on macOS or Haiku).\n\n## Example\n\n`open *.txt` opens all the text files in the current directory using your system’s default text editor.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/open.html](https://fishshell.com/docs/3.7/cmds/open.html)"
- name: or
  summary: or is used to execute a command if the previous command was not successful (returned a status of something other than 0)
  description: "# or - conditionally execute a command\n\n## Synopsis\n\n```\nCOMMAND1; or COMMAND2\n```\n\n## Description\n\n`or` is used to execute a command if the previous command was not successful (returned a status of something other than 0).\n\n`or` statements may be used as part of the condition in an [if](if) or [while](while) block.\n\n`or` does not change the current exit status itself, but the command it runs most likely will. The exit status of the last foreground command to exit can always be accessed using the [\\$status](../language#variables-status) variable.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\nThe following code runs the `make` command to build a program. If the build succeeds, the program is installed. If either step fails, `make clean` is run, which removes the files created by the build process.\n\n```\nmake; and make install; or make clean\n```\n\n## See Also\n\n- [and](and) command\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/or.html](https://fishshell.com/docs/3.7/cmds/or.html)"
- name: path
  summary: path performs operations on paths
  description: "# path - manipulate and check paths\n\n## Synopsis\n\n```\npath basename GENERAL_OPTIONS [PATH ...]\npath dirname GENERAL_OPTIONS  [PATH ...]\npath extension GENERAL_OPTIONS [PATH ...]\npath filter GENERAL_OPTIONS [-v | --invert]\n    [-d] [-f] [-l] [-r] [-w] [-x]\n    [(-t | --type) TYPE] [(-p | --perm) PERMISSION] [PATH ...]\npath is GENERAL_OPTIONS [(-v | --invert)] [(-t | --type) TYPE]\n    [-d] [-f] [-l] [-r] [-w] [-x]\n    [(-p | --perm) PERMISSION] [PATH ...]\npath mtime GENERAL_OPTIONS [(-R | --relative)] [PATH ...]\npath normalize GENERAL_OPTIONS [PATH ...]\npath resolve GENERAL_OPTIONS [PATH ...]\npath change-extension GENERAL_OPTIONS EXTENSION [PATH ...]\npath sort GENERAL_OPTIONS [-r | --reverse]\n    [-u | --unique] [--key=basename|dirname|path] [PATH ...]\n\nGENERAL_OPTIONS\n    [-z | --null-in] [-Z | --null-out] [-q | --quiet]\n```\n\n## Description\n\n`path` performs operations on paths.\n\nPATH arguments are taken from the command line unless standard input is connected to a pipe or a file, in which case they are read from standard input, one PATH per line. It is an error to supply PATH arguments on both the command line and on standard input.\n\nArguments starting with `-` are normally interpreted as switches; `--` causes the following arguments not to be treated as switches even if they begin with `-`. Switches and required arguments are recognized only on the command line.\n\nWhen a path starts with `-`, `path filter` and `path normalize` will prepend `./` on output to avoid it being interpreted as an option otherwise, so it’s safe to pass path’s output to other commands that can handle relative paths.\n\nAll subcommands accept a `-q` or `--quiet` switch, which suppresses the usual output but exits with the documented status. In this case these commands will quit early, without reading all of the available input.\n\nAll subcommands also accept a `-Z` or `--null-out` switch, which makes them print output separated with NUL instead of newlines. This is for further processing, e.g. passing to another `path`, or `xargs -0`. This is not recommended when the output goes to the terminal or a command substitution.\n\nAll subcommands also accept a `-z` or `--null-in` switch, which makes them accept arguments from stdin separated with NULL-bytes. Since Unix paths can’t contain NULL, that makes it possible to handle all possible paths and read input from e.g. `find -print0`. If arguments are given on the commandline this has no effect. This should mostly be unnecessary since `path` automatically starts splitting on NULL if one appears in the first PATH_MAX bytes, PATH_MAX being the operating system’s maximum length for a path plus a NULL byte.\n\nSome subcommands operate on the paths as strings and so work on nonexistent paths, while others need to access the paths themselves and so filter out nonexistent paths.\n\nThe following subcommands are available.\n\n## “basename” subcommand\n\n```\npath basename [-z | --null-in] [-Z | --null-out] [-q | --quiet] [PATH ...]\n```\n\n`path basename` returns the last path component of the given path, by removing the directory prefix and removing trailing slashes. In other words, it is the part that is not the dirname. For files you might call it the “filename”.\n\nIt returns 0 if there was a basename, i.e. if the path wasn’t empty or just slashes.\n\n### Examples\n\n```\n>_ path basename ./foo.mp4\nfoo.mp4\n\n>_ path basename ../banana\nbanana\n\n>_ path basename /usr/bin/\nbin\n\n>_ path basename /usr/bin/*\n# This prints all files in /usr/bin/\n# A selection:\ncp\nfish\ngrep\nrm\n```\n\n## “dirname” subcommand\n\n```\npath dirname [-z | --null-in] [-Z | --null-out] [-q | --quiet] [PATH ...]\n```\n\n`path dirname` returns the dirname for the given path. This is the part before the last “/”, discounting trailing slashes. In other words, it is the part that is not the basename (discounting superfluous slashes).\n\nIt returns 0 if there was a dirname, i.e. if the path wasn’t empty or just slashes.\n\n### Examples\n\n```\n>_ path dirname ./foo.mp4\n.\n\n>_ path dirname ../banana\n..\n\n>_ path dirname /usr/bin/\n/usr\n```\n\n## “extension” subcommand\n\n```\npath extension [-z | --null-in] [-Z | --null-out] [-q | --quiet] [PATH ...]\n```\n\n`path extension` returns the extension of the given path. This is the part after (and including) the last “.”, unless that “.” followed a “/” or the basename is “.” or “..”, in which case there is no extension and an empty line is printed.\n\nIf the filename ends in a “.”, only a “.” is printed.\n\nIt returns 0 if there was an extension.\n\n### Examples\n\n```\n>_ path extension ./foo.mp4\n.mp4\n\n>_ path extension ../banana\n# an empty line, status 1\n\n>_ path extension ~/.config\n# an empty line, status 1\n\n>_ path extension ~/.config.d\n.d\n\n>_ path extension ~/.config.\n.\n\n>_ set -l path (path change-extension '' ./foo.mp4)\n>_ set -l extension (path extension ./foo.mp4)\n> echo $path$extension\n# reconstructs the original path again.\n./foo.mp4\n```\n\n## “filter” subcommand\n\n```\npath filter [-z | --null-in] [-Z | --null-out] [-q | --quiet] \\\n    [-d] [-f] [-l] [-r] [-w] [-x] \\\n    [-v | --invert] [(-t | --type) TYPE] [(-p | --perm) PERMISSION] [PATH ...]\n```\n\n`path filter` returns all of the given paths that match the given checks. In all cases, the paths need to exist, nonexistent paths are always filtered.\n\nThe available filters are:\n\n- `-t` or `--type` with the options: “dir”, “file”, “link”, “block”, “char”, “fifo” and “socket”, in which case the path needs to be a directory, file, link, block device, character device, named pipe or socket, respectively.\n- `-d`, `-f` and `-l` are short for `--type=dir`, `--type=file` and `--type=link`, respectively. There are no shortcuts for the other types.\n- `-p` or `--perm` with the options: “read”, “write”, and “exec”, as well as “suid”, “sgid”, “user” (referring to the path owner) and “group” (referring to the path’s group), in which case the path needs to have all of the given permissions for the current user.\n- `-r`, `-w` and `-x` are short for `--perm=read`, `--perm=write` and `--perm=exec`, respectively. There are no shortcuts for the other permissions.\n\nNote that the path needs to be *any* of the given types, but have *all* of the given permissions. This is because having a path that is both writable and executable makes sense, but having a path that is both a directory and a file doesn’t. Links will count as the type of the linked-to file, so links to files count as files, links to directories count as directories.\n\nThe filter options can either be given as multiple options, or comma-separated - `path filter -t dir,file` or `path filter --type dir --type file` are equivalent.\n\nWith `--invert`, the meaning of the filtering is inverted - any path that wouldn’t pass (including by not existing) passes, and any path that would pass fails.\n\nWhen a path starts with `-`, `path filter` will prepend `./` to avoid it being interpreted as an option otherwise.\n\nIt returns 0 if at least one path passed the filter.\n\n`path is` is shorthand for `path filter -q`, i.e. just checking without producing output, see [The is subcommand](#cmd-path-is).\n\n### Examples\n\n```\n>_ path filter /usr/bin /usr/argagagji\n# The (hopefully) nonexistent argagagji is filtered implicitly:\n/usr/bin\n\n>_ path filter --type file /usr/bin /usr/bin/fish\n# Only fish is a file\n/usr/bin/fish\n\n>_ path filter --type file,dir --perm exec,write /usr/bin/fish /home/me\n# fish is a file, which passes, and executable, which passes,\n# but probably not writable, which fails.\n#\n# $HOME is a directory and both writable and executable, typically.\n# So it passes.\n/home/me\n\n>_ path filter -fdxw /usr/bin/fish /home/me\n# This is the same as above: \"-f\" is \"--type=file\", \"-d\" is \"--type=dir\",\n# \"-x\" is short for \"--perm=exec\" and \"-w\" short for \"--perm=write\"!\n/home/me\n\n>_ path filter -fx $PATH/*\n# Prints all possible commands - the first entry of each name is what fish would execute!\n```\n\n## “is” subcommand\n\n```\npath is [-z | --null-in] [-Z | --null-out] [-q | --quiet] \\\n    [-d] [-f] [-l] [-r] [-w] [-x] \\\n    [-v | --invert] [(-t | --type) TYPE] [(-p | --perm) PERMISSION] [PATH ...]\n```\n\n`path is` is short for `path filter -q`. It returns true if any of the given files passes the filter, but does not produce any output.\n\n`--quiet` can still be passed for compatibility but is redundant. The options are the same as for `path filter`.\n\n### Examples\n\n```\n>_ path is /usr/bin /usr/argagagji\n# /usr/bin exists, so this returns a status of 0 (true). It prints nothing.\n>_ path is /usr/argagagji\n# /usr/argagagji does not, so this returns a status of 1 (false). It also prints nothing.\n>_ path is -fx /bin/sh\n# /bin/sh is usually an executable file, so this returns true.\n```\n\n## “mtime” subcommand\n\n```\npath mtime [-z | --null-in] [-Z | --null-out] [-q | --quiet] [-R | --relative] [PATH ...]\n```\n\n`path mtime` returns the last modification time (“mtime” in unix jargon) of the given paths, in seconds since the unix epoch (the beginning of the 1st of January 1970).\n\nWith `--relative` (or `-R`), it prints the number of seconds since the modification time. It only reads the current time once at start, so in case multiple paths are given the times are all relative to the *start* of `path mtime -R` running.\n\nIf you want to know if a file is newer or older than another file, consider using `test -nt` instead. See [the test documentation](test).\n\nIt returns 0 if reading mtime for any path succeeded.\n\n### Examples\n\n```\n>_ date +%s\n# This prints the current time as seconds since the epoch\n1657217847\n\n>_ path mtime /etc/\n1657213796\n\n>_ path mtime -R /etc/\n4078\n# So /etc/ on this system was last modified a little over an hour ago\n\n# This is the same as\n>_ math (date +%s) - (path mtime /etc/)\n```\n\n## “normalize” subcommand\n\n```\npath normalize [-z | --null-in] [-Z | --null-out] [-q | --quiet] [PATH ...]\n```\n\n`path normalize` returns the normalized versions of all paths. That means it squashes duplicate “/” (except for two leading “//”), collapses “../” with earlier components and removes “.” components.\n\nUnlike `realpath` or `path resolve`, it does not make the paths absolute. It also does not resolve any symlinks. As such it can operate on non-existent paths.\n\nBecause it operates on paths as strings and doesn’t resolve symlinks, it works sort of like `pwd -L` and `cd`. E.g. `path normalize link/..` will return `.`, just like `cd link; cd ..` would return to the current directory. For a physical view of the filesystem, see `path resolve`.\n\nLeading “./” components are usually removed. But when a path starts with `-`, `path normalize` will add it instead to avoid confusion with options.\n\nIt returns 0 if any normalization was done, i.e. any given path wasn’t in canonical form.\n\n### Examples\n\n```\n>_ path normalize /usr/bin//../../etc/fish\n# The \"//\" is squashed and the \"..\" components neutralize the components before\n/etc/fish\n\n>_ path normalize /bin//bash\n# The \"//\" is squashed, but /bin isn't resolved even if your system links it to /usr/bin.\n/bin/bash\n\n>_ path normalize ./my/subdirs/../sub2\nmy/sub2\n\n>_ path normalize -- -/foo\n./-/foo\n```\n\n## “resolve” subcommand\n\n```\npath resolve [-z | --null-in] [-Z | --null-out] [-q | --quiet] [PATH ...]\n```\n\n`path resolve` returns the normalized, physical and absolute versions of all paths. That means it resolves symlinks and does what `path normalize` does: it squashes duplicate “/”, collapses “../” with earlier components and removes “.” components. Then it turns that path into the absolute path starting from the filesystem root “/”.\n\nIt is similar to `realpath`, as it creates the “real”, canonical version of the path. However, for paths that can’t be resolved, e.g. if they don’t exist or form a symlink loop, it will resolve as far as it can and normalize the rest.\n\nBecause it resolves symlinks, it works sort of like `pwd -P`. E.g. `path resolve link/..` will return the parent directory of what the link points to, just like `cd link; cd (pwd -P)/..` would go to it. For a logical view of the filesystem, see `path normalize`.\n\nIt returns 0 if any normalization or resolution was done, i.e. any given path wasn’t in canonical form.\n\n### Examples\n\n```\n>_ path resolve /bin//sh\n# The \"//\" is squashed, and /bin is resolved if your system links it to /usr/bin.\n# sh here is bash (this is common on linux systems)\n/usr/bin/bash\n\n>_ path resolve /bin/foo///bar/../baz\n# Assuming /bin exists and is a symlink to /usr/bin, but /bin/foo doesn't.\n# This resolves the /bin/ and normalizes the nonexistent rest:\n/usr/bin/foo/baz\n```\n\n## “change-extension” subcommand\n\n```\npath change-extension [-z | --null-in] [-Z | --null-out] \\\n    [-q | --quiet] EXTENSION [PATH ...]\n```\n\n`path change-extension` returns the given paths, with their extension changed to the given new extension. The extension is the part after (and including) the last “.”, unless that “.” followed a “/” or the basename is “.” or “..”, in which case there is no previous extension and the new one is simply added.\n\nIf the extension is empty, any previous extension is stripped, along with the “.”. This is, of course, the inverse of `path extension`.\n\nOne leading dot on the extension is ignored, so “.mp3” and “mp3” are treated the same.\n\nIt returns 0 if it was given any paths.\n\n### Examples\n\n```\n>_ path change-extension mp4 ./foo.wmv\n./foo.mp4\n\n>_ path change-extension .mp4 ./foo.wmv\n./foo.mp4\n\n>_ path change-extension '' ../banana\n../banana\n# but status 1, because there was no extension.\n\n>_ path change-extension '' ~/.config\n/home/alfa/.config\n# status 1\n\n>_ path change-extension '' ~/.config.d\n/home/alfa/.config\n# status 0\n\n>_ path change-extension '' ~/.config.\n/home/alfa/.config\n# status 0\n```\n\n## “sort” subcommand\n\n```\npath sort [-z | --null-in] [-Z | --null-out] \\\n    [-q | --quiet] [-r | --reverse] \\\n    [--key=basename|dirname|path] [PATH ...]\n```\n\n`path sort` returns the given paths in sorted order. They are sorted in the same order as globs - alphabetically, but with runs of numerical digits compared numerically.\n\nWith `--reverse` or `-r` the sort is reversed.\n\nWith `--key=` only the given part of the path is compared, e.g. `--key=dirname` causes only the dirname to be compared, `--key=basename` only the basename and `--key=path` causes the entire path to be compared (this is the default).\n\nWith `--unique` or `-u` the sort is deduplicated, meaning only the first of a run that have the same key is kept. So if you are sorting by basename, then only the first of each basename is used.\n\nThe sort used is stable, so sorting first by basename and then by dirname works and causes the files to be grouped according to directory.\n\nIt currently returns 0 if it was given any paths.\n\n### Examples\n\n```\n>_ path sort 10-foo 2-bar\n2-bar\n10-foo\n\n>_ path sort --reverse 10-foo 2-bar\n10-foo\n2-bar\n\n>_ path sort --unique --key=basename $fish_function_path/*.fish\n# prints a list of all function files fish would use, sorted by name.\n```\n\n## Combining `path`\n\n`path` is meant to be easy to combine with itself, other tools and fish.\n\nThis is why\n\n- `path`’s output is automatically split by fish if it goes into a command substitution, so just doing `(path ...)` handles all paths, even those containing newlines, correctly\n- `path` has `--null-in` to handle null-delimited input (typically automatically detected!), and `--null-out` to pass on null-delimited output\n\nSome examples of combining `path`:\n\n```\n# Expand all paths in the current directory, leave only executable files, and print their resolved path\npath filter -zZ -xf -- * | path resolve -z\n\n# The same thing, but using find (note -maxdepth needs to come first or find will scream)\n# (this also depends on your particular version of find)\n# Note the `-z` is unnecessary for any sensible version of find - if `path` sees a NULL,\n# it will split on NULL automatically.\nfind . -maxdepth 1 -type f -executable -print0 | path resolve -z\n\nset -l paths (path filter -p exec $PATH/fish -Z | path resolve)\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/path.html](https://fishshell.com/docs/3.7/cmds/path.html)"
- name: popd
  summary: popd removes the top directory from the directory stack and changes the working directory to the new top directory
  description: "# popd - move through directory stack\n\n## Synopsis\n\n```\npopd\n```\n\n## Description\n\n`popd` removes the top directory from the [directory stack](../interactive#directory-stack) and changes the working directory to the new top directory. Use [pushd](pushd) to add directories to the stack.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n```\npushd /usr/src\n# Working directory is now /usr/src\n# Directory stack contains /usr/src\n\npushd /usr/src/fish-shell\n# Working directory is now /usr/src/fish-shell\n# Directory stack contains /usr/src /usr/src/fish-shell\n\npopd\n# Working directory is now /usr/src\n# Directory stack contains /usr/src\n```\n\n## See Also\n\n- the [dirs](dirs) command to print the directory stack\n- the [cdh](cdh) command which provides a more intuitive way to navigate to recently visited directories.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/popd.html](https://fishshell.com/docs/3.7/cmds/popd.html)"
- name: prevd
  summary: prevd moves backwards POS positions in the history of visited directories; if the beginning of the history has been hit, a warning is printed
  description: "# prevd - move backward through directory history\n\n## Synopsis\n\n```\nprevd [-l | --list] [POS]\n```\n\n## Description\n\n`prevd` moves backwards *POS* positions in the [history of visited directories](../interactive#directory-history); if the beginning of the history has been hit, a warning is printed.\n\nIf the **-l** or **--list** flag is specified, the current history is also displayed.\n\nNote that the `cd` command limits directory history to the 25 most recently visited directories. The history is stored in the `dirprev` and `dirnext` variables which this command manipulates.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n```\ncd /usr/src\n# Working directory is now /usr/src\n\ncd /usr/src/fish-shell\n# Working directory is now /usr/src/fish-shell\n\nprevd\n# Working directory is now /usr/src\n\nnextd\n# Working directory is now /usr/src/fish-shell\n```\n\n## See Also\n\n- the [cdh](cdh) command to display a prompt to quickly navigate the history\n- the [dirh](dirh) command to print the directory history\n- the [nextd](nextd) command to move forward\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/prevd.html](https://fishshell.com/docs/3.7/cmds/prevd.html)"
- name: printf
  summary: printf uses the format string FORMAT to print the ARGUMENT arguments
  description: "# printf - display text according to a format string\n\n## Synopsis\n\n```\nprintf FORMAT [ARGUMENT ...]\n```\n\n## Description\n\n`printf` uses the format string *FORMAT* to print the *ARGUMENT* arguments. This means that it takes format specifiers in the format string and replaces each with an argument.\n\nThe *FORMAT* argument is re-used as many times as necessary to convert all of the given arguments. So `printf %s\\n flounder catfish clownfish shark` will print four lines.\n\nUnlike [echo](echo), `printf` does not append a new line unless it is specified as part of the string.\n\nIt doesn’t support any options, so there is no need for a `--` separator, which makes it easier to use for arbitrary input than `echo`. [\\[1\\]](#id2)\n\n## Format Specifiers\n\nValid format specifiers are taken from the C library function `printf(3)`:\n\n- `%d` or `%i`: Argument will be used as decimal integer (signed or unsigned)\n- `%o`: An octal unsigned integer\n- `%u`: An unsigned decimal integer - this means negative numbers will wrap around\n- `%x` or `%X`: An unsigned hexadecimal integer\n- `%f`, `%g` or `%G`: A floating-point number. `%f` defaults to 6 places after the decimal point (which is locale-dependent - e.g. in de_DE it will be a `,`). `%g` and `%G` will trim trailing zeroes and switch to scientific notation (like `%e`) if the numbers get small or large enough.\n- `%e` or `%E`: A floating-point number in scientific (XXXeYY) notation\n- `%s`: A string\n- `%b`: As a string, interpreting backslash escapes, except that octal escapes are of the form 0 or 0ooo.\n\n`%%` signifies a literal “%”.\n\nConversion can fail, e.g. “102.234” can’t losslessly convert to an integer, causing printf to print an error. If you are okay with losing information, silence errors with `2>/dev/null`.\n\nA number between the `%` and the format letter specifies the width. The result will be left-padded with spaces.\n\n## Backslash Escapes\n\nprintf also knows a number of backslash escapes:\n\n- `\\\"` double quote\n- `\\\\` backslash\n- `\\a` alert (bell)\n- `\\b` backspace\n- `\\c` produce no further output\n- `\\e` escape\n- `\\f` form feed\n- `\\n` new line\n- `\\r` carriage return\n- `\\t` horizontal tab\n- `\\v` vertical tab\n- `\\ooo` octal number (ooo is 1 to 3 digits)\n- `\\xhh` hexadecimal number (hhh is 1 to 2 digits)\n- `\\uhhhh` 16-bit Unicode character (hhhh is 4 digits)\n- `\\Uhhhhhhhh` 32-bit Unicode character (hhhhhhhh is 8 digits)\n\n## Errors and Return Status\n\nIf the given argument doesn’t work for the given format (like when you try to convert a number like 3.141592 to an integer), printf prints an error, to stderr. printf will then also return non-zero, but will still try to print as much as it can.\n\nIt will also return non-zero if no argument at all was given, in which case it will print nothing.\n\nThis printf has been imported from the printf in GNU Coreutils version 6.9. If you would like to use a newer version of printf, for example the one shipped with your OS, try `command printf`.\n\n## Example\n\n```\nprintf '%s\\t%s\\n' flounder fish\n```\n\nWill print “flounder fish” (separated with a tab character), followed by a newline character. This is useful for writing completions, as fish expects completion scripts to output the option followed by the description, separated with a tab character.\n\n```\nprintf '%s: %d' \"Number of bananas in my pocket\" 42\n```\n\nWill print “Number of bananas in my pocket: 42”, `without` a newline.\n\n## See Also\n\n- the [echo](echo) command, for simpler output\n\n## Footnotes\n\n\\[[1](#id1)\\]\n\nIn fact, while fish’s `echo` supports `--`, POSIX forbids it, so other implementations can’t be used if the input contains anything starting with `-`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/printf.html](https://fishshell.com/docs/3.7/cmds/printf.html)"
- name: prompt_hostname
  summary: prompt_hostname prints a shortened version the current hostname for use in the prompt
  description: "# prompt_hostname - print the hostname, shortened for use in the prompt\n\n## Synopsis\n\n```\nprompt_hostname\n```\n\n## Description\n\n`prompt_hostname` prints a shortened version the current hostname for use in the prompt. It will print just the first component of the hostname, everything up to the first dot.\n\n## Examples\n\n```\nfunction fish_prompt\n    echo -n (whoami)@(prompt_hostname) (prompt_pwd) '$ '\nend\n```\n\n```\n# The machine's full hostname is foo.bar.com\n>_ prompt_hostname\nfoo\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/prompt_hostname.html](https://fishshell.com/docs/3.7/cmds/prompt_hostname.html)"
- name: prompt_login
  summary: prompt_login is a function to describe the current login
  description: "# prompt_login - describe the login suitable for prompt\n\n## Synopsis\n\n```\nprompt_login\n```\n\n## Description\n\n`prompt_login` is a function to describe the current login. It will show the user, the host and also whether the shell is running in a chroot (currently Debian’s `debian_chroot` file is supported).\n\n## Examples\n\n```\nfunction fish_prompt\n    echo -n (prompt_login) (prompt_pwd) '$ '\nend\n```\n\n```\n>_ prompt_login\nroot@bananablaster\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/prompt_login.html](https://fishshell.com/docs/3.7/cmds/prompt_login.html)"
- name: prompt_pwd
  summary: prompt_pwd is a function to print the current working directory in a way suitable for prompts
  description: "# prompt_pwd - print pwd suitable for prompt\n\n## Synopsis\n\n```\nprompt_pwd\n```\n\n## Description\n\n`prompt_pwd` is a function to print the current working directory in a way suitable for prompts. It will replace the home directory with “~” and shorten every path component but the last to a default of one character.\n\nTo change the number of characters per path component, pass `--dir-length=` or set `fish_prompt_pwd_dir_length` to the number of characters. Setting it to 0 or an invalid value will disable shortening entirely. This defaults to 1.\n\nTo keep some components unshortened, pass `--full-length-dirs=` or set `fish_prompt_pwd_full_dirs` to the number of components. This defaults to 1, keeping the last component.\n\nIf any positional arguments are given, `prompt_pwd` shortens them instead of [`PWD`](../language#envvar-PWD).\n\n## Options\n\n**-d** or **--dir-length** *MAX*  \nCauses the components to be shortened to *MAX* characters each. This overrides `fish_prompt_pwd_dir_length`.\n\n**-D** or **--full-length-dirs** *NUM*  \nKeeps *NUM* components (counted from the right) as full length without shortening. This overrides `fish_prompt_pwd_full_dirs`.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## Examples\n\n```\n>_ cd ~/\n>_ echo $PWD\n/home/alfa\n\n>_ prompt_pwd\n~\n\n>_ cd /tmp/banana/sausage/with/mustard\n>_ prompt_pwd\n/t/b/s/w/mustard\n\n>_ set -g fish_prompt_pwd_dir_length 3\n>_ prompt_pwd\n/tmp/ban/sau/wit/mustard\n\n>_ prompt_pwd --full-length-dirs=2 --dir-length=1\n/t/b/s/with/mustard\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/prompt_pwd.html](https://fishshell.com/docs/3.7/cmds/prompt_pwd.html)"
- name: psub
  summary: Some shells (e.g., ksh, bash) feature a syntax that is a mix between command substitution and piping, called process substitution
  description: "# psub - perform process substitution\n\n## Synopsis\n\n```\nCOMMAND1 ( COMMAND2 | psub [-F | --fifo] [-f | --file] [(-s | --suffix) SUFFIX] )\n```\n\n## Description\n\nSome shells (e.g., ksh, bash) feature a syntax that is a mix between command substitution and piping, called process substitution. It is used to send the output of a command into the calling command, much like command substitution, but with the difference that the output is not sent through commandline arguments but through a named pipe, with the filename of the named pipe sent as an argument to the calling program. `psub` combined with a regular command substitution provides the same functionality.\n\nThe following options are available:\n\n**-f** or **--file**  \nUse a regular file instead of a named pipe to communicate with the calling process. This will cause `psub` to be significantly slower when large amounts of data are involved, but has the advantage that the reading process can seek in the stream. This is the default.\n\n**-F** or **--fifo**  \nUse a named pipe rather than a file. You should only use this if the command produces no more than 8 KiB of output. The limit on the amount of data a FIFO can buffer varies with the OS but is typically 8 KiB, 16 KiB or 64 KiB. If you use this option and the command on the left of the psub pipeline produces more output a deadlock is likely to occur.\n\n**-s** or **--suffix** *SUFFIX*  \nAppend SUFFIX to the filename.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## Example\n\n```\ndiff (sort a.txt | psub) (sort b.txt | psub)\n# shows the difference between the sorted versions of files ``a.txt`` and ``b.txt``.\n\nsource-highlight -f esc (cpp main.c | psub -f -s .c)\n# highlights ``main.c`` after preprocessing as a C source.\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/psub.html](https://fishshell.com/docs/3.7/cmds/psub.html)"
- name: pushd
  summary: The pushd function adds DIRECTORY to the top of the directory stack and makes it the current working directory
  description: "# pushd - push directory to directory stack\n\n## Synopsis\n\n```\npushd DIRECTORY\n```\n\n## Description\n\nThe `pushd` function adds *DIRECTORY* to the top of the [directory stack](../interactive#directory-stack) and makes it the current working directory. [popd](popd) will pop it off and return to the original directory.\n\nWithout arguments, it exchanges the top two directories in the stack.\n\n`pushd +NUMBER` rotates the stack counter-clockwise i.e. from bottom to top\n\n`pushd -NUMBER` rotates clockwise i.e. top to bottom.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n```\ncd ~/dir1\npushd ~/dir2\npushd ~/dir3\n# Working directory is now ~/dir3\n# Directory stack contains ~/dir2 ~/dir1\n\npushd /tmp\n# Working directory is now /tmp\n# Directory stack contains ~/dir3 ~/dir2 ~/dir1\n\npushd +1\n# Working directory is now ~/dir3\n# Directory stack contains ~/dir2 ~/dir1 /tmp\n\npopd\n# Working directory is now ~/dir2\n# Directory stack contains ~/dir1 /tmp\n```\n\n## See Also\n\n- the [dirs](dirs) command to print the directory stack\n- the [cdh](cdh) command which provides a more intuitive way to navigate to recently visited directories.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/pushd.html](https://fishshell.com/docs/3.7/cmds/pushd.html)"
- name: pwd
  summary: pwd outputs (prints) the current working directory
  description: "# pwd - output the current working directory\n\n## Synopsis\n\n```\npwd [-P | --physical]\npwd [-L | --logical]\n```\n\n## Description\n\n`pwd` outputs (prints) the current working directory.\n\nThe following options are available:\n\n**-L** or **--logical**  \nOutput the logical working directory, without resolving symlinks (default behavior).\n\n**-P** or **--physical**  \nOutput the physical working directory, with symlinks resolved.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n## See Also\n\nNavigate directories using the [directory history](../interactive#directory-history) or the [directory stack](../interactive#directory-stack)\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/pwd.html](https://fishshell.com/docs/3.7/cmds/pwd.html)"
- name: random
  summary: random generates a pseudo-random integer from a uniform distribution
  description: "# random - generate random number\n\n## Synopsis\n\n```\nrandom\nrandom SEED\nrandom START END\nrandom START STEP END\nrandom choice [ITEMS ...]\n```\n\n## Description\n\n`random` generates a pseudo-random integer from a uniform distribution. The range (inclusive) depends on the arguments.\n\nNo arguments indicate a range of 0 to 32767 (inclusive).\n\nIf one argument is specified, the internal engine will be seeded with the argument for future invocations of `random` and no output will be produced.\n\nTwo arguments indicate a range from *START* to *END* (both *START* and *END* included).\n\nThree arguments indicate a range from *START* to *END* with a spacing of *STEP* between possible outputs.\n\n`random choice` will select one random item from the succeeding arguments.\n\nThe **-h** or **--help** option displays help about using this command.\n\nNote that seeding the engine will NOT give the same result across different systems.\n\nYou should not consider `random` cryptographically secure, or even statistically accurate.\n\n## Example\n\nThe following code will count down from a random even number between 10 and 20 to 1:\n\n```\nfor i in (seq (random 10 2 20) -1 1)\n    echo $i\nend\n```\n\nAnd this will open a random picture from any of the subdirectories:\n\n```\nopen (random choice **.jpg)\n```\n\nOr, to only get even numbers from 2 to 20:\n\n```\nrandom 2 2 20\n```\n\nOr odd numbers from 1 to 3:\n\n```\nrandom 1 2 3 # or 1 2 4\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/random.html](https://fishshell.com/docs/3.7/cmds/random.html)"
- name: read
  summary: read reads from standard input and either writes the result back to standard output (for use in command substitution), or stores the result in one or more shell variables
  description: "# read - read line of input into variables\n\n## Synopsis\n\n```\nread [OPTIONS] [VARIABLE ...]\n```\n\n## Description\n\n`read` reads from standard input and either writes the result back to standard output (for use in command substitution), or stores the result in one or more shell variables. By default, `read` reads a single line and splits it into variables on spaces or tabs. Alternatively, a null character or a maximum number of characters can be used to terminate the input, and other delimiters can be given. Unlike other shells, there is no default variable (such as `REPLY`) for storing the result - instead, it is printed on standard output.\n\nThe following options are available:\n\n**-c** *CMD* or **--command** *CMD*  \nSets the initial string in the interactive mode command buffer to *CMD*.\n\n**-d** or **--delimiter** *DELIMITER*  \nSplits on *DELIMITER*. *DELIMITER* will be used as an entire string to split on, not a set of characters.\n\n**-g** or **--global**  \nMakes the variables global.\n\n**-s** or **--silent**  \nMasks characters written to the terminal, replacing them with asterisks. This is useful for reading things like passwords or other sensitive information.\n\n**-f** or **--function**  \nScopes the variable to the currently executing function. It is erased when the function ends.\n\n**-l** or **--local**  \nScopes the variable to the currently executing block. It is erased when the block ends. Outside of a block, this is the same as **--function**.\n\n**-n** or **--nchars** *NCHARS*  \nMakes `read` return after reading *NCHARS* characters or the end of the line, whichever comes first.\n\n**-p** or **--prompt** *PROMPT_CMD*  \nUses the output of the shell command *PROMPT_CMD* as the prompt for the interactive mode. The default prompt command is `set_color green; echo read; set_color normal; echo \"> \"`\n\n**-P** or **--prompt-str** *PROMPT_STR*  \nUses the *PROMPT_STR* as the prompt for the interactive mode. It is equivalent to `echo $PROMPT_STR` and is provided solely to avoid the need to frame the prompt as a command. All special characters in the string are automatically escaped before being passed to the [echo](echo) command.\n\n**-R** or **--right-prompt** *RIGHT_PROMPT_CMD*  \nUses the output of the shell command *RIGHT_PROMPT_CMD* as the right prompt for the interactive mode. There is no default right prompt command.\n\n**-S** or **--shell**  \nEnables syntax highlighting, tab completions and command termination suitable for entering shellscript code in the interactive mode. NOTE: Prior to fish 3.0, the short opt for **--shell** was **-s**, but it has been changed for compatibility with bash’s **-s** short opt for **--silent**.\n\n**-t** -or **--tokenize**  \nCauses read to split the input into variables by the shell’s tokenization rules. This means it will honor quotes and escaping. This option is of course incompatible with other options to control splitting like **--delimiter** and does not honor [`IFS`](../language#envvar-IFS) (like fish’s tokenizer). It saves the tokens in the manner they’d be passed to commands on the commandline, so e.g. `a\\ b` is stored as `a b`. Note that currently it leaves command substitutions intact along with the parentheses.\n\n**-u** or **--unexport**  \nPrevents the variables from being exported to child processes (default behaviour).\n\n**-U** or **--universal**  \nCauses the specified shell variable to be made universal.\n\n**-x** or **--export**  \nExports the variables to child processes.\n\n**-a** or **--list**  \nStores the result as a list in a single variable. This option is also available as **--array** for backwards compatibility.\n\n**-z** or **--null**  \nMarks the end of the line with the NUL character, instead of newline. This also disables interactive mode.\n\n**-L** or **--line**  \nReads each line into successive variables, and stops after each variable has been filled. This cannot be combined with the `--delimiter` option.\n\nWithout the `--line` option, `read` reads a single line of input from standard input, breaks it into tokens, and then assigns one token to each variable specified in *VARIABLES*. If there are more tokens than variables, the complete remainder is assigned to the last variable.\n\nIf no option to determine how to split like `--delimiter`, `--line` or `--tokenize` is given, the variable `IFS` is used as a list of characters to split on. Relying on the use of `IFS` is deprecated and this behaviour will be removed in future versions. The default value of `IFS` contains space, tab and newline characters. As a special case, if `IFS` is set to the empty string, each character of the input is considered a separate token.\n\nWith the `--line` option, `read` reads a line of input from standard input into each provided variable, stopping when each variable has been filled. The line is not tokenized.\n\nIf no variable names are provided, `read` enters a special case that simply provides redirection from standard input to standard output, useful for command substitution. For instance, the fish shell command below can be used to read data that should be provided via a command line argument from the console instead of hardcoding it in the command itself, allowing the command to both be reused as-is in various contexts with different input values and preventing possibly sensitive text from being included in the shell history:\n\n```\nmysql -uuser -p(read)\n```\n\nWhen running in this mode, `read` does not split the input in any way and text is redirected to standard output without any further processing or manipulation.\n\nIf `-a` or `--array` is provided, only one variable name is allowed and the tokens are stored as a list in this variable.\n\nSee the documentation for `set` for more details on the scoping rules for variables.\n\nWhen `read` reaches the end-of-file (EOF) instead of the terminator, the exit status is set to 1. Otherwise, it is set to 0.\n\nIn order to protect the shell from consuming too many system resources, `read` will only consume a maximum of 100 MiB (104857600 bytes); if the terminator is not reached before this limit then *VARIABLE* is set to empty and the exit status is set to 122. This limit can be altered with the [`fish_read_limit`](../language#envvar-fish_read_limit) variable. If set to 0 (zero), the limit is removed.\n\n## Example\n\n`read` has a few separate uses.\n\nThe following code stores the value ‘hello’ in the shell variable `foo`.\n\n```\necho hello|read foo\n```\n\nThe [while](while) command is a neat way to handle command output line-by-line:\n\n```\nprintf '%s\\n' line1 line2 line3 line4 | while read -l foo\n                  echo \"This is another line: $foo\"\n              end\n```\n\nDelimiters given via “-d” are taken as one string:\n\n```\necho a==b==c | read -d == -l a b c\necho $a # a\necho $b # b\necho $c # c\n```\n\n`--tokenize` honors quotes and escaping like the shell’s argument passing:\n\n```\necho 'a\\ b' | read -t first second\necho $first # outputs \"a b\", $second is empty\n\necho 'a\"foo bar\"b (command echo wurst)*\" \"{a,b}' | read -lt -l a b c\necho $a # outputs 'afoo barb' (without the quotes)\necho $b # outputs '(command echo wurst)* {a,b}' (without the quotes)\necho $c # nothing\n```\n\nFor an example on interactive use, see [Querying for user input](../language#user-input).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/read.html](https://fishshell.com/docs/3.7/cmds/read.html)"
- name: realpath
  summary: realpath follows all symbolic links encountered for the provided PATH, printing the absolute path resolved
  description: "# realpath - convert a path to an absolute path without symlinks\n\n## Synopsis\n\n```\nrealpath [OPTIONS] PATH\n```\n\n## Description\n\n**realpath** follows all symbolic links encountered for the provided [`PATH`](../language#envvar-PATH), printing the absolute path resolved. [fish](fish) provides a **realpath**-alike builtin intended to enrich systems where no such command is installed by default.\n\nIf a **realpath** command exists, that will be preferred. `builtin realpath` will explicitly use the fish implementation of **realpath**.\n\nThe following options are available:\n\n**-s** or **--no-symlinks**  \nDon’t resolve symlinks, only make paths absolute, squash multiple slashes and remove trailing slashes.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/realpath.html](https://fishshell.com/docs/3.7/cmds/realpath.html)"
- name: return
  summary: return halts a currently running function
  description: "# return - stop the current inner function\n\n## Synopsis\n\n```\nreturn [N]\n```\n\n## Description\n\n**return** halts a currently running function. The exit status is set to *N* if it is given. If **return** is invoked outside of a function or dot script it is equivalent to exit.\n\nIt is often added inside of a conditional block such as an [if](if) statement or a [switch](switch) statement to conditionally stop the executing function and return to the caller; it can also be used to specify the exit status of a function.\n\nIf at the top level of a script, it exits with the given status, like [exit](exit). If at the top level in an interactive session, it will set [`status`](../language#envvar-status), but not exit the shell.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\nAn implementation of the false command as a fish function:\n\n```\nfunction false\n    return 1\nend\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/return.html](https://fishshell.com/docs/3.7/cmds/return.html)"
- name: set
  summary: set manipulates shell variables
  description: "# set - display and change shell variables\n\n## Synopsis\n\n```\nset\nset (-f | --function) (-l | local) (-g | --global) (-U | --universal)\nset [-Uflg] NAME [VALUE ...]\nset [-Uflg] NAME[[INDEX ...]] [VALUE ...]\nset (-a | --append) [-flgU] NAME VALUE ...\nset (-q | --query) (-e | --erase) [-flgU] [NAME][[INDEX]] ...]\nset (-S | --show) [NAME ...]\n```\n\n## Description\n\n`set` manipulates [shell variables](../language#variables).\n\nIf both *NAME* and *VALUE* are provided, `set` assigns any values to variable *NAME*. Variables in fish are [lists](../language#variables-lists), multiple values are allowed. One or more variable *INDEX* can be specified including ranges (not for all options.)\n\nIf no *VALUE* is given, the variable will be set to the empty list.\n\nIf `set` is ran without arguments, it prints the names and values of all shell variables in sorted order. Passing [scope](../language#variables-scope) or [export](../language#variables-export) flags allows filtering this to only matching variables, so `set --local` would only show local variables.\n\nWith `--erase` and optionally a scope flag `set` will erase the matching variable (or the variable of that name in the smallest possible scope).\n\nWith `--show`, `set` will describe the given variable names, explaining how they have been defined - in which scope with which values and options.\n\nThe following options control variable scope:\n\n**-U** or **--universal**  \nSets a universal variable. The variable will be immediately available to all the user’s `fish` instances on the machine, and will be persisted across restarts of the shell.\n\n**-f** or **--function**  \nSets a variable scoped to the executing function. It is erased when the function ends.\n\n**-l** or **--local**  \nSets a locally-scoped variable in this block. It is erased when the block ends. Outside of a block, this is the same as **--function**.\n\n**-g** or **--global**  \nSets a globally-scoped variable. Global variables are available to all functions running in the same shell. They can be modified or erased.\n\nThese options modify how variables operate:\n\n**--export** or **-x**  \nCauses the specified shell variable to be exported to child processes (making it an “environment variable”).\n\n**--unexport** or **-u**  \nCauses the specified shell variable to NOT be exported to child processes.\n\n**--path**  \nTreat specified variable as a [path variable](../language#variables-path); variable will be split on colons (`:`) and will be displayed joined by colons when quoted (`echo \"$PATH\"`) or exported.\n\n**--unpath**  \nCauses variable to no longer be treated as a [path variable](../language#variables-path). Note: variables ending in “PATH” are automatically path variables.\n\nFurther options:\n\n**-a** or **--append** *NAME* *VALUE* …  \nAppends *VALUES* to the current set of values for variable **NAME**. Can be used with **--prepend** to both append and prepend at the same time. This cannot be used when assigning to a variable slice.\n\n**-p** or **--prepend** *NAME* *VALUE* …  \nPrepends *VALUES* to the current set of values for variable **NAME**. This can be used with **--append** to both append and prepend at the same time. This cannot be used when assigning to a variable slice.\n\n**-e** or **--erase** *NAME\\*\\[\\*INDEX*\\]  \nCauses the specified shell variables to be erased. Supports erasing from multiple scopes at once. Individual items in a variable at *INDEX* in brackets can be specified.\n\n**-q** or **--query** *NAME\\*\\[\\*INDEX*\\]  \nTest if the specified variable names are defined. If an *INDEX* is provided, check for items at that slot. Does not output anything, but the shell status is set to the number of variables specified that were not defined, up to a maximum of 255. If no variable was given, it also returns 255.\n\n**-n** or **--names**  \nList only the names of all defined variables, not their value. The names are guaranteed to be sorted.\n\n**-S** or **--show**  \nShows information about the given variables. If no variable names are given then all variables are shown in sorted order. It shows the scopes the given variables are set in, along with the values in each and whether or not it is exported. No other flags can be used with this option.\n\n**-L** or **--long**  \nDo not abbreviate long values when printing set variables.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nIf a variable is set to more than one value, the variable will be a list with the specified elements. If a variable is set to zero elements, it will become a list with zero elements.\n\nIf the variable name is one or more list elements, such as `PATH[1 3 7]`, only those list elements specified will be changed. If you specify a negative index when expanding or assigning to a list variable, the index will be calculated from the end of the list. For example, the index -1 means the last index of a list.\n\nThe scoping rules when creating or updating a variable are:\n\n- Variables may be explicitly set as universal, global, function, or local. Variables with the same name but in a different scope will not be changed.\n- If the scope of a variable is not explicitly set *but a variable by that name has been previously defined*, the scope of the existing variable is used. If the variable is already defined in multiple scopes, the variable with the narrowest scope will be updated.\n- If a variable’s scope is not explicitly set and there is no existing variable by that name, the variable will be local to the currently executing function. Note that this is different from using the `-l` or `--local` flag, in which case the variable will be local to the most-inner currently executing block, while without them the variable will be local to the function as a whole. If no function is executing, the variable will be set in the global scope.\n\nThe exporting rules when creating or updating a variable are identical to the scoping rules for variables:\n\n- Variables may be explicitly set to either exported or not exported. When an exported variable goes out of scope, it is unexported.\n- If a variable is not explicitly set to be exported or not exported, but has been previously defined, the previous exporting rule for the variable is kept.\n- If a variable is not explicitly set to be either exported or unexported and has never before been defined, the variable will not be exported.\n\nIn query mode, the scope to be examined can be specified. Whether the variable has to be a path variable or exported can also be specified.\n\nIn erase mode, if variable indices are specified, only the specified slices of the list variable will be erased.\n\n`set` requires all options to come before any other arguments. For example, `set flags -l` will have the effect of setting the value of the variable `flags` to ‘-l’, not making the variable local.\n\n## Exit status\n\nIn assignment mode, `set` does not modify the exit status, but passes along whatever [`status`](../language#envvar-status) was set, including by command substitutions. This allows capturing the output and exit status of a subcommand, like in `if set output (command)`.\n\nIn query mode, the exit status is the number of variables that were not found.\n\nIn erase mode, `set` exits with a zero exit status in case of success, with a non-zero exit status if the commandline was invalid, if any of the variables did not exist or was a [special read-only variable](../language#variables-special).\n\n## Examples\n\nPrint all global, exported variables:\n\n```\n> set -gx\n```\n\nSet the value of the variable \\_\\$foo\\_ to be ‘hi’.:\n\n```\n> set foo hi\n```\n\nAppend the value “there” to the variable \\$foo:\n\n```\n> set -a foo there\n```\n\nRemove \\_\\$smurf\\_ from the scope:\n\n```\n> set -e smurf\n```\n\nRemove \\_\\$smurf\\_ from the global and universal scopes:\n\n```\n> set -e -Ug smurf\n```\n\nChange the fourth element of the \\$PATH list to ~/bin:\n\n```\n> set PATH[4] ~/bin\n```\n\nOutputs the path to Python if `type -p` returns true:\n\n```\nif set python_path (type -p python)\n    echo \"Python is at $python_path\"\nend\n```\n\nSetting a variable doesn’t modify \\$status; a command substitution still will, though:\n\n```\n> echo $status\n0\n> false\n> set foo bar\n> echo $status\n1\n> true\n> set foo banana (false)\n> echo $status\n1\n```\n\n`VAR=VALUE command` sets a variable for just one command, like other shells. This runs fish with a temporary home directory:\n\n```\n> HOME=(mktemp -d) fish\n```\n\n(which is essentially the same as):\n\n```\n> begin; set -lx HOME (mktemp -d); fish; end\n```\n\n## Notes\n\n- Fish versions prior to 3.0 supported the syntax `set PATH[1] PATH[4] /bin /sbin`, which worked like `set PATH[1 4] /bin /sbin`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/set.html](https://fishshell.com/docs/3.7/cmds/set.html)"
- name: set_color
  summary: set_color is used to control the color and styling of text in the terminal
  description: "# set_color - set the terminal color\n\n## Synopsis\n\n```\nset_color [OPTIONS] VALUE\n```\n\n## Description\n\n`set_color` is used to control the color and styling of text in the terminal. *VALUE* describes that styling. *VALUE* can be a reserved color name like **red** or an RGB color value given as 3 or 6 hexadecimal digits (“F27” or “FF2277”). A special keyword **normal** resets text formatting to terminal defaults.\n\nValid colors include:\n\n- **black**, **red**, **green**, **yellow**, **blue**, **magenta**, **cyan**, **white**\n- **brblack**, **brred**, **brgreen**, **bryellow**, **brblue**, **brmagenta**, **brcyan**, **brwhite**\n\nThe *br*- (as in ‘bright’) forms are full-brightness variants of the 8 standard-brightness colors on many terminals. **brblack** has higher brightness than **black** - towards gray.\n\nAn RGB value with three or six hex digits, such as A0FF33 or f2f can be used. Fish will choose the closest supported color. A three digit value is equivalent to specifying each digit twice; e.g., `set_color 2BC` is the same as `set_color 22BBCC`. Hexadecimal RGB values can be in lower or uppercase. Depending on the capabilities of your terminal (and the level of support `set_color` has for it) the actual color may be approximated by a nearby matching reserved color name or `set_color` may not have an effect on color.\n\nA second color may be given as a desired fallback color. e.g. `set_color 124212 brblue` will instruct set_color to use *brblue* if a terminal is not capable of the exact shade of grey desired. This is very useful when an 8 or 16 color terminal might otherwise not use a color.\n\nThe following options are available:\n\n**-b** or **--background** *COLOR*  \nSets the background color.\n\n**-c** or **--print-colors**  \nPrints the given colors or a colored list of the 16 named colors.\n\n**-o** or **--bold**  \nSets bold mode.\n\n**-d** or **--dim**  \nSets dim mode.\n\n**-i** or **--italics**  \nSets italics mode.\n\n**-r** or **--reverse**  \nSets reverse mode.\n\n**-u** or **--underline**  \nSets underlined mode.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nUsing the **normal** keyword will reset foreground, background, and all formatting back to default.\n\n## Notes\n\n1.  Using the **normal** keyword will reset both background and foreground colors to whatever is the default for the terminal.\n2.  Setting the background color only affects subsequently written characters. Fish provides no way to set the background color for the entire terminal window. Configuring the window background color (and other attributes such as its opacity) has to be done using whatever mechanisms the terminal provides. Look for a config option.\n3.  Some terminals use the `--bold` escape sequence to switch to a brighter color set rather than increasing the weight of text.\n4.  `set_color` works by printing sequences of characters to standard output. If used in command substitution or a pipe, these characters will also be captured. This may or may not be desirable. Checking the exit status of `isatty stdout` before using `set_color` can be useful to decide not to colorize output in a script.\n\n## Examples\n\n```\nset_color red; echo \"Roses are red\"\nset_color blue; echo \"Violets are blue\"\nset_color 62A; echo \"Eggplants are dark purple\"\nset_color normal; echo \"Normal is nice\" # Resets the background too\n```\n\n## Terminal Capability Detection\n\nFish uses some heuristics to determine what colors a terminal supports to avoid sending sequences that it won’t understand.\n\nIn particular it will:\n\n- Enable 256 colors if [`TERM`](../language#envvar-TERM) contains “xterm”, except for known exceptions (like MacOS 10.6 Terminal.app)\n- Enable 24-bit (“true-color”) even if the \\$TERM entry only reports 256 colors. This includes modern xterm, VTE-based terminals like Gnome Terminal, Konsole and iTerm2.\n- Detect support for italics, dim, reverse and other modes.\n\nIf terminfo reports 256 color support for a terminal, 256 color support will always be enabled.\n\nTo force true-color support on or off, set [`fish_term24bit`](../language#envvar-fish_term24bit) to “1” for on and 0 for off - `set -g fish_term24bit 1`.\n\nTo debug color palette problems, `tput colors` may be useful to see the number of colors in terminfo for a terminal. Fish launched as `fish -d term_support` will include diagnostic messages that indicate the color support mode in use.\n\nThe `set_color` command uses the terminfo database to look up how to change terminal colors on whatever terminal is in use. Some systems have old and incomplete terminfo databases, and lack color information for terminals that support it. Fish assumes that all terminals can use the \\[ANSI X3.64\\]([https://en.wikipedia.org/wiki/ANSI_escape_code](https://en.wikipedia.org/wiki/ANSI_escape_code)) escape sequences if the terminfo definition indicates a color below 16 is not supported.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/set_color.html](https://fishshell.com/docs/3.7/cmds/set_color.html)"
- name: source
  summary: source evaluates the commands of the specified FILE in the current shell as a new block of code
  description: "# source - evaluate contents of file\n\n## Synopsis\n\n```\nsource FILE [ARGUMENTS ...]\nSOMECOMMAND | source\n```\n\n## Description\n\n`source` evaluates the commands of the specified *FILE* in the current shell as a new block of code. This is different from starting a new process to perform the commands (i.e. `fish < FILE`) since the commands will be evaluated by the current shell, which means that changes in shell variables will affect the current shell. If additional arguments are specified after the file name, they will be inserted into the [`argv`](../language#envvar-argv) variable. The [`argv`](../language#envvar-argv) variable will not include the name of the sourced file.\n\nfish will search the working directory to resolve relative paths but will not search [`PATH`](../language#envvar-PATH) .\n\nIf no file is specified and stdin is not the terminal, or if the file name `-` is used, stdin will be read.\n\nThe exit status of `source` is the exit status of the last job to execute. If something goes wrong while opening or reading the file, `source` exits with a non-zero status.\n\n**.** (a single period) is an alias for the `source` command. The use of **.** is deprecated in favour of `source`, and **.** will be removed in a future version of fish.\n\n`source` creates a new [local scope](../language#variables-scope); `set --local` within a sourced block will not affect variables in the enclosing scope.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n```\nsource ~/.config/fish/config.fish\n# Causes fish to re-read its initialization file.\n```\n\n## Caveats\n\nIn fish versions prior to 2.3.0, the [`argv`](../language#envvar-argv) variable would have a single element (the name of the sourced file) if no arguments are present. Otherwise, it would contain arguments without the name of the sourced file. That behavior was very confusing and unlike other shells such as bash and zsh.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/source.html](https://fishshell.com/docs/3.7/cmds/source.html)"
- name: status
  summary: With no arguments, status displays a summary of the current login and job control status of the shell
  description: "# status - query fish runtime information\n\n## Synopsis\n\n```\nstatus\nstatus is-login\nstatus is-interactive\nstatus is-block\nstatus is-breakpoint\nstatus is-command-substitution\nstatus is-no-job-control\nstatus is-full-job-control\nstatus is-interactive-job-control\nstatus current-command\nstatus current-commandline\nstatus filename\nstatus basename\nstatus dirname\nstatus fish-path\nstatus function\nstatus line-number\nstatus stack-trace\nstatus job-control CONTROL_TYPE\nstatus features\nstatus test-feature FEATURE\n```\n\n## Description\n\nWith no arguments, `status` displays a summary of the current login and job control status of the shell.\n\nThe following operations (subcommands) are available:\n\n**is-command-substitution**, **-c** or **--is-command-substitution**  \nReturns 0 if fish is currently executing a command substitution.\n\n**is-block**, **-b** or **--is-block**  \nReturns 0 if fish is currently executing a block of code.\n\n**is-breakpoint**  \nReturns 0 if fish is currently showing a prompt in the context of a [breakpoint](breakpoint) command. See also the [fish_breakpoint_prompt](fish_breakpoint_prompt) function.\n\n**is-interactive**, **-i** or **--is-interactive**  \nReturns 0 if fish is interactive - that is, connected to a keyboard.\n\n**is-login**, **-l** or **--is-login**  \nReturns 0 if fish is a login shell - that is, if fish should perform login tasks such as setting up [`PATH`](../language#envvar-PATH).\n\n**is-full-job-control** or **--is-full-job-control**  \nReturns 0 if full job control is enabled.\n\n**is-interactive-job-control** or **--is-interactive-job-control**  \nReturns 0 if interactive job control is enabled.\n\n**is-no-job-control** or **--is-no-job-control**  \nReturns 0 if no job control is enabled.\n\n**current-command**  \nPrints the name of the currently-running function or command, like the deprecated [`_`](../language#envvar-_) variable.\n\n**current-commandline**  \nPrints the entirety of the currently-running commandline, inclusive of all jobs and operators.\n\n**filename**, **current-filename**, **-f** or **--current-filename**  \nPrints the filename of the currently-running script. If the current script was called via a symlink, this will return the symlink. If the current script was received by piping into [source](source), then this will return `-`.\n\n**basename**  \nPrints just the filename of the running script, without any path components before.\n\n**dirname**  \nPrints just the path to the running script, without the actual filename itself. This can be relative to [`PWD`](../language#envvar-PWD) (including just “.”), depending on how the script was called. This is the same as passing the filename to `dirname(3)`. It’s useful if you want to use other files in the current script’s directory or similar.\n\n**fish-path**  \nPrints the absolute path to the currently executing instance of fish. This is a best-effort attempt and the exact output is down to what the platform gives fish. In some cases you might only get “fish”.\n\n**function** or **current-function**  \nPrints the name of the currently called function if able, when missing displays “Not a function” (or equivalent translated string).\n\n**line-number**, **current-line-number**, **-n** or **--current-line-number**  \nPrints the line number of the currently running script.\n\n**stack-trace**, **print-stack-trace**, **-t** or **--print-stack-trace**  \nPrints a stack trace of all function calls on the call stack.\n\n**job-control**, **-j** or **--job-control** *CONTROL_TYPE*  \nSets the job control type to *CONTROL_TYPE*, which can be **none**, **full**, or **interactive**.\n\n**features**  \nLists all available feature flags.\n\n**test-feature** *FEATURE*  \nReturns 0 when FEATURE is enabled, 1 if it is disabled, and 2 if it is not recognized.\n\n## Notes\n\nFor backwards compatibility most subcommands can also be specified as a long or short option. For example, rather than `status is-login` you can type `status --is-login`. The flag forms are deprecated and may be removed in a future release (but not before fish 4.0).\n\nYou can only specify one subcommand per invocation even if you use the flag form of the subcommand.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/status.html](https://fishshell.com/docs/3.7/cmds/status.html)"
- name: string
  summary: string performs operations on strings
  description: "# string - manipulate strings\n\n## Synopsis\n\n```\nstring collect [-a | --allow-empty] [-N | --no-trim-newlines] [STRING ...]\nstring escape [-n | --no-quoted] [--style=] [STRING ...]\nstring join [-q | --quiet] [-n | --no-empty] SEP [STRING ...]\nstring join0 [-q | --quiet] [STRING ...]\nstring length [-q | --quiet] [STRING ...]\nstring lower [-q | --quiet] [STRING ...]\nstring match [-a | --all] [-e | --entire] [-i | --ignore-case]\n             [-g | --groups-only] [-r | --regex] [-n | --index]\n             [-q | --quiet] [-v | --invert]\n             PATTERN [STRING ...]\nstring pad [-r | --right] [(-c | --char) CHAR] [(-w | --width) INTEGER]\n           [STRING ...]\nstring repeat [(-n | --count) COUNT] [(-m | --max) MAX] [-N | --no-newline]\n              [-q | --quiet] [STRING ...]\nstring replace [-a | --all] [-f | --filter] [-i | --ignore-case]\n               [-r | --regex] [-q | --quiet] PATTERN REPLACE [STRING ...]\nstring shorten [(-c | --char) CHARS] [(-m | --max) INTEGER]\n               [-N | --no-newline] [-l | --left] [-q | --quiet] [STRING ...]\nstring split [(-f | --fields) FIELDS] [(-m | --max) MAX] [-n | --no-empty]\n             [-q | --quiet] [-r | --right] SEP [STRING ...]\nstring split0 [(-f | --fields) FIELDS] [(-m | --max) MAX] [-n | --no-empty]\n              [-q | --quiet] [-r | --right] [STRING ...]\nstring sub [(-s | --start) START] [(-e | --end) END] [(-l | --length) LENGTH]\n           [-q | --quiet] [STRING ...]\nstring trim [-l | --left] [-r | --right] [(-c | --chars) CHARS]\n            [-q | --quiet] [STRING ...]\nstring unescape [--style=] [STRING ...]\nstring upper [-q | --quiet] [STRING ...]\n```\n\n## Description\n\n`string` performs operations on strings.\n\n*STRING* arguments are taken from the command line unless standard input is connected to a pipe or a file, in which case they are read from standard input, one *STRING* per line. It is an error to supply *STRING* arguments on the command line and on standard input.\n\nArguments beginning with `-` are normally interpreted as switches; `--` causes the following arguments not to be treated as switches even if they begin with `-`. Switches and required arguments are recognized only on the command line.\n\nMost subcommands accept a **-q** or **--quiet** switch, which suppresses the usual output but exits with the documented status. In this case these commands will quit early, without reading all of the available input.\n\nThe following subcommands are available.\n\n## “collect” subcommand\n\n```\nstring collect [-a | --allow-empty] [-N | --no-trim-newlines] [STRING ...]\n```\n\n`string collect` collects its input into a single output argument, without splitting the output when used in a command substitution. This is useful when trying to collect multiline output from another command into a variable. Exit status: 0 if any output argument is non-empty, or 1 otherwise.\n\nA command like `echo (cmd | string collect)` is mostly equivalent to a quoted command substitution (`echo \"$(cmd)\"`). The main difference is that the former evaluates to zero or one elements whereas the quoted command substitution always evaluates to one element due to string interpolation.\n\nIf invoked with multiple arguments instead of input, `string collect` preserves each argument separately, where the number of output arguments is equal to the number of arguments given to `string collect`.\n\nAny trailing newlines on the input are trimmed, just as with `\"$(cmd)\"` substitution. Use **--no-trim-newlines** to disable this behavior, which may be useful when running a command such as `set contents (cat filename | string collect -N)`.\n\nWith **--allow-empty**, `string collect` always prints one (empty) argument. This can be used to prevent an argument from disappearing.\n\n### Examples\n\n```\n>_ echo \"zero $(echo one\\ntwo\\nthree) four\"\nzero one\ntwo\nthree four\n\n>_ echo \\\"(echo one\\ntwo\\nthree | string collect)\\\"\n\"one\ntwo\nthree\"\n\n>_ echo \\\"(echo one\\ntwo\\nthree | string collect -N)\\\"\n\"one\ntwo\nthree\n\"\n\n>_ echo foo(true | string collect --allow-empty)bar\nfoobar\n```\n\n## “escape” and “unescape” subcommands\n\n```\nstring escape [-n | --no-quoted] [--style=] [STRING ...]\nstring unescape [--style=] [STRING ...]\n```\n\n`string escape` escapes each *STRING* in one of three ways. The first is **--style=script**. This is the default. It alters the string such that it can be passed back to `eval` to produce the original argument again. By default, all special characters are escaped, and quotes are used to simplify the output when possible. If **-n** or **--no-quoted** is given, the simplifying quoted format is not used. Exit status: 0 if at least one string was escaped, or 1 otherwise.\n\n**--style=var** ensures the string can be used as a variable name by hex encoding any non-alphanumeric characters. The string is first converted to UTF-8 before being encoded.\n\n**--style=url** ensures the string can be used as a URL by hex encoding any character which is not legal in a URL. The string is first converted to UTF-8 before being encoded.\n\n**--style=regex** escapes an input string for literal matching within a regex expression. The string is first converted to UTF-8 before being encoded.\n\n`string unescape` performs the inverse of the `string escape` command. If the string to be unescaped is not properly formatted it is ignored. For example, doing `string unescape --style=var (string escape --style=var $str)` will return the original string. There is no support for unescaping **--style=regex**.\n\n### Examples\n\n```\n>_ echo \\x07 | string escape\n\\cg\n\n>_ string escape --style=var 'a1 b2'\\u6161\na1_20_b2_E6_85_A1_\n```\n\n## “join” and “join0” subcommands\n\n```\nstring join [-q | --quiet] SEP [STRING ...]\nstring join0 [-q | --quiet] [STRING ...]\n```\n\n`string join` joins its *STRING* arguments into a single string separated by *SEP*, which can be an empty string. Exit status: 0 if at least one join was performed, or 1 otherwise. If `-n` or `--no-empty` is specified, empty strings are excluded from consideration (e.g. `string join -n + a b \"\" c` would expand to `a+b+c` not `a+b++c`).\n\n`string join0` joins its *STRING* arguments into a single string separated by the zero byte (NUL), and adds a trailing NUL. This is most useful in conjunction with tools that accept NUL-delimited input, such as `sort -z`. Exit status: 0 if at least one join was performed, or 1 otherwise.\n\nBecause Unix uses NUL as the string terminator, passing the output of `string join0` as an *argument* to a command (via a [command substitution](../language#expand-command-substitution)) won’t actually work. Fish will pass the correct bytes along, but the command won’t be able to tell where the argument ends. This is a limitation of Unix’ argument passing.\n\n### Examples\n\n```\n>_ seq 3 | string join ...\n1...2...3\n\n# Give a list of NUL-separated filenames to du (this is a GNU extension)\n>_ string join0 file1 file2 file\\nwith\\nmultiple\\nlines | du --files0-from=-\n\n# Just put the strings together without a separator\n>_ string join '' a b c\nabc\n```\n\n## “length” subcommand\n\n```\nstring length [-q | --quiet] [-V | --visible] [STRING ...]\n```\n\n`string length` reports the length of each string argument in characters. Exit status: 0 if at least one non-empty *STRING* was given, or 1 otherwise.\n\nWith **-V** or **--visible**, it uses the visible width of the arguments. That means it will discount escape sequences fish knows about, account for \\$fish_emoji_width and \\$fish_ambiguous_width. It will also count each line (separated by `\\n`) on its own, and with a carriage return (`\\r`) count only the widest stretch on a line. The intent is to measure the number of columns the *STRING* would occupy in the current terminal.\n\n### Examples\n\n```\n>_ string length 'hello, world'\n12\n\n>_ set str foo\n>_ string length -q $str; echo $status\n0\n# Equivalent to test -n \"$str\"\n\n>_ string length --visible (set_color red)foobar\n# the set_color is discounted, so this is the width of \"foobar\"\n6\n\n>_ string length --visible 🐟🐟🐟🐟\n# depending on $fish_emoji_width, this is either 4 or 8\n# in new terminals it should be\n8\n\n>_ string length --visible abcdef\\r123\n# this displays as \"123def\", so the width is 6\n6\n\n>_ string length --visible a\\nbc\n# counts \"a\" and \"bc\" as separate lines, so it prints width for each\n1\n2\n```\n\n## “lower” subcommand\n\n```\nstring lower [-q | --quiet] [STRING ...]\n```\n\n`string lower` converts each string argument to lowercase. Exit status: 0 if at least one string was converted to lowercase, else 1. This means that in conjunction with the **-q** flag you can readily test whether a string is already lowercase.\n\n## “match” subcommand\n\n```\nstring match [-a | --all] [-e | --entire] [-i | --ignore-case]\n             [-g | --groups-only] [-r | --regex] [-n | --index]\n             [-q | --quiet] [-v | --invert]\n             PATTERN [STRING ...]\n```\n\n`string match` tests each *STRING* against *PATTERN* and prints matching substrings. Only the first match for each *STRING* is reported unless **-a** or **--all** is given, in which case all matches are reported.\n\nIf you specify the **-e** or **--entire** then each matching string is printed including any prefix or suffix not matched by the pattern (equivalent to `grep` without the **-o** flag). You can, obviously, achieve the same result by prepending and appending **\\*** or **.\\*** depending on whether or not you have specified the **--regex** flag. The **--entire** flag is simply a way to avoid having to complicate the pattern in that fashion and make the intent of the `string match` clearer. Without **--entire** and **--regex**, a *PATTERN* will need to match the entire *STRING* before it will be reported.\n\nMatching can be made case-insensitive with **--ignore-case** or **-i**.\n\nIf **--groups-only** or **-g** is given, only the capturing groups will be reported - meaning the full match will be skipped. This is incompatible with **--entire** and **--invert**, and requires **--regex**. It is useful as a simple cutting tool instead of `string replace`, so you can simply choose “this part” of a string.\n\nIf **--index** or **-n** is given, each match is reported as a 1-based start position and a length. By default, PATTERN is interpreted as a glob pattern matched against each entire *STRING* argument. A glob pattern is only considered a valid match if it matches the entire *STRING*.\n\nIf **--regex** or **-r** is given, *PATTERN* is interpreted as a Perl-compatible regular expression, which does not have to match the entire *STRING*. For a regular expression containing capturing groups, multiple items will be reported for each match, one for the entire match and one for each capturing group. With this, only the matching part of the *STRING* will be reported, unless **--entire** is given.\n\nWhen matching via regular expressions, `string match` automatically sets variables for all named capturing groups (`(?<name>expression)`). It will create a variable with the name of the group, in the default scope, for each named capturing group, and set it to the value of the capturing group in the first matched argument. If a named capture group matched an empty string, the variable will be set to the empty string (like `set var \"\"`). If it did not match, the variable will be set to nothing (like `set var`). When **--regex** is used with **--all**, this behavior changes. Each named variable will contain a list of matches, with the first match contained in the first element, the second match in the second, and so on. If the group was empty or did not match, the corresponding element will be an empty string.\n\nIf **--invert** or **-v** is used the selected lines will be only those which do not match the given glob pattern or regular expression.\n\nExit status: 0 if at least one match was found, or 1 otherwise.\n\n### Match Glob Examples\n\n```\n>_ string match '?' a\na\n\n>_ string match 'a*b' axxb\naxxb\n\n>_ string match -i 'a??B' Axxb\nAxxb\n\n>_ string match -- '-*' -h foo --version bar\n# To match things that look like options, we need a `--`\n# to tell string its options end there.\n-h\n--version\n\n>_ echo 'ok?' | string match '*\\?'\nok?\n\n# Note that only the second STRING will match here.\n>_ string match 'foo' 'foo1' 'foo' 'foo2'\nfoo\n\n>_ string match -e 'foo' 'foo1' 'foo' 'foo2'\nfoo1\nfoo\nfoo2\n\n>_ string match 'foo?' 'foo1' 'foo' 'foo2'\nfoo1\nfoo2\n```\n\n### Match Regex Examples\n\n```\n>_ string match -r 'cat|dog|fish' 'nice dog'\ndog\n\n>_ string match -r -v \"c.*[12]\" {cat,dog}(seq 1 4)\ndog1\ndog2\ncat3\ndog3\ncat4\ndog4\n\n>_ string match -r -- '-.*' -h foo --version bar\n# To match things that look like options, we need a `--`\n# to tell string its options end there.\n-h\n--version\n\n>_ string match -r '(\\d\\d?):(\\d\\d):(\\d\\d)' 2:34:56\n2:34:56\n2\n34\n56\n\n>_ string match -r '^(\\w{2,4})\\1$' papa mud murmur\npapa\npa\nmurmur\nmur\n\n>_ string match -r -a -n at ratatat\n2 2\n4 2\n6 2\n\n>_ string match -r -i '0x[0-9a-f]{1,8}' 'int magic = 0xBadC0de;'\n0xBadC0de\n\n>_ echo $version\n3.1.2-1575-ga2ff32d90\n>_ string match -rq '(?<major>\\d+).(?<minor>\\d+).(?<revision>\\d+)' -- $version\n>_ echo \"You are using fish $major!\"\nYou are using fish 3!\n\n>_ string match -raq ' *(?<sentence>[^.!?]+)(?<punctuation>[.!?])?' \"hello, friend. goodbye\"\n>_ printf \"%s\\n\" -- $sentence\nhello, friend\ngoodbye\n>_ printf \"%s\\n\" -- $punctuation\n.\n\n>_ string match -rq '(?<word>hello)' 'hi'\n>_ count $word\n0\n```\n\n## “pad” and “shorten” subcommands\n\n```\nstring pad [-r | --right] [(-c | --char) CHAR] [(-w | --width) INTEGER]\n           [STRING ...]\n```\n\n`string pad` extends each *STRING* to the given visible width by adding *CHAR* to the left. That means the width of all visible characters added together, excluding escape sequences and accounting for [`fish_emoji_width`](../language#envvar-fish_emoji_width) and [`fish_ambiguous_width`](../language#envvar-fish_ambiguous_width). It is the amount of columns in a terminal the *STRING* occupies.\n\nThe escape sequences reflect what fish knows about, and how it computes its output. Your terminal might support more escapes, or not support escape sequences that fish knows about.\n\nIf **-r** or **--right** is given, add the padding after a string.\n\nIf **-c** or **--char** is given, pad with *CHAR* instead of whitespace.\n\nThe output is padded to the maximum width of all input strings. If **-w** or **--width** is given, use at least that.\n\n```\n>_ string pad -w 10 abc abcdef\n       abc\n    abcdef\n\n>_ string pad --right --char=🐟 \"fish are pretty\" \"rich. \"\nfish are pretty\nrich.  🐟🐟🐟🐟\n\n>_ string pad -w$COLUMNS (date)\n# Prints the current time on the right edge of the screen.\n```\n\n## See Also\n\n- The [printf](printf) command can do simple padding, for example `printf %10s\\n` works like `string pad -w10`.\n- [string length](string-length) with the `--visible` option can be used to show what fish thinks the width is.\n\n```\nstring shorten [(-c | --char) CHARS] [(-m | --max) INTEGER]\n               [-N | --no-newline] [-l | --left] [-q | --quiet] [STRING ...]\n```\n\n`string shorten` truncates each *STRING* to the given visible width and adds an ellipsis to indicate it. “Visible width” means the width of all visible characters added together, excluding escape sequences and accounting for [`fish_emoji_width`](../language#envvar-fish_emoji_width) and [`fish_ambiguous_width`](../language#envvar-fish_ambiguous_width). It is the amount of columns in a terminal the *STRING* occupies.\n\nThe escape sequences reflect what fish knows about, and how it computes its output. Your terminal might support more escapes, or not support escape sequences that fish knows about.\n\nIf **-m** or **--max** is given, truncate at the given width. Otherwise, the lowest non-zero width of all input strings is used. A max of 0 means no shortening takes place, all STRINGs are printed as-is.\n\nIf **-N** or **--no-newline** is given, only the first line (or last line with **--left**) of each STRING is used, and an ellipsis is added if it was multiline. This only works for STRINGs being given as arguments, multiple lines given on stdin will be interpreted as separate STRINGs instead.\n\nIf **-c** or **--char** is given, add *CHAR* instead of an ellipsis. This can also be empty or more than one character.\n\nIf **-l** or **--left** is given, remove text from the left on instead, so this prints the longest *suffix* of the string that fits. With **--no-newline**, this will take from the last line instead of the first.\n\nIf **-q** or **--quiet** is given, `string shorten` only runs for the return value - if anything would be shortened, it returns 0, else 1.\n\nThe default ellipsis is `…`. If fish thinks your system is incapable because of your locale, it will use `...` instead.\n\nThe return value is 0 if any shortening occured, 1 otherwise.\n\n```\n>_ string shorten foo foobar\n# No width was given, we infer, and \"foo\" is the shortest.\nfoo\nfo…\n\n>_ string shorten --char=\"...\" foo foobar\n# The target width is 3 because of \"foo\",\n# and our ellipsis is 3 too, so we can't really show anything.\n# This is the default ellipsis if your locale doesn't allow \"…\".\nfoo\n...\n\n>_ string shorten --char=\"\" --max 4 abcdef 123456\n# Leaving the char empty makes us not add an ellipsis\n# So this truncates at 4 columns:\nabcd\n1234\n\n>_ touch \"a multiline\"\\n\"file\"\n>_ for file in *; string shorten -N -- $file; end\n# Shorten the multiline file so we only show one line per file:\na multiline…\n\n>_ ss -p | string shorten -m$COLUMNS -c \"\"\n# `ss` from Linux' iproute2 shows socket information, but prints extremely long lines.\n# This shortens input so it fits on the screen without overflowing lines.\n\n>_ git branch | string match -rg '^\\* (.*)' | string shorten -m20\n# Take the current git branch and shorten it at 20 columns.\n# Here the branch is \"builtin-path-with-expand\"\nbuiltin-path-with-e…\n\n>_ git branch | string match -rg '^\\* (.*)' | string shorten -m20 --left\n# Taking 20 columns from the right instead:\n…in-path-with-expand\n```\n\n## See Also\n\n- [string](#cmd-string)’s `pad` subcommand does the inverse of this command, adding padding to a specific width instead.\n- The [printf](printf) command can do simple padding, for example `printf %10s\\n` works like `string pad -w10`.\n- [string length](string-length) with the `--visible` option can be used to show what fish thinks the width is.\n\n## “repeat” subcommand\n\n```\nstring repeat [(-n | --count) COUNT] [(-m | --max) MAX] [-N | --no-newline]\n              [-q | --quiet] [STRING ...]\n```\n\n`string repeat` repeats the *STRING* **-n** or **--count** times. The **-m** or **--max** option will limit the number of outputted characters (excluding the newline). This option can be used by itself or in conjunction with **--count**. If both **--count** and **--max** are present, max char will be outputed unless the final repeated string size is less than max, in that case, the string will repeat until count has been reached. Both **--count** and **--max** will accept a number greater than or equal to zero, in the case of zero, nothing will be outputed. If **-N** or **--no-newline** is given, the output won’t contain a newline character at the end. Exit status: 0 if yielded string is not empty, 1 otherwise.\n\n### Examples\n\n### Repeat Examples\n\n```\n>_ string repeat -n 2 'foo '\nfoo foo\n\n>_ echo foo | string repeat -n 2\nfoofoo\n\n>_ string repeat -n 2 -m 5 'foo'\nfoofo\n\n>_ string repeat -m 5 'foo'\nfoofo\n```\n\n## “replace” subcommand\n\n```\nstring replace [-a | --all] [-f | --filter] [-i | --ignore-case]\n               [-r | --regex] [-q | --quiet] PATTERN REPLACEMENT [STRING ...]\n```\n\n`string replace` is similar to `string match` but replaces non-overlapping matching substrings with a replacement string and prints the result. By default, *PATTERN* is treated as a literal substring to be matched.\n\nIf **-r** or **--regex** is given, *PATTERN* is interpreted as a Perl-compatible regular expression, and *REPLACEMENT* can contain C-style escape sequences like **t** as well as references to capturing groups by number or name as *\\$n* or *\\${n}*.\n\nIf you specify the **-f** or **--filter** flag then each input string is printed only if a replacement was done. This is useful where you would otherwise use this idiom: `a_cmd | string match pattern | string replace pattern new_pattern`. You can instead just write `a_cmd | string replace --filter pattern new_pattern`.\n\nExit status: 0 if at least one replacement was performed, or 1 otherwise.\n\n### Replace Literal Examples\n\n```\n>_ string replace is was 'blue is my favorite'\nblue was my favorite\n\n>_ string replace 3rd last 1st 2nd 3rd\n1st\n2nd\nlast\n\n>_ string replace -a ' ' _ 'spaces to underscores'\nspaces_to_underscores\n```\n\n### Replace Regex Examples\n\n```\n>_ string replace -r -a '[^\\d.]+' ' ' '0 one two 3.14 four 5x'\n0 3.14 5\n\n>_ string replace -r '(\\w+)\\s+(\\w+)' '$2 $1 $$' 'left right'\nright left $\n\n>_ string replace -r '\\s*newline\\s*' '\\n' 'put a newline here'\nput a\nhere\n```\n\n## “split” and “split0” subcommands\n\n```\nstring split [(-f | --fields) FIELDS] [(-m | --max) MAX] [-n | --no-empty]\n             [-q | --quiet] [-r | --right] SEP [STRING ...]\nstring split0 [(-f | --fields) FIELDS] [(-m | --max) MAX] [-n | --no-empty]\n              [-q | --quiet] [-r | --right] [STRING ...]\n```\n\n`string split` splits each *STRING* on the separator *SEP*, which can be an empty string. If **-m** or **--max** is specified, at most MAX splits are done on each *STRING*. If **-r** or **--right** is given, splitting is performed right-to-left. This is useful in combination with **-m** or **--max**. With **-n** or **--no-empty**, empty results are excluded from consideration (e.g. `hello\\n\\nworld` would expand to two strings and not three). Exit status: 0 if at least one split was performed, or 1 otherwise.\n\nUse **-f** or **--fields** to print out specific fields. FIELDS is a comma-separated string of field numbers and/or spans. Each field is one-indexed, and will be printed on separate lines. If a given field does not exist, then the command exits with status 1 and does not print anything, unless **--allow-empty** is used.\n\nSee also the **--delimiter** option of the [read](read) command.\n\n`string split0` splits each *STRING* on the zero byte (NUL). Options are the same as `string split` except that no separator is given.\n\n`split0` has the important property that its output is not further split when used in a command substitution, allowing for the command substitution to produce elements containing newlines. This is most useful when used with Unix tools that produce zero bytes, such as `find -print0` or `sort -z`. See split0 examples below.\n\n### Examples\n\n```\n>_ string split . example.com\nexample\ncom\n\n>_ string split -r -m1 / /usr/local/bin/fish\n/usr/local/bin\nfish\n\n>_ string split '' abc\na\nb\nc\n\n>_ string split --allow-empty -f1,3-4,5 '' abcd\na\nc\nd\n```\n\n### NUL Delimited Examples\n\n```\n>_ # Count files in a directory, without being confused by newlines.\n>_ count (find . -print0 | string split0)\n42\n\n>_ # Sort a list of elements which may contain newlines\n>_ set foo beta alpha\\ngamma\n>_ set foo (string join0 $foo | sort -z | string split0)\n>_ string escape $foo[1]\nalpha\\ngamma\n```\n\n## “sub” subcommand\n\n```\nstring sub [(-s | --start) START] [(-e | --end) END] [(-l | --length) LENGTH]\n           [-q | --quiet] [STRING ...]\n```\n\n`string sub` prints a substring of each string argument. The start/end of the substring can be specified with **-s**/**-e** or **--start**/**--end** followed by a 1-based index value. Positive index values are relative to the start of the string and negative index values are relative to the end of the string. The default start value is 1. The length of the substring can be specified with **-l** or **--length**. If the length or end is not specified, the substring continues to the end of each STRING. Exit status: 0 if at least one substring operation was performed, 1 otherwise. **--length** is mutually exclusive with **--end**.\n\n### Examples\n\n```\n>_ string sub --length 2 abcde\nab\n\n>_ string sub -s 2 -l 2 abcde\nbc\n\n>_ string sub --start=-2 abcde\nde\n\n>_ string sub --end=3 abcde\nabc\n\n>_ string sub -e -1 abcde\nabcd\n\n>_ string sub -s 2 -e -1 abcde\nbcd\n\n>_ string sub -s -3 -e -2 abcde\nc\n```\n\n## “trim” subcommand\n\n```\nstring trim [-l | --left] [-r | --right] [(-c | --chars) CHARS]\n            [-q | --quiet] [STRING ...]\n```\n\n`string trim` removes leading and trailing whitespace from each *STRING*. If **-l** or **--left** is given, only leading whitespace is removed. If **-r** or **--right** is given, only trailing whitespace is trimmed. The **-c** or **--chars** switch causes the characters in *CHARS* to be removed instead of whitespace. Exit status: 0 if at least one character was trimmed, or 1 otherwise.\n\n### Examples\n\n```\n>_ string trim ' abc  '\nabc\n\n>_ string trim --right --chars=yz xyzzy zany\nx\nzan\n```\n\n## “upper” subcommand\n\n```\nstring upper [-q | --quiet] [STRING ...]\n```\n\n`string upper` converts each string argument to uppercase. Exit status: 0 if at least one string was converted to uppercase, else 1. This means that in conjunction with the **-q** flag you can readily test whether a string is already uppercase.\n\n## Regular Expressions\n\nBoth the `match` and `replace` subcommand support regular expressions when used with the **-r** or **--regex** option. The dialect is that of PCRE2.\n\nIn general, special characters are special by default, so `a+` matches one or more “a”s, while `a\\+` matches an “a” and then a “+”. `(a+)` matches one or more “a”s in a capturing group (`(?:XXXX)` denotes a non-capturing group). For the replacement parameter of `replace`, `$n` refers to the n-th group of the match. In the match parameter, `\\n` (e.g. `\\1`) refers back to groups.\n\nSome features include repetitions:\n\n- `*` refers to 0 or more repetitions of the previous expression\n- `+` 1 or more\n- `?` 0 or 1.\n- `{n}` to exactly n (where n is a number)\n- `{n,m}` at least n, no more than m.\n- `{n,}` n or more\n\nCharacter classes, some of the more important:\n\n- `.` any character except newline\n- `\\d` a decimal digit and `\\D`, not a decimal digit\n- `\\s` whitespace and `\\S`, not whitespace\n- `\\w` a “word” character and `\\W`, a “non-word” character\n- `[...]` (where “…” is some characters) is a character set\n- `[^...]` is the inverse of the given character set\n- `[x-y]` is the range of characters from x-y\n- `[[:xxx:]]` is a named character set\n- `[[:^xxx:]]` is the inverse of a named character set\n- `[[:alnum:]]` : “alphanumeric”\n- `[[:alpha:]]` : “alphabetic”\n- `[[:ascii:]]` : “0-127”\n- `[[:blank:]]` : “space or tab”\n- `[[:cntrl:]]` : “control character”\n- `[[:digit:]]` : “decimal digit”\n- `[[:graph:]]` : “printing, excluding space”\n- `[[:lower:]]` : “lower case letter”\n- `[[:print:]]` : “printing, including space”\n- `[[:punct:]]` : “printing, excluding alphanumeric”\n- `[[:space:]]` : “white space”\n- `[[:upper:]]` : “upper case letter”\n- `[[:word:]]` : “same as w”\n- `[[:xdigit:]]` : “hexadecimal digit”\n\nGroups:\n\n- `(...)` is a capturing group\n- `(?:...)` is a non-capturing group\n- `\\n` is a backreference (where n is the number of the group, starting with 1)\n- `$n` is a reference from the replacement expression to a group in the match expression.\n\nAnd some other things:\n\n- `\\b` denotes a word boundary, `\\B` is not a word boundary.\n- `^` is the start of the string or line, `$` the end.\n- `|` is “alternation”, i.e. the “or”.\n\n## Comparison to other tools\n\nMost operations `string` supports can also be done by external tools. Some of these include `grep`, `sed` and `cut`.\n\nIf you are familiar with these, it is useful to know how `string` differs from them.\n\nIn contrast to these classics, `string` reads input either from stdin or as arguments. `string` also does not deal with files, so it requires redirections to be used with them.\n\nIn contrast to `grep`, `string`’s `match` defaults to glob-mode, while `replace` defaults to literal matching. If set to regex-mode, they use PCRE regular expressions, which is comparable to `grep`’s `-P` option. `match` defaults to printing just the match, which is like `grep` with `-o` (use **--entire** to enable grep-like behavior).\n\nLike `sed`’s `s/old/new/` command, `string replace` still prints strings that don’t match. `sed`’s `-n` in combination with a `/p` modifier or command is like `string replace -f`.\n\n`string split somedelimiter` is a replacement for `tr somedelimiter \\n`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string.html](https://fishshell.com/docs/3.7/cmds/string.html)"
- name: string-collect
  summary: string collect collects its input into a single output argument, without splitting the output when used in a command substitution
  description: "# string-collect - join strings into one\n\n## Synopsis\n\n```\nstring collect [-a | --allow-empty] [-N | --no-trim-newlines] [STRING ...]\n```\n\n## Description\n\n`string collect` collects its input into a single output argument, without splitting the output when used in a command substitution. This is useful when trying to collect multiline output from another command into a variable. Exit status: 0 if any output argument is non-empty, or 1 otherwise.\n\nA command like `echo (cmd | string collect)` is mostly equivalent to a quoted command substitution (`echo \"$(cmd)\"`). The main difference is that the former evaluates to zero or one elements whereas the quoted command substitution always evaluates to one element due to string interpolation.\n\nIf invoked with multiple arguments instead of input, `string collect` preserves each argument separately, where the number of output arguments is equal to the number of arguments given to `string collect`.\n\nAny trailing newlines on the input are trimmed, just as with `\"$(cmd)\"` substitution. Use **--no-trim-newlines** to disable this behavior, which may be useful when running a command such as `set contents (cat filename | string collect -N)`.\n\nWith **--allow-empty**, `string collect` always prints one (empty) argument. This can be used to prevent an argument from disappearing.\n\n## Examples\n\n```\n>_ echo \"zero $(echo one\\ntwo\\nthree) four\"\nzero one\ntwo\nthree four\n\n>_ echo \\\"(echo one\\ntwo\\nthree | string collect)\\\"\n\"one\ntwo\nthree\"\n\n>_ echo \\\"(echo one\\ntwo\\nthree | string collect -N)\\\"\n\"one\ntwo\nthree\n\"\n\n>_ echo foo(true | string collect --allow-empty)bar\nfoobar\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-collect.html](https://fishshell.com/docs/3.7/cmds/string-collect.html)"
- name: string-escape
  summary: string escape escapes each STRING in one of three ways
  description: "# string-escape - escape special characters\n\n## Synopsis\n\n```\nstring escape [-n | --no-quoted] [--style=] [STRING ...]\nstring unescape [--style=] [STRING ...]\n```\n\n## Description\n\n`string escape` escapes each *STRING* in one of three ways. The first is **--style=script**. This is the default. It alters the string such that it can be passed back to `eval` to produce the original argument again. By default, all special characters are escaped, and quotes are used to simplify the output when possible. If **-n** or **--no-quoted** is given, the simplifying quoted format is not used. Exit status: 0 if at least one string was escaped, or 1 otherwise.\n\n**--style=var** ensures the string can be used as a variable name by hex encoding any non-alphanumeric characters. The string is first converted to UTF-8 before being encoded.\n\n**--style=url** ensures the string can be used as a URL by hex encoding any character which is not legal in a URL. The string is first converted to UTF-8 before being encoded.\n\n**--style=regex** escapes an input string for literal matching within a regex expression. The string is first converted to UTF-8 before being encoded.\n\n`string unescape` performs the inverse of the `string escape` command. If the string to be unescaped is not properly formatted it is ignored. For example, doing `string unescape --style=var (string escape --style=var $str)` will return the original string. There is no support for unescaping **--style=regex**.\n\n## Examples\n\n```\n>_ echo \\x07 | string escape\n\\cg\n\n>_ string escape --style=var 'a1 b2'\\u6161\na1_20_b2_E6_85_A1_\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-escape.html](https://fishshell.com/docs/3.7/cmds/string-escape.html)"
- name: string-join
  summary: string join joins its STRING arguments into a single string separated by SEP, which can be an empty string
  description: "# string-join - join strings with delimiter\n\n## Synopsis\n\n```\nstring join [-q | --quiet] SEP [STRING ...]\nstring join0 [-q | --quiet] [STRING ...]\n```\n\n## Description\n\n`string join` joins its *STRING* arguments into a single string separated by *SEP*, which can be an empty string. Exit status: 0 if at least one join was performed, or 1 otherwise. If `-n` or `--no-empty` is specified, empty strings are excluded from consideration (e.g. `string join -n + a b \"\" c` would expand to `a+b+c` not `a+b++c`).\n\n`string join0` joins its *STRING* arguments into a single string separated by the zero byte (NUL), and adds a trailing NUL. This is most useful in conjunction with tools that accept NUL-delimited input, such as `sort -z`. Exit status: 0 if at least one join was performed, or 1 otherwise.\n\nBecause Unix uses NUL as the string terminator, passing the output of `string join0` as an *argument* to a command (via a [command substitution](../language#expand-command-substitution)) won’t actually work. Fish will pass the correct bytes along, but the command won’t be able to tell where the argument ends. This is a limitation of Unix’ argument passing.\n\n## Examples\n\n```\n>_ seq 3 | string join ...\n1...2...3\n\n# Give a list of NUL-separated filenames to du (this is a GNU extension)\n>_ string join0 file1 file2 file\\nwith\\nmultiple\\nlines | du --files0-from=-\n\n# Just put the strings together without a separator\n>_ string join '' a b c\nabc\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-join.html](https://fishshell.com/docs/3.7/cmds/string-join.html)"
- name: string-join0
  summary: string join joins its STRING arguments into a single string separated by SEP, which can be an empty string
  description: "# string-join0 - join strings with zero bytes\n\n## Synopsis\n\n```\nstring join [-q | --quiet] SEP [STRING ...]\nstring join0 [-q | --quiet] [STRING ...]\n```\n\n## Description\n\n`string join` joins its *STRING* arguments into a single string separated by *SEP*, which can be an empty string. Exit status: 0 if at least one join was performed, or 1 otherwise. If `-n` or `--no-empty` is specified, empty strings are excluded from consideration (e.g. `string join -n + a b \"\" c` would expand to `a+b+c` not `a+b++c`).\n\n`string join0` joins its *STRING* arguments into a single string separated by the zero byte (NUL), and adds a trailing NUL. This is most useful in conjunction with tools that accept NUL-delimited input, such as `sort -z`. Exit status: 0 if at least one join was performed, or 1 otherwise.\n\nBecause Unix uses NUL as the string terminator, passing the output of `string join0` as an *argument* to a command (via a [command substitution](../language#expand-command-substitution)) won’t actually work. Fish will pass the correct bytes along, but the command won’t be able to tell where the argument ends. This is a limitation of Unix’ argument passing.\n\n## Examples\n\n```\n>_ seq 3 | string join ...\n1...2...3\n\n# Give a list of NUL-separated filenames to du (this is a GNU extension)\n>_ string join0 file1 file2 file\\nwith\\nmultiple\\nlines | du --files0-from=-\n\n# Just put the strings together without a separator\n>_ string join '' a b c\nabc\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-join0.html](https://fishshell.com/docs/3.7/cmds/string-join0.html)"
- name: string-length
  summary: string length reports the length of each string argument in characters
  description: "# string-length - print string lengths\n\n## Synopsis\n\n```\nstring length [-q | --quiet] [-V | --visible] [STRING ...]\n```\n\n## Description\n\n`string length` reports the length of each string argument in characters. Exit status: 0 if at least one non-empty *STRING* was given, or 1 otherwise.\n\nWith **-V** or **--visible**, it uses the visible width of the arguments. That means it will discount escape sequences fish knows about, account for \\$fish_emoji_width and \\$fish_ambiguous_width. It will also count each line (separated by `\\n`) on its own, and with a carriage return (`\\r`) count only the widest stretch on a line. The intent is to measure the number of columns the *STRING* would occupy in the current terminal.\n\n## Examples\n\n```\n>_ string length 'hello, world'\n12\n\n>_ set str foo\n>_ string length -q $str; echo $status\n0\n# Equivalent to test -n \"$str\"\n\n>_ string length --visible (set_color red)foobar\n# the set_color is discounted, so this is the width of \"foobar\"\n6\n\n>_ string length --visible 🐟🐟🐟🐟\n# depending on $fish_emoji_width, this is either 4 or 8\n# in new terminals it should be\n8\n\n>_ string length --visible abcdef\\r123\n# this displays as \"123def\", so the width is 6\n6\n\n>_ string length --visible a\\nbc\n# counts \"a\" and \"bc\" as separate lines, so it prints width for each\n1\n2\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-length.html](https://fishshell.com/docs/3.7/cmds/string-length.html)"
- name: string-lower
  summary: string lower converts each string argument to lowercase
  description: "# string-lower - convert strings to lowercase\n\n## Synopsis\n\n```\nstring lower [-q | --quiet] [STRING ...]\n```\n\n## Description\n\n`string lower` converts each string argument to lowercase. Exit status: 0 if at least one string was converted to lowercase, else 1. This means that in conjunction with the **-q** flag you can readily test whether a string is already lowercase.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-lower.html](https://fishshell.com/docs/3.7/cmds/string-lower.html)"
- name: string-match
  summary: string match tests each STRING against PATTERN and prints matching substrings
  description: "# string-match - match substrings\n\n## Synopsis\n\n```\nstring match [-a | --all] [-e | --entire] [-i | --ignore-case]\n             [-g | --groups-only] [-r | --regex] [-n | --index]\n             [-q | --quiet] [-v | --invert]\n             PATTERN [STRING ...]\n```\n\n## Description\n\n`string match` tests each *STRING* against *PATTERN* and prints matching substrings. Only the first match for each *STRING* is reported unless **-a** or **--all** is given, in which case all matches are reported.\n\nIf you specify the **-e** or **--entire** then each matching string is printed including any prefix or suffix not matched by the pattern (equivalent to `grep` without the **-o** flag). You can, obviously, achieve the same result by prepending and appending **\\*** or **.\\*** depending on whether or not you have specified the **--regex** flag. The **--entire** flag is simply a way to avoid having to complicate the pattern in that fashion and make the intent of the `string match` clearer. Without **--entire** and **--regex**, a *PATTERN* will need to match the entire *STRING* before it will be reported.\n\nMatching can be made case-insensitive with **--ignore-case** or **-i**.\n\nIf **--groups-only** or **-g** is given, only the capturing groups will be reported - meaning the full match will be skipped. This is incompatible with **--entire** and **--invert**, and requires **--regex**. It is useful as a simple cutting tool instead of `string replace`, so you can simply choose “this part” of a string.\n\nIf **--index** or **-n** is given, each match is reported as a 1-based start position and a length. By default, PATTERN is interpreted as a glob pattern matched against each entire *STRING* argument. A glob pattern is only considered a valid match if it matches the entire *STRING*.\n\nIf **--regex** or **-r** is given, *PATTERN* is interpreted as a Perl-compatible regular expression, which does not have to match the entire *STRING*. For a regular expression containing capturing groups, multiple items will be reported for each match, one for the entire match and one for each capturing group. With this, only the matching part of the *STRING* will be reported, unless **--entire** is given.\n\nWhen matching via regular expressions, `string match` automatically sets variables for all named capturing groups (`(?<name>expression)`). It will create a variable with the name of the group, in the default scope, for each named capturing group, and set it to the value of the capturing group in the first matched argument. If a named capture group matched an empty string, the variable will be set to the empty string (like `set var \"\"`). If it did not match, the variable will be set to nothing (like `set var`). When **--regex** is used with **--all**, this behavior changes. Each named variable will contain a list of matches, with the first match contained in the first element, the second match in the second, and so on. If the group was empty or did not match, the corresponding element will be an empty string.\n\nIf **--invert** or **-v** is used the selected lines will be only those which do not match the given glob pattern or regular expression.\n\nExit status: 0 if at least one match was found, or 1 otherwise.\n\n## Examples\n\n### Match Glob Examples\n\n```\n>_ string match '?' a\na\n\n>_ string match 'a*b' axxb\naxxb\n\n>_ string match -i 'a??B' Axxb\nAxxb\n\n>_ string match -- '-*' -h foo --version bar\n# To match things that look like options, we need a `--`\n# to tell string its options end there.\n-h\n--version\n\n>_ echo 'ok?' | string match '*\\?'\nok?\n\n# Note that only the second STRING will match here.\n>_ string match 'foo' 'foo1' 'foo' 'foo2'\nfoo\n\n>_ string match -e 'foo' 'foo1' 'foo' 'foo2'\nfoo1\nfoo\nfoo2\n\n>_ string match 'foo?' 'foo1' 'foo' 'foo2'\nfoo1\nfoo2\n```\n\n### Match Regex Examples\n\n```\n>_ string match -r 'cat|dog|fish' 'nice dog'\ndog\n\n>_ string match -r -v \"c.*[12]\" {cat,dog}(seq 1 4)\ndog1\ndog2\ncat3\ndog3\ncat4\ndog4\n\n>_ string match -r -- '-.*' -h foo --version bar\n# To match things that look like options, we need a `--`\n# to tell string its options end there.\n-h\n--version\n\n>_ string match -r '(\\d\\d?):(\\d\\d):(\\d\\d)' 2:34:56\n2:34:56\n2\n34\n56\n\n>_ string match -r '^(\\w{2,4})\\1$' papa mud murmur\npapa\npa\nmurmur\nmur\n\n>_ string match -r -a -n at ratatat\n2 2\n4 2\n6 2\n\n>_ string match -r -i '0x[0-9a-f]{1,8}' 'int magic = 0xBadC0de;'\n0xBadC0de\n\n>_ echo $version\n3.1.2-1575-ga2ff32d90\n>_ string match -rq '(?<major>\\d+).(?<minor>\\d+).(?<revision>\\d+)' -- $version\n>_ echo \"You are using fish $major!\"\nYou are using fish 3!\n\n>_ string match -raq ' *(?<sentence>[^.!?]+)(?<punctuation>[.!?])?' \"hello, friend. goodbye\"\n>_ printf \"%s\\n\" -- $sentence\nhello, friend\ngoodbye\n>_ printf \"%s\\n\" -- $punctuation\n.\n\n>_ string match -rq '(?<word>hello)' 'hi'\n>_ count $word\n0\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-match.html](https://fishshell.com/docs/3.7/cmds/string-match.html)"
- name: string-pad
  summary: string pad extends each STRING to the given visible width by adding CHAR to the left
  description: "# string-pad - pad strings to a fixed width\n\n## Synopsis\n\n```\nstring pad [-r | --right] [(-c | --char) CHAR] [(-w | --width) INTEGER]\n           [STRING ...]\n```\n\n## Description\n\n`string pad` extends each *STRING* to the given visible width by adding *CHAR* to the left. That means the width of all visible characters added together, excluding escape sequences and accounting for [`fish_emoji_width`](../language#envvar-fish_emoji_width) and [`fish_ambiguous_width`](../language#envvar-fish_ambiguous_width). It is the amount of columns in a terminal the *STRING* occupies.\n\nThe escape sequences reflect what fish knows about, and how it computes its output. Your terminal might support more escapes, or not support escape sequences that fish knows about.\n\nIf **-r** or **--right** is given, add the padding after a string.\n\nIf **-c** or **--char** is given, pad with *CHAR* instead of whitespace.\n\nThe output is padded to the maximum width of all input strings. If **-w** or **--width** is given, use at least that.\n\n## Examples\n\n```\n>_ string pad -w 10 abc abcdef\n       abc\n    abcdef\n\n>_ string pad --right --char=🐟 \"fish are pretty\" \"rich. \"\nfish are pretty\nrich.  🐟🐟🐟🐟\n\n>_ string pad -w$COLUMNS (date)\n# Prints the current time on the right edge of the screen.\n```\n\n## See Also\n\n- The [printf](printf) command can do simple padding, for example `printf %10s\\n` works like `string pad -w10`.\n- [string length](string-length) with the `--visible` option can be used to show what fish thinks the width is.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-pad.html](https://fishshell.com/docs/3.7/cmds/string-pad.html)"
- name: string-repeat
  summary: string repeat repeats the STRING -n or --count times
  description: "# string-repeat - multiply a string\n\n## Synopsis\n\n```\nstring repeat [(-n | --count) COUNT] [(-m | --max) MAX] [-N | --no-newline]\n              [-q | --quiet] [STRING ...]\n```\n\n## Description\n\n`string repeat` repeats the *STRING* **-n** or **--count** times. The **-m** or **--max** option will limit the number of outputted characters (excluding the newline). This option can be used by itself or in conjunction with **--count**. If both **--count** and **--max** are present, max char will be outputed unless the final repeated string size is less than max, in that case, the string will repeat until count has been reached. Both **--count** and **--max** will accept a number greater than or equal to zero, in the case of zero, nothing will be outputed. If **-N** or **--no-newline** is given, the output won’t contain a newline character at the end. Exit status: 0 if yielded string is not empty, 1 otherwise.\n\n## Examples\n\n### Repeat Examples\n\n```\n>_ string repeat -n 2 'foo '\nfoo foo\n\n>_ echo foo | string repeat -n 2\nfoofoo\n\n>_ string repeat -n 2 -m 5 'foo'\nfoofo\n\n>_ string repeat -m 5 'foo'\nfoofo\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-repeat.html](https://fishshell.com/docs/3.7/cmds/string-repeat.html)"
- name: string-replace
  summary: string replace is similar to string match but replaces non-overlapping matching substrings with a replacement string and prints the result
  description: "# string-replace - replace substrings\n\n## Synopsis\n\n```\nstring replace [-a | --all] [-f | --filter] [-i | --ignore-case]\n               [-r | --regex] [-q | --quiet] PATTERN REPLACEMENT [STRING ...]\n```\n\n## Description\n\n`string replace` is similar to `string match` but replaces non-overlapping matching substrings with a replacement string and prints the result. By default, *PATTERN* is treated as a literal substring to be matched.\n\nIf **-r** or **--regex** is given, *PATTERN* is interpreted as a Perl-compatible regular expression, and *REPLACEMENT* can contain C-style escape sequences like **t** as well as references to capturing groups by number or name as *\\$n* or *\\${n}*.\n\nIf you specify the **-f** or **--filter** flag then each input string is printed only if a replacement was done. This is useful where you would otherwise use this idiom: `a_cmd | string match pattern | string replace pattern new_pattern`. You can instead just write `a_cmd | string replace --filter pattern new_pattern`.\n\nExit status: 0 if at least one replacement was performed, or 1 otherwise.\n\n## Examples\n\n### Replace Literal Examples\n\n```\n>_ string replace is was 'blue is my favorite'\nblue was my favorite\n\n>_ string replace 3rd last 1st 2nd 3rd\n1st\n2nd\nlast\n\n>_ string replace -a ' ' _ 'spaces to underscores'\nspaces_to_underscores\n```\n\n### Replace Regex Examples\n\n```\n>_ string replace -r -a '[^\\d.]+' ' ' '0 one two 3.14 four 5x'\n0 3.14 5\n\n>_ string replace -r '(\\w+)\\s+(\\w+)' '$2 $1 $$' 'left right'\nright left $\n\n>_ string replace -r '\\s*newline\\s*' '\\n' 'put a newline here'\nput a\nhere\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-replace.html](https://fishshell.com/docs/3.7/cmds/string-replace.html)"
- name: string-shorten
  summary: string shorten truncates each STRING to the given visible width and adds an ellipsis to indicate it
  description: "# string-shorten - shorten strings to a width, with an ellipsis\n\n## Synopsis\n\n```\nstring shorten [(-c | --char) CHARS] [(-m | --max) INTEGER]\n               [-N | --no-newline] [-l | --left] [-q | --quiet] [STRING ...]\n```\n\n## Description\n\n`string shorten` truncates each *STRING* to the given visible width and adds an ellipsis to indicate it. “Visible width” means the width of all visible characters added together, excluding escape sequences and accounting for [`fish_emoji_width`](../language#envvar-fish_emoji_width) and [`fish_ambiguous_width`](../language#envvar-fish_ambiguous_width). It is the amount of columns in a terminal the *STRING* occupies.\n\nThe escape sequences reflect what fish knows about, and how it computes its output. Your terminal might support more escapes, or not support escape sequences that fish knows about.\n\nIf **-m** or **--max** is given, truncate at the given width. Otherwise, the lowest non-zero width of all input strings is used. A max of 0 means no shortening takes place, all STRINGs are printed as-is.\n\nIf **-N** or **--no-newline** is given, only the first line (or last line with **--left**) of each STRING is used, and an ellipsis is added if it was multiline. This only works for STRINGs being given as arguments, multiple lines given on stdin will be interpreted as separate STRINGs instead.\n\nIf **-c** or **--char** is given, add *CHAR* instead of an ellipsis. This can also be empty or more than one character.\n\nIf **-l** or **--left** is given, remove text from the left on instead, so this prints the longest *suffix* of the string that fits. With **--no-newline**, this will take from the last line instead of the first.\n\nIf **-q** or **--quiet** is given, `string shorten` only runs for the return value - if anything would be shortened, it returns 0, else 1.\n\nThe default ellipsis is `…`. If fish thinks your system is incapable because of your locale, it will use `...` instead.\n\nThe return value is 0 if any shortening occured, 1 otherwise.\n\n## Examples\n\n```\n>_ string shorten foo foobar\n# No width was given, we infer, and \"foo\" is the shortest.\nfoo\nfo…\n\n>_ string shorten --char=\"...\" foo foobar\n# The target width is 3 because of \"foo\",\n# and our ellipsis is 3 too, so we can't really show anything.\n# This is the default ellipsis if your locale doesn't allow \"…\".\nfoo\n...\n\n>_ string shorten --char=\"\" --max 4 abcdef 123456\n# Leaving the char empty makes us not add an ellipsis\n# So this truncates at 4 columns:\nabcd\n1234\n\n>_ touch \"a multiline\"\\n\"file\"\n>_ for file in *; string shorten -N -- $file; end\n# Shorten the multiline file so we only show one line per file:\na multiline…\n\n>_ ss -p | string shorten -m$COLUMNS -c \"\"\n# `ss` from Linux' iproute2 shows socket information, but prints extremely long lines.\n# This shortens input so it fits on the screen without overflowing lines.\n\n>_ git branch | string match -rg '^\\* (.*)' | string shorten -m20\n# Take the current git branch and shorten it at 20 columns.\n# Here the branch is \"builtin-path-with-expand\"\nbuiltin-path-with-e…\n\n>_ git branch | string match -rg '^\\* (.*)' | string shorten -m20 --left\n# Taking 20 columns from the right instead:\n…in-path-with-expand\n```\n\n## See Also\n\n- [string](string#cmd-string)’s `pad` subcommand does the inverse of this command, adding padding to a specific width instead.\n- The [printf](printf) command can do simple padding, for example `printf %10s\\n` works like `string pad -w10`.\n- [string length](string-length) with the `--visible` option can be used to show what fish thinks the width is.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-shorten.html](https://fishshell.com/docs/3.7/cmds/string-shorten.html)"
- name: string-split
  summary: string split splits each STRING on the separator SEP, which can be an empty string
  description: "# string-split - split strings by delimiter\n\n## Synopsis\n\n```\nstring split [(-f | --fields) FIELDS] [(-m | --max) MAX] [-n | --no-empty]\n             [-q | --quiet] [-r | --right] SEP [STRING ...]\nstring split0 [(-f | --fields) FIELDS] [(-m | --max) MAX] [-n | --no-empty]\n              [-q | --quiet] [-r | --right] [STRING ...]\n```\n\n## Description\n\n`string split` splits each *STRING* on the separator *SEP*, which can be an empty string. If **-m** or **--max** is specified, at most MAX splits are done on each *STRING*. If **-r** or **--right** is given, splitting is performed right-to-left. This is useful in combination with **-m** or **--max**. With **-n** or **--no-empty**, empty results are excluded from consideration (e.g. `hello\\n\\nworld` would expand to two strings and not three). Exit status: 0 if at least one split was performed, or 1 otherwise.\n\nUse **-f** or **--fields** to print out specific fields. FIELDS is a comma-separated string of field numbers and/or spans. Each field is one-indexed, and will be printed on separate lines. If a given field does not exist, then the command exits with status 1 and does not print anything, unless **--allow-empty** is used.\n\nSee also the **--delimiter** option of the [read](read) command.\n\n`string split0` splits each *STRING* on the zero byte (NUL). Options are the same as `string split` except that no separator is given.\n\n`split0` has the important property that its output is not further split when used in a command substitution, allowing for the command substitution to produce elements containing newlines. This is most useful when used with Unix tools that produce zero bytes, such as `find -print0` or `sort -z`. See split0 examples below.\n\n## Examples\n\n```\n>_ string split . example.com\nexample\ncom\n\n>_ string split -r -m1 / /usr/local/bin/fish\n/usr/local/bin\nfish\n\n>_ string split '' abc\na\nb\nc\n\n>_ string split --allow-empty -f1,3-4,5 '' abcd\na\nc\nd\n```\n\n### NUL Delimited Examples\n\n```\n>_ # Count files in a directory, without being confused by newlines.\n>_ count (find . -print0 | string split0)\n42\n\n>_ # Sort a list of elements which may contain newlines\n>_ set foo beta alpha\\ngamma\n>_ set foo (string join0 $foo | sort -z | string split0)\n>_ string escape $foo[1]\nalpha\\ngamma\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-split.html](https://fishshell.com/docs/3.7/cmds/string-split.html)"
- name: string-split0
  summary: string split splits each STRING on the separator SEP, which can be an empty string
  description: "# string-split0 - split on zero bytes\n\n## Synopsis\n\n```\nstring split [(-f | --fields) FIELDS] [(-m | --max) MAX] [-n | --no-empty]\n             [-q | --quiet] [-r | --right] SEP [STRING ...]\nstring split0 [(-f | --fields) FIELDS] [(-m | --max) MAX] [-n | --no-empty]\n              [-q | --quiet] [-r | --right] [STRING ...]\n```\n\n## Description\n\n`string split` splits each *STRING* on the separator *SEP*, which can be an empty string. If **-m** or **--max** is specified, at most MAX splits are done on each *STRING*. If **-r** or **--right** is given, splitting is performed right-to-left. This is useful in combination with **-m** or **--max**. With **-n** or **--no-empty**, empty results are excluded from consideration (e.g. `hello\\n\\nworld` would expand to two strings and not three). Exit status: 0 if at least one split was performed, or 1 otherwise.\n\nUse **-f** or **--fields** to print out specific fields. FIELDS is a comma-separated string of field numbers and/or spans. Each field is one-indexed, and will be printed on separate lines. If a given field does not exist, then the command exits with status 1 and does not print anything, unless **--allow-empty** is used.\n\nSee also the **--delimiter** option of the [read](read) command.\n\n`string split0` splits each *STRING* on the zero byte (NUL). Options are the same as `string split` except that no separator is given.\n\n`split0` has the important property that its output is not further split when used in a command substitution, allowing for the command substitution to produce elements containing newlines. This is most useful when used with Unix tools that produce zero bytes, such as `find -print0` or `sort -z`. See split0 examples below.\n\n## Examples\n\n```\n>_ string split . example.com\nexample\ncom\n\n>_ string split -r -m1 / /usr/local/bin/fish\n/usr/local/bin\nfish\n\n>_ string split '' abc\na\nb\nc\n\n>_ string split --allow-empty -f1,3-4,5 '' abcd\na\nc\nd\n```\n\n### NUL Delimited Examples\n\n```\n>_ # Count files in a directory, without being confused by newlines.\n>_ count (find . -print0 | string split0)\n42\n\n>_ # Sort a list of elements which may contain newlines\n>_ set foo beta alpha\\ngamma\n>_ set foo (string join0 $foo | sort -z | string split0)\n>_ string escape $foo[1]\nalpha\\ngamma\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-split0.html](https://fishshell.com/docs/3.7/cmds/string-split0.html)"
- name: string-sub
  summary: string sub prints a substring of each string argument
  description: "# string-sub - extract substrings\n\n## Synopsis\n\n```\nstring sub [(-s | --start) START] [(-e | --end) END] [(-l | --length) LENGTH]\n           [-q | --quiet] [STRING ...]\n```\n\n## Description\n\n`string sub` prints a substring of each string argument. The start/end of the substring can be specified with **-s**/**-e** or **--start**/**--end** followed by a 1-based index value. Positive index values are relative to the start of the string and negative index values are relative to the end of the string. The default start value is 1. The length of the substring can be specified with **-l** or **--length**. If the length or end is not specified, the substring continues to the end of each STRING. Exit status: 0 if at least one substring operation was performed, 1 otherwise. **--length** is mutually exclusive with **--end**.\n\n## Examples\n\n```\n>_ string sub --length 2 abcde\nab\n\n>_ string sub -s 2 -l 2 abcde\nbc\n\n>_ string sub --start=-2 abcde\nde\n\n>_ string sub --end=3 abcde\nabc\n\n>_ string sub -e -1 abcde\nabcd\n\n>_ string sub -s 2 -e -1 abcde\nbcd\n\n>_ string sub -s -3 -e -2 abcde\nc\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-sub.html](https://fishshell.com/docs/3.7/cmds/string-sub.html)"
- name: string-trim
  summary: string trim removes leading and trailing whitespace from each STRING
  description: "# string-trim - remove trailing whitespace\n\n## Synopsis\n\n```\nstring trim [-l | --left] [-r | --right] [(-c | --chars) CHARS]\n            [-q | --quiet] [STRING ...]\n```\n\n## Description\n\n`string trim` removes leading and trailing whitespace from each *STRING*. If **-l** or **--left** is given, only leading whitespace is removed. If **-r** or **--right** is given, only trailing whitespace is trimmed. The **-c** or **--chars** switch causes the characters in *CHARS* to be removed instead of whitespace. Exit status: 0 if at least one character was trimmed, or 1 otherwise.\n\n## Examples\n\n```\n>_ string trim ' abc  '\nabc\n\n>_ string trim --right --chars=yz xyzzy zany\nx\nzan\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-trim.html](https://fishshell.com/docs/3.7/cmds/string-trim.html)"
- name: string-unescape
  summary: string escape escapes each STRING in one of three ways
  description: "# string-unescape - expand escape sequences\n\n## Synopsis\n\n```\nstring escape [-n | --no-quoted] [--style=] [STRING ...]\nstring unescape [--style=] [STRING ...]\n```\n\n## Description\n\n`string escape` escapes each *STRING* in one of three ways. The first is **--style=script**. This is the default. It alters the string such that it can be passed back to `eval` to produce the original argument again. By default, all special characters are escaped, and quotes are used to simplify the output when possible. If **-n** or **--no-quoted** is given, the simplifying quoted format is not used. Exit status: 0 if at least one string was escaped, or 1 otherwise.\n\n**--style=var** ensures the string can be used as a variable name by hex encoding any non-alphanumeric characters. The string is first converted to UTF-8 before being encoded.\n\n**--style=url** ensures the string can be used as a URL by hex encoding any character which is not legal in a URL. The string is first converted to UTF-8 before being encoded.\n\n**--style=regex** escapes an input string for literal matching within a regex expression. The string is first converted to UTF-8 before being encoded.\n\n`string unescape` performs the inverse of the `string escape` command. If the string to be unescaped is not properly formatted it is ignored. For example, doing `string unescape --style=var (string escape --style=var $str)` will return the original string. There is no support for unescaping **--style=regex**.\n\n## Examples\n\n```\n>_ echo \\x07 | string escape\n\\cg\n\n>_ string escape --style=var 'a1 b2'\\u6161\na1_20_b2_E6_85_A1_\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-unescape.html](https://fishshell.com/docs/3.7/cmds/string-unescape.html)"
- name: string-upper
  summary: string upper converts each string argument to uppercase
  description: "# string-upper - convert strings to uppercase\n\n## Synopsis\n\n```\nstring upper [-q | --quiet] [STRING ...]\n```\n\n## Description\n\n`string upper` converts each string argument to uppercase. Exit status: 0 if at least one string was converted to uppercase, else 1. This means that in conjunction with the **-q** flag you can readily test whether a string is already uppercase.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/string-upper.html](https://fishshell.com/docs/3.7/cmds/string-upper.html)"
- name: suspend
  summary: suspend suspends execution of the current shell by sending it a SIGTSTP signal, returning to the controlling process
  description: "# suspend - suspend the current shell\n\n## Synopsis\n\n```\nsuspend [--force]\n```\n\n## Description\n\n`suspend` suspends execution of the current shell by sending it a SIGTSTP signal, returning to the controlling process. It can be resumed later by sending it a SIGCONT. In order to prevent suspending a shell that doesn’t have a controlling process, it will not suspend the shell if it is a login shell. This requirement is bypassed if the **--force** option is given or the shell is not interactive.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/suspend.html](https://fishshell.com/docs/3.7/cmds/suspend.html)"
- name: switch
  summary: switch performs one of several blocks of commands, depending on whether a specified value equals one of several globbed values
  description: "# switch - conditionally execute a block of commands\n\n## Synopsis\n\n```\nswitch VALUE; [case [GLOB ...]; [COMMANDS ...]; ...] end\n```\n\n## Description\n\n`switch` performs one of several blocks of commands, depending on whether a specified value equals one of several globbed values. `case` is used together with the `switch` statement in order to determine which block should be executed.\n\nEach `case` command is given one or more parameters. The first `case` command with a parameter that matches the string specified in the switch command will be evaluated. `case` parameters may contain globs. These need to be escaped or quoted in order to avoid regular glob expansion using filenames.\n\nNote that fish does not fall through on case statements. Only the first matching case is executed.\n\nNote that [break](break) cannot be used to exit a case/switch block early like in other languages. It can only be used in loops.\n\nNote that command substitutions in a case statement will be evaluated even if its body is not taken. All substitutions, including command substitutions, must be performed before the value can be compared against the parameter.\n\n## Example\n\nIf the variable `$animal` contains the name of an animal, the following code would attempt to classify it:\n\n```\nswitch $animal\n    case cat\n        echo evil\n    case wolf dog human moose dolphin whale\n        echo mammal\n    case duck goose albatross\n        echo bird\n    case shark trout stingray\n        echo fish\n    case '*'\n        echo I have no idea what a $animal is\nend\n```\n\nIf the above code was run with `$animal` set to `whale`, the output would be `mammal`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/switch.html](https://fishshell.com/docs/3.7/cmds/switch.html)"
- name: test
  summary: Tests the expression given and sets the exit status to 0 if true, and 1 if false
  description: "# test - perform tests on files and text\n\n## Synopsis\n\n```\ntest [EXPRESSION]\n[ [EXPRESSION] ]\n```\n\n## Description\n\nTests the expression given and sets the exit status to 0 if true, and 1 if false. An expression is made up of one or more operators and their arguments.\n\nThe first form (`test`) is preferred. For compatibility with other shells, the second form is available: a matching pair of square brackets (`[ [EXPRESSION] ]`).\n\nThis test is mostly POSIX-compatible.\n\nWhen using a variable as an argument for a test operator you should almost always enclose it in double-quotes. There are only two situations it is safe to omit the quote marks. The first is when the argument is a literal string with no whitespace or other characters special to the shell (e.g., semicolon). For example, `test -b /my/file`. The second is using a variable that expands to exactly one element including if that element is the empty string (e.g., `set x ''`). If the variable is not set, set but with no value, or set to more than one value you must enclose it in double-quotes. For example, `test \"$x\" = \"$y\"`. Since it is always safe to enclose variables in double-quotes when used as `test` arguments that is the recommended practice.\n\n## Operators for files and directories\n\n**-b** *FILE*  \nReturns true if *FILE* is a block device.\n\n**-c** *FILE*  \nReturns true if *FILE* is a character device.\n\n**-d** *FILE*  \nReturns true if *FILE* is a directory.\n\n**-e** *FILE*  \nReturns true if *FILE* exists.\n\n**-f** *FILE*  \nReturns true if *FILE* is a regular file.\n\n**-g** *FILE*  \nReturns true if *FILE* has the set-group-ID bit set.\n\n**-G** *FILE*  \nReturns true if *FILE* exists and has the same group ID as the current user.\n\n**-k** *FILE*  \nReturns true if *FILE* has the sticky bit set. If the OS does not support the concept it returns false. See [https://en.wikipedia.org/wiki/Sticky_bit](https://en.wikipedia.org/wiki/Sticky_bit).\n\n**-L** *FILE*  \nReturns true if *FILE* is a symbolic link.\n\n**-O** *FILE*  \nReturns true if *FILE* exists and is owned by the current user.\n\n**-p** *FILE*  \nReturns true if *FILE* is a named pipe.\n\n**-r** *FILE*  \nReturns true if *FILE* is marked as readable.\n\n**-s** *FILE*  \nReturns true if the size of *FILE* is greater than zero.\n\n**-S** *FILE*  \nReturns true if *FILE* is a socket.\n\n**-t** *FD*  \nReturns true if the file descriptor *FD* is a terminal (TTY).\n\n**-u** *FILE*  \nReturns true if *FILE* has the set-user-ID bit set.\n\n**-w** *FILE*  \nReturns true if *FILE* is marked as writable; note that this does not check if the filesystem is read-only.\n\n**-x** *FILE*  \nReturns true if *FILE* is marked as executable.\n\n## Operators to compare files and directories\n\n*FILE1* **-nt** *FILE2*  \nReturns true if *FILE1* is newer than *FILE2*, or *FILE1* exists and *FILE2* does not.\n\n*FILE1* **-ot** *FILE2*  \nReturns true if *FILE1* is older than *FILE2*, or *FILE2* exists and *FILE1* does not.\n\n*FILE1* **-ef** *FILE1*  \nReturns true if *FILE1* and *FILE2* refer to the same file.\n\n## Operators for text strings\n\n*STRING1* **=** *STRING2*  \nReturns true if the strings *STRING1* and *STRING2* are identical.\n\n*STRING1* **!=** *STRING2*  \nReturns true if the strings *STRING1* and *STRING2* are not identical.\n\n**-n** *STRING*  \nReturns true if the length of *STRING* is non-zero.\n\n**-z** *STRING*  \nReturns true if the length of *STRING* is zero.\n\n## Operators to compare and examine numbers\n\n*NUM1* **-eq** *NUM2*  \nReturns true if *NUM1* and *NUM2* are numerically equal.\n\n*NUM1* **-ne** *NUM2*  \nReturns true if *NUM1* and *NUM2* are not numerically equal.\n\n*NUM1* **-gt** *NUM2*  \nReturns true if *NUM1* is greater than *NUM2*.\n\n*NUM1* **-ge** *NUM2*  \nReturns true if *NUM1* is greater than or equal to *NUM2*.\n\n*NUM1* **-lt** *NUM2*  \nReturns true if *NUM1* is less than *NUM2*.\n\n*NUM1* **-le** *NUM2*  \nReturns true if *NUM1* is less than or equal to *NUM2*.\n\nBoth integers and floating point numbers are supported.\n\n## Operators to combine expressions\n\n*COND1* **-a** *COND2*  \nReturns true if both *COND1* and *COND2* are true.\n\n*COND1* **-o** *COND2*  \nReturns true if either *COND1* or *COND2* are true.\n\nExpressions can be inverted using the **!** operator:\n\n**!** *EXPRESSION*  \nReturns true if *EXPRESSION* is false, and false if *EXPRESSION* is true.\n\nExpressions can be grouped using parentheses.\n\n**(** *EXPRESSION* **)**  \nReturns the value of *EXPRESSION*.\n\nNote that parentheses will usually require escaping with `\\(` to avoid being interpreted as a command substitution.\n\n## Examples\n\nIf the `/tmp` directory exists, copy the `/etc/motd` file to it:\n\n```\nif test -d /tmp\n    cp /etc/motd /tmp/motd\nend\n```\n\nIf the variable `MANPATH` is defined and not empty, print the contents. (If `MANPATH` is not defined, then it will expand to zero arguments, unless quoted.)\n\n```\nif test -n \"$MANPATH\"\n    echo $MANPATH\nend\n```\n\nParentheses and the `-o` and `-a` operators can be combined to produce more complicated expressions. In this example, success is printed if there is a `/foo` or `/bar` file as well as a `/baz` or `/bat` file.\n\n```\nif test \\( -f /foo -o -f /bar \\) -a \\( -f /baz -o -f /bat \\)\n    echo Success.\nend\n```\n\nNumerical comparisons will simply fail if one of the operands is not a number:\n\n```\nif test 42 -eq \"The answer to life, the universe and everything\"\n    echo So long and thanks for all the fish # will not be executed\nend\n```\n\nA common comparison is with [`status`](../language#envvar-status):\n\n```\nif test $status -eq 0\n    echo \"Previous command succeeded\"\nend\n```\n\nThe previous test can likewise be inverted:\n\n```\nif test ! $status -eq 0\n    echo \"Previous command failed\"\nend\n```\n\nwhich is logically equivalent to the following:\n\n```\nif test $status -ne 0\n    echo \"Previous command failed\"\nend\n```\n\n## Standards\n\n`test` implements a subset of the [IEEE Std 1003.1-2008 (POSIX.1) standard](https://www.unix.com/man-page/posix/1p/test/). The following exceptions apply:\n\n- The `<` and `>` operators for comparing strings are not implemented.\n- Because this test is a shell builtin and not a standalone utility, using the -c flag on a special file descriptors like standard input and output may not return the same result when invoked from within a pipe as one would expect when invoking the `test` utility in another shell.\n\nIn cases such as this, one can use `command` `test` to explicitly use the system’s standalone `test` rather than this `builtin` `test`.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/test.html](https://fishshell.com/docs/3.7/cmds/test.html)"
- name: time
  summary: time causes fish to measure how long a command takes and print the results afterwards
  description: "# time - measure how long a command or block takes\n\n## Synopsis\n\n```\ntime COMMAND\n```\n\n## Description\n\n`time` causes fish to measure how long a command takes and print the results afterwards. The command can be a simple fish command or a block. The results can not currently be redirected.\n\nFor checking timing after a command has completed, check [\\$CMD_DURATION](../language#variables-special).\n\nYour system most likely also has a `time` command. To use that use something like `command time`, as in `command time sleep 10`. Because it’s not inside fish, it won’t have access to fish functions and won’t be able to time blocks and such.\n\n## How to interpret the output\n\nTime outputs a few different values. Let’s look at an example:\n\n```\n> time string repeat -n 10000000 y\\n | command grep y >/dev/null\n________________________________________________________\nExecuted in  805.98 millis    fish           external\n   usr time  798.88 millis  763.88 millis   34.99 millis\n   sys time  141.22 millis   40.20 millis  101.02 millis\n```\n\nThe time after “Executed in” is what is known as the “wall-clock time”. It is simply a measure of how long it took from the start of the command until it finished. Typically it is reasonably close to [`CMD_DURATION`](../language#envvar-CMD_DURATION), except for a slight skew because the two are taken at slightly different times.\n\nThe other times are all measures of CPU time. That means they measure how long the CPU was used in this part, and they count multiple cores separately. So a program with four threads using all CPU for a second will have a time of 4 seconds.\n\nThe “usr” time is how much CPU time was spent inside the program itself, the “sys” time is how long was spent in the kernel on behalf of that program.\n\nThe “fish” time is how much CPU was spent in fish, the “external” time how much was spent in external commands.\n\nSo in this example, since `string` is a builtin, everything that `string repeat` did is accounted to fish. Any time it spends doing syscalls like `write()` is accounted for in the fish/sys time.\n\nAnd `grep` here is explicitly invoked as an external command, so its times will be counted in the “external” column.\n\nNote that, as in this example, the CPU times can add up to more than the execution time. This is because things can be done in parallel - `grep` can match while `string repeat` writes.\n\n## Example\n\n(for obvious reasons exact results will vary on your system)\n\n```\n>_ time sleep 1s\n\n________________________________________________________\nExecuted in    1,01 secs   fish           external\n   usr time    2,32 millis    0,00 micros    2,32 millis\n   sys time    0,88 millis  877,00 micros    0,00 millis\n\n>_ time for i in 1 2 3; sleep 1s; end\n\n________________________________________________________\nExecuted in    3,01 secs   fish           external\n   usr time    9,16 millis    2,94 millis    6,23 millis\n   sys time    0,23 millis    0,00 millis    0,23 millis\n```\n\nInline variable assignments need to follow the `time` keyword:\n\n```\n>_ time a_moment=1.5m sleep $a_moment\n\n________________________________________________________\nExecuted in   90.00 secs      fish           external\n   usr time    4.62 millis    4.62 millis    0.00 millis\n   sys time    2.35 millis    0.41 millis    1.95 millis\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/time.html](https://fishshell.com/docs/3.7/cmds/time.html)"
- name: trap
  summary: trap is a wrapper around the fish event delivery framework
  description: "# trap - perform an action when the shell receives a signal\n\n## Synopsis\n\n```\ntrap [OPTIONS] [[ARG] REASON ... ]\n```\n\n## Description\n\n`trap` is a wrapper around the fish event delivery framework. It exists for backwards compatibility with POSIX shells. For other uses, it is recommended to define an [event handler](../language#event).\n\nThe following parameters are available:\n\n*ARG*  \nCommand to be executed on signal delivery.\n\n*REASON*  \nName of the event to trap. For example, a signal like `INT` or `SIGINT`, or the special symbol `EXIT`.\n\n**-l** or **--list-signals**  \nPrints a list of signal names.\n\n**-p** or **--print**  \nPrints all defined signal handlers.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nIf *ARG* and *REASON* are both specified, *ARG* is the command to be executed when the event specified by *REASON* occurs (e.g., the signal is delivered).\n\nIf *ARG* is absent (and there is a single *REASON*) or `-`, each specified signal is reset to its original disposition (the value it had upon entrance to the shell). If *ARG* is the null string the signal specified by each *REASON* is ignored by the shell and by the commands it invokes.\n\nIf *ARG* is not present and **-p** has been supplied, then the trap commands associated with each *REASON* are displayed. If no arguments are supplied or if only **-p** is given, `trap` prints the list of commands associated with each signal.\n\nSignal names are case insensitive and the `SIG` prefix is optional. Trapping a signal will prevent fish from exiting in response to that signal.\n\nThe exit status is 1 if any *REASON* is invalid; otherwise trap returns 0.\n\n## Example\n\n```\ntrap \"status --print-stack-trace\" SIGUSR1\n# Prints a stack trace each time the SIGUSR1 signal is sent to the shell.\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/trap.html](https://fishshell.com/docs/3.7/cmds/trap.html)"
- name: 'true'
  summary: true sets the exit status to 0
  description: "# true - return a successful result\n\n## Synopsis\n\n```\ntrue\n```\n\n## Description\n\n`true` sets the exit status to 0.\n\n**:** (a single colon) is an alias for the `true` command.\n\n## See Also\n\n- [false](false) command\n- [\\$status](../language#variables-status) variable\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/true.html](https://fishshell.com/docs/3.7/cmds/true.html)"
- name: Tutorial
  summary: Fish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly
  description: "# Tutorial\n\n## Why fish?\n\nFish is a fully-equipped command line shell (like bash or zsh) that is smart and user-friendly. Fish supports powerful features like syntax highlighting, autosuggestions, and tab completions that just work, with nothing to learn or configure.\n\nIf you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then fish might be just what you’re looking for!\n\n## Getting started\n\nOnce installed, just type in `fish` into your current shell to try it out!\n\nYou will be greeted by the standard fish prompt, which means you are all set up and can start using fish:\n\n```\n> fish\nWelcome to fish, the friendly interactive shell\nType help for instructions on how to use fish\nyou@hostname ~>\n```\n\nThis prompt that you see above is the fish default prompt: it shows your username, hostname, and working directory. - to change this prompt see [how to change your prompt](interactive#prompt) - to switch to fish permanently see [Default Shell](index#default-shell).\n\nFrom now on, we’ll pretend your prompt is just a `>` to save space.\n\n## Learning fish\n\nThis tutorial assumes a basic understanding of command line shells and Unix commands, and that you have a working copy of fish.\n\nIf you have a strong understanding of other shells, and want to know what fish does differently, search for the magic phrase *unlike other shells*, which is used to call out important differences.\n\nOr, if you want a quick overview over the differences to other shells like Bash, see [Fish For Bash Users](fish_for_bash_users#fish-for-bash-users).\n\nFor the full, detailed description of how to use fish interactively, see [Interactive Use](interactive#interactive).\n\nFor a comprehensive description of fish’s scripting language, see [The Fish Language](language#language).\n\n## Running Commands\n\nFish runs commands like other shells: you type a command, followed by its arguments. Spaces are separators:\n\n```\n> echo hello world\nhello world\n```\n\nThis runs the command `echo` with the arguments `hello` and `world`. In this case that’s the same as one argument `hello world`, but in many cases it’s not. If you need to pass an argument that includes a space, you can [escape](language#escapes) with a backslash, or [quote](language#quotes) it using single or double quotes:\n\n```\n> mkdir My\\ Files\n# Makes a directory called \"My Files\", with a space in the name\n> cp ~/Some\\ File 'My Files'\n# Copies a file called \"Some File\" in the home directory to \"My Files\"\n> ls \"My Files\"\nSome File\n```\n\n## Getting Help\n\nRun `help` to open fish’s help in a web browser, and `man` with the page (like `fish-language`) to open it in a man page. You can also ask for help with a specific command, for example, `help set` to open in a web browser, or `man set` to see it in the terminal.\n\n```\n> man set\nset - handle shell variables\n  Synopsis...\n```\n\nTo open this section, use `help getting-help`.\n\nFish works by running commands, which are often also installed on your computer. Usually these commands also provide help in the man system, so you can get help for them there. Try `man ls` to get help on your computer’s `ls` command.\n\n## Syntax Highlighting\n\nYou’ll quickly notice that fish performs syntax highlighting as you type. Invalid commands are colored red by default:\n\n``` highlight\n> /bin/mkd\n```\n\nA command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:\n\n```\n> /bin/mkdir\n```\n\nValid file paths are underlined as you type them:\n\n``` highlight\n> cat ~/somefi\n```\n\nThis tells you that there exists a file that starts with `somefi`, which is useful feedback as you type.\n\nThese colors, and many more, can be changed by running `fish_config`, or by modifying [color variables](interactive#variables-color) directly.\n\nFor example, if you want to disable (almost) all coloring:\n\n```\nfish_config theme choose none\n```\n\nThis picks the “none” theme. To see all themes:\n\n```\nfish_config theme show\n```\n\nJust running `fish_config` will open up a browser interface that allows you to pick from the available themes.\n\n## Wildcards\n\nFish supports the familiar wildcard `*`. To list all JPEG files:\n\n```\n> ls *.jpg\nlena.jpg\nmeena.jpg\nsanta maria.jpg\n```\n\nYou can include multiple wildcards:\n\n```\n> ls l*.p*\nlena.png\nlesson.pdf\n```\n\nThe recursive wildcard `**` searches directories recursively:\n\n```\n> ls /var/**.log\n/var/log/system.log\n/var/run/sntp.log\n```\n\nIf that directory traversal is taking a long time, you can Control+C out of it.\n\nFor more, see [Wildcards](language#expand-wildcard).\n\n## Pipes and Redirections\n\nYou can pipe between commands with the usual vertical bar:\n\n```\n> echo hello world | wc\n      1       2      12\n```\n\nstdin and stdout can be redirected via the familiar `<` and `>`. stderr is redirected with a `2>`.\n\n```\n> grep fish < /etc/shells > ~/output.txt 2> ~/errors.txt\n```\n\nTo redirect stdout and stderr into one file, you can use `&>`:\n\n```\n> make &> make_output.txt\n```\n\nFor more, see [Input and output redirections](language#redirects) and [Pipes](language#pipes).\n\n## Autosuggestions\n\nAs you type fish will suggest commands to the right of the cursor, in gray. For example:\n\n``` highlight\n> /bin/hostname\n```\n\nIt knows about paths and options:\n\n``` highlight\n> grep --ignore-case\n```\n\nAnd history too. Type a command once, and you can re-summon it by just typing a few letters:\n\n``` highlight\n> rsync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo\n```\n\nTo accept the autosuggestion, hit → (right arrow) or Control+F. To accept a single word of the autosuggestion, Alt+→ (right arrow). If the autosuggestion is not what you want, just ignore it.\n\nIf you don’t like autosuggestions, you can disable them by setting `$fish_autosuggestion_enabled` to 0:\n\n```\nset -g fish_autosuggestion_enabled 0\n```\n\n## Tab Completions\n\nA rich set of tab completions work “out of the box”.\n\nPress Tab and fish will attempt to complete the command, argument, or path:\n\n``` highlight\n> /priTab => /private/\n```\n\nIf there’s more than one possibility, it will list them:\n\n``` highlight\n> ~/stuff/sTab\n~/stuff/script.sh  (command)  ~/stuff/sources/  (directory)\n```\n\nHit tab again to cycle through the possibilities. The part in parentheses there (that “command” and “directory”) is the completion description. It’s just a short hint to explain what kind of argument it is.\n\nfish can also complete many commands, like git branches:\n\n``` highlight\n> git merge prTab => git merge prompt_designer\n> git checkout bTab\nbuiltin_list_io_merge (Branch)  builtin_set_color (Branch) busted_events (Tag)\n```\n\nTry hitting tab and see what fish can do!\n\n## Variables\n\nLike other shells, a dollar sign followed by a variable name is replaced with the value of that variable:\n\n```\n> echo My home directory is $HOME\nMy home directory is /home/tutorial\n```\n\nThis is known as variable substitution, and it also happens in double quotes, but not single quotes:\n\n```\n> echo \"My current directory is $PWD\"\nMy current directory is /home/tutorial\n> echo 'My current directory is $PWD'\nMy current directory is $PWD\n```\n\nUnlike other shells, fish has an ordinary command to set variables: `set`, which takes a variable name, and then its value.\n\n```\n> set name 'Mister Noodle'\n> echo $name\nMister Noodle\n```\n\n(Notice the quotes: without them, `Mister` and `Noodle` would have been separate arguments, and `$name` would have been made into a list of two elements.)\n\nUnlike other shells, variables are not further split after substitution:\n\n```\n> mkdir $name\n> ls\nMister Noodle\n```\n\nIn bash, this would have created two directories “Mister” and “Noodle”. In fish, it created only one: the variable had the value “Mister Noodle”, so that is the argument that was passed to `mkdir`, spaces and all.\n\nYou can erase (or “delete”) a variable with `-e` or `--erase`\n\n```\n> set -e MyVariable\n> env | grep MyVariable\n(no output)\n```\n\nFor more, see [Variable expansion](language#expand-variable).\n\n## Exports (Shell Variables)\n\nSometimes you need to have a variable available to an external command, often as a setting. For example many programs like `git` or `man` read the `$PAGER` variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include `$BROWSER`, `$LANG` (to configure your language) and `$PATH`. You’ll note these are written in ALLCAPS, but that’s just a convention.\n\nTo give a variable to an external command, it needs to be “exported”. This is done with a flag to `set`, either `--export` or just `-x`.\n\n```\n> set -x MyVariable SomeValue\n> env | grep MyVariable\nMyVariable=SomeValue\n```\n\nIt can also be unexported with `--unexport` or `-u`.\n\nThis works the other way around as well! If fish is started by something else, it inherits that parents exported variables. So if your terminal emulator starts fish, and it exports `$LANG` set to `en_US.UTF-8`, fish will receive that setting. And whatever started your terminal emulator also gave *it* some variables that it will then pass on unless it specifically decides not to. This is how fish usually receives the values for things like `$LANG`, `$PATH` and `$TERM`, without you having to specify them again.\n\nExported variables can be local or global or universal - “exported” is not a [scope](language#variables-scope)! Usually you’d make them global via `set -gx MyVariable SomeValue`.\n\nFor more, see [Exporting variables](language#variables-export).\n\n## Lists\n\nThe `set` command above used quotes to ensure that `Mister Noodle` was one argument. If it had been two arguments, then `name` would have been a list of length 2. In fact, all variables in fish are really lists, that can contain any number of values, or none at all.\n\nSome variables, like `$PWD`, only have one value. By convention, we talk about that variable’s value, but we really mean its first (and only) value.\n\nOther variables, like `$PATH`, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n```\n\nVariables whose name ends in “PATH” are automatically split on colons to become lists. They are joined using colons when exported to subcommands. This is for compatibility with other tools, which expect \\$PATH to use colons. You can also explicitly add this quirk to a variable with `set --path`, or remove it with `set --unpath`.\n\nLists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.\n\nGet the length of a list with `count`:\n\n```\n> count $PATH\n5\n```\n\nYou can append (or prepend) to a list by setting the list to itself, with some additional arguments. Here we append /usr/local/bin to \\$PATH:\n\n```\n> set PATH $PATH /usr/local/bin\n```\n\nYou can access individual elements with square brackets. Indexing starts at 1 from the beginning, and -1 from the end:\n\n```\n> echo $PATH\n/usr/bin /bin /usr/sbin /sbin /usr/local/bin\n> echo $PATH[1]\n/usr/bin\n> echo $PATH[-1]\n/usr/local/bin\n```\n\nYou can also access ranges of elements, known as “slices”:\n\n```\n> echo $PATH[1..2]\n/usr/bin /bin\n> echo $PATH[-1..2]\n/usr/local/bin /sbin /usr/sbin /bin\n```\n\nYou can iterate over a list (or a slice) with a for loop:\n\n```\nfor val in $PATH\n  echo \"entry: $val\"\nend\n# Will print:\n# entry: /usr/bin/\n# entry: /bin\n# entry: /usr/sbin\n# entry: /sbin\n# entry: /usr/local/bin\n```\n\nLists adjacent to other lists or strings are expanded as [cartesian products](language#cartesian-product) unless quoted (see [Variable expansion](language#expand-variable)):\n\n```\n> set a 1 2 3\n> set 1 a b c\n> echo $a$1\n1a 2a 3a 1b 2b 3b 1c 2c 3c\n> echo $a\" banana\"\n1 banana 2 banana 3 banana\n> echo \"$a banana\"\n1 2 3 banana\n```\n\nThis is similar to [Brace expansion](language#expand-brace).\n\nFor more, see [Lists](language#variables-lists).\n\n## Command Substitutions\n\nCommand substitutions use the output of one command as an argument to another. Unlike other shells, fish does not use backticks \\`\\` for command substitutions. Instead, it uses parentheses with or without a dollar:\n\n```\n> echo In (pwd), running $(uname)\nIn /home/tutorial, running FreeBSD\n```\n\nA common idiom is to capture the output of a command in a variable:\n\n```\n> set os (uname)\n> echo $os\nLinux\n```\n\nCommand substitutions without a dollar are not expanded within quotes, so the version with a dollar is simpler:\n\n```\n> touch \"testing_$(date +%s).txt\"\n> ls *.txt\ntesting_1360099791.txt\n```\n\nUnlike other shells, fish does not split command substitutions on any whitespace (like spaces or tabs), only newlines. Usually this is a big help because unix commands operate on a line-by-line basis. Sometimes it can be an issue with commands like `pkg-config` that print what is meant to be multiple arguments on a single line. To split it on spaces too, use `string split`.\n\n```\n> printf '%s\\n' (pkg-config --libs gio-2.0)\n-lgio-2.0 -lgobject-2.0 -lglib-2.0\n> printf '%s\\n' (pkg-config --libs gio-2.0 | string split -n \" \")\n-lgio-2.0\n-lgobject-2.0\n-lglib-2.0\n```\n\nIf you need a command substitutions output as one argument, without any splits, use quoted command substitution:\n\n```\n> echo \"first line\nsecond line\" > myfile\n> set myfile \"$(cat myfile)\"\n> printf '|%s|' $myfile\n|first line\nsecond line|\n```\n\nFor more, see [Command substitution](language#expand-command-substitution).\n\n## Separating Commands (Semicolon)\n\nLike other shells, fish allows multiple commands either on separate lines or the same line.\n\nTo write them on the same line, use the semicolon (“;”). That means the following two examples are equivalent:\n\n```\necho fish; echo chips\n\n# or\necho fish\necho chips\n```\n\nThis is useful interactively to enter multiple commands. In a script it’s easier to read if the commands are on separate lines.\n\n## Exit Status\n\nWhen a command exits, it returns a status code as a non-negative integer (that’s a whole number \\>= 0).\n\nUnlike other shells, fish stores the exit status of the last command in `$status` instead of `$?`.\n\n```\n> false\n> echo $status\n1\n```\n\nThis indicates how the command fared - 0 usually means success, while the others signify kinds of failure. For instance fish’s `set --query` returns the number of variables it queried that weren’t set - `set --query PATH` usually returns 0, `set --query arglbargl boogagoogoo` usually returns 2.\n\nThere is also a `$pipestatus` list variable for the exit statuses [\\[1\\]](#id3) of processes in a pipe.\n\nFor more, see [The status variable](language#variables-status).\n\n\\[[1](#id2)\\]\n\nor “stati” if you prefer, or “statūs” if you’ve time-travelled from ancient Rome or work as a latin teacher\n\n## Combiners (And, Or, Not)\n\nfish supports the familiar `&&` and `||` to combine commands, and `!` to negate them:\n\n```\n> ./configure && make && sudo make install\n```\n\nHere, `make` is only executed if `./configure` succeeds (returns 0), and `sudo make install` is only executed if both `./configure` and `make` succeed.\n\nfish also supports [and](cmds/and), [or](cmds/or), and [not](cmds/not). The first two are job modifiers and have lower precedence. Example usage:\n\n```\n> cp file1 file1_bak && cp file2 file2_bak; and echo \"Backup successful\"; or echo \"Backup failed\"\nBackup failed\n```\n\nAs mentioned in [the section on the semicolon](#tut-semicolon), this can also be written in multiple lines, like so:\n\n```\ncp file1 file1_bak && cp file2 file2_bak\nand echo \"Backup successful\"\nor echo \"Backup failed\"\n```\n\n## Conditionals (If, Else, Switch)\n\nUse [if](cmds/if) and [else](cmds/else) to conditionally execute code, based on the exit status of a command.\n\n```\nif grep fish /etc/shells\n    echo Found fish\nelse if grep bash /etc/shells\n    echo Found bash\nelse\n    echo Got nothing\nend\n```\n\nTo compare strings or numbers or check file properties (whether a file exists or is writeable and such), use [test](cmds/test), like\n\n```\nif test \"$fish\" = \"flounder\"\n    echo FLOUNDER\nend\n\n# or\n\nif test \"$number\" -gt 5\n    echo $number is greater than five\nelse\n    echo $number is five or less\nend\n\n# or\n\n# This test is true if the path /etc/hosts exists\n# - it could be a file or directory or symlink (or possibly something else).\nif test -e /etc/hosts\n    echo We most likely have a hosts file\nelse\n    echo We do not have a hosts file\nend\n```\n\n[Combiners](#tut-combiners) can also be used to make more complex conditions, like\n\n```\nif command -sq fish; and grep fish /etc/shells\n    echo fish is installed and configured\nend\n```\n\nFor even more complex conditions, use [begin](cmds/begin) and [end](cmds/end) to group parts of them.\n\nThere is also a [switch](cmds/switch) command:\n\n```\nswitch (uname)\ncase Linux\n    echo Hi Tux!\ncase Darwin\n    echo Hi Hexley!\ncase FreeBSD NetBSD DragonFly\n    echo Hi Beastie!\ncase '*'\n    echo Hi, stranger!\nend\n```\n\nAs you see, [case](cmds/case) does not fall through, and can accept multiple arguments or (quoted) wildcards.\n\nFor more, see [Conditions](language#syntax-conditional).\n\n## Functions\n\nA fish function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in “numbered variables” like `$1`, but instead in a single list `$argv`. To create a function, use the [function](cmds/function) builtin:\n\n```\nfunction say_hello\n    echo Hello $argv\nend\nsay_hello\n# prints: Hello\nsay_hello everybody!\n# prints: Hello everybody!\n```\n\nUnlike other shells, fish does not have aliases or special prompt syntax. Functions take their place. [\\[2\\]](#id5)\n\nYou can list the names of all functions with the [functions](cmds/functions) builtin (note the plural!). fish starts out with a number of functions:\n\n```\n> functions\nN_, abbr, alias, bg, cd, cdh, contains_seq, dirh, dirs, disown, down-or-search, edit_command_buffer, export, fg, fish_add_path, fish_breakpoint_prompt, fish_clipboard_copy, fish_clipboard_paste, fish_config, fish_default_key_bindings, fish_default_mode_prompt, fish_git_prompt, fish_hg_prompt, fish_hybrid_key_bindings, fish_indent, fish_is_root_user, fish_job_summary, fish_key_reader, fish_md5, fish_mode_prompt, fish_npm_helper, fish_opt, fish_print_git_action, fish_print_hg_root, fish_prompt, fish_sigtrap_handler, fish_svn_prompt, fish_title, fish_update_completions, fish_vcs_prompt, fish_vi_cursor, fish_vi_key_bindings, funced, funcsave, grep, help, history, hostname, isatty, kill, la, ll, ls, man, nextd, open, popd, prevd, prompt_hostname, prompt_pwd, psub, pushd, realpath, seq, setenv, suspend, trap, type, umask, up-or-search, vared, wait\n```\n\nYou can see the source for any function by passing its name to `functions`:\n\n```\n> functions ls\nfunction ls --description 'List contents of directory'\n    command ls -G $argv\nend\n```\n\nFor more, see [Functions](language#syntax-function).\n\n\\[[2](#id4)\\]\n\nThere is a function called [alias](cmds/alias), but it’s just a shortcut to make functions. fish also provides [abbreviations](interactive#abbreviations), through the [abbr](cmds/abbr#cmd-abbr) command.\n\n## Loops\n\nWhile loops:\n\n```\nwhile true\n    echo \"Loop forever\"\nend\n# Prints:\n# Loop forever\n# Loop forever\n# Loop forever\n# yes, this really will loop forever. Unless you abort it with ctrl-c.\n```\n\nFor loops can be used to iterate over a list. For example, a list of files:\n\n```\nfor file in *.txt\n    cp $file $file.bak\nend\n```\n\nIterating over a list of numbers can be done with `seq`:\n\n```\nfor x in (seq 5)\n    touch file_$x.txt\nend\n```\n\nFor more, see [Loops and blocks](language#syntax-loops-and-blocks).\n\n## Prompt\n\nUnlike other shells, there is no prompt variable like `PS1`. To display your prompt, fish executes the [fish_prompt](cmds/fish_prompt) function and uses its output as the prompt. And if it exists, fish also executes the [fish_right_prompt](cmds/fish_right_prompt) function and uses its output as the right prompt.\n\nYou can define your own prompt from the command line:\n\n```\n> function fish_prompt; echo \"New Prompt % \"; end\nNew Prompt % _\n```\n\nThen, if you are happy with it, you can save it to disk by typing `funcsave fish_prompt`. This saves the prompt in `~/.config/fish/functions/fish_prompt.fish`. (Or, if you want, you can create that file manually from the start.)\n\nMultiple lines are OK. Colors can be set via [set_color](cmds/set_color), passing it named ANSI colors, or hex RGB values:\n\n```\nfunction fish_prompt\n    set_color purple\n    date \"+%m/%d/%y\"\n    set_color F00\n    echo (pwd) '>' (set_color normal)\nend\n```\n\nThis prompt would look like:\n\n``` highlight\n02/06/13\n/home/tutorial > _\n```\n\nYou can choose among some sample prompts by running `fish_config` for a web UI or `fish_config prompt` for a simpler version inside your terminal.\n\n## \\$PATH\n\n`$PATH` is an environment variable containing the directories that fish searches for commands. Unlike other shells, \\$PATH is a [list](#tut-lists), not a colon-delimited string.\n\nFish takes care to set `$PATH` to a default, but typically it is just inherited from fish’s parent process and is set to a value that makes sense for the system - see [Exports](#tut-exports).\n\nTo prepend /usr/local/bin and /usr/sbin to `$PATH`, you can write:\n\n```\n> set PATH /usr/local/bin /usr/sbin $PATH\n```\n\nTo remove /usr/local/bin from `$PATH`, you can write:\n\n```\n> set PATH (string match -v /usr/local/bin $PATH)\n```\n\nFor compatibility with other shells and external commands, \\$PATH is a [path variable](language#variables-path), and so will be joined with colons (not spaces) when you quote it:\n\n```\n> echo \"$PATH\"\n/usr/local/sbin:/usr/local/bin:/usr/bin\n```\n\nand it will be exported like that, and when fish starts it splits the \\$PATH it receives into a list on colon.\n\nYou can do so directly in `config.fish`, like you might do in other shells with `.profile`. See [this example](#path-example).\n\nA faster way is to use the [fish_add_path](cmds/fish_add_path) function, which adds given directories to the path if they aren’t already included. It does this by modifying the `$fish_user_paths` [universal variable](#tut-universal), which is automatically prepended to `$PATH`. For example, to permanently add `/usr/local/bin` to your `$PATH`, you could write:\n\n```\n> fish_add_path /usr/local/bin\n```\n\nThe advantage is that you don’t have to go mucking around in files: just run this once at the command line, and it will affect the current session and all future instances too. You can also add this line to [config.fish](#tut-config), as it only adds the component if necessary.\n\nOr you can modify \\$fish_user_paths yourself, but you should be careful *not* to append to it unconditionally in config.fish, or it will grow longer and longer.\n\n## Startup (Where’s .bashrc?)\n\nFish starts by executing commands in `~/.config/fish/config.fish`. You can create it if it does not exist.\n\nIt is possible to directly create functions and variables in `config.fish` file, using the commands shown above. For example:\n\n```\n> cat ~/.config/fish/config.fish\n\nset -x PATH $PATH /sbin/\n\nfunction ll\n    ls -lh $argv\nend\n```\n\nHowever, it is more common and efficient to use autoloading functions and universal variables.\n\nIf you want to organize your configuration, fish also reads commands in .fish files in `~/.config/fish/conf.d/`. See [Configuration Files](language#configuration) for the details.\n\n## Autoloading Functions\n\nWhen fish encounters a command, it attempts to autoload a function for that command, by looking for a file with the name of that command in `~/.config/fish/functions/`.\n\nFor example, if you wanted to have a function `ll`, you would add a text file `ll.fish` to `~/.config/fish/functions`:\n\n```\n> cat ~/.config/fish/functions/ll.fish\nfunction ll\n    ls -lh $argv\nend\n```\n\nThis is the preferred way to define your prompt as well:\n\n```\n> cat ~/.config/fish/functions/fish_prompt.fish\nfunction fish_prompt\n    echo (pwd) \"> \"\nend\n```\n\nSee the documentation for [funced](cmds/funced) and [funcsave](cmds/funcsave) for ways to create these files automatically, and [\\$fish_function_path](language#syntax-function-autoloading) to control their location.\n\n## Universal Variables\n\nA universal variable is a variable whose value is shared across all instances of fish, now and in the future – even after a reboot. You can make a variable universal with `set -U`:\n\n```\n> set -U EDITOR vim\n```\n\nNow in another shell:\n\n```\n> echo $EDITOR\nvim\n```\n\n## Ready for more?\n\nIf you want to learn more about fish, there is [lots of detailed documentation](index#intro), the [official gitter channel](https://gitter.im/fish-shell/fish-shell), an [official mailing list](https://lists.sourceforge.net/lists/listinfo/fish-users), and the [github page](https://github.com/fish-shell/fish-shell/).\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/tutorial.html](https://fishshell.com/docs/3.7/tutorial.html)"
- name: type
  summary: With no options, type indicates how each NAME would be interpreted if used as a command name
  description: "# type - locate a command and describe its type\n\n## Synopsis\n\n```\ntype [OPTIONS] NAME [...]\n```\n\n## Description\n\nWith no options, **type** indicates how each *NAME* would be interpreted if used as a command name.\n\nThe following options are available:\n\n**-a** or **--all**  \nPrints all of possible definitions of the specified names.\n\n**-s** or **--short**  \nSuppresses function expansion when used with no options or with **-a**/**--all**.\n\n**-f** or **--no-functions**  \nSuppresses function and builtin lookup.\n\n**-t** or **--type**  \nPrints `function`, `builtin`, or `file` if *NAME* is a shell function, builtin, or disk file, respectively.\n\n**-p** or **--path**  \nPrints the path to *NAME* if *NAME* resolves to an executable file in [`PATH`](../language#envvar-PATH), the path to the script containing the definition of the function *NAME* if *NAME* resolves to a function loaded from a file on disk (i.e. not interactively defined at the prompt), or nothing otherwise.\n\n**-P** or **--force-path**  \nReturns the path to the executable file *NAME*, presuming *NAME* is found in the [`PATH`](../language#envvar-PATH) environment variable, or nothing otherwise. **--force-path** explicitly resolves only the path to executable files in [`PATH`](../language#envvar-PATH), regardless of whether *NAME* is shadowed by a function or builtin with the same name.\n\n**-q** or **--query**  \nSuppresses all output; this is useful when testing the exit status. For compatibility with old fish versions this is also **--quiet**.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nThe **-q**, **-p**, **-t** and **-P** flags (and their long flag aliases) are mutually exclusive. Only one can be specified at a time.\n\n`type` returns 0 if at least one entry was found, 1 otherwise, and 2 for invalid options or option combinations.\n\n## Example\n\n```\n>_ type fg\nfg is a builtin\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/type.html](https://fishshell.com/docs/3.7/cmds/type.html)"
- name: ulimit
  summary: ulimit sets or outputs the resource usage limits of the shell and any processes spawned by it
  description: "# ulimit - set or get resource usage limits\n\n## Synopsis\n\n```\nulimit [OPTIONS] [LIMIT]\n```\n\n## Description\n\n`ulimit` sets or outputs the resource usage limits of the shell and any processes spawned by it. If a new limit value is omitted, the current value of the limit of the resource is printed; otherwise, the specified limit is set to the new value.\n\nUse one of the following switches to specify which resource limit to set or report:\n\n**-b** or **--socket-buffers**  \nThe maximum size of socket buffers.\n\n**-c** or **--core-size**  \nThe maximum size of core files created. By setting this limit to zero, core dumps can be disabled.\n\n**-d** or **--data-size**  \nThe maximum size of a process’ data segment.\n\n**-e** or **--nice**  \nControls the maximum nice value; on Linux, this value is subtracted from 20 to give the effective value.\n\n**-f** or **--file-size**  \nThe maximum size of files created by a process.\n\n**-i** or **--pending-signals**  \nThe maximum number of signals that may be queued.\n\n**-l** or **--lock-size**  \nThe maximum size that may be locked into memory.\n\n**-m** or **--resident-set-size**  \nThe maximum resident set size.\n\n**-n** or **--file-descriptor-count**  \nThe maximum number of open file descriptors.\n\n**-q** or **--queue-size**  \nThe maximum size of data in POSIX message queues.\n\n**-r** or **--realtime-priority**  \nThe maximum realtime scheduling priority.\n\n**-s** or **--stack-size**  \nThe maximum stack size.\n\n**-t** or **--cpu-time**  \nThe maximum amount of CPU time in seconds.\n\n**-u** or **--process-count**  \nThe maximum number of processes available to the current user.\n\n**-w** or **--swap-size**  \nThe maximum swap space available to the current user.\n\n**-v** or **--virtual-memory-size**  \nThe maximum amount of virtual memory available to the shell.\n\n**-y** or **--realtime-maxtime**  \nThe maximum contiguous realtime CPU time in microseconds.\n\n**-K** or **--kernel-queues**  \nThe maximum number of kqueues (kernel queues) for the current user.\n\n**-P** or **--ptys**  \nThe maximum number of pseudo-terminals for the current user.\n\n**-T** or **--threads**  \nThe maximum number of simultaneous threads for the current user.\n\nNote that not all these limits are available in all operating systems; consult the documentation for `setrlimit` in your operating system.\n\nThe value of limit can be a number in the unit specified for the resource or one of the special values `hard`, `soft`, or `unlimited`, which stand for the current hard limit, the current soft limit, and no limit, respectively.\n\nIf limit is given, it is the new value of the specified resource. If no option is given, then **-f** is assumed. Values are in kilobytes, except for **-t**, which is in seconds and **-n** and **-u**, which are unscaled values. The exit status is 0 unless an invalid option or argument is supplied, or an error occurs while setting a new limit.\n\n`ulimit` also accepts the following options that determine what type of limit to set:\n\n**-H** or **--hard**  \nSets hard resource limit.\n\n**-S** or **--soft**  \nSets soft resource limit.\n\nA hard limit can only be decreased. Once it is set it cannot be increased; a soft limit may be increased up to the value of the hard limit. If neither **-H** nor **-S** is specified, both the soft and hard limits are updated when assigning a new limit value, and the soft limit is used when reporting the current value.\n\nThe following additional options are also understood by `ulimit`:\n\n**-a** or **--all**  \nPrints all current limits.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nThe `fish` implementation of `ulimit` should behave identically to the implementation in bash, except for these differences:\n\n- Fish `ulimit` supports GNU-style long options for all switches.\n- Fish `ulimit` does not support the **-p** option for getting the pipe size. The bash implementation consists of a compile-time check that empirically guesses this number by writing to a pipe and waiting for SIGPIPE. Fish does not do this because this method of determining pipe size is unreliable. Depending on bash version, there may also be further additional limits to set in bash that do not exist in fish.\n- Fish `ulimit` does not support getting or setting multiple limits in one command, except reporting all values using the **-a** switch.\n\n## Example\n\n`ulimit -Hs 64` sets the hard stack size limit to 64 kB.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/ulimit.html](https://fishshell.com/docs/3.7/cmds/ulimit.html)"
- name: umask
  summary: umask displays and manipulates the “umask”, or file creation mode mask, which is used to restrict the default access to files
  description: "# umask - set or get the file creation mode mask\n\n## Synopsis\n\n```\numask [OPTIONS] [MASK]\n```\n\n## Description\n\n`umask` displays and manipulates the “umask”, or file creation mode mask, which is used to restrict the default access to files.\n\nThe umask may be expressed either as an octal number, which represents the rights that will be removed by default, or symbolically, which represents the only rights that will be granted by default.\n\nAccess rights are explained in the manual page for the `chmod(1)` program.\n\nWith no parameters, the current file creation mode mask is printed as an octal number.\n\n**-S** or **--symbolic**  \nPrints the umask in symbolic form instead of octal form.\n\n**-p** or **--as-command**  \nOutputs the umask in a form that may be reused as input.\n\n**-h** or **--help**  \nDisplays help about using this command.\n\nIf a numeric mask is specified as a parameter, the current shell’s umask will be set to that value, and the rights specified by that mask will be removed from new files and directories by default.\n\nIf a symbolic mask is specified, the desired permission bits, and not the inverse, should be specified. A symbolic mask is a comma separated list of rights. Each right consists of three parts:\n\n- The first part specifies to whom this set of right applies, and can be one of `u`, `g`, `o` or `a`, where `u` specifies the user who owns the file, `g` specifies the group owner of the file, `o` specific other users rights and `a` specifies all three should be changed.\n- The second part of a right specifies the mode, and can be one of `=`, `+` or `-`, where `=` specifies that the rights should be set to the new value, `+` specifies that the specified right should be added to those previously specified and `-` specifies that the specified rights should be removed from those previously specified.\n- The third part of a right specifies what rights should be changed and can be any combination of `r`, `w` and `x`, representing read, write and execute rights.\n\nIf the first and second parts are skipped, they are assumed to be `a` and `=`, respectively. As an example, `r,u+w` means all users should have read access and the file owner should also have write access.\n\nNote that symbolic masks currently do not work as intended.\n\n## Example\n\n`umask 177` or `umask u=rw` sets the file creation mask to read and write for the owner and no permissions at all for any other users.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/umask.html](https://fishshell.com/docs/3.7/cmds/umask.html)"
- name: vared
  summary: vared is used to interactively edit the value of an environment variable
  description: "# vared - interactively edit the value of an environment variable\n\n## Synopsis\n\n```\nvared VARIABLE_NAME\n```\n\n## Description\n\n`vared` is used to interactively edit the value of an environment variable. Array variables as a whole can not be edited using `vared`, but individual list elements can.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n`vared PATH[3]` edits the third element of the PATH list\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/vared.html](https://fishshell.com/docs/3.7/cmds/vared.html)"
- name: wait
  summary: wait waits for child jobs to complete
  description: "# wait - wait for jobs to complete\n\n## Synopsis\n\n```\nwait [-n | --any] [PID | PROCESS_NAME] ...\n```\n\n## Description\n\n`wait` waits for child jobs to complete.\n\nIf a *PID* is specified, the command waits for the job that the process with that process ID belongs to.\n\nIf a *PROCESS_NAME* is specified, the command waits for the jobs that the matched processes belong to.\n\nIf neither a pid nor a process name is specified, the command waits for all background jobs.\n\nIf the **-n** or **--any** flag is provided, the command returns as soon as the first job completes. If it is not provided, it returns after all jobs complete.\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n```\nsleep 10 &\nwait $last_pid\n```\n\nspawns `sleep` in the background, and then waits until it finishes.\n\n```\nfor i in (seq 1 5); sleep 10 &; end\nwait\n```\n\nspawns five jobs in the background, and then waits until all of them finishes.\n\n```\nfor i in (seq 1 5); sleep 10 &; end\nhoge &\nwait sleep\n```\n\nspawns five jobs and `hoge` in the background, and then waits until all `sleep`s finish, and doesn’t wait for `hoge` finishing.\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/wait.html](https://fishshell.com/docs/3.7/cmds/wait.html)"
- name: while
  summary: while repeatedly executes CONDITION, and if the exit status is 0, then executes COMMANDS
  description: "# while - perform a set of commands multiple times\n\n## Synopsis\n\n```\nwhile CONDITION; COMMANDS; end\n```\n\n## Description\n\n**while** repeatedly executes `CONDITION`, and if the exit status is 0, then executes `COMMANDS`.\n\nThe exit status of the **while** loop is the exit status of the last iteration of the `COMMANDS` executed, or 0 if none were executed. (This matches other shells and is POSIX-compatible.)\n\nYou can use [and](and) or [or](or) for complex conditions. Even more complex control can be achieved with `while true` containing a [break](break).\n\nThe **-h** or **--help** option displays help about using this command.\n\n## Example\n\n```\nwhile test -f foo.txt; or test -f bar.txt ; echo file exists; sleep 10; end\n# outputs 'file exists' at 10 second intervals,\n# as long as the file foo.txt or bar.txt exists.\n```\n\n© 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors  \nLicensed under the GNU General Public License, version 2.  \n[https://fishshell.com/docs/3.7/cmds/while.html](https://fishshell.com/docs/3.7/cmds/while.html)"
