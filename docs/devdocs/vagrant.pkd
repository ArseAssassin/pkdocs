---
name: Vagrant
slug: vagrant
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2010–2018 Mitchell Hashimoto
  Licensed under the MPL 2.0 License.
  https://www.vagrantup.com/docs/index.html
homepage: https://www.vagrantup.com/

---
- name: Action Hooks
  id: plugins/action-hooks
  summary: Action hooks provide ways to interact with Vagrant at a very low level by injecting middleware in various phases of Vagrant's lifecycle
  description: "# Action Hooks\n\nAction hooks provide ways to interact with Vagrant at a very low level by injecting middleware in various phases of Vagrant's lifecycle. This is an advanced option, even for plugin development.\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\n## Public Action Hooks\n\nThe following action hooks are available in the core of Vagrant. Please note that this list is not exhaustive and additional hooks can be added via plugins.\n\n- [`environment_plugins_loaded`](#environment_plugins_loaded) - called after the plugins have been loaded, but before the configurations, provisioners, providers, etc. are loaded.\n\n- [`environment_load`](#environment_load) - called after the environment and all configurations are fully loaded.\n\n- [`environment_unload`](#environment_unload) - called after the environment is done being used. The environment should not be used in this hook.\n\n- [`machine_action_boot`](#machine_action_boot) - called after the hypervisor has reported the machine was booted.\n\n- [`machine_action_config_validate`](#machine_action_config_validate) - called after all `Vagrantfile`s have been loaded, merged, and validated.\n\n- [`machine_action_destroy`](#machine_action_destroy) - called after the hypervisor has reported the virtual machine is down.\n\n- [`machine_action_halt`](#machine_action_halt) - called after the hypervisor has moved the machine into a halted state (usually \"stopped\" but not \"terminated\").\n\n- [`machine_action_package`](#machine_action_package) - called after Vagrant has successfully packaged a new box.\n\n- [`machine_action_provision`](#machine_action_provision) - called after all provisioners have executed.\n\n- [`machine_action_read_state`](#machine_action_read_state) - called after Vagrant has loaded state from disk and the hypervisor.\n\n- [`machine_action_reload`](#machine_action_reload) - called after a virtual machine is reloaded (varies by hypervisor).\n\n- [`machine_action_resume`](#machine_action_resume) - called after a virtual machine is moved from the halted to up state.\n\n- [`machine_action_run_command`](#machine_action_run_command) - called after a command is executed on the machine.\n\n- [`machine_action_ssh`](#machine_action_ssh) - called after an SSH connection has been established.\n\n- [`machine_action_ssh_run`](#machine_action_ssh_run) - called after an SSH command is executed.\n\n- [`machine_action_start`](#machine_action_start) - called after the machine has been started.\n\n- [`machine_action_suspend`](#machine_action_suspend) - called after the machine has been suspended.\n\n- [`machine_action_sync_folders`](#machine_action_sync_folders) - called after synced folders have been set up.\n\n- [`machine_action_up`](#machine_action_up) - called after the machine has entered the up state.\n\n## Private API\n\nYou may find additional action hooks if you browse the Vagrant source code, but only the list of action hooks here are guaranteed to persist between Vagrant releases. Please do not rely on the internal API as it is subject to change without notice.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/action-hooks.html](https://www.vagrantup.com/docs/plugins/action-hooks.html)"
- name: Additional Box Information
  id: boxes/info
  summary: When creating a Vagrant box, you can supply additional information that might be relevant to the user when running vagrant box list -i
  description: "# Additional Box Information\n\nWhen creating a Vagrant box, you can supply additional information that might be relevant to the user when running `vagrant box list -i`. For example, you could package your box to include information about the author of the box and a website for users to learn more:\n\n``` highlight\nbrian@localghost % vagrant box list -i\nhashicorp/precise64     (virtualbox, 1.0.0)\n  - author: brian\n  - homepage: https://www.vagrantup.com\n```\n\n## Box Info\n\nTo accomplish this, you simply need to include a file named `info.json` when creating a [base box](base) which is a JSON document containing any and all relevant information that will be displayed to the user when the `-i` option is used with `vagrant box list`.\n\n``` json\n{\n \"author\": \"brian\",\n \"homepage\": \"https://example.com\"\n}\n```\n\nThere are no special keys or values in `info.json`, and Vagrant will print each key and value on its own line.\n\nThe [Box File Format](format) provides more information about what else goes into a Vagrant box.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/boxes/info.html](https://www.vagrantup.com/docs/boxes/info.html)"
- name: Aliases
  id: cli/aliases
  summary: Inspired in part by Git's own alias functionality, aliases make your Vagrant experience simpler, easier, and more familiar by allowing you to create your own custom Vagrant commands
  description: "# Aliases\n\nInspired in part by Git's own [alias functionality](https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases), aliases make your Vagrant experience simpler, easier, and more familiar by allowing you to create your own custom Vagrant commands.\n\nAliases can be defined within `VAGRANT_HOME/aliases` file, or in a custom file defined using the `VAGRANT_ALIAS_FILE` environment variable, in the following format:\n\n``` highlight\n# basic command-level aliases\nstart = up\nstop = halt\n\n# advanced command-line aliases\neradicate = !vagrant destroy && rm -rf .vagrant\n```\n\nIn a nutshell, aliases are defined using a standard `key = value` format, where the `key` is the new Vagrant command, and the `value` is the aliased command. Using this format, there are two types of aliases that can be defined: internal and external aliases.\n\n## Internal Aliases\n\nInternal command aliases call the CLI class directly, allowing you to alias one Vagrant command to another Vagrant command. This technique can be very useful for creating commands that you think *should* exist. For example, if `vagrant stop` feels more intuitive than `vagrant halt`, the following alias definitions would make that change possible:\n\n``` highlight\nstop = halt\n```\n\nThis makes the following commands equivalent:\n\n``` highlight\nvagrant stop\nvagrant halt\n```\n\n## External Aliases\n\nWhile internal aliases can be used to define more intuitive Vagrant commands, external command aliases are used to define Vagrant commands with brand new functionality. These aliases are prefixed with the `!` character, which indicates to the interpreter that the alias should be executed as a shell command. For example, let's say that you want to be able to view the processor and memory utilization of the active project's virtual machine. To do this, you could define a `vagrant metrics` command that returns the required information in an easy-to-read format, like so:\n\n``` highlight\nmetrics = !ps aux | grep \"[V]BoxHeadless\" | grep $(cat .vagrant/machines/default/virtualbox/id) | awk '{ printf(\"CPU: %.02f%%, Memory: %.02f%%\", $3, $4) }'\n```\n\nThe above alias, from within the context of an active Vagrant project, would print the CPU and memory utilization directly to the console:\n\n``` highlight\nCPU: 4.20%, Memory: 11.00%\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/aliases.html](https://www.vagrantup.com/docs/cli/aliases.html)"
- name: Ansible and Vagrant
  id: provisioning/ansible_intro
  summary: The list of common options for these two provisioners is documented in a separate documentation page
  description: "# Ansible and Vagrant\n\nThe information below is applicable to both Vagrant Ansible provisioners:\n\n- [`ansible`](ansible), where Ansible is executed on the **Vagrant host**\n- [`ansible_local`](ansible_local), where Ansible is executed on the **Vagrant guest**\n\nThe list of common options for these two provisioners is documented in a [separate documentation page](ansible_common).\n\nThis documentation page will not go into how to use Ansible or how to write Ansible playbooks, since Ansible is a complete deployment and configuration management system that is beyond the scope of Vagrant documentation.\n\nTo learn more about Ansible, please consult the [Ansible Documentation Site](https://docs.ansible.com/).\n\n## The Playbook File\n\nThe first component of a successful Ansible provisioner setup is the Ansible playbook which contains the steps that should be run on the guest. Ansible's [playbook documentation](https://docs.ansible.com/playbooks.html) goes into great detail on how to author playbooks, and there are a number of [best practices](https://docs.ansible.com/playbooks_best_practices.html) that can be applied to use Ansible's powerful features effectively.\n\nA playbook that installs and starts (or restarts) the NTP daemon via YUM looks like:\n\n``` highlight\n---\n- hosts: all\n  tasks:\n    - name: ensure ntpd is at the latest version\n      yum: pkg=ntp state=latest\n      notify:\n      - restart ntpd\n  handlers:\n    - name: restart ntpd\n      service: name=ntpd state=restarted\n```\n\nYou can of course target other operating systems that do not have YUM by changing the playbook tasks. Ansible ships with a number of [modules](https://docs.ansible.com/modules.html) that make running otherwise tedious tasks dead simple.\n\n### Running Ansible\n\nThe `playbook` option is strictly required by both Ansible provisioners ([`ansible`](ansible) and [`ansible_local`](ansible_local)), as illustrated in this basic Vagrantfile\\` configuration:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n\n  # Use :ansible or :ansible_local to\n  # select the provisioner of your choice\n  config.vm.provision :ansible do |ansible|\n    ansible.playbook = \"playbook.yml\"\n  end\nend\n```\n\nSince an Ansible playbook can include many files, you may also collect the related files in a [directory structure](https://docs.ansible.com/playbooks_best_practices.html#directory-layout) like this:\n\n``` highlight\n.\n|-- Vagrantfile\n|-- provisioning\n|   |-- group_vars\n|           |-- all\n|   |-- roles\n|           |-- bar\n|           |-- foo\n|   |-- playbook.yml\n```\n\nIn such an arrangement, the `ansible.playbook` path should be adjusted accordingly:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"ansible\" do |ansible|\n    ansible.playbook = \"provisioning/playbook.yml\"\n  end\nend\n```\n\n## The Inventory File\n\nWhen using Ansible, it needs to know on which machines a given playbook should run. It does this by way of an [inventory](https://docs.ansible.com/intro_inventory.html) file which lists those machines. In the context of Vagrant, there are two ways to approach working with inventory files.\n\n### Auto-Generated Inventory\n\nThe first and simplest option is to not provide one to Vagrant at all. Vagrant will generate an inventory file encompassing all of the virtual machines it manages, and use it for provisioning machines.\n\n#### Example with the [`ansible`](ansible) provisioner\n\n``` highlight\n# Generated by Vagrant\n\ndefault ansible_ssh_host=127.0.0.1 ansible_ssh_port=2200 ansible_ssh_user='vagrant' ansible_ssh_private_key_file='/home/.../.vagrant/machines/default/virtualbox/private_key'\n```\n\nNote that the generated inventory file is stored as part of your local Vagrant environment in `.vagrant/provisioners/ansible/inventory/vagrant_ansible_inventory`.\n\n#### Example with the [`ansible_local`](ansible_local) provisioner\n\n``` highlight\n# Generated by Vagrant\n\ndefault ansible_connection=local\n```\n\nNote that the generated inventory file is uploaded to the guest VM in a subdirectory of [`tmp_path`](ansible_local), e.g. `/tmp/vagrant-ansible/inventory/vagrant_ansible_local_inventory`.\n\n#### Host Variables\n\nAs of Vagrant 1.8.0, the [`host_vars`](ansible_common#host_vars) option can be used to set [variables for individual hosts](https://docs.ansible.com/ansible/intro_inventory.html#host-variables) in the generated inventory file (see also the notes on group variables below).\n\nWith this configuration example:\n\n``` highlight\nVagrant.configure(\"2\") do |config|\n  config.vm.define \"host1\"\n  config.vm.define \"host2\"\n  config.vm.provision \"ansible\" do |ansible|\n    ansible.playbook = \"playbook.yml\"\n    ansible.host_vars = {\n      \"host1\" => {\"http_port\" => 80,\n                  \"maxRequestsPerChild\" => 808},\n      \"host2\" => {\"http_port\" => 303,\n                  \"maxRequestsPerChild\" => 909}\n    }\n  end\nend\n```\n\nVagrant would generate the following inventory file:\n\n``` highlight\n# Generated by Vagrant\n\nhost1 ansible_ssh_host=... http_port=80 maxRequestsPerChild=808\nhost2 ansible_ssh_host=... http_port=303 maxRequestsPerChild=909\n```\n\n#### Groups and Group Variables\n\nThe [`groups`](ansible_common#groups) option can be used to pass a hash of group names and group members to be included in the generated inventory file.\n\nAs of Vagrant 1.8.0, it is also possible to specify [group variables](https://docs.ansible.com/ansible/intro_inventory.html#group-variables), and group members as [host ranges (with numeric or alphabetic patterns)](https://docs.ansible.com/ansible/intro_inventory.html#hosts-and-groups).\n\nWith this configuration example:\n\n``` highlight\nVagrant.configure(\"2\") do |config|\n\n  config.vm.box = \"ubuntu/trusty64\"\n\n  config.vm.define \"machine1\"\n  config.vm.define \"machine2\"\n\n  config.vm.provision \"ansible\" do |ansible|\n    ansible.playbook = \"playbook.yml\"\n    ansible.groups = {\n      \"group1\" => [\"machine1\"],\n      \"group2\" => [\"machine2\"],\n      \"group3\" => [\"machine[1:2]\"],\n      \"group4\" => [\"other_node-[a:d]\"], # silly group definition\n      \"all_groups:children\" => [\"group1\", \"group2\"],\n      \"group1:vars\" => {\"variable1\" => 9,\n                        \"variable2\" => \"example\"}\n    }\n  end\nend\n```\n\nVagrant would generate the following inventory file:\n\n``` highlight\n# Generated by Vagrant\n\nmachine1 ansible_ssh_host=127.0.0.1 ansible_ssh_port=2200 ansible_ssh_user='vagrant' ansible_ssh_private_key_file='/home/.../.vagrant/machines/machine1/virtualbox/private_key'\nmachine2 ansible_ssh_host=127.0.0.1 ansible_ssh_port=2222 ansible_ssh_user='vagrant' ansible_ssh_private_key_file='/home/.../.vagrant/machines/machine2/virtualbox/private_key'\n\n[group1]\nmachine1\n\n[group2]\nmachine2\n\n[group3]\nmachine[1:2]\n\n[group4]\nother_node-[a:d]\n\n[all_groups:children]\ngroup1\ngroup2\n\n[group1:vars]\nvariable1=9\nvariable2=example\n```\n\n**Notes:**\n\n- Prior to Vagrant 1.7.3, the `ansible_ssh_private_key_file` variable was not set in generated inventory, but passed as command line argument to `ansible-playbook` command.\n\n- The generation of group variables blocks (e.g. `[group1:vars]`) is only possible since Vagrant 1.8.0. Note however that setting variables directly in the inventory is not the [preferred practice in Ansible](https://docs.ansible.com/intro_inventory.html#splitting-out-host-and-group-specific-data). If possible, group (or host) variables should be set in `YAML` files stored in the `group_vars/` or `host_vars/` directories in the playbook (or inventory) directory instead.\n\n- Unmanaged machines and undefined groups are not added to the inventory, to avoid useless Ansible errors (e.g. *unreachable host* or *undefined child group*)\n\n  For example, `machine3` and `group3` in the example below would not be added to the generated inventory file:\n\n  ``` ruby\n  ansible.groups = {\n    \"group1\" => [\"machine1\"],\n    \"group2\" => [\"machine2\", \"machine3\"],\n    \"all_groups:children\" => [\"group1\", \"group2\", \"group3\"]\n  }\n  ```\n\n- [Host range patterns (numeric and alphabetic ranges)](https://docs.ansible.com/ansible/intro_inventory.html#hosts-and-groups) will not be validated by Vagrant. As of Vagrant 1.8.0, host range patterns will be added as group members to the inventory anyway, this might lead to errors in Ansible (e.g *unreachable host*).\n\n### Static Inventory\n\nThe second option is for situations where you would like to have more control over the inventory management.\n\nWith the [`inventory_path`](ansible_common#inventory_path) option, you can reference a specific inventory resource (e.g. a static inventory file, a [dynamic inventory script](https://docs.ansible.com/intro_dynamic_inventory.html) or even [multiple inventories stored in the same directory](https://docs.ansible.com/intro_dynamic_inventory.html#using-multiple-inventory-sources)). Vagrant will then use this inventory information instead of generating it.\n\nA very simple inventory file for use with Vagrant might look like:\n\n``` highlight\ndefault ansible_ssh_host=192.168.111.222\n```\n\nWhere the above IP address is one set in your Vagrantfile:\n\n``` highlight\nconfig.vm.network :private_network, ip: \"192.168.111.222\"\n```\n\n**Notes:**\n\n- The machine names in `Vagrantfile` and `ansible.inventory_path` files should correspond, unless you use `ansible.limit` option to reference the correct machines.\n- The SSH host addresses (and ports) must obviously be specified twice, in `Vagrantfile` and `ansible.inventory_path` files.\n- Sharing hostnames across Vagrant host and guests might be a good idea (e.g. with some Ansible configuration task, or with a plugin like [`vagrant-hostmanager`](https://github.com/smdahlen/vagrant-hostmanager)).\n\n### The Ansible Configuration File\n\nCertain settings in Ansible are (only) adjustable via a [configuration file](https://docs.ansible.com/intro_configuration.html), and you might want to ship such a file in your Vagrant project.\n\nWhen shipping an Ansible configuration file it is good to know that:\n\n- as of Ansible 1.5, the lookup order is the following:\n  - any path set as `ANSIBLE_CONFIG` environment variable\n  - [`ansible.cfg`](#ansible-cfg) in the runtime working directory\n  - [`.ansible.cfg`](#ansible-cfg-1) in the user home directory\n  - [`/etc/ansible/ansible.cfg`](#etc-ansible-ansible-cfg)\n- Ansible commands don't look for a configuration file relative to the playbook file location (e.g. in the same directory)\n- an `ansible.cfg` file located in the same directory as your `Vagrantfile` will be used by default.\n- it is also possible to reference any other location with the [config_file](ansible_common#config_file) provisioner option. In this case, Vagrant will set the `ANSIBLE_CONFIG` environment variable accordingly.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/ansible_intro.html](https://www.vagrantup.com/docs/provisioning/ansible_intro.html)"
- name: Ansible Local Provisioner
  id: provisioning/ansible_local
  summary: The Vagrant Ansible Local provisioner allows you to provision the guest using Ansible playbooks by executing ansible-playbook directly on the guest machine
  description: "# Ansible Local Provisioner\n\n**Provisioner name: `ansible_local`**\n\nThe Vagrant Ansible Local provisioner allows you to provision the guest using [Ansible](http://ansible.com) playbooks by executing **`ansible-playbook` directly on the guest machine**.\n\n> **Warning:** If you are not familiar with Ansible and Vagrant already, I recommend starting with the [shell provisioner](shell). However, if you are comfortable with Vagrant already, Vagrant is a great way to learn Ansible.\n\n## Setup Requirements\n\nThe main advantage of the Ansible Local provisioner in comparison to the [Ansible (remote) provisioner](ansible) is that it does not require any additional software on your Vagrant host.\n\nOn the other hand, [Ansible must obviously be installed](https://docs.ansible.com/intro_installation.html#installing-the-control-machine) on your guest machine(s).\n\n**Note:** By default, Vagrant will *try* to automatically install Ansible if it is not yet present on the guest machine (see the `install` option below for more details).\n\n## Usage\n\nThis page only documents the specific parts of the `ansible_local` provisioner. General Ansible concepts like Playbook or Inventory are shortly explained in the [introduction to Ansible and Vagrant](ansible_intro).\n\nThe Ansible Local provisioner requires that all the Ansible Playbook files are available on the guest machine, at the location referred by the `provisioning_path` option. Usually these files are initially present on the host machine (as part of your Vagrant project), and it is quite easy to share them with a Vagrant [Synced Folder](../synced-folders/index).\n\n### Simplest Configuration\n\nTo run Ansible from your Vagrant guest, the basic `Vagrantfile` configuration looks like:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # Run Ansible from the Vagrant VM\n  config.vm.provision \"ansible_local\" do |ansible|\n    ansible.playbook = \"playbook.yml\"\n  end\nend\n```\n\n**Requirements:**\n\n- The `playbook.yml` file is stored in your Vagrant's project home directory.\n\n- The [default shared directory](../synced-folders/basic_usage) is enabled (`.` → `/vagrant`).\n\n## Options\n\nThis section lists the *specific* options for the Ansible Local provisioner. In addition to the options listed below, this provisioner supports the [**common options** for both Ansible provisioners](ansible_common).\n\n- [`install`](#install) (boolean) - Try to automatically install Ansible on the guest system.\n\n  This option is enabled by default.\n\n  Vagrant will try to install (or upgrade) Ansible when one of these conditions are met:\n\n  - Ansible is not installed (or cannot be found).\n  - The [`version`](ansible_common#version) option is set to `\"latest\"`.\n  - The current Ansible version does not correspond to the [`version`](ansible_common#version) option.\n\n  > **Attention:** There is no guarantee that this automated installation will replace a custom Ansible setup, that might be already present on the Vagrant box.\n\n- [`install_mode`](#install_mode) (`:default`, `:pip`, or `:pip_args_only`) - Select the way to automatically install Ansible on the guest system.\n\n  - [`:default`](#default): Ansible is installed from the operating system package manager. This mode doesn't support `version` selection. For many platforms (e.g Debian, FreeBSD, OpenSUSE) the official package repository is used, except for the following Linux distributions:\n    - On Ubuntu-like systems, the latest Ansible release is installed from the `ppa:ansible/ansible` repository. The compatibility is maintained only for active long-term support (LTS) versions.\n    - On RedHat-like systems, the latest Ansible release is installed from the [EPEL](http://fedoraproject.org/wiki/EPEL) repository.\n\n  - [`:pip`](#pip): Ansible is installed from [PyPI](https://pypi.python.org/pypi) with [pip](https://pip.pypa.io) package installer. With this mode, Vagrant will systematically try to [install the latest pip version](https://pip.pypa.io/en/stable/installing/#installing-with-get-pip-py). With the `:pip` mode you can optionally install a specific Ansible release by setting the [`version`](ansible_common#version) option.\n\n    Example:\n\n    ``` ruby\n    config.vm.provision \"ansible_local\" do |ansible|\n      ansible.playbook = \"playbook.yml\"\n      ansible.install_mode = \"pip\"\n      ansible.version = \"2.2.1.0\"\n    end\n    ```\n\n    With this configuration, Vagrant will install `pip` and then execute the command\n\n    ``` shell\n    sudo pip install --upgrade ansible==2.2.1.0\n    ```\n\n  - [`:pip_args_only`](#pip_args_only): This mode is very similar to the `:pip` mode, with the difference that in this case no pip arguments will be automatically set by Vagrant.\n\n    Example:\n\n    ``` ruby\n    config.vm.provision \"ansible_local\" do |ansible|\n      ansible.playbook = \"playbook.yml\"\n      ansible.install_mode = \"pip_args_only\"\n      ansible.pip_args = \"-r /vagrant/requirements.txt\"\n    end\n    ```\n\n    With this configuration, Vagrant will install `pip` and then execute the command\n\n    ``` shell\n    sudo pip install -r /vagrant/requirements.txt\n    ```\n\n  The default value of `install_mode` is `:default`, and any invalid value for this option will silently fall back to the default value.\n\n- [`pip_args`](#pip_args) (string) - When Ansible is installed via pip, this option allows the definition of additional pip arguments to be passed along on the command line (for example, [`--index-url`](https://pip.pypa.io/en/stable/reference/pip_install/#cmdoption-i)).\n\n  By default, this option is not set.\n\n  Example:\n\n  ``` ruby\n  config.vm.provision \"ansible_local\" do |ansible|\n    ansible.playbook = \"playbook.yml\"\n    ansible.install_mode = :pip\n    ansible.pip_args = \"--index-url https://pypi.internal\"\n  end\n  ```\n\n  With this configuration, Vagrant will install `pip` and then execute the command\n\n  ``` shell\n  sudo pip install --index-url https://pypi.internal --upgrade ansible\n  ```\n\n- [`provisioning_path`](#provisioning_path) (string) - An absolute path on the guest machine where the Ansible files are stored. The `ansible-galaxy` and `ansible-playbook` commands are executed from this directory. This is the location to place an [ansible.cfg](http://docs.ansible.com/ansible/intro_configuration.html) file, in case you need it.\n\n  The default value is `/vagrant`.\n\n- [`tmp_path`](#tmp_path) (string) - An absolute path on the guest machine where temporary files are stored by the Ansible Local provisioner.\n\n  The default value is `/tmp/vagrant-ansible`\n\n## Tips and Tricks\n\n### Install Galaxy Roles in a path owned by root\n\n**Disclaimer:** This tip is not a recommendation to install galaxy roles out of the vagrant user space, especially if you rely on ssh agent forwarding to fetch the roles.\n\nBe careful that `ansible-galaxy` command is executed by default as vagrant user. Setting `galaxy_roles_path` to a folder like `/etc/ansible/roles` will fail, and `ansible-galaxy` will extract the role a second time in `/home/vagrant/.ansible/roles/`. Then if your playbook uses `become` to run as `root`, it will fail with a *\"role was not found\"* error.\n\nTo work around that, you can use `ansible.galaxy_command` to prepend the command with `sudo`, as illustrated in the example below:\n\n``` ruby\nVagrant.configure(2) do |config|\n  config.vm.box = \"centos/7\"\n  config.vm.provision \"ansible_local\" do |ansible|\n    ansible.become = true\n    ansible.playbook = \"playbook.yml\"\n    ansible.galaxy_role_file = \"requirements.yml\"\n    ansible.galaxy_roles_path = \"/etc/ansible/roles\"\n    ansible.galaxy_command = \"sudo ansible-galaxy install --role-file=%{role_file} --roles-path=%{roles_path} --force\"\n  end\nend\n```\n\n### Ansible Parallel Execution from a Guest\n\nWith the following configuration pattern, you can install and execute Ansible only on a single guest machine (the `\"controller\"`) to provision all your machines.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n\n  config.vm.box = \"ubuntu/trusty64\"\n\n  config.vm.define \"node1\" do |machine|\n    machine.vm.network \"private_network\", ip: \"172.17.177.21\"\n  end\n\n  config.vm.define \"node2\" do |machine|\n    machine.vm.network \"private_network\", ip: \"172.17.177.22\"\n  end\n\n  config.vm.define 'controller' do |machine|\n    machine.vm.network \"private_network\", ip: \"172.17.177.11\"\n\n    machine.vm.provision :ansible_local do |ansible|\n      ansible.playbook       = \"example.yml\"\n      ansible.verbose        = true\n      ansible.install        = true\n      ansible.limit          = \"all\" # or only \"nodes\" group, etc.\n      ansible.inventory_path = \"inventory\"\n    end\n  end\n\nend\n```\n\nYou need to create a static `inventory` file that corresponds to your `Vagrantfile` machine definitions:\n\n``` highlight\ncontroller ansible_connection=local\nnode1      ansible_ssh_host=172.17.177.21 ansible_ssh_private_key_file=/vagrant/.vagrant/machines/node1/virtualbox/private_key\nnode2      ansible_ssh_host=172.17.177.22 ansible_ssh_private_key_file=/vagrant/.vagrant/machines/node2/virtualbox/private_key\n\n[nodes]\nnode[1:2]\n```\n\nAnd finally, you also have to create an [`ansible.cfg` file](https://docs.ansible.com/intro_configuration.html#openssh-specific-settings) to fully disable SSH host key checking. More SSH configurations can be added to the `ssh_args` parameter (e.g. agent forwarding, etc.)\n\n``` highlight\n[defaults]\nhost_key_checking = no\n\n[ssh_connection]\nssh_args = -o ControlMaster=auto -o ControlPersist=60s -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/ansible_local.html](https://www.vagrantup.com/docs/provisioning/ansible_local.html)"
- name: Ansible Provisioner
  id: provisioning/ansible
  summary: The Vagrant Ansible provisioner allows you to provision the guest using Ansible playbooks by executing ansible-playbook from the Vagrant host
  description: "# Ansible Provisioner\n\n**Provisioner name: `ansible`**\n\nThe Vagrant Ansible provisioner allows you to provision the guest using [Ansible](http://ansible.com) playbooks by executing **`ansible-playbook` from the Vagrant host**.\n\n> **Warning:** If you are not familiar with Ansible and Vagrant already, I recommend starting with the [shell provisioner](shell). However, if you are comfortable with Vagrant already, Vagrant is a great way to learn Ansible.\n\n## Setup Requirements\n\n- **[Install Ansible](https://docs.ansible.com/intro_installation.html#installing-the-control-machine) on your Vagrant host**.\n\n- Your Vagrant host should ideally provide a recent version of OpenSSH that [supports ControlPersist](https://docs.ansible.com/faq.html#how-do-i-get-ansible-to-reuse-connections-enable-kerberized-ssh-or-have-ansible-pay-attention-to-my-local-ssh-config-file).\n\nIf installing Ansible directly on the Vagrant host is not an option in your development environment, you might be looking for the [Ansible Local provisioner](ansible_local) alternative.\n\n## Usage\n\nThis page only documents the specific parts of the `ansible` (remote) provisioner. General Ansible concepts like Playbook or Inventory are shortly explained in the [introduction to Ansible and Vagrant](ansible_intro).\n\n### Simplest Configuration\n\nTo run Ansible against your Vagrant guest, the basic `Vagrantfile` configuration looks like:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n\n  #\n  # Run Ansible from the Vagrant Host\n  #\n  config.vm.provision \"ansible\" do |ansible|\n    ansible.playbook = \"playbook.yml\"\n  end\n\nend\n```\n\n## Options\n\nThis section lists the *specific* options for the Ansible (remote) provisioner. In addition to the options listed below, this provisioner supports the [**common options** for both Ansible provisioners](ansible_common).\n\n- [`ask_become_pass`](#ask_become_pass) (boolean) - require Ansible to [prompt for a password](https://docs.ansible.com/intro_getting_started.html#remote-connection-information) when switching to another user with the [become/sudo mechanism](http://docs.ansible.com/ansible/become.html).\n\n  The default value is `false`.\n\n- [`ask_sudo_pass`](#ask_sudo_pass) (boolean) - Backwards compatible alias for the [ask_become_pass](#ask_become_pass) option.\n\n  > **Deprecation:** The `ask_sudo_pass` option is deprecated and will be removed in a future release. Please use the [**`ask_become_pass`**](#ask_become_pass) option instead.\n\n- [`ask_vault_pass`](#ask_vault_pass) (boolean) - require Ansible to [prompt for a vault password](https://docs.ansible.com/playbooks_vault.html#vault).\n\n  The default value is `false`.\n\n- [`force_remote_user`](#force_remote_user) (boolean) - require Vagrant to set the `ansible_ssh_user` setting in the generated inventory, or as an extra variable when a static inventory is used. All the Ansible `remote_user` parameters will then be overridden by the value of `config.ssh.username` of the [Vagrant SSH Settings](../vagrantfile/ssh_settings).\n\n  If this option is set to `false` Vagrant will set the Vagrant SSH username as a default Ansible remote user, but `remote_user` parameters of your Ansible plays or tasks will still be taken into account and thus override the Vagrant configuration.\n\n  The default value is `true`.\n\n  > **Compatibility Note:** This option was introduced in Vagrant 1.8.0. Previous Vagrant versions behave like if this option was set to `false`.\n\n- [`host_key_checking`](#host_key_checking) (boolean) - require Ansible to [enable SSH host key checking](https://docs.ansible.com/intro_getting_started.html#host-key-checking).\n\n  The default value is `false`.\n\n- [`raw_ssh_args`](#raw_ssh_args) (array of strings) - require Ansible to apply a list of OpenSSH client options.\n\n  Example: `['-o ControlMaster=no']`.\n\n  It is an *unsafe wildcard* that can be used to pass additional SSH settings to Ansible via `ANSIBLE_SSH_ARGS` environment variable, overriding any other SSH arguments (e.g. defined in an [`ansible.cfg` configuration file](https://docs.ansible.com/intro_configuration.html#ssh-args)).\n\n## Tips and Tricks\n\n### Ansible Parallel Execution\n\nVagrant is designed to provision [multi-machine environments](../multi-machine) in sequence, but the following configuration pattern can be used to take advantage of Ansible parallelism:\n\n``` ruby\n# Vagrant 1.7+ automatically inserts a different\n# insecure keypair for each new VM created. The easiest way\n# to use the same keypair for all the machines is to disable\n# this feature and rely on the legacy insecure key.\n# config.ssh.insert_key = false\n#\n# Note:\n# As of Vagrant 1.7.3, it is no longer necessary to disable\n# the keypair creation when using the auto-generated inventory.\n\nN = 3\n(1..N).each do |machine_id|\n  config.vm.define \"machine#{machine_id}\" do |machine|\n    machine.vm.hostname = \"machine#{machine_id}\"\n    machine.vm.network \"private_network\", ip: \"192.168.77.#{20+machine_id}\"\n\n    # Only execute once the Ansible provisioner,\n    # when all the machines are up and ready.\n    if machine_id == N\n      machine.vm.provision :ansible do |ansible|\n        # Disable default limit to connect to all the machines\n        ansible.limit = \"all\"\n        ansible.playbook = \"playbook.yml\"\n      end\n    end\n  end\nend\n```\n\n> **Tip:** If you apply this parallel provisioning pattern with a static Ansible inventory, you will have to organize the things so that [all the relevant private keys are provided to the `ansible-playbook` command](https://github.com/hashicorp/vagrant/pull/5765#issuecomment-120247738). The same kind of considerations applies if you are using multiple private keys for a same machine (see [`config.ssh.private_key_path` SSH setting](../vagrantfile/ssh_settings)).\n\n### Force Paramiko Connection Mode\n\nThe Ansible provisioner is implemented with native OpenSSH support in mind, and there is no official support for [paramiko](https://github.com/paramiko/paramiko/) (A native Python SSHv2 protocol library).\n\nIf you really need to use this connection mode though, it is possible to enable paramiko as illustrated in the following configuration examples:\n\nWith auto-generated inventory:\n\n``` ruby\nansible.raw_arguments = [\"--connection=paramiko\"]\n```\n\nWith a custom inventory, the private key must be specified (e.g. via an `ansible.cfg` configuration file, `--private-key` argument, or as part of your inventory file):\n\n``` ruby\nansible.inventory_path = \"./my-inventory\"\nansible.raw_arguments  = [\n  \"--connection=paramiko\",\n  \"--private-key=/home/.../.vagrant/machines/.../private_key\"\n]\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/ansible.html](https://www.vagrantup.com/docs/provisioning/ansible.html)"
- name: Backwards Compatibility
  id: installation/backwards-compatibility
  summary: Vagrant 1.1+ provides full backwards compatibility for valid Vagrant 1.0.x Vagrantfiles which do not use plugins
  description: "# Backwards Compatibility\n\n## For 1.0.x\n\nVagrant 1.1+ provides full backwards compatibility for valid Vagrant 1.0.x Vagrantfiles which do not use plugins. After installing Vagrant 1.1, your 1.0.x environments should continue working without modifications, and existing running machines will continue to be managed properly.\n\nThis compatibility layer will remain in Vagrant up to and including Vagrant 2.0. It may still exist after that, but Vagrant's compatibility promise is only for two versions. Seeing that major Vagrant releases take years to develop and release, it is safe to stick with your version 1.0.x Vagrantfile for the time being.\n\nIf you use any Vagrant 1.0.x plugins, you must remove references to these from your Vagrantfile prior to upgrading. Vagrant 1.1+ introduces a new plugin format that will protect against this sort of incompatibility from ever happening again.\n\n## For 1.x\n\nBackwards compatibility between 1.x is not promised, and Vagrantfile syntax stability is not promised until 2.0 final. Any backwards incompatibilities within 1.x will be clearly documented.\n\nThis is similar to how Vagrant 0.x was handled. In practice, Vagrant 0.x only introduced a handful of backwards incompatibilities during the entire development cycle, but the possibility of backwards incompatibilities is made clear so people are not surprised.\n\nVagrant 2.0 final will have a stable Vagrantfile format that will remain backwards compatible, just as 1.0 is considered stable.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/installation/backwards-compatibility.html](https://www.vagrantup.com/docs/installation/backwards-compatibility.html)"
- name: Basic Provider Usage
  id: providers/basic_usage
  summary: Vagrant boxes are all provider-specific
  description: "# Basic Provider Usage\n\n## Boxes\n\nVagrant boxes are all provider-specific. A box for VirtualBox is incompatible with the VMware Fusion provider, or any other provider. A box must be installed for each provider, and can share the same name as other boxes as long as the providers differ. So you can have both a VirtualBox and VMware Fusion \"precise64\" box.\n\nInstalling boxes has not changed at all:\n\n``` highlight\n$ vagrant box add hashicorp/precise64\n```\n\nVagrant now automatically detects what provider a box is for. This is visible when listing boxes. Vagrant puts the provider in parentheses next to the name, as can be seen below.\n\n``` highlight\n$ vagrant box list\nprecise64 (virtualbox)\nprecise64 (vmware_fusion)\n```\n\n## Vagrant Up\n\nOnce a provider is installed, you can use it by calling `vagrant up` with the `--provider` flag. This will force Vagrant to use that specific provider. No other configuration is necessary!\n\nIn normal day-to-day usage, the `--provider` flag is not necessary since Vagrant can usually pick the right provider for you. More details on how it does this is below.\n\n``` highlight\n$ vagrant up --provider=vmware_fusion\n```\n\nIf you specified a `--provider` flag, you only need to do this for the `up` command. Once a machine is up and running, Vagrant is able to see what provider is backing a running machine, so commands such as `destroy`, `suspend`, etc. do not need to be told what provider to use.\n\n> Vagrant currently restricts you to bringing up one provider per machine. If you have a multi-machine environment, you can bring up one machine backed by VirtualBox and another backed by VMware Fusion, for example, but you cannot back the *same machine* with both VirtualBox and VMware Fusion. This is a limitation that will be removed in a future version of Vagrant.\n\n## Default Provider\n\nAs mentioned earlier, you typically do not need to specify `--provider` *ever*. Vagrant is smart enough about being able to detect the provider you want for a given environment.\n\nVagrant attempts to find the default provider in the following order:\n\n1.  The `--provider` flag on a `vagrant up` is chosen above all else, if it is present.\n\n2.  If the `VAGRANT_DEFAULT_PROVIDER` environmental variable is set, it takes next priority and will be the provider chosen.\n\n3.  Vagrant will go through all of the `config.vm.provider` calls in the Vagrantfile and try each in order. It will choose the first provider that is usable. For example, if you configure Hyper-V, it will never be chosen on Mac this way. It must be both configured and usable.\n\n4.  Vagrant will go through all installed provider plugins (including the ones that come with Vagrant), and find the first plugin that reports it is usable. There is a priority system here: systems that are known better have a higher priority than systems that are worse. For example, if you have the VMware provider installed, it will always take priority over VirtualBox.\n\n5.  If Vagrant still has not found any usable providers, it will error.\n\nUsing this method, there are very few cases that Vagrant does not find the correct provider for you. This also allows each [Vagrantfile](../vagrantfile/index) to define what providers the development environment is made for by ordering provider configurations.\n\nA trick is to use `config.vm.provider` with no configuration at the top of your Vagrantfile to define the order of providers you prefer to support:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ... other config up here\n\n  # Prefer VMware Fusion before VirtualBox\n  config.vm.provider \"vmware_fusion\"\n  config.vm.provider \"virtualbox\"\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/providers/basic_usage.html](https://www.vagrantup.com/docs/providers/basic_usage.html)"
- name: Basic Usage
  id: synced-folders/basic_usage
  summary: Synced folders are configured within your Vagrantfile using the config.vm.synced_folder method
  description: "# Basic Usage\n\n## Configuration\n\nSynced folders are configured within your Vagrantfile using the `config.vm.synced_folder` method. Usage of the configuration directive is very simple:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # other config here\n\n  config.vm.synced_folder \"src/\", \"/srv/website\"\nend\n```\n\nThe first parameter is a path to a directory on the host machine. If the path is relative, it is relative to the project root. The second parameter must be an absolute path of where to share the folder within the guest machine. This folder will be created (recursively, if it must) if it does not exist. By default, Vagrant mounts the synced folders with the owner/group set to the SSH user and any parent folders set to root.\n\n## Options\n\nYou may also specify additional optional parameters when configuring synced folders. These options are listed below. More detailed examples of using some of these options are shown below this section, note the owner/group example supplies two additional options separated by commas.\n\nIn addition to these options, the specific synced folder type might allow more options. See the documentation for your specific synced folder type for more details. The built-in synced folder types are documented in other pages available in the navigation for these docs.\n\n- [`create`](#create) (boolean) - If true, the host path will be created if it does not exist. Defaults to false.\n\n- [`disabled`](#disabled) (boolean) - If true, this synced folder will be disabled and will not be setup. This can be used to disable a previously defined synced folder or to conditionally disable a definition based on some external factor.\n\n- [`group`](#group) (string) - The group that will own the synced folder. By default this will be the SSH user. Some synced folder types do not support modifying the group.\n\n- [`mount_options`](#mount_options) (array) - A list of additional mount options to pass to the `mount` command.\n\n- [`owner`](#owner) (string) - The user who should be the owner of this synced folder. By default this will be the SSH user. Some synced folder types do not support modifying the owner.\n\n- [`type`](#type) (string) - The type of synced folder. If this is not specified, Vagrant will automatically choose the best synced folder option for your environment. Otherwise, you can specify a specific type such as \"nfs\".\n\n- [`id`](#id) (string) - The name for the mount point of this synced folder in the guest machine. This shows up when you run `mount` in the guest machine.\n\n## Enabling\n\nSynced folders are automatically setup during `vagrant up` and `vagrant reload`.\n\n## Disabling\n\nSynced folders can be disabled by adding the `disabled` option to any definition:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.synced_folder \"src/\", \"/srv/website\", disabled: true\nend\n```\n\nDisabling the default `/vagrant` share can be done as follows:\n\n``` ruby\nconfig.vm.synced_folder \".\", \"/vagrant\", disabled: true\n```\n\n## Modifying the Owner/Group\n\nSometimes it is preferable to mount folders with a different owner/group than the default SSH user. Keep in mind that these options will only affect the synced folder itself. If you want to modify the owner/group of the synced folder's parent folders use a script. It is possible to set these options:\n\n``` ruby\nconfig.vm.synced_folder \"src/\", \"/srv/website\",\n  owner: \"root\", group: \"root\"\n```\n\n*NOTE: Owner and group IDs defined within `mount_options` will have precedence over the `owner` and `group` options.*\n\nFor example, given the following configuration:\n\n``` ruby\nconfig.vm.synced_folder \".\", \"/vagrant\", owner: \"vagrant\",\n  group: \"vagrant\", mount_options: [\"uid=1234\", \"gid=1234\"]\n```\n\nthe mounted synced folder will be owned by the user with ID `1234` and the group with ID `1234`. The `owner` and `group` options will be ignored.\n\n## Symbolic Links\n\nSupport for symbolic links across synced folder implementations and host/guest combinations is not consistent. Vagrant does its best to make sure symbolic links work by configuring various hypervisors (such as VirtualBox), but some host/guest combinations still do not work properly. This can affect some development environments that rely on symbolic links.\n\nThe recommendation is to make sure to test symbolic links on all the host/guest combinations you sync folders on if this is important to you.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/synced-folders/basic_usage.html](https://www.vagrantup.com/docs/synced-folders/basic_usage.html)"
- name: Basic Usage
  id: triggers/usage
  summary: Below are some very simple examples of how to use Vagrant Triggers
  description: "# Basic Usage\n\nBelow are some very simple examples of how to use Vagrant Triggers.\n\n## Examples\n\nThe following is a basic example of two global triggers. One that runs *before* the `:up` command and one that runs *after* the `:up` command:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.trigger.before :up do |trigger|\n    trigger.name = \"Hello world\"\n    trigger.info = \"I am running before vagrant up!!\"\n  end\n\n  config.trigger.after :up do |trigger|\n    trigger.name = \"Hello world\"\n    trigger.info = \"I am running after vagrant up!!\"\n  end\n\n  config.vm.define \"ubuntu\" do |ubuntu|\n    ubuntu.vm.box = \"ubuntu\"\n  end\nend\n```\n\nThese will run before and after each defined guest in the Vagrantfile.\n\nRunning a remote script to save a database on your host before **destroy**ing a guest:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.define \"ubuntu\" do |ubuntu|\n    ubuntu.vm.box = \"ubuntu\"\n\n    ubuntu.trigger.before :destroy do |trigger|\n      trigger.warn = \"Dumping database to /vagrant/outfile\"\n      trigger.run_remote = {inline: \"pg_dump dbname > /vagrant/outfile\"}\n    end\n  end\nend\n```\n\nNow that the trigger is defined, running the **destroy** command will fire off the defined trigger before Vagrant destroys the machine.\n\n``` shell\n$ vagrant destroy ubuntu\n```\n\nAn example of defining three triggers that start and stop tinyproxy on your host machine using homebrew:\n\n``` shell\n#/bin/bash\n# start-tinyproxy.sh\nbrew services start tinyproxy\n```\n\n``` shell\n#/bin/bash\n# stop-tinyproxy.sh\nbrew services stop tinyproxy\n```\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.define \"ubuntu\" do |ubuntu|\n    ubuntu.vm.box = \"ubuntu\"\n\n    ubuntu.trigger.before :up do |trigger|\n      trigger.info = \"Starting tinyproxy...\"\n      trigger.run = {path: \"start-tinyproxy.sh\"}\n    end\n\n    ubuntu.trigger.after :destroy, :halt do |trigger|\n      trigger.info = \"Stopping tinyproxy...\"\n      trigger.run = {path: \"stop-tinyproxy.sh\"}\n    end\n  end\nend\n```\n\nRunning `vagrant up` would fire the before trigger to start tinyproxy, where as running either `vagrant destroy` or `vagrant halt` would stop tinyproxy.\n\n### Ruby Option\n\nTriggers can also be defined to run Ruby, rather than bash or powershell. An example of this might be using a Ruby option to get more information from the `VBoxManage` tool. In this case, we are printing the `ostype` defined for thte guest after it has been brought up.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.define \"ubuntu\" do |ubuntu|\n    ubuntu.vm.box = \"ubuntu\"\n\n    ubuntu.trigger.after :up do |trigger|\n      trigger.info = \"More information with ruby magic\"\n      trigger.ruby do |env,machine|\n        puts `VBoxManage showvminfo #{machine.id} --machinereadable | grep ostype`\n      end\n    end\n  end\nend\n```\n\nIf you are defining your triggers using the hash syntax, you must use the `Proc` type for defining a ruby trigger.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.define \"ubuntu\" do |ubuntu|\n    ubuntu.vm.box = \"ubuntu\"\n\n    ubuntu.trigger.after :up,\n      info: \"More information with ruby magic\",\n      ruby: proc{|env,machine| puts `VBoxManage showvminfo #{machine.id} --machinereadable | grep ostype`}\n  end\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/triggers/usage.html](https://www.vagrantup.com/docs/triggers/usage.html)"
- name: Basic Usage of Networking
  id: networking/basic_usage
  summary: Vagrant offers multiple options for how you are able to connect your guest machines to the network, but there is a standard usage pattern as well as some points common to all network configurations that are important to know
  description: "# Basic Usage of Networking\n\nVagrant offers multiple options for how you are able to connect your guest machines to the network, but there is a standard usage pattern as well as some points common to all network configurations that are important to know.\n\n## Configuration\n\nAll networks are configured within your [Vagrantfile](../vagrantfile/index) using the `config.vm.network` method call. For example, the Vagrantfile below defines some port forwarding:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ...\n  config.vm.network \"forwarded_port\", guest: 80, host: 8080\nend\n```\n\nEvery network type has an identifier such as `\"forwarded_port\"` in the above example. Following this is a set of configuration arguments that can differ for each network type. In the case of forwarded ports, two numeric arguments are expected: the port on the guest followed by the port on the host that the guest port can be accessed by.\n\n## Multiple Networks\n\nMultiple networks can be defined by having multiple `config.vm.network` calls within the Vagrantfile. The exact meaning of this can differ for each [provider](../providers/index), but in general the order specifies the order in which the networks are enabled.\n\n## Enabling Networks\n\nNetworks are automatically configured and enabled after they've been defined in the Vagrantfile as part of the `vagrant up` or `vagrant reload` process.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/networking/basic_usage.html](https://www.vagrantup.com/docs/networking/basic_usage.html)"
- name: Basic Usage of Provisioners
  id: provisioning/basic_usage
  summary: While Vagrant offers multiple options for how you are able to provision your machine, there is a standard usage pattern as well as some important points common to all provisioners that are important to know
  description: "# Basic Usage of Provisioners\n\nWhile Vagrant offers multiple options for how you are able to provision your machine, there is a standard usage pattern as well as some important points common to all provisioners that are important to know.\n\n## Configuration\n\nFirst, every provisioner is configured within your [Vagrantfile](../vagrantfile/index) using the `config.vm.provision` method call. For example, the Vagrantfile below enables shell provisioning:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ... other configuration\n\n  config.vm.provision \"shell\", inline: \"echo hello\"\nend\n```\n\nEvery provisioner has a type, such as `\"shell\"`, used as the first parameter to the provisioning configuration. Following that is basic key/value for configuring that specific provisioner. Instead of basic key/value, you can also use a Ruby block for a syntax that is more like variable assignment. The following is effectively the same as the prior example:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ... other configuration\n\n  config.vm.provision \"shell\" do |s|\n    s.inline = \"echo hello\"\n  end\nend\n```\n\nThe benefit of the block-based syntax is that with more than a couple options it can greatly improve readability. Additionally, some provisioners, like the Chef provisioner, have special methods that can be called within that block to ease configuration that cannot be done with the key/value approach, or you can use this syntax to pass arguments to a shell script.\n\nThe attributes that can be set in a single-line are the attributes that are set with the `=` style, such as `inline = \"echo hello\"` above. If the style is instead more of a function call, such as `add_recipe \"foo\"`, then this cannot be specified in a single line.\n\nProvisioners can also be named (since 1.7.0). These names are used cosmetically for output as well as overriding provisioner settings (covered further below). An example of naming provisioners is shown below:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ... other configuration\n\n  config.vm.provision \"bootstrap\", type: \"shell\" do |s|\n    s.inline = \"echo hello\"\n  end\nend\n```\n\nNaming provisioners is simple. The first argument to `config.vm.provision` becomes the name, and then a `type` option is used to specify the provisioner type, such as `type: \"shell\"` above.\n\n## Running Provisioners\n\nProvisioners are run in three cases: the initial `vagrant up`, `vagrant provision`, and `vagrant reload --provision`.\n\nA `--no-provision` flag can be passed to `up` and `reload` if you do not want to run provisioners. Likewise, you can pass `--provision` to force provisioning.\n\nThe `--provision-with` flag can be used if you only want to run a specific provisioner if you have multiple provisioners specified. For example, if you have a shell and Puppet provisioner and only want to run the shell one, you can do `vagrant provision --provision-with shell`. The arguments to `--provision-with` can be the provisioner type (such as \"shell\") or the provisioner name (such as \"bootstrap\" from above).\n\n## Run Once, Always or Never\n\nBy default, provisioners are only run once, during the first `vagrant up` since the last `vagrant destroy`, unless the `--provision` flag is set, as noted above.\n\nOptionally, you can configure provisioners to run on every `up` or `reload`. They will only be not run if the `--no-provision` flag is explicitly specified. To do this set the `run` option to \"always\", as shown below:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\", inline: \"echo hello\",\n    run: \"always\"\nend\n```\n\nYou can also set `run:` to `\"never\"` if you have an optional provisioner that you want to mention to the user in a \"post up message\" or that requires some other configuration before it is possible, then call this with `vagrant provision --provision-with bootstrap`.\n\nIf you are using the block format, you must specify it outside of the block, as shown below:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"bootstrap\", type: \"shell\", run: \"never\" do |s|\n    s.inline = \"echo hello\"\n  end\nend\n```\n\n## Multiple Provisioners\n\nMultiple `config.vm.provision` methods can be used to define multiple provisioners. These provisioners will be run in the order they're defined. This is useful for a variety of reasons, but most commonly it is used so that a shell script can bootstrap some of the system so that another provisioner can take over later.\n\nIf you define provisioners at multiple \"scope\" levels (such as globally in the configuration block, then in a [multi-machine](../multi-machine/index) definition, then maybe in a [provider-specific override](../providers/configuration)), then the outer scopes will always run *before* any inner scopes. For example, in the Vagrantfile below:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\", inline: \"echo foo\"\n\n  config.vm.define \"web\" do |web|\n    web.vm.provision \"shell\", inline: \"echo bar\"\n  end\n\n  config.vm.provision \"shell\", inline: \"echo baz\"\nend\n```\n\nThe ordering of the provisioners will be to echo \"foo\", \"baz\", then \"bar\" (note the second one might not be what you expect!). Remember: ordering is *outside in*.\n\nWith multiple provisioners, use the `--provision-with` setting along with names to get more fine grained control over what is run and when.\n\n## Overriding Provisioner Settings\n\n> **Warning: Advanced Topic!** Provisioner overriding is an advanced topic that really only becomes useful if you are already using multi-machine and/or provider overrides. If you are just getting started with Vagrant, you can safely skip this.\n\nWhen using features such as [multi-machine](../multi-machine/index) or [provider-specific overrides](../providers/configuration), you may want to define common provisioners in the global configuration scope of a Vagrantfile, but override certain aspects of them internally. Vagrant allows you to do this, but has some details to consider.\n\nTo override settings, you must assign a name to your provisioner.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"foo\", type: \"shell\",\n    inline: \"echo foo\"\n\n  config.vm.define \"web\" do |web|\n    web.vm.provision \"foo\", type: \"shell\",\n      inline: \"echo bar\"\n  end\nend\n```\n\nIn the above, only \"bar\" will be echoed, because the inline setting overloaded the outer provisioner. This overload is only effective within that scope: the \"web\" VM. If there were another VM defined, it would still echo \"foo\" unless it itself also overloaded the provisioner.\n\n**Be careful with ordering.** When overriding a provisioner in a sub-scope, the provisioner will run at *that point*. In the example below, the output would be \"foo\" then \"bar\":\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"foo\", type: \"shell\",\n    inline: \"echo ORIGINAL!\"\n\n  config.vm.define \"web\" do |web|\n    web.vm.provision \"shell\",\n      inline: \"echo foo\"\n    web.vm.provision \"foo\", type: \"shell\",\n      inline: \"echo bar\"\n  end\nend\n```\n\nIf you want to preserve the original ordering, you can specify the `preserve_order: true` flag:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"do-this\",\n    type: \"shell\",\n    preserve_order: true,\n    inline: \"echo FIRST!\"\n  config.vm.provision \"then-this\",\n    type: \"shell\",\n    preserve_order: true,\n    inline: \"echo SECOND!\"\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/basic_usage.html](https://www.vagrantup.com/docs/provisioning/basic_usage.html)"
- name: Box File Format
  id: boxes/format
  summary: In the past, boxes were just tar files of VirtualBox exports
  description: "# Box File Format\n\nIn the past, boxes were just [tar files](https://en.wikipedia.org/wiki/Tar_(computing)) of VirtualBox exports. With Vagrant supporting multiple [providers](../providers/index) and [versioning](versioning) now, box files are slightly more complicated.\n\nBox files made for Vagrant 1.0.x (the VirtualBox export `tar` files) continue to work with Vagrant today. When Vagrant encounters one of these old boxes, it automatically updates it internally to the new format.\n\nToday, there are three different components:\n\n- Box File - This is a compressed (`tar`, `tar.gz`, `zip`) file that is specific to a single provider and can contain anything. Vagrant core does not ever use the contents of this file. Instead, they are passed to the provider. Therefore, a VirtualBox box file has different contents from a VMware box file and so on.\n\n- Box Catalog Metadata - This is a JSON document (typically exchanged during interactions with [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud)) that specifies the name of the box, a description, available versions, available providers, and URLs to the actual box files (next component) for each provider and version. If this catalog metadata does not exist, a box file can still be added directly, but it will not support versioning and updating.\n\n- Box Information - This is a JSON document that can provide additional information about the box that displays when a user runs `vagrant box list -i`. More information is provided [here](info).\n\nThe first two components are covered in more detail below.\n\n## Box File\n\nThe actual box file is the required portion for Vagrant. It is recommended you always use a metadata file alongside a box file, but direct box files are supported for legacy reasons in Vagrant.\n\nBox files are compressed using `tar`, `tar.gz`, or `zip`. The contents of the archive can be anything, and is specific to each [provider](../providers/index). Vagrant core itself only unpacks the boxes for use later.\n\nWithin the archive, Vagrant does expect a single file: `metadata.json`. This is a JSON file that is completely unrelated to the above box catalog metadata component; there is only one `metadata.json` per box file (inside the box file), whereas one catalog metadata JSON document can describe multiple versions of the same box, potentially spanning multiple providers.\n\n`metadata.json` must contain at least the \"provider\" key with the provider the box is for. Vagrant uses this to verify the provider of the box. For example, if your box was for VirtualBox, the `metadata.json` would look like this:\n\n``` json\n{\n  \"provider\": \"virtualbox\"\n}\n```\n\nIf there is no `metadata.json` file or the file does not contain valid JSON with at least a \"provider\" key, then Vagrant will error when adding the box, because it cannot verify the provider.\n\nOther keys/values may be added to the metadata without issue. The value of the metadata file is passed opaquely into Vagrant and plugins can make use of it. At this point, Vagrant core does not use any other keys in this file.\n\n## Box Metadata\n\nThe metadata is an optional component for a box (but highly recommended) that enables [versioning](versioning), updating, multiple providers from a single file, and more.\n\n> **You do not need to manually make the metadata.** If you have an account with [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud), you can create boxes there, and HashiCorp's Vagrant Cloud automatically creates the metadata for you. The format is still documented here.\n\nIt is a JSON document, structured in the following way:\n\n``` json\n{\n  \"name\": \"hashicorp/precise64\",\n  \"description\": \"This box contains Ubuntu 12.04 LTS 64-bit.\",\n  \"versions\": [\n    {\n      \"version\": \"0.1.0\",\n      \"providers\": [\n        {\n          \"name\": \"virtualbox\",\n          \"url\": \"http://somewhere.com/precise64_010_virtualbox.box\",\n          \"checksum_type\": \"sha1\",\n          \"checksum\": \"foo\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nAs you can see, the JSON document can describe multiple versions of a box, multiple providers, and can add/remove providers in different versions.\n\nThis JSON file can be passed directly to `vagrant box add` from the local filesystem using a file path or via a URL, and Vagrant will install the proper version of the box. In this case, the value for the `url` key in the JSON can also be a file path. If multiple providers are available, Vagrant will ask what provider you want to use.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/boxes/format.html](https://www.vagrantup.com/docs/boxes/format.html)"
- name: Box Versioning
  id: boxes/versioning
  summary: Since Vagrant 1.5, boxes support versioning
  description: "# Box Versioning\n\nSince Vagrant 1.5, boxes support versioning. This allows the people who make boxes to push updates to the box, and the people who use the box have a simple workflow for checking for updates, updating their boxes, and seeing what has changed.\n\nIf you are just getting started with Vagrant, box versioning is not too important, and we recommend learning about some other topics first. But if you are using Vagrant on a team or plan on creating your own boxes, versioning is very important. Luckily, having versioning built right in to Vagrant makes it easy to use and fit nicely into the Vagrant workflow.\n\nThis page will cover how to use versioned boxes. It does *not* cover how to update your own custom boxes with versions. That is covered in [creating a base box](base).\n\n## Viewing Versions and Updating\n\n`vagrant box list` only shows *installed* versions of boxes. If you want to see all available versions of a box, you will have to find the box on [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud). An easy way to find a box is to use the url `https://vagrantcloud.com/$USER/$BOX`. For example, for the `hashicorp/precise64` box, you can find information about it at `https://vagrantcloud.com/hashicorp/precise64`.\n\nYou can check if the box you are using is outdated with `vagrant box outdated`. This can check if the box in your current Vagrant environment is outdated as well as any other box installed on the system.\n\nFinally, you can update boxes with `vagrant box update`. This will download and install the new box. This *will not* magically update running Vagrant environments. If a Vagrant environment is already running, you will have to destroy and recreate it to acquire the new updates in the box. The update command just downloads these updates locally.\n\n## Version Constraints\n\nYou can constrain a Vagrant environment to a specific version or versions of a box using the [Vagrantfile](../vagrantfile/index) by specifying the `config.vm.box_version` option.\n\nIf this option is not specified, the latest version is always used. This is equivalent to specifying a constraint of \"\\>= 0\".\n\nThe box version configuration can be a specific version or a constraint of versions. Constraints can be any combination of the following: `= X`, `> X`, `< X`, `>= X`, `<= X`, `~> X`. You can combine multiple constraints by separating them with commas. All the constraints should be self explanatory except perhaps for `~>`, known as the \"pessimistic constraint\". Examples explain it best: `~> 1.0` is equivalent to `>= 1.0, < 2.0`. And `~> 1.1.5` is equivalent to `>= 1.1.5, < 1.2.0`.\n\nYou can choose to handle versions however you see fit. However, many boxes in the public catalog follow [semantic versioning](http://semver.org/). Basically, only the first number (the \"major version\") breaks backwards compatibility. In terms of Vagrant boxes, this means that any software that runs in version \"1.1.5\" of a box should work in \"1.2\" and \"1.4.5\" and so on, but \"2.0\" might introduce big changes that break your software. By following this convention, the best constraint is `~> 1.0` because you know it is safe no matter what version is in that range.\n\nPlease note that, while the semantic versioning specification allows for more than three points and pre-release or beta versions, Vagrant boxes must be of the format `X.Y.Z` where `X`, `Y`, and `Z` are all positive integers.\n\n## Automatic Update Checking\n\nUsing the [Vagrantfile](../vagrantfile/index), you can also configure Vagrant to automatically check for updates during any `vagrant up`. This is enabled by default, but can easily be disabled with `config.vm.box_check_update = false` in your Vagrantfile.\n\nWhen this is enabled, Vagrant will check for updates on every `vagrant up`, not just when the machine is being created from scratch, but also when it is resuming, starting after being halted, etc.\n\nIf an update is found, Vagrant will output a warning to the user letting them know an update is available. That user can choose to ignore the warning for now, or can update the box by running `vagrant box update`.\n\nVagrant can not and does not automatically download the updated box and update the machine because boxes can be relatively large and updating the machine requires destroying it and recreating it, which can cause important data to be lost. Therefore, this process is manual to the extent that the user has to manually enter a command to do it.\n\n## Pruning Old Versions\n\nVagrant does not automatically prune old versions because it does not know if they might be in use by other Vagrant environments. Because boxes can be large, you may want to actively prune them once in a while using `vagrant box remove`. You can see all the boxes that are installed using `vagrant box list`.\n\nAnother option is to use `vagrant box prune` command to remove all installed boxes that are outdated and not currently in use.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/boxes/versioning.html](https://www.vagrantup.com/docs/boxes/versioning.html)"
- name: Boxes
  id: boxes
  summary: Boxes are the package format for Vagrant environments
  description: "# Boxes\n\nBoxes are the package format for Vagrant environments. A box can be used by anyone on any platform that Vagrant supports to bring up an identical working environment.\n\nThe `vagrant box` utility provides all the functionality for managing boxes. You can read the documentation on the [vagrant box](cli/box) command for more information.\n\nThe easiest way to use a box is to add a box from the [publicly available catalog of Vagrant boxes](https://vagrantcloud.com/boxes/search). You can also add and share your own customized boxes on this website.\n\nBoxes also support versioning so that members of your team using Vagrant can update the underlying box easily, and the people who create boxes can push fixes and communicate these fixes efficiently.\n\nYou can learn all about boxes by reading this page as well as the sub-pages in the navigation to the left.\n\n## Discovering Boxes\n\nThe easiest way to find boxes is to look on the [public Vagrant box catalog](https://vagrantcloud.com/boxes/search) for a box matching your use case. The catalog contains most major operating systems as bases, as well as specialized boxes to get you up and running quickly with LAMP stacks, Ruby, Python, etc.\n\nThe boxes on the public catalog work with many different [providers](providers/index). Whether you are using Vagrant with VirtualBox, VMware, AWS, etc. you should be able to find a box you need.\n\nAdding a box from the catalog is very easy. Each box shows you instructions with how to add it, but they all follow the same format:\n\n``` highlight\n$ vagrant box add USER/BOX\n```\n\nFor example: `vagrant box add hashicorp/precise64`. You can also quickly initialize a Vagrant environment with `vagrant init hashicorp/precise64`.\n\n> **Namespaces do not guarantee canonical boxes!** A common misconception is that a namespace like \"ubuntu\" represents the canonical space for Ubuntu boxes. This is untrue. Namespaces on Vagrant Cloud behave very similarly to namespaces on GitHub, for example. Just as GitHub's support team is unable to assist with issues in someone's repository, HashiCorp's support team is unable to assist with third-party published boxes.\n\n## Official Boxes\n\nHashiCorp (the makers of Vagrant) publish a basic Ubuntu 12.04 (32 and 64-bit) box that is available for minimal use cases. It is highly optimized, small in size, and includes support for Virtualbox and VMware. You can use it like this:\n\n``` shell\n$ vagrant init hashicorp/precise64\n```\n\nor you can update your `Vagrantfile` as follows:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise64\"\nend\n```\n\nFor other users, we recommend the [Bento boxes](https://vagrantcloud.com/bento). The Bento boxes are [open source](https://github.com/chef/bento) and built for a number of providers including VMware, Virtualbox, and Parallels. There are a variety of operating systems and versions available.\n\nThese are the only two officially-recommended box sets.\n\n> **It is often a point of confusion**, but Canonical (the company that makes the Ubuntu operating system) publishes boxes under the \"ubuntu\" namespace on Vagrant Cloud. These boxes only support Virtualbox and do not provide an ideal experience for most users. If you encounter issues with these boxes, please try the Bento boxes instead.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/boxes.html](https://www.vagrantup.com/docs/boxes.html)"
- name: Boxes
  id: vmware/boxes
  summary: As with every Vagrant provider, the Vagrant VMware providers have a custom box format
  description: "# Boxes\n\nAs with [every Vagrant provider](../providers/basic_usage), the Vagrant VMware providers have a custom box format.\n\nThis page documents the format so that you can create your own base boxes. Note that currently you must make these base boxes by hand. A future release of Vagrant will provide additional mechanisms for automatically creating such images.\n\n> **Note:** This is a reasonably advanced topic that a beginning user of Vagrant does not need to understand. If you are just getting started with Vagrant, skip this and use an available box. If you are an experienced user of Vagrant and want to create your own custom boxes, this is for you.\n\nPrior to reading this page, please understand the [basics of the box file format](../boxes/format).\n\n## Contents\n\nA VMware base box is a compressed archive of the necessary contents of a VMware \"vmwarevm\" file. Here is an example of what is contained in such a box:\n\n``` highlight\n$ tree\n.\n|-- disk-s001.vmdk\n|-- disk-s002.vmdk\n|-- ...\n|-- disk.vmdk\n|-- metadata.json\n|-- precise64.nvram\n|-- precise64.vmsd\n|-- precise64.vmx\n|-- precise64.vmxf\n\n0 directories, 17 files\n```\n\nThe files that are strictly required for a VMware machine to function are: nvram, vmsd, vmx, vmxf, and vmdk files.\n\nThere is also the \"metadata.json\" file used by Vagrant itself. This file contains nothing but the defaults which are documented on the [box format](../boxes/format) page.\n\nWhen bringing up a VMware backed machine, Vagrant copies all of the contents in the box into a privately managed \"vmwarevm\" folder, and uses the first \"vmx\" file found to control the machine.\n\n> **Vagrant 1.8 and higher support linked clones**. Prior versions of Vagrant do not support linked clones. For more information on linked clones, please see the documentation.\n\n## VMX Whitelisting\n\nSettings in the VMX file control the behavior of the VMware virtual machine when it is booted. In the past Vagrant has removed the configured network device when creating a new instance and inserted a new configuration. With the introduction of [\"predictable network interface names\"](https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/) this approach can cause unexpected behaviors or errors with VMware Vagrant boxes. While some boxes that use the predictable network interface names are configured to handle the VMX modifications Vagrant makes, it is better if Vagrant does not make the modification at all.\n\nVagrant will now warn if a whitelisted setting is detected within a Vagrant box VMX file. If it is detected, a warning will be shown alerting the user and providing a configuration snippet. The configuration snippet can be used in the Vagrantfile if Vagrant fails to start the virtual machine.\n\n### Making compatible boxes\n\nThese are the VMX settings the whitelisting applies to:\n\n- [`ethernet*.pcislotnumber`](#ethernet-pcislotnumber)\n\nIf the newly created box does not depend on Vagrant's existing behavior of modifying this setting, it can disable Vagrant from applying the modification by adding a Vagrantfile to the box with the following content:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  [\"vmware_workstation\", \"vmware_fusion\"].each do |vmware_provider|\n    config.vm.provider(vmware_provider) do |vmware|\n      vmware.whitelist_verified = true\n    end\n  end\nend\n```\n\nThis will prevent Vagrant from displaying a warning to the user as well as disable the VMX settings modifications.\n\n## Installed Software\n\nBase boxes for VMware should have the following software installed, as a bare minimum:\n\n- SSH server with key-based authentication setup. If you want the box to work with default Vagrant settings, the SSH user must be set to accept the [insecure keypair](https://github.com/hashicorp/vagrant/blob/master/keys/vagrant.pub) that ships with Vagrant.\n\n- [VMware Tools](https://kb.vmware.com/kb/340) so that things such as shared folders can function. There are many other benefits to installing the tools, such as improved networking performance.\n\n## Optimizing Box Size\n\nPrior to packaging up a box, you should shrink the hard drives as much as possible. This can be done with `vmware-vdiskmanager` which is usually found in `/Applications/VMware Fusion.app/Contents/Library` for VMware Fusion. You first want to defragment then shrink the drive. Usage shown below:\n\n``` highlight\n$ vmware-vdiskmanager -d /path/to/main.vmdk\n...\n$ vmware-vdiskmanager -k /path/to/main.vmdk\n...\n```\n\n## Packaging\n\nRemove any extraneous files from the \"vmwarevm\" folder and package it. Be sure to compress the tar with gzip (done below in a single command) since VMware hard disks are not compressed by default.\n\n``` highlight\n$ cd /path/to/my/vm.vmwarevm\n$ tar cvzf custom.box ./*\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vmware/boxes.html](https://www.vagrantup.com/docs/vmware/boxes.html)"
- name: CFEngine Provisioner
  id: provisioning/cfengine
  summary: The Vagrant CFEngine provisioner allows you to provision the guest using CFEngine
  description: "# CFEngine Provisioner\n\n**Provisioner name: `cfengine`**\n\nThe Vagrant CFEngine provisioner allows you to provision the guest using [CFEngine](https://cfengine.com/). It can set up both CFEngine policy servers and clients. You can configure both the policy server and the clients in a single [multi-machine `Vagrantfile`](../multi-machine/index).\n\n> **Warning:** If you are not familiar with CFEngine and Vagrant already, I recommend starting with the [shell provisioner](shell). However, if you are comfortable with Vagrant already, Vagrant is the best way to learn CFEngine.\n\nLet us look at some common examples first. See the bottom of this document for a comprehensive list of options.\n\n## Setting up a CFEngine server and client\n\nThe CFEngine provisioner automatically installs the latest [CFEngine Community packages](https://cfengine.com/cfengine-linux-distros) on the VM, then configures and starts CFEngine according to your specification.\n\nConfiguring a VM as a CFEngine policy server is easy:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"cfengine\" do |cf|\n    cf.am_policy_hub = true\n  end\nend\n```\n\nThe host will automatically be [bootstrapped](https://cfengine.com/docs/3.5/manuals-architecture-networking.html#bootstrapping) to itself to become a policy server.\n\nIf you already have a working CFEngine policy server, you can get a CFEngine client installed and bootstrapped by specifying its IP address:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"cfengine\" do |cf|\n    cf.policy_server_address = \"10.0.2.15\"\n  end\nend\n```\n\n## Copying files to the VM\n\nIf you have some policy or other files that you want to install by default on a VM, you can use the `files_path` attribute:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n   config.vm.provision \"cfengine\" do |cf|\n      cf.am_policy_hub = true\n      cf.files_path = \"cfengine_files\"\n    end\n  end\n```\n\nEverything under `cfengine_files/` in the Vagrant project directory will be recursively copied under `/var/cfengine/` in the VM, on top of its default contents.\n\nA common use case is to add your own files to `/var/cfengine/masterfiles/` in the policy server. Assuming your extra files are stored under `cfengine_files/masterfiles/`, the line shown above will add them to the VM after CFEngine is installed, but before it is bootstrapped.\n\n## Modes of operation\n\nThe default mode of operation is `:bootstrap`, which results in CFEngine being bootstrapped according to the information provided in the `Vagrantfile`. You can also set `mode` to `:single_run`, which will run `cf-agent` once on the host to execute the file specified in the `run_file` parameter, but will not bootstrap it, so it will not be executed periodically.\n\nThe recommended mode of operation is `:bootstrap`, as you get the full benefits of CFEngine when you have it running periodically.\n\n## Running a standalone file\n\nIf you want to run a standalone file, you can specify the `run_file` parameter. The file will be copied to the VM and executed on its own using `cf-agent`. Note that the file needs to be a standalone policy, including its own [`body common control`](https://cfengine.com/docs/3.5/reference-components.html#common-control).\n\nThe `run_file` parameter is mandatory if `mode` is set to `:single_run`, but can also be specified when `mode` is set to `:bootstrap` - in this case the file will be executed after the host has been bootstrapped.\n\n## Full Alphabetical List of Configuration Options\n\n- [`am_policy_hub`](#am_policy_hub) (boolean, default `false`) determines whether the VM will be configured as a CFEngine policy hub (automatically bootstrapped to its own IP address). You can combine it with `policy_server_address` if the VM has multiple network interfaces and you want to bootstrap to a specific one.\n- [`extra_agent_args`](#extra_agent_args) (string, default `nil`) can be used to pass additional arguments to `cf-agent` when it is executed. For example, you could use it to pass the `-I` or `-v` options to enable additional output from the agent.\n- [`classes`](#classes) (array, default `nil`) can be used to define additional classes during `cf-agent` runs. These classes will be defined using the `-D` option to `cf-agent`.\n- [`deb_repo_file`](#deb_repo_file) (string, default `\"/etc/apt/sources.list.d/cfengine-community.list\"`) specifies the file in which the CFEngine repository information will be stored in Debian systems.\n- [`deb_repo_line`](#deb_repo_line) (string, default `\"deb https://cfengine.com/pub/apt $(lsb_release -cs) main\"`) specifies the repository to use for `.deb` packages.\n- [`files_path`](#files_path) (string, default `nil`) specifies a directory that will be copied to the VM on top of the default `/var/cfengine/` (the contents of `/var/cfengine/` will not be replaced, the files will added to it).\n- [`force_bootstrap`](#force_bootstrap) (boolean, default `false`) specifies whether CFEngine will be bootstrapped again even if the host has already been bootstrapped.\n- [`install`](#install) (boolean or `:force`, default `true`) specifies whether CFEngine will be installed on the VM if needed. If you set this parameter to `:force`, then CFEngine will be reinstalled even if it is already present on the machine.\n- [`mode`](#mode) (`:bootstrap` or `:single_run`, default `:bootstrap`) specifies whether CFEngine will be bootstrapped so that it executes periodically, or will be run a single time. If `mode` is set to `:single_run` you have to set `run_file`.\n- [`policy_server_address`](#policy_server_address) (string, no default) specifies the IP address of the policy server to which CFEngine will be bootstrapped. If `am_policy_hub` is set to `true`, this parameter defaults to the VM's IP address, but can still be set (for example, if the VM has more than one network interface).\n- [`repo_gpg_key_url`](#repo_gpg_key_url) (string, default `\"https://cfengine.com/pub/gpg.key\"`) contains the URL to obtain the GPG key used to verify the packages obtained from the repository.\n- [`run_file`](#run_file) (string, default `nil`) can be used to specify a file inside the Vagrant project directory that will be copied to the VM and executed once using `cf-agent`. This parameter is mandatory if `mode` is set to `:single_run`, but can also be specified when `mode` is set to `:bootstrap` - in this case the file will be executed after the host has been bootstrapped.\n- [`upload_path`](#upload_path) (string, default `\"/tmp/vagrant-cfengine-file\"`) specifies the file to which `run_file` (if specified) will be copied on the VM before being executed.\n- [`yum_repo_file`](#yum_repo_file) (string, default `\"/etc/yum.repos.d/cfengine-community.repo\"`) specifies the file in which the CFEngine repository information will be stored in RedHat systems.\n- [`yum_repo_url`](#yum_repo_url) (string, default `\"https://cfengine.com/pub/yum/\"`) specifies the URL of the repository to use for `.rpm` packages.\n- [`package_name`](#package_name) (string, default `\"cfengine-community\"`) specifies the name of the package used to install CFEngine.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/cfengine.html](https://www.vagrantup.com/docs/provisioning/cfengine.html)"
- name: Chef Apply Provisioner
  id: provisioning/chef_apply
  summary: The Vagrant Chef Apply provisioner allows you to provision the guest using Chef, specifically with Chef Apply
  description: "# Chef Apply Provisioner\n\n**Provisioner name: `chef_apply`**\n\nThe Vagrant Chef Apply provisioner allows you to provision the guest using [Chef](https://www.getchef.com/), specifically with [Chef Apply](https://docs.getchef.com/ctl_chef_apply.html).\n\nChef Apply is ideal for people who are already experienced with Chef and the Chef ecosystem. Specifically, this documentation page does not cover how use Chef or how to write Chef recipes.\n\n> **Warning:** If you are not familiar with Chef and Vagrant already, we recommend starting with the [shell provisioner](shell).\n\n## Options\n\nThis section lists the complete set of available options for the Chef Apply provisioner. More detailed examples of how to use the provisioner are available below this section.\n\n- [`recipe`](#recipe) (string) - The raw recipe contents to execute using Chef Apply on the guest.\n\n- [`log_level`](#log_level) (string) - The log level to use while executing `chef-apply`. The default value is \"info\".\n\n- [`upload_path`](#upload_path) (string) - **Advanced!** The location on the guest where the generated recipe file should be stored. For most use cases, it is unlikely you will need to customize this value. The default value is `/tmp/vagrant-chef-apply-#` where `#` is a unique counter generated by Vagrant to prevent collisions.\n\nIn addition to all the options listed above, the Chef Apply provisioner supports the [common options for all Chef provisioners](chef_common).\n\n## Specifying a Recipe\n\nThe easiest way to get started with the Chef Apply provisioner is to just specify an inline [Chef recipe](https://docs.chef.io/recipes.html). For example:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_apply\" do |chef|\n    chef.recipe = \"package[apache2]\"\n  end\nend\n```\n\nThis causes Vagrant to run Chef Apply with the given recipe contents. If you are familiar with Chef, you know this will install the apache2 package from the system package provider.\n\nSince single-line Chef recipes are rare, you can also specify the recipe using a \"heredoc\":\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_apply\" do |chef|\n    chef.recipe = <<-RECIPE\n      package \"apache2\"\n\n      template \"/etc/apache2/my.config\" do\n        # ...\n      end\n    RECIPE\n  end\nend\n```\n\nFinally, if you would prefer to store the recipe as plain-text, you can set the recipe to the contents of a file:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_apply\" do |chef|\n    chef.recipe = File.read(\"/path/to/my/recipe.rb\")\n  end\nend\n```\n\n## Roles\n\nThe Vagrant Chef Apply provisioner does not support roles. Please use a different Vagrant Chef provisioner if you need support for roles.\n\n## Data Bags\n\nThe Vagrant Chef Apply provisioner does not support data_bags. Please use a different Vagrant Chef provisioner if you need support for data_bags.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/chef_apply.html](https://www.vagrantup.com/docs/provisioning/chef_apply.html)"
- name: Chef Client Provisioner
  id: provisioning/chef_client
  summary: The Vagrant Chef Client provisioner allows you to provision the guest using Chef, specifically by connecting to an existing Chef Server and registering the Vagrant machine as a node within your infrastructure
  description: "# Chef Client Provisioner\n\n**Provisioner name: `chef_client`**\n\nThe Vagrant Chef Client provisioner allows you to provision the guest using [Chef](https://www.chef.io/chef/), specifically by connecting to an existing Chef Server and registering the Vagrant machine as a node within your infrastructure.\n\nIf you are just learning Chef for the first time, you probably want to start with the [Chef Solo](chef_solo) provisioner.\n\n> **Warning:** If you are not familiar with Chef and Vagrant already, I recommend starting with the [shell provisioner](shell).\n\n## Authenticating\n\nThe minimum required to use provision using Chef Client is to provide a URL to the Chef Server as well as the path to the validation key so that the node can register with the Chef Server:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_client\" do |chef|\n    chef.chef_server_url = \"http://mychefserver.com\"\n    chef.validation_key_path = \"validation.pem\"\n  end\nend\n```\n\nThe node will register with the Chef Server specified, download the proper run list for that node, and provision.\n\n## Specifying a Run List\n\nNormally, the Chef Server is responsible for specifying the run list for the node. However, you can override what the Chef Server sends down by manually specifying a run list:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_client\" do |chef|\n    # Add a recipe\n    chef.add_recipe \"apache\"\n\n    # Or maybe a role\n    chef.add_role \"web\"\n  end\nend\n```\n\nRemember, this will *override* the run list specified on the Chef server itself.\n\n## Environments\n\nYou can specify the [environment](https://docs.chef.io/environments.html) for the node to come up in using the `environment` configuration option:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_client\" do |chef|\n    # ...\n\n    chef.environment = \"development\"\n  end\nend\n```\n\n## Other Configuration Options\n\nThere are a few more configuration options available. These generally do not need to be modified but are available if your Chef Server requires customization of these variables.\n\n- [`client_key_path`](#client_key_path)\n- [`node_name`](#node_name)\n- [`validation_client_name`](#validation_client_name)\n\nIn addition to all the options listed above, the Chef Client provisioner supports the [common options for all Chef provisioners](chef_common).\n\n## Cleanup\n\nWhen you provision your Vagrant virtual machine with Chef Server, it creates a new Chef \"node\" entry and Chef \"client\" entry on the Chef Server, using the hostname of the machine. After you tear down your guest machine, Vagrant can be configured to do it automatically with the following settings:\n\n``` ruby\nchef.delete_node = true\nchef.delete_client = true\n```\n\nIf you do not specify it or set it to `false`, you must explicitly delete these entries from the Chef Server before you provision a new one with Chef Server. For example, using Chef's built-in `knife` tool:\n\n``` highlight\n$ knife node delete precise64\n$ knife client delete precise64\n```\n\nIf you fail to do so, you will get the following error when Vagrant tries to provision the machine with Chef Client:\n\n``` highlight\nHTTP Request Returned 409 Conflict: Client already exists.\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/chef_client.html](https://www.vagrantup.com/docs/provisioning/chef_client.html)"
- name: Chef Solo Provisioner
  id: provisioning/chef_solo
  summary: The Vagrant Chef Solo provisioner allows you to provision the guest using Chef, specifically with Chef Solo
  description: "# Chef Solo Provisioner\n\n**Provisioner name: `chef_solo`**\n\nThe Vagrant Chef Solo provisioner allows you to provision the guest using [Chef](https://www.chef.io/chef/), specifically with [Chef Solo](https://docs.chef.io/chef_solo.html).\n\nChef Solo is ideal for people who are already experienced with Chef, already have Chef cookbooks, or are looking to learn Chef. Specifically, this documentation page will not go into how to use Chef or how to write Chef cookbooks, since Chef is a complete system that is beyond the scope of a single page of documentation.\n\n> **Warning:** If you are not familiar with Chef and Vagrant already, I recommend starting with the [shell provisioner](shell). However, if you are comfortable with Vagrant already, Vagrant is the best way to learn Chef.\n\n## Options\n\nThis section lists the complete set of available options for the Chef Solo provisioner. More detailed examples of how to use the provisioner are available below this section.\n\n- [`cookbooks_path`](#cookbooks_path) (string or array) - A list of paths to where cookbooks are stored. By default this is \"cookbooks\", expecting a cookbooks folder relative to the Vagrantfile location.\n\n- [`data_bags_path`](#data_bags_path) (string or array) - A path where data bags are stored. By default, no data bag path is set. Chef 12 or higher is required to use the array option. Chef 11 and lower only accept a string value.\n\n- [`environments_path`](#environments_path) (string) - A path where environment definitions are located. By default, no environments folder is set.\n\n- [`nodes_path`](#nodes_path) (string or array) - A list of paths where node objects (in JSON format) are stored. By default, no nodes path is set.\n\n- [`environment`](#environment) (string) - The environment you want the Chef run to be a part of. This requires Chef 11.6.0 or later, and that `environments_path` is set.\n\n- [`recipe_url`](#recipe_url) (string) - URL to an archive of cookbooks that Chef will download and use.\n\n- [`roles_path`](#roles_path) (string or array) - A list of paths where roles are defined. By default this is empty. Multiple role directories are only supported by Chef 11.8.0 and later.\n\n- [`synced_folder_type`](#synced_folder_type) (string) - The type of synced folders to use when sharing the data required for the provisioner to work properly. By default this will use the default synced folder type. For example, you can set this to \"nfs\" to use NFS synced folders.\n\nIn addition to all the options listed above, the Chef Solo provisioner supports the [common options for all Chef provisioners](chef_common).\n\n## Specifying a Run List\n\nThe easiest way to get started with the Chef Solo provisioner is to just specify a [run list](https://docs.chef.io/nodes.html#about-run-lists). This looks like:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_solo\" do |chef|\n    chef.add_recipe \"apache\"\n  end\nend\n```\n\nThis causes Vagrant to run Chef Solo with the \"apache\" cookbook. The cookbooks by default are looked for in the \"cookbooks\" directory relative to your project root. The directory structure ends up looking like this:\n\n``` highlight\n$ tree\n.\n|-- Vagrantfile\n|-- cookbooks\n|   |-- apache\n|       |-- recipes\n|           |-- default.rb\n```\n\nThe order of the calls to `add_recipe` will specify the order of the run list. Earlier recipes added with `add_recipe` are run before later recipes added.\n\n## Custom Cookbooks Path\n\nInstead of using the default \"cookbooks\" directory, a custom cookbooks path can also be set via the `cookbooks_path` configuration directive:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_solo\" do |chef|\n    chef.cookbooks_path = \"my_cookbooks\"\n  end\nend\n```\n\nThe path can be relative or absolute. If it is relative, it is relative to the project root.\n\nThe configuration value can also be an array of paths:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_solo\" do |chef|\n    chef.cookbooks_path = [\"cookbooks\", \"my_cookbooks\"]\n  end\nend\n```\n\n## Roles\n\nVagrant also supports provisioning with [Chef roles](https://docs.chef.io/roles.html). This is done by specifying a path to a roles folder where roles are defined and by adding roles to your run list:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_solo\" do |chef|\n    chef.roles_path = \"roles\"\n    chef.add_role(\"web\")\n  end\nend\n```\n\nJust like the cookbooks path, the roles path is relative to the project root if a relative path is given.\n\nThe configuration value can also be an array of paths on Chef 11.8.0 and newer. On older Chef versions only the first path is used.\n\n**Note:** The name of the role file must be the same as the role name. For example the `web` role must be in the `roles_path` as web.json or web.rb. This is required by Chef itself, and is not a limitation imposed by Vagrant.\n\n## Data Bags\n\n[Data bags](https://docs.chef.io/data_bags.html) are also supported by the Chef Solo provisioner. This is done by specifying a path to your data bags directory:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_solo\" do |chef|\n    chef.data_bags_path = \"data_bags\"\n  end\nend\n```\n\n## Custom JSON Data\n\nAdditional configuration data for Chef attributes can be passed in to Chef Solo. This is done by setting the `json` property with a Ruby hash (dictionary-like object), which is converted to JSON and passed in to Chef:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_solo\" do |chef|\n    # ...\n\n    chef.json = {\n      \"apache\" => {\n        \"listen_address\" => \"0.0.0.0\"\n      }\n    }\n  end\nend\n```\n\nHashes, arrays, etc. can be used with the JSON configuration object. Basically, anything that can be turned cleanly into JSON works.\n\n## Custom Node Name\n\nYou can specify a custom node name by setting the `node_name` property. This is useful for cookbooks that may depend on this being set to some sort of value. Example:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_solo\" do |chef|\n    chef.node_name = \"foo\"\n  end\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/chef_solo.html](https://www.vagrantup.com/docs/provisioning/chef_solo.html)"
- name: Chef Zero Provisioner
  id: provisioning/chef_zero
  summary: The Vagrant Chef Zero provisioner allows you to provision the guest using Chef, specifically with Chef Zero/local mode
  description: "# Chef Zero Provisioner\n\n**Provisioner name: `chef_zero`**\n\nThe Vagrant Chef Zero provisioner allows you to provision the guest using [Chef](https://www.getchef.com/chef/), specifically with [Chef Zero/local mode](https://docs.getchef.com/ctl_chef_client.html#run-in-local-mode).\n\nThis new provisioner is a middle ground between running a full blown Chef Server and using the limited [Chef Solo](chef_solo) provisioner. It runs a local in-memory Chef Server and fakes the validation and client key registration.\n\n> **Warning:** If you are not familiar with Chef and Vagrant already, I recommend starting with the [shell provisioner](shell). However, if you are comfortable with Vagrant already, Vagrant is the best way to learn Chef.\n\n## Options\n\nThis section lists the complete set of available options for the Chef Zero provisioner. More detailed examples of how to use the provisioner are available below this section.\n\n- [`cookbooks_path`](#cookbooks_path) (string or array) - A list of paths to where cookbooks are stored. By default this is \"cookbooks\", expecting a cookbooks folder relative to the Vagrantfile location.\n\n- [`data_bags_path`](#data_bags_path) (string or array) - A path where data bags are stored. By default, no data bag path is set. Chef 12 or higher is required to use the array option. Chef 11 and lower only accept a string value.\n\n- [`environments_path`](#environments_path) (string) - A path where environment definitions are located. By default, no environments folder is set.\n\n- [`nodes_path`](#nodes_path) (string or array) - A list of paths where node objects (in JSON format) are stored. By default, no nodes path is set. This value is required.\n\n- [`environment`](#environment) (string) - The environment you want the Chef run to be a part of. This requires Chef 11.6.0 or later, and that `environments_path` is set.\n\n- [`roles_path`](#roles_path) (string or array) - A list of paths where roles are defined. By default this is empty. Multiple role directories are only supported by Chef 11.8.0 and later.\n\n- [`synced_folder_type`](#synced_folder_type) (string) - The type of synced folders to use when sharing the data required for the provisioner to work properly. By default this will use the default synced folder type. For example, you can set this to \"nfs\" to use NFS synced folders.\n\nIn addition to all the options listed above, the Chef Zero provisioner supports the [common options for all Chef provisioners](chef_common).\n\n## Usage\n\nThe Chef Zero provisioner is configured basically the same way as the Chef Solo provisioner. See the [Chef Solo documentations](chef_solo) for more information.\n\nA basic example could look like this:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"chef_zero\" do |chef|\n    # Specify the local paths where Chef data is stored\n    chef.cookbooks_path = \"cookbooks\"\n    chef.data_bags_path = \"data_bags\"\n    chef.nodes_path = \"nodes\"\n    chef.roles_path = \"roles\"\n\n    # Add a recipe\n    chef.add_recipe \"apache\"\n\n    # Or maybe a role\n    chef.add_role \"web\"\n  end\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/chef_zero.html](https://www.vagrantup.com/docs/provisioning/chef_zero.html)"
- name: Command-Line Interface
  id: cli/index
  summary: Almost all interaction with Vagrant is done through the command-line interface
  description: "# Command-Line Interface\n\nAlmost all interaction with Vagrant is done through the command-line interface.\n\nThe interface is available using the `vagrant` command, and comes installed with Vagrant automatically. The `vagrant` command in turn has many subcommands, such as `vagrant up`, `vagrant destroy`, etc.\n\nIf you run `vagrant` by itself, help will be displayed showing all available subcommands. In addition to this, you can run any Vagrant command with the `-h` flag to output help about that specific command. For example, try running `vagrant init -h`. The help will output a one sentence synopsis of what the command does as well as a list of all the flags the command accepts.\n\nIn depth documentation and use cases of various Vagrant commands is available by reading the appropriate sub-section available in the left navigational area of this site.\n\nYou may also wish to consult the [documentation](../other/environmental-variables) regarding the environmental variables that can be used to configure and control Vagrant in a global way.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/](https://www.vagrantup.com/docs/cli/)"
- name: Common Issues
  id: virtualbox/common-issues
  summary: This page lists some common issues people run into with Vagrant and VirtualBox as well as solutions for those issues
  description: "# Common Issues\n\nThis page lists some common issues people run into with Vagrant and VirtualBox as well as solutions for those issues.\n\n## Hanging on Windows\n\nIf Vagrant commands are hanging on Windows because they're communicating to VirtualBox, this may be caused by a permissions issue with VirtualBox. This is easy to fix. Starting VirtualBox as a normal user or as an administrator will prevent you from using it in the opposite way. Please keep in mind that when Vagrant interacts with VirtualBox, it will interact with it with the same access level as the console running Vagrant.\n\nTo fix this issue, completely shut down all VirtualBox machines and GUIs. Wait a few seconds. Then, launch VirtualBox only with the access level you wish to use.\n\n## DNS Not Working\n\nIf DNS is not working within your VM, then you may need to enable a DNS proxy (built-in to VirtualBox). Please [see the StackOverflow answers here](https://serverfault.com/questions/453185/vagrant-virtualbox-dns-10-0-2-3-not-working) for a guide on how to do that.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/virtualbox/common-issues.html](https://www.vagrantup.com/docs/virtualbox/common-issues.html)"
- name: config.ssh.username
  id: vagrantfile/ssh_settings#config-ssh-username
  summary: The settings within config.ssh relate to configuring how Vagrant will access your machine over SSH
  belongs_to: SSH Settings
  description: "# SSH Settings\n\n**Config namespace: `config.ssh`**\n\nThe settings within `config.ssh` relate to configuring how Vagrant will access your machine over SSH. As with most Vagrant settings, the defaults are typically fine, but you can fine tune whatever you would like.\n\n## Available Settings\n\n- [`config.ssh.username`](#config-ssh-username) (string) - This sets the username that Vagrant will SSH as by default. Providers are free to override this if they detect a more appropriate user. By default this is \"vagrant\", since that is what most public boxes are made as.\n\n- [`config.ssh.password`](#config-ssh-password) (string) - This sets a password that Vagrant will use to authenticate the SSH user. Note that Vagrant recommends you use key-based authentication rather than a password (see `private_key_path`) below. If you use a password, Vagrant will automatically insert a keypair if `insert_key` is true.\n\n- [`config.ssh.host`](#config-ssh-host) (string) - The hostname or IP to SSH into. By default this is empty, because the provider usually figures this out for you.\n\n- [`config.ssh.port`](#config-ssh-port) (integer) - The port to SSH into. By default this is port 22.\n\n- [`config.ssh.guest_port`](#config-ssh-guest_port) (integer) - The port on the guest that SSH is running on. This is used by some providers to detect forwarded ports for SSH. For example, if this is set to 22 (the default), and Vagrant detects a forwarded port to port 22 on the guest from port 4567 on the host, Vagrant will attempt to use port 4567 to talk to the guest if there is no other option.\n\n- [`config.ssh.private_key_path`](#config-ssh-private_key_path) (string, array of strings) - The path to the private key to use to SSH into the guest machine. By default this is the insecure private key that ships with Vagrant, since that is what public boxes use. If you make your own custom box with a custom SSH key, this should point to that private key. You can also specify multiple private keys by setting this to be an array. This is useful, for example, if you use the default private key to bootstrap the machine, but replace it with perhaps a more secure key later.\n\n- [`config.ssh.keys_only`](#config-ssh-keys_only) (boolean) - Only use Vagrant-provided SSH private keys (do not use any keys stored in ssh-agent). The default value is `true`.\n\n- [`config.ssh.verify_host_key`](#config-ssh-verify_host_key) (string, symbol) - Perform strict host-key verification. The default value is `:never`.\n\n- [`config.ssh.paranoid`](#config-ssh-paranoid) (boolean) - Perform strict host-key verification. The default value is `false`.\n\n  **Deprecation:** The `config.ssh.paranoid` option is deprecated and will be removed in a future release. Please use the `config.ssh.verify_host_key` option instead.\n\n- [`config.ssh.forward_agent`](#config-ssh-forward_agent) (boolean) - If `true`, agent forwarding over SSH connections is enabled. Defaults to false.\n\n- [`config.ssh.forward_x11`](#config-ssh-forward_x11) (boolean) - If `true`, X11 forwarding over SSH connections is enabled. Defaults to false.\n\n- [`config.ssh.forward_env`](#config-ssh-forward_env) (array of strings) - An array of host environment variables to forward to the guest. If you are familiar with OpenSSH, this corresponds to the `SendEnv` parameter.\n\n  ``` ruby\n  config.ssh.forward_env = [\"CUSTOM_VAR\"]\n  ```\n\n- [`config.ssh.insert_key`](#config-ssh-insert_key) (boolean) - If `true`, Vagrant will automatically insert a keypair to use for SSH, replacing Vagrant's default insecure key inside the machine if detected. By default, this is true.\n\n  This only has an effect if you do not already use private keys for authentication or if you are relying on the default insecure key. If you do not have to care about security in your project and want to keep using the default insecure key, set this to `false`.\n\n- [`config.ssh.proxy_command`](#config-ssh-proxy_command) (string) - A command-line command to execute that receives the data to send to SSH on stdin. This can be used to proxy the SSH connection. `%h` in the command is replaced with the host and `%p` is replaced with the port.\n\n- [`config.ssh.pty`](#config-ssh-pty) (boolean) - If `true`, pty will be used for provisioning. Defaults to false.\n\n  This setting is an *advanced feature* that should not be enabled unless absolutely necessary. It breaks some other features of Vagrant, and is really only exposed for cases where it is absolutely necessary. If you can find a way to not use a pty, that is recommended instead.\n\n  When pty is enabled, it is important to note that command output will *not* be streamed to the UI. Instead, the output will be delivered in full to the UI once the command has completed.\n\n- [`config.ssh.keep_alive`](#config-ssh-keep_alive) (boolean) - If `true`, this setting SSH will send keep-alive packets every 5 seconds by default to keep connections alive.\n\n- [`config.ssh.shell`](#config-ssh-shell) (string) - The shell to use when executing SSH commands from Vagrant. By default this is `bash -l`. Note that this has no effect on the shell you get when you run `vagrant ssh`. This configuration option only affects the shell to use when executing commands internally in Vagrant.\n\n- [`config.ssh.export_command_template`](#config-ssh-export_command_template) (string) - The template used to generate exported environment variables in the active session. This can be useful when using a Bourne incompatible shell like C shell. The template supports two variables which are replaced with the desired environment variable key and environment variable value: `%ENV_KEY%` and `%ENV_VALUE%`. The default template is:\n\n  ``` ruby\n  config.ssh.export_command_template = 'export %ENV_KEY%=\"%ENV_VALUE%\"'\n  ```\n\n- [`config.ssh.sudo_command`](#config-ssh-sudo_command) (string) - The command to use when executing a command with `sudo`. This defaults to `sudo -E -H %c`. The `%c` will be replaced by the command that is being executed.\n\n- [`config.ssh.compression`](#config-ssh-compression) (boolean) - If `false`, this setting will not include the compression setting when ssh'ing into a machine. If this is not set, it will default to `true` and `Compression=yes` will be enabled with ssh.\n\n- [`config.ssh.dsa_authentication`](#config-ssh-dsa_authentication) (boolean) - If `false`, this setting will not include `DSAAuthentication` when ssh'ing into a machine. If this is not set, it will default to `true` and `DSAAuthentication=yes` will be used with ssh.\n\n- [`config.ssh.extra_args`](#config-ssh-extra_args) (array of strings) - This settings value is passed directly into the ssh executable. This allows you to pass any arbitrary commands to do things such as reverse tunneling down into the ssh program. These options can either be single flags set as strings such as `\"-6\"` for IPV6 or an array of arguments such as `[\"-L\", \"8008:localhost:80\"]` for enabling a tunnel from host port 8008 to port 80 on guest.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html](https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html)"
- name: config.vagrant.host
  id: vagrantfile/vagrant_settings#config-vagrant-host
  summary: The settings within config.vagrant modify the behavior of Vagrant itself
  belongs_to: Vagrant Settings
  description: "# Vagrant Settings\n\n**Config namespace: `config.vagrant`**\n\nThe settings within `config.vagrant` modify the behavior of Vagrant itself.\n\n## Available Settings\n\n- [`config.vagrant.host`](#config-vagrant-host) (string, symbol) - This sets the type of host machine that is running Vagrant. By default this is `:detect`, which causes Vagrant to auto-detect the host. Vagrant needs to know this information in order to perform some host-specific things, such as preparing NFS folders if they're enabled. You should only manually set this if auto-detection fails.\n\n- [`config.vagrant.plugins`](#config-vagrant-plugins) - (string, array, hash) - Define plugin, list of plugins, or definition of plugins to install for the local project. Vagrant will require these plugins be installed and available for the project. If the plugins are not available, it will attempt to automatically install them into the local project. When requiring a single plugin, a string can be provided:\n\n  ``` ruby\n  config.vagrant.plugins = \"vagrant-plugin\"\n  ```\n\n  If multiple plugins are required, they can be provided as an array:\n\n  ``` ruby\n  config.vagrant.plugins = [\"vagrant-plugin\", \"vagrant-other-plugin\"]\n  ```\n\n  Plugins can also be defined as a Hash, which supports setting extra options for the plugins. When a Hash is used, the key is the name of the plugin, and the value is a Hash of options for the plugin. For example, to set an explicit version of a plugin to install:\n\n  ``` ruby\n  config.vagrant.plugins = {\"vagrant-scp\" => {\"version\" => \"1.0.0\"}}\n  ```\n\n  Supported options are:\n\n  - [`entry_point`](#entry_point) - Path for Vagrant to load plugin\n  - [`sources`](#sources) - Custom sources for downloading plugin\n  - [`version`](#version) - Version constraint for plugin\n\n- [`config.vagrant.sensitive`](#config-vagrant-sensitive) - (string, array) - Value or list of values that should not be displayed in Vagrant's output. Value(s) will be removed from Vagrant's normal UI output as well as logger output.\n\n  ``` ruby\n  config.vagrant.sensitive = [\"MySecretPassword\", ENV[\"MY_TOKEN\"]]\n  ```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/vagrant_settings.html](https://www.vagrantup.com/docs/vagrantfile/vagrant_settings.html)"
- name: config.vm.base_mac
  id: vagrantfile/machine_settings#config-vm-base_mac
  summary: The settings within config.vm modify the configuration of the machine that Vagrant manages
  belongs_to: Machine Settings
  description: "# Machine Settings\n\n**Config namespace: `config.vm`**\n\nThe settings within `config.vm` modify the configuration of the machine that Vagrant manages.\n\n## Available Settings\n\n- [`config.vm.base_mac`](#config-vm-base_mac) (string) - The MAC address to be assigned to the default NAT interface on the guest. *Support for this option is provider dependent.*\n\n- [`config.vm.base_address`](#config-vm-base_address) (string) - The IP address to be assigned to the default NAT interface on the guest. *Support for this option is provider dependent.*\n\n- [`config.vm.boot_timeout`](#config-vm-boot_timeout) (integer) - The time in seconds that Vagrant will wait for the machine to boot and be accessible. By default this is 300 seconds.\n\n- [`config.vm.box`](#config-vm-box) (string) - This configures what [box](../boxes) the machine will be brought up against. The value here should be the name of an installed box or a shorthand name of a box in [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud).\n\n- [`config.vm.box_check_update`](#config-vm-box_check_update) (boolean) - If true, Vagrant will check for updates to the configured box on every `vagrant up`. If an update is found, Vagrant will tell the user. By default this is true. Updates will only be checked for boxes that properly support updates (boxes from [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud) or some other versioned box).\n\n- [`config.vm.box_download_checksum`](#config-vm-box_download_checksum) (string) - The checksum of the box specified by `config.vm.box_url`. If not specified, no checksum comparison will be done. If specified, Vagrant will compare the checksum of the downloaded box to this value and error if they do not match. Checksum checking is only done when Vagrant must download the box. If this is specified, then `config.vm.box_download_checksum_type` must also be specified.\n\n- [`config.vm.box_download_checksum_type`](#config-vm-box_download_checksum_type) (string) - The type of checksum specified by `config.vm.box_download_checksum` (if any). Supported values are currently \"md5\", \"sha1\", and \"sha256\".\n\n- [`config.vm.box_download_client_cert`](#config-vm-box_download_client_cert) (string) - Path to a client certificate to use when downloading the box, if it is necessary. By default, no client certificate is used to download the box.\n\n- [`config.vm.box_download_ca_cert`](#config-vm-box_download_ca_cert) (string) - Path to a CA cert bundle to use when downloading a box directly. By default, Vagrant will use the Mozilla CA cert bundle.\n\n- [`config.vm.box_download_ca_path`](#config-vm-box_download_ca_path) (string) - Path to a directory containing CA certificates for downloading a box directly. By default, Vagrant will use the Mozilla CA cert bundle.\n\n- [`config.vm.box_download_insecure`](#config-vm-box_download_insecure) (boolean) - If true, then SSL certificates from the server will not be verified. By default, if the URL is an HTTPS URL, then SSL certs will be verified.\n\n- [`config.vm.box_download_location_trusted`](#config-vm-box_download_location_trusted) (boolean) - If true, then all HTTP redirects will be treated as trusted. That means credentials used for initial URL will be used for all subsequent redirects. By default, redirect locations are untrusted so credentials (if specified) used only for initial HTTP request.\n\n- [`config.vm.box_url`](#config-vm-box_url) (string, array of strings) - The URL that the configured box can be found at. If `config.vm.box` is a shorthand to a box in [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud) then this value does not need to be specified. Otherwise, it should point to the proper place where the box can be found if it is not installed. This can also be an array of multiple URLs. The URLs will be tried in order.\n\n  Note that any client certificates, insecure download settings, and so on will apply to all URLs in this list. The URLs can also be local files by using the `file://` scheme. For example: \"file:///tmp/test.box\".\n\n- [`config.vm.box_version`](#config-vm-box_version) (string) - The version of the box to use. This defaults to \"\\>= 0\" (the latest version available). This can contain an arbitrary list of constraints, separated by commas, such as: `>= 1.0, < 1.5`. When constraints are given, Vagrant will use the latest available box satisfying these constraints.\n\n- [`config.vm.communicator`](#config-vm-communicator) (string) - The communicator type to use to connect to the guest box. By default this is `\"ssh\"`, but should be changed to `\"winrm\"` for Windows guests.\n\n- [`config.vm.graceful_halt_timeout`](#config-vm-graceful_halt_timeout) (integer) - The time in seconds that Vagrant will wait for the machine to gracefully halt when `vagrant halt` is called. Defaults to 60 seconds.\n\n- [`config.vm.guest`](#config-vm-guest) (string, symbol) - The guest OS that will be running within this machine. This defaults to `:linux`, and Vagrant will auto-detect the proper distro. However, this should be changed to `:windows` for Windows guests. Vagrant needs to know this information to perform some guest OS-specific things such as mounting folders and configuring networks.\n\n- [`config.vm.hostname`](#config-vm-hostname) (string) - The hostname the machine should have. Defaults to nil. If nil, Vagrant will not manage the hostname. If set to a string, the hostname will be set on boot. If set, Vagrant will update `/etc/hosts` on the guest with the configured hostname.\n\n- [`config.vm.ignore_box_vagrantfile`](#config-vm-ignore_box_vagrantfile) (boolean) - If true, Vagrant will not load the the settings found inside a boxes Vagrantfile, if present. Defaults to `false`.\n\n- [`config.vm.network`](#config-vm-network) - Configures [networks](../networking/index) on the machine. Please see the networking page for more information.\n\n- [`config.vm.post_up_message`](#config-vm-post_up_message) (string) - A message to show after `vagrant up`. This will be shown to the user and is useful for containing instructions such as how to access various components of the development environment.\n\n- [`config.vm.provider`](#config-vm-provider) - Configures [provider-specific configuration](../providers/configuration), which is used to modify settings which are specific to a certain [provider](../providers/index). If the provider you are configuring does not exist or is not setup on the system of the person who runs `vagrant up`, Vagrant will ignore this configuration block. This allows a Vagrantfile that is configured for many providers to be shared among a group of people who may not have all the same providers installed.\n\n- [`config.vm.provision`](#config-vm-provision) - Configures [provisioners](../provisioning/index) on the machine, so that software can be automatically installed and configured when the machine is created. Please see the page on provisioners for more information on how this setting works.\n\n- [`config.vm.synced_folder`](#config-vm-synced_folder) - Configures [synced folders](../synced-folders/index) on the machine, so that folders on your host machine can be synced to and from the guest machine. Please see the page on synced folders for more information on how this setting works.\n\n- [`config.vm.usable_port_range`](#config-vm-usable_port_range) (range) - A range of ports Vagrant can use for handling port collisions and such. Defaults to `2200..2250`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/machine_settings.html](https://www.vagrantup.com/docs/vagrantfile/machine_settings.html)"
- name: config.winrm.username
  id: vagrantfile/winrm_settings#config-winrm-username
  summary: The settings within config.winrm relate to configuring how Vagrant will access your Windows guest over WinRM
  belongs_to: WinRM Settings
  description: "# WinRM Settings\n\n**Config namespace: `config.winrm`**\n\nThe settings within `config.winrm` relate to configuring how Vagrant will access your Windows guest over WinRM. As with most Vagrant settings, the defaults are typically fine, but you can fine tune whatever you would like.\n\nThese settings are only used if you've set your communicator type to `:winrm`.\n\n## Available Settings\n\n- [`config.winrm.username`](#config-winrm-username) (string) - This sets the username that Vagrant will use to login to the WinRM web service by default. Providers are free to override this if they detect a more appropriate user. By default this is \"vagrant,\" since that is what most public boxes are made as.\n\n- [`config.winrm.password`](#config-winrm-password) (string) - This sets a password that Vagrant will use to authenticate the WinRM user. By default this is \"vagrant,\" since that is what most public boxes are made as.\n\n- [`config.winrm.host`](#config-winrm-host) (string) - The hostname or IP to connect to the WinRM service. By default this is empty, because the provider usually figures this out for you.\n\n- [`config.winrm.port`](#config-winrm-port) (integer) - The WinRM port to connect to, by default 5985.\n\n- [`config.winrm.guest_port`](#config-winrm-guest_port) (integer) - The port on the guest that WinRM is running on. This is used by some providers to detect forwarded ports for WinRM. For example, if this is set to 5985 (the default), and Vagrant detects a forwarded port to port 5985 on the guest from port 4567 on the host, Vagrant will attempt to use port 4567 to talk to the guest if there is no other option.\n\n- [`config.winrm.transport`](#config-winrm-transport) (symbol)- The transport used for WinRM communication. Valid settings include: `:negotiate`, `:ssl`, and `:plaintext`. The default is `:negotiate`.\n\n- [`config.winrm.basic_auth_only`](#config-winrm-basic_auth_only) (boolean) - Whether to use Basic Authentication. Defaults to `false`. If set to `true` you should also use the `:plaintext` transport setting and the Windows machine must be configured appropriately.\n\n  **Note:** It is strongly recommended that you only use basic authentication for debugging purposes. Credentials will be transferred in plain text.\n\n- [`config.winrm.ssl_peer_verification`](#config-winrm-ssl_peer_verification) (boolean) - When set to `false` ssl certificate validation is not performed.\n\n- [`config.winrm.timeout`](#config-winrm-timeout) (integer) - The maximum amount of time to wait for a response from the endpoint. This defaults to 60 seconds. Note that this will not \"timeout\" commands that exceed this amount of time to process, it just requires the endpoint to report the status of the command before the given amount of time passes.\n\n- [`config.winrm.retry_limit`](#config-winrm-retry_limit) (integer) - The maximum number of times to retry opening a shell after failure. This defaults to 3.\n\n- [`config.winrm.retry_delay`](#config-winrm-retry_delay) (integer) - The amount of time to wait between retries and defaults to 10 seconds.\n\n- [`config.winrm.codepage`](#config-winrm-codepage) (string) - The WINRS_CODEPAGE which is the client's console output code page. The default is 65001 (UTF-8).\n\n  **Note:** Versions of Windows older than Windows 7/Server 2008 R2 may exhibit undesirable behavior using the default UTF-8 codepage. When using these older versions of Windows, its best to use the native code page of the server's locale. For example, en-US servers will have a codepage of 437. The Windows `chcp` command can be used to determine the value of the native codepage.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/winrm_settings.html](https://www.vagrantup.com/docs/vagrantfile/winrm_settings.html)"
- name: Configuration
  id: vmware/configuration
  summary: While Vagrant VMware Desktop provider is a drop-in replacement for VirtualBox, there are some additional features that are exposed that allow you to more finely configure VMware-specific aspects of your machines
  description: "# Configuration\n\nWhile Vagrant VMware Desktop provider is a drop-in replacement for VirtualBox, there are some additional features that are exposed that allow you to more finely configure VMware-specific aspects of your machines.\n\nConfiguration settings for the provider are set in the Vagrantfile:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"my-box\"\n  config.vm.provider \"vmware_desktop\" do |v|\n    v.gui = true\n  end\nend\n```\n\n## Provider settings\n\n- [`clone_directory`](#clone_directory) (string) - Path for storing VMware clones. This value can also be set using the `VAGRANT_VMWARE_CLONE_DIRECTORY` environment variable. This defaults to `./.vagrant`\n- [`enable_vmrun_ip_lookup`](#enable_vmrun_ip_lookup) (bool) - Use vmrun to discover guest IP address. This defaults to `true`\n- [`functional_hgfs`](#functional_hgfs) (bool) - HGFS is functional within the guest. This defaults to detected capability of the guest\n- [`unmount_default_hgfs`](#unmount_default_hgfs) (bool) - Unmount the default HGFS mount point within the guest. This defaults to `false`\n- [`gui`](#gui) (bool) - Launch guest with a GUI. This defaults to `false`\n- [`ssh_info_public`](#ssh_info_public) (bool) - Use the public IP address for SSH connections to guest. This defaults to `false`\n- [`verify_vmnet`](#verify_vmnet) (bool) - Verify vmnet devices health before usage. This defaults to `true`\n- [`linked_clone`](#linked_clone) (bool) - Use linked clones instead of full copy clones. This defaults to `true`\n- [`vmx`](#vmx) (hash) - VMX key/value pairs to set or unset. If the value is `nil`, the key will be deleted.\n- [`whitelist_verified`](#whitelist_verified) (bool, symbol) - Flag that VMware box has been properly configured for whitelisted VMX settings. `true` if verified, `false` if unverified, `:disable_warning` to silence whitelist warnings.\n- [`port_forward_network_pause`](#port_forward_network_pause) - Number of seconds to pause after applying port forwarding configuration. This allows guest time to acquire DHCP address if previous address is dropped when VMware network services are restarted. This defaults to `0`\n- [`utility_port`](#utility_port) (integer) - Listen port of the Vagrant VMware Utility service. This defaults to `9922`\n- [`utility_certificate_path`](#utility_certificate_path) (string) - Path to the Vagrant VMware Utility service certificates directory. The default value is dependent on the host\n\n### VM Clone Directory\n\nBy default, the VMware provider will clone the VMware VM in the box to the \".vagrant\" folder relative to the folder where the Vagrantfile is. Usually, this is fine. For some people, for example those who use a differential backup software such as Time Machine, this is very annoying because you cannot regularly ignore giant virtual machines as part of backups.\n\nThe directory where the provider clones the virtual machine can be customized by setting the `VAGRANT_VMWARE_CLONE_DIRECTORY` environmental variable. This does not need to be unique per project. Each project will get a different sub-directory within this folder. Therefore, it is safe to set this systemwide.\n\n### Linked Clones\n\nBy default new machines are created using a linked clone to the base box. This reduces the time and required disk space incurred by directly importing the base box.\n\nLinked clones are based on a master VM, which is generated by importing the base box only once the first time it is required. For the linked clones only differencing disk images are created where the parent disk image belongs to the master VM. To disable linked clones:\n\n``` ruby\nconfig.vm.provider \"vmware_desktop\" do |v|\n  v.linked_clone = false\nend\n```\n\n### VMX Customization\n\nIf you want to add or remove specific keys from the VMX file, you can do that:\n\n``` ruby\nconfig.vm.provider \"vmware_desktop\" do |v|\n  v.vmx[\"custom-key\"]  = \"value\"\n  v.vmx[\"another-key\"] = nil\nend\n```\n\nIn the example above, the \"custom-key\" key will be set to \"value\" and the \"another-key\" key will be removed from the VMX file.\n\nVMX customization is done as the final step before the VMware machine is booted, so you have the ability to possibly undo or misconfigure things that Vagrant has set up itself.\n\nVMX is an undocumented format and there is no official reference for the available keys and values. This customization option is exposed for people who have knowledge of exactly what they want.\n\nThe most common keys people look for are setting memory and CPUs. The example below sets both:\n\n``` ruby\nconfig.vm.provider \"vmware_desktop\" do |v|\n  v.vmx[\"memsize\"] = \"1024\"\n  v.vmx[\"numvcpus\"] = \"2\"\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vmware/configuration.html](https://www.vagrantup.com/docs/vmware/configuration.html)"
- name: Configuration
  id: virtualbox/configuration
  summary: The VirtualBox provider exposes some additional configuration options that allow you to more finely control your VirtualBox-powered Vagrant environments
  description: "# Configuration\n\nThe VirtualBox provider exposes some additional configuration options that allow you to more finely control your VirtualBox-powered Vagrant environments.\n\n## GUI vs. Headless\n\nBy default, VirtualBox machines are started in headless mode, meaning there is no UI for the machines visible on the host machine. Sometimes, you want to have a UI. Common use cases include wanting to see a browser that may be running in the machine, or debugging a strange boot issue. You can easily tell the VirtualBox provider to boot with a GUI:\n\n``` ruby\nconfig.vm.provider \"virtualbox\" do |v|\n  v.gui = true\nend\n```\n\n## Virtual Machine Name\n\nYou can customize the name that appears in the VirtualBox GUI by setting the `name` property. By default, Vagrant sets it to the containing folder of the Vagrantfile plus a timestamp of when the machine was created. By setting another name, your VM can be more easily identified.\n\n``` ruby\nconfig.vm.provider \"virtualbox\" do |v|\n  v.name = \"my_vm\"\nend\n```\n\n## Linked Clones\n\nBy default new machines are created by importing the base box. For large boxes this produces a large overhead in terms of time (the import operation) and space (the new machine contains a copy of the base box's image). Using linked clones can drastically reduce this overhead.\n\nLinked clones are based on a master VM, which is generated by importing the base box only once the first time it is required. For the linked clones only differencing disk images are created where the parent disk image belongs to the master VM.\n\n``` ruby\nconfig.vm.provider \"virtualbox\" do |v|\n  v.linked_clone = true\nend\n```\n\nTo have backward compatibility:\n\n``` ruby\nconfig.vm.provider 'virtualbox' do |v|\n  v.linked_clone = true if Gem::Version.new(Vagrant::VERSION) >= Gem::Version.new('1.8.0')\nend\n```\n\nIf you do not want backward compatibility and want to force users to support linked cloning, you can use `Vagrant.require_version` with 1.8.\n\n> **Note:** the generated master VMs are currently not removed automatically by Vagrant. This has to be done manually. However, a master VM can only be removed when there are no linked clones connected to it.\n\n## VBoxManage Customizations\n\n[VBoxManage](https://www.virtualbox.org/manual/ch08.html) is a utility that can be used to make modifications to VirtualBox virtual machines from the command line.\n\nVagrant exposes a way to call any command against VBoxManage just prior to booting the machine:\n\n``` ruby\nconfig.vm.provider \"virtualbox\" do |v|\n  v.customize [\"modifyvm\", :id, \"--cpuexecutioncap\", \"50\"]\nend\n```\n\nIn the example above, the VM is modified to have a host CPU execution cap of 50%, meaning that no matter how much CPU is used in the VM, no more than 50% would be used on your own host machine. Some details:\n\n- The `:id` special parameter is replaced with the ID of the virtual machine being created, so when a VBoxManage command requires an ID, you can pass this special parameter.\n\n- Multiple `customize` directives can be used. They will be executed in the order given.\n\nThere are some convenience shortcuts for memory and CPU settings:\n\n``` ruby\nconfig.vm.provider \"virtualbox\" do |v|\n  v.memory = 1024\n  v.cpus = 2\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/virtualbox/configuration.html](https://www.vagrantup.com/docs/virtualbox/configuration.html)"
- name: Configuration
  id: providers/configuration
  summary: While well-behaved Vagrant providers should work with any Vagrantfile with sane defaults, providers generally expose unique configuration options so that you can get the most out of each provider
  description: "# Configuration\n\nWhile well-behaved Vagrant providers should work with any Vagrantfile with sane defaults, providers generally expose unique configuration options so that you can get the most out of each provider.\n\nThis provider-specific configuration is done within the Vagrantfile in a way that is portable, easy to use, and easy to understand.\n\n## Portability\n\nAn important fact is that even if you configure other providers within a Vagrantfile, the Vagrantfile remains portable even to individuals who do not necessarily have that provider installed.\n\nFor example, if you configure VMware Fusion and send it to an individual who does not have the VMware Fusion provider, Vagrant will silently ignore that part of the configuration.\n\n## Provider Configuration\n\nConfiguring a specific provider looks like this:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ...\n\n  config.vm.provider \"virtualbox\" do |vb|\n    vb.customize [\"modifyvm\", :id, \"--cpuexecutioncap\", \"50\"]\n  end\nend\n```\n\nMultiple `config.vm.provider` blocks can exist to configure multiple providers.\n\nThe configuration format should look very similar to how provisioners are configured. The `config.vm.provider` takes a single parameter: the name of the provider being configured. Then, an inner block with custom configuration options is exposed that can be used to configure that provider.\n\nThis inner configuration differs among providers, so please read the documentation for your provider of choice to see available configuration options.\n\nRemember, some providers do not require any provider-specific configuration and work directly out of the box. Provider-specific configuration is meant as a way to expose more options to get the most of the provider of your choice. It is not meant as a roadblock to running against a specific provider.\n\n## Overriding Configuration\n\nProviders can also override non-provider specific configuration, such as `config.vm.box` and any other Vagrant configuration. This is done by specifying a second argument to `config.vm.provider`. This argument is just like the normal `config`, so set any settings you want, and they will be overridden only for that provider.\n\nExample:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"precise64\"\n\n  config.vm.provider \"vmware_fusion\" do |v, override|\n    override.vm.box = \"precise64_fusion\"\n  end\nend\n```\n\nIn the above case, Vagrant will use the \"precise64\" box by default, but will use \"precise64_fusion\" if the VMware Fusion provider is used.\n\n> **The Vagrant Way:** The proper \"Vagrant way\" is to avoid any provider-specific overrides if possible by making boxes for multiple providers that are as identical as possible, since box names can map to multiple providers. However, this is not always possible, and in those cases, overrides are available.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/providers/configuration.html](https://www.vagrantup.com/docs/providers/configuration.html)"
- name: Configuration
  id: hyperv/configuration
  summary: The Vagrant Hyper-V provider has some provider-specific configuration options you may set
  description: "# Configuration\n\nThe Vagrant Hyper-V provider has some provider-specific configuration options you may set. A complete reference is shown below:\n\n- [`auto_start_action`](#auto_start_action) (Nothing, StartIfRunning, Start) - Automatic start action for VM on host startup. Default: Nothing.\n- [`auto_stop_action`](#auto_stop_action) (ShutDown, TurnOff, Save) - Automatic stop action for VM on host shutdown. Default: ShutDown.\n- [`cpus`](#cpus) (integer) - Number of virtual CPUs allocated to VM at startup.\n- [`differencing_disk`](#differencing_disk) (boolean) - **Deprecated** Use differencing disk instead of cloning entire VHD (use `linked_clone` instead) Default: false.\n- [`enable_virtualization_extensions`](#enable_virtualization_extensions) (boolean) - Enable virtualization extensions for the virtual CPUs. Default: false\n- [`enable_checkpoints`](#enable_checkpoints) (boolean) Enable checkpoints of the VM. Default: false\n- [`enable_automatic_checkpoints`](#enable_automatic_checkpoints) (boolean) Enable automatic checkpoints of the VM. Default: false\n- [`ip_address_timeout`](#ip_address_timeout) (integer) - Number of seconds to wait for the VM to report an IP address. Default: 120.\n- [`linked_clone`](#linked_clone) (boolean) - Use differencing disk instead of cloning entire VHD. Default: false\n- [`mac`](#mac) (string) - MAC address for the guest network interface\n- [`maxmemory`](#maxmemory) (integer) - Maximum number of megabytes allowed to be allocated for the VM. When set Dynamic Memory Allocation will be enabled.\n- [`memory`](#memory) (integer) - Number of megabytes allocated to VM at startup. If `maxmemory` is set, this will be amount of memory allocated at startup.\n- [`vlan_id`](#vlan_id) (integer) - VLAN ID for the guest network interface.\n- [`vmname`](#vmname) (string) - Name of virtual machine as shown in Hyper-V manager. Default: Generated name.\n- [`vm_integration_services`](#vm_integration_services) (Hash) - Hash to set the state of integration services. (Note: Unknown key values will be passed directly.)\n  - [`guest_service_interface`](#guest_service_interface) (boolean)\n  - [`heartbeat`](#heartbeat) (boolean)\n  - [`key_value_pair_exchange`](#key_value_pair_exchange) (boolean)\n  - [`shutdown`](#shutdown) (boolean)\n  - [`time_synchronization`](#time_synchronization) (boolean)\n  - [`vss`](#vss) (boolean)\n\n## VM Integration Services\n\nThe `vm_integration_services` configuration option consists of a simple Hash. The key values are the names of VM integration services to enable or disable for the VM. Vagrant includes an internal mapping of known services which allows them to be provided in a \"snake case\" format. When a provided key is unknown, the key value is used \"as-is\" without any modifications.\n\nFor example, if a new `CustomVMSRV` VM integration service was added and Vagrant is not aware of this new service name, it can be provided as the key value explicitly:\n\n``` ruby\nconfig.vm.provider \"hyperv\" do |h|\n  h.vm_integration_services = {\n    guest_service_interface: true,\n    CustomVMSRV: true\n  }\nend\n```\n\nThis example would enable the `GuestServiceInterface` (which Vagrant is aware) and `CustomVMSRV` (which Vagrant is *not* aware) VM integration services.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/hyperv/configuration.html](https://www.vagrantup.com/docs/hyperv/configuration.html)"
- name: Configuration
  id: triggers/configuration
  summary: Vagrant Triggers has a few options to define trigger behavior
  description: "# Configuration\n\nVagrant Triggers has a few options to define trigger behavior.\n\n## Options\n\nThe trigger class takes various options.\n\n- [`action`](#action) (symbol, array) - Expected to be a single symbol value, an array of symbols, or a *splat* of symbols. The first argument that comes after either **before** or **after** when defining a new trigger. Can be any valid Vagrant command. It also accepts a special value `:all` which will make the trigger fire for every action. An action can be ignored with the `ignore` setting if desired. These are the valid action commands for triggers:\n\n  - [`destroy`](#destroy)\n  - [`halt`](#halt)\n  - [`provision`](#provision)\n  - [`reload`](#reload)\n  - [`resume`](#resume)\n  - [`suspend`](#suspend)\n  - [`up`](#up)\n\n- [`ignore`](#ignore) (symbol, array) - Symbol or array of symbols corresponding to the action that a trigger should not fire on.\n\n- [`info`](#info) (string) - A message that will be printed at the beginning of a trigger.\n\n- [`name`](#name) (string) - The name of the trigger. If set, the name will be displayed when firing the trigger.\n\n- [`on_error`](#on_error) (symbol) - Defines how the trigger should behave if it encounters an error. By default this will be `:halt`, but can be configured to ignore failures and continue on with `:continue`.\n\n- [`only_on`](#only_on) (string, regex, array) - Limit the trigger to these guests. Values can be a string or regex that matches a guest name.\n\n- [`ruby`](#ruby) (block) - A block of Ruby code to be executed on the host. The block accepts two arguments that can be used with your Ruby code: `env` and `machine`. These options correspond to the Vagrant environment used (note: these are not your shell's environment variables), and the Vagrant guest machine that the trigger is firing on. This option can only be a `Proc` type, which must be explicitly called out when using the hash syntax for a trigger.\n\n  ``` ruby\n  ubuntu.trigger.after :up do |trigger|\n    trigger.info = \"More information\"\n    trigger.ruby do |env,machine|\n      greetings = \"hello there #{machine.id}!\"\n      puts greetings\n    end\n  end\n  ```\n\n- [`run_remote`](#run_remote) (hash) - A collection of settings to run a inline or remote script with on the guest. These settings correspond to the [shell provisioner](../provisioning/shell).\n\n- [`run`](#run) (hash) - A collection of settings to run a inline or remote script on the host. These settings correspond to the [shell provisioner](../provisioning/shell). However, at the moment the only settings `run` takes advantage of are:\n\n  - [`args`](#args)\n  - [`inline`](#inline)\n  - [`path`](#path)\n\n- [`warn`](#warn) (string) - A warning message that will be printed at the beginning of a trigger.\n\n- [`exit_codes`](#exit_codes) (integer, array) - A set of acceptable exit codes to continue on. Defaults to `0` if option is absent. For now only valid with the `run` option.\n\n- [`abort`](#abort) (integer,boolean) - An option that will exit the running Vagrant process once the trigger fires. If set to `true`, Vagrant will use exit code 1. Otherwise, an integer can be provided and Vagrant will it as its exit code when aborting.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/triggers/configuration.html](https://www.vagrantup.com/docs/triggers/configuration.html)"
- name: Configuration Version
  id: vagrantfile/version
  summary: Configuration versions are the mechanism by which Vagrant 1.1+ is able to remain backwards compatible with Vagrant 1.0.x Vagrantfiles, while introducing dramatically new features and configuration options
  description: "# Configuration Version\n\nConfiguration versions are the mechanism by which Vagrant 1.1+ is able to remain [backwards compatible](../installation/backwards-compatibility) with Vagrant 1.0.x Vagrantfiles, while introducing dramatically new features and configuration options.\n\nIf you run `vagrant init` today, the Vagrantfile will be in roughly the following format:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ...\nend\n```\n\nThe `\"2\"` in the first line above represents the version of the configuration object `config` that will be used for configuration for that block (the section between the `do` and the `end`). This object can be very different from version to version.\n\nCurrently, there are only two supported versions: \"1\" and \"2\". Version 1 represents the configuration from Vagrant 1.0.x. \"2\" represents the configuration for 1.1+ leading up to 2.0.x.\n\nWhen loading Vagrantfiles, Vagrant uses the proper configuration object for each version, and properly merges them, just like any other configuration.\n\nThe important thing to understand as a general user of Vagrant is that *within a single configuration section*, only a single version can be used. You cannot use the new `config.vm.provider` configurations in a version 1 configuration section. Likewise, `config.vm.forward_port` will not work in a version 2 configuration section (it was renamed).\n\nIf you want, you can mix and match multiple configuration versions in the same Vagrantfile. This is useful if you found some useful configuration snippet or something that you want to use. Example:\n\n``` ruby\nVagrant.configure(\"1\") do |config|\n  # v1 configs...\nend\n\nVagrant.configure(\"2\") do |config|\n  # v2 configs...\nend\n```\n\n> **What is `Vagrant::Config.run`?** You may see this in Vagrantfiles. This was actually how Vagrant 1.0.x did configuration. In Vagrant 1.1+, this is synonymous with `Vagrant.configure(\"1\")`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/version.html](https://www.vagrantup.com/docs/vagrantfile/version.html)"
- name: Creating a Base Box
  id: boxes/base
  summary: There are a special category of boxes known as "base boxes." These boxes contain the bare minimum required for Vagrant to function, are generally not made by repackaging an existing Vagrant environment (hence the "base" in the "base box")
  description: "# Creating a Base Box\n\nThere are a special category of boxes known as \"base boxes.\" These boxes contain the bare minimum required for Vagrant to function, are generally not made by repackaging an existing Vagrant environment (hence the \"base\" in the \"base box\").\n\nFor example, the Ubuntu boxes provided by the Vagrant project (such as \"precise64\") are base boxes. They were created from a minimal Ubuntu install from an ISO, rather than repackaging an existing environment.\n\nBase boxes are extremely useful for having a clean slate starting point from which to build future development environments. The Vagrant project hopes in the future to be able to provide base boxes for many more operating systems. Until then, this page documents how you can create your own base box.\n\n> **Advanced topic!** Creating a base box can be a time consuming and tedious process, and is not recommended for new Vagrant users. If you are just getting started with Vagrant, we recommend trying to find existing base boxes to use first.\n\n## What's in a Base Box?\n\nA base box typically consists of only a bare minimum set of software for Vagrant to function. As an example, a Linux box may contain only the following:\n\n- Package manager\n- SSH\n- SSH user so Vagrant can connect\n- Perhaps Chef, Puppet, etc. but not strictly required.\n\nIn addition to this, each [provider](../providers/index) may require additional software. For example, if you are making a base box for VirtualBox, you will want to include the VirtualBox guest additions so that shared folders work properly. But if you are making an AWS base box, this is not required.\n\n## Creating a Base Box\n\nCreating a base box is actually provider-specific. This means that depending on if you are using VirtualBox, VMware, AWS, etc. the process for creating a base box is different. Because of this, this one document cannot be a full guide to creating a base box.\n\nThis page will document some general guidelines for creating base boxes, however, and will link to provider-specific guides for creating base boxes.\n\nProvider-specific guides for creating base boxes are linked below:\n\n- [Docker Base Boxes](../docker/boxes)\n- [Hyper-V Base Boxes](../hyperv/boxes)\n- [VMware Base Boxes](../vmware/boxes)\n- [VirtualBox Base Boxes](../virtualbox/boxes)\n\n### Packer and Vagrant Cloud\n\nWe strongly recommend using [Packer](https://www.packer.io) to create reproducible builds for your base boxes, as well as automating the builds. Read more about [automating Vagrant box creation with Packer](https://www.packer.io/guides/packer-on-cicd/build-image-in-cicd.html) in the Packer documentation.\n\n### Disk Space\n\nWhen creating a base box, make sure the user will have enough disk space to do interesting things, without being annoying. For example, in VirtualBox, you should create a dynamically resizing drive with a large maximum size. This causes the actual footprint of the drive to be small initially, but to dynamically grow towards the max size as disk space is needed, providing the most flexibility for the end user.\n\nIf you are creating an AWS base box, do not force the AMI to allocate terabytes of EBS storage, for example, since the user can do that on their own. But you should default to mounting ephemeral drives, because they're free and provide a lot of disk space.\n\n### Memory\n\nLike disk space, finding the right balance of the default amount of memory is important. For most providers, the user can modify the memory with the Vagrantfile, so do not use too much by default. It would be a poor user experience (and mildly shocking) if a `vagrant up` from a base box instantly required many gigabytes of RAM. Instead, choose a value such as 512MB, which is usually enough to play around and do interesting things with a Vagrant machine, but can easily be increased when needed.\n\n### Peripherals (Audio, USB, etc.)\n\nDisable any non-necessary hardware in a base box such as audio and USB controllers. These are generally unnecessary for Vagrant usage and, again, can be easily added via the Vagrantfile in most cases.\n\n## Default User Settings\n\nJust about every aspect of Vagrant can be modified. However, Vagrant does expect some defaults which will cause your base box to \"just work\" out of the box. You should create these as defaults if you intend to publicly distribute your box.\n\nIf you are creating a base box for private use, you should try *not* to follow these, as they open up your base box to security risks (known users, passwords, private keys, etc.).\n\n### \"vagrant\" User\n\nBy default, Vagrant expects a \"vagrant\" user to SSH into the machine as. This user should be setup with the [insecure keypair](https://github.com/hashicorp/vagrant/tree/master/keys) that Vagrant uses as a default to attempt to SSH. Also, even though Vagrant uses key-based authentication by default, it is a general convention to set the password for the \"vagrant\" user to \"vagrant\". This lets people login as that user manually if they need to.\n\nTo configure SSH access with the insecure keypair, place the public key into the `~/.ssh/authorized_keys` file for the \"vagrant\" user. Note that OpenSSH is very picky about file permissions. Therefore, make sure that `~/.ssh` has `0700` permissions and the authorized keys file has `0600` permissions.\n\nWhen Vagrant boots a box and detects the insecure keypair, it will automatically replace it with a randomly generated keypair for additional security while the box is running.\n\n### Root Password: \"vagrant\"\n\nVagrant does not actually use or expect any root password. However, having a generally well known root password makes it easier for the general public to modify the machine if needed.\n\nPublicly available base boxes usually use a root password of \"vagrant\" to keep things easy.\n\n### Password-less Sudo\n\nThis is **important!**. Many aspects of Vagrant expect the default SSH user to have passwordless sudo configured. This lets Vagrant configure networks, mount synced folders, install software, and more.\n\nTo begin, some minimal installations of operating systems do not even include `sudo` by default. Verify that you install `sudo` in some way.\n\nAfter installing sudo, configure it (usually using `visudo`) to allow passwordless sudo for the \"vagrant\" user. This can be done with the following line at the end of the configuration file:\n\n``` highlight\nvagrant ALL=(ALL) NOPASSWD: ALL\n```\n\nAdditionally, Vagrant does not use a pty or tty by default when connected via SSH. You will need to make sure there is no line that has `requiretty` in it. Remove that if it exists. This allows sudo to work properly without a tty. Note that you *can* configure Vagrant to request a pty, which lets you keep this configuration. But Vagrant by default does not do this.\n\n### SSH Tweaks\n\nIn order to keep SSH speedy even when your machine or the Vagrant machine is not connected to the internet, set the `UseDNS` configuration to `no` in the SSH server configuration.\n\nThis avoids a reverse DNS lookup on the connecting SSH client which can take many seconds.\n\n## Windows Boxes\n\nSupported Windows guest operating systems: - Windows 7 - Windows 8 - Windows Server 2008 - Windows Server 2008 R2 - Windows Server 2012 - Windows Server 2012 R2\n\nWindows Server 2003 and Windows XP are *not* supported, but if you are a die hard XP fan [this](https://stackoverflow.com/a/18593425/18475) may help you.\n\n### Base Windows Configuration\n\n- Turn off UAC\n- Disable complex passwords\n- Disable \"Shutdown Tracker\"\n- Disable \"Server Manager\" starting at login (for non-Core)\n\nIn addition to disabling UAC in the control panel, you also must disable UAC in the registry. This may vary from Windows version to Windows version, but Windows 8/8.1 use the command below. This will allow some things like automated Puppet installs to work within Vagrant Windows base boxes.\n\n``` highlight\nreg add HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v EnableLUA /d 0 /t REG_DWORD /f /reg:64\n```\n\n### Base WinRM Configuration\n\nTo enable and configure WinRM you will need to set the WinRM service to auto-start and allow unencrypted basic auth (obviously this is not secure). Run the following commands from a regular Windows command prompt:\n\n``` highlight\nwinrm quickconfig -q\nwinrm set winrm/config/winrs @{MaxMemoryPerShellMB=\"512\"}\nwinrm set winrm/config @{MaxTimeoutms=\"1800000\"}\nwinrm set winrm/config/service @{AllowUnencrypted=\"true\"}\nwinrm set winrm/config/service/auth @{Basic=\"true\"}\nsc config WinRM start= auto\n```\n\n### Additional WinRM 1.1 Configuration\n\nThese additional configuration steps are specific to Windows Server 2008 (WinRM 1.1). For Windows Server 2008 R2, Windows 7 and later versions of Windows you can ignore this section.\n\n1.  Ensure the Windows PowerShell feature is installed\n2.  Change the WinRM port to 5985 or upgrade to WinRM 2.0\n\nThe following commands will change the WinRM 1.1 port to what's expected by Vagrant:\n\n``` highlight\nnetsh firewall add portopening TCP 5985 \"Port 5985\"\nwinrm set winrm/config/listener?Address=*+Transport=HTTP @{Port=\"5985\"}\n```\n\n## Other Software\n\nAt this point, you have all the common software you absolutely *need* for your base box to work with Vagrant. However, there is some additional software you can install if you wish.\n\nWhile we plan on it in the future, Vagrant still does not install Chef or Puppet automatically when using those provisioners. Users can use a shell provisioner to do this, but if you want Chef/Puppet to just work out of the box, you will have to install them in the base box.\n\nInstalling this is outside the scope of this page, but should be fairly straightforward.\n\nIn addition to this, feel free to install and configure any other software you want available by default for this base box.\n\n## Packaging the Box\n\nPackaging the box into a `box` file is provider-specific. Please refer to the provider-specific documentation for creating a base box. Some provider-specific guides are linked to towards the top of this page.\n\n## Distributing the Box\n\nYou can distribute the box file however you would like. However, if you want to support versioning, putting multiple providers at a single URL, pushing updates, analytics, and more, we recommend you add the box to [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud).\n\nYou can upload both public and private boxes to this service.\n\n## Testing the Box\n\nTo test the box, pretend you are a new user of Vagrant and give it a shot:\n\n``` highlight\n$ vagrant box add --name my-box /path/to/the/new.box\n...\n$ vagrant init my-box\n...\n$ vagrant up\n...\n```\n\nIf you made a box for some other provider, be sure to specify the `--provider` option to `vagrant up`. If the up succeeded, then your box worked!\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/boxes/base.html](https://www.vagrantup.com/docs/boxes/base.html)"
- name: Creating a Base Box
  id: hyperv/boxes
  summary: As with every Vagrant provider, the Vagrant Hyper-V provider has a custom box format that affects how base boxes are made
  description: "# Creating a Base Box\n\nAs with [every Vagrant provider](../providers/basic_usage), the Vagrant Hyper-V provider has a custom box format that affects how base boxes are made.\n\nPrior to reading this, you should read the [general guide to creating base boxes](../boxes/base). Actually, it would probably be most useful to keep this open in a separate tab as you may be referencing it frequently while creating a base box. That page contains important information about common software to install on the box.\n\nAdditionally, it is helpful to understand the [basics of the box file format](../boxes/format).\n\n> **Advanced topic!** This is a reasonably advanced topic that a beginning user of Vagrant does not need to understand. If you are just getting started with Vagrant, skip this and use an available box. If you are an experienced user of Vagrant and want to create your own custom boxes, this is for you.\n\n## Additional Software\n\nIn addition to the software that should be installed based on the [general guide to creating base boxes](../boxes/base), Hyper-V base boxes require some additional software.\n\n### Hyper-V Kernel Modules\n\nYou will need to install Hyper-V kernel modules. While this improves performance, it also enables necessary features such as reporting its IP address so that Vagrant can access it.\n\nYou can verify Hyper-V kernel modules are properly installed by running `lsmod` on Linux machines and looking for modules prefixed with `hv_`. Additionally, you will need to verify that the \"Network\" tab for your virtual machine in the Hyper-V manager is reporting an IP address. If it is not reporting an IP address, Vagrant will not be able to access it.\n\nFor most newer Linux distributions, the Hyper-V modules will be available out of the box.\n\nUbuntu 12.04 requires some special steps to make networking work. These are reproduced here in case similar steps are needed with other distributions. Without these commands, Ubuntu 12.04 will not report an IP address to Hyper-V:\n\n``` highlight\n$ sudo apt-get install linux-tools-3.11.0-15-generic\n$ sudo apt-get install hv-kvp-daemon-init\n$ sudo cp /usr/lib/linux-tools/3.11.0-15/hv_* /usr/sbin/\n```\n\n## Packaging the Box\n\nTo package a Hyper-V box, export the virtual machine from the Hyper-V Manager using the \"Export\" feature. This will create a directory with a structure similar to the following:\n\n``` highlight\n.\n|-- Snapshots\n|-- Virtual Hard drives\n|-- Virtual Machines\n```\n\nDelete the \"Snapshots\" folder. It is of no use to the Vagrant Hyper-V provider and can only add to the size of the box if there are snapshots in that folder.\n\nThen, create the \"metadata.json\" file necessary for the box, as documented in [basics of the box file format](../boxes/format). The proper provider value to use for the metadata is \"hyperv\".\n\nFinally, create an archive of those contents (but *not* the parent folder) using a tool such as `tar`:\n\n``` highlight\n$ tar cvzf ~/custom.box ./*\n```\n\nA common mistake is to also package the parent folder by accident. Vagrant will not work in this case. To verify you've packaged it properly, add the box to Vagrant and try to bring up the machine.\n\n## Additional Help\n\nThere is also some less structured help available from the experience of other users. These are not official documentation but if you are running into trouble they may help you:\n\n- [Ubuntu 14.04.2 without secure boot](https://github.com/hashicorp/vagrant/issues/5419#issuecomment-86235427)\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/hyperv/boxes.html](https://www.vagrantup.com/docs/hyperv/boxes.html)"
- name: Creating a Base Box
  id: virtualbox/boxes
  summary: As with every Vagrant provider, the Vagrant VirtualBox provider has a custom box format that affects how base boxes are made
  description: "# Creating a Base Box\n\nAs with [every Vagrant provider](../providers/basic_usage), the Vagrant VirtualBox provider has a custom box format that affects how base boxes are made.\n\nPrior to reading this, you should read the [general guide to creating base boxes](../boxes/base). Actually, it would probably be most useful to keep this open in a separate tab as you may be referencing it frequently while creating a base box. That page contains important information about common software to install on the box.\n\nAdditionally, it is helpful to understand the [basics of the box file format](../boxes/format).\n\n> **Advanced topic!** This is a reasonably advanced topic that a beginning user of Vagrant does not need to understand. If you are just getting started with Vagrant, skip this and use an available box. If you are an experienced user of Vagrant and want to create your own custom boxes, this is for you.\n\n## Virtual Machine\n\nThe virtual machine created in VirtualBox can use any configuration you would like, but Vagrant has some hard requirements:\n\n- The first network interface (adapter 1) *must* be a NAT adapter. Vagrant uses this to connect the first time.\n\n- The MAC address of the first network interface (the NAT adapter) should be noted, since you will need to put it in a Vagrantfile later as the value for `config.vm.base_mac`. To get this value, use the VirtualBox GUI.\n\nOther than the above, you are free to customize the base virtual machine as you see fit.\n\n## Additional Software\n\nIn addition to the software that should be installed based on the [general guide to creating base boxes](../boxes/base), VirtualBox base boxes require some additional software.\n\n### VirtualBox Guest Additions\n\n[VirtualBox Guest Additions](https://www.virtualbox.org/manual/ch04.html) must be installed so that things such as shared folders can function. Installing guest additions also usually improves performance since the guest OS can make some optimizations by knowing it is running within VirtualBox.\n\nBefore installing the guest additions, you will need the linux kernel headers and the basic developer tools. On Ubuntu, you can easily install these like so:\n\n``` highlight\n$ sudo apt-get install linux-headers-$(uname -r) build-essential dkms\n```\n\n#### To install via the GUI:\n\nNext, make sure that the guest additions image is available by using the GUI and clicking on \"Devices\" followed by \"Install Guest Additions\". Then mount the CD-ROM to some location. On Ubuntu, this usually looks like this:\n\n``` highlight\n$ sudo mount /dev/cdrom /media/cdrom\n```\n\nFinally, run the shell script that matches your system to install the guest additions. For example, for Linux on x86, it is the following:\n\n``` highlight\n$ sudo sh /media/cdrom/VBoxLinuxAdditions.run\n```\n\nIf the command succeeds, then the guest additions are now installed!\n\n#### To install via the command line:\n\nYou can find the appropriate guest additions version to match your VirtualBox version by selecting the appropriate version [here](http://download.virtualbox.org/virtualbox/). The examples below use 4.3.8, which was the latest VirtualBox version at the time of writing.\n\n``` highlight\nwget http://download.virtualbox.org/virtualbox/4.3.8/VBoxGuestAdditions_4.3.8.iso\nsudo mkdir /media/VBoxGuestAdditions\nsudo mount -o loop,ro VBoxGuestAdditions_4.3.8.iso /media/VBoxGuestAdditions\nsudo sh /media/VBoxGuestAdditions/VBoxLinuxAdditions.run\nrm VBoxGuestAdditions_4.3.8.iso\nsudo umount /media/VBoxGuestAdditions\nsudo rmdir /media/VBoxGuestAdditions\n```\n\nIf you did not install a Desktop environment when you installed the operating system, as recommended to reduce size, the install of the VirtualBox additions should warn you about the lack of OpenGL or Window System Drivers, but you can safely ignore this.\n\nIf the commands succeed, then the guest additions are now installed!\n\n## Packaging the Box\n\nVagrant includes a simple way to package VirtualBox base boxes. Once you've installed all the software you want to install, you can run this command:\n\n``` highlight\n$ vagrant package --base my-virtual-machine\n```\n\nWhere \"my-virtual-machine\" is replaced by the name of the virtual machine in VirtualBox to package as a base box.\n\nIt will take a few minutes, but after it is complete, a file \"package.box\" should be in your working directory which is the new base box. At this point, you've successfully created a base box!\n\n## Raw Contents\n\nThis section documents the actual raw contents of the box file. This is not as useful when creating a base box but can be useful in debugging issues if necessary.\n\nA VirtualBox base box is an archive of the resulting files of [exporting](https://www.virtualbox.org/manual/ch08.html#vboxmanage-export) a VirtualBox virtual machine. Here is an example of what is contained in such a box:\n\n``` highlight\n$ tree\n.\n|-- Vagrantfile\n|-- box-disk1.vmdk\n|-- box.ovf\n|-- metadata.json\n\n0 directories, 4 files\n```\n\nIn addition to the files from exporting a VirtualBox VM, there is the \"metadata.json\" file used by Vagrant itself.\n\nAlso, there is a \"Vagrantfile.\" This contains some configuration to properly set the MAC address of the NAT network device, since VirtualBox requires this to be correct in order to function properly. If you are not using `vagrant package --base` above, you will have to set the `config.vm.base_mac` setting in this Vagrantfile to the MAC address of the NAT device without colons.\n\nWhen bringing up a VirtualBox backed machine, Vagrant [imports](https://www.virtualbox.org/manual/ch08.html#vboxmanage-import) the \"box.ovf\" file found in the box contents.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/virtualbox/boxes.html](https://www.vagrantup.com/docs/virtualbox/boxes.html)"
- name: Custom Provider
  id: share/provider
  summary: 'Warning: Advanced Topic! This topic is related to developing Vagrant plugins'
  description: "# Custom Provider\n\n> **Warning: Advanced Topic!** This topic is related to developing Vagrant plugins. If you are not interested in this or you are just starting with Vagrant, it is safe to skip this page.\n\nIf you are developing a [custom Vagrant provider](../plugins/providers), you will need to do a tiny bit more work in order for it to work well with Vagrant Share.\n\nFor now, this is only one step:\n\n- [`public_address`](#public_address) provider capability - You must implement this capability to return a string that is an address that can be used to access the guest from Vagrant. This does not need to be a globally routable address, it only needs to be accessible from the machine running Vagrant. If you cannot detect an address, return `nil`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/share/provider.html](https://www.vagrantup.com/docs/share/provider.html)"
- name: Custom Provider
  id: providers/custom
  summary: To learn how to make your own custom Vagrant providers, read the Vagrant plugin development guide on creating custom providers
  description: "# Custom Provider\n\nTo learn how to make your own custom Vagrant providers, read the Vagrant plugin development guide on [creating custom providers](../plugins/providers).\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/providers/custom.html](https://www.vagrantup.com/docs/providers/custom.html)"
- name: Debugging
  id: other/debugging
  summary: As much as we try to keep Vagrant stable and bug free, it is inevitable that issues will arise and Vagrant will behave in unexpected ways
  description: "# Debugging\n\nAs much as we try to keep Vagrant stable and bug free, it is inevitable that issues will arise and Vagrant will behave in unexpected ways.\n\nWhen using these support channels, it is generally helpful to include debugging logs along with any error reports. These logs can often help you troubleshoot any problems you may be having.\n\n> **Scan for sensitive information!** Vagrant debug logs include information about your system including environment variables and user information. If you store sensitive information in the environment or in your user account, please scan or scrub the debug log of this information before uploading the contents to the public Internet.\n\n> **Submit debug logs using GitHub Gist.** If you plan on submitting a bug report or issue that includes debug-level logs, please use a service like [Gist](https://gist.github.com). **Do not** paste the raw debug logs into an issue as it makes it very difficult to scroll and parse the information.\n\nTo enable detailed logging, set the `VAGRANT_LOG` environmental variable to the desired log level name, which is one of `debug` (loud), `info` (normal), `warn` (quiet), and `error` (very quiet). When asking for support, please set this to `debug`. When troubleshooting your own issues, you should start with `info`, which is much quieter, but contains important information about the behavior of Vagrant.\n\nOn Linux and Mac systems, this can be done by prepending the `vagrant` command with an environmental variable declaration:\n\n``` highlight\n$ VAGRANT_LOG=info vagrant up\n```\n\nOn Windows, multiple steps are required:\n\n``` highlight\n$ set VAGRANT_LOG=info\n$ vagrant up\n```\n\nYou can also get the debug level output using the `--debug` command line option. For example:\n\n``` highlight\n$ vagrant up --debug\n```\n\nOn Linux and Mac, if you are saving the output to a file, you may need to redirect stderr and stdout using `&>`:\n\n``` highlight\n$ vagrant up --debug &> vagrant.log\n```\n\nOn Windows in PowerShell (outputs to log and screen):\n\n``` highlight\n$ vagrant up --debug 2>&1 | Tee-Object -FilePath \".\\vagrant.log\"\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/other/debugging.html](https://www.vagrantup.com/docs/other/debugging.html)"
- name: Default Provider
  id: providers/default
  summary: By default, VirtualBox is the default provider for Vagrant
  description: "# Default Provider\n\nBy default, VirtualBox is the default provider for Vagrant. VirtualBox is still the most accessible platform to use Vagrant: it is free, cross-platform, and has been supported by Vagrant for years. With VirtualBox as the default provider, it provides the lowest friction for new users to get started with Vagrant.\n\nHowever, you may find after using Vagrant for some time that you prefer to use another provider as your default. In fact, this is quite common. To make this experience better, Vagrant allows specifying the default provider to use by setting the `VAGRANT_DEFAULT_PROVIDER` environmental variable.\n\nJust set `VAGRANT_DEFAULT_PROVIDER` to the provider you wish to be the default. For example, if you use Vagrant with VMware Fusion, you can set the environmental variable to `vmware_fusion` and it will be your default.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/providers/default.html](https://www.vagrantup.com/docs/providers/default.html)"
- name: Docker
  id: docker/index
  summary: Vagrant comes with support out of the box for using Docker as a provider
  description: "# Docker\n\nVagrant comes with support out of the box for using Docker as a provider. This allows for your development environments to be backed by Docker containers rather than virtual machines. Additionally, it provides for a good workflow for developing Dockerfiles.\n\n> **Warning: Docker knowledge assumed.** We assume that you know what Docker is and that you are comfortable with the basics of Docker. If not, we recommend starting with another provider such as [VirtualBox](../virtualbox/index).\n\nUse the navigation to the left to find a specific Docker topic to read more about.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/docker/](https://www.vagrantup.com/docs/docker/)"
- name: Docker Basic Usage
  id: docker/basics
  summary: The Docker provider in Vagrant behaves just like any other provider
  description: "# Docker Basic Usage\n\nThe Docker provider in Vagrant behaves just like any other provider. If you are familiar with Vagrant already, then using the Docker provider should be intuitive and simple.\n\nThe Docker provider *does not* require a `config.vm.box` setting. Since the \"base image\" for a Docker container is pulled from the Docker Index or built from a Dockerfile, the box does not add much value, and is optional for this provider.\n\n## Docker Images\n\nThe first method that Vagrant can use to source a Docker container is via an image. This image can be from any Docker registry. An example is shown below:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provider \"docker\" do |d|\n    d.image = \"foo/bar\"\n  end\nend\n```\n\nWhen `vagrant up --provider=docker` is run, this will bring up the image `foo/bar`.\n\nThis is useful for extra components of your application that it might depend on: databases, queues, etc. Typically, the primary application you are working on is built with a Dockerfile, or via a container with SSH.\n\n## Dockerfiles\n\nVagrant can also automatically build and run images based on a local Dockerfile. This is useful for iterating on an application locally that is built into an image later. An example is shown below:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provider \"docker\" do |d|\n    d.build_dir = \".\"\n  end\nend\n```\n\nThe above configuration will look for a `Dockerfile` in the same directory as the Vagrantfile. When `vagrant up --provider=docker` is run, Vagrant automatically builds that Dockerfile and starts a container based on that Dockerfile.\n\nThe Dockerfile is rebuilt when `vagrant reload` is called.\n\n## Synced Folders and Networking\n\nWhen using Docker, Vagrant automatically converts synced folders and networking options into Docker volumes and forwarded ports. You do not have to use the Docker-specific configurations to do this. This helps keep your Vagrantfile similar to how it has always looked.\n\nThe Docker provider does not support specifying options for `owner` or `group` on folders synced with a docker container.\n\nPrivate and public networks are not currently supported.\n\n### Volume Consistency\n\nDocker's [volume consistency](https://docs.docker.com/v17.09/engine/admin/volumes/bind-mounts/) setting can be specified using the `docker_consistency` option when defining a synced folder. This can [greatly improve performance on macOS](https://docs.docker.com/docker-for-mac/osxfs-caching). An example is shown using the `cached` and `delegated` settings:\n\n``` ruby\nconfig.vm.synced_folder \"/host/dir1\", \"/guest/dir1\", docker_consistency: \"cached\"\nconfig.vm.synced_folder \"/host/dir2\", \"/guest/dir2\", docker_consistency: \"delegated\"\n```\n\n## Host VM\n\nIf the system cannot run Linux containers natively, Vagrant automatically spins up a \"host VM\" to run Docker. This allows your Docker-based Vagrant environments to remain portable, without inconsistencies depending on the platform they are running on.\n\nVagrant will spin up a single instance of a host VM and run multiple containers on this one VM. This means that with the Docker provider, you only have the overhead of one virtual machine, and only if it is absolutely necessary.\n\nBy default, the host VM Vagrant spins up is [backed by boot2docker](https://github.com/hashicorp/vagrant/blob/master/plugins/providers/docker/hostmachine/Vagrantfile), because it launches quickly and uses little resources. But the host VM can be customized to point to *any* Vagrantfile. This allows the host VM to more closely match production by running a VM running Ubuntu, RHEL, etc. It can run any operating system supported by Vagrant.\n\n> **Synced folder note:** Vagrant will attempt to use the \"best\" synced folder implementation it can. For boot2docker, this is often rsync. In this case, make sure you have rsync installed on your host machine. Vagrant will give you a human-friendly error message if it is not.\n\nAn example of changing the host VM is shown below. Remember that this is optional, and Vagrant will spin up a default host VM if it is not specified:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provider \"docker\" do |d|\n    d.vagrant_vagrantfile = \"../path/to/Vagrantfile\"\n  end\nend\n```\n\nThe host VM will be spun up at the first `vagrant up` where the provider is Docker. To control this host VM, use the [global-status command](../cli/global-status) along with global control.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/docker/basics.html](https://www.vagrantup.com/docs/docker/basics.html)"
- name: Docker Boxes
  id: docker/boxes
  summary: The Docker provider does not require a Vagrant box
  description: "# Docker Boxes\n\nThe Docker provider does not require a Vagrant box. The `config.vm.box` setting is completely optional.\n\nA box can still be used and specified, however, to provide defaults. Because the `Vagrantfile` within a box is loaded as part of the configuration loading sequence, it can be used to configure the foundation of a development environment.\n\nIn general, however, you will not need a box with the Docker provider.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/docker/boxes.html](https://www.vagrantup.com/docs/docker/boxes.html)"
- name: Docker Commands
  id: docker/commands
  summary: The Docker provider exposes some additional Vagrant commands that are useful for interacting with Docker containers
  description: "# Docker Commands\n\nThe Docker provider exposes some additional Vagrant commands that are useful for interacting with Docker containers. This helps with your workflow on top of Vagrant so that you have full access to Docker underneath.\n\n### docker-exec\n\n`vagrant docker-exec` can be used to run one-off commands against a Docker container that is currently running. If the container is not running, an error will be returned.\n\n``` shell\n$ vagrant docker-exec app -- rake db:migrate\n```\n\nThe above would run `rake db:migrate` in the context of an `app` container.\n\nNote that the \"name\" corresponds to the name of the VM, **not** the name of the Docker container. Consider the following Vagrantfile:\n\n``` ruby\nVagrant.configure(2) do |config|\n  config.vm.provider \"docker\" do |d|\n    d.image = \"consul\"\n  end\nend\n```\n\nThis Vagrantfile will start the official Docker Consul image. However, the associated Vagrant command to `docker-exec` into this instance is:\n\n``` shell\n$ vagrant docker-exec -it -- /bin/sh\n```\n\nIn particular, the command is actually:\n\n``` shell\n$ vagrant docker-exec default -it -- /bin/sh\n```\n\nBecause \"default\" is the default name of the first defined VM. In a multi-machine Vagrant setup as shown below, the \"name\" attribute corresponds to the name of the VM, **not** the name of the container:\n\n``` ruby\nVagrant.configure do |config|\n  config.vm.define \"web\" do\n    config.vm.provider \"docker\" do |d|\n      d.image = \"nginx\"\n    end\n  end\n\n  config.vm.define \"consul\" do\n    config.vm.provider \"docker\" do |d|\n      d.image = \"consul\"\n    end\n  end\nend\n```\n\nThe following command is invalid:\n\n``` shell\n# Not valid\n$ vagrant docker-exec -it nginx -- /bin/sh\n```\n\nThis is because the \"name\" of the VM is \"web\", so the command is actually:\n\n``` shell\n$ vagrant docker-exec -it web -- /bin/sh\n```\n\nFor this reason, it is recommended that you name the VM the same as the container. In the above example, it is unambiguous that the command to enter the Consul container is:\n\n``` shell\n$ vagrant docker-exec -it consul -- /bin/sh\n```\n\n### docker-logs\n\n`vagrant docker-logs` can be used to see the logs of a running container. Because most Docker containers are single-process, this is used to see the logs of that one process. Additionally, the logs can be tailed.\n\n### docker-run\n\n`vagrant docker-run` can be used to run one-off commands against a Docker container. The one-off Docker container that is started shares all the volumes, links, etc. of the original Docker container. An example is shown below:\n\n``` shell\n$ vagrant docker-run app -- rake db:migrate\n```\n\nThe above would run `rake db:migrate` in the context of an `app` container.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/docker/commands.html](https://www.vagrantup.com/docs/docker/commands.html)"
- name: Docker Configuration
  id: docker/configuration
  summary: The Docker provider has some provider-specific configuration options you may set
  description: "# Docker Configuration\n\nThe Docker provider has some provider-specific configuration options you may set. A complete reference is shown below.\n\n### Required\n\nOne of the following settings is required when using the Docker provider:\n\n- [`build_dir`](#build_dir) (string) - The path to a directory containing a Dockerfile.\n\n- [`image`](#image) (string) - The image to launch, specified by the image ID or a name such as `ubuntu:12.04`.\n\n- [`git_repo`](#git_repo) (string) - The URL of a git repository to build the image from. Supports pulling specific tags, branches and revision, consult the [docker documenation](https://docs.docker.com/engine/reference/commandline/build/#/git-repositories) for more information.\n\n### Optional\n\nGeneral settings:\n\n- [`build_args`](#build_args) (array of strings) - Extra arguments to pass to `docker build` when `build_dir` is in use.\n\n- [`cmd`](#cmd) (array of strings) - Custom command to run on the container. Example: `[\"ls\", \"/app\"]`.\n\n- [`compose`](#compose) (boolean) - If true, Vagrant will use `docker-compose` to manage the lifecycle and configuration of containers. This defaults to false.\n\n- [`compose_configuration`](#compose_configuration) (Hash) - Configuration values used for populating the `docker-compose.yml` file. The value of this Hash is directly merged and written to the `docker-compose.yml` file allowing customization of non-services items like networks and volumes.\n\n- [`create_args`](#create_args) (array of strings) - Additional arguments to pass to `docker run` when the container is started. This can be used to set parameters that are not exposed via the Vagrantfile.\n\n- [`dockerfile`](#dockerfile) (string) - Name of the Dockerfile in the build directory. This defaults to \"Dockerfile\"\n\n- [`env`](#env) (hash) - Environmental variables to expose into the container.\n\n- [`expose`](#expose) (array of integers) - Ports to expose from the container but not to the host machine. Useful for links.\n\n- [`link`](#link) (method, string argument) - Link this container to another by name. The argument should be in the format of `(name:alias)`. Example: `docker.link(\"db:db\")`. Note, if you are linking to another container in the same Vagrantfile, make sure you call `vagrant up` with the `--no-parallel` flag.\n\n- [`force_host_vm`](#force_host_vm) (boolean) - If true, then a host VM will be spun up even if the computer running Vagrant supports Linux containers. This is useful to enforce a consistent environment to run Docker. This value defaults to \"false\" on Linux, Mac, and Windows hosts and defaults to \"true\" on other hosts. Users on other hosts who choose to use a different Docker provider or opt-in to the native Docker builds can explicitly set this value to false to disable the behavior.\n\n- [`has_ssh`](#has_ssh) (boolean) - If true, then Vagrant will support SSH with the container. This allows `vagrant ssh` to work, provisioners, etc. This defaults to false.\n\n- [`host_vm_build_dir_options`](#host_vm_build_dir_options) (hash) - Synced folder options for the `build_dir`, since the build directory is synced using a synced folder if a host VM is in use.\n\n- [`name`](#name) (string) - Name of the container. Note that this has to be unique across all containers on the host VM. By default Vagrant will generate some random name.\n\n- [`pull`](#pull) (bool) - If true, the image will be pulled on every `up` and `reload`. Defaults to false.\n\n- [`ports`](#ports) (array of strings) - Ports to expose from the container to the host. These should be in the format of `host:container`.\n\n- [`remains_running`](#remains_running) (boolean) - If true, Vagrant expects this container to remain running and will make sure that it does for a certain amount of time. If false, then Vagrant expects that this container will automatically stop at some point, and will not error if it sees it do that.\n\n- [`stop_timeout`](#stop_timeout) (integer) - The amount of time to wait when stopping a container before sending a SIGTERM to the process.\n\n- [`vagrant_machine`](#vagrant_machine) (string) - The name of the Vagrant machine in the `vagrant_vagrantfile` to use as the host machine. This defaults to \"default\".\n\n- [`vagrant_vagrantfile`](#vagrant_vagrantfile) (string) - Path to a Vagrantfile that contains the `vagrant_machine` to use as the host VM if needed.\n\n- [`volumes`](#volumes) (array of strings) - List of directories to mount as volumes into the container. These directories must exist in the host where Docker is running. If you want to sync folders from the host Vagrant is running, just use synced folders.\n\nBelow, we have settings related to auth. If these are set, then Vagrant will `docker login` prior to starting containers, allowing you to pull images from private repositories.\n\n- [`email`](#email) (string) - Email address for logging in.\n\n- [`username`](#username) (string) - Username for logging in.\n\n- [`password`](#password) (string) - Password for logging in.\n\n- [`auth_server`](#auth_server) (string) - The server to use for authentication. If not set, the Docker Hub will be used.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/docker/configuration.html](https://www.vagrantup.com/docs/docker/configuration.html)"
- name: Docker Provisioner
  id: provisioning/docker
  summary: The Vagrant Docker provisioner can automatically install Docker, pull Docker containers, and configure certain containers to run on boot
  description: "# Docker Provisioner\n\n**Provisioner name: `\"docker\"`**\n\nThe Vagrant Docker provisioner can automatically install [Docker](https://www.docker.io), pull Docker containers, and configure certain containers to run on boot.\n\nThe docker provisioner is ideal for organizations that are using Docker as a means to distribute things like their application or services. Or, if you are just getting started with Docker, the Docker provisioner provides the easiest possible way to begin using Docker since the provisioner automates installing Docker for you.\n\nAs with all provisioners, the Docker provisioner can be used along with all the other provisioners Vagrant has in order to setup your working environment the best way possible. For example, perhaps you use Puppet to install services like databases or web servers but use Docker to house your application runtime. You can use the Puppet provisioner along with the Docker provisioner.\n\n> **Note:** This documentation is for the Docker *provisioner*. If you are looking for the Docker *provider*, visit the [Docker provider documentation](../docker/index).\n\n## Options\n\nThe docker provisioner takes various options. None are required. If no options are required, the Docker provisioner will only install Docker for you (if it is not already installed).\n\n- [`images`](#images) (array) - A list of images to pull using `docker pull`. You can also use the `pull_images` function. See the example below this section for more information.\n\nIn addition to the options that can be set, various functions are available and can be called to configure other aspects of the Docker provisioner. Most of these functions have examples in more detailed sections below.\n\n- [`build_image`](#build_image) - Build an image from a Dockerfile.\n\n- [`pull_images`](#pull_images) - Pull the given images. This does not start these images.\n\n- [`post_install_provisioner`](#post_install_provisioner) - A [provisioner block](../provisioning) that runs post docker installation.\n\n- [`run`](#run) - Run a container and configure it to start on boot. This can only be specified once.\n\n## Building Images\n\nThe provisioner can automatically build images. Images are built prior to any configured containers to run, so you can build an image before running it. Building an image is easy:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"docker\" do |d|\n    d.build_image \"/vagrant/app\"\n  end\nend\n```\n\nThe argument to build an image is the path to give to `docker build`. This must be a path that exists within the guest machine. If you need to get data to the guest machine, use a synced folder.\n\nThe `build_image` function accepts options as a second parameter. Here are the available options:\n\n- [`args`](#args) (string) - Additional arguments to pass to `docker build`. Use this to pass in things like `-t \"foo\"` to tag the image.\n\n## Pulling Images\n\nThe docker provisioner can automatically pull images from the Docker registry for you. There are two ways to specify images to pull. The first is as an array using `images`:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"docker\",\n    images: [\"ubuntu\"]\nend\n```\n\nThis will cause Vagrant to pull the \"ubuntu\" image from the registry for you automatically.\n\nThe second way to pull images is to use the `pull_images` function. Each call to `pull_images` will *append* the images to be pulled. The `images` variable, on the other hand, can only be used once.\n\nAdditionally, the `pull_images` function cannot be used with the simple configuration method for provisioners (specifying it all in one line).\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"docker\" do |d|\n    d.pull_images \"ubuntu\"\n    d.pull_images \"vagrant\"\n  end\nend\n```\n\n## Running Containers\n\nIn addition to pulling images, the Docker provisioner can run and start containers for you. This lets you automatically start services as part of `vagrant up`.\n\nRunning containers can only be configured using the Ruby block syntax with the `do...end` blocks. An example of running a container is shown below:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"docker\" do |d|\n    d.run \"rabbitmq\"\n  end\nend\n```\n\nThis will `docker run` a container with the \"rabbitmq\" image. Note that Vagrant uses the first parameter (the image name by default) to override any settings used in a previous `run` definition. Therefore, if you need to run multiple containers from the same image then you must specify the `image` option (documented below) with a unique name.\n\nIn addition to the name, the `run` method accepts a set of options, all optional:\n\n- [`image`](#image) (string) - The image to run. This defaults to the first argument but can also be given here as an option.\n\n- [`cmd`](#cmd) (string) - The command to start within the container. If not specified, then the container's default command will be used, such as the \"CMD\" command [specified in the `Dockerfile`](https:/docs.docker.io/en/latest/use/builder/#cmd).\n\n- [`args`](#args-1) (string) - Extra arguments for [`docker run`](https:/docs.docker.io/en/latest/commandline/cli/#run) on the command line. These are raw arguments that are passed directly to Docker.\n\n- [`auto_assign_name`](#auto_assign_name) (boolean) - If true, the `--name` of the container will be set to the first argument of the run. By default this is true. If the name set contains a \"/\" (because of the image name), it will be replaced with \"-\". Therefore, if you do `d.run \"foo/bar\"`, then the name of the container will be \"foo-bar\".\n\n- [`daemonize`](#daemonize) (boolean) - If true, the \"-d\" flag is given to `docker run` to daemonize the containers. By default this is true.\n\n- [`restart`](#restart) (string) - The restart policy for the container. Defaults to \"always\"\n\nFor example, here is how you would configure Docker to run a container with the Vagrant shared directory mounted inside of it:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"docker\" do |d|\n    d.run \"ubuntu\",\n      cmd: \"bash -l\",\n      args: \"-v '/vagrant:/var/www'\"\n  end\nend\n```\n\nIn case you need to run multiple containers based off the same image, you can do so by providing different names and specifying the `image` parameter to it:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"docker\" do |d|\n    d.run \"db-1\", image: \"user/mysql\"\n    d.run \"db-2\", image: \"user/mysql\"\n  end\nend\n```\n\n## Other\n\nThis section documents some other things related to the Docker provisioner that are generally useful to know if you are using this provisioner.\n\n### Customize `/etc/default/docker`\n\nTo customize this file, use the `post_install_provisioner` shell provisioner.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"docker\" do |d|\n    d.post_install_provision \"shell\", inline:\"echo export http_proxy='http://127.0.0.1:3128/' >> /etc/default/docker\"\n    d.run \"ubuntu\",\n      cmd: \"bash -l\",\n      args: \"-v '/vagrant:/var/www'\"\n  end\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/docker.html](https://www.vagrantup.com/docs/provisioning/docker.html)"
- name: Environmental Variables
  id: other/environmental-variables
  summary: Vagrant has a set of environmental variables that can be used to configure and control it in a global way
  description: "# Environmental Variables\n\nVagrant has a set of environmental variables that can be used to configure and control it in a global way. This page lists those environmental variables.\n\n## `VAGRANT_ALIAS_FILE`\n\n`VAGRANT_ALIAS_FILE` can be set to change the file where Vagrant aliases are defined. By default, this is set to `~/.vagrant.d/aliases`.\n\n## `VAGRANT_DEBUG_LAUNCHER`\n\nFor performance reasons, especially for Windows users, Vagrant uses a static binary to launch the actual Vagrant process. If you have *very* early issues when launching Vagrant from the official installer, you can specify the `VAGRANT_DEBUG_LAUNCHER` environment variable to output debugging information about the launch process.\n\n## `VAGRANT_DEFAULT_PROVIDER`\n\nThis configures the default provider Vagrant will use.\n\nThis normally does not need to be set since Vagrant is fairly intelligent about how to detect the default provider. By setting this, you will force Vagrant to use this provider for any *new* Vagrant environments. Existing Vagrant environments will continue to use the provider they came `up` with. Once you `vagrant destroy` existing environments, this will take effect.\n\n## `VAGRANT_DEFAULT_TEMPLATE`\n\nThis configures the template used by `vagrant init` when the `--template` option is not provided.\n\n## `VAGRANT_PREFERRED_PROVIDERS`\n\nThis configures providers that Vagrant should prefer.\n\nMuch like the `VAGRANT_DEFAULT_PROVIDER` this environment variable normally does not need to be set. By setting this you will instruct Vagrant to *prefer* providers defined in this environment variable for any *new* Vagrant environments. Existing Vagrant environments will continue to use the provider they came `up` with. Once you `vagrant destroy` existing environments, this will take effect. A single provider can be defined within this environment variable or a comma delimited list of providers.\n\n## `VAGRANT_BOX_UPDATE_CHECK_DISABLE`\n\nBy default, Vagrant will query the metadata API server to see if a newer box version is available for download. This optional can be disabled on a per-Vagrantfile basis with `config.vm.box_check_update`, but it can also be disabled globally setting `VAGRANT_BOX_UPDATE_CHECK_DISABLE` to any non-empty value.\n\nThis option will not affect global box functions like `vagrant box update`.\n\n## `VAGRANT_CHECKPOINT_DISABLE`\n\nVagrant does occasional network calls to check whether the version of Vagrant that is running locally is up to date. We understand that software making remote calls over the internet for any reason can be undesirable. To suppress these calls, set the environment variable `VAGRANT_CHECKPOINT_DISABLE` to any non-empty value.\n\nIf you use other HashiCorp tools like Packer and would prefer to configure this setting only once, you can set `CHECKPOINT_DISABLE` instead.\n\n## `VAGRANT_CWD`\n\n`VAGRANT_CWD` can be set to change the working directory of Vagrant. By default, Vagrant uses the current directory you are in. The working directory is important because it is where Vagrant looks for the Vagrantfile. It also defines how relative paths in the Vagrantfile are expanded, since they're expanded relative to where the Vagrantfile is found.\n\nThis environmental variable is most commonly set when running Vagrant from a scripting environment in order to set the directory that Vagrant sees.\n\n## `VAGRANT_DOTFILE_PATH`\n\n`VAGRANT_DOTFILE_PATH` can be set to change the directory where Vagrant stores VM-specific state, such as the VirtualBox VM UUID. By default, this is set to `.vagrant`. If you keep your Vagrantfile in a Dropbox folder in order to share the folder between your desktop and laptop (for example), Vagrant will overwrite the files in this directory with the details of the VM on the most recently-used host. To avoid this, you could set `VAGRANT_DOTFILE_PATH` to `.vagrant-laptop` and `.vagrant-desktop` on the respective machines. (Remember to update your `.gitignore`!)\n\n## `VAGRANT_HOME`\n\n`VAGRANT_HOME` can be set to change the directory where Vagrant stores global state. By default, this is set to `~/.vagrant.d`. The Vagrant home directory is where things such as boxes are stored, so it can actually become quite large on disk.\n\n## `VAGRANT_LOG`\n\n`VAGRANT_LOG` specifies the verbosity of log messages from Vagrant. By default, Vagrant does not actively show any log messages.\n\nLog messages are very useful when troubleshooting issues, reporting bugs, or getting support. At the most verbose level, Vagrant outputs basically everything it is doing.\n\nAvailable log levels are \"debug,\" \"info,\" \"warn,\" and \"error.\" Both \"warn\" and \"error\" are practically useless since there are very few cases of these, and Vagrant generally reports them within the normal output.\n\n\"info\" is a good level to start with if you are having problems, because while it is much louder than normal output, it is still very human-readable and can help identify certain issues.\n\n\"debug\" output is *extremely* verbose and can be difficult to read without some knowledge of Vagrant internals. It is the best output to attach to a support request or bug report, however.\n\n## `VAGRANT_NO_COLOR`\n\nIf this is set to any value, then Vagrant will not use any colorized output. This is useful if you are logging the output to a file or on a system that does not support colors.\n\nThe equivalent behavior can be achieved by using the `--no-color` flag on a command-by-command basis. This environmental variable is useful for setting this flag globally.\n\n## `VAGRANT_FORCE_COLOR`\n\nIf this is set to any value, then Vagrant will force colored output, even if it detected that there is no TTY or the current environment does not support it.\n\nThe equivalent behavior can be achieved by using the `--color` flag on a command-by-command basis. This environmental variable is useful for setting this flag globally.\n\n## `VAGRANT_NO_PLUGINS`\n\nIf this is set to any value, then Vagrant will not load any 3rd party plugins. This is useful if you install a plugin and it is introducing instability to Vagrant, or if you want a specific Vagrant environment to not load plugins.\n\nNote that any `vagrant plugin` commands automatically do not load any plugins, so if you do install any unstable plugins, you can always use the `vagrant plugin` commands without having to worry.\n\n## `VAGRANT_ALLOW_PLUGIN_SOURCE_ERRORS`\n\nIf this is set to any value, then Vagrant will not error when a configured plugin source is unavailable. When installing a Vagrant plugin Vagrant will error and halt if a plugin source is inaccessible. In some cases it may be desirable to ignore inaccessible sources and continue with the plugin installation. Enabling this value will cause Vagrant to simply log the plugin source error and continue.\n\n## `VAGRANT_INSTALL_LOCAL_PLUGINS`\n\nIf this is set to any value, Vagrant will not prompt for confirmation prior to installing local plugins which have been defined within the local Vagrantfile.\n\n## `VAGRANT_LOCAL_PLUGINS_LOAD`\n\nIf this is set Vagrant will not stub the Vagrantfile when running `vagrant plugin` commands. When this environment variable is set the `--local` flag will not be required by `vagrant plugin` commands to enable local project plugins.\n\n## `VAGRANT_NO_PARALLEL`\n\nIf this is set, Vagrant will not perform any parallel operations (such as parallel box provisioning). All operations will be performed in serial.\n\n## `VAGRANT_DETECTED_OS`\n\nThis environment variable may be set by the Vagrant launcher to help determine the current runtime platform. In general Vagrant will set this value when running on a Windows host using a cygwin or msys based shell. If this value is set, the Vagrant launcher will not modify it.\n\n## `VAGRANT_DETECTED_ARCH`\n\nThis environment variable may be set by the Vagrant launcher to help determine the current runtime architecture in use. In general Vagrant will set this value when running on a Windows host using a cygwin or msys based shell. The value the Vagrant launcher may set in this environment variable will not always match the actual architecture of the platform itself. Instead it signifies the detected architecture of the environment it is running within. If this value is set, the Vagrant launcher will not modify it.\n\n## `VAGRANT_WINPTY_DISABLE`\n\nIf this is set, Vagrant will *not* wrap interactive processes with winpty where required.\n\n## `VAGRANT_PREFER_SYSTEM_BIN`\n\nIf this is set, Vagrant will prefer using utility executables (like `ssh` and `rsync`) from the local system instead of those vendored within the Vagrant installation.\n\nVagrant will default to using a system provided `ssh` on Windows. This environment variable can also be used to disable that behavior to force Vagrant to use the embedded `ssh` executable by setting it to `0`.\n\n## `VAGRANT_SKIP_SUBPROCESS_JAILBREAK`\n\nAs of Vagrant 1.7.3, Vagrant tries to intelligently detect if it is running in the installer or running via Bundler. Although not officially supported, Vagrant tries its best to work when executed via Bundler. When Vagrant detects that you have spawned a subprocess that lives outside of Vagrant's installer, Vagrant will do its best to reset the preserved environment during the subprocess execution.\n\nIf Vagrant detects it is running outside of the officially installer, the original environment will always be restored. You can disable this automatic jailbreak by setting `VAGRANT_SKIP_SUBPROCESS_JAILBREAK`.\n\n## `VAGRANT_VAGRANTFILE`\n\nThis specifies the filename of the Vagrantfile that Vagrant searches for. By default, this is \"Vagrantfile\". Note that this is *not* a file path, but just a filename.\n\nThis environmental variable is commonly used in scripting environments where a single folder may contain multiple Vagrantfiles representing different configurations.\n\n## `VAGRANT_DISABLE_VBOXSYMLINKCREATE`\n\nIf set, this will disable the ability to create symlinks with all virtualbox shared folders. Defaults to true if the option is not set. This can be overridden on a per-folder basis within your Vagrantfile config by settings the `SharedFoldersEnableSymlinksCreate` option to true.\n\n## `VAGRANT_ENABLE_RESOLV_REPLACE`\n\nUse the Ruby Resolv library in place of the libc resolver.\n\n## `VAGRANT_DISABLE_RESOLV_REPLACE`\n\nVagrant can optionally use the Ruby Resolv library in place of the libc resolver. This can be disabled setting this environment variable.\n\n## `VAGRANT_POWERSHELL_VERSION_DETECTION_TIMEOUT`\n\nVagrant will use a default timeout when checking for the installed version of PowerShell. Occasionally the default can be too low and Vagrant will report being unable to detect the installed version of PowerShell. This environment variable can be used to extend the timeout used during PowerShell version detection.\n\nWhen setting this environment variable, its value will be in seconds. By default, it will use 30 seconds as a timeout.\n\n## `VAGRANT_USE_VAGRANT_TRIGGERS`\n\nVagrant will not display the warning about disabling the core trigger feature if the community plugin is installed.\n\n## `VAGRANT_IGNORE_WINRM_PLUGIN`\n\nVagrant will not display warning when `vagrant-winrm` plugin is installed.\n\n## `VAGRANT_USER_AGENT_PROVISIONAL_STRING`\n\nVagrant will append the contents of this variable to the default user agent header.\n\n## `VAGRANT_IS_HYPERV_ADMIN`\n\nDisable Vagrant's check for Hyper-V admin privileges and allow Vagrant to assume the current user has full access to Hyper-V. This is useful if the internal privilege check incorrectly determines the current user does not have access to Hyper-V.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/other/environmental-variables.html](https://www.vagrantup.com/docs/other/environmental-variables.html)"
- name: File Provisioner
  id: provisioning/file
  summary: The Vagrant file provisioner allows you to upload a file or directory from the host machine to the guest machine
  description: "# File Provisioner\n\n**Provisioner name: `\"file\"`**\n\nThe Vagrant file provisioner allows you to upload a file or directory from the host machine to the guest machine.\n\nFile provisioning is a simple way to, for example, replicate your local ~/.gitconfig to the vagrant user's home directory on the guest machine so you will not have to run `git config --global` every time you provision a new VM.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ... other configuration\n\n  config.vm.provision \"file\", source: \"~/.gitconfig\", destination: \".gitconfig\"\nend\n```\n\nIf you want to upload a folder to your guest system, it can be accomplished by using a file provisioner seen below. When copied, the resulting folder on the guest will replace `folder` as `newfolder` and place its on the guest machine. Note that if you'd like the same folder name on your guest machine, make sure that the destination path has the same name as the folder on your host.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ... other configuration\n\n  config.vm.provision \"file\", source: \"~/path/to/host/folder\", destination: \"$HOME/remote/newfolder\"\nend\n```\n\nPrior to copying `~/path/to/host/folder` to the guest machine:\n\n``` highlight\n    folder\n    ├── script.sh\n    ├── otherfolder\n    │   └── hello.sh\n    ├── goodbye.sh\n    ├── hello.sh\n    └── woot.sh\n\n    1 directory, 5 files\n```\n\nAfter to copying `~/path/to/host/folder` into `$HOME/remote/newfolder` to the guest machine:\n\n``` highlight\n    newfolder\n    ├── script.sh\n    ├── otherfolder\n    │   └── hello.sh\n    ├── goodbye.sh\n    ├── hello.sh\n    └── woot.sh\n\n    1 directory, 5 files\n```\n\nNote that, unlike with synced folders, files or directories that are uploaded will not be kept in sync. Continuing with the example above, if you make further changes to your local ~/.gitconfig, they will not be immediately reflected in the copy you uploaded to the guest machine.\n\nThe file uploads by the file provisioner are done as the *SSH or PowerShell user*. This is important since these users generally do not have elevated privileges on their own. If you want to upload files to locations that require elevated privileges, we recommend uploading them to temporary locations and then using the [shell provisioner](shell) to move them into place.\n\n## Options\n\nThe file provisioner takes only two options, both of which are required:\n\n- [`source`](#source) (string) - Is the local path of the file or directory to be uploaded.\n\n- [`destination`](#destination) (string) - Is the remote path on the guest machine where the source will be uploaded to. The file/folder is uploaded as the SSH user over SCP, so this location must be writable to that user. The SSH user can be determined by running `vagrant ssh-config`, and defaults to \"vagrant\".\n\n## Caveats\n\nWhile the file provisioner does support trailing slashes or \"globing\", this can lead to some confusing results due to the underlying tool used to copy files and folders between the host and guests. For example, if you have a source and destination with a trailing slash defined below:\n\n``` ruby\nconfig.vm.provision \"file\", source: \"~/pathfolder\", destination: \"/remote/newlocation/\"\n```\n\nYou are telling vagrant to upload `~/pathfolder` under the remote dir `/remote/newlocation`, which will look like:\n\n``` highlight\n    newlocation\n    ├── pathfolder\n    │   └── file.sh\n\n    1 directory, 2 files\n```\n\nThis behavior can also be achieved by defining your file provisioner below:\n\n``` ruby\nconfig.vm.provision \"file\", source: \"~/pathfolder\", destination: \"/remote/newlocation/pathfolder\"\n```\n\nAnother example is using globing on the host machine to grab all files within a folder, but not the top level folder itself:\n\n``` ruby\nconfig.vm.provision \"file\", source: \"~/otherfolder/.\", destination: \"/remote/otherlocation\"\n```\n\nThe file provisioner is defined to include all files under `~/otherfolder` to the new location `/remote/otherlocation`. This idea can be achieved by simply having your destination folder differ from the source folder:\n\n``` ruby\nconfig.vm.provision \"file\", source: \"/otherfolder\", destination: \"/remote/otherlocation\"\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/file.html](https://www.vagrantup.com/docs/provisioning/file.html)"
- name: Forwarded Ports
  id: networking/forwarded_ports
  summary: Vagrant forwarded ports allow you to access a port on your host machine and have all data forwarded to a port on the guest machine, over either TCP or UDP
  description: "# Forwarded Ports\n\n**Network identifier: `forwarded_port`**\n\nVagrant forwarded ports allow you to access a port on your host machine and have all data forwarded to a port on the guest machine, over either TCP or UDP.\n\nFor example: If the guest machine is running a web server listening on port 80, you can make a forwarded port mapping to port 8080 (or anything) on your host machine. You can then open your browser to `localhost:8080` and browse the website, while all actual network data is being sent to the guest.\n\n## Defining a Forwarded Port\n\nThe forwarded port configuration expects two parameters, the port on the guest and the port on the host. Example:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"forwarded_port\", guest: 80, host: 8080\nend\n```\n\nThis will allow accessing port 80 on the guest via port 8080 on the host.\n\nFor most providers, forwarded ports by default bind to all interfaces. This means that other devices on your network can access the forwarded ports. If you want to restrict access, see the `guest_ip` and `host_ip` settings below.\n\n## Options Reference\n\nThis is a complete list of the options that are available for forwarded ports. Only the `guest` and `host` options are required. Below this section, there are more detailed examples of using these options.\n\n- [`auto_correct`](#auto_correct) (boolean) - If true, the host port will be changed automatically in case it collides with a port already in use. By default, this is false.\n\n- [`guest`](#guest) (int) - The port on the guest that you want to be exposed on the host. This can be any port.\n\n- [`guest_ip`](#guest_ip) (string) - The guest IP to bind the forwarded port to. If this is not set, the port will go to every IP interface. By default, this is empty.\n\n- [`host`](#host) (int) - The port on the host that you want to use to access the port on the guest. This must be greater than port 1024 unless Vagrant is running as root (which is not recommended).\n\n- [`host_ip`](#host_ip) (string) - The IP on the host you want to bind the forwarded port to. If not specified, it will be bound to every IP. By default, this is empty.\n\n- [`protocol`](#protocol) (string) - Either \"udp\" or \"tcp\". This specifies the protocol that will be allowed through the forwarded port. By default this is \"tcp\".\n\n- [`id`](#id) (string) - Name of the rule (can be visible in VirtualBox). By default this is \"protocol\"\"guest\" (example : \"tcp123\").\n\n## Forwarded Port Protocols\n\nBy default, any defined port will only forward the TCP protocol. As an optional third parameter, you may specify `protocol: 'udp'` in order to pass UDP traffic. If a given port needs to be able to listen to the same port on both protocols, you must define the port twice with each protocol specified, like so:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"forwarded_port\", guest: 2003, host: 12003, protocol: \"tcp\"\n  config.vm.network \"forwarded_port\", guest: 2003, host: 12003, protocol: \"udp\"\nend\n```\n\n## Port Collisions and Correction\n\nIt is common when running multiple Vagrant machines to unknowingly create forwarded port definitions that collide with each other (two separate Vagrant projects forwarded to port 8080, for example). Vagrant includes built-in mechanism to detect this and correct it, automatically.\n\nPort collision detection is always done. Vagrant will not allow you to define a forwarded port where the port on the host appears to be accepting traffic or connections.\n\nPort collision auto-correction must be manually enabled for each forwarded port, since it is often surprising when it occurs and can lead the Vagrant user to think that the port was not properly forwarded. Enabling auto correct is easy:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"forwarded_port\", guest: 80, host: 8080,\n    auto_correct: true\nend\n```\n\nThe final `:auto_correct` parameter set to true tells Vagrant to auto correct any collisions. During a `vagrant up` or `vagrant reload`, Vagrant will output information about any collisions detections and auto corrections made, so you can take notice and act accordingly.\n\nYou can define allowed port range assignable by Vagrant when port collision is detected via [config.vm.usable_port_range](../vagrantfile/machine_settings) property.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.usable_port_range = 8000..8999\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/networking/forwarded_ports.html](https://www.vagrantup.com/docs/networking/forwarded_ports.html)"
- name: FTP & SFTP Strategy
  id: push/ftp
  summary: Vagrant Push FTP and SFTP strategy pushes the code in your Vagrant development environment to a remote FTP or SFTP server
  description: "# Vagrant Push\n\n## FTP & SFTP Strategy\n\nVagrant Push FTP and SFTP strategy pushes the code in your Vagrant development environment to a remote FTP or SFTP server.\n\nThe Vagrant Push FTP And SFTP strategy supports the following configuration options:\n\n- [`host`](#host) - The address of the remote (S)FTP server. If the (S)FTP server is running on a non-standard port, you can specify the port after the address (`host:port`).\n\n- [`username`](#username) - The username to use for authentication with the (S)FTP server.\n\n- [`password`](#password) - The password to use for authentication with the (S)FTP server.\n\n- [`passive`](#passive) - Use passive FTP (default is true).\n\n- [`secure`](#secure) - Use secure (SFTP) (default is false).\n\n- [`destination`](#destination) - The root destination on the target system to sync the files (default is `/`).\n\n- [`exclude`](#exclude) - Add a file or file pattern to exclude from the upload, relative to the `dir`. This value may be specified multiple times and is additive. `exclude` take precedence over `include` values.\n\n- [`include`](#include) - Add a file or file pattern to include in the upload, relative to the `dir`. This value may be specified multiple times and is additive.\n\n- [`dir`](#dir) - The base directory containing the files to upload. By default this is the same directory as the Vagrantfile, but you can specify this if you have a `src` folder or `bin` folder or some other folder you want to upload.\n\n### Usage\n\nThe Vagrant Push FTP and SFTP strategy is defined in the `Vagrantfile` using the `ftp` key:\n\n``` ruby\nconfig.push.define \"ftp\" do |push|\n  push.host = \"ftp.company.com\"\n  push.username = \"username\"\n  push.password = \"password\"\nend\n```\n\nAnd then push the application to the FTP or SFTP server:\n\n``` shell\n$ vagrant push\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/push/ftp.html](https://www.vagrantup.com/docs/push/ftp.html)"
- name: Heroku Strategy
  id: push/heroku
  summary: Heroku is a public PAAS provider that makes it easy to deploy an application
  description: "# Vagrant Push\n\n## Heroku Strategy\n\n[Heroku](https://heroku.com/ \"Heroku\") is a public PAAS provider that makes it easy to deploy an application. The Vagrant Push Heroku strategy pushes your application's code to Heroku.\n\n> **Warning:** The Vagrant Push Heroku strategy requires you have configured your Heroku credentials and created the Heroku application. This documentation will not cover these prerequisites, but you can read more about them in the [Heroku documentation](https://devcenter.heroku.com).\n\nOnly files which are committed to the Git repository will be pushed to Heroku. Additionally, the current working branch is always pushed to the Heroku, even if it is not the \"master\" branch.\n\nThe Vagrant Push Heroku strategy supports the following configuration options:\n\n- [`app`](#app) - The name of the Heroku application. If the Heroku application does not exist, an exception will be raised. If this value is not specified, the basename of the directory containing the `Vagrantfile` is assumed to be the name of the Heroku application. Since this value can change between users, it is highly recommended that you add the `app` setting to your `Vagrantfile`.\n\n- [`dir`](#dir) - The base directory containing the Git repository to upload to Heroku. By default this is the same directory as the Vagrantfile, but you can specify this if you have a nested Git directory.\n\n- [`remote`](#remote) - The name of the Git remote where Heroku is configured. The default value is \"heroku\".\n\n### Usage\n\nThe Vagrant Push Heroku strategy is defined in the `Vagrantfile` using the `heroku` key:\n\n``` ruby\nconfig.push.define \"heroku\" do |push|\n  push.app = \"my_application\"\nend\n```\n\nAnd then push the application to Heroku:\n\n``` shell\n$ vagrant push\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/push/heroku.html](https://www.vagrantup.com/docs/push/heroku.html)"
- name: HTTP Sharing
  id: share/http
  summary: Vagrant Share can create a publicly accessible URL endpoint to access an HTTP server running in your Vagrant environment
  description: "# HTTP Sharing\n\nVagrant Share can create a publicly accessible URL endpoint to access an HTTP server running in your Vagrant environment. This is known as \"HTTP sharing,\" and is enabled by default when `vagrant share` is used.\n\nBecause this mode of sharing creates a publicly accessible URL, the accessing party does not need to have Vagrant installed in order to view your environment.\n\nThis has a number of useful use cases: you can test webhooks by exposing your Vagrant environment to the internet, you can show your work to clients, teammates, or managers, etc.\n\n## Usage\n\nTo use HTTP sharing, simply run `vagrant share`:\n\n``` highlight\n$ vagrant share\n==> default: Detecting network information for machine...\ndefault: Local machine address: 192.168.84.130\ndefault: Local HTTP port: 9999\ndefault: Local HTTPS port: disabled\n==> default: Creating Vagrant Share session...\n==> default: HTTP URL: http://b1fb1f3f.ngrok.io\n```\n\nVagrant detects where your HTTP server is running in your Vagrant environment and outputs the endpoint that can be used to access this share. Just give this URL to anyone you want to share it with, and they will be able to access your Vagrant environment!\n\nIf Vagrant has trouble detecting the port of your servers in your environment, use the `--http` and/or `--https` flags to be more explicit.\n\nThe share will be accessible for the duration that `vagrant share` is running. Press `Ctrl-C` to quit the sharing session.\n\n> **Warning:** This URL is accessible by *anyone* who knows it, so be careful if you are sharing sensitive information.\n\n## Disabling\n\nIf you want to disable the creation of the publicly accessible endpoint, run `vagrant share` with the `--disable-http` flag. This will share your environment using one of the other methods available, and will not create the URL endpoint.\n\n## Missing Assets\n\nShared web applications must use **relative paths** for loading any local assets such as images, stylesheets, javascript.\n\nThe web application under development will be accessed remotely. This means that if you have any hardcoded asset (images, stylesheets, etc.) URLs such as `<img src=\"http://127.0.0.1/header.png\">`, then they will not load for people accessing your share.\n\nMost web frameworks or toolkits have settings or helpers to generate relative paths. For example, if you are a WordPress developer, the [Root Relative URLs](http://wordpress.org/plugins/root-relative-urls/) plugin will automatically do this for you.\n\nRelative URLs to assets is generally a best practice in general, so you should do this anyways!\n\n## HTTPS (SSL)\n\nVagrant Share can also expose an SSL port that can be accessed over SSL. Creating an HTTPS share requires a non-free ngrok account.\n\n`vagrant share` by default looks for any SSL traffic on port 443 in your development environment. If it cannot find any, then SSL is disabled by default.\n\nThe HTTPS share can be explicitly disabled using the `--disable-https` flag.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/share/http.html](https://www.vagrantup.com/docs/share/http.html)"
- name: Hyper-V
  id: hyperv/index
  summary: Vagrant comes with support out of the box for Hyper-V, a native hypervisor written by Microsoft
  description: "# Hyper-V\n\nVagrant comes with support out of the box for [Hyper-V](https://en.wikipedia.org/wiki/Hyper-V), a native hypervisor written by Microsoft. Hyper-V is available by default for almost all Windows 8.1 and later installs.\n\nThe Hyper-V provider is compatible with Windows 8.1 and later only. Prior versions of Hyper-V do not include the necessary APIs for Vagrant to work.\n\nHyper-V must be enabled prior to using the provider. Most Windows installations will not have Hyper-V enabled by default. Hyper-V is available by default for almost all Windows Enterprise, Professional, or Education 8.1 and later installs. To enable Hyper-V, go to \"Programs and Features\", click on \"Turn Windows features on or off\" and check the box next to \"Hyper-V\". Or install via PowerShell with:\n\n`Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All`\n\nSee official documentation [here](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v).\n\n> **Warning:** Enabling Hyper-V will cause VirtualBox, VMware, and any other virtualization technology to no longer work. See [this blog post](http://www.hanselman.com/blog/SwitchEasilyBetweenVirtualBoxAndHyperVWithABCDEditBootEntryInWindows81.aspx) for an easy way to create a boot entry to boot Windows without Hyper-V enabled, if there will be times you will need other hypervisors.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/hyperv/](https://www.vagrantup.com/docs/hyperv/)"
- name: Installation
  id: vmware/installation
  summary: If you are upgrading from the Vagrant VMware Workstation or Vagrant VMware Fusion plugins, please halt or destroy all VMware VMs currently being managed by Vagrant
  description: "# Installation\n\nIf you are upgrading from the Vagrant VMware Workstation or Vagrant VMware Fusion plugins, please halt or destroy all VMware VMs currently being managed by Vagrant. Then continue with the instructions below.\n\nInstallation of the Vagrant VMware provider requires two steps. First the Vagrant VMware Utility must be installed. This can be done by downloading and installing the correct system package from the [Vagrant VMware Utility downloads page](https://www.vagrantup.com/vmware/downloads.html).\n\nNext, install the Vagrant VMware provider plugin using the standard plugin installation procedure:\n\n``` shell\n$ vagrant plugin install vagrant-vmware-desktop\n```\n\nFor more information on plugin installation, please see the [Vagrant plugin usage documentation](../plugins/usage).\n\nThe Vagrant VMware plugin is a commercial product provided by [HashiCorp](https://www.hashicorp.com) and **require the purchase of a license** to operate. To purchase a license, please visit the [Vagrant VMware provider](https://www.vagrantup.com/vmware#buy-now) page. Upon purchasing a license, you will receive a license file in your inbox. Download this file and save it to a temporary location on your computer.\n\n> **Warning!** You cannot use your VMware product license as a Vagrant VMware plugin license. They are separate commercial products, each requiring their own license.\n\nAfter installing the Vagrant VMware Desktop plugin for your system, you will need to install the license:\n\n``` shell\n$ vagrant plugin license vagrant-vmware-desktop ~/license.lic\n```\n\nThe first parameter is the name of the plugin, and the second parameter is the path to the license file on disk. Please be sure to replace `~/license.lic` with the path where you temporarily saved the downloaded license file to disk. After you have installed the plugin license, you may remove the temporary file.\n\nTo verify the license installation, run:\n\n``` shell\n$ vagrant\n```\n\nIf the license is not installed correctly, you will see an error message.\n\n## Upgrading to v1.x\n\nIt is **extremely important** that the VMware plugin is upgraded to 1.0.0 or above. This release resolved critical security vulnerabilities. To learn more, please [read our release announcement](https://www.hashicorp.com/blog/introducing-the-vagrant-vmware-desktop-plugin).\n\nAfter upgrading, please verify that the following paths are empty. The upgrade process should remove these for you, but for security reasons it is important to double check. If you're a new user or installing the VMware provider on a new machine, you may skip this step. If you're a Windows user, you may skip this step as well.\n\nThe path `~/.vagrant.d/gems/*/vagrant-vmware-{fusion,workstation}` should no longer exist. The gem `vagrant-vmware-desktop` may exist since this is the name of the new plugin. If the old directories exist, remove them. An example for a Unix-like shell is shown below:\n\n``` shell\n# Check if they exist and verify that they're the correct paths as shown below.\n$ ls ~/.vagrant.d/gems/*/vagrant-vmware-{fusion,workstation}\n...\n\n# Remove them\n$ rm -rf ~/.vagrant.d/gems/*/vagrant-vmware-{fusion,workstation}\n```\n\n## Updating the Vagrant VMware Desktop plugin\n\nThe Vagrant VMware Desktop plugin can be updated directly from Vagrant. Run the following command to update Vagrant to the latest version of the Vagrant VMware Desktop plugin:\n\n``` shell\n$ vagrant plugin update vagrant-vmware-desktop\n```\n\n## Frequently Asked Questions\n\n**Q: I purchased a Vagrant VMware plugin license, but I did not receive an email?**  \nFirst, please check your JUNK or SPAM folders. Since the license comes from an automated system, it might have been flagged as spam by your email provider. If you do not see the email there, please [contact support](mailto:support@hashicorp.com?subject=License%20Not%20Received) and include the original order number.\n\n**Q: Do I need to keep the Vagrant VMware plugin license file on disk?**  \nAfter you have installed the Vagrant VMware plugin license, it is safe to remove your copy from disk. Vagrant copies the license into its structure for reference on boot.\n\n**Q: I lost my original email, where can I download my Vagrant VMware plugin license again?**  \nPlease [contact support](mailto:support@hashicorp.com?subject=Lost%20My%20License&body=Hello%20support!%20I%20seem%20to%20have%20misplaced%20my%20Vagrant%20VMware%20license.%20Could%20you%20please%20send%20it%20to%20me?%20Thanks!). **Note:** please contact support using the email address with which you made the original purchase. If you use an alternate email, you will be asked to verify that you are the owner of the requested license.\n\n**Q: I upgraded my VMware product and now my license is invalid?**  \nThe Vagrant VMware plugin licenses are valid for specific VMware product versions at the time of purchase. When new versions of VMware products are released, significant changes to the plugin code are often required to support this new version. For this reason, you may need to upgrade your current license to work with the new version of the VMware product. Customers can check their license upgrade eligibility by visiting the [License Upgrade Center](https://license.hashicorp.com/upgrade/vmware) and entering the email address with which they made the original purchase.\n\nYour existing license will continue to work with all previous versions of the VMware products. If you do not wish to update at this time, you can rollback your VMware installation to an older version.\n\n**Q: Why is the Vagrant VMware plugin not working with my trial version of VMware Fusion/Workstation?**  \nThe Vagrant VMware Fusion and Vagrant VMware Workstation plugins are not compatible with trial versions of the VMware products. We apologize for the inconvenience.\n\n**Q: How do I upgrade my currently installed Vagrant VMware plugin?**  \nYou can update the Vagrant VMware plugin to the latest version by re-running the install command:\n\n``` shell\n$ vagrant plugin install vagrant-vmware-desktop\n```\n\n## Support\n\nIf you have any issues purchasing, installing, or using the Vagrant VMware plugins, please [contact support](mailto:support@hashicorp.com). To expedite the support process, please include the [Vagrant debug output](../other/debugging) as a Gist if applicable. This will help us more quickly diagnose your issue.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vmware/installation.html](https://www.vagrantup.com/docs/vmware/installation.html)"
- name: Installing Vagrant
  id: installation/index
  summary: Installing Vagrant is extremely easy
  description: "# Installing Vagrant\n\nInstalling Vagrant is extremely easy. Head over to the [Vagrant downloads page](https://www.vagrantup.com/downloads.html) and get the appropriate installer or package for your platform. Install the package using standard procedures for your operating system.\n\nThe installer will automatically add `vagrant` to your system path so that it is available in terminals. If it is not found, please try logging out and logging back in to your system (this is particularly necessary sometimes for Windows).\n\n> **Looking for the gem install?** Vagrant 1.0.x had the option to be installed as a [RubyGem](https://en.wikipedia.org/wiki/RubyGems). This installation method is no longer supported. If you have an old version of Vagrant installed via Rubygems, please remove it prior to installing newer versions of Vagrant.\n\n> **Beware of system package managers!** Some operating system distributions include a vagrant package in their upstream package repos. Please do not install Vagrant in this manner. Typically these packages are missing dependencies or include very outdated versions of Vagrant. If you install via your system's package manager, it is very likely that you will experience issues. Please use the official installers on the downloads page.\n\n## Running Multiple Hypervisors\n\nSometimes, certain hypervisors do not allow you to bring up virtual machines if more than one hypervisor is in use. If you are lucky, you might see the following error message come up when trying to bring up a virtual machine with Vagrant and VirtualBox:\n\n``` highlight\nThere was an error while executing `VBoxManage`, a CLI used by Vagrant for controlling VirtualBox. The command and stderr is shown below.\n\nCommand: [\"startvm\", <ID of the VM>, \"--type\", \"headless\"]\n\nStderr: VBoxManage: error: VT-x is being used by another hypervisor (VERR_VMX_IN_VMX_ROOT_MODE).\nVBoxManage: error: VirtualBox can't operate in VMX root mode. Please disable the KVM kernel extension, recompile your kernel and reboot\n(VERR_VMX_IN_VMX_ROOT_MODE)\nVBoxManage: error: Details: code NS_ERROR_FAILURE (0x80004005), component ConsoleWrap, interface IConsole\n```\n\nOther operating systems like Windows will blue screen if you attempt to bring up a VirtualBox VM with Hyper-V enabled. Below are a couple of ways to ensure you can use Vagrant and VirtualBox if another hypervisor is present.\n\n### Linux, VirtualBox, and KVM\n\nThe above error message is because another hypervisor (like KVM) is in use. We must blacklist these in order for VirtualBox to run correctly.\n\nFirst find out the name of the hypervisor:\n\n``` highlight\n$ lsmod | grep kvm\nkvm_intel             204800  6\nkvm                   593920  1 kvm_intel\nirqbypass              16384  1 kvm\n```\n\nThe one we're interested in is `kvm_intel`. You might have another.\n\nBlacklist the hypervisor (run the following as root):\n\n``` highlight\n# echo 'blacklist kvm-intel' >> /etc/modprobe.d/blacklist.conf\n```\n\nRestart your machine and try running vagrant again.\n\n### Windows, VirtualBox, and Hyper-V\n\nIf you wish to use VirtualBox on Windows, you must ensure that Hyper-V is not enabled on Windows. You can turn off the feature by running this Powershell command:\n\n``` shell\nDisable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-All\n```\n\nYou can also disable it by going through the Windows system settings:\n\n- Right click on the Windows button and select ‘Apps and Features’.\n- Select Turn Windows Features on or off.\n- Unselect Hyper-V and click OK.\n\nYou might have to reboot your machine for the changes to take effect. More information about Hyper-V can be read [here](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v).\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/installation/](https://www.vagrantup.com/docs/installation/)"
- name: Installing Vagrant from Source
  id: installation/source
  summary: Installing Vagrant from source is an advanced topic and is only recommended when using the official installer is not an option
  description: "# Installing Vagrant from Source\n\nInstalling Vagrant from source is an advanced topic and is only recommended when using the official installer is not an option. This page details the steps and prerequisites for installing Vagrant from source.\n\n## Install Ruby\n\nYou must have a modern Ruby (\\>= 2.2) in order to develop and build Vagrant. The specific Ruby version is documented in the Vagrant's `gemspec`. Please refer to the `vagrant.gemspec` in the repository on GitHub, as it will contain the most up-to-date requirement. This guide will not discuss how to install and manage Ruby. However, beware of the following pitfalls:\n\n- Do **NOT** use the system Ruby - use a Ruby version manager like rvm or chruby\n- Vagrant plugins are configured based on current environment. If plugins are installed using Vagrant from source, they will not work from the package based Vagrant installation.\n\n## Clone Vagrant\n\nClone Vagrant's repository from GitHub into the directory where you keep code on your machine:\n\n``` shell\n$ git clone https://github.com/hashicorp/vagrant.git\n```\n\nNext, `cd` into that path. All commands will be run from this path:\n\n``` shell\n$ cd /path/to/your/vagrant/clone\n```\n\nRun the `bundle` command with a required version\\* to install the requirements:\n\n``` shell\n$ bundle install\n```\n\nYou can now run Vagrant by running `bundle exec vagrant` from inside that directory.\n\n## Use Locally\n\nIn order to use your locally-installed version of Vagrant in other projects, you will need to create a binstub and add it to your path.\n\nFirst, run the following command from the Vagrant repo:\n\n``` shell\n$ bundle --binstubs exec\n```\n\nThis will generate files in `exec/`, including `vagrant`. You can now specify the full path to the `exec/vagrant` anywhere on your operating system:\n\n``` shell\n$ /path/to/vagrant/exec/vagrant init -m hashicorp/precise64\n```\n\nNote that you *will* receive warnings that running Vagrant like this is not supported. It's true. It's not. You should listen to those warnings.\n\nIf you do not want to specify the full path to Vagrant (i.e. you just want to run `vagrant`), you can create a symbolic link to your exec:\n\n``` shell\n$ ln -sf /path/to/vagrant/exec/vagrant /usr/local/bin/vagrant\n```\n\nWhen you want to switch back to the official Vagrant version, simply remove the symlink.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/installation/source.html](https://www.vagrantup.com/docs/installation/source.html)"
- name: Kernel Upgrade
  id: vmware/kernel-upgrade
  summary: If as part of running your Vagrant environment with VMware, you perform a kernel upgrade, it is likely that the VMware guest tools will stop working
  description: "# Kernel Upgrade\n\nIf as part of running your Vagrant environment with VMware, you perform a kernel upgrade, it is likely that the VMware guest tools will stop working. This breaks features of Vagrant such as synced folders and sometimes networking as well.\n\nThis page documents how to upgrade your kernel and keep your guest tools functioning. If you are not planning to upgrade your kernel, then you can safely skip this page.\n\n## Enable Auto-Upgrade of VMware Tools\n\nIf you are running a common OS, VMware tools can often auto-upgrade themselves. This setting is disabled by default. The Vagrantfile settings below will enable auto-upgrading:\n\n``` ruby\n# Ensure that VMWare Tools recompiles kernel modules\n# when we update the linux images\n$fix_vmware_tools_script = <<SCRIPT\nsed -i.bak 's/answer AUTO_KMODS_ENABLED_ANSWER no/answer AUTO_KMODS_ENABLED_ANSWER yes/g' /etc/vmware-tools/locations\nsed -i 's/answer AUTO_KMODS_ENABLED no/answer AUTO_KMODS_ENABLED yes/g' /etc/vmware-tools/locations\nSCRIPT\n\nVagrant.configure(\"2\") do |config|\n  # ...\n\n  config.vm.provision \"shell\", inline: $fix_vmware_tools_script\nend\n```\n\nNote that this does not work for every OS, so `vagrant up` with the above settings, do a kernel upgrade, and do a `vagrant reload`. If HGFS (synced folders) and everything appears to be working, great! If not, then read on...\n\n## Manually Reinstalling VMware Tools\n\nAt this point, you will have to manually reinstall VMware tools. The best source of information for how to do this is the [VMware documentation](https://kb.vmware.com/selfservice/microsites/search.do?language=en_US&cmd=displayKC&externalId=1018414).\n\nThere are some gotchas:\n\n- Make sure you have the kernel headers properly installed. This varies by distro but is generally a package available via the package manager.\n\n- Watch the installation output carefully. Even if HGFS (synced folders) support failed to build, the installer will output that installing VMware tools was successful. Read the output to find any error messages.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vmware/kernel-upgrade.html](https://www.vagrantup.com/docs/vmware/kernel-upgrade.html)"
- name: Known Issues
  id: vmware/known-issues
  summary: This page tracks some known issues or limitations of the VMware provider
  description: "# Known Issues\n\nThis page tracks some known issues or limitations of the VMware provider. Note that none of these are generally blockers to using the provider, but are good to know.\n\n## Network disconnect\n\nWhen Vagrant applies port forwarding rules while bring up a guest instance, other running VMware VMs may experience a loss of network connectivity. The cause of this connectivity issue is the restarting of the VMware NAT service to apply new port forwarding rules. Since new rules cannot be applied to the NAT service while it is running, it is required to restart the service, which results in the loss of connectivity.\n\n## Forwarded Ports Failing in Workstation on Windows\n\nVMware Workstation has a bug on Windows where forwarded ports do not work properly. Vagrant actually works around this bug and makes them work. However, if you run the virtual network editor on Windows, the forwarded ports will suddenly stop working.\n\nIn this case, run `vagrant reload` and things will begin working again.\n\nThis issue has been reported to VMware, but a fix has not been released yet.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vmware/known-issues.html](https://www.vagrantup.com/docs/vmware/known-issues.html)"
- name: Limitations
  id: hyperv/limitations
  summary: The Vagrant Hyper-V provider works in almost every way like the VirtualBox or VMware provider would, but has some limitations that are inherent to Hyper-V itself
  description: "# Limitations\n\nThe Vagrant Hyper-V provider works in almost every way like the VirtualBox or VMware provider would, but has some limitations that are inherent to Hyper-V itself.\n\n## Limited Networking\n\nVagrant does not yet know how to create and configure new networks for Hyper-V. When launching a machine with Hyper-V, Vagrant will prompt you asking what virtual switch you want to connect the virtual machine to.\n\nA result of this is that networking configurations in the Vagrantfile are completely ignored with Hyper-V. Vagrant cannot enforce a static IP or automatically configure a NAT.\n\nHowever, the IP address of the machine will be reported as part of the `vagrant up`, and you can use that IP address as if it were a host only network.\n\n## Snapshots\n\nRestoring snapshot VMs using `vagrant snapshot pop` or `vagrant snapshot restore` will sometimes raise errors when mounting SMB shared folders, however these mounts will still work inside the guest.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/hyperv/limitations.html](https://www.vagrantup.com/docs/hyperv/limitations.html)"
- name: Local Exec Strategy
  id: push/local-exec
  summary: The Vagrant Push Local Exec strategy allows the user to invoke an arbitrary shell command or script as part of a push
  description: "# Vagrant Push\n\n## Local Exec Strategy\n\nThe Vagrant Push Local Exec strategy allows the user to invoke an arbitrary shell command or script as part of a push.\n\n> **Warning:** The Vagrant Push Local Exec strategy does not perform any validation on the correctness of the shell script.\n\nThe Vagrant Push Local Exec strategy supports the following configuration options:\n\n- [`script`](#script) - The path to a script on disk (relative to the `Vagrantfile`) to execute. Vagrant will attempt to convert this script to an executable, but an exception will be raised if that fails.\n- [`inline`](#inline) - The inline script to execute (as a string).\n- [`args`](#args) (string or array) - Optional arguments to pass to the shell script when executing it as a single string. These arguments must be written as if they were typed directly on the command line, so be sure to escape characters, quote, etc. as needed. You may also pass the arguments in using an array. In this case, Vagrant will handle quoting for you.\n\nPlease note - only one of the `script` and `inline` options may be specified in a single push definition.\n\n### Usage\n\nThe Vagrant Push Local Exec strategy is defined in the `Vagrantfile` using the `local-exec` key:\n\nRemote path:\n\n``` ruby\nconfig.push.define \"local-exec\" do |push|\n  push.inline = <<-SCRIPT\n    scp -r . server:/var/www/website\n  SCRIPT\nend\n```\n\nLocal path:\n\n``` ruby\nconfig.push.define \"local-exec\" do |push|\n  push.inline = <<-SCRIPT\n    cp -r . /var/www/website\n  SCRIPT\nend\n```\n\nFor more complicated scripts, you may store them in a separate file and read them from the `Vagrantfile` like so:\n\n``` ruby\nconfig.push.define \"local-exec\" do |push|\n  push.script = \"my-script.sh\"\nend\n```\n\nAnd then invoke the push with Vagrant:\n\n``` shell\n$ vagrant push\n```\n\n### Script Arguments\n\nRefer to [Shell Provisioner](../provisioning/shell).\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/push/local-exec.html](https://www.vagrantup.com/docs/push/local-exec.html)"
- name: Machine Readable Output
  id: cli/machine-readable
  summary: Every Vagrant command accepts a --machine-readable flag which enables machine readable output mode
  description: "# Machine Readable Output\n\nEvery Vagrant command accepts a `--machine-readable` flag which enables machine readable output mode. In this mode, the output to the terminal is replaced with machine-friendly output.\n\nThis mode makes it easy to programmatically execute Vagrant and read data out of it. This output format is protected by our [backwards compatibility](../installation/backwards-compatibility) policy. Until Vagrant 2.0 is released, however, the machine readable output may change as we determine more use cases for it. But the backwards compatibility promise should make it safe to write client libraries to parse the output format.\n\n> **Advanced topic!** This is an advanced topic for use only if you want to programmatically execute Vagrant. If you are just getting started with Vagrant, you may safely skip this section.\n\n## Work-In-Progress\n\nThe machine-readable output is very new (released as part of Vagrant 1.4). We're still gathering use cases for it and building up the output for each of the commands. It is likely that what you may want to achieve with the machine-readable output is not possible due to missing information.\n\nIn this case, we ask that you please [open an issue](https://github.com/hashicorp/vagrant/issues) requesting that certain information become available. We will most likely add it!\n\n## Format\n\nThe machine readable format is a line-oriented, comma-delimited text format. This makes it extremely easy to parse using standard Unix tools such as awk or grep in addition to full programming languages like Ruby or Python.\n\nThe format is:\n\n``` highlight\ntimestamp,target,type,data...\n```\n\nEach component is explained below:\n\n- **timestamp** is a Unix timestamp in UTC of when the message was printed.\n\n- **target** is the target of the following output. This is empty if the message is related to Vagrant globally. Otherwise, this is generally a machine name so you can relate output to a specific machine when multi-VM is in use.\n\n- **type** is the type of machine-readable message being outputted. There are a set of standard types which are covered later.\n\n- **data** is zero or more comma-separated values associated with the prior type. The exact amount and meaning of this data is type-dependent, so you must read the documentation associated with the type to understand fully.\n\nWithin the format, if data contains a comma, it is replaced with `%!(VAGRANT_COMMA)`. This was preferred over an escape character such as \\\\ because it is more friendly to tools like awk.\n\nNewlines within the format are replaced with their respective standard escape sequence. Newlines become a literal `\\n` within the output. Carriage returns become a literal `\\r`.\n\n## Types\n\nThis section documents all the available types that may be outputted with the machine-readable output.\n\n| Type              | Description                                                                                                                        |\n|-------------------|------------------------------------------------------------------------------------------------------------------------------------|\n| box-name          | Name of a box installed into Vagrant.                                                                                              |\n| box-provider      | Provider for an installed box.                                                                                                     |\n| cli-command       | A subcommand of `vagrant` that is available.                                                                                       |\n| error-exit        | An error occurred that caused Vagrant to exit. This contains that error. Contains two data elements: type of error, error message. |\n| provider-name     | The provider name of the target machine. targeted                                                                                  |\n| ssh-config        | The OpenSSH compatible SSH config for a machine. This is usually the result of the \"ssh-config\" command. targeted                  |\n| state             | The state ID of the target machine. targeted                                                                                       |\n| state-human-long  | Human-readable description of the state of the machine. This is the long version, and may be a paragraph or longer. targeted       |\n| state-human-short | Human-readable description of the state of the machine. This is the short version, limited to at most a sentence. targeted         |\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/machine-readable.html](https://www.vagrantup.com/docs/cli/machine-readable.html)"
- name: Machine Settings
  id: vagrantfile/machine_settings
  summary: The settings within config.vm modify the configuration of the machine that Vagrant manages
  description: "# Machine Settings\n\n**Config namespace: `config.vm`**\n\nThe settings within `config.vm` modify the configuration of the machine that Vagrant manages.\n\n## Available Settings\n\n- [`config.vm.base_mac`](#config-vm-base_mac) (string) - The MAC address to be assigned to the default NAT interface on the guest. *Support for this option is provider dependent.*\n\n- [`config.vm.base_address`](#config-vm-base_address) (string) - The IP address to be assigned to the default NAT interface on the guest. *Support for this option is provider dependent.*\n\n- [`config.vm.boot_timeout`](#config-vm-boot_timeout) (integer) - The time in seconds that Vagrant will wait for the machine to boot and be accessible. By default this is 300 seconds.\n\n- [`config.vm.box`](#config-vm-box) (string) - This configures what [box](../boxes) the machine will be brought up against. The value here should be the name of an installed box or a shorthand name of a box in [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud).\n\n- [`config.vm.box_check_update`](#config-vm-box_check_update) (boolean) - If true, Vagrant will check for updates to the configured box on every `vagrant up`. If an update is found, Vagrant will tell the user. By default this is true. Updates will only be checked for boxes that properly support updates (boxes from [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud) or some other versioned box).\n\n- [`config.vm.box_download_checksum`](#config-vm-box_download_checksum) (string) - The checksum of the box specified by `config.vm.box_url`. If not specified, no checksum comparison will be done. If specified, Vagrant will compare the checksum of the downloaded box to this value and error if they do not match. Checksum checking is only done when Vagrant must download the box. If this is specified, then `config.vm.box_download_checksum_type` must also be specified.\n\n- [`config.vm.box_download_checksum_type`](#config-vm-box_download_checksum_type) (string) - The type of checksum specified by `config.vm.box_download_checksum` (if any). Supported values are currently \"md5\", \"sha1\", and \"sha256\".\n\n- [`config.vm.box_download_client_cert`](#config-vm-box_download_client_cert) (string) - Path to a client certificate to use when downloading the box, if it is necessary. By default, no client certificate is used to download the box.\n\n- [`config.vm.box_download_ca_cert`](#config-vm-box_download_ca_cert) (string) - Path to a CA cert bundle to use when downloading a box directly. By default, Vagrant will use the Mozilla CA cert bundle.\n\n- [`config.vm.box_download_ca_path`](#config-vm-box_download_ca_path) (string) - Path to a directory containing CA certificates for downloading a box directly. By default, Vagrant will use the Mozilla CA cert bundle.\n\n- [`config.vm.box_download_insecure`](#config-vm-box_download_insecure) (boolean) - If true, then SSL certificates from the server will not be verified. By default, if the URL is an HTTPS URL, then SSL certs will be verified.\n\n- [`config.vm.box_download_location_trusted`](#config-vm-box_download_location_trusted) (boolean) - If true, then all HTTP redirects will be treated as trusted. That means credentials used for initial URL will be used for all subsequent redirects. By default, redirect locations are untrusted so credentials (if specified) used only for initial HTTP request.\n\n- [`config.vm.box_url`](#config-vm-box_url) (string, array of strings) - The URL that the configured box can be found at. If `config.vm.box` is a shorthand to a box in [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud) then this value does not need to be specified. Otherwise, it should point to the proper place where the box can be found if it is not installed. This can also be an array of multiple URLs. The URLs will be tried in order.\n\n  Note that any client certificates, insecure download settings, and so on will apply to all URLs in this list. The URLs can also be local files by using the `file://` scheme. For example: \"file:///tmp/test.box\".\n\n- [`config.vm.box_version`](#config-vm-box_version) (string) - The version of the box to use. This defaults to \"\\>= 0\" (the latest version available). This can contain an arbitrary list of constraints, separated by commas, such as: `>= 1.0, < 1.5`. When constraints are given, Vagrant will use the latest available box satisfying these constraints.\n\n- [`config.vm.communicator`](#config-vm-communicator) (string) - The communicator type to use to connect to the guest box. By default this is `\"ssh\"`, but should be changed to `\"winrm\"` for Windows guests.\n\n- [`config.vm.graceful_halt_timeout`](#config-vm-graceful_halt_timeout) (integer) - The time in seconds that Vagrant will wait for the machine to gracefully halt when `vagrant halt` is called. Defaults to 60 seconds.\n\n- [`config.vm.guest`](#config-vm-guest) (string, symbol) - The guest OS that will be running within this machine. This defaults to `:linux`, and Vagrant will auto-detect the proper distro. However, this should be changed to `:windows` for Windows guests. Vagrant needs to know this information to perform some guest OS-specific things such as mounting folders and configuring networks.\n\n- [`config.vm.hostname`](#config-vm-hostname) (string) - The hostname the machine should have. Defaults to nil. If nil, Vagrant will not manage the hostname. If set to a string, the hostname will be set on boot. If set, Vagrant will update `/etc/hosts` on the guest with the configured hostname.\n\n- [`config.vm.ignore_box_vagrantfile`](#config-vm-ignore_box_vagrantfile) (boolean) - If true, Vagrant will not load the the settings found inside a boxes Vagrantfile, if present. Defaults to `false`.\n\n- [`config.vm.network`](#config-vm-network) - Configures [networks](../networking/index) on the machine. Please see the networking page for more information.\n\n- [`config.vm.post_up_message`](#config-vm-post_up_message) (string) - A message to show after `vagrant up`. This will be shown to the user and is useful for containing instructions such as how to access various components of the development environment.\n\n- [`config.vm.provider`](#config-vm-provider) - Configures [provider-specific configuration](../providers/configuration), which is used to modify settings which are specific to a certain [provider](../providers/index). If the provider you are configuring does not exist or is not setup on the system of the person who runs `vagrant up`, Vagrant will ignore this configuration block. This allows a Vagrantfile that is configured for many providers to be shared among a group of people who may not have all the same providers installed.\n\n- [`config.vm.provision`](#config-vm-provision) - Configures [provisioners](../provisioning/index) on the machine, so that software can be automatically installed and configured when the machine is created. Please see the page on provisioners for more information on how this setting works.\n\n- [`config.vm.synced_folder`](#config-vm-synced_folder) - Configures [synced folders](../synced-folders/index) on the machine, so that folders on your host machine can be synced to and from the guest machine. Please see the page on synced folders for more information on how this setting works.\n\n- [`config.vm.usable_port_range`](#config-vm-usable_port_range) (range) - A range of ports Vagrant can use for handling port collisions and such. Defaults to `2200..2250`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/machine_settings.html](https://www.vagrantup.com/docs/vagrantfile/machine_settings.html)"
- name: Minimum Vagrant Version
  id: vagrantfile/vagrant_version
  summary: A set of Vagrant version requirements can be specified in the Vagrantfile to enforce that people use a specific version of Vagrant with a Vagrantfile
  description: "# Minimum Vagrant Version\n\nA set of Vagrant version requirements can be specified in the Vagrantfile to enforce that people use a specific version of Vagrant with a Vagrantfile. This can help with compatibility issues that may otherwise arise from using a too old or too new Vagrant version with a Vagrantfile.\n\nVagrant version requirements should be specified at the top of a Vagrantfile with the `Vagrant.require_version` helper:\n\n``` ruby\nVagrant.require_version \">= 1.3.5\"\n```\n\nIn the case above, the Vagrantfile will only load if the version loading it is Vagrant 1.3.5 or greater.\n\nMultiple requirements can be specified as well:\n\n``` ruby\nVagrant.require_version \">= 1.3.5\", \"< 1.4.0\"\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/vagrant_version.html](https://www.vagrantup.com/docs/vagrantfile/vagrant_version.html)"
- name: More Commands
  id: cli/non-primary
  summary: In addition to the commands listed in the sidebar and shown in vagrant -h, Vagrant comes with some more commands that are hidden from basic help output
  description: "# More Commands\n\nIn addition to the commands listed in the sidebar and shown in `vagrant -h`, Vagrant comes with some more commands that are hidden from basic help output. These commands are hidden because they're not useful to beginners or they're not commonly used. We call these commands \"non-primary subcommands\".\n\nYou can view all subcommands, including the non-primary subcommands, by running `vagrant list-commands`, which itself is a non-primary subcommand!\n\nNote that while you have to run a special command to list the non-primary subcommands, you do not have to do anything special to actually *run* the non-primary subcommands. They're executed just like any other subcommand: `vagrant COMMAND`.\n\nThe list of non-primary commands is below. Click on any command to learn more about it.\n\n- [docker-exec](../docker/commands)\n- [docker-logs](../docker/commands)\n- [docker-run](../docker/commands)\n- [rsync](rsync)\n- [rsync-auto](rsync-auto)\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/non-primary.html](https://www.vagrantup.com/docs/cli/non-primary.html)"
- name: Multi-Machine
  id: multi-machine
  summary: Vagrant is able to define and control multiple guest machines per Vagrantfile
  description: "# Multi-Machine\n\nVagrant is able to define and control multiple guest machines per Vagrantfile. This is known as a \"multi-machine\" environment.\n\nThese machines are generally able to work together or are somehow associated with each other. Here are some use-cases people are using multi-machine environments for today:\n\n- Accurately modeling a multi-server production topology, such as separating a web and database server.\n- Modeling a distributed system and how they interact with each other.\n- Testing an interface, such as an API to a service component.\n- Disaster-case testing: machines dying, network partitions, slow networks, inconsistent world views, etc.\n\nHistorically, running complex environments such as these was done by flattening them onto a single machine. The problem with that is that it is an inaccurate model of the production setup, which can behave far differently.\n\nUsing the multi-machine feature of Vagrant, these environments can be modeled in the context of a single Vagrant environment without losing any of the benefits of Vagrant.\n\n## Defining Multiple Machines\n\nMultiple machines are defined within the same project [Vagrantfile](vagrantfile/index) using the `config.vm.define` method call. This configuration directive is a little funny, because it creates a Vagrant configuration within a configuration. An example shows this best:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\", inline: \"echo Hello\"\n\n  config.vm.define \"web\" do |web|\n    web.vm.box = \"apache\"\n  end\n\n  config.vm.define \"db\" do |db|\n    db.vm.box = \"mysql\"\n  end\nend\n```\n\nAs you can see, `config.vm.define` takes a block with another variable. This variable, such as `web` above, is the *exact* same as the `config` variable, except any configuration of the inner variable applies only to the machine being defined. Therefore, any configuration on `web` will only affect the `web` machine.\n\nAnd importantly, you can continue to use the `config` object as well. The configuration object is loaded and merged before the machine-specific configuration, just like other Vagrantfiles within the [Vagrantfile load order](vagrantfile/index#load-order).\n\nIf you are familiar with programming, this is similar to how languages have different variable scopes.\n\nWhen using these scopes, order of execution for things such as provisioners becomes important. Vagrant enforces ordering outside-in, in the order listed in the Vagrantfile. For example, with the Vagrantfile below:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision :shell, inline: \"echo A\"\n\n  config.vm.define :testing do |test|\n    test.vm.provision :shell, inline: \"echo B\"\n  end\n\n  config.vm.provision :shell, inline: \"echo C\"\nend\n```\n\nThe provisioners in this case will output \"A\", then \"C\", then \"B\". Notice that \"B\" is last. That is because the ordering is outside-in, in the order of the file.\n\nIf you want to apply a slightly different configuration to multiple machines, see [this tip](vagrantfile/tips#loop-over-vm-definitions).\n\n## Controlling Multiple Machines\n\nThe moment more than one machine is defined within a Vagrantfile, the usage of the various `vagrant` commands changes slightly. The change should be mostly intuitive.\n\nCommands that only make sense to target a single machine, such as `vagrant ssh`, now *require* the name of the machine to control. Using the example above, you would say `vagrant ssh web` or `vagrant ssh db`.\n\nOther commands, such as `vagrant up`, operate on *every* machine by default. So if you ran `vagrant up`, Vagrant would bring up both the web and DB machine. You could also optionally be specific and say `vagrant up web` or `vagrant up db`.\n\nAdditionally, you can specify a regular expression for matching only certain machines. This is useful in some cases where you specify many similar machines, for example if you are testing a distributed service you may have a `leader` machine as well as a `follower0`, `follower1`, `follower2`, etc. If you want to bring up all the followers but not the leader, you can just do `vagrant up /follower[0-9]/`. If Vagrant sees a machine name within forward slashes, it assumes you are using a regular expression.\n\n## Communication Between Machines\n\nIn order to facilitate communication within machines in a multi-machine setup, the various [networking](networking/index) options should be used. In particular, the [private network](networking/private_network) can be used to make a private network between multiple machines and the host.\n\n## Specifying a Primary Machine\n\nYou can also specify a *primary machine*. The primary machine will be the default machine used when a specific machine in a multi-machine environment is not specified.\n\nTo specify a default machine, just mark it primary when defining it. Only one primary machine may be specified.\n\n``` ruby\nconfig.vm.define \"web\", primary: true do |web|\n  # ...\nend\n```\n\n## Autostart Machines\n\nBy default in a multi-machine environment, `vagrant up` will start all of the defined machines. The `autostart` setting allows you to tell Vagrant to *not* start specific machines. Example:\n\n``` ruby\nconfig.vm.define \"web\"\nconfig.vm.define \"db\"\nconfig.vm.define \"db_follower\", autostart: false\n```\n\nWhen running `vagrant up` with the settings above, Vagrant will automatically start the \"web\" and \"db\" machines, but will not start the \"db_follower\" machine. You can manually force the \"db_follower\" machine to start by running `vagrant up db_follower`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/multi-machine](https://www.vagrantup.com/docs/multi-machine)"
- name: Multi-Machine
  id: multi-machine/index
  summary: Vagrant is able to define and control multiple guest machines per Vagrantfile
  description: "# Multi-Machine\n\nVagrant is able to define and control multiple guest machines per Vagrantfile. This is known as a \"multi-machine\" environment.\n\nThese machines are generally able to work together or are somehow associated with each other. Here are some use-cases people are using multi-machine environments for today:\n\n- Accurately modeling a multi-server production topology, such as separating a web and database server.\n- Modeling a distributed system and how they interact with each other.\n- Testing an interface, such as an API to a service component.\n- Disaster-case testing: machines dying, network partitions, slow networks, inconsistent world views, etc.\n\nHistorically, running complex environments such as these was done by flattening them onto a single machine. The problem with that is that it is an inaccurate model of the production setup, which can behave far differently.\n\nUsing the multi-machine feature of Vagrant, these environments can be modeled in the context of a single Vagrant environment without losing any of the benefits of Vagrant.\n\n## Defining Multiple Machines\n\nMultiple machines are defined within the same project [Vagrantfile](../vagrantfile/index) using the `config.vm.define` method call. This configuration directive is a little funny, because it creates a Vagrant configuration within a configuration. An example shows this best:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\", inline: \"echo Hello\"\n\n  config.vm.define \"web\" do |web|\n    web.vm.box = \"apache\"\n  end\n\n  config.vm.define \"db\" do |db|\n    db.vm.box = \"mysql\"\n  end\nend\n```\n\nAs you can see, `config.vm.define` takes a block with another variable. This variable, such as `web` above, is the *exact* same as the `config` variable, except any configuration of the inner variable applies only to the machine being defined. Therefore, any configuration on `web` will only affect the `web` machine.\n\nAnd importantly, you can continue to use the `config` object as well. The configuration object is loaded and merged before the machine-specific configuration, just like other Vagrantfiles within the [Vagrantfile load order](../vagrantfile/index#load-order).\n\nIf you are familiar with programming, this is similar to how languages have different variable scopes.\n\nWhen using these scopes, order of execution for things such as provisioners becomes important. Vagrant enforces ordering outside-in, in the order listed in the Vagrantfile. For example, with the Vagrantfile below:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision :shell, inline: \"echo A\"\n\n  config.vm.define :testing do |test|\n    test.vm.provision :shell, inline: \"echo B\"\n  end\n\n  config.vm.provision :shell, inline: \"echo C\"\nend\n```\n\nThe provisioners in this case will output \"A\", then \"C\", then \"B\". Notice that \"B\" is last. That is because the ordering is outside-in, in the order of the file.\n\nIf you want to apply a slightly different configuration to multiple machines, see [this tip](../vagrantfile/tips#loop-over-vm-definitions).\n\n## Controlling Multiple Machines\n\nThe moment more than one machine is defined within a Vagrantfile, the usage of the various `vagrant` commands changes slightly. The change should be mostly intuitive.\n\nCommands that only make sense to target a single machine, such as `vagrant ssh`, now *require* the name of the machine to control. Using the example above, you would say `vagrant ssh web` or `vagrant ssh db`.\n\nOther commands, such as `vagrant up`, operate on *every* machine by default. So if you ran `vagrant up`, Vagrant would bring up both the web and DB machine. You could also optionally be specific and say `vagrant up web` or `vagrant up db`.\n\nAdditionally, you can specify a regular expression for matching only certain machines. This is useful in some cases where you specify many similar machines, for example if you are testing a distributed service you may have a `leader` machine as well as a `follower0`, `follower1`, `follower2`, etc. If you want to bring up all the followers but not the leader, you can just do `vagrant up /follower[0-9]/`. If Vagrant sees a machine name within forward slashes, it assumes you are using a regular expression.\n\n## Communication Between Machines\n\nIn order to facilitate communication within machines in a multi-machine setup, the various [networking](../networking/index) options should be used. In particular, the [private network](../networking/private_network) can be used to make a private network between multiple machines and the host.\n\n## Specifying a Primary Machine\n\nYou can also specify a *primary machine*. The primary machine will be the default machine used when a specific machine in a multi-machine environment is not specified.\n\nTo specify a default machine, just mark it primary when defining it. Only one primary machine may be specified.\n\n``` ruby\nconfig.vm.define \"web\", primary: true do |web|\n  # ...\nend\n```\n\n## Autostart Machines\n\nBy default in a multi-machine environment, `vagrant up` will start all of the defined machines. The `autostart` setting allows you to tell Vagrant to *not* start specific machines. Example:\n\n``` ruby\nconfig.vm.define \"web\"\nconfig.vm.define \"db\"\nconfig.vm.define \"db_follower\", autostart: false\n```\n\nWhen running `vagrant up` with the settings above, Vagrant will automatically start the \"web\" and \"db\" machines, but will not start the \"db_follower\" machine. You can manually force the \"db_follower\" machine to start by running `vagrant up db_follower`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/multi-machine/](https://www.vagrantup.com/docs/multi-machine/)"
- name: Networking
  id: virtualbox/networking
  summary: The Vagrant VirtualBox provider supports using the private network as a VirtualBox internal network
  description: "# Networking\n\n## VirtualBox Internal Network\n\nThe Vagrant VirtualBox provider supports using the private network as a VirtualBox [internal network](https://www.virtualbox.org/manual/ch06.html#network_internal). By default, private networks are host-only networks, because those are the easiest to work with. However, internal networks can be enabled as well.\n\nTo specify a private network as an internal network for VirtualBox use the `virtualbox__intnet` option with the network. The `virtualbox__` (double underscore) prefix tells Vagrant that this option is only for the VirtualBox provider.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"private_network\", ip: \"192.168.50.4\",\n    virtualbox__intnet: true\nend\n```\n\nAdditionally, if you want to specify that the VirtualBox provider join a specific internal network, specify the name of the internal network:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"private_network\", ip: \"192.168.50.4\",\n    virtualbox__intnet: \"mynetwork\"\nend\n```\n\n## VirtualBox NIC Type\n\nYou can specify a specific NIC type for the created network interface by using the `nic_type` parameter. This is not prefixed by `virtualbox__` for legacy reasons, but is VirtualBox-specific.\n\nThis is an advanced option and should only be used if you know what you are using, since it can cause the network device to not work at all.\n\nExample:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"private_network\", ip: \"192.168.50.4\",\n    nic_type: \"virtio\"\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/virtualbox/networking.html](https://www.vagrantup.com/docs/virtualbox/networking.html)"
- name: Networking
  id: networking/index
  summary: In order to access the Vagrant environment created, Vagrant exposes some high-level networking options for things such as forwarded ports, connecting to a public network, or creating a private network
  description: "# Networking\n\nIn order to access the Vagrant environment created, Vagrant exposes some high-level networking options for things such as forwarded ports, connecting to a public network, or creating a private network.\n\nThe high-level networking options are meant to define an abstraction that works across multiple [providers](../providers/index). This means that you can take your Vagrantfile you used to spin up a VirtualBox machine and you can reasonably expect that Vagrantfile to behave the same with something like VMware.\n\nYou should first read the [basic usage](basic_usage) page and then continue by reading the documentation for a specific networking primitive by following the navigation to the left.\n\n## Advanced Configuration\n\nIn some cases, these options are *too* high-level, and you may want to more finely tune and configure the network interfaces of the underlying machine. Most providers expose [provider-specific configuration](../providers/configuration) to do this, so please read the documentation for your specific provider to see what options are available.\n\n> **For beginners:** It is strongly recommended you use only the high-level networking options until you are comfortable with the Vagrant workflow and have things working at a basic level. Provider-specific network configuration can very quickly lock you out of your guest machine if improperly done.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/networking/](https://www.vagrantup.com/docs/networking/)"
- name: NFS
  id: synced-folders/nfs
  summary: In some cases the default shared folder implementations (such as VirtualBox shared folders) have high performance penalties
  description: "# NFS\n\nIn some cases the default shared folder implementations (such as VirtualBox shared folders) have high performance penalties. If you are seeing less than ideal performance with synced folders, [NFS](https://en.wikipedia.org/wiki/Network_File_System_%28protocol%29) can offer a solution. Vagrant has built-in support to orchestrate the configuration of the NFS server on the host and guest for you.\n\n> **Windows users:** NFS folders do not work on Windows hosts. Vagrant will ignore your request for NFS synced folders on Windows.\n\n## Prerequisites\n\nBefore using synced folders backed by NFS, the host machine must have `nfsd` installed, the NFS server daemon. This comes pre-installed on Mac OS X, and is typically a simple package install on Linux.\n\nAdditionally, the guest machine must have NFS support installed. This is also usually a simple package installation away.\n\nIf you are using the VirtualBox provider, you will also need to make sure you have a [private network set up](../networking/private_network). This is due to a limitation of VirtualBox's built-in networking. With VMware, you do not need this.\n\n## Enabling NFS Synced Folders\n\nTo enable NFS, just add the `type: \"nfs\"` flag onto your synced folder:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.synced_folder \".\", \"/vagrant\", type: \"nfs\"\nend\n```\n\nIf you add this to an existing Vagrantfile that has a running guest machine, be sure to `vagrant reload` to see your changes.\n\n## NFS Synced Folder Options\n\nNFS synced folders have a set of options that can be specified that are unique to NFS. These are listed below. These options can be specified in the final part of the `config.vm.synced_folder` definition, along with the `type` option.\n\n- [`nfs_export`](#nfs_export) (boolean) - If this is false, then Vagrant will not modify your `/etc/exports` automatically and assumes you've done so already.\n\n- [`nfs_udp`](#nfs_udp) (boolean) - Whether or not to use UDP as the transport. UDP is faster but has some limitations (see the NFS documentation for more details). This defaults to true.\n\n- [`nfs_version`](#nfs_version) (string \\| integer) - The NFS protocol version to use when mounting the folder on the guest. This defaults to 3.\n\n## NFS Global Options\n\nThere are also more global NFS options you can set with `config.nfs` in the Vagrantfile. These are documented below:\n\n- [`functional`](#functional) (bool) - Defaults to true. If false, then NFS will not be used as a synced folder type. If a synced folder specifically requests NFS, it will error.\n\n- [`map_uid`](#map_uid) and `map_gid` (int) - The UID/GID, respectively, to map all read/write requests too. This will not affect the owner/group within the guest machine itself, but any writes will behave as if they were written as this UID/GID on the host. This defaults to the current user running Vagrant.\n\n- [`verify_installed`](#verify_installed) (bool) - Defaults to true. If this is false, then Vagrant will skip checking if NFS is installed.\n\n## Specifying NFS Arguments\n\nIn addition to the options specified above, it is possible for Vagrant to specify alternate NFS arguments when mounting the NFS share by using the `mount_options` key. For example, to use the `actimeo=2` client mount option:\n\n``` ruby\nconfig.vm.synced_folder \".\", \"/vagrant\",\n  type: \"nfs\",\n  mount_options: ['actimeo=2']\n```\n\nThis would result in the following `mount` command being executed on the guest:\n\n``` highlight\nmount -o 'actimeo=2' 172.28.128.1:'/path/to/vagrantfile' /vagrant\n```\n\nYou can also tweak the arguments specified in the `/etc/exports` template when the mount is added, by using the OS-specific `linux__nfs_options` or `bsd__nfs_options` keys. Note that these options completely override the default arguments that are added by Vagrant automatically. For example, to make the NFS share asynchronous:\n\n``` ruby\nconfig.vm.synced_folder \".\", \"/vagrant\",\n  type: \"nfs\",\n  linux__nfs_options: ['rw','no_subtree_check','all_squash','async']\n```\n\nThis would result in the following content in `/etc/exports` on the host (note the added `async` flag):\n\n``` highlight\n# VAGRANT-BEGIN: 21171 5b8f0135-9e73-4166-9bfd-ac43d5f14261\n\"/path/to/vagrantfile\" 172.28.128.5(rw,no_subtree_check,all_squash,async,anonuid=21171,anongid=660,fsid=3382034405)\n# VAGRANT-END: 21171 5b8f0135-9e73-4166-9bfd-ac43d5f14261\n```\n\n## Root Privilege Requirement\n\nTo configure NFS, Vagrant must modify system files on the host. Therefore, at some point during the `vagrant up` sequence, you may be prompted for administrative privileges (via the typical `sudo` program). These privileges are used to modify `/etc/exports` as well as to start and stop the NFS server daemon.\n\nIf you do not want to type your password on every `vagrant up`, Vagrant uses thoughtfully crafted commands to make fine-grained sudoers modifications possible to avoid entering your password.\n\nBelow, we have a couple example sudoers entries. Note that you may have to modify them *slightly* on certain hosts because the way Vagrant modifies `/etc/exports` changes a bit from OS to OS. If the commands below are located in non-standard paths, modify them as appropriate.\n\nFor \\*nix users, make sure to edit your `/etc/sudoers` file with `visudo`. It protects you against syntax errors which could leave you without the ability to gain elevated privileges.\n\nAll of the snippets below require Vagrant version 1.7.3 or higher.\n\n> **Use the appropriate group for your user** Depending on how your machine is configured, you might need to use a different group than the ones listed in the examples below.\n\nFor OS X, sudoers should have this entry:\n\n``` highlight\nCmnd_Alias VAGRANT_EXPORTS_ADD = /usr/bin/tee -a /etc/exports\nCmnd_Alias VAGRANT_NFSD = /sbin/nfsd restart\nCmnd_Alias VAGRANT_EXPORTS_REMOVE = /usr/bin/sed -E -e /*/ d -ibak /etc/exports\n%admin ALL=(root) NOPASSWD: VAGRANT_EXPORTS_ADD, VAGRANT_NFSD, VAGRANT_EXPORTS_REMOVE\n```\n\nFor Ubuntu Linux , sudoers should look like this:\n\n``` highlight\nCmnd_Alias VAGRANT_EXPORTS_CHOWN = /bin/chown 0\\:0 /tmp/*\nCmnd_Alias VAGRANT_EXPORTS_MV = /bin/mv -f /tmp/* /etc/exports\nCmnd_Alias VAGRANT_NFSD_CHECK = /etc/init.d/nfs-kernel-server status\nCmnd_Alias VAGRANT_NFSD_START = /etc/init.d/nfs-kernel-server start\nCmnd_Alias VAGRANT_NFSD_APPLY = /usr/sbin/exportfs -ar\n%sudo ALL=(root) NOPASSWD: VAGRANT_EXPORTS_CHOWN, VAGRANT_EXPORTS_MV, VAGRANT_NFSD_CHECK, VAGRANT_NFSD_START, VAGRANT_NFSD_APPLY\n```\n\nFor Fedora Linux, sudoers might look like this (given your user belongs to the vagrant group):\n\n``` highlight\nCmnd_Alias VAGRANT_EXPORTS_CHOWN = /bin/chown 0\\:0 /tmp/*\nCmnd_Alias VAGRANT_EXPORTS_MV = /bin/mv -f /tmp/* /etc/exports\nCmnd_Alias VAGRANT_NFSD_CHECK = /usr/bin/systemctl status --no-pager nfs-server.service\nCmnd_Alias VAGRANT_NFSD_START = /usr/bin/systemctl start nfs-server.service\nCmnd_Alias VAGRANT_NFSD_APPLY = /usr/sbin/exportfs -ar\n%vagrant ALL=(root) NOPASSWD: VAGRANT_EXPORTS_CHOWN, VAGRANT_EXPORTS_MV, VAGRANT_NFSD_CHECK, VAGRANT_NFSD_START, VAGRANT_NFSD_APPLY\n```\n\nIf you don't want to edit `/etc/sudoers` directly, you can create `/etc/sudoers.d/vagrant-syncedfolders` with the appropriate entries, assuming `/etc/sudoers.d` has been enabled.\n\n## Other Notes\n\n**Encrypted folders:** If you have an encrypted disk, then NFS very often will refuse to export the filesystem. The error message given by NFS is often not clear. One error message seen is `<path> does not support NFS`. There is no workaround for this other than sharing a directory which is not encrypted.\n\n**Version 4:** UDP is generally not a valid transport protocol for NFSv4. Early implementations of NFS 4.0 still allowed UDP which allows the UDP transport protocol to be used in rare cases. RFC5661 explicitly states UDP alone should not be used for the transport protocol in NFS 4.1. Errors due to unsupported transport protocols for specific versions of NFS are not always clear. A common error message when attempting to use UDP with NFSv4:\n\n``` highlight\nmount.nfs: an incorrect mount option was specified\n```\n\nWhen using NFSv4, ensure the `nfs_udp` option is set to false. For example:\n\n``` ruby\nconfig.vm.synced_folder \".\", \"/vagrant\",\n  type: \"nfs\",\n  nfs_version: 4,\n  nfs_udp: false\n```\n\nFor more information about transport protocols and NFS version 4 see:\n\n- NFSv4.0 - [RFC7530](https://tools.ietf.org/html/rfc7530#section-3.1)\n- NFSv4.1 - [RFC5661](https://tools.ietf.org/html/rfc5661#section-2.9.1)\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/synced-folders/nfs.html](https://www.vagrantup.com/docs/synced-folders/nfs.html)"
- name: Other
  id: other/index
  summary: This section covers other information that does not quite fit under the other categories
  description: "# Other\n\nThis section covers other information that does not quite fit under the other categories.\n\n- [Debugging](debugging)\n- [Environment Variables](environmental-variables)\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/other/](https://www.vagrantup.com/docs/other/)"
- name: Plugin Development Basics
  id: plugins/development-basics
  summary: Plugins are a great way to augment or change the behavior and functionality of Vagrant
  description: "# Plugin Development Basics\n\nPlugins are a great way to augment or change the behavior and functionality of Vagrant. Since plugins introduce additional external dependencies for users, they should be used as a last resort when attempting to do something with Vagrant.\n\nBut if you need to introduce custom behaviors into Vagrant, plugins are the best way, since they are safe against future upgrades and use a stable API.\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\nPlugins are written using [Ruby](https://www.ruby-lang.org/en/) and are packaged using [RubyGems](https://rubygems.org/). Familiarity with Ruby is required, but the [packaging and distribution](packaging) section should help guide you to packaging your plugin into a RubyGem.\n\n## Setup and Workflow\n\nBecause plugins are packaged as RubyGems, Vagrant plugins should be developed as if you were developing a regular RubyGem. The easiest way to do this is to use the `bundle gem` command.\n\nOnce the directory structure for a RubyGem is setup, you will want to modify your Gemfile. Here is the basic structure of a Gemfile for Vagrant plugin development:\n\n``` ruby\nsource \"https://rubygems.org\"\n\ngroup :development do\n  gem \"vagrant\", git: \"https://github.com/hashicorp/vagrant.git\"\nend\n\ngroup :plugins do\n  gem \"my-vagrant-plugin\", path: \".\"\nend\n```\n\nThis Gemfile gets \"vagrant\" for development. This allows you to `bundle exec vagrant` to run Vagrant with your plugin already loaded, so that you can test it manually that way.\n\nThe only thing about this Gemfile that may stand out as odd is the \"plugins\" group and putting your plugin in that group. Because `vagrant plugin` commands do not work in development, this is how you \"install\" your plugin into Vagrant. Vagrant will automatically load any gems listed in the \"plugins\" group. Note that this also allows you to add multiple plugins to Vagrant for development, if your plugin works with another plugin.\n\nWhen you want to manually test your plugin, use `bundle exec vagrant` in order to run Vagrant with your plugin loaded (as we specified in the Gemfile).\n\n## Plugin Definition\n\nAll plugins are required to have a definition. A definition contains details about the plugin such as the name of it and what components it contains.\n\nA definition at the bare minimum looks like the following:\n\n``` ruby\nclass MyPlugin < Vagrant.plugin(\"2\")\n  name \"My Plugin\"\nend\n```\n\nA definition is a class that inherits from `Vagrant.plugin(\"2\")`. The \"2\" there is the version that the plugin is valid for. API stability is only promised for each major version of Vagrant, so this is important. (The 1.x series is working towards 2.0, so the API version is \"2\")\n\n**The most critical feature of a plugin definition** is that it must *always* load, no matter what version of Vagrant is running. Theoretically, Vagrant version 87 (does not actually exist) would be able to load a version 2 plugin definition. This is achieved through clever lazy loading of individual components of the plugin, and is covered shortly.\n\n## Plugin Components\n\nWithin the definition, a plugin advertises what components it adds to Vagrant. An example is shown below where a command and provisioner are added:\n\n``` ruby\nclass MyPlugin < Vagrant.plugin(\"2\")\n  name \"My Plugin\"\n\n  command \"run-my-plugin\" do\n    require_relative \"command\"\n    Command\n  end\n\n  provisioner \"my-provisioner\" do\n    require_relative \"provisioner\"\n    Provisioner\n  end\nend\n```\n\nLet us go over the major pieces of what is going on here. Note from a general Ruby language perspective the above *should* be familiar. The syntax should not scare you. If it does, then please familiarize with Ruby further before attempting to write a plugin.\n\nThe first thing to note is that individual components are defined by making a method call with the component name, such as `command` or `provisioner`. These in turn take some parameters. In the case of our example it is just the name of the command and the name of the provisioner. All component definitions then take a block argument (a callback) that must return the actual component implementation class.\n\nThe block argument is where the \"clever lazy loading\" (mentioned above) comes into play. The component blocks should lazy load the actual file that contains the implementation of the component, and then return that component.\n\nThis is done because the actual dependencies and APIs used when defining components are not stable across major Vagrant versions. A command implementation written for Vagrant 2.0 will not be compatible with Vagrant 3.0 and so on. But the *definition* is just plain Ruby that must always be forward compatible to future Vagrant versions.\n\nTo repeat, **the lazy loading aspect of plugin components is critical** to the way Vagrant plugins work. All components must be lazily loaded and returned within their definition blocks.\n\nNow, each component has a different API. Please visit the relevant section using the navigation to the left under \"Plugins\" to learn more about developing each type of component.\n\n## Error Handling\n\nOne of Vagrant's biggest strength is gracefully handling errors and reporting them in human-readable ways. Vagrant has always strongly believed that if a user sees a stack trace, it is a bug. It is expected that plugins will behave the same way, and Vagrant provides strong error handling mechanisms to assist with this.\n\nError handling in Vagrant is done entirely by raising Ruby exceptions. But Vagrant treats certain errors differently than others. If an error is raised that inherits from `Vagrant::Errors::VagrantError`, then the `vagrant` command will output the message of the error in nice red text to the console and exit with an exit status of 1.\n\nOtherwise, Vagrant reports an \"unexpected error\" that should be reported as a bug, and shows a full stack trace and other ugliness. Any stack traces should be considered bugs.\n\nTherefore, to fit into Vagrant's error handling mechanisms, subclass `VagrantError` and set a proper message on your exception. To see examples of this, look at Vagrant's [built-in errors](https://github.com/hashicorp/vagrant/blob/master/lib/vagrant/errors.rb).\n\n## Console Input and Output\n\nMost plugins are likely going to want to do some sort of input/output. Plugins should *never* use Ruby's built-in `puts` or `gets` style methods. Instead, all input/output should go through some sort of Vagrant UI object. The Vagrant UI object properly handles cases where there is no TTY, output pipes are closed, there is no input pipe, etc.\n\nA UI object is available on every `Vagrant::Environment` via the `ui` property and is exposed within every middleware environment via the `:ui` key. UI objects have [decent documentation](https://github.com/hashicorp/vagrant/blob/master/lib/vagrant/ui.rb) within the comments of their source.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/development-basics.html](https://www.vagrantup.com/docs/plugins/development-basics.html)"
- name: 'Plugin Development: Commands'
  id: plugins/commands
  summary: This page documents how to add new commands to Vagrant, invocable via vagrant YOUR-COMMAND
  description: "# Plugin Development: Commands\n\nThis page documents how to add new commands to Vagrant, invocable via `vagrant YOUR-COMMAND`. Prior to reading this, you should be familiar with the [plugin development basics](development-basics).\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\n## Definition Component\n\nWithin the context of a plugin definition, new commands can be defined like so:\n\n``` ruby\ncommand \"foo\" do\n  require_relative \"command\"\n  Command\nend\n```\n\nCommands are defined with the `command` method, which takes as an argument the name of the command, in this case \"foo.\" This means the command will be invocable via `vagrant foo`. Then the block argument returns a class that implements the `Vagrant.plugin(2, \"command\")` interface.\n\nYou can also define *non-primary commands*. These commands do not show up in the `vagrant -h` output. They only show up if the user explicitly does a `vagrant list-commands` which shows the full listing of available commands. This is useful for highly specific commands or plugins that a beginner to Vagrant would not be using anyways. Vagrant itself uses non-primary commands to expose some internal functions, as well.\n\nTo define a non-primary command:\n\n``` ruby\ncommand(\"foo\", primary: false) do\n  require_relative \"command\"\n  Command\nend\n```\n\n## Implementation\n\nImplementations of commands should subclass `Vagrant.plugin(2, :command)`, which is a Vagrant method that will return the proper superclass for a version 2 command. The implementation itself is quite simple, since the class needs to only implement a single method: `execute`. Example:\n\n``` ruby\nclass Command < Vagrant.plugin(2, :command)\n  def execute\n    puts \"Hello!\"\n    0\n  end\nend\n```\n\nThe `execute` method is called when the command is invoked, and it should return the exit status (0 for success, anything else for error).\n\nThis is a command at its simplest form. Of course, the command superclass gives you access to the Vagrant environment and provides some helpers to do common tasks such as command line parsing.\n\n## Parsing Command-Line Options\n\nThe `parse_options` method is available which will parse the command line for you. It takes an [OptionParser](http://ruby-doc.org/stdlib-1.9.3/libdoc/optparse/rdoc/OptionParser.html) as an argument, and adds some common elements to it such as the `--help` flag, automatically showing help if requested. View the API docs directly for more information.\n\nThis is recommended over raw parsing/manipulation of command line flags. The following is an example of parsing command line flags pulled directly from the built-in Vagrant `destroy` command:\n\n``` ruby\noptions = {}\noptions[:force] = false\n\nopts = OptionParser.new do |o|\n  o.banner = \"Usage: vagrant destroy [vm-name]\"\n  o.separator \"\"\n\n  o.on(\"-f\", \"--force\", \"Destroy without confirmation.\") do |f|\n    options[:force] = f\n  end\nend\n\n# Parse the options\nargv = parse_options(opts)\n```\n\n## Using Vagrant Machines\n\nThe `with_target_vms` method is a helper that helps you interact with the machines that Vagrant manages in a standard Vagrant way. This method automatically does the right thing in the case of multi-machine environments, handling target machines on the command line (`vagrant foo my-vm`), etc. If you need to do any manipulation of a Vagrant machine, including SSH access, this helper should be used.\n\nAn example of using the helper, again pulled directly from the built-in `destroy` command:\n\n``` ruby\nwith_target_vms(argv, reverse: true) do |machine|\n  machine.action(:destroy)\nend\n```\n\nIn this case, it asks for the machines in reverse order and calls the destroy action on each of them. If a user says `vagrant destroy foo`, then the helper automatically only yields the `foo` machine. If no parameter is given and it is a multi-machine environment, every machine in the environment is yielded, and so on. It just does the right thing.\n\n## Using the Raw Vagrant Environment\n\nThe raw loaded `Vagrant::Environment` object is available with the '@env' instance variable.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/commands.html](https://www.vagrantup.com/docs/plugins/commands.html)"
- name: 'Plugin Development: Configuration'
  id: plugins/configuration
  summary: This page documents how to add new configuration options to Vagrant, settable with config.YOURKEY in Vagrantfiles
  description: "# Plugin Development: Configuration\n\nThis page documents how to add new configuration options to Vagrant, settable with `config.YOURKEY` in Vagrantfiles. Prior to reading this, you should be familiar with the [plugin development basics](development-basics).\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\n## Definition Component\n\nWithin the context of a plugin definition, new configuration keys can be defined like so:\n\n``` ruby\nconfig \"foo\" do\n  require_relative \"config\"\n  Config\nend\n```\n\nConfiguration keys are defined with the `config` method, which takes as an argument the name of the configuration variable as the argument. This means that the configuration object will be accessible via `config.foo` in Vagrantfiles. Then, the block argument returns a class that implements the `Vagrant.plugin(2, :config)` interface.\n\n## Implementation\n\nImplementations of configuration keys should subclass `Vagrant.plugin(2, :config)`, which is a Vagrant method that will return the proper subclass for a version 2 configuration section. The implementation is very simple, and acts mostly as a plain Ruby object. Here is an example:\n\n``` ruby\nclass Config < Vagrant.plugin(2, :config)\n  attr_accessor :widgets\n\n  def initialize\n    @widgets = UNSET_VALUE\n  end\n\n  def finalize!\n    @widgets = 0 if @widgets == UNSET_VALUE\n  end\nend\n```\n\nWhen using this configuration class, it looks like the following:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  # ...\n\n  config.foo.widgets = 12\nend\n```\n\nEasy. The only odd thing is the `UNSET_VALUE` bits above. This is actually so that Vagrant can properly automatically merge multiple configurations. Merging is covered in the next section, and `UNSET_VALUE` will be explained there.\n\n## Merging\n\nVagrant works by loading [multiple Vagrantfiles and merging them](../vagrantfile/index#load-order). This merge logic is built-in to configuration classes. When merging two configuration objects, we will call them \"old\" and \"new\", it'll by default take all the instance variables defined on \"new\" that are not `UNSET_VALUE` and set them onto the merged result.\n\nThe reason `UNSET_VALUE` is used instead of Ruby's `nil` is because it is possible that you want the default to be some value, and the user actually wants to set the value to `nil`, and it is impossible for Vagrant to automatically determine whether the user set the instance variable, or if it was defaulted as nil.\n\nThis merge logic is what you want almost every time. Hence, in the example above, `@widgets` is set to `UNSET_VALUE`. If we had two Vagrant configuration objects in the same file, then Vagrant would properly merge the follows. The example below shows this:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.widgets = 1\nend\n\nVagrant.configure(\"2\") do |config|\n  # ... other stuff\nend\n\nVagrant.configure(\"2\") do |config|\n  config.widgets = 2\nend\n```\n\nIf this were placed in a Vagrantfile, after merging, the value of widgets would be \"2\".\n\nThe `finalize!` method is called only once ever on the final configuration object in order to set defaults. If `finalize!` is called, that configuration will never be merged again, it is final. This lets you detect any `UNSET_VALUE` and set the proper default, as we do in the above example.\n\nOf course, sometimes you want custom merge logic. Let us say we wanted our widgets to be additive. We can override the `merge` method to do this:\n\n``` ruby\nclass Config < Vagrant.config(\"2\", :config)\n  attr_accessor :widgets\n\n  def initialize\n    @widgets = 0\n  end\n\n  def merge(other)\n    super.tap do |result|\n      result.widgets = @widgets + other.widgets\n    end\n  end\nend\n```\n\nIn this case, we did not use `UNSET_VALUE` for widgets because we did not need that behavior. We default to 0 and always merge by summing the two widgets. Now, if we ran the example above that had the 3 configuration blocks, the final value of widgets would be \"3\".\n\n## Validation\n\nConfiguration classes are also responsible for validating their own values. Vagrant will call the `validate` method to do this. An example validation method is shown below:\n\n``` ruby\nclass Config < Vagrant.plugin(\"2\", :config)\n  # ...\n\n  def validate(machine)\n    errors = _detected_errors\n    if @widgets <= 5\n      errors << \"widgets must be greater than 5\"\n    end\n\n    { \"foo\" => errors }\n  end\nend\n```\n\nThe validation method is given a `machine` object, since validation is done for each machine that Vagrant is managing. This allows you to conditionally validate some keys based on the state of the machine and so on.\n\nThe `_detected_errors` method returns any errors already detected by Vagrant, such as unknown configuration keys. This returns an array of error messages, so be sure to turn it into the proper Hash object to return later.\n\nThe return value is a Ruby Hash object, where the key is a section name, and the value is a list of error messages. These will be displayed by Vagrant. The hash must not contain any values if there are no errors.\n\n## Accessing\n\nAfter all the configuration options are merged and finalized, you will likely want to access the finalized value in your plugin. The initializer function varies with each type of plugin, but *most* plugins expose an initializer like this:\n\n``` ruby\ndef initialize(machine, config)\n  @machine = machine\n  @config  = config\nend\n```\n\nWhen authoring a plugin, simply call `super` in your initialize function to setup these instance variables:\n\n``` ruby\ndef initialize(*)\n  super\n\n  @config.is_now_available\n  # ...existing code\nend\n\ndef my_helper\n  @config.is_here_too\nend\n```\n\nFor examples, take a look at Vagrant's own internal plugins in the `plugins` folder in Vagrant's source on GitHub.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/configuration.html](https://www.vagrantup.com/docs/plugins/configuration.html)"
- name: 'Plugin Development: Guest Capabilities'
  id: plugins/guest-capabilities
  summary: This page documents how to add new capabilities for guests to Vagrant, allowing Vagrant to perform new actions on specific guest operating systems
  description: "# Plugin Development: Guest Capabilities\n\nThis page documents how to add new capabilities for [guests](guests) to Vagrant, allowing Vagrant to perform new actions on specific guest operating systems. Prior to reading this, you should be familiar with the [plugin development basics](development-basics).\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\nGuest capabilities augment [guests](guests) by attaching specific \"capabilities\" to the guest, which are actions that can be performed in the context of that guest operating system.\n\nThe power of capabilities is that plugins can add new capabilities to existing guest operating systems without modifying the core of Vagrant. In earlier versions of Vagrant, all the guest logic was contained in the core of Vagrant and was not easily augmented.\n\n## Definition Component\n\nWithin the context of a plugin definition, guest capabilities can be defined like so:\n\n``` ruby\nguest_capability \"ubuntu\", \"my_custom_capability\" do\n  require_relative \"cap/my_custom_capability\"\n  Cap::MyCustomCapability\nend\n```\n\nGuest capabilities are defined by calling the `guest_capability` method, which takes two parameters: the guest to add the capability to, and the name of the capability itself. Then, the block argument returns a class that implements a method named the same as the capability. This is covered in more detail in the next section.\n\n## Implementation\n\nImplementations should be classes or modules that have a method with the same name as the capability. The method must be immediately accessible on the class returned from the `guest_capability` component, meaning that if it is an instance method, an instance should be returned.\n\nIn general, class methods are used for capabilities. For example, here is the implementation for the capability above:\n\n``` ruby\nmodule Cap\n  class MyCustomCapability\n    def self.my_custom_capability(machine)\n      # implementation\n    end\n  end\nend\n```\n\nAll capabilities get the Vagrant machine object as the first argument. Additional arguments are determined by the specific capability, so view the documentation or usage of the capability you are trying to implement for more information.\n\nSome capabilities must also return values back to the caller, so be aware of that when implementing a capability.\n\nCapabilities always have access to communication channels such as SSH on the machine, and the machine can generally be assumed to be booted.\n\n## Calling Capabilities\n\nSince you have access to the machine in every capability, capabilities can also call *other* capabilities. This is useful for using the inheritance mechanism of capabilities to potentially ask helpers for more information. For example, the \"redhat\" guest has a \"network_scripts_dir\" capability that simply returns the directory where networking scripts go.\n\nCapabilities on child guests of RedHat such as CentOS or Fedora use this capability to determine where networking scripts go, while sometimes overriding it themselves.\n\nCapabilities can be called like so:\n\n``` ruby\nmachine.guest.capability(:capability_name)\n```\n\nAny additional arguments given to the method will be passed on to the capability, and the capability will return the value that the actual capability returned.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/guest-capabilities.html](https://www.vagrantup.com/docs/plugins/guest-capabilities.html)"
- name: 'Plugin Development: Guests'
  id: plugins/guests
  summary: This page documents how to add new guest OS detection to Vagrant, allowing Vagrant to properly configure new operating systems
  description: "# Plugin Development: Guests\n\nThis page documents how to add new guest OS detection to Vagrant, allowing Vagrant to properly configure new operating systems. Prior to reading this, you should be familiar with the [plugin development basics](development-basics).\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\nVagrant has many features that requires doing guest OS-specific actions, such as mounting folders, configuring networks, etc. These tasks vary from operating system to operating system. If you find that one of these does not work for your operating system, then maybe the guest implementation is incomplete or incorrect.\n\n## Definition Component\n\nWithin the context of a plugin definition, new guests can be defined like so:\n\n``` ruby\nguest \"ubuntu\" do\n  require_relative \"guest\"\n  Guest\nend\n```\n\nGuests are defined with the `guest` method. The first argument is the name of the guest. This name is not actually used anywhere, but may in the future, so choose something helpful. Then, the block argument returns a class that implements the `Vagrant.plugin(2, :guest)` interface.\n\n## Implementation\n\nImplementations of guests subclass `Vagrant.plugin(\"2\", \"guest\")`. Within this implementation, only the `detect?` method needs to be implemented.\n\nThe `detect?` method is called by Vagrant at some point after the machine is booted in order to determine what operating system the guest is running. If you detect that it is your operating system, return `true` from `detect?`. Otherwise, return `false`.\n\nCommunication channels to the machine are guaranteed to be running at this point, so the most common way to detect the operating system is to do some basic testing:\n\n``` ruby\nclass MyGuest < Vagrant.plugin(\"2\", \"guest\")\n  def detect?(machine)\n    machine.communicate.test(\"cat /etc/myos-release\")\n  end\nend\n```\n\nAfter detecting an OS, that OS is used for various [guest capabilities](guest-capabilities) that may be required.\n\n## Guest Inheritance\n\nVagrant also supports a form of inheritance for guests, since sometimes operating systems stem from a common root. A good example of this is Linux is the root of Debian, which further is the root of Ubuntu in many cases. Inheritance allows guests to share a lot of common behavior while allowing distro-specific overrides.\n\nInheritance is not done via standard Ruby class inheritance because Vagrant uses a custom [capability-based](guest-capabilities) system. Vagrant handles inheritance dispatch for you.\n\nTo subclass another guest, specify that guest's name as a second parameter in the guest definition:\n\n``` ruby\nguest \"ubuntu\", \"debian\" do\n  require_relative \"guest\"\n  Guest\nend\n```\n\nWith the above component, the \"ubuntu\" guest inherits from \"debian.\" When a capability is looked up for \"ubuntu\", all capabilities from \"debian\" are also available, and any capabilities in \"ubuntu\" override parent capabilities.\n\nWhen detecting operating systems with `detect?`, Vagrant always does a depth-first search by searching the children operating systems before checking their parents. Therefore, it is guaranteed in the above example that the `detect?` method on \"ubuntu\" will be called before \"debian.\"\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/guests.html](https://www.vagrantup.com/docs/plugins/guests.html)"
- name: 'Plugin Development: Host Capabilities'
  id: plugins/host-capabilities
  summary: This page documents how to add new capabilities for hosts to Vagrant, allowing Vagrant to perform new actions on specific host operating systems
  description: "# Plugin Development: Host Capabilities\n\nThis page documents how to add new capabilities for [hosts](hosts) to Vagrant, allowing Vagrant to perform new actions on specific host operating systems. Prior to reading this, you should be familiar with the [plugin development basics](development-basics).\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\nHost capabilities augment [hosts](hosts) by attaching specific \"capabilities\" to the host, which are actions that can be performed in the context of that host operating system.\n\nThe power of capabilities is that plugins can add new capabilities to existing host operating systems without modifying the core of Vagrant. In earlier versions of Vagrant, all the host logic was contained in the core of Vagrant and was not easily augmented.\n\n## Definition and Implementation\n\nThe definition and implementation of host capabilities is identical to [guest capabilities](guest-capabilities).\n\nThe main difference from guest capabilities, however, is that instead of taking a machine as the first argument, all host capabilities take an instance of `Vagrant::Environment` as their first argument.\n\nAccess to the environment allows host capabilities to access global state, specific machines, and also allows them to call other host capabilities.\n\n## Calling Capabilities\n\nSince you have access to the environment in every capability, capabilities can also call *other* host capabilities. This is useful for using the inheritance mechanism of capabilities to potentially ask helpers for more information. For example, the \"linux\" guest has a \"nfs_check_command\" capability that returns the command to use to check if NFS is running.\n\nCapabilities on child guests of Linux such as RedHat or Arch use this capability to mostly inherit the Linux behavior, except for this minor detail.\n\nCapabilities can be called like so:\n\n``` ruby\nenvironment.host.capability(:capability_name)\n```\n\nAny additional arguments given to the method will be passed on to the capability, and the capability will return the value that the actual capability returned.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/host-capabilities.html](https://www.vagrantup.com/docs/plugins/host-capabilities.html)"
- name: 'Plugin Development: Hosts'
  id: plugins/hosts
  summary: This page documents how to add new host OS detection to Vagrant, allowing Vagrant to properly execute host-specific operations on new operating systems
  description: "# Plugin Development: Hosts\n\nThis page documents how to add new host OS detection to Vagrant, allowing Vagrant to properly execute host-specific operations on new operating systems. Prior to reading this, you should be familiar with the [plugin development basics](development-basics).\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\nVagrant has some features that require host OS-specific actions, such as exporting NFS folders. These tasks vary from operating system to operating system. Vagrant uses host detection as well as [host capabilities](host-capabilities) to perform these host OS-specific operations.\n\n## Definition Component\n\nWithin the context of a plugin definition, new hosts can be defined like so:\n\n``` ruby\nhost \"ubuntu\" do\n  require_relative \"host\"\n  Host\nend\n```\n\nHosts are defined with the `host` method. The first argument is the name of the host. This name is not actually used anywhere, but may in the future, so choose something helpful. Then, the block argument returns a class that implements the `Vagrant.plugin(2, :host)` interface.\n\n## Implementation\n\nImplementations of hosts subclass `Vagrant.plugin(\"2\", \"host\")`. Within this implementation, only the `detect?` method needs to be implemented.\n\nThe `detect?` method is called by Vagrant very early on in its initialization process to determine if the OS that Vagrant is running on is this host. If you detect that it is your operating system, return `true` from `detect?`. Otherwise, return `false`.\n\n``` ruby\nclass MyHost < Vagrant.plugin(\"2\", \"host\")\n  def detect?(environment)\n    File.file?(\"/etc/arch-release\")\n  end\nend\n```\n\nAfter detecting an OS, that OS is used for various [host capabilities](host-capabilities) that may be required.\n\n## Host Inheritance\n\nVagrant also supports a form of inheritance for hosts, since sometimes operating systems stem from a common root. A good example of this is Linux is the root of Debian, which further is the root of Ubuntu in many cases. Inheritance allows hosts to share a lot of common behavior while allowing distro-specific overrides.\n\nInheritance is not done via standard Ruby class inheritance because Vagrant uses a custom [capability-based](host-capabilities) system. Vagrant handles inheritance dispatch for you.\n\nTo subclass another host, specify that host's name as a second parameter in the host definition:\n\n``` ruby\nhost \"ubuntu\", \"debian\" do\n  require_relative \"host\"\n  Host\nend\n```\n\nWith the above component, the \"ubuntu\" host inherits from \"debian.\" When a capability is looked up for \"ubuntu\", all capabilities from \"debian\" are also available, and any capabilities in \"ubuntu\" override parent capabilities.\n\nWhen detecting operating systems with `detect?`, Vagrant always does a depth-first search by searching the children operating systems before checking their parents. Therefore, it is guaranteed in the above example that the `detect?` method on \"ubuntu\" will be called before \"debian.\"\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/hosts.html](https://www.vagrantup.com/docs/plugins/hosts.html)"
- name: 'Plugin Development: Packaging & Distribution'
  id: plugins/packaging
  summary: This page documents how to organize the file structure of your plugin and distribute it so that it is installable using standard installation methods
  description: "# Plugin Development: Packaging & Distribution\n\nThis page documents how to organize the file structure of your plugin and distribute it so that it is installable using [standard installation methods](usage). Prior to reading this, you should be familiar with the [plugin development basics](development-basics).\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\n## Example Plugin\n\nThe best way to describe packaging and distribution is to look at how another plugin does it. The best example plugin available for this is [vagrant-aws](https://github.com/mitchellh/vagrant-aws).\n\nBy using [Bundler](http://bundler.io) and Rake, building a new vagrant-aws package is easy. By simply calling `rake package`, a `gem` file is dropped into the directory. By calling `rake release`, the gem is built and it is uploaded to the central [RubyGems](https://rubygems.org) repository so that it can be installed using `vagrant plugin install`.\n\nYour plugin can and should be this easy, too, since you basically get this for free by using Bundler.\n\n## Setting Up Your Project\n\nTo setup your project, run `bundle gem vagrant-my-plugin`. This will create a `vagrant-my-plugin` directory that has the initial layout to be a RubyGem.\n\nYou should modify the `vagrant-my-plugin.gemspec` file to add any dependencies and change any metadata. View the [vagrant-aws.gemspec](https://github.com/mitchellh/vagrant-aws/blob/master/vagrant-aws.gemspec) for a good example.\n\n> **Do not depend on Vagrant** for your gem. Vagrant is no longer distributed as a gem, and you can assume that it will always be available when your plugin is installed.\n\nOnce the directory structure for a RubyGem is setup, you will want to modify your Gemfile. Here is the basic structure of a Gemfile for Vagrant plugin development:\n\n``` ruby\nsource \"https://rubygems.org\"\n\ngroup :development do\n  gem \"vagrant\", git: \"https://github.com/hashicorp/vagrant.git\"\nend\n\ngroup :plugins do\n  gem \"my-vagrant-plugin\", path: \".\"\nend\n```\n\nThis Gemfile gets \"vagrant\" for development. This allows you to `bundle exec vagrant` to run Vagrant with your plugin already loaded, so that you can test it manually that way.\n\nThe only thing about this Gemfile that may stand out as odd is the \"plugins\" group and putting your plugin in that group. Because `vagrant plugin` commands do not work in development, this is how you \"install\" your plugin into Vagrant. Vagrant will automatically load any gems listed in the \"plugins\" group. Note that this also allows you to add multiple plugins to Vagrant for development, if your plugin works with another plugin.\n\nNext, create a `Rakefile` that has at the very least, the following contents:\n\n``` ruby\nrequire \"rubygems\"\nrequire \"bundler/setup\"\nBundler::GemHelper.install_tasks\n```\n\nIf you run `rake -T` now, which lists all the available rake tasks, you should see that you have the `package` and `release` tasks. You can now develop your plugin and build it!\n\nYou can view the [vagrant-aws Rakefile](https://github.com/mitchellh/vagrant-aws/blob/master/Rakefile) for a more comprehensive example that includes testing.\n\n## Testing Your Plugin\n\nTo manually test your plugin during development, use `bundle exec vagrant` to execute Vagrant with your plugin loaded (thanks to the Gemfile setup we did earlier).\n\nFor automated testing, the [vagrant-spec](https://github.com/hashicorp/vagrant-spec) project provides helpers for both unit and acceptance testing plugins. See the giant README for that project for a detailed description of how to integrate vagrant-spec into your project. Vagrant itself (and all of its core plugins) use vagrant-spec for automated testing.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/packaging.html](https://www.vagrantup.com/docs/plugins/packaging.html)"
- name: 'Plugin Development: Providers'
  id: plugins/providers
  summary: This page documents how to add support for new providers to Vagrant, allowing Vagrant to run and manage machines powered by a system other than VirtualBox
  description: "# Plugin Development: Providers\n\nThis page documents how to add support for new [providers](../providers/index) to Vagrant, allowing Vagrant to run and manage machines powered by a system other than VirtualBox. Prior to reading this, you should be familiar with the [plugin development basics](development-basics).\n\nPrior to developing a provider you should also be familiar with how [providers work](../providers/index) from a user standpoint.\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\n## Example Provider: AWS\n\nThe best way to learn how to write a provider is to see how one is written in practice. To augment this documentation, please heavily study the [vagrant-aws](https://github.com/mitchellh/vagrant-aws) plugin, which implements an AWS provider. The plugin is a good example of how to structure, test, and implement your plugin.\n\n## Definition Component\n\nWithin the context of a plugin definition, new providers are defined like so:\n\n``` ruby\nprovider \"my_cloud\" do\n  require_relative \"provider\"\n  Provider\nend\n```\n\nProviders are defined with the `provider` method, which takes a single argument specifying the name of the provider. This is the name that is used with `vagrant up` to specify the provider. So in the case above, our provider would be used by calling `vagrant up --provider=my_cloud`.\n\nThe block argument then lazily loads and returns a class that implements the `Vagrant.plugin(2, :provider)` interface, which is covered next.\n\n## Provider Class\n\nThe provider class should subclass and implement `Vagrant.plugin(2, :provider)` which is an upgrade-safe way to let Vagrant return the proper parent class.\n\nThis class and the methods that need to be implemented are [very well documented](https://github.com/hashicorp/vagrant/blob/master/lib/vagrant/plugin/v2/provider.rb). The documentation done on the class in the comments should be enough to understand what needs to be done.\n\nViewing the [AWS provider class](https://github.com/mitchellh/vagrant-aws/blob/master/lib/vagrant-aws/provider.rb) as well as the [overall structure of the plugin](https://github.com/mitchellh/vagrant-aws) is recommended as a strong getting started point.\n\nInstead of going in depth over each method that needs to be implemented, the documentation will cover high-level but important points to help you create your provider.\n\n## Box Format\n\nEach provider is responsible for having its own box format. This is actually an extremely simple step due to how generic boxes are. Before explaining you should get familiar with the general [box file format](../boxes/format).\n\nThe only requirement for your box format is that the `metadata.json` file have a `provider` key which matches the name of your provider you chose above.\n\nIn addition to this, you may put any data in the metadata as well as any files in the archive. Since Vagrant core itself does not care, it is up to your provider to handle the data of the box. Vagrant core just handles unpacking and verifying the box is for the proper provider.\n\nAs an example of a couple box formats that are actually in use:\n\n- The `virtualbox` box format is just a flat directory of the contents of a `VBoxManage export` command.\n\n- The `vmware_fusion` box format is just a flat directory of the contents of a `vmwarevm` folder, but only including the bare essential files for VMware to function.\n\n- The `aws` box format is just a Vagrantfile defaulting some configuration. You can see an [example aws box unpacked here](https://github.com/mitchellh/vagrant-aws/tree/master/example_box).\n\nBefore anything with your provider is even written, you can verify your box format works by doing `vagrant box add` with it. When you do a `vagrant box list` you can see what boxes for what providers are installed.\n\nYou do *not need* the provider plugin installed to add a box for that provider.\n\n## Actions\n\nProbably the most important concept to understand when building a provider is the provider \"action\" interface. It is the secret sauce that makes providers do the magic they do.\n\nActions are built on top of the concept of [middleware](https://github.com/mitchellh/middleware), which allow providers to execute multiple distinct steps, have error recovery mechanics, as well as before/after behaviors, and much more.\n\nVagrant core requests specific actions from your provider through the `action` method on your provider class. The full list of actions requested is listed in the comments of that method on the superclass. If your provider does not implement a certain action, then Vagrant core will show a friendly error, so do not worry if you miss any, things will not explode or crash spectacularly.\n\nTake a look at how the VirtualBox provider [uses actions to build up complicated multi-step processes](https://github.com/hashicorp/vagrant/blob/master/plugins/providers/virtualbox/action.rb#L287). The AWS provider [uses a similar process](https://github.com/mitchellh/vagrant-aws/blob/master/lib/vagrant-aws/action.rb).\n\n## Built-in Middleware\n\nTo assist with common tasks, Vagrant ships with a set of [built-in middleware](https://github.com/hashicorp/vagrant/tree/master/lib/vagrant/action/builtin). Each of the middleware is well commented on the behavior and options for each, and using these built-in middleware is critical to building a well-behaved provider.\n\nThese built-in middleware can be thought of as a standard library for your actions on your provider. The core VirtualBox provider uses these built-in middleware heavily.\n\n## Persisting State\n\nIn the process of creating and managing a machine, providers generally need to store some sort of state somewhere. Vagrant provides each machine with a directory to store this state.\n\nAs a use-case example for this, the VirtualBox provider stores the UUID of the VirtualBox virtual machine created. This allows the provider to track whether the machine is created, running, suspended, etc.\n\nThe VMware provider actually copies the entire virtual machine into this state directory, complete with virtual disk drives and everything.\n\nThe directory is available from the `data_dir` attribute of the `Machine` instance given to initialize your provider. Within middleware actions, the machine is always available via the `:machine` key on the environment. The `data_dir` attribute is a Ruby [Pathname](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/pathname/rdoc/Pathname.html) object.\n\nIt is important for providers to carefully manage all the contents of this directory. Vagrant core itself does little to clean up this directory. Therefore, when a machine is destroyed, be sure to clean up all the state from this directory.\n\n## Configuration\n\nVagrant supports [provider-specific configuration](../providers/configuration), allowing for users to finely tune and control specific providers from Vagrantfiles. It is easy for your custom provider to expose custom configuration as well.\n\nProvider-specific configuration is a special case of a normal [configuration plugin](configuration). When defining the configuration component, name the configuration the same as the provider, and as a second parameter, specify `:provider`, like so:\n\n``` ruby\nconfig(\"my_cloud\", :provider) do\n  require_relative \"config\"\n  Config\nend\n```\n\nAs long as the name matches your provider, and the second `:provider` parameter is given, Vagrant will automatically expose this as provider-specific configuration for your provider. Users can now do the following in their Vagrantfiles:\n\n``` ruby\nconfig.vm.provider :my_cloud do |config|\n  # Your specific configuration!\nend\n```\n\nThe configuration class returned from the `config` component in the plugin is the same as any other [configuration plugin](configuration), so read that page for more information. Vagrant automatically handles configuration validation and such just like any other configuration piece.\n\nThe provider-specific configuration is available on the machine object via the `provider_config` attribute. So within actions or your provider class, you can access the config via `machine.provider_config`.\n\n> **Best practice:** Your provider should *not require* provider-specific configuration to function, if possible. Vagrant practices a strong [convention over configuration](https://en.wikipedia.org/wiki/Convention_over_configuration) philosophy. When a user installs your provider, they should ideally be able to `vagrant up --provider=your_provider` and have it just work.\n\n## Parallelization\n\nVagrant supports parallelizing some actions, such as `vagrant up`, if the provider explicitly supports it. By default, Vagrant will not parallelize a provider.\n\nWhen parallelization is enabled, multiple [actions](#actions) may be run in parallel. Therefore, providers must be certain that their action stacks are thread-safe. The core of Vagrant itself (such as box collections, SSH, etc.) is thread-safe.\n\nProviders can explicitly enable parallelization by setting the `parallel` option on the provider component:\n\n``` ruby\nprovider(\"my_cloud\", parallel: true) do\n  require_relative \"provider\"\n  Provider\nend\n```\n\nThat is the only change that is needed to enable parallelization.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/providers.html](https://www.vagrantup.com/docs/plugins/providers.html)"
- name: 'Plugin Development: Provisioners'
  id: plugins/provisioners
  summary: This page documents how to add new provisioners to Vagrant, allowing Vagrant to automatically install software and configure software using a custom provisioner
  description: "# Plugin Development: Provisioners\n\nThis page documents how to add new [provisioners](../provisioning/index) to Vagrant, allowing Vagrant to automatically install software and configure software using a custom provisioner. Prior to reading this, you should be familiar with the [plugin development basics](development-basics).\n\n> **Warning: Advanced Topic!** Developing plugins is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Ruby should approach.\n\n## Definition Component\n\nWithin the context of a plugin definition, new provisioners can be defined like so:\n\n``` ruby\nprovisioner \"custom\" do\n  require_relative \"provisioner\"\n  Provisioner\nend\n```\n\nProvisioners are defined with the `provisioner` method, which takes a single argument specifying the name of the provisioner. This is the name that used with `config.vm.provision` when configuring and enabling the provisioner. So in the case above, the provisioner would be enabled using `config.vm.provision :custom`.\n\nThe block argument then lazily loads and returns a class that implements the `Vagrant.plugin(2, :provisioner)` interface, which is covered next.\n\n## Provisioner Class\n\nThe provisioner class should subclass and implement `Vagrant.plugin(2, :provisioner)` which is an upgrade-safe way to let Vagrant return the proper parent class for provisioners.\n\nThis class and the methods that need to be implemented are [very well documented](https://github.com/hashicorp/vagrant/blob/master/lib/vagrant/plugin/v2/provisioner.rb). The documentation on the class in the comments should be enough to understand what needs to be done.\n\nThere are two main methods that need to be implemented: the `configure` method and the `provision` method.\n\nThe `configure` method is called early in the machine booting process to allow the provisioner to define new configuration on the machine, such as sharing folders, defining networks, etc. As an example, the [Chef solo provisioner](https://github.com/hashicorp/vagrant/blob/master/plugins/provisioners/chef/provisioner/chef_solo.rb#L24) uses this to define shared folders.\n\nThe `provision` method is called when the machine is booted and ready for SSH connections. In this method, the provisioner should execute any commands that need to be executed.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/provisioners.html](https://www.vagrantup.com/docs/plugins/provisioners.html)"
- name: Plugin Usage
  id: plugins/usage
  summary: Installing a Vagrant plugin is easy, and should not take more than a few seconds
  description: "# Plugin Usage\n\nInstalling a Vagrant plugin is easy, and should not take more than a few seconds.\n\nPlease refer to the documentation of any plugin you plan on using for more information on how to use it, but there is one common method for installation and plugin activation.\n\n> **Warning!** 3rd party plugins can introduce instabilities into Vagrant due to the nature of them being written by non-core users.\n\n## Installation\n\nPlugins are installed using `vagrant plugin install`:\n\n``` shell\n# Installing a plugin from a known gem source\n$ vagrant plugin install my-plugin\n\n# Installing a plugin from a local file source\n$ vagrant plugin install /path/to/my-plugin.gem\n```\n\nOnce a plugin is installed, it will automatically be loaded by Vagrant. Plugins which cannot be loaded should not crash Vagrant. Instead, Vagrant will show an error message that a plugin failed to load.\n\n## Usage\n\nOnce a plugin is installed, you should refer to the plugin's documentation to see exactly how to use it. Plugins which add commands should be instantly available via `vagrant`, provisioners should be available via `config.vm.provision`, etc.\n\n**Note:** In the future, the `vagrant plugin` command will include a subcommand that will document the components that each plugin installs.\n\n## Updating\n\nPlugins can be updated by running `vagrant plugin update`. This will update every installed plugin to the latest version. You can update a specific plugin by calling `vagrant plugin update NAME`. Vagrant will output what plugins were updated and to what version.\n\nTo determine the changes in a specific version of a plugin, refer to the plugin's homepage (usually a GitHub page or similar). It is the plugin author's responsibility to provide a change log if he or she chooses to.\n\n## Uninstallation\n\nUninstalling a plugin is as easy as installing it. Just use the `vagrant plugin uninstall` command and the plugin will be removed. Example:\n\n``` shell\n$ vagrant plugin uninstall my-plugin\n```\n\n## Listing Plugins\n\nTo view what plugins are installed into your Vagrant environment at any time, use the `vagrant plugin list` command. This will list the plugins that are installed along with their version.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/usage.html](https://www.vagrantup.com/docs/plugins/usage.html)"
- name: Plugins
  id: plugins/index
  summary: Vagrant comes with many great features out of the box to get your environments up and running
  description: "# Plugins\n\nVagrant comes with many great features out of the box to get your environments up and running. Sometimes, however, you want to change the way Vagrant does something or add additional functionality to Vagrant. This can be done via Vagrant *plugins*.\n\nPlugins are powerful, first-class citizens that extend Vagrant using a well-documented, stable API that can withstand major version upgrades.\n\nIn fact, most of the core of Vagrant is [implemented using plugins](https://github.com/hashicorp/vagrant/tree/master/plugins). Since Vagrant [dogfoods](https://en.wikipedia.org/wiki/Eating_your_own_dog_food) its own plugin API, you can be confident that the interface is stable and well supported.\n\nUse the navigation on the left below the \"Plugins\" section to learn more about how to use and build your own plugins.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/plugins/](https://www.vagrantup.com/docs/plugins/)"
- name: Private Networks
  id: networking/private_network
  summary: Vagrant private networks allow you to access your guest machine by some address that is not publicly accessible from the global internet
  description: "# Private Networks\n\n**Network identifier: `private_network`**\n\nVagrant private networks allow you to access your guest machine by some address that is not publicly accessible from the global internet. In general, this means your machine gets an address in the [private address space](https://en.wikipedia.org/wiki/Private_network#Private_IPv4_address_spaces).\n\nMultiple machines within the same private network (also usually with the restriction that they're backed by the same [provider](../providers/index)) can communicate with each other on private networks.\n\n> **Guest operating system support.** Private networks generally require configuring the network adapters on the guest machine. This process varies from OS to OS. Vagrant ships with knowledge of how to configure networks on a variety of guest operating systems, but it is possible if you are using a particularly old or new operating system that private networks will not properly configure.\n\n## DHCP\n\nThe easiest way to use a private network is to allow the IP to be assigned via DHCP.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"private_network\", type: \"dhcp\"\nend\n```\n\nThis will automatically assign an IP address from the reserved address space. The IP address can be determined by using `vagrant ssh` to SSH into the machine and using the appropriate command line tool to find the IP, such as `ifconfig`.\n\n## Static IP\n\nYou can also specify a static IP address for the machine. This lets you access the Vagrant managed machine using a static, known IP. The Vagrantfile for a static IP looks like this:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"private_network\", ip: \"192.168.50.4\"\nend\n```\n\nIt is up to the users to make sure that the static IP does not collide with any other machines on the same network.\n\nWhile you can choose any IP you would like, you *should* use an IP from the [reserved private address space](https://en.wikipedia.org/wiki/Private_network#Private_IPv4_address_spaces). These IPs are guaranteed to never be publicly routable, and most routers actually block traffic from going to them from the outside world.\n\nFor some operating systems, additional configuration options for the static IP address are available such as setting the default gateway or MTU.\n\n> **Warning!** Do not choose an IP that overlaps with any other IP space on your system. This can cause the network to not be reachable.\n\n## IPv6\n\nYou can specify a static IP via IPv6. DHCP for IPv6 is not supported. To use IPv6, just specify an IPv6 address as the IP:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"private_network\", ip: \"fde4:8dba:82e1::c4\"\nend\n```\n\nThis will assign that IP to the machine. The entire `/64` subnet will be reserved. Please make sure to use the reserved local addresses approved for IPv6.\n\nYou can also modify the prefix length by changing the `netmask` option (defaults to 64):\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"private_network\",\n    ip: \"fde4:8dba:82e1::c4\",\n    netmask: \"96\"\nend\n```\n\nIPv6 supports for private networks was added in Vagrant 1.7.5 and may not work with every provider.\n\n## Disable Auto-Configuration\n\nIf you want to manually configure the network interface yourself, you can disable Vagrant's auto-configure feature by specifying `auto_config`:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"private_network\", ip: \"192.168.50.4\",\n    auto_config: false\nend\n```\n\nIf you already started the Vagrant environment before setting `auto_config`, the files it initially placed there will stay there. You will have to remove those files manually or destroy and recreate the machine.\n\nThe files created by Vagrant depend on the OS. For example, for many Linux distros, this is `/etc/network/interfaces`. In general you should look in the normal location that network interfaces are configured for your distro.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/networking/private_network.html](https://www.vagrantup.com/docs/networking/private_network.html)"
- name: Provider Installation
  id: providers/installation
  summary: Providers are distributed as Vagrant plugins, and are therefore installed using standard plugin installation steps
  description: "# Provider Installation\n\nProviders are distributed as Vagrant plugins, and are therefore installed using [standard plugin installation steps](../plugins/usage). After installing a plugin which contains a provider, the provider should immediately be available.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/providers/installation.html](https://www.vagrantup.com/docs/providers/installation.html)"
- name: Providers
  id: providers/index
  summary: While Vagrant ships out of the box with support for VirtualBox, Hyper-V, and Docker, Vagrant has the ability to manage other types of machines as well
  description: "# Providers\n\nWhile Vagrant ships out of the box with support for [VirtualBox](https://www.virtualbox.org), [Hyper-V](https://www.microsoft.com/hyper-v), and [Docker](https://www.docker.io), Vagrant has the ability to manage other types of machines as well. This is done by using other *providers* with Vagrant.\n\nAlternate providers can offer different features that make more sense in your use case. For example, if you are using Vagrant for any real work, [VMware](https://www.vmware.com) providers are recommended since they're well supported and generally more stable and performant than VirtualBox.\n\nBefore you can use another provider, you must install it. Installation of other providers is done via the Vagrant plugin system.\n\nOnce the provider is installed, usage is straightforward and simple, as you would expect with Vagrant. Read into the relevant subsections found in the navigation to the left for more information.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/providers/](https://www.vagrantup.com/docs/providers/)"
- name: Provisioning
  id: provisioning
  summary: Provisioners in Vagrant allow you to automatically install software, alter configurations, and more on the machine as part of the vagrant up process
  description: "# Provisioning\n\nProvisioners in Vagrant allow you to automatically install software, alter configurations, and more on the machine as part of the `vagrant up` process.\n\nThis is useful since [boxes](boxes) typically are not built *perfectly* for your use case. Of course, if you want to just use `vagrant ssh` and install the software by hand, that works. But by using the provisioning systems built-in to Vagrant, it automates the process so that it is repeatable. Most importantly, it requires no human interaction, so you can `vagrant destroy` and `vagrant up` and have a fully ready-to-go work environment with a single command. Powerful.\n\nVagrant gives you multiple options for provisioning the machine, from simple shell scripts to more complex, industry-standard configuration management systems.\n\nIf you've never used a configuration management system before, it is recommended you start with basic [shell scripts](provisioning/shell) for provisioning.\n\nYou can find the full list of built-in provisioners and usage of these provisioners in the navigational area to the left.\n\n## When Provisioning Happens\n\nProvisioning happens at certain points during the lifetime of your Vagrant environment:\n\n- On the first `vagrant up` that creates the environment, provisioning is run. If the environment was already created and the up is just resuming a machine or booting it up, they will not run unless the `--provision` flag is explicitly provided.\n\n- When `vagrant provision` is used on a running environment.\n\n- When `vagrant reload --provision` is called. The `--provision` flag must be present to force provisioning.\n\nYou can also bring up your environment and explicitly *not* run provisioners by specifying `--no-provision`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning](https://www.vagrantup.com/docs/provisioning)"
- name: Provisioning
  id: provisioning/index
  summary: Provisioners in Vagrant allow you to automatically install software, alter configurations, and more on the machine as part of the vagrant up process
  description: "# Provisioning\n\nProvisioners in Vagrant allow you to automatically install software, alter configurations, and more on the machine as part of the `vagrant up` process.\n\nThis is useful since [boxes](../boxes) typically are not built *perfectly* for your use case. Of course, if you want to just use `vagrant ssh` and install the software by hand, that works. But by using the provisioning systems built-in to Vagrant, it automates the process so that it is repeatable. Most importantly, it requires no human interaction, so you can `vagrant destroy` and `vagrant up` and have a fully ready-to-go work environment with a single command. Powerful.\n\nVagrant gives you multiple options for provisioning the machine, from simple shell scripts to more complex, industry-standard configuration management systems.\n\nIf you've never used a configuration management system before, it is recommended you start with basic [shell scripts](shell) for provisioning.\n\nYou can find the full list of built-in provisioners and usage of these provisioners in the navigational area to the left.\n\n## When Provisioning Happens\n\nProvisioning happens at certain points during the lifetime of your Vagrant environment:\n\n- On the first `vagrant up` that creates the environment, provisioning is run. If the environment was already created and the up is just resuming a machine or booting it up, they will not run unless the `--provision` flag is explicitly provided.\n\n- When `vagrant provision` is used on a running environment.\n\n- When `vagrant reload --provision` is called. The `--provision` flag must be present to force provisioning.\n\nYou can also bring up your environment and explicitly *not* run provisioners by specifying `--no-provision`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/](https://www.vagrantup.com/docs/provisioning/)"
- name: Public Networks
  id: networking/public_network
  summary: Vagrant public networks are less private than private networks, and the exact meaning actually varies from provider to provider, hence the ambiguous definition
  description: "# Public Networks\n\n**Network identifier: `public_network`**\n\nVagrant public networks are less private than private networks, and the exact meaning actually varies from [provider to provider](../providers/index), hence the ambiguous definition. The idea is that while [private networks](private_network) should never allow the general public access to your machine, public networks can.\n\n> **Confused?** We kind of are, too. It is likely that public networks will be replaced by `:bridged` in a future release, since that is in general what should be done with public networks, and providers that do not support bridging generally do not have any other features that map to public networks either.\n\n> **Warning!** Vagrant boxes are insecure by default and by design, featuring public passwords, insecure keypairs for SSH access, and potentially allow root access over SSH. With these known credentials, your box is easily accessible by anyone on your network. Before configuring Vagrant to use a public network, consider *all* potential security implications and review the [default box configuration](../boxes/base) to identify potential security risks.\n\n## DHCP\n\nThe easiest way to use a public network is to allow the IP to be assigned via DHCP. In this case, defining a public network is trivially easy:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"public_network\"\nend\n```\n\nWhen DHCP is used, the IP can be determined by using `vagrant ssh` to SSH into the machine and using the appropriate command line tool to find the IP, such as `ifconfig`.\n\n### Using the DHCP Assigned Default Route\n\nSome cases require the DHCP assigned default route to be untouched. In these cases one may specify the `use_dhcp_assigned_default_route` option. As an example:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"public_network\",\n    use_dhcp_assigned_default_route: true\nend\n```\n\n## Static IP\n\nDepending on your setup, you may wish to manually set the IP of your bridged interface. To do so, add a `:ip` clause to the network definition.\n\n``` ruby\nconfig.vm.network \"public_network\", ip: \"192.168.0.17\"\n```\n\n## Default Network Interface\n\nIf more than one network interface is available on the host machine, Vagrant will ask you to choose which interface the virtual machine should bridge to. A default interface can be specified by adding a `:bridge` clause to the network definition.\n\n``` ruby\nconfig.vm.network \"public_network\", bridge: \"en1: Wi-Fi (AirPort)\"\n```\n\nThe string identifying the desired interface must exactly match the name of an available interface. If it cannot be found, Vagrant will ask you to pick from a list of available network interfaces.\n\nWith some providers, it is possible to specify a list of adapters to bridge against:\n\n``` ruby\nconfig.vm.network \"public_network\", bridge: [\n  \"en1: Wi-Fi (AirPort)\",\n  \"en6: Broadcom NetXtreme Gigabit Ethernet Controller\",\n]\n```\n\nIn this example, the first network adapter that exists and can successfully be bridge will be used.\n\n## Disable Auto-Configuration\n\nIf you want to manually configure the network interface yourself, you can disable auto-configuration by specifying `auto_config`:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"public_network\", auto_config: false\nend\n```\n\nThen the shell provisioner can be used to configure the ip of the interface:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"public_network\", auto_config: false\n\n  # manual ip\n  config.vm.provision \"shell\",\n    run: \"always\",\n    inline: \"ifconfig eth1 192.168.0.17 netmask 255.255.255.0 up\"\n\n  # manual ipv6\n  config.vm.provision \"shell\",\n    run: \"always\",\n    inline: \"ifconfig eth1 inet6 add fc00::17/7\"\nend\n```\n\n## Default Router\n\nDepending on your setup, you may wish to manually override the default router configuration. This is required if you need access the Vagrant box from other networks over the public network. To do so, you can use a shell provisioner script:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.network \"public_network\", ip: \"192.168.0.17\"\n\n  # default router\n  config.vm.provision \"shell\",\n    run: \"always\",\n    inline: \"route add default gw 192.168.0.1\"\n\n  # default router ipv6\n  config.vm.provision \"shell\",\n    run: \"always\",\n    inline: \"route -A inet6 add default gw fc00::1 eth1\"\n\n  # delete default gw on eth0\n  config.vm.provision \"shell\",\n    run: \"always\",\n    inline: \"eval `route -n | awk '{ if ($8 ==\\\"eth0\\\" && $2 != \\\"0.0.0.0\\\") print \\\"route del default gw \\\" $2; }'`\"\nend\n```\n\nNote the above is fairly complex and may be guest OS specific, but we document the rough idea of how to do it because it is a common question.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/networking/public_network.html](https://www.vagrantup.com/docs/networking/public_network.html)"
- name: Puppet Agent Provisioner
  id: provisioning/puppet_agent
  summary: The Vagrant Puppet agent provisioner allows you to provision the guest using Puppet, specifically by calling puppet agent, connecting to a Puppet master, and retrieving the set of modules and manifests from there
  description: "# Puppet Agent Provisioner\n\n**Provisioner name: `puppet_server`**\n\nThe Vagrant Puppet agent provisioner allows you to provision the guest using [Puppet](https://www.puppetlabs.com/puppet), specifically by calling `puppet agent`, connecting to a Puppet master, and retrieving the set of modules and manifests from there.\n\n> **Warning:** If you are not familiar with Puppet and Vagrant already, I recommend starting with the [shell provisioner](shell). However, if you are comfortable with Vagrant already, Vagrant is the best way to learn Puppet.\n\n## Options\n\nThe `puppet_server` provisioner takes various options. None are strictly required. They are listed below:\n\n- [`binary_path`](#binary_path) (string) - Path on the guest to Puppet's `bin/` directory.\n\n- [`client_cert_path`](#client_cert_path) (string) - Path to the client certificate for the node on your disk. This defaults to nothing, in which case a client cert will not be uploaded.\n\n- [`client_private_key_path`](#client_private_key_path) (string) - Path to the client private key for the node on your disk. This defaults to nothing, in which case a client private key will not be uploaded.\n\n- [`facter`](#facter) (hash) - Additional Facter facts to make available to the Puppet run.\n\n- [`options`](#options-1) (string or array) - Additional command line options to pass to `puppet agent` when Puppet is ran.\n\n- [`puppet_node`](#puppet_node) (string) - The name of the node. If this is not set, this will attempt to use a hostname if set via `config.vm.hostname`. Otherwise, the box name will be used.\n\n- [`puppet_server`](#puppet_server) (string) - Hostname of the Puppet server. By default \"puppet\" will be used.\n\n## Specifying the Puppet Master\n\nThe quickest way to get started with the Puppet agent provisioner is to just specify the location of the Puppet master:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet_server\" do |puppet|\n    puppet.puppet_server = \"puppet.example.com\"\n  end\nend\n```\n\nBy default, Vagrant will look for the host named \"puppet\" on the local domain of the guest machine.\n\n## Configuring the Node Name\n\nThe node name that the agent registers as can be customized. Remember this is important because Puppet uses the node name as part of the process to compile the catalog the node will run.\n\nThe node name defaults to the hostname of the guest machine, but can be customized using the Vagrantfile:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet_server\" do |puppet|\n    puppet.puppet_node = \"node.example.com\"\n  end\nend\n```\n\n## Additional Options\n\nPuppet supports a lot of command-line flags. Basically any setting can be overridden on the command line. To give you the most power and flexibility possible with Puppet, Vagrant allows you to specify custom command line flags to use:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet_server\" do |puppet|\n    puppet.options = \"--verbose --debug\"\n  end\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/puppet_agent.html](https://www.vagrantup.com/docs/provisioning/puppet_agent.html)"
- name: Puppet Apply Provisioner
  id: provisioning/puppet_apply
  summary: The Vagrant Puppet provisioner allows you to provision the guest using Puppet, specifically by calling puppet apply, without a Puppet Master
  description: "# Puppet Apply Provisioner\n\n**Provisioner name: `puppet`**\n\nThe Vagrant Puppet provisioner allows you to provision the guest using [Puppet](https://www.puppetlabs.com/puppet), specifically by calling `puppet apply`, without a Puppet Master.\n\n> **Warning:** If you are not familiar with Puppet and Vagrant already, I recommend starting with the [shell provisioner](shell). However, if you are comfortable with Vagrant already, Vagrant is the best way to learn Puppet.\n\n## Options\n\nThis section lists the complete set of available options for the Puppet provisioner. More detailed examples of how to use the provisioner are available below this section.\n\n- [`binary_path`](#binary_path) (string) - Path on the guest to Puppet's `bin/` directory.\n\n- [`facter`](#facter) (hash) - A hash of data to set as available facter variables within the Puppet run.\n\n- [`hiera_config_path`](#hiera_config_path) (string) - Path to the Hiera configuration on the host. Read the section below on how to use Hiera with Vagrant.\n\n- [`manifest_file`](#manifest_file) (string) - The name of the manifest file that will serve as the entrypoint for the Puppet run. This manifest file is expected to exist in the configured `manifests_path` (see below). This defaults to \"default.pp\"\n\n- [`manifests_path`](#manifests_path) (string) - The path to the directory which contains the manifest files. This defaults to \"manifests\"\n\n- [`module_path`](#module_path) (string or array of strings) - Path or paths, on the host, to the directory which contains Puppet modules, if any.\n\n- [`environment`](#environment) (string) - Name of the Puppet environment.\n\n- [`environment_path`](#environment_path) (string) - Path to the directory that contains environment files on the host disk.\n\n- [`environment_variables`](#environment_variables) (hash) - A hash of string key/value pairs to be set as environment variables before the puppet apply run.\n\n- [`options`](#options-1) (array of strings) - Additionally options to pass to the Puppet executable when running Puppet.\n\n- [`synced_folder_type`](#synced_folder_type) (string) - The type of synced folders to use when sharing the data required for the provisioner to work properly. By default this will use the default synced folder type. For example, you can set this to \"nfs\" to use NFS synced folders.\n\n- [`synced_folder_args`](#synced_folder_args) (array) - Arguments that are passed to the folder sync. For example \\['-a', '--delete', '--exclude=fixtures'\\] for the rsync sync command.\n\n- [`temp_dir`](#temp_dir) (string) - The directory where all the data associated with the Puppet run (manifest files, modules, etc.) will be stored on the guest machine.\n\n- [`working_directory`](#working_directory) (string) - Path in the guest that will be the working directory when Puppet is executed. This is usually only set because relative paths are used in the Hiera configuration.\n\n> If only `environment` and `environment_path` are specified, it will parse and use the manifest specified in the `environment.conf` file. If `manifests_path` and `manifest_file` is specified along with the environment options, the manifest from the environment will be overridden by the specified `manifest_file`. If `manifests_path` and `manifest_file` are specified without environments, the old non-environment mode will be used (which will fail on Puppet 4+).\n\n## Bare Minimum\n\nThe quickest way to get started with the Puppet provisioner is to just enable it:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet\"\nend\n```\n\n> `puppet` need to be installed in the guest vm.\n\nBy default, Vagrant will configure Puppet to look for manifests in the \"manifests\" folder relative to the project root, and will use the \"default.pp\" manifest as an entry-point. This means, if your directory tree looks like the one below, you can get started with Puppet with just that one line in your Vagrantfile.\n\n``` highlight\n$ tree\n.\n|-- Vagrantfile\n|-- manifests\n|   |-- default.pp\n```\n\n## Custom Manifest Settings\n\nOf course, you are able to put and name your manifests whatever you would like. You can override both the directory where Puppet looks for manifests with `manifests_path`, and the manifest file used as the entry-point with `manifest_file`:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet\" do |puppet|\n    puppet.manifests_path = \"my_manifests\"\n    puppet.manifest_file = \"default.pp\"\n  end\nend\n```\n\nThe path can be relative or absolute. If it is relative, it is relative to the project root.\n\nYou can also specify a manifests path that is on the remote machine already, perhaps put in place by a shell provisioner. In this case, Vagrant will not attempt to upload the manifests directory. To specify a remote manifests path, use the following syntax:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet\" do |puppet|\n    puppet.manifests_path = [\"vm\", \"/path/to/manifests\"]\n    puppet.manifest_file = \"default.pp\"\n  end\nend\n```\n\nIt is a somewhat odd syntax, but the tuple (two-element array) says that the path is located in the \"vm\" at \"/path/to/manifests\".\n\n## Environments\n\nIf you are using Puppet 4 or higher, you can provision using [Puppet Environments](https://docs.puppetlabs.com/puppet/latest/reference/environments.html) by specifying the name of the environment and the path on the local disk to the environment files:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet\" do |puppet|\n    puppet.environment_path = \"../puppet/environments\"\n    puppet.environment = \"testenv\"\n  end\nend\n```\n\nThe default manifest is the environment's `manifests` directory. If the environment has an `environment.conf` the manifest path is parsed from there. Relative paths are assumed to be relative to the directory of the environment. If the manifest setting in `environment.conf` use the Puppet variables `$codedir` or `$environment` they are resolved to the parent directory of `environment_path` and `environment` respectively.\n\n## Modules\n\nVagrant also supports provisioning with [Puppet modules](https://docs.puppetlabs.com/guides/modules.html). This is done by specifying a path to a modules folder where modules are located. The manifest file is still used as an entry-point.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet\" do |puppet|\n    puppet.module_path = \"modules\"\n  end\nend\n```\n\nJust like the manifests path, the modules path is relative to the project root if a relative path is given.\n\n## Custom Facts\n\nCustom facts to be exposed by [Facter](https://puppetlabs.com/facter) can be specified as well:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet\" do |puppet|\n    puppet.facter = {\n      \"vagrant\" => \"1\"\n    }\n  end\nend\n```\n\nNow, the `$vagrant` variable in your Puppet manifests will equal \"1\".\n\n## Configuring Hiera\n\n[Hiera](https://docs.puppetlabs.com/hiera/1/) configuration is also supported. `hiera_config_path` specifies the path to the Hiera configuration file stored on the host. If the `:datadir` setting in the Hiera configuration file is a relative path, `working_directory` should be used to specify the directory in the guest that path is relative to.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet\" do |puppet|\n    puppet.hiera_config_path = \"hiera.yaml\"\n    puppet.working_directory = \"/tmp/vagrant-puppet\"\n  end\nend\n```\n\n`hiera_config_path` can be relative or absolute. If it is relative, it is relative to the project root. `working_directory` is an absolute path within the guest.\n\n## Additional Options\n\nPuppet supports a lot of command-line flags. Basically any setting can be overridden on the command line. To give you the most power and flexibility possible with Puppet, Vagrant allows you to specify custom command line flags to use:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"puppet\" do |puppet|\n    puppet.options = \"--verbose --debug\"\n  end\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/puppet_apply.html](https://www.vagrantup.com/docs/provisioning/puppet_apply.html)"
- name: RSync
  id: synced-folders/rsync
  summary: Vagrant can use rsync as a mechanism to sync a folder to the guest machine
  description: "# RSync\n\n**Synced folder type:** `rsync`\n\nVagrant can use [rsync](https://en.wikipedia.org/wiki/Rsync) as a mechanism to sync a folder to the guest machine. This synced folder type is useful primarily in situations where other synced folder mechanisms are not available, such as when NFS or VirtualBox shared folders are not available in the guest machine.\n\nThe rsync synced folder does a one-time one-way sync from the machine running to the machine being started by Vagrant.\n\nThe [rsync](../cli/rsync) and [rsync-auto](../cli/rsync-auto) commands can be used to force a resync and to automatically resync when changes occur in the filesystem. Without running these commands, Vagrant only syncs the folders on `vagrant up` or `vagrant reload`.\n\n## Prerequisites\n\nTo use the rsync synced folder type, the machine running Vagrant must have `rsync` (or `rsync.exe`) on the path. This executable is expected to behave like the standard rsync tool.\n\nOn Windows, rsync installed with Cygwin or MinGW will be detected by Vagrant and works well.\n\nThe destination machine must also have rsync installed, but Vagrant can automatically install rsync into many operating systems. If Vagrant is unable to automatically install rsync for your operating system, it will tell you.\n\nThe destination folder will be created as the user initiating the connection, this is `vagrant` by default. This user requires the appropriate permissions on the destination folder.\n\n## Options\n\nThe rsync synced folder type accepts the following options:\n\n- [`rsync__args`](#rsync__args) (array of strings) - A list of arguments to supply to `rsync`. By default this is `[\"--verbose\", \"--archive\", \"--delete\", \"-z\", \"--copy-links\"]`.\n\n- [`rsync__auto`](#rsync__auto) (boolean) - If false, then `rsync-auto` will not watch and automatically sync this folder. By default, this is true. **Note**: This option will not automatically invoke the `rsync-auto` subcommand.\n\n- [`rsync__chown`](#rsync__chown) (boolean) - If false, then the [`owner` and `group`](basic_usage) options for the synced folder are ignored and Vagrant will not execute a recursive `chown`. This defaults to true. This option exists because the `chown` causes issues for some development environments. Note that any `rsync__args` options for ownership **will be overridden** by `rsync__chown`.\n\n- [`rsync__exclude`](#rsync__exclude) (string or array of strings) - A list of files or directories to exclude from the sync. The values can be any acceptable rsync exclude pattern. By default, the \".vagrant/\" directory is excluded. We recommend excluding revision control directories such as \".git/\" as well.\n\n- [`rsync__rsync_path`](#rsync__rsync_path) (string) - The path on the remote host where rsync is and how it is executed. This is platform specific but defaults to \"sudo rsync\" for many guests.\n\n- [`rsync__verbose`](#rsync__verbose) (boolean) - If true, then the output from the rsync process will be echoed to the console. The output of rsync is subject to `rsync__args` of course. By default, this is false.\n\n## Example\n\nThe following is an example of using RSync to sync a folder:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.synced_folder \".\", \"/vagrant\", type: \"rsync\",\n    rsync__exclude: \".git/\"\nend\n```\n\n## Rsync to a restricted folder\n\nIf required to copy to a destination where `vagrant` user does not have permissions, use `\"--rsync-path='sudo rsync'\"` to run rsync with sudo on the guest\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.synced_folder \"bin\", \"/usr/local/bin\", type: \"rsync\",\n    rsync__exclude: \".git/\",\n    rsync__args: [\"--verbose\", \"--rsync-path='sudo rsync'\", \"--archive\", \"--delete\", \"-z\"]\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/synced-folders/rsync.html](https://www.vagrantup.com/docs/synced-folders/rsync.html)"
- name: Salt Provisioner
  id: provisioning/salt
  summary: The Vagrant Salt provisioner allows you to provision the guest using Salt states
  description: "# Salt Provisioner\n\n**Provisioner name: `salt`**\n\nThe Vagrant Salt provisioner allows you to provision the guest using [Salt](http://saltstack.com/) states.\n\nSalt states are [YAML](https://en.wikipedia.org/wiki/YAML) documents that describes the current state a machine should be in, e.g. what packages should be installed, which services are running, and the contents of arbitrary files.\n\n*NOTE: The Salt provisioner is builtin to Vagrant. If the `vagrant-salt` plugin is installed, it should be uninstalled to ensure expected behavior.*\n\n## Masterless Quickstart\n\nWhat follows is a basic Vagrantfile that will get salt working on a single minion, without a master:\n\n``` ruby\n  Vagrant.configure(\"2\") do |config|\n    ## Choose your base box\n    config.vm.box = \"precise64\"\n\n    ## For masterless, mount your salt file root\n    config.vm.synced_folder \"salt/roots/\", \"/srv/salt/\"\n\n    ## Use all the defaults:\n    config.vm.provision :salt do |salt|\n\n      salt.masterless = true\n      salt.minion_config = \"salt/minion\"\n      salt.run_highstate = true\n\n    end\n  end\n```\n\nThis sets up a shared folder for the salt root, and copies the minion file over, then runs `state.highstate` on the machine. Your minion file must contain the line `file_client: local` in order to work in a masterless setup.\n\n## Install Options\n\n- [`install_master`](#install_master) (boolean) - Should vagrant install the salt-master on this machine. Not supported on Windows guest machines.\n\n- [`no_minion`](#no_minion) (boolean) - Do not install the minion, default `false`. Not supported on Windows guest machines.\n\n- [`install_syndic`](#install_syndic) (boolean) - Install the salt-syndic, default `false`. Not supported on Windows guest machines.\n\n- [`install_type`](#install_type) (stable \\| git \\| daily \\| testing) - Whether to install from a distribution's stable package manager, git tree-ish, daily ppa, or testing repository. Not supported on Windows guest machines.\n\n- [`install_args`](#install_args) (string, default: \"develop\") - When performing a git install, you can specify a branch, tag, or any treeish. Not supported on Windows.\n\n- [`always_install`](#always_install) (boolean) - Installs salt binaries even if they are already detected, default `false`\n\n- [`bootstrap_script`](#bootstrap_script) (string) - Path to your customized salt-bootstrap.sh script. Not supported on Windows guest machines.\n\n- [`bootstrap_options`](#bootstrap_options) (string) - Additional command-line options to pass to the bootstrap script.\n\n- [`version`](#version) (string, default: \"2017.7.1\") - Version of minion to be installed.\n\n- [`python_version`](#python_version) (string, default: \"2\") - Major Python version of minion to be installed. Only valid for minion versions \\>= 2017.7.0. Only supported on Windows guest machines.\n\n## Minion Options\n\nThese only make sense when `no_minion` is `false`.\n\n- [`minion_config`](#minion_config) (string, default: \"salt/minion\") - Path to a custom salt minion config file.\n\n- [`minion_key`](#minion_key) (string, default: \"salt/key/minion.key\") - Path to your minion key\n\n- [`minion_id`](#minion_id) (string) - Unique identifier for minion. Used for masterless and preseeding keys.\n\n- [`minion_pub`](#minion_pub) (string, default: \"salt/key/minion.pub\") - Path to your minion public key\n\n- [`grains_config`](#grains_config) (string) - Path to a custom salt grains file. On Windows, the minion needs `ipc_mode: tcp` set otherwise it will [fail to communicate](https://github.com/saltstack/salt/issues/22796) with the master.\n\n- [`masterless`](#masterless) (boolean) - Calls state.highstate in local mode. Uses `minion_id` and `pillar_data` when provided.\n\n- [`minion_json_config`](#minion_json_config) (string) - Valid json for configuring the salt minion (`-j` in bootstrap-salt.sh). Not supported on Windows.\n\n- [`salt_call_args`](#salt_call_args) (array) - An array of additional command line flag arguments to be passed to the `salt-call` command when provisioning with masterless.\n\n## Master Options\n\nThese only make sense when `install_master` is `true`. Not supported on Windows guest machines.\n\n- [`master_config`](#master_config) (string, default: \"salt/master\") Path to a custom salt master config file.\n\n- [`master_key`](#master_key) (string, default: \"salt/key/master.pem\") - Path to your master key.\n\n- [`master_pub`](#master_pub) (string, default: \"salt/key/master.pub\") - Path to your master public key.\n\n- [`seed_master`](#seed_master) (dictionary) - Upload keys to master, thereby pre-seeding it before use. Example: `{minion_name:/path/to/key.pub}`\n\n- [`master_json_config`](#master_json_config) (string) - Valid json for configuring the salt master (`-J` in bootstrap-salt.sh). Not supported on Windows.\n\n- [`salt_args`](#salt_args) (array) - An array of additional command line flag arguments to be passed to the `salt` command when provisioning with masterless.\n\n## Execute States\n\nEither of the following may be used to actually execute states during provisioning.\n\n- [`run_highstate`](#run_highstate) - (boolean) Executes `state.highstate` on vagrant up. Can be applied to any machine.\n\n## Execute Runners\n\nEither of the following may be used to actually execute runners during provisioning.\n\n- [`run_overstate`](#run_overstate) - (boolean) Executes `state.over` on vagrant up. Can be applied to the master only. This is superseded by orchestrate. Not supported on Windows guest machines.\n\n- [`orchestrations`](#orchestrations) - (array of strings) Executes `state.orchestrate` on vagrant up. Can be applied to the master only. This is superseded by run_overstate. Not supported on Windows guest machines.\n\n## Output Control\n\nThese may be used to control the output of state execution:\n\n- [`colorize`](#colorize) (boolean) - If true, output is colorized. Defaults to false.\n\n- [`log_level`](#log_level) (string) - The verbosity of the outputs. Defaults to \"debug\". Can be one of \"all\", \"garbage\", \"trace\", \"debug\", \"info\", or \"warning\". Requires `verbose` to be set to \"true\".\n\n- [`verbose`](#verbose) (boolean) - The verbosity of the outputs. Defaults to \"false\". Must be true for log_level taking effect and the output of the salt-commands being displayed.\n\n## Pillar Data\n\nYou can export pillar data for use during provisioning by using the `pillar` command. Each call will merge the data so you can safely call it multiple times. The data passed in should only be hashes and lists. Here is an example::\n\n``` ruby\n      config.vm.provision :salt do |salt|\n\n        # Export hostnames for webserver config\n        salt.pillar({\n          \"hostnames\" => {\n            \"www\" => \"www.example.com\",\n            \"intranet\" => \"intranet.example.com\"\n          }\n        })\n\n        # Export database credentials\n        salt.pillar({\n          \"database\" => {\n            \"user\" => \"jdoe\",\n            \"password\" => \"topsecret\"\n          }\n        })\n\n        salt.run_highstate = true\n\n      end\n```\n\nOn Windows guests, this requires PowerShell 3.0 or higher.\n\n## Preseeding Keys\n\nPreseeding keys is the recommended way to handle provisioning using a master. On a machine with salt installed, run `salt-key --gen-keys=[minion_id]` to generate the necessary .pub and .pem files\n\nFor an example of a more advanced setup, look at the original [plugin](https://github.com/saltstack/salty-vagrant/tree/develop/example).\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/salt.html](https://www.vagrantup.com/docs/provisioning/salt.html)"
- name: Security
  id: share/security
  summary: Sharing your Vagrant environment understandably raises a number of security concerns
  description: "# Security\n\nSharing your Vagrant environment understandably raises a number of security concerns.\n\nThe primary security mechanism for Vagrant Share is security through obscurity along with an encryption key for SSH. Additionally, there are several configuration options made available to help control access and manage security:\n\n- [`--disable-http`](#disable-http) will not create a publicly accessible HTTP URL. When this is set, the only way to access the share is with `vagrant connect`.\n\nIn addition to these options, there are other features we've built to help:\n\n- Vagrant share uses end-to-end TLS for non-HTTP connections. So even unencrypted TCP streams are encrypted through the various proxies and only unencrypted during the final local communication between the local proxy and the Vagrant environment.\n\n- SSH keys are encrypted by default, using a password that is not transmitted to our servers or across the network at all.\n\n- SSH is not shared by default, it must explicitly be shared with the `--ssh` flag.\n\nMost importantly, you must understand that by running `vagrant share`, you are making your Vagrant environment accessible by anyone who knows the share name. When share is not running, it is not accessible.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/share/security.html](https://www.vagrantup.com/docs/share/security.html)"
- name: Shared Ansible Options
  id: provisioning/ansible_common
  summary: These options get passed to the ansible-playbook command that ships with Ansible, either via command line arguments or environment variables, depending on Ansible own capabilities
  description: "# Shared Ansible Options\n\nThe following options are available to both Vagrant Ansible provisioners:\n\n- [`ansible`](ansible)\n- [`ansible_local`](ansible_local)\n\nThese options get passed to the `ansible-playbook` command that ships with Ansible, either via command line arguments or environment variables, depending on Ansible own capabilities.\n\nSome of these options are for advanced usage only and should not be used unless you understand their purpose.\n\n- [`become`](#become) (boolean) - Perform all the Ansible playbook tasks [as another user](http://docs.ansible.com/ansible/become.html), different from the user used to log into the guest system.\n\n  The default value is `false`.\n\n- [`become_user`](#become_user) (string) - Set the default username to be used by the Ansible `become` [privilege escalation](http://docs.ansible.com/ansible/become.html) mechanism.\n\n  By default this option is not set, and the Ansible default value (`root`) will be used.\n\n- [`compatibility_mode`](#compatibility_mode) (string) - Set the **minimal** version of Ansible to be supported. Vagrant will only use parameters that are compatible with the given version.\n\n  Possible values:\n\n  - [`\"auto\"`](#quot-auto-quot-) *(Vagrant will automatically select the optimal compatibility mode by checking the Ansible version currently available)*\n  - [`\"1.8\"`](#quot-1-8-quot-) *(Ansible versions prior to 1.8 should mostly work well, but some options might not be supported)*\n  - [`\"2.0\"`](#quot-2-0-quot-) *(The generated Ansible inventory will be incompatible with Ansible 1.x)*\n\n  By default this option is set to `\"auto\"`. If Vagrant is not able to detect any supported Ansible version, it will fall back on the compatibility mode `\"1.8\"` with a warning.\n\n  Vagrant will error if the specified compatibility mode is incompatible with the current Ansible version.\n\n  > **Attention:** Vagrant doesn't perform any validation between the `compatibility_mode` value and the value of the [`version`](#version) option.\n\n  > **Compatibility Note:** This option was introduced in Vagrant 2.0. The behavior of previous Vagrant versions can be simulated by setting the `compatibility_mode` to `\"1.8\"`.\n\n- [`config_file`](#config_file) (string) - The path to an [Ansible Configuration file](https://docs.ansible.com/intro_configuration.html).\n\n  By default, this option is not set, and Ansible will [search for a possible configuration file in some default locations](ansible_intro#ANSIBLE_CONFIG).\n\n- [`extra_vars`](#extra_vars) (string or hash) - Pass additional variables (with highest priority) to the playbook.\n\n  This parameter can be a path to a JSON or YAML file, or a hash.\n\n  Example:\n\n  ``` ruby\n  ansible.extra_vars = {\n    ntp_server: \"pool.ntp.org\",\n    nginx: {\n      port: 8008,\n      workers: 4\n    }\n  }\n  ```\n\n  These variables take the highest precedence over any other variables.\n\n- [`galaxy_command`](#galaxy_command) (template string) - The command pattern used to install Galaxy roles when `galaxy_role_file` is set.\n\n  The following (optional) placeholders can be used in this command pattern:\n\n  - [`%{role_file}`](#role_file-) is replaced by the absolute path to the `galaxy_role_file` option\n  - [`%{roles_path}`](#roles_path-) is\n    - replaced by the absolute path to the `galaxy_roles_path` option when such option is defined, or\n    - replaced by the absolute path to a `roles` subdirectory sitting in the `playbook` parent directory.\n\n  By default, this option is set to\n\n  `ansible-galaxy install --role-file=%{role_file} --roles-path=%{roles_path} --force`\n\n- [`galaxy_role_file`](#galaxy_role_file) (string) - The path to the Ansible Galaxy role file.\n\n  By default, this option is set to `nil` and Galaxy support is then disabled.\n\n  Note: if an absolute path is given, the `ansible_local` provisioner will assume that it corresponds to the exact location on the guest system.\n\n  ``` ruby\n  ansible.galaxy_role_file = \"requirements.yml\"\n  ```\n\n- [`galaxy_roles_path`](#galaxy_roles_path) (string) - The path to the directory where Ansible Galaxy roles must be installed\n\n  By default, this option is set to `nil`, which means that the Galaxy roles will be installed in a `roles` subdirectory located in the parent directory of the `playbook` file.\n\n- [`groups`](#groups) (hash) - Set of inventory groups to be included in the [auto-generated inventory file](ansible_intro).\n\n  Example:\n\n  ``` ruby\n  ansible.groups = {\n    \"web\" => [\"vm1\", \"vm2\"],\n    \"db\"  => [\"vm3\"]\n  }\n  ```\n\n  Example with [group variables](https://docs.ansible.com/ansible/intro_inventory.html#group-variables):\n\n  ``` ruby\n  ansible.groups = {\n    \"atlanta\" => [\"host1\", \"host2\"],\n    \"atlanta:vars\" => {\"ntp_server\" => \"ntp.atlanta.example.com\",\n                       \"proxy\" => \"proxy.atlanta.example.com\"}\n  }\n  ```\n\n  Notes:\n\n  - Alphanumeric patterns are not supported (e.g. `db-[a:f]`, `vm[01:10]`).\n  - This option has no effect when the `inventory_path` option is defined.\n\n- [`host_vars`](#host_vars) (hash) - Set of inventory host variables to be included in the [auto-generated inventory file](https://docs.ansible.com/ansible/intro_inventory.html#host-variables).\n\n  Example:\n\n  ``` ruby\n  ansible.host_vars = {\n    \"host1\" => {\"http_port\" => 80,\n                \"maxRequestsPerChild\" => 808},\n                \"comments\" => \"text with spaces\",\n    \"host2\" => {\"http_port\" => 303,\n                \"maxRequestsPerChild\" => 909}\n  }\n  ```\n\n  Note: This option has no effect when the `inventory_path` option is defined.\n\n- [`inventory_path`](#inventory_path) (string) - The path to an Ansible inventory resource (e.g. a [static inventory file](https://docs.ansible.com/intro_inventory.html), a [dynamic inventory script](https://docs.ansible.com/intro_dynamic_inventory.html) or even [multiple inventories stored in the same directory](https://docs.ansible.com/intro_dynamic_inventory.html#using-multiple-inventory-sources)).\n\n  By default, this option is disabled and Vagrant generates an inventory based on the `Vagrantfile` information.\n\n- [`limit`](#limit) (string or array of strings) - Set of machines or groups from the inventory file to further control which hosts [are affected](https://docs.ansible.com/glossary.html#limit-groups).\n\n  The default value is set to the machine name (taken from `Vagrantfile`) to ensure that `vagrant provision` command only affect the expected machine.\n\n  Setting `limit = \"all\"` can be used to make Ansible connect to all machines from the inventory file.\n\n- [`playbook_command`](#playbook_command) (string) - The command used to run playbooks.\n\n  The default value is `ansible-playbook`\n\n- [`raw_arguments`](#raw_arguments) (array of strings) - a list of additional `ansible-playbook` arguments.\n\n  It is an *unsafe wildcard* that can be used to apply Ansible options that are not (yet) supported by this Vagrant provisioner. As of Vagrant 1.7, `raw_arguments` has the highest priority and its values can potentially override or break other Vagrant settings.\n\n  Examples:\n\n  - [`['--check', '-M', '/my/modules']`](#39-check-39-39-m-39-39-my-modules-39-)\n  - [`[\"--connection=paramiko\", \"--forks=10\"]`](#quot-connection-paramiko-quot-quot-forks-10-quot-)\n\n  > **Attention:** The `ansible` provisioner does not support whitespace characters in `raw_arguments` elements. Therefore **don't write** something like `[\"-c paramiko\"]`, which will result with an invalid `\" paramiko\"` parameter value.\n\n- [`skip_tags`](#skip_tags) (string or array of strings) - Only plays, roles and tasks that [*do not match* these values will be executed](https://docs.ansible.com/playbooks_tags.html).\n\n- [`start_at_task`](#start_at_task) (string) - The task name where the [playbook execution will start](https://docs.ansible.com/playbooks_startnstep.html#start-at-task).\n\n- [`sudo`](#sudo) (boolean) - Backwards compatible alias for the [`become`](#become) option.\n\n  > **Deprecation:** The `sudo` option is deprecated and will be removed in a future release. Please use the [**`become`**](#become) option instead.\n\n- [`sudo_user`](#sudo_user) (string) - Backwards compatible alias for the [`become_user`](#become_user) option.\n\n  > **Deprecation:** The `sudo_user` option is deprecated and will be removed in a future release. Please use the [**`become_user`**](#become_user) option instead.\n\n- [`tags`](#tags) (string or array of strings) - Only plays, roles and tasks [tagged with these values will be executed](https://docs.ansible.com/playbooks_tags.html) .\n\n- [`vault_password_file`](#vault_password_file) (string) - The path of a file containing the password used by [Ansible Vault](https://docs.ansible.com/playbooks_vault.html#vault).\n\n- [`verbose`](#verbose) (boolean or string) - Set Ansible's verbosity to obtain detailed logging\n\n  Default value is `false` (minimal verbosity).\n\n  Examples: `true` (equivalent to `v`), `-vvv` (equivalent to `vvv`), `vvvv`.\n\n  Note that when the `verbose` option is enabled, the `ansible-playbook` command used by Vagrant will be displayed.\n\n- [`version`](#version) (string) - The expected Ansible version.\n\n  This option is disabled by default.\n\n  When an Ansible version is defined (e.g. `\"2.1.6.0\"`), the Ansible provisioner will be executed only if Ansible is installed at the requested version.\n\n  When this option is set to `\"latest\"`, no version check is applied.\n\n  > **Tip:** With the `ansible_local` provisioner, it is currently possible to use this option to specify which version of Ansible must be automatically installed, but **only** in combination with the [**`install_mode`**](ansible_local#install_mode) set to **`:pip`**.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/ansible_common.html](https://www.vagrantup.com/docs/provisioning/ansible_common.html)"
- name: Shared Chef Options
  id: provisioning/chef_common
  summary: The following options are available to all Vagrant Chef provisioners
  description: "# Shared Chef Options\n\n## All Chef Provisioners\n\nThe following options are available to all Vagrant Chef provisioners. Many of these options are for advanced users only and should not be used unless you understand their purpose.\n\n- [`binary_path`](#binary_path) (string) - The path to Chef's `bin/` directory on the guest machine.\n\n- [`binary_env`](#binary_env) (string) - Arbitrary environment variables to set before running the Chef provisioner command. This should be of the format `KEY=value` as a string.\n\n- [`install`](#install) (boolean, string) - Install Chef on the system if it does not exist. The default value is \"true\", which will use the official Omnibus installer from Chef. This is a trinary attribute (it can have three values):\n\n  - [`true`](#true) (boolean) - install Chef\n  - [`false`](#false) (boolean) - do not install Chef\n  - [`\"force\"`](#quot-force-quot-) (string) - install Chef, even if it is already installed at the proper version on the guest\n\n- [`installer_download_path`](#installer_download_path) (string) - The path where the Chef installer will be downloaded to. This option is only honored if the `install` attribute is `true` or `\"force\"`. The default value is to use the path provided by Chef's Omnibus installer, which varies between releases. This value has no effect on Windows because Chef's omnibus installer lacks the option on Windows.\n\n- [`log_level`](#log_level) (string) - The Chef log level. See the Chef docs for acceptable values.\n\n- [`product`](#product) (string) - The name of the Chef product to install. The default value is \"chef\", which corresponds to the Chef Client. You can also specify \"chefdk\", which will install the Chef Development Kit. At the time of this writing, the ChefDK is only available through the \"current\" channel, so you will need to update that value as well.\n\n- [`channel`](#channel) (string) - The release channel from which to pull the Chef Client or the Chef Development Kit. The default value is `\"stable\"` which will pull the latest stable version of the Chef Client. For newer versions, or if you wish to install the Chef Development Kit, you may need to change the channel to \"current\". Because Chef Software floats the versions that are contained in the channel, they may change and Vagrant is unable to detect this.\n\n- [`version`](#version) (string) - The version of Chef to install on the guest. If Chef is already installed on the system, the installed version is compared with the requested version. If they match, no action is taken. If they do not match, the value specified in this attribute will be installed in favor of the existing version (a message will be displayed). You can also specify \"latest\" (default), which will install the latest version of Chef on the system. In this case, Chef will use whatever version is on the system. To force the newest version of Chef to be installed on every provision, set the [`install`](#install) option to \"force\".\n\n- [`omnibus_url`](#omnibus_url) (string) - Location of Omnibus installation scripts. This URL specifies the location of install.sh/install.ps1 for Linux/Unix and Windows respectively. It defaults to <https://omnitruck.chef.io>. The full URL is in this case:\n\n  - Linux/Unix: <https://omnitruck.chef.io/install.sh>\n  - Windows: <https://omnitruck.chef.io/install.ps1>\n\nIf you want to have <https://example.com/install.sh> as Omnibus script for your Linux/Unix installations, you should set this option to <https://example.com>\n\n## Runner Chef Provisioners\n\nThe following options are available to any of the Chef \"runner\" provisioners which include [Chef Solo](chef_solo), [Chef Zero](chef_zero), and [Chef Client](chef_client).\n\n- [`arguments`](#arguments) (string) - A list of additional arguments to pass on the command-line to Chef. Since these are passed in a shell-like environment, be sure to properly quote and escape characters if necessary. By default, no additional arguments are sent.\n\n- [`attempts`](#attempts) (int) - The number of times Chef will be run if an error occurs. This defaults to 1. This can be increased to a higher number if your Chef runs take multiple runs to reach convergence.\n\n- [`custom_config_path`](#custom_config_path) (string) - A path to a custom Chef configuration local on your machine that will be used as the Chef configuration. This Chef configuration will be loaded *after* the Chef configuration that Vagrant generates, allowing you to override anything that Vagrant does. This is also a great way to use new Chef features that may not be supported fully by Vagrant's abstractions yet.\n\n- [`encrypted_data_bag_secret_key_path`](#encrypted_data_bag_secret_key_path) (string) - The path to the secret key file to decrypt encrypted data bags. By default, this is not set.\n\n- [`environment`](#environment) (string) - The environment you want the Chef run to be a part of.\n\n- [`formatter`](#formatter) (string) - The formatter to use for output from Chef.\n\n- [`http_proxy`](#http_proxy), `http_proxy_user`, `http_proxy_pass`, `no_proxy` (string) - Settings to configure HTTP and HTTPS proxies to use from Chef. These settings are also available with `http` replaced with `https` to configure HTTPS proxies.\n\n- [`json`](#json) (hash) - Custom node attributes to pass into the Chef run.\n\n- [`log_level`](#log_level-1) (string) - The log level for Chef output. This defaults to \"info\".\n\n- [`node_name`](#node_name) (string) - The node name for the Chef Client. By default this will be your hostname.\n\n- [`provisioning_path`](#provisioning_path) (string) - The path on the remote machine where Vagrant will store all necessary files for provisioning such as cookbooks, configurations, etc. This path must be world writable. By default this is `/tmp/vagrant-chef-#` where \"#\" is replaced by a unique counter.\n\n- [`run_list`](#run_list) (array) - The run list that will be executed on the node.\n\n- [`file_cache_path`](#file_cache_path) and `file_backup_path` (string) - Paths on the remote machine where files will be cached and backed up. It is useful sometimes to configure this to a synced folder address so that this can be shared across many Vagrant runs.\n\n- [`verbose_logging`](#verbose_logging) (boolean) - Whether or not to enable the Chef `verbose_logging` option. By default this is false.\n\n- [`enable_reporting`](#enable_reporting) (boolean) - Whether or not to enable the Chef `enable_reporting` option. By default this is true.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/chef_common.html](https://www.vagrantup.com/docs/provisioning/chef_common.html)"
- name: Shell Provisioner
  id: provisioning/shell
  summary: The Vagrant Shell provisioner allows you to upload and execute a script within the guest machine
  description: "# Shell Provisioner\n\n**Provisioner name: `\"shell\"`**\n\nThe Vagrant Shell provisioner allows you to upload and execute a script within the guest machine.\n\nShell provisioning is ideal for users new to Vagrant who want to get up and running quickly and provides a strong alternative for users who are not comfortable with a full configuration management system such as Chef or Puppet.\n\nFor POSIX-like machines, the shell provisioner executes scripts with SSH. For Windows guest machines that are configured to use WinRM, the shell provisioner executes PowerShell and Batch scripts over WinRM.\n\n## Options\n\nThe shell provisioner takes various options. One of `inline` or `path` is required:\n\n- [`inline`](#inline) (string) - Specifies a shell command inline to execute on the remote machine. See the [inline scripts](#inline-scripts) section below for more information.\n\n- [`path`](#path) (string) - Path to a shell script to upload and execute. It can be a script relative to the project Vagrantfile or a remote script (like a [gist](https://gist.github.com)).\n\nThe remainder of the available options are optional:\n\n- [`args`](#args) (string or array) - Arguments to pass to the shell script when executing it as a single string. These arguments must be written as if they were typed directly on the command line, so be sure to escape characters, quote, etc. as needed. You may also pass the arguments in using an array. In this case, Vagrant will handle quoting for you.\n\n- [`env`](#env) (hash) - List of key-value pairs to pass in as environment variables to the script. Vagrant will handle quoting for environment variable values, but the keys remain untouched.\n\n- [`binary`](#binary) (boolean) - Vagrant automatically replaces Windows line endings with Unix line endings. If this is false, then Vagrant will not do this. By default this is \"false\". If the shell provisioner is communicating over WinRM, this defaults to \"true\".\n\n- [`privileged`](#privileged) (boolean) - Specifies whether to execute the shell script as a privileged user or not (`sudo`). By default this is \"true\". Windows guests use a scheduled task to run as a true administrator without the WinRM limitations.\n\n- [`upload_path`](#upload_path) (string) - Is the remote path where the shell script will be uploaded to. The script is uploaded as the SSH user over SCP, so this location must be writable to that user. By default this is \"/tmp/vagrant-shell\". On Windows, this will default to \"C:\\tmp\\vagrant-shell\".\n\n- [`keep_color`](#keep_color) (boolean) - Vagrant automatically colors output in green and red depending on whether the output is from stdout or stderr. If this is true, Vagrant will not do this, allowing the native colors from the script to be outputted.\n\n- [`name`](#name) (string) - This value will be displayed in the output so that identification by the user is easier when many shell provisioners are present.\n\n- [`powershell_args`](#powershell_args) (string) - Extra arguments to pass to `PowerShell` if you are provisioning with PowerShell on Windows.\n\n- [`powershell_elevated_interactive`](#powershell_elevated_interactive) (boolean) - Run an elevated script in interactive mode on Windows. By default this is \"false\". Must also be `privileged`. Be sure to enable auto-login for Windows as the user must be logged in for interactive mode to work.\n\n- [`md5`](#md5) (string) - MD5 checksum used to validate remotely downloaded shell files.\n\n- [`sha1`](#sha1) (string) - SHA1 checksum used to validate remotely downloaded shell files.\n\n- [`sensitive`](#sensitive) (boolean) - Marks the Hash values used in the `env` option as sensitive and hides them from output. By default this is \"false\".\n\n## Inline Scripts\n\nPerhaps the easiest way to get started is with an inline script. An inline script is a script that is given to Vagrant directly within the Vagrantfile. An example is best:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\",\n    inline: \"echo Hello, World\"\nend\n```\n\nThis causes `echo Hello, World` to be run within the guest machine when provisioners are run.\n\nCombined with a little bit more Ruby, this makes it very easy to embed your shell scripts directly within your Vagrantfile. Another example below:\n\n``` ruby\n$script = <<-SCRIPT\necho I am provisioning...\ndate > /etc/vagrant_provisioned_at\nSCRIPT\n\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\", inline: $script\nend\n```\n\nI understand that if you are not familiar with Ruby, the above may seem very advanced or foreign. But do not fear, what it is doing is quite simple: the script is assigned to a global variable `$script`. This global variable contains a string which is then passed in as the inline script to the Vagrant configuration.\n\nOf course, if any Ruby in your Vagrantfile outside of basic variable assignment makes you uncomfortable, you can use an actual script file, documented in the next section.\n\nFor Windows guest machines, the inline script *must* be PowerShell. Batch scripts are not allowed as inline scripts.\n\n## External Script\n\nThe shell provisioner can also take an option specifying a path to a shell script on the host machine. Vagrant will then upload this script into the guest and execute it. An example:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\", path: \"script.sh\"\nend\n```\n\nRelative paths, such as above, are expanded relative to the location of the root Vagrantfile for your project. Absolute paths can also be used, as well as shortcuts such as `~` (home directory) and `..` (parent directory).\n\nIf you use a remote script as part of your provisioning process, you can pass in its URL as the `path` argument as well:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\", path: \"https://example.com/provisioner.sh\"\nend\n```\n\nIf you are running a Batch or PowerShell script for Windows, make sure that the external path has the proper extension (\".bat\" or \".ps1\"), because Windows uses this to determine what kind of file it is to execute. If you exclude this extension, it likely will not work.\n\nTo run a script already available on the guest you can use an inline script to invoke the remote script on the guest.\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\",\n    inline: \"/bin/sh /path/to/the/script/already/on/the/guest.sh\"\nend\n```\n\n## Script Arguments\n\nYou can parameterize your scripts as well like any normal shell script. These arguments can be specified to the shell provisioner. They should be specified as a string as they'd be typed on the command line, so be sure to properly escape anything:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\" do |s|\n    s.inline = \"echo $1\"\n    s.args   = \"'hello, world!'\"\n  end\nend\n```\n\nYou can also specify arguments as an array if you do not want to worry about quoting:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.provision \"shell\" do |s|\n    s.inline = \"echo $1\"\n    s.args   = [\"hello, world!\"]\n  end\nend\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/provisioning/shell.html](https://www.vagrantup.com/docs/provisioning/shell.html)"
- name: SMB
  id: synced-folders/smb
  summary: Vagrant can use SMB as a mechanism to create a bi-directional synced folder between the host machine and the Vagrant machine
  description: "# SMB\n\n**Synced folder type:** `smb`\n\nVagrant can use [SMB](https://en.wikipedia.org/wiki/Server_Message_Block) as a mechanism to create a bi-directional synced folder between the host machine and the Vagrant machine.\n\nSMB is built-in to Windows machines and provides a higher performance alternative to some other mechanisms such as VirtualBox shared folders.\n\n> SMB is currently only supported when the host machine is Windows or macOS. The guest machine can be Windows, Linux, or macOS.\n\n## Prerequisites\n\n### Windows Host\n\nTo use the SMB synced folder type on a Windows host, the machine must have PowerShell version 3 or later installed. In addition, when Vagrant attempts to create new SMB shares, or remove existing SMB shares, Administrator privileges will be required. Vagrant will request these privileges using UAC.\n\n### macOS Host\n\nTo use the SMB synced folder type on a macOS host, file sharing must be enabled for the local account. Enable SMB file sharing by following the instructions below:\n\n- Open \"System Preferences\"\n- Click \"Sharing\"\n- Check the \"On\" checkbox next to \"File Sharing\"\n- Click \"Options\"\n- Check \"Share files and folders using SMB\"\n- Check the \"On\" checkbox next to your username within \"Windows File Sharing\"\n- Click \"Done\"\n\nWhen Vagrant attempts to create new SMB shares, or remove existing SMB shares, root access will be required. Vagrant will request these privileges using `sudo` to run the `/usr/sbin/sharing` command. Adding the following to the system's `sudoers` configuration will allow Vagrant to manage SMB shares without requiring a password each time:\n\n``` highlight\nCmnd_Alias VAGRANT_SMB_ADD = /usr/sbin/sharing -a * -S * -s * -g * -n *\nCmnd_Alias VAGRANT_SMB_REMOVE = /usr/sbin/sharing -r *\nCmnd_Alias VAGRANT_SMB_LIST = /usr/sbin/sharing -l\nCmnd_Alias VAGRANT_SMB_PLOAD = /bin/launchctl load -w /System/Library/LaunchDaemons/com.apple.smb.preferences.plist\nCmnd_Alias VAGRANT_SMB_DLOAD = /bin/launchctl load -w /System/Library/LaunchDaemons/com.apple.smbd.plist\nCmnd_Alias VAGRANT_SMB_DSTART = /bin/launchctl start com.apple.smbd\n%admin ALL=(root) NOPASSWD: VAGRANT_SMB_ADD, VAGRANT_SMB_REMOVE, VAGRANT_SMB_LIST, VAGRANT_SMB_PLOAD, VAGRANT_SMB_DLOAD, VAGRANT_SMB_DSTART\n```\n\n### Guests\n\nThe destination machine must be able to mount SMB filesystems. On Linux the package to do this is usually called `smbfs` or `cifs`. Vagrant knows how to automatically install this for some operating systems.\n\n## Options\n\nThe SMB synced folder type has a variety of options it accepts:\n\n- [`smb_host`](#smb_host) (string) - The host IP where the SMB mount is located. If this is not specified, Vagrant will attempt to determine this automatically.\n\n- [`smb_password`](#smb_password) (string) - The password used for authentication to mount the SMB mount. This is the password for the username specified by `smb_username`. If this is not specified, Vagrant will prompt you for it. It is highly recommended that you do not set this, since it would expose your password directly in your Vagrantfile.\n\n- [`smb_username`](#smb_username) (string) - The username used for authentication to mount the SMB mount. This is the username to access the mount, *not* the username of the account where the folder is being mounted to. This is usually your Windows username. If you sign into a domain, specify it as `user@domain`. If this option is not specified, Vagrant will prompt you for it.\n\n## Example\n\nThe following is an example of using SMB to sync a folder:\n\n``` ruby\nVagrant.configure(\"2\") do |config|\n  config.vm.synced_folder \".\", \"/vagrant\", type: \"smb\"\nend\n```\n\n## Preventing Idle Disconnects\n\nOn Windows, if a file is not accessed for some period of time, it may disconnect from the guest and prevent the guest from accessing the SMB-mounted share. To prevent this, the following command can be used in a superuser shell. Note that you should research if this is the right option for you.\n\n``` highlight\nnet config server /autodisconnect:-1\n```\n\n## Common Issues\n\n### \"wrong fs type\" Error\n\nIf during mounting on Linux you are seeing an error message that includes the words \"wrong fs type,\" this is because the SMB kernel extension needs to be updated in the OS.\n\nIf updating the kernel extension is not an option, you can workaround the issue by specifying the following options on your synced folder:\n\n``` ruby\nmount_options: [\"username=USERNAME\",\"password=PASSWORD\"]\n```\n\nReplace \"USERNAME\" and \"PASSWORD\" with your SMB username and password.\n\nVagrant 1.8 changed SMB mounting to use the more secure credential file mechanism. However, many operating systems ship with an outdated filesystem type for SMB out of the box which does not support this. The above workaround reverts Vagrant to the insecure before, but causes it work.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/synced-folders/smb.html](https://www.vagrantup.com/docs/synced-folders/smb.html)"
- name: SSH Settings
  id: vagrantfile/ssh_settings
  summary: The settings within config.ssh relate to configuring how Vagrant will access your machine over SSH
  description: "# SSH Settings\n\n**Config namespace: `config.ssh`**\n\nThe settings within `config.ssh` relate to configuring how Vagrant will access your machine over SSH. As with most Vagrant settings, the defaults are typically fine, but you can fine tune whatever you would like.\n\n## Available Settings\n\n- [`config.ssh.username`](#config-ssh-username) (string) - This sets the username that Vagrant will SSH as by default. Providers are free to override this if they detect a more appropriate user. By default this is \"vagrant\", since that is what most public boxes are made as.\n\n- [`config.ssh.password`](#config-ssh-password) (string) - This sets a password that Vagrant will use to authenticate the SSH user. Note that Vagrant recommends you use key-based authentication rather than a password (see `private_key_path`) below. If you use a password, Vagrant will automatically insert a keypair if `insert_key` is true.\n\n- [`config.ssh.host`](#config-ssh-host) (string) - The hostname or IP to SSH into. By default this is empty, because the provider usually figures this out for you.\n\n- [`config.ssh.port`](#config-ssh-port) (integer) - The port to SSH into. By default this is port 22.\n\n- [`config.ssh.guest_port`](#config-ssh-guest_port) (integer) - The port on the guest that SSH is running on. This is used by some providers to detect forwarded ports for SSH. For example, if this is set to 22 (the default), and Vagrant detects a forwarded port to port 22 on the guest from port 4567 on the host, Vagrant will attempt to use port 4567 to talk to the guest if there is no other option.\n\n- [`config.ssh.private_key_path`](#config-ssh-private_key_path) (string, array of strings) - The path to the private key to use to SSH into the guest machine. By default this is the insecure private key that ships with Vagrant, since that is what public boxes use. If you make your own custom box with a custom SSH key, this should point to that private key. You can also specify multiple private keys by setting this to be an array. This is useful, for example, if you use the default private key to bootstrap the machine, but replace it with perhaps a more secure key later.\n\n- [`config.ssh.keys_only`](#config-ssh-keys_only) (boolean) - Only use Vagrant-provided SSH private keys (do not use any keys stored in ssh-agent). The default value is `true`.\n\n- [`config.ssh.verify_host_key`](#config-ssh-verify_host_key) (string, symbol) - Perform strict host-key verification. The default value is `:never`.\n\n- [`config.ssh.paranoid`](#config-ssh-paranoid) (boolean) - Perform strict host-key verification. The default value is `false`.\n\n  **Deprecation:** The `config.ssh.paranoid` option is deprecated and will be removed in a future release. Please use the `config.ssh.verify_host_key` option instead.\n\n- [`config.ssh.forward_agent`](#config-ssh-forward_agent) (boolean) - If `true`, agent forwarding over SSH connections is enabled. Defaults to false.\n\n- [`config.ssh.forward_x11`](#config-ssh-forward_x11) (boolean) - If `true`, X11 forwarding over SSH connections is enabled. Defaults to false.\n\n- [`config.ssh.forward_env`](#config-ssh-forward_env) (array of strings) - An array of host environment variables to forward to the guest. If you are familiar with OpenSSH, this corresponds to the `SendEnv` parameter.\n\n  ``` ruby\n  config.ssh.forward_env = [\"CUSTOM_VAR\"]\n  ```\n\n- [`config.ssh.insert_key`](#config-ssh-insert_key) (boolean) - If `true`, Vagrant will automatically insert a keypair to use for SSH, replacing Vagrant's default insecure key inside the machine if detected. By default, this is true.\n\n  This only has an effect if you do not already use private keys for authentication or if you are relying on the default insecure key. If you do not have to care about security in your project and want to keep using the default insecure key, set this to `false`.\n\n- [`config.ssh.proxy_command`](#config-ssh-proxy_command) (string) - A command-line command to execute that receives the data to send to SSH on stdin. This can be used to proxy the SSH connection. `%h` in the command is replaced with the host and `%p` is replaced with the port.\n\n- [`config.ssh.pty`](#config-ssh-pty) (boolean) - If `true`, pty will be used for provisioning. Defaults to false.\n\n  This setting is an *advanced feature* that should not be enabled unless absolutely necessary. It breaks some other features of Vagrant, and is really only exposed for cases where it is absolutely necessary. If you can find a way to not use a pty, that is recommended instead.\n\n  When pty is enabled, it is important to note that command output will *not* be streamed to the UI. Instead, the output will be delivered in full to the UI once the command has completed.\n\n- [`config.ssh.keep_alive`](#config-ssh-keep_alive) (boolean) - If `true`, this setting SSH will send keep-alive packets every 5 seconds by default to keep connections alive.\n\n- [`config.ssh.shell`](#config-ssh-shell) (string) - The shell to use when executing SSH commands from Vagrant. By default this is `bash -l`. Note that this has no effect on the shell you get when you run `vagrant ssh`. This configuration option only affects the shell to use when executing commands internally in Vagrant.\n\n- [`config.ssh.export_command_template`](#config-ssh-export_command_template) (string) - The template used to generate exported environment variables in the active session. This can be useful when using a Bourne incompatible shell like C shell. The template supports two variables which are replaced with the desired environment variable key and environment variable value: `%ENV_KEY%` and `%ENV_VALUE%`. The default template is:\n\n  ``` ruby\n  config.ssh.export_command_template = 'export %ENV_KEY%=\"%ENV_VALUE%\"'\n  ```\n\n- [`config.ssh.sudo_command`](#config-ssh-sudo_command) (string) - The command to use when executing a command with `sudo`. This defaults to `sudo -E -H %c`. The `%c` will be replaced by the command that is being executed.\n\n- [`config.ssh.compression`](#config-ssh-compression) (boolean) - If `false`, this setting will not include the compression setting when ssh'ing into a machine. If this is not set, it will default to `true` and `Compression=yes` will be enabled with ssh.\n\n- [`config.ssh.dsa_authentication`](#config-ssh-dsa_authentication) (boolean) - If `false`, this setting will not include `DSAAuthentication` when ssh'ing into a machine. If this is not set, it will default to `true` and `DSAAuthentication=yes` will be used with ssh.\n\n- [`config.ssh.extra_args`](#config-ssh-extra_args) (array of strings) - This settings value is passed directly into the ssh executable. This allows you to pass any arbitrary commands to do things such as reverse tunneling down into the ssh program. These options can either be single flags set as strings such as `\"-6\"` for IPV6 or an array of arguments such as `[\"-L\", \"8008:localhost:80\"]` for enabling a tunnel from host port 8008 to port 80 on guest.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html](https://www.vagrantup.com/docs/vagrantfile/ssh_settings.html)"
- name: SSH Sharing
  id: share/ssh
  summary: Vagrant share makes it trivially easy to allow remote SSH access to your Vagrant environment by supplying the --ssh flag to vagrant share
  description: "# SSH Sharing\n\nVagrant share makes it trivially easy to allow remote SSH access to your Vagrant environment by supplying the `--ssh` flag to `vagrant share`.\n\nEasy SSH sharing is incredibly useful if you want to give access to a colleague for troubleshooting ops issues. Additionally, it enables pair programming with a Vagrant environment, if you want!\n\nSSH sharing is disabled by default as a security measure. To enable SSH sharing, simply supply the `--ssh` flag when calling `vagrant share`.\n\n## Usage\n\nJust run `vagrant share --ssh`!\n\nWhen SSH sharing is enabled, Vagrant generates a brand new keypair for SSH access. The public key portion is automatically inserted into the Vagrant machine, and the private key portion is provided to the user connecting to the Vagrant share. This private key is encrypted using a password that you will be prompted for. This password is *never* transmitted across the network by Vagrant, and is an extra layer of security preventing anyone who may know your share name from easily accessing your machine.\n\nAfter running `vagrant share --ssh`, it will output the name of your share:\n\n``` highlight\n$ vagrant share --ssh\n==> default: Detecting network information for machine...\ndefault: Local machine address: 192.168.84.130\n==> default: Generating new SSH key...\ndefault: Please enter a password to encrypt the key:\ndefault: Repeat the password to confirm:\ndefault: Inserting generated SSH key into machine...\ndefault: Local HTTP port: disabled\ndefault: Local HTTPS port: disabled\ndefault: SSH Port: 2200\n==> default: Creating Vagrant Share session...\nshare: Cloning VMware VM: 'hashicorp/vagrant-share'. This can take some time...\nshare: Verifying vmnet devices are healthy...\nshare: Preparing network adapters...\nshare: Starting the VMware VM...\nshare: Waiting for machine to boot. This may take a few minutes...\nshare: SSH address: 192.168.84.134:22\nshare: SSH username: tc\nshare: SSH auth method: password\nshare:\nshare: Inserting generated public key within guest...\nshare: Removing insecure key from the guest if it's present...\nshare: Key inserted! Disconnecting and reconnecting using new SSH key...\nshare: Machine booted and ready!\nshare: Forwarding ports...\nshare: -- 31338 => 65534\nshare: -- 22 => 2202\nshare: SSH address: 192.168.84.134:22\nshare: SSH username: tc\nshare: SSH auth method: password\nshare: Configuring network adapters within the VM...\n==> share:\n==> share: Your Vagrant Share is running! Name: bazaar_wolf:sultan_oasis\n==> share:\n==> share: You're sharing with SSH access. This means that another can SSH to\n==> share: your Vagrant machine by running:\n==> share:\n==> share:   vagrant connect --ssh bazaar_wolf:sultan_oasis\n==> share:\n```\n\nAnyone can then SSH directly to your Vagrant environment by running `vagrant connect --ssh NAME` where NAME is the name of the share outputted previously.\n\n``` highlight\n$ vagrant connect --ssh bazaar_wolf:sultan_oasis\nLoading share 'bazaar_wolf:sultan_oasis'...\nThe SSH key to connect to this share is encrypted. You will\nrequire the password entered when creating the share to\ndecrypt it. Verify you have access to this password before\ncontinuing.\n\nPress enter to continue, or Ctrl-C to exit now.\nPassword for the private key:\nExecuting SSH...\nWelcome to Ubuntu 12.04.3 LTS (GNU/Linux 3.8.0-29-generic x86_64)\n\n * Documentation:  https://help.ubuntu.com/\nLast login: Fri Mar  7 17:44:50 2014 from 192.168.163.1\nvagrant@vagrant:~$\n```\n\nIf the private key is encrypted (the default behavior), then the connecting person will be prompted for the password to decrypt the private key.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/share/ssh.html](https://www.vagrantup.com/docs/share/ssh.html)"
- name: Synced Folders
  id: synced-folders/index
  summary: Synced folders enable Vagrant to sync a folder on the host machine to the guest machine, allowing you to continue working on your project's files on your host machine, but use the resources in the guest machine to compile or run your project
  description: "# Synced Folders\n\nSynced folders enable Vagrant to sync a folder on the host machine to the guest machine, allowing you to continue working on your project's files on your host machine, but use the resources in the guest machine to compile or run your project.\n\nBy default, Vagrant will share your project directory (the directory with the [Vagrantfile](../vagrantfile/index)) to `/vagrant`.\n\nRead the [basic usage](basic_usage) page to get started with synced folders.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/synced-folders/](https://www.vagrantup.com/docs/synced-folders/)"
- name: Tips & Tricks
  id: vagrantfile/tips
  summary: The Vagrantfile is a very flexible configuration format
  description: "# Tips & Tricks\n\nThe Vagrantfile is a very flexible configuration format. Since it is just Ruby, there is a lot you can do with it. However, in that same vein, since it is Ruby, there are a lot of ways you can shoot yourself in the foot. When using some of the tips and tricks on this page, please take care to use them correctly.\n\n## Loop Over VM Definitions\n\nIf you want to apply a slightly different configuration to many multi-machine machines, you can use a loop to do this. For example, if you wanted to create three machines:\n\n``` ruby\n(1..3).each do |i|\n  config.vm.define \"node-#{i}\" do |node|\n    node.vm.provision \"shell\",\n      inline: \"echo hello from node #{i}\"\n  end\nend\n```\n\n> **Warning:** The inner portion of multi-machine definitions and provider overrides are lazy-loaded. This can cause issues if you change the value of a variable used within the configs. For example, the loop below *does not work*:\n\n``` ruby\n# THIS DOES NOT WORK!\nfor i in 1..3 do\n  config.vm.define \"node-#{i}\" do |node|\n    node.vm.provision \"shell\",\n      inline: \"echo hello from node #{i}\"\n  end\nend\n```\n\nThe `for i in ...` construct in Ruby actually modifies the value of `i` for each iteration, rather than making a copy. Therefore, when you run this, every node will actually provision with the same text.\n\nThis is an easy mistake to make, and Vagrant cannot really protect against it, so the best we can do is mention it here.\n\n## Overwrite host locale in ssh session\n\nUsually, host locale environment variables are passed to guest. It may cause failures if the guest software do not support host locale. One possible solution is override locale in the `Vagrantfile`:\n\n``` ruby\nENV[\"LC_ALL\"] = \"en_US.UTF-8\"\n\nVagrant.configure(\"2\") do |config|\n  # ...\nend\n```\n\nThe change is only visible within the `Vagrantfile`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/tips.html](https://www.vagrantup.com/docs/vagrantfile/tips.html)"
- name: Uninstalling Vagrant
  id: installation/uninstallation
  summary: Uninstalling Vagrant is easy and straightforward
  description: "# Uninstalling Vagrant\n\nUninstalling Vagrant is easy and straightforward. You can either uninstall the Vagrant binary, the user data, or both. The sections below cover how to do this on every platform.\n\n## Removing the Vagrant Program\n\nRemoving the Vagrant program will remove the `vagrant` binary and all dependencies from your machine. After uninstalling the program, you can always [reinstall](index) again using standard methods.\n\nOn **Windows**\n\n> Uninstall using the add/remove programs section of the control panel\n\nOn **Mac OS X**:\n\n``` shell\nrm -rf /opt/vagrant\nrm -f /usr/local/bin/vagrant\nsudo pkgutil --forget com.vagrant.vagrant\n```\n\nOn **Linux**:\n\n``` shell\nrm -rf /opt/vagrant\nrm -f /usr/bin/vagrant\n```\n\n## Removing User Data\n\nRemoving the user data will remove all [boxes](../boxes), [plugins](../plugins/index), license files, and any stored state that may be used by Vagrant. Removing the user data effectively makes Vagrant think it is a fresh install.\n\nOn all platforms, remove the `~/.vagrant.d` directory to delete the user data. When debugging, the Vagrant support team may ask you to remove this directory. Before removing this directory, please make a backup.\n\nRunning Vagrant will automatically regenerate any data necessary to run, so it is safe to remove the user data at any time.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/installation/uninstallation.html](https://www.vagrantup.com/docs/installation/uninstallation.html)"
- name: Upgrading From Vagrant 1.0.x
  id: installation/upgrading-from-1-0
  summary: The upgrade process from 1.0.x to 1.x is straightforward
  description: "# Upgrading From Vagrant 1.0.x\n\nThe upgrade process from 1.0.x to 1.x is straightforward. Vagrant is quite [backwards compatible](backwards-compatibility) with Vagrant 1.0.x, so you can simply reinstall Vagrant over your previous installation by downloading the latest package and installing it using standard procedures for your operating system.\n\nAs the [backwards compatibility](backwards-compatibility) page says, **Vagrant 1.0.x plugins will not work with Vagrant 1.1+**. Many of these plugins have been updated to work with newer versions of Vagrant, so you can look to see if they've been updated. If not however, you will have to remove them before upgrading.\n\nIt is recommended you remove *all* plugins before upgrading, and then slowly add back the plugins. This usually makes for a smoother upgrade process.\n\n> **If your version of Vagrant was installed via Rubygems**, you must uninstall the old version prior to installing the package for the new version of Vagrant. The Rubygems installation is no longer supported.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/installation/upgrading-from-1-0.html](https://www.vagrantup.com/docs/installation/upgrading-from-1-0.html)"
- name: Upgrading Vagrant
  id: installation/upgrading
  summary: If you are upgrading from Vagrant 1.0.x, please read the specific page dedicated to that
  description: "# Upgrading Vagrant\n\nIf you are upgrading from Vagrant 1.0.x, please read the [specific page dedicated to that](upgrading-from-1-0). This page covers upgrading Vagrant in general during the 1.x series.\n\nVagrant upgrades during the 1.x release series are straightforward:\n\n1.  [Download](https://www.vagrantup.com/downloads.html) the new package\n2.  Install it over the existing package\n\nThe installers will properly overwrite and remove old files. It is recommended that no other Vagrant processes are running during the upgrade process.\n\nNote that Vagrantfile stability for the new Vagrantfile syntax is not promised until 2.0 final. So while Vagrantfiles made for 1.0.x will [continue to work](backwards-compatibility), newer Vagrantfiles may have backwards incompatible changes until 2.0 final.\n\n> **Run into troubles upgrading?** Please [report an issue](https://github.com/hashicorp/vagrant/issues) if you run into problems upgrading. Upgrades are meant to be a smooth process and we consider it a bug if it was not.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/installation/upgrading.html](https://www.vagrantup.com/docs/installation/upgrading.html)"
- name: Usage
  id: virtualbox/usage
  summary: The Vagrant VirtualBox provider is used just like any other provider
  description: "# Usage\n\nThe Vagrant VirtualBox provider is used just like any other provider. Please read the general [basic usage](../providers/basic_usage) page for providers.\n\nThe value to use for the `--provider` flag is `virtualbox`.\n\nThe Vagrant VirtualBox provider does not support parallel execution at this time. Specifying the `--parallel` option will have no effect.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/virtualbox/usage.html](https://www.vagrantup.com/docs/virtualbox/usage.html)"
- name: Usage
  id: vmware/usage
  summary: The Vagrant VMware provider is used just like any other provider
  description: "# Usage\n\nThe Vagrant VMware provider is used just like any other provider. Please read the general [basic usage](../providers/basic_usage) page for providers.\n\nThe value to use for the `--provider` flag is `vmware_desktop`. For compatibility with older versions of the plugin, `vmware_fusion` can be used for VMware Fusion, and `vmware_workstation` for VMware Workstation.\n\nThe Vagrant VMware provider does not support parallel execution at this time. Specifying the `--parallel` option will have no effect.\n\nTo get started, create a new `Vagrantfile` that points to a VMware box:\n\n``` ruby\n# vagrant init hashicorp/precise64\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"hashicorp/precise64\"\nend\n```\n\nThen run:\n\n``` shell\n$ vagrant up --provider vmware_desktop\n```\n\nThis will download and bring up a new VMware Fusion/Workstation virtual machine in Vagrant.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vmware/usage.html](https://www.vagrantup.com/docs/vmware/usage.html)"
- name: Usage
  id: hyperv/usage
  summary: The Vagrant Hyper-V provider is used just like any other provider
  description: "# Usage\n\nThe Vagrant Hyper-V provider is used just like any other provider. Please read the general [basic usage](../providers/basic_usage) page for providers.\n\nThe value to use for the `--provider` flag is `hyperv`.\n\nHyper-V also requires that you execute Vagrant with administrative privileges. Creating and managing virtual machines with Hyper-V requires admin rights. Vagrant will show you an error if it does not have the proper permissions.\n\nBoxes for Hyper-V can be easily found on [HashiCorp's Vagrant Cloud](https://vagrantcloud.com/boxes/search). To get started, you might want to try the `hashicorp/precise64` box.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/hyperv/usage.html](https://www.vagrantup.com/docs/hyperv/usage.html)"
- name: Vagrant and Windows Subsystem for Linux
  id: other/wsl
  summary: Recent versions of Windows 10 now include Windows Subsystem for Linux (WSL) as an optional Windows feature
  description: "# Vagrant and Windows Subsystem for Linux\n\nRecent versions of Windows 10 now include Windows Subsystem for Linux (WSL) as an optional Windows feature. The WSL supports running a Linux environment within Windows. Vagrant support for WSL is still in development and should be considered *beta*.\n\n> **Warning: Advanced Topic!** Using Vagrant within the Windows Subsystem for Linux is an advanced topic that only experienced Vagrant users who are reasonably comfortable with Windows, WSL, and Linux should approach.\n\n## Vagrant Installation\n\nVagrant *must* be installed within the Linux distribution used with WSL. While the `vagrant.exe` executable provided by the Vagrant Windows installation is accessible from within the WSL, it will not function as expected.\n\nDownload the installer package for the Linux distribution from the releases page and install Vagrant.\n\n\\_*NOTE: When Vagrant is installed on the Windows system the version installed within the Linux distribution *must* match.*\n\n# Vagrant Usage\n\n## Windows Access\n\nBy default Vagrant will not access features available on the Windows system from within the WSL. This means the VirtualBox and Hyper-V providers will not be available. To enable Windows access, which will also enable the VirtualBox and Hyper-V providers, set the `VAGRANT_WSL_ENABLE_WINDOWS_ACCESS` environment variable:\n\n``` highlight\n$ export VAGRANT_WSL_ENABLE_WINDOWS_ACCESS=\"1\"\n```\n\nWhen Windows access is enabled Vagrant will automatically adjust `VAGRANT_HOME` to be located on the Windows host. This is required to ensure `VAGRANT_HOME` is located on a DrvFs file system.\n\n## PATH modifications\n\nVagrant will detect when it is being run within the WSL and adjust how it locates and executes third party executables. For example, when using the VirtualBox provider Vagrant will interact with VirtualBox installed on the Windows system, not within the WSL. It is important to ensure that any required Windows executable is available within your `PATH` to allow Vagrant to access them.\n\nFor example, when using the VirtualBox provider:\n\n``` highlight\nexport PATH=\"$PATH:/mnt/c/Program Files/Oracle/VirtualBox\"\n```\n\n## Synced Folders\n\nSupport for synced folders within the WSL is implementation dependent. In most cases synced folders will not be supported when running Vagrant within WSL on a VolFs file system. Synced folder implementations must \"opt-in\" to supporting usage from VolFs file systems. To use synced folders from within the WSL that do not support VolFs file systems, move the Vagrant project directory to a DrvFs file system location (/mnt/c/ prefixed path for example).\n\n## Windows Access\n\nWorking within the WSL provides a layer of isolation from the actual Windows system. In most cases Vagrant will need access to the actual Windows system to function correctly. As most Vagrant providers will need to be installed on Windows directly (not within the WSL) Vagrant will require Windows access. Access to the Windows system is controlled via an environment variable: `VAGRANT_WSL_ENABLE_WINDOWS_ACCESS`. If this environment variable is set, Vagrant will access the Windows system to run executables and enable things like synced folders. When running in a bash shell within WSL, the environment variable can be setup like so:\n\n``` highlight\n$ export VAGRANT_WSL_ENABLE_WINDOWS_ACCESS=\"1\"\n```\n\nThis will enable Vagrant to access the Windows system outside of the WSL and properly interact with Windows executables. This will automatically modify the `VAGRANT_HOME` environment variable if it is not already defined, setting it to be within the user's home directory on Windows.\n\nIt is important to note that paths shared with the Windows system will not have Linux permissions enforced. For example, when a directory within the WSL is synced to a guest using the VirtualBox provider, any local permissions defined on that directory (or its contents) will not be visible from the guest. Likewise, any files created from the guest within the synced folder will be world readable/writeable in WSL.\n\nOther useful WSL related environment variables:\n\n- [`VAGRANT_WSL_WINDOWS_ACCESS_USER`](#vagrant_wsl_windows_access_user) - Override current Windows username\n- [`VAGRANT_WSL_DISABLE_VAGRANT_HOME`](#vagrant_wsl_disable_vagrant_home) - Do not modify the `VAGRANT_HOME` variable\n- [`VAGRANT_WSL_WINDOWS_ACCESS_USER_HOME_PATH`](#vagrant_wsl_windows_access_user_home_path) - Custom Windows system home path\n\nIf a Vagrant project directory is not within the user's home directory on the Windows system, certain actions that include permission checks may fail (like `vagrant ssh`). When accessing Vagrant projects outside the WSL Vagrant will skip these permission checks when the project path is within the path defined in the `VAGRANT_WSL_WINDOWS_ACCESS_USER_HOME_PATH` environment variable. For example, if a user wants to run a Vagrant project from the WSL that is located at `C:\\TestDir\\vagrant-project`:\n\n``` highlight\nC:\\Users\\vagrant> cd C:\\TestDir\\vagrant-project\nC:\\TestDir\\vagrant-project> bash\nvagrant@vagrant-10:/mnt/c/TestDir/vagrant-project$ export VAGRANT_WSL_WINDOWS_ACCESS_USER_HOME_PATH=\"/mnt/c/TestDir\"\nvagrant@vagrant-10:/mnt/c/TestDir/vagrant-project$ vagrant ssh\n```\n\n## Using Docker\n\nThe docker daemon cannot be run inside the Windows Subsystem for Linux. However, the daemon *can* be run on Windows and accessed by Vagrant while running in the WSL. Once docker is installed and running on Windows, export the following environment variable to give Vagrant access:\n\n``` highlight\nvagrant@vagrant-10:/mnt/c/Users/vagrant$ export DOCKER_HOST=tcp://127.0.0.1:2375\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/other/wsl.html](https://www.vagrantup.com/docs/other/wsl.html)"
- name: vagrant box
  id: cli/box
  summary: This is the command used to manage (add, remove, etc.) boxes
  description: "# Box\n\n**Command: `vagrant box`**\n\nThis is the command used to manage (add, remove, etc.) [boxes](../boxes).\n\nThe main functionality of this command is exposed via even more subcommands:\n\n- [`add`](#box-add)\n- [`list`](#box-list)\n- [`outdated`](#box-outdated)\n- [`prune`](#box-prune)\n- [`remove`](#box-remove)\n- [`repackage`](#box-repackage)\n- [`update`](#box-update)\n\n# Box Add\n\n**Command: `vagrant box add ADDRESS`**\n\nThis adds a box with the given address to Vagrant. The address can be one of three things:\n\n- A shorthand name from the [public catalog of available Vagrant images](https://vagrantcloud.com/boxes/search), such as \"hashicorp/precise64\".\n\n- File path or HTTP URL to a box in a [catalog](https://vagrantcloud.com/boxes/search). For HTTP, basic authentication is supported and `http_proxy` environmental variables are respected. HTTPS is also supported.\n\n- URL directly a box file. In this case, you must specify a `--name` flag (see below) and versioning/updates will not work.\n\nIf an error occurs during the download or the download is interrupted with a Ctrl-C, then Vagrant will attempt to resume the download the next time it is requested. Vagrant will only attempt to resume a download for 24 hours after the initial download.\n\n## Options\n\n- [`--box-version VALUE`](#box-version-value) - The version of the box you want to add. By default, the latest version will be added. The value of this can be an exact version number such as \"1.2.3\" or it can be a set of version constraints. A version constraint looks like \"\\>= 1.0, \\< 2.0\".\n\n- [`--cacert CERTFILE`](#cacert-certfile) - The certificate for the CA used to verify the peer. This should be used if the remote end does not use a standard root CA.\n\n- [`--capath CERTDIR`](#capath-certdir) - The certificate directory for the CA used to verify the peer. This should be used if the remote end does not use a standard root CA.\n\n- [`--cert CERTFILE`](#cert-certfile) - A client certificate to use when downloading the box, if necessary.\n\n- [`--clean`](#clean) - If given, Vagrant will remove any old temporary files from prior downloads of the same URL. This is useful if you do not want Vagrant to resume a download from a previous point, perhaps because the contents changed.\n\n- [`--force`](#force) - When present, the box will be downloaded and overwrite any existing box with this name.\n\n- [`--insecure`](#insecure) - When present, SSL certificates will not be verified if the URL is an HTTPS URL.\n\n- [`--provider PROVIDER`](#provider-provider) - If given, Vagrant will verify the box you are adding is for the given provider. By default, Vagrant automatically detects the proper provider to use.\n\n## Options for direct box files\n\nThe options below only apply if you are adding a box file directly (when you are not using a catalog).\n\n- [`--checksum VALUE`](#checksum-value) - A checksum for the box that is downloaded. If specified, Vagrant will compare this checksum to what is actually downloaded and will error if the checksums do not match. This is highly recommended since box files are so large. If this is specified, `--checksum-type` must also be specified. If you are downloading from a catalog, the checksum is included within the catalog entry.\n\n- [`--checksum-type TYPE`](#checksum-type-type) - The type of checksum that `--checksum` is if it is specified. Supported values are currently \"md5\", \"sha1\", and \"sha256\".\n\n- [`--name VALUE`](#name-value) - Logical name for the box. This is the value that you would put into `config.vm.box` in your Vagrantfile. When adding a box from a catalog, the name is included in the catalog entry and does not have to be specified.\n\n> **Checksums for versioned boxes or boxes from HashiCorp's Vagrant Cloud:** For boxes from HashiCorp's Vagrant Cloud, the checksums are embedded in the metadata of the box. The metadata itself is served over TLS and its format is validated.\n\n# Box List\n\n**Command: `vagrant box list`**\n\nThis command lists all the boxes that are installed into Vagrant.\n\n# Box Outdated\n\n**Command: `vagrant box outdated`**\n\nThis command tells you whether or not the box you are using in your current Vagrant environment is outdated. If the `--global` flag is present, every installed box will be checked for updates.\n\nChecking for updates involves refreshing the metadata associated with a box. This generally requires an internet connection.\n\n## Options\n\n- [`--global`](#global) - Check for updates for all installed boxes, not just the boxes for the current Vagrant environment.\n\n# Box Prune\n\n**Command: `vagrant box prune`**\n\nThis command removes old versions of installed boxes. If the box is currently in use vagrant will ask for confirmation.\n\n## Options\n\n- [`--provider PROVIDER`](#provider-provider-1) - The specific provider type for the boxes to destroy.\n\n- [`--dry-run`](#dry-run) - Only print the boxes that would be removed.\n\n- [`--name NAME`](#name-name) - The specific box name to check for outdated versions.\n\n- [`--force`](#force-1) - Destroy without confirmation even when box is in use.\n\n# Box Remove\n\n**Command: `vagrant box remove NAME`**\n\nThis command removes a box from Vagrant that matches the given name.\n\nIf a box has multiple providers, the exact provider must be specified with the `--provider` flag. If a box has multiple versions, you can select what versions to delete with the `--box-version` flag or remove all versions with the `--all` flag.\n\n## Options\n\n- [`--box-version VALUE`](#box-version-value-1) - Version of version constraints of the boxes to remove. See documentation on this flag for `box add` for more details.\n\n- [`--all`](#all) - Remove all available versions of a box.\n\n- [`--force`](#force-2) - Forces removing the box even if an active Vagrant environment is using it.\n\n- [`--provider VALUE`](#provider-value) - The provider-specific box to remove with the given name. This is only required if a box is backed by multiple providers. If there is only a single provider, Vagrant will default to removing it.\n\n# Box Repackage\n\n**Command: `vagrant box repackage NAME PROVIDER VERSION`**\n\nThis command repackages the given box and puts it in the current directory so you can redistribute it. The name, provider, and version of the box can be retrieved using `vagrant box list`.\n\nWhen you add a box, Vagrant unpacks it and stores it internally. The original `*.box` file is not preserved. This command is useful for reclaiming a `*.box` file from an installed Vagrant box.\n\n# Box Update\n\n**Command: `vagrant box update`**\n\nThis command updates the box for the current Vagrant environment if there are updates available. The command can also update a specific box (outside of an active Vagrant environment), by specifying the `--box` flag.\n\n*Note that updating the box will not update an already-running Vagrant machine. To reflect the changes in the box, you will have to destroy and bring back up the Vagrant machine.*\n\nIf you just want to check if there are updates available, use the `vagrant box outdated` command.\n\n## Options\n\n- [`--box VALUE`](#box-value) - Name of a specific box to update. If this flag is not specified, Vagrant will update the boxes for the active Vagrant environment.\n\n- [`--provider VALUE`](#provider-value-1) - When `--box` is present, this controls what provider-specific box to update. This is not required unless the box has multiple providers. Without the `--box` flag, this has no effect.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/box.html](https://www.vagrantup.com/docs/cli/box.html)"
- name: vagrant cloud
  id: cli/cloud
  summary: This is the command used to manage anything related to Vagrant Cloud
  description: "# Cloud\n\n**Command: `vagrant cloud`**\n\nThis is the command used to manage anything related to [Vagrant Cloud](https://vagrantcloud.com).\n\nThe main functionality of this command is exposed via subcommands:\n\n- [`auth`](#cloud-auth)\n- [`box`](#cloud-box)\n- [`provider`](#cloud-provider)\n- [`publish`](#cloud-publish)\n- [`search`](#cloud-search)\n- [`version`](#cloud-version)\n\n# Cloud Auth\n\n**Command: `vagrant cloud auth`**\n\nThe `cloud auth` command is for handling all things related to authorization with Vagrant Cloud.\n\n- [`login`](#cloud-auth-login)\n- [`logout`](#cloud-auth-logout)\n- [`whoami`](#cloud-auth-whoami)\n\n## Cloud Auth Login\n\n**Command: `vagrant cloud auth login`**\n\nThe login command is used to authenticate with [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud) server. Logging in is only necessary if you are accessing protected boxes.\n\n**Logging in is not a requirement to use Vagrant.** The vast majority of Vagrant does *not* require a login. Only certain features such as protected boxes.\n\nThe reference of available command-line flags to this command is available below.\n\n### Options\n\n- [`--check`](#check) - This will check if you are logged in. In addition to outputting whether you are logged in or not, the command exit status will be 0 if you are logged in, or 1 if you are not.\n\n- [`--logout`](#logout) - This will log you out if you are logged in. If you are already logged out, this command will do nothing. It is not an error to call this command if you are already logged out.\n\n- [`--token`](#token) - This will set the Vagrant Cloud login token manually to the provided string. It is assumed this token is a valid Vagrant Cloud access token.\n\n### Examples\n\nSecurely authenticate to Vagrant Cloud using a username and password:\n\n``` highlight\n$ vagrant cloud auth login\n# ...\nVagrant Cloud username:\nVagrant Cloud password:\n```\n\nCheck if the current user is authenticated:\n\n``` highlight\n$ vagrant cloud auth login --check\nYou are already logged in.\n```\n\nSecurely authenticate with Vagrant Cloud using a token:\n\n``` highlight\n$ vagrant cloud auth login --token ABCD1234\nThe token was successfully saved.\n```\n\n## Cloud Auth Logout\n\n**Command: `vagrant cloud auth logout`**\n\nThis will log you out if you are logged in. If you are already logged out, this command will do nothing. It is not an error to call this command if you are already logged out.\n\n## Cloud Auth Whomi\n\n**Command: `vagrant cloud auth whoami [TOKEN]`**\n\nThis command will validate your Vagrant Cloud token and will print the user who it belongs to. If a token is passed in, it will attempt to validate it instead of the token stored stored on disk.\n\n# Cloud Box\n\n**Command: `vagrant cloud box`**\n\nThe `cloud box` command is used to manage life cycle operations for all `box` entities on Vagrant Cloud.\n\n- [`create`](#cloud-box-create)\n- [`delete`](#cloud-box-delete)\n- [`show`](#cloud-box-show)\n- [`update`](#cloud-box-update)\n\n## Cloud Box Create\n\n**Command: `vagrant cloud box create ORGANIZATION/BOX-NAME`**\n\nThe box create command is used to create a new box entry on Vagrant Cloud.\n\n### Options\n\n- [`--description DESCRIPTION`](#description-description) - A full description of the box. Can be formatted with Markdown.\n- [`--short-description DESCRIPTION`](#short-description-description) - A short summary of the box.\n- [`--private`](#private) - Will make the new box private (Public by default)\n\n## Cloud Box Delete\n\n**Command: `vagrant cloud box delete ORGANIZATION/BOX-NAME`**\n\nThe box delete command will *permanently* delete the given box entry on Vagrant Cloud. Before making the request, it will ask if you are sure you want to delete the box.\n\n## Cloud Box Show\n\n**Command: `vagrant cloud box show ORGANIZATION/BOX-NAME`**\n\nThe box show command will display information about the latest version for the given Vagrant box.\n\n## Cloud Box Update\n\n**Command: `vagrant cloud box update ORGANIZATION/BOX-NAME`**\n\nThe box update command will update an already created box on Vagrant Cloud with the given options.\n\n### Options\n\n- [`--description DESCRIPTION`](#description-description-1) - A full description of the box. Can be formatted with Markdown.\n- [`--short-description DESCRIPTION`](#short-description-description-1) - A short summary of the box.\n- [`--private`](#private-1) - Will make the new box private (Public by default)\n\n# Cloud Provider\n\n**Command: `vagrant cloud provider`**\n\nThe `cloud provider` command is used to manage the life cycle operations for all `provider` entities on Vagrant Cloud.\n\n- [`create`](#cloud-provider-create)\n- [`delete`](#cloud-provider-delete)\n- [`update`](#cloud-provider-update)\n- [`upload`](#cloud-provider-upload)\n\n## Cloud Provider Create\n\n**Command: `vagrant cloud provider create ORGANIZATION/BOX-NAME PROVIDER-NAME VERSION [URL]`**\n\nThe provider create command is used to create a new provider entry on Vagrant Cloud. The `url` argument is expected to be a remote URL that Vagrant Cloud can use to download the provider. If no `url` is specified, the provider entry can be updated later with a url or the [upload](#cloud-provider-upload) command can be used to upload a Vagrant [box file](../boxes).\n\n## Cloud Provider Delete\n\n**Command: `vagrant cloud provider delete ORGANIZATION/BOX-NAME PROVIDER-NAME VERSION`**\n\nThe provider delete command is used to delete a provider entry on Vagrant Cloud. Before making the request, it will ask if you are sure you want to delete the provider.\n\n## Cloud Provider Update\n\n**Command: `vagrant cloud provider update ORGANIZATION/BOX-NAME PROVIDER-NAME VERSION [URL]`**\n\nThe provider update command will update an already created provider for a box on Vagrant Cloud with the given options.\n\n## Cloud Provider Upload\n\n**Command: `vagrant cloud provider upload ORGANIZATION/BOX-NAME PROVIDER-NAME VERSION BOX-FILE`**\n\nThe provider upload command will upload a Vagrant [box file](../boxes) to Vagrant Cloud for the specified version and provider.\n\n# Cloud Publish\n\n**Command: `vagrant cloud publish ORGANIZATION/BOX-NAME VERSION PROVIDER-NAME [PROVIDER-FILE]`**\n\nThe publish command is a complete solution for creating and updating a Vagrant box on Vagrant Cloud. Instead of having to create each attribute of a Vagrant box with separate commands, the publish command instead asks you to provide all the information required before creating or updating a new box.\n\n## Options\n\n- [`--box-version VERSION`](#box-version-version) - Version to create for the box\n- [`--description DESCRIPTION`](#description-description-2) - A full description of the box. Can be formatted with Markdown.\n- [`--force`](#force) - Disables confirmation when creating or updating a box.\n- [`--short-description DESCRIPTION`](#short-description-description-2) - A short summary of the box.\n- [`--private`](#private-2) - Will make the new box private (Public by default)\n- [`--release`](#release) - Automatically releases the box after creation (Unreleased by default)\n- [`--url`](#url) - Valid remote URL to download the box file\n- [`--version-description DESCRIPTION`](#version-description-description) - Description of the version that will be created.\n\n## Examples\n\nCreating a new box on Vagrant Cloud:\n\n``` highlight\n$ vagrant cloud publish briancain/supertest 1.0.0 virtualbox boxes/my/virtualbox.box -d \"A really cool box to download and use\" --version-description \"A cool version\" --release --short-description \"Donwload me!\"\nYou are about to create a box on Vagrant Cloud with the following options:\nbriancain/supertest (1.0.0) for virtualbox\nAutomatic Release:     true\nBox Description:       A really cool box to download and use\nBox Short Description: Download me!\nVersion Description:   A cool version\nDo you wish to continue? [y/N] y\nCreating a box entry...\nCreating a version entry...\nCreating a provider entry...\nUploading provider with file /Users/vagrant/boxes/my/virtualbox.box\nReleasing box...\nComplete! Published briancain/supertest\ntag:                  briancain/supertest\nusername:             briancain\nname:                 supertest\nprivate:              false\ndownloads:            0\ncreated_at:           2018-07-25T17:53:04.340Z\nupdated_at:           2018-07-25T18:01:10.665Z\nshort_description:    Download me!\ndescription_markdown: A reall cool box to download and use\ncurrent_version:      1.0.0\nproviders:            virtualbox\n```\n\n# Cloud Search\n\n**Command: `vagrant cloud search QUERY`**\n\nThe cloud search command will take a query and search Vagrant Cloud for any matching Vagrant boxes. Various filters can be applied to the results.\n\n## Options\n\n- [`--json`](#json) - Format search results in JSON.\n- [`--page PAGE`](#page-page) - The page to display. Defaults to the first page of results.\n- [`--short`](#short) - Shows a simple list of box names for the results.\n- [`--order ORDER`](#order-order) - Order to display results. Can either be `desc` or `asc`. Defaults to `desc`.\n- [`--limit LIMIT`](#limit-limit) - Max number of search results to display. Defaults to 25.\n- [`--provider PROVIDER`](#provider-provider) - Filter search results to a single provider.\n- [`--sort-by SORT`](#sort-by-sort) - The field to sort results on. Can be `created`, `downloads` , or `updated`. Defaults to `downloads`.\n\n## Examples\n\nIf you are looking for a HashiCorp box:\n\n``` highlight\nvagrant cloud search hashicorp --limit 5\n| NAME                    | VERSION | DOWNLOADS | PROVIDERS                       |\n+-------------------------+---------+-----------+---------------------------------+\n| hashicorp/precise64     | 1.1.0   | 6,675,725 | virtualbox,vmware_fusion,hyperv |\n| hashicorp/precise32     | 1.0.0   | 2,261,377 | virtualbox                      |\n| hashicorp/boot2docker   | 1.7.8   |    59,284 | vmware_desktop,virtualbox       |\n| hashicorp/connect-vm    | 0.1.0   |     6,912 | vmware_desktop,virtualbox       |\n| hashicorp/vagrant-share | 0.1.0   |     3,488 | vmware_desktop,virtualbox       |\n+-------------------------+---------+-----------+---------------------------------+\n```\n\n# Cloud Version\n\n**Command: `vagrant cloud version`**\n\nThe `cloud version` command is used to manage life cycle operations for all `version` entities for a box on Vagrant Cloud.\n\n- [`create`](#cloud-version-create)\n- [`delete`](#cloud-version-delete)\n- [`release`](#cloud-version-release)\n- [`revoke`](#cloud-version-revoke)\n- [`update`](#cloud-version-update)\n\n## Cloud Version Create\n\n**Command: `vagrant cloud version create ORGANIZATION/BOX-NAME VERSION`**\n\nThe cloud create command creates a version entry for a box on Vagrant Cloud.\n\n### Options\n\n- [`--description DESCRIPTION`](#description-description-3) - Description of the version that will be created.\n\n## Cloud Version Delete\n\n**Command: `vagrant cloud version delete ORGANIZATION/BOX-NAME VERSION`**\n\nThe cloud delete command deletes a version entry for a box on Vagrant Cloud. Before making the request, it will ask if you are sure you want to delete the version.\n\n## Cloud Version Release\n\n**Command: `vagrant cloud version release ORGANIZATION/BOX-NAME VERSION`**\n\nThe cloud release command releases a version entry for a box on Vagrant Cloud if it already exists. Before making the request, it will ask if you are sure you want to release the version.\n\n## Cloud Version Revoke\n\n**Command: `vagrant cloud version revoke ORGANIZATION/BOX-NAME VERSION`**\n\nThe cloud revoke command revokes a version entry for a box on Vagrant Cloud if it already exists. Before making the request, it will ask if you are sure you want to revoke the version.\n\n## Cloud Version Update\n\n**Command: `vagrant cloud version update ORGANIZATION/BOX-NAME VERSION`**\n\n### Options\n\n- [`--description DESCRIPTION`](#description-description-4) - Description of the version that will be created.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/cloud.html](https://www.vagrantup.com/docs/cli/cloud.html)"
- name: vagrant connect
  id: cli/connect
  summary: The connect command complements the share command by enabling access to shared environments
  description: "# Connect\n\n**Command: `vagrant connect NAME`**\n\nThe connect command complements the [share command](share) by enabling access to shared environments. You can learn about all the details of Vagrant Share in the [Vagrant Share section](../share/index).\n\nThe reference of available command-line flags to this command is available below.\n\n## Options\n\n- [`--disable-static-ip`](#disable-static-ip) - The connect command will not spin up a small virtual machine to create a static IP you can access. When this flag is set, the only way to access the connection is to use the SOCKS proxy address outputted.\n\n- [`--static-ip IP`](#static-ip-ip) - Tells connect what static IP address to use for the virtual machine. By default, Vagrant connect will use an IP address that looks available in the 172.16.0.0/16 space.\n\n- [`--ssh`](#ssh) - Connects via SSH to an environment shared with `vagrant share --ssh`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/connect.html](https://www.vagrantup.com/docs/cli/connect.html)"
- name: Vagrant Connect
  id: share/connect
  summary: Vagrant can share any or every port to your Vagrant environment, not just SSH and HTTP
  description: "# Vagrant Connect\n\nVagrant can share any or *every* port to your Vagrant environment, not just SSH and HTTP. The `vagrant connect` command gives the connecting person a static IP they can use to communicate to the shared Vagrant environment. Any TCP traffic sent to this IP is sent to the shared Vagrant environment.\n\n## Usage\n\nJust call `vagrant share --full`. This will automatically share as many ports as possible for remote connections. Please see [the Vagrant share security page](security) for more information.\n\nNote the share name at the end of calling `vagrant share --full`, and give this to the person who wants to connect to your machine. They simply have to call `vagrant connect NAME`. This will give them a static IP they can use to access your Vagrant environment.\n\n## How does it work?\n\n`vagrant connect` works by doing what Vagrant does best: managing virtual machines. `vagrant connect` creates a tiny virtual machine that takes up only around 20 MB in RAM, using VirtualBox or VMware (more provider support is coming soon).\n\nAny traffic sent to this tiny virtual machine is then proxied through to the shared Vagrant environment as if it were directed at it.\n\n## Beware: Vagrant Insecure Key\n\nIf the Vagrant environment or box you are using is protected with the Vagrant insecure keypair (most public boxes are), then SSH will be easily available to anyone who connects.\n\nWhile hopefully you are sharing with someone you trust, in certain environments you might be sharing with a class, or a conference, and you do not want them to be able to SSH in.\n\nIn this case, we recommend changing or removing the insecure key from the Vagrant machine.\n\nFinally, we want to note that we are working on making it so that when Vagrant share is used, the Vagrant private key is actively rejected unless explicitly allowed. This feature is not yet done, however.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/share/connect.html](https://www.vagrantup.com/docs/share/connect.html)"
- name: vagrant destroy
  id: cli/destroy
  summary: This command stops the running machine Vagrant is managing and destroys all resources that were created during the machine creation process
  description: "# Destroy\n\n**Command: `vagrant destroy [name|id]`**\n\nThis command stops the running machine Vagrant is managing and destroys all resources that were created during the machine creation process. After running this command, your computer should be left at a clean state, as if you never created the guest machine in the first place.\n\nFor linux-based guests, Vagrant uses the `shutdown` command to gracefully terminate the machine. Due to the varying nature of operating systems, the `shutdown` command may exist at many different locations in the guest's `$PATH`. It is the guest machine's responsibility to properly populate the `$PATH` with directory containing the `shutdown` command.\n\n## Options\n\n- [`-f`](#f) or `--force` - Do not ask for confirmation before destroying.\n- [`--[no-]parallel`](#no-parallel) - Destroys multiple machines in parallel if the provider supports it. Please consult the provider documentation to see if this feature is supported.\n\n> The `destroy` command does not remove a box that may have been installed on your computer during `vagrant up`. Thus, even if you run `vagrant destroy`, the box installed in the system will still be present on the hard drive. To return your computer to the state as it was before `vagrant up` command, you need to use `vagrant box remove`.\n>\n> For more information, read about the [`vagrant box remove`](box) command.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/destroy.html](https://www.vagrantup.com/docs/cli/destroy.html)"
- name: vagrant global-status
  id: cli/global-status
  summary: This command will tell you the state of all active Vagrant environments on the system for the currently logged in user
  description: "# Global Status\n\n**Command: `vagrant global-status`**\n\nThis command will tell you the state of all active Vagrant environments on the system for the currently logged in user.\n\n> **This command does not actively verify the state of machines**, and is instead based on a cache. Because of this, it is possible to see stale results (machines say they're running but they're not). For example, if you restart your computer, Vagrant would not know. To prune the invalid entries, run global status with the `--prune` flag.\n\nThe IDs in the output that look like `a1b2c3` can be used to control the Vagrant machine from anywhere on the system. Any Vagrant command that takes a target machine (such as `up`, `halt`, `destroy`) can be used with this ID to control it. For example: `vagrant destroy a1b2c3`.\n\n## Options\n\n- [`--prune`](#prune) - Prunes invalid entries from the list. This is much more time consuming than simply listing the entries.\n\n## Environment Not Showing Up\n\nIf your environment is not showing up, you may have to do a `vagrant destroy` followed by a `vagrant up`.\n\nIf you just upgraded from a previous version of Vagrant, existing environments will not show up in global-status until they are destroyed and recreated.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/global-status.html](https://www.vagrantup.com/docs/cli/global-status.html)"
- name: vagrant halt
  id: cli/halt
  summary: This command shuts down the running machine Vagrant is managing
  description: "# Halt\n\n**Command: `vagrant halt [name|id]`**\n\nThis command shuts down the running machine Vagrant is managing.\n\nVagrant will first attempt to gracefully shut down the machine by running the guest OS shutdown mechanism. If this fails, or if the `--force` flag is specified, Vagrant will effectively just shut off power to the machine.\n\nFor linux-based guests, Vagrant uses the `shutdown` command to gracefully terminate the machine. Due to the varying nature of operating systems, the `shutdown` command may exist at many different locations in the guest's `$PATH`. It is the guest machine's responsibility to properly populate the `$PATH` with directory containing the `shutdown` command.\n\n## Options\n\n- [`-f`](#f) or `--force` - Do not attempt to gracefully shut down the machine. This effectively pulls the power on the guest machine.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/halt.html](https://www.vagrantup.com/docs/cli/halt.html)"
- name: vagrant init
  id: cli/init
  summary: This initializes the current directory to be a Vagrant environment by creating an initial Vagrantfile if one does not already exist
  description: "# Init\n\n**Command: `vagrant init [name [url]]`**\n\nThis initializes the current directory to be a Vagrant environment by creating an initial [Vagrantfile](../vagrantfile/index) if one does not already exist.\n\nIf a first argument is given, it will prepopulate the `config.vm.box` setting in the created Vagrantfile.\n\nIf a second argument is given, it will prepopulate the `config.vm.box_url` setting in the created Vagrantfile.\n\n## Options\n\n- [`--box-version`](#box-version) - (Optional) The box version or box version constraint to add to the `Vagrantfile`.\n\n- [`--force`](#force) - If specified, this command will overwrite any existing `Vagrantfile`.\n\n- [`--minimal`](#minimal) - If specified, a minimal Vagrantfile will be created. This Vagrantfile does not contain the instructional comments that the normal Vagrantfile contains.\n\n- [`--output FILE`](#output-file) - This will output the Vagrantfile to the given file. If this is \"-\", the Vagrantfile will be sent to stdout.\n\n- [`--template FILE`](#template-file) - Provide a custom ERB template for generating the Vagrantfile.\n\n## Examples\n\nCreate a base Vagrantfile:\n\n``` shell\n$ vagrant init hashicorp/precise64\n```\n\nCreate a minimal Vagrantfile (no comments or helpers):\n\n``` shell\n$ vagrant init -m hashicorp/precise64\n```\n\nCreate a new Vagrantfile, overwriting the one at the current path:\n\n``` shell\n$ vagrant init -f hashicorp/precise64\n```\n\nCreate a Vagrantfile with the specific box, from the specific box URL:\n\n``` shell\n$ vagrant init my-company-box https://boxes.company.com/my-company.box\n```\n\nCreate a Vagrantfile, locking the box to a version constraint:\n\n``` shell\n$ vagrant init --box-version '> 0.1.5' hashicorp/precise64\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/init.html](https://www.vagrantup.com/docs/cli/init.html)"
- name: vagrant login
  id: cli/login
  summary: The login command is used to authenticate with the HashiCorp's Vagrant Cloud server
  description: "# Login\n\n**Command: `vagrant login`**\n\nThe login command is used to authenticate with the [HashiCorp's Vagrant Cloud](https://www.vagrantup.com/docs/vagrant-cloud) server. Logging in is only necessary if you are accessing protected boxes or using [Vagrant Share](../share/index).\n\n**Logging in is not a requirement to use Vagrant.** The vast majority of Vagrant does *not* require a login. Only certain features such as protected boxes or [Vagrant Share](../share/index) require a login.\n\nThe reference of available command-line flags to this command is available below.\n\n## Options\n\n- [`--check`](#check) - This will check if you are logged in. In addition to outputting whether you are logged in or not, the command will have exit status 0 if you are logged in, and exit status 1 if you are not.\n\n- [`--logout`](#logout) - This will log you out if you are logged in. If you are already logged out, this command will do nothing. It is not an error to call this command if you are already logged out.\n\n- [`--token`](#token) - This will set the Vagrant Cloud login token manually to the provided string. It is assumed this token is a valid Vagrant Cloud access token.\n\n## Examples\n\nSecurely authenticate to Vagrant Cloud using a username and password:\n\n``` highlight\n$ vagrant login\n# ...\nVagrant Cloud username:\nVagrant Cloud password:\n```\n\nCheck if the current user is authenticated:\n\n``` highlight\n$ vagrant login --check\nYou are already logged in.\n```\n\nSecurely authenticate with Vagrant Cloud using a token:\n\n``` highlight\n$ vagrant login --token ABCD1234\nThe token was successfully saved.\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/login.html](https://www.vagrantup.com/docs/cli/login.html)"
- name: vagrant package
  id: cli/package
  summary: This packages a currently running VirtualBox or Hyper-V environment into a re-usable box
  description: "# Package\n\n**Command: `vagrant package [name|id]`**\n\nThis packages a currently running *VirtualBox* or *Hyper-V* environment into a re-usable [box](../boxes). This command can only be used with other [providers](../providers/index) based on the provider implementation and if the provider supports it.\n\n## Options\n\n- [`--base NAME`](#base-name) - Instead of packaging a VirtualBox machine that Vagrant manages, this will package a VirtualBox machine that VirtualBox manages. `NAME` should be the name or UUID of the machine from the VirtualBox GUI. Currently this option is only available for VirtualBox.\n\n- [`--output NAME`](#output-name) - The resulting package will be saved as `NAME`. By default, it will be saved as `package.box`.\n\n- [`--include x,y,z`](#include-x-y-z) - Additional files will be packaged with the box. These can be used by a packaged Vagrantfile (documented below) to perform additional tasks.\n\n- [`--vagrantfile FILE`](#vagrantfile-file) - Packages a Vagrantfile with the box, that is loaded as part of the [Vagrantfile load order](../vagrantfile/index#load-order) when the resulting box is used.\n\n> **A common misconception** is that the `--vagrantfile` option will package a Vagrantfile that is used when `vagrant init` is used with this box. This is not the case. Instead, a Vagrantfile is loaded and read as part of the Vagrant load process when the box is used. For more information, read about the [Vagrantfile load order](../vagrantfile/index#load-order).\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/package.html](https://www.vagrantup.com/docs/cli/package.html)"
- name: vagrant plugin
  id: cli/plugin
  summary: This is the command used to manage plugins
  description: "# Plugin\n\n**Command: `vagrant plugin`**\n\nThis is the command used to manage [plugins](../plugins/index).\n\nThe main functionality of this command is exposed via another level of subcommands:\n\n- [`expunge`](#plugin-expunge)\n- [`install`](#plugin-install)\n- [`license`](#plugin-license)\n- [`list`](#plugin-list)\n- [`repair`](#plugin-repair)\n- [`uninstall`](#plugin-uninstall)\n- [`update`](#plugin-update)\n\n# Plugin Expunge\n\n**Command: `vagrant plugin expunge`**\n\nThis removes all user installed plugin information. All plugin gems, their dependencies, and the `plugins.json` file are removed. This command provides a simple mechanism to fully remove all user installed custom plugins.\n\nWhen upgrading Vagrant it may be required to reinstall plugins due to an internal incompatibility. The expunge command can help make that process easier by attempting to automatically reinstall currently configured plugins:\n\n``` shell\n# Delete all plugins and reinstall\n$ vagrant plugin expunge --reinstall\n```\n\nThis command accepts optional command-line flags:\n\n- [`--force`](#force) - Do not prompt for confirmation prior to removal\n- [`--global-only`](#global-only) - Only expunge global plugins\n- [`--local`](#local) - Include plugins in local project\n- [`--local-only`](#local-only) - Only expunge local project plugins\n- [`--reinstall`](#reinstall) - Attempt to reinstall plugins after removal\n\n# Plugin Install\n\n**Command: `vagrant plugin install <name>...`**\n\nThis installs a plugin with the given name or file path. If the name is not a path to a file, then the plugin is installed from remote repositories, usually [RubyGems](https://rubygems.org). This command will also update a plugin if it is already installed, but you can also use `vagrant plugin update` for that.\n\n``` shell\n# Installing a plugin from a known gem source\n$ vagrant plugin install my-plugin\n\n# Installing a plugin from a local file source\n$ vagrant plugin install /path/to/my-plugin.gem\n```\n\nIf multiple names are specified, multiple plugins will be installed. If flags are given below, the flags will apply to *all* plugins being installed by the current command invocation.\n\nIf the plugin is already installed, this command will reinstall it with the latest version available.\n\nThis command accepts optional command-line flags:\n\n- [`--entry-point ENTRYPOINT`](#entry-point-entrypoint) - By default, installed plugins are loaded internally by loading an initialization file of the same name as the plugin. Most of the time, this is correct. If the plugin you are installing has another entrypoint, this flag can be used to specify it.\n\n- [`--local`](#local-1) - Install plugin to the local Vagrant project only.\n\n- [`--plugin-clean-sources`](#plugin-clean-sources) - Clears all sources that have been defined so far. This is an advanced feature. The use case is primarily for corporate firewalls that prevent access to RubyGems.org.\n\n- [`--plugin-source SOURCE`](#plugin-source-source) - Adds a source from which to fetch a plugin. Note that this does not only affect the single plugin being installed, by all future plugin as well. This is a limitation of the underlying plugin installer Vagrant uses.\n\n- [`--plugin-version VERSION`](#plugin-version-version) - The version of the plugin to install. By default, this command will install the latest version. You can constrain the version using this flag. You can set it to a specific version, such as \"1.2.3\" or you can set it to a version constraint, such as \"\\> 1.0.2\". You can set it to a more complex constraint by comma-separating multiple constraints: \"\\> 1.0.2, \\< 1.1.0\" (do not forget to quote these on the command-line).\n\n# Plugin License\n\n**Command: `vagrant plugin license <name> <license-file>`**\n\nThis command installs a license for a proprietary Vagrant plugin, such as the [VMware Fusion provider](../vmware).\n\n# Plugin List\n\n**Command: `vagrant plugin list`**\n\nThis lists all installed plugins and their respective installed versions. If a version constraint was specified for a plugin when installing it, the constraint will be listed as well. Other plugin-specific information may be shown, too.\n\nThis command accepts optional command-line flags:\n\n- [`--local`](#local-2) - Include local project plugins.\n\n# Plugin Repair\n\nVagrant may fail to properly initialize user installed custom plugins. This can be caused my improper plugin installation/removal, or by manual manipulation of plugin related files like the `plugins.json` data file. Vagrant can attempt to automatically repair the problem.\n\nIf automatic repair is not successful, refer to the [expunge](#plugin-expunge) command\n\nThis command accepts optional command-line flags:\n\n- [`--local`](#local-3) - Repair local project plugins.\n\n# Plugin Uninstall\n\n**Command: `vagrant plugin uninstall <name> [<name2> <name3> ...]`**\n\nThis uninstalls the plugin with the given name. Any dependencies of the plugin will also be uninstalled assuming no other plugin needs them.\n\nIf multiple plugins are given, multiple plugins will be uninstalled.\n\nThis command accepts optional command-line flags:\n\n- [`--local`](#local-4) - Uninstall plugin from local project.\n\n# Plugin Update\n\n**Command: `vagrant plugin update [<name>]`**\n\nThis updates the plugins that are installed within Vagrant. If you specified version constraints when installing the plugin, this command will respect those constraints. If you want to change a version constraint, re-install the plugin using `vagrant plugin install`.\n\nIf a name is specified, only that single plugin will be updated. If a name is specified of a plugin that is not installed, this command will not install it.\n\nThis command accepts optional command-line flags:\n\n- [`--local`](#local-5) - Update plugin from local project.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/plugin.html](https://www.vagrantup.com/docs/cli/plugin.html)"
- name: vagrant port
  id: cli/port
  summary: --guest PORT - This displays just the host port that corresponds to the given guest port
  description: "# Port\n\n**Command: `vagrant port [name|id]`**\n\nThe port command displays the full list of guest ports mapped to the host machine ports:\n\n``` highlight\n$ vagrant port\n    22 (guest) => 2222 (host)\n    80 (guest) => 8080 (host)\n```\n\nIn a multi-machine Vagrantfile, the name of the machine must be specified:\n\n``` highlight\n$ vagrant port my-machine\n```\n\n## Options\n\n- [`--guest PORT`](#guest-port) - This displays just the host port that corresponds to the given guest port. If the guest is not forwarding that port, an error is returned. This is useful for quick scripting, for example:\n\n  ``` highlight\n  $ ssh -p $(vagrant port --guest 22)\n  ```\n\n- [`--machine-readable`](#machine-readable) - This tells Vagrant to display machine-readable output instead of the human-friendly output. More information is available in the [machine-readable output](machine-readable) documentation.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/port.html](https://www.vagrantup.com/docs/cli/port.html)"
- name: vagrant powershell
  id: cli/powershell
  summary: This will open a PowerShell prompt on the host into a running Vagrant guest machine
  description: "# PowerShell\n\n**Command: `vagrant powershell`**\n\nThis will open a PowerShell prompt on the host into a running Vagrant guest machine.\n\nThis command will only work if the machines supports PowerShell. Not every environment will support PowerShell. At the moment, only Windows is supported with this command.\n\n## Options\n\n- [`-c COMMAND`](#c-command) or `--command COMMAND` - This executes a single PowerShell command, prints out the stdout and stderr, and exits.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/powershell.html](https://www.vagrantup.com/docs/cli/powershell.html)"
- name: vagrant provision
  id: cli/provision
  summary: Runs any configured provisioners against the running Vagrant managed machine
  description: "# Provision\n\n**Command: `vagrant provision [vm-name]`**\n\nRuns any configured [provisioners](../provisioning/index) against the running Vagrant managed machine.\n\nThis command is a great way to quickly test any provisioners, and is especially useful for incremental development of shell scripts, Chef cookbooks, or Puppet modules. You can just make simple modifications to the provisioning scripts on your machine, run a `vagrant provision`, and check for the desired results. Rinse and repeat.\n\n# Options\n\n- [`--provision-with x,y,z`](#provision-with-x-y-z) - This will only run the given provisioners. For example, if you have a `:shell` and `:chef_solo` provisioner and run `vagrant provision --provision-with shell`, only the shell provisioner will be run.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/provision.html](https://www.vagrantup.com/docs/cli/provision.html)"
- name: Vagrant Push
  id: push/index
  summary: As of version 1.7, Vagrant is capable of deploying or "pushing" application code in the same directory as your Vagrantfile to a remote such as an FTP server
  description: "# Vagrant Push\n\nAs of version 1.7, Vagrant is capable of deploying or \"pushing\" application code in the same directory as your Vagrantfile to a remote such as an FTP server.\n\nPushes are defined in an application's `Vagrantfile` and are invoked using the `vagrant push` subcommand. Much like other components of Vagrant, each Vagrant Push plugin has its own configuration options. Please consult the documentation for your Vagrant Push plugin for more information. Here is an example Vagrant Push configuration section in a `Vagrantfile`:\n\n``` ruby\nconfig.push.define \"ftp\" do |push|\n  push.host = \"ftp.company.com\"\n  push.username = \"...\"\n  # ...\nend\n```\n\nWhen the application is ready to be deployed to the FTP server, just run a single command:\n\n``` shell\n$ vagrant push\n```\n\nMuch like [Vagrant Providers](../providers/index \"Vagrant Providers\"), Vagrant Push also supports multiple backend declarations. Consider the common scenario of a staging and QA environment:\n\n``` ruby\nconfig.push.define \"staging\", strategy: \"ftp\" do |push|\n  # ...\nend\n\nconfig.push.define \"qa\", strategy: \"ftp\" do |push|\n  # ...\nend\n```\n\nIn this scenario, the user must pass the name of the Vagrant Push to the subcommand:\n\n``` shell\n$ vagrant push staging\n```\n\nVagrant Push is the easiest way to deploy your application. You can read more in the documentation links on the sidebar.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/push/](https://www.vagrantup.com/docs/push/)"
- name: vagrant rdp
  id: cli/rdp
  summary: This will start an RDP client for a remote desktop session with the guest
  description: "# RDP\n\n**Command: `vagrant rdp`**\n\nThis will start an RDP client for a remote desktop session with the guest. This only works for Vagrant environments that support remote desktop, which is typically only Windows.\n\n## Raw Arguments\n\nYou can pass raw arguments through to your RDP client on the command-line by appending it after a `--`. Vagrant just passes these through. For example:\n\n``` highlight\n$ vagrant rdp -- /span\n```\n\nThe above command on Windows will execute `mstsc.exe /span config.rdp`, allowing your RDP to span multiple desktops.\n\nOn Darwin hosts, such as Mac OS X, the additional arguments are added to the generated RDP configuration file. Since these files can contain multiple options with different spacing, you *must* quote multiple arguments. For example:\n\n``` highlight\n$ vagrant rdp -- \"screen mode id:i:0\" \"other config:s:value\"\n```\n\nNote that as of the publishing of this guide, the Microsoft RDP Client for Mac does *not* perform validation on the configuration file. This means if you specify an invalid configuration option or make a typographical error, the client will silently ignore the error and continue!\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/rdp.html](https://www.vagrantup.com/docs/cli/rdp.html)"
- name: vagrant reload
  id: cli/reload
  summary: The equivalent of running a halt followed by an up
  description: "# Reload\n\n**Command: `vagrant reload [name|id]`**\n\nThe equivalent of running a [halt](halt) followed by an [up](up).\n\nThis command is usually required for changes made in the Vagrantfile to take effect. After making any modifications to the Vagrantfile, a `reload` should be called.\n\nThe configured provisioners will not run again, by default. You can force the provisioners to re-run by specifying the `--provision` flag.\n\n# Options\n\n- [`--provision`](#provision) - Force the provisioners to run.\n\n- [`--provision-with x,y,z`](#provision-with-x-y-z) - This will only run the given provisioners. For example, if you have a `:shell` and `:chef_solo` provisioner and run `vagrant reload --provision-with shell`, only the shell provisioner will be run.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/reload.html](https://www.vagrantup.com/docs/cli/reload.html)"
- name: vagrant resume
  id: cli/resume
  summary: This resumes a Vagrant managed machine that was previously suspended, perhaps with the suspend command
  description: "# Resume\n\n**Command: `vagrant resume [name|id]`**\n\nThis resumes a Vagrant managed machine that was previously suspended, perhaps with the [suspend command](suspend).\n\nThe configured provisioners will not run again, by default. You can force the provisioners to re-run by specifying the `--provision` flag.\n\n# Options\n\n- [`--provision`](#provision) - Force the provisioners to run.\n\n- [`--provision-with x,y,z`](#provision-with-x-y-z) - This will only run the given provisioners. For example, if you have a `:shell` and `:chef_solo` provisioner and run `vagrant provision --provision-with shell`, only the shell provisioner will be run.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/resume.html](https://www.vagrantup.com/docs/cli/resume.html)"
- name: vagrant rsync
  id: cli/rsync
  summary: This command forces a re-sync of any rsync synced folders
  description: "# Rsync\n\n**Command: `vagrant rsync`**\n\nThis command forces a re-sync of any [rsync synced folders](../synced-folders/rsync).\n\nNote that if you change any settings within the rsync synced folders such as exclude paths, you will need to `vagrant reload` before this command will pick up those changes.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/rsync.html](https://www.vagrantup.com/docs/cli/rsync.html)"
- name: vagrant rsync-auto
  id: cli/rsync-auto
  summary: This command watches all local directories of any rsync synced folders and automatically initiates an rsync transfer when changes are detected
  description: "# rsync-auto\n\n**Command: `vagrant rsync-auto`**\n\nThis command watches all local directories of any [rsync synced folders](../synced-folders/rsync) and automatically initiates an rsync transfer when changes are detected. This command does not exit until an interrupt is received.\n\nThe change detection is optimized to use platform-specific APIs to listen for filesystem changes, and does not simply poll the directory.\n\n## Options\n\n- [`--[no-]poll`](#no-poll) - Force Vagrant to watch for changes using filesystem polling instead of filesystem events. This is required for some filesystems that do not support events. Warning: enabling this will make `rsync-auto` *much* slower. By default, polling is disabled.\n\n## Machine State Changes\n\nThe `rsync-auto` command does not currently handle machine state changes gracefully. For example, if you start the `rsync-auto` command, then halt the guest machine, then make changes to some files, then boot it back up, `rsync-auto` will not attempt to resync.\n\nTo ensure that the command works properly, you should start `rsync-auto` only when the machine is running, and shut it down before any machine state changes.\n\nYou can always force a resync with the [rsync](rsync) command.\n\n## Vagrantfile Changes\n\nIf you change or move your Vagrantfile, the `rsync-auto` command will have to be restarted. For example, if you add synced folders to the Vagrantfile, or move the directory that contains the Vagrantfile, the `rsync-auto` command will either not pick up the changes or may begin experiencing strange behavior.\n\nBefore making any such changes, it is recommended that you turn off `rsync-auto`, then restart it afterwards.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/rsync-auto.html](https://www.vagrantup.com/docs/cli/rsync-auto.html)"
- name: Vagrant Settings
  id: vagrantfile/vagrant_settings
  summary: The settings within config.vagrant modify the behavior of Vagrant itself
  description: "# Vagrant Settings\n\n**Config namespace: `config.vagrant`**\n\nThe settings within `config.vagrant` modify the behavior of Vagrant itself.\n\n## Available Settings\n\n- [`config.vagrant.host`](#config-vagrant-host) (string, symbol) - This sets the type of host machine that is running Vagrant. By default this is `:detect`, which causes Vagrant to auto-detect the host. Vagrant needs to know this information in order to perform some host-specific things, such as preparing NFS folders if they're enabled. You should only manually set this if auto-detection fails.\n\n- [`config.vagrant.plugins`](#config-vagrant-plugins) - (string, array, hash) - Define plugin, list of plugins, or definition of plugins to install for the local project. Vagrant will require these plugins be installed and available for the project. If the plugins are not available, it will attempt to automatically install them into the local project. When requiring a single plugin, a string can be provided:\n\n  ``` ruby\n  config.vagrant.plugins = \"vagrant-plugin\"\n  ```\n\n  If multiple plugins are required, they can be provided as an array:\n\n  ``` ruby\n  config.vagrant.plugins = [\"vagrant-plugin\", \"vagrant-other-plugin\"]\n  ```\n\n  Plugins can also be defined as a Hash, which supports setting extra options for the plugins. When a Hash is used, the key is the name of the plugin, and the value is a Hash of options for the plugin. For example, to set an explicit version of a plugin to install:\n\n  ``` ruby\n  config.vagrant.plugins = {\"vagrant-scp\" => {\"version\" => \"1.0.0\"}}\n  ```\n\n  Supported options are:\n\n  - [`entry_point`](#entry_point) - Path for Vagrant to load plugin\n  - [`sources`](#sources) - Custom sources for downloading plugin\n  - [`version`](#version) - Version constraint for plugin\n\n- [`config.vagrant.sensitive`](#config-vagrant-sensitive) - (string, array) - Value or list of values that should not be displayed in Vagrant's output. Value(s) will be removed from Vagrant's normal UI output as well as logger output.\n\n  ``` ruby\n  config.vagrant.sensitive = [\"MySecretPassword\", ENV[\"MY_TOKEN\"]]\n  ```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/vagrant_settings.html](https://www.vagrantup.com/docs/vagrantfile/vagrant_settings.html)"
- name: Vagrant Share
  id: share/index
  summary: 'Vagrant Share allows you to share your Vagrant environment with anyone in the world, enabling collaboration directly in your Vagrant environment in almost any network environment with just a single command: vagrant share'
  description: "# Vagrant Share\n\nVagrant Share allows you to share your Vagrant environment with anyone in the world, enabling collaboration directly in your Vagrant environment in almost any network environment with just a single command: `vagrant share`.\n\nVagrant share has three primary modes or features. These features are not mutually exclusive, meaning that any combination of them can be active at any given time:\n\n- **HTTP sharing** will create a URL that you can give to anyone. This URL will route directly into your Vagrant environment. The person using this URL does not need Vagrant installed, so it can be shared with anyone. This is useful for testing webhooks or showing your work to clients, teammates, managers, etc.\n\n- **SSH sharing** will allow instant SSH access to your Vagrant environment by anyone by running `vagrant connect --ssh` on the remote side. This is useful for pair programming, debugging ops problems, etc.\n\n- **General sharing** allows anyone to access any exposed port of your Vagrant environment by running `vagrant connect` on the remote side. This is useful if the remote side wants to access your Vagrant environment as if it were a computer on the LAN.\n\nThe details of each are covered in their specific section in the sidebar to the left. We also have a section where we go into detail about the security implications of this feature.\n\n## Installation\n\nVagrant Share is a Vagrant plugin that must be installed. It is not included with Vagrant system packages. To install the Vagrant Share plugin, run the following command:\n\n``` shell\n$ vagrant plugin install vagrant-share\n```\n\nVagrant Share requires [ngrok](https://ngrok.com) to be used.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/share/](https://www.vagrantup.com/docs/share/)"
- name: vagrant share
  id: cli/share
  summary: The share command initializes a Vagrant Share session, allowing you to share your Vagrant environment with anyone in the world, enabling collaboration directly in your Vagrant environment in almost any network environment
  description: "# Share\n\n**Command: `vagrant share`**\n\nThe share command initializes a Vagrant Share session, allowing you to share your Vagrant environment with anyone in the world, enabling collaboration directly in your Vagrant environment in almost any network environment.\n\nYou can learn about all the details of Vagrant Share in the [Vagrant Share section](../share/index).\n\nThe reference of available command-line flags to this command is available below.\n\n## Options\n\n- [`--disable-http`](#disable-http) - Disables the creation of a publicly accessible HTTP endpoint to your Vagrant environment. With this set, the only way to access your share is with `vagrant connect`.\n\n- [`--http PORT`](#http-port) - The port of the HTTP server running in the Vagrant environment. By default, Vagrant will attempt to find this for you. This has no effect if `--disable-http` is set.\n\n- [`--https PORT`](#https-port) - The port of an HTTPS server running in the Vagrant environment. By default, Vagrant will attempt to find this for you. This has no effect if `--disable-http` is set.\n\n- [`--ssh`](#ssh) - Enables SSH sharing (more information below). By default, this is not enabled.\n\n- [`--ssh-no-password`](#ssh-no-password) - Disables the encryption of the SSH keypair created when SSH sharing is enabled.\n\n- [`--ssh-port PORT`](#ssh-port-port) - The port of the SSH server running in the Vagrant environment. By default, Vagrant will attempt to find this for you.\n\n- [`--ssh-once`](#ssh-once) - Allows SSH access only once. After the first attempt to connect via SSH to the Vagrant environment, the generated keypair is destroyed.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/share.html](https://www.vagrantup.com/docs/cli/share.html)"
- name: vagrant snapshot
  id: cli/snapshot
  summary: This is the command used to manage snapshots with the guest machine
  description: "# Snapshot\n\n**Command: `vagrant snapshot`**\n\nThis is the command used to manage snapshots with the guest machine. Snapshots record a point-in-time state of a guest machine. You can then quickly restore to this environment. This lets you experiment and try things and quickly restore back to a previous state.\n\nSnapshotting is not supported by every provider. If it is not supported, Vagrant will give you an error message.\n\nThe main functionality of this command is exposed via even more subcommands:\n\n- [`push`](#snapshot-push)\n- [`pop`](#snapshot-pop)\n- [`save`](#snapshot-save)\n- [`restore`](#snapshot-restore)\n- [`list`](#snapshot-list)\n- [`delete`](#snapshot-delete)\n\n# Snapshot Push\n\n**Command: `vagrant snapshot push`**\n\nThis takes a snapshot and pushes it onto the snapshot stack.\n\nThis is a shorthand for `vagrant snapshot save` where you do not need to specify a name. When you call the inverse `vagrant snapshot pop`, it will restore the pushed state.\n\n> **Warning:** If you are using `push` and `pop`, avoid using `save` and `restore` which are unsafe to mix.\n\n# Snapshot Pop\n\n**Command: `vagrant snapshot pop`**\n\nThis command is the inverse of `vagrant snapshot push`: it will restore the pushed state.\n\n## Options\n\n- [`--[no-]provision`](#no-provision) - Force the provisioners to run (or prevent them from doing so).\n\n- [`--no-delete`](#no-delete) - Prevents deletion of the snapshot after restoring (so that you can restore to the same point again later).\n\n# Snapshot Save\n\n**Command: `vagrant snapshot save [vm-name] NAME`**\n\nThis command saves a new named snapshot. If this command is used, the `push` and `pop` subcommands cannot be safely used.\n\n# Snapshot Restore\n\n**Command: `vagrant snapshot restore [vm-name] NAME`**\n\nThis command restores the named snapshot.\n\n- [`--[no-]provision`](#no-provision-1) - Force the provisioners to run (or prevent them from doing so).\n\n# Snapshot List\n\n**Command: `vagrant snapshot list`**\n\nThis command will list all the snapshots taken.\n\n# Snapshot Delete\n\n**Command: `vagrant snapshot delete NAME`**\n\nThis command will delete the named snapshot.\n\nSome providers require all \"child\" snapshots to be deleted first. Vagrant itself does not track what these children are. If this is the case (such as with VirtualBox), then you must be sure to delete the snapshots in the reverse order they were taken.\n\nThis command is typically *much faster* if the machine is halted prior to snapshotting. If this is not an option, or is not ideal, then the deletion can also be done online with most providers.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/snapshot.html](https://www.vagrantup.com/docs/cli/snapshot.html)"
- name: vagrant ssh
  id: cli/ssh
  summary: This will SSH into a running Vagrant machine and give you access to a shell
  description: "# SSH\n\n**Command: `vagrant ssh [name|id] [-- extra_ssh_args]`**\n\nThis will SSH into a running Vagrant machine and give you access to a shell.\n\nOn a simple vagrant project, the instance created will be named default.\n\nVagrant will ssh into this instance without the instance name:\n\n``` shell\n$ vagrant ssh\n\nWelcome to your Vagrant-built virtual machine.\nLast login: Fri Sep 14 06:23:18 2012 from 10.0.2.2\n$ logout\nConnection to 127.0.0.1 closed.\n```\n\nOr you could use the name:\n\n``` shell\n$ vagrant ssh default\n\n\nWelcome to your Vagrant-built virtual machine.\nLast login: Fri Jul 20 15:09:52 2018 from 10.0.2.2\n$ logout\nConnection to 127.0.0.1 closed.\n$\n```\n\nOn multi-machine setups, you can login to each vm using the name as displayed on `vagrant status`\n\n``` shell\n $ vagrant status\nCurrent machine states:\n\nnode1                     running (virtualbox)\nnode2                     running (virtualbox)\n\nThis environment represents multiple VMs. The VMs are all listed\nabove with their current state.\n$ vagrant ssh node1\n\nWelcome to your Vagrant-built virtual machine.\nLast login: Fri Sep 14 06:23:18 2012 from 10.0.2.2\nvagrant@precise64:~$ logout\nConnection to 127.0.0.1 closed.\n$ vagrant ssh node2\n\nWelcome to your Vagrant-built virtual machine.\nLast login: Fri Sep 14 06:23:18 2012 from 10.0.2.2\nvagrant@precise64:~$ logout\nConnection to 127.0.0.1 closed.\n$\n```\n\nOn a system with machines running from different projects, you could use the id as listed in `vagrant global-status`\n\n``` shell\n$ vagrant global-status\nid       name   provider   state   directory\n-----------------------------------------------------------------------\n13759ff  node1  virtualbox running /Users/user/vagrant/folder\n\nThe above shows information about all known Vagrant environments\non this machine. This data is cached and may not be completely\nup-to-date (use \"vagrant global-status --prune\" to prune invalid\nentries). To interact with any of the machines, you can go to that\ndirectory and run Vagrant, or you can use the ID directly with\nVagrant commands from any directory.\n$ vagrant ssh 13759ff\n\nWelcome to your Vagrant-built virtual machine.\nLast login: Fri Jul 20 15:19:36 2018 from 10.0.2.2\nvagrant@precise64:~$ logout\nConnection to 127.0.0.1 closed.\n$\n```\n\nIf a `--` (two hyphens) are found on the command line, any arguments after this are passed directly into the `ssh` executable. This allows you to pass any arbitrary commands to do things such as reverse tunneling down into the `ssh` program.\n\n## Options\n\n- [`-c COMMAND`](#c-command) or `--command COMMAND` - This executes a single SSH command, prints out the stdout and stderr, and exits.\n\n- [`-p`](#p) or `--plain` - This does an SSH without authentication, leaving authentication up to the user.\n\n## SSH client usage\n\nVagrant will attempt to use the local SSH client installed on the host machine. On POSIX machines, an SSH client must be installed and available on the PATH.\n\nFor Windows installations, an SSH client is provided within the installer image. If no SSH client is found on the current PATH, Vagrant will use the SSH client it provided. Depending on the local environment used for running Vagrant, the installer provided SSH client may not work correctly. For example, when using a cygwin or msys2 shell the SSH client will fail to work as expected when run interactively. Installing the SSH package built for the current working environment will resolve this issue.\n\n## Background Execution\n\nIf the command you specify runs in the background (such as appending a `&` to a shell command), it will be terminated almost immediately. This is because when Vagrant executes the command, it executes it within the context of a shell, and when the shell exits, all of the child processes also exit.\n\nTo avoid this, you will need to detach the process from the shell. Please Google to learn how to do this for your shell. One method of doing this is the `nohup` command.\n\n## Pageant on Windows\n\nThe SSH executable will not be able to access Pageant on Windows. While Vagrant is capable of accessing Pageant via internal libraries, the SSH executable does not have support for Pageant. This means keys from Pageant will not be available for forwarding when using the `vagrant ssh` command.\n\nThird party programs exist to allow the SSH executable to access Pageant by creating a unix socket for the SSH executable to read. For more information please see [ssh-pageant](https://github.com/cuviper/ssh-pageant).\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/ssh.html](https://www.vagrantup.com/docs/cli/ssh.html)"
- name: vagrant ssh-config
  id: cli/ssh_config
  summary: This will output valid configuration for an SSH config file to SSH into the running Vagrant machine from ssh directly (instead of using vagrant ssh)
  description: "# SSH Config\n\n**Command: `vagrant ssh-config [name|id]`**\n\nThis will output valid configuration for an SSH config file to SSH into the running Vagrant machine from `ssh` directly (instead of using `vagrant ssh`).\n\n## Options\n\n- [`--host NAME`](#host-name) - Name of the host for the outputted configuration.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/ssh_config.html](https://www.vagrantup.com/docs/cli/ssh_config.html)"
- name: vagrant status
  id: cli/status
  summary: This will tell you the state of the machines Vagrant is managing
  description: "# Status\n\n**Command: `vagrant status [name|id]`**\n\nThis will tell you the state of the machines Vagrant is managing.\n\nIt is quite easy, especially once you get comfortable with Vagrant, to forget whether your Vagrant machine is running, suspended, not created, etc. This command tells you the state of the underlying guest machine.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/status.html](https://www.vagrantup.com/docs/cli/status.html)"
- name: vagrant suspend
  id: cli/suspend
  summary: This suspends the guest machine Vagrant is managing, rather than fully shutting it down or destroying it
  description: "# Suspend\n\n**Command: `vagrant suspend [name|id]`**\n\nThis suspends the guest machine Vagrant is managing, rather than fully [shutting it down](halt) or [destroying it](destroy).\n\nA suspend effectively saves the *exact point-in-time state* of the machine, so that when you [resume](resume) it later, it begins running immediately from that point, rather than doing a full boot.\n\nThis generally requires extra disk space to store all the contents of the RAM within your guest machine, but the machine no longer consumes the RAM of your host machine or CPU cycles while it is suspended.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/suspend.html](https://www.vagrantup.com/docs/cli/suspend.html)"
- name: Vagrant Triggers
  id: triggers/index
  summary: As of version 2.1.0, Vagrant is capable of executing machine triggers before or after Vagrant commands
  description: "# Vagrant Triggers\n\nAs of version 2.1.0, Vagrant is capable of executing machine triggers *before* or *after* Vagrant commands.\n\nEach trigger is expected to be given a command key for when it should be fired during the Vagrant command lifecycle. These could be defined as a single key or an array which acts like a *whitelist* for the defined trigger.\n\n``` ruby\n# single command trigger\nconfig.trigger.after :up do |trigger|\n...\nend\n\n# multiple commands for this trigger\nconfig.trigger.before [:up, :destroy, :halt, :package] do |trigger|\n...\nend\n\n# or defined as a splat list\nconfig.trigger.before :up, :destroy, :halt, :package do |trigger|\n...\nend\n```\n\nAlternatively, the key `:all` could be given which would run the trigger before or after every Vagrant command. If there is a command you don't want the trigger to run on, you can ignore that command with the `ignore` option.\n\n``` ruby\n# single command trigger\nconfig.trigger.before :all do |trigger|\n  trigger.info = \"Running a before trigger!\"\n  trigger.ignore = [:destroy, :halt]\nend\n```\n\n**Note:** *If a trigger is defined on a command that does not exist, a warning will be displayed.*\n\nTriggers can be defined as a block or hash in a Vagrantfile. The example below will result in the same trigger:\n\n``` ruby\nconfig.trigger.after :up do |trigger|\n  trigger.name = \"Finished Message\"\n  trigger.info = \"Machine is up!\"\nend\n\nconfig.trigger.after :up,\n  name: \"Finished Message\",\n  info: \"Machine is up!\"\n```\n\nTriggers can also be defined within the scope of guests in a Vagrantfile. These triggers will only run on the configured guest. An example of a guest only trigger:\n\n``` ruby\nconfig.vm.define \"ubuntu\" do |ubuntu|\n  ubuntu.vm.box = \"ubuntu\"\n  ubuntu.trigger.before :destroy do |trigger|\n    trigger.warn = \"Dumping database to /vagrant/outfile\"\n    trigger.run_remote = {inline: \"pg_dump dbname > /vagrant/outfile\"}\n  end\nend\n```\n\nGlobal and machine-scoped triggers will execute in the order that they are defined within a Vagrantfile. Take for example an abstracted Vagrantfile:\n\n``` highlight\nVagrantfile\n  global trigger 1\n  global trigger 2\n  machine defined\n    machine trigger 3\n  global trigger 4\nend\n```\n\nIn this generic case, the triggers would fire in the order: 1 -\\> 2 -\\> 3 -\\> 4\n\nFor more information about what options are available for triggers, see the [configuration section](configuration).\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/triggers/](https://www.vagrantup.com/docs/triggers/)"
- name: vagrant up
  id: cli/up
  summary: This command creates and configures guest machines according to your Vagrantfile
  description: "# Up\n\n**Command: `vagrant up [name|id]`**\n\nThis command creates and configures guest machines according to your [Vagrantfile](../vagrantfile/index).\n\nThis is the single most important command in Vagrant, since it is how any Vagrant machine is created. Anyone using Vagrant must use this command on a day-to-day basis.\n\n## Options\n\n- [`name`](#name) - Name of machine defined in [Vagrantfile](../vagrantfile/index)\n\n- [`id`](#id) - Machine id found with `vagrant global-status`. Using `id` allows you to call `vagrant up id` from any directory.\n\n- [`--[no-]destroy-on-error`](#no-destroy-on-error) - Destroy the newly created machine if a fatal, unexpected error occurs. This will only happen on the first `vagrant up`. By default this is set.\n\n- [`--[no-]install-provider`](#no-install-provider) - If the requested provider is not installed, Vagrant will attempt to automatically install it if it can. By default this is enabled.\n\n- [`--[no-]parallel`](#no-parallel) - Bring multiple machines up in parallel if the provider supports it. Please consult the provider documentation to see if this feature is supported.\n\n- [`--provider x`](#provider-x) - Bring the machine up with the given [provider](../providers/index). By default this is \"virtualbox\".\n\n- [`--[no-]provision`](#no-provision) - Force, or prevent, the provisioners to run.\n\n- [`--provision-with x,y,z`](#provision-with-x-y-z) - This will only run the given provisioners. For example, if you have a `:shell` and `:chef_solo` provisioner and run `vagrant provision --provision-with shell`, only the shell provisioner will be run.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/up.html](https://www.vagrantup.com/docs/cli/up.html)"
- name: vagrant validate
  id: cli/validate
  summary: This command validates your Vagrantfile
  description: "# Validate\n\n**Command: `vagrant validate`**\n\nThis command validates your [Vagrantfile](../vagrantfile/index).\n\n## Examples\n\n``` shell\n$ vagrant validate\nVagrantfile validated successfully.\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/validate.html](https://www.vagrantup.com/docs/cli/validate.html)"
- name: vagrant version
  id: cli/version
  summary: This command tells you the version of Vagrant you have installed as well as the latest version of Vagrant that is currently available
  description: "# Version\n\n**Command: `vagrant version`**\n\nThis command tells you the version of Vagrant you have installed as well as the latest version of Vagrant that is currently available.\n\nIn order to determine the latest available Vagrant version, this command must make a network call. If you only want to see the currently installed version, use `vagrant --version`.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/cli/version.html](https://www.vagrantup.com/docs/cli/version.html)"
- name: Vagrant VMware Utility Installation
  id: vmware/vagrant-vmware-utility
  summary: The Vagrant VMware Utility is provided as a system package
  description: "# Vagrant VMware Utility Installation\n\n## System Packages\n\nThe Vagrant VMware Utility is provided as a system package. To install the utility, download and install the correct system package from the downloads page.\n\n[Download 1.0.5](https://www.vagrantup.com/vmware/downloads.html)\n\n## Manual Installation\n\nIf there is no officially supported system package of the utility available, it may be possible to manually install utility. This applies to Linux platforms only. First, download the latest zip package from the releases page.\n\nNext create a directory for the executable and unpack the executable as root.\n\n``` shell\nsudo mkdir /opt/vagrant-vmware-utility/bin\nsudo unzip -d /opt/vagrant-vmware-utility/bin vagrant-vmware-utility_1.0.0_x86_64.zip\n```\n\nAfter the executable has been installed, the utility setup tasks must be run. First, generate the required certificates:\n\n``` shell\nsudo /opt/vagrant-vmware-utility/bin/vagrant-vmware-utility certificate generate\n```\n\nThe path provided from this command can be used to set the [`utility_certificate_path`](configuration#utility_certificate_path) in the Vagrantfile configuration if installing to a non-standard path.\n\nFinally, install the service. This will also enable the service.\n\n``` shell\nsudo /usr/local/vagrant-vmware-utility/vagrant-vmware-utility service install\n```\n\n# Usage\n\nThe Vagrant VMware Utility provides the Vagrant VMware provider plugin access to various VMware functionalities. The Vagrant VMware Utility is required by the Vagrant VMware Desktop provider plugin.\n\n## Vagrant VMware Utility Access\n\nThe Vagrant VMware Utility provides support for all users on the system using the Vagrant VMware Desktop plugin. If access restrictions to the Utility need to be applied to users on the system, this can be accomplished by restricting user access to the certificates used for connecting to the service.\n\nOn Windows platforms these certificates can be found at:\n\n- C:\\ProgramData\\HashiCorp\\vagrant-vmware-desktop\\certificates\n\nOn POSIX platforms these certificates can be found at:\n\n- /opt/vagrant-vmware-desktop/certificates\n\n## Vagrant VMware Utility Service\n\nThe Vagrant VMware Utility consists of a small service which runs on the host platform. When the utility installer package is installed, the service is configured to automatically start. If the plugin reports errors communicating with the service, it may have stopped for some reason. The most common cause of the service not being in a running state is the VMware application not being installed. The service can be started again by using the proper command below:\n\n### Windows\n\nOn Windows platforms a service is created called `vagrant-vmware-utility`. The service can be manually started using the services GUI (`services.msc`) or by running the following command from a `cmd.exe` in administrator mode:\n\n``` shell\n> net.exe start vagrant-vmware-utility\n```\n\n### macOS\n\n``` shell\n> sudo launchctl load -w /Library/LaunchDaemons/com.vagrant.vagrant-vmware-utility.plist\n```\n\n### Linux systemd\n\n``` shell\n> sudo systemctl start vagrant-vmware-utility\n```\n\n### Linux SysVinit\n\n``` shell\n> sudo /etc/init.d/vagrant-vmware-utility start\n```\n\n### Linux runit\n\n``` shell\n> sudo sv start vagrant-vmware-utility\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vmware/vagrant-vmware-utility.html](https://www.vagrantup.com/docs/vmware/vagrant-vmware-utility.html)"
- name: Vagrantfile
  id: vagrantfile/index
  summary: The primary function of the Vagrantfile is to describe the type of machine required for a project, and how to configure and provision these machines
  description: "# Vagrantfile\n\nThe primary function of the Vagrantfile is to describe the type of machine required for a project, and how to configure and provision these machines. Vagrantfiles are called Vagrantfiles because the actual literal filename for the file is `Vagrantfile` (casing does not matter unless your file system is running in a strict case sensitive mode).\n\nVagrant is meant to run with one Vagrantfile per project, and the Vagrantfile is supposed to be committed to version control. This allows other developers involved in the project to check out the code, run `vagrant up`, and be on their way. Vagrantfiles are portable across every platform Vagrant supports.\n\nThe syntax of Vagrantfiles is [Ruby](http://www.ruby-lang.org), but knowledge of the Ruby programming language is not necessary to make modifications to the Vagrantfile, since it is mostly simple variable assignment. In fact, Ruby is not even the most popular community Vagrant is used within, which should help show you that despite not having Ruby knowledge, people are very successful with Vagrant.\n\n## Lookup Path\n\nWhen you run any `vagrant` command, Vagrant climbs up the directory tree looking for the first Vagrantfile it can find, starting first in the current directory. So if you run `vagrant` in `/home/mitchellh/projects/foo`, it will search the following paths in order for a Vagrantfile, until it finds one:\n\n``` highlight\n/home/mitchellh/projects/foo/Vagrantfile\n/home/mitchellh/projects/Vagrantfile\n/home/mitchellh/Vagrantfile\n/home/Vagrantfile\n/Vagrantfile\n```\n\nThis feature lets you run `vagrant` from any directory in your project.\n\nYou can change the starting directory where Vagrant looks for a Vagrantfile by setting the `VAGRANT_CWD` environmental variable to some other path.\n\n## Load Order and Merging\n\nAn important concept to understand is how Vagrant loads Vagrantfiles. Vagrant actually loads a series of Vagrantfiles, merging the settings as it goes. This allows Vagrantfiles of varying level of specificity to override prior settings. Vagrantfiles are loaded in the order shown below. Note that if a Vagrantfile is not found at any step, Vagrant continues with the next step.\n\n1.  Vagrantfile packaged with the [box](../boxes) that is to be used for a given machine.\n2.  Vagrantfile in your Vagrant home directory (defaults to `~/.vagrant.d`). This lets you specify some defaults for your system user.\n3.  Vagrantfile from the project directory. This is the Vagrantfile that you will be modifying most of the time.\n4.  [Multi-machine overrides](../multi-machine/index) if any.\n5.  [Provider-specific overrides](../providers/configuration), if any.\n\nAt each level, settings set will be merged with previous values. What this exactly means depends on the setting. For most settings, this means that the newer setting overrides the older one. However, for things such as defining networks, the networks are actually appended to each other. By default, you should assume that settings will override each other. If the behavior is different, it will be noted in the relevant documentation section.\n\nWithin each Vagrantfile, you may specify multiple `Vagrant.configure` blocks. All configurations will be merged within a single Vagrantfile in the order they're defined.\n\n## Available Configuration Options\n\nYou can learn more about the available configuration options by clicking the relevant section in the left navigational area.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/](https://www.vagrantup.com/docs/vagrantfile/)"
- name: VirtualBox
  id: virtualbox/index
  summary: Vagrant comes with support out of the box for VirtualBox, a free, cross-platform consumer virtualization product
  description: "# VirtualBox\n\nVagrant comes with support out of the box for [VirtualBox](https://www.virtualbox.org), a free, cross-platform consumer virtualization product.\n\nThe VirtualBox provider is compatible with VirtualBox versions 4.0.x, 4.1.x, 4.2.x, 4.3.x, 5.0.x, 5.1.x, and 5.2.x. Other versions are unsupported and the provider will display an error message. Please note that beta and pre-release versions of VirtualBox are not supported and may not be well-behaved.\n\nVirtualBox must be installed on its own prior to using the provider, or the provider will display an error message asking you to install it. VirtualBox can be installed by [downloading](https://www.virtualbox.org/wiki/Downloads) a package or installer for your operating system and using standard procedures to install that package.\n\nUse the navigation to the left to find a specific VirtualBox topic to read more about.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/virtualbox/](https://www.vagrantup.com/docs/virtualbox/)"
- name: VirtualBox
  id: synced-folders/virtualbox
  summary: If you are using the Vagrant VirtualBox provider, then VirtualBox shared folders are the default synced folder type
  description: "# VirtualBox\n\nIf you are using the Vagrant VirtualBox [provider](../providers/index), then VirtualBox shared folders are the default synced folder type. These synced folders use the VirtualBox shared folder system to sync file changes from the guest to the host and vice versa.\n\n## Options\n\n- [`SharedFoldersEnableSymlinksCreate`](#sharedfoldersenablesymlinkscreate) (boolean) - If false, will disable the ability to create symlinks with the given virtualbox shared folder. Defaults to true if the option is not present.\n\n## Caveats\n\nThere is a [VirtualBox bug](https://github.com/hashicorp/vagrant/issues/351#issuecomment-1339640) related to `sendfile` which can result in corrupted or non-updating files. You should deactivate `sendfile` in any web servers you may be running.\n\nIn Nginx:\n\n``` highlight\nsendfile off;\n```\n\nIn Apache:\n\n``` highlight\nEnableSendfile Off\n```\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/synced-folders/virtualbox.html](https://www.vagrantup.com/docs/synced-folders/virtualbox.html)"
- name: VMware
  id: vmware/index
  summary: HashiCorp develops an official VMware Fusion and VMware Workstation provider for Vagrant
  description: "# VMware\n\n[HashiCorp](https://www.hashicorp.com) develops an official [VMware Fusion](https://www.vmware.com/products/fusion/overview.html) and [VMware Workstation](https://www.vmware.com/products/workstation/) [provider](../providers/index) for Vagrant. This provider allows Vagrant to power VMware based machines and take advantage of the improved stability and performance that VMware software offers.\n\nLearn more about the VMware providers on the [VMware provider](https://www.vagrantup.com/vmware) page on the Vagrant website.\n\nThis provider is a drop-in replacement for VirtualBox, meaning that every VirtualBox feature that Vagrant supports is fully functional in VMware as well. However, there are some VMware-specific things such as box formats, configurations, etc. that are documented here.\n\nFor the most up-to-date information on compatibility and supported versions of VMware Fusion and VMware Workstation, please visit the [Vagrant VMware product page](https://www.vagrantup.com/vmware). Please note that VMware Fusion and VMware Workstation are third-party products that must be purchased and installed separately prior to using the provider.\n\nUse the navigation to the left to find a specific VMware topic to read more about.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vmware/](https://www.vagrantup.com/docs/vmware/)"
- name: VMware
  id: vmware
  summary: HashiCorp develops an official VMware Fusion and VMware Workstation provider for Vagrant
  description: "# VMware\n\n[HashiCorp](https://www.hashicorp.com) develops an official [VMware Fusion](https://www.vmware.com/products/fusion/overview.html) and [VMware Workstation](https://www.vmware.com/products/workstation/) [provider](providers/index) for Vagrant. This provider allows Vagrant to power VMware based machines and take advantage of the improved stability and performance that VMware software offers.\n\nLearn more about the VMware providers on the [VMware provider](https://www.vagrantup.com/vmware) page on the Vagrant website.\n\nThis provider is a drop-in replacement for VirtualBox, meaning that every VirtualBox feature that Vagrant supports is fully functional in VMware as well. However, there are some VMware-specific things such as box formats, configurations, etc. that are documented here.\n\nFor the most up-to-date information on compatibility and supported versions of VMware Fusion and VMware Workstation, please visit the [Vagrant VMware product page](https://www.vagrantup.com/vmware). Please note that VMware Fusion and VMware Workstation are third-party products that must be purchased and installed separately prior to using the provider.\n\nUse the navigation to the left to find a specific VMware topic to read more about.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vmware](https://www.vagrantup.com/docs/vmware)"
- name: WinRM Settings
  id: vagrantfile/winrm_settings
  summary: The settings within config.winrm relate to configuring how Vagrant will access your Windows guest over WinRM
  description: "# WinRM Settings\n\n**Config namespace: `config.winrm`**\n\nThe settings within `config.winrm` relate to configuring how Vagrant will access your Windows guest over WinRM. As with most Vagrant settings, the defaults are typically fine, but you can fine tune whatever you would like.\n\nThese settings are only used if you've set your communicator type to `:winrm`.\n\n## Available Settings\n\n- [`config.winrm.username`](#config-winrm-username) (string) - This sets the username that Vagrant will use to login to the WinRM web service by default. Providers are free to override this if they detect a more appropriate user. By default this is \"vagrant,\" since that is what most public boxes are made as.\n\n- [`config.winrm.password`](#config-winrm-password) (string) - This sets a password that Vagrant will use to authenticate the WinRM user. By default this is \"vagrant,\" since that is what most public boxes are made as.\n\n- [`config.winrm.host`](#config-winrm-host) (string) - The hostname or IP to connect to the WinRM service. By default this is empty, because the provider usually figures this out for you.\n\n- [`config.winrm.port`](#config-winrm-port) (integer) - The WinRM port to connect to, by default 5985.\n\n- [`config.winrm.guest_port`](#config-winrm-guest_port) (integer) - The port on the guest that WinRM is running on. This is used by some providers to detect forwarded ports for WinRM. For example, if this is set to 5985 (the default), and Vagrant detects a forwarded port to port 5985 on the guest from port 4567 on the host, Vagrant will attempt to use port 4567 to talk to the guest if there is no other option.\n\n- [`config.winrm.transport`](#config-winrm-transport) (symbol)- The transport used for WinRM communication. Valid settings include: `:negotiate`, `:ssl`, and `:plaintext`. The default is `:negotiate`.\n\n- [`config.winrm.basic_auth_only`](#config-winrm-basic_auth_only) (boolean) - Whether to use Basic Authentication. Defaults to `false`. If set to `true` you should also use the `:plaintext` transport setting and the Windows machine must be configured appropriately.\n\n  **Note:** It is strongly recommended that you only use basic authentication for debugging purposes. Credentials will be transferred in plain text.\n\n- [`config.winrm.ssl_peer_verification`](#config-winrm-ssl_peer_verification) (boolean) - When set to `false` ssl certificate validation is not performed.\n\n- [`config.winrm.timeout`](#config-winrm-timeout) (integer) - The maximum amount of time to wait for a response from the endpoint. This defaults to 60 seconds. Note that this will not \"timeout\" commands that exceed this amount of time to process, it just requires the endpoint to report the status of the command before the given amount of time passes.\n\n- [`config.winrm.retry_limit`](#config-winrm-retry_limit) (integer) - The maximum number of times to retry opening a shell after failure. This defaults to 3.\n\n- [`config.winrm.retry_delay`](#config-winrm-retry_delay) (integer) - The amount of time to wait between retries and defaults to 10 seconds.\n\n- [`config.winrm.codepage`](#config-winrm-codepage) (string) - The WINRS_CODEPAGE which is the client's console output code page. The default is 65001 (UTF-8).\n\n  **Note:** Versions of Windows older than Windows 7/Server 2008 R2 may exhibit undesirable behavior using the default UTF-8 codepage. When using these older versions of Windows, its best to use the native code page of the server's locale. For example, en-US servers will have a codepage of 437. The Windows `chcp` command can be used to determine the value of the native codepage.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/winrm_settings.html](https://www.vagrantup.com/docs/vagrantfile/winrm_settings.html)"
- name: WinSSH
  id: vagrantfile/winssh_settings
  summary: The WinSSH communicator is built specifically for the Windows native port of OpenSSH
  description: "# WinSSH\n\nThe WinSSH communicator is built specifically for the Windows native port of OpenSSH. It does not rely on a POSIX-like environment which removes the requirement of extra software installation (like cygwin) for proper functionality.\n\nFor more information, see the [Win32-OpenSSH project page](https://github.com/PowerShell/Win32-OpenSSH/).\n\n# WinSSH Settings\n\nThe WinSSH communicator uses the same connection configuration options as the SSH communicator. These settings provide the information for the communicator to establish a connection to the VM.\n\nThe configuration options below are specific to the WinSSH communicator.\n\n**Config namespace: `config.winssh`**\n\n## Available Settings\n\n- [`config.winssh.forward_agent`](#config-winssh-forward_agent) (boolean) - If `true`, agent forwarding over SSH connections is enabled. Defaults to false.\n\n- [`config.winssh.forward_env`](#config-winssh-forward_env) (array of strings) - An array of host environment variables to forward to the guest. If you are familiar with OpenSSH, this corresponds to the `SendEnv` parameter.\n\n  ``` ruby\n  config.winssh.forward_env = [\"CUSTOM_VAR\"]\n  ```\n\n- [`config.winssh.proxy_command`](#config-winssh-proxy_command) (string) - A command-line command to execute that receives the data to send to SSH on stdin. This can be used to proxy the SSH connection. `%h` in the command is replaced with the host and `%p` is replaced with the port.\n\n- [`config.winssh.keep_alive`](#config-winssh-keep_alive) (boolean) - If `true`, this setting SSH will send keep-alive packets every 5 seconds by default to keep connections alive.\n\n- [`config.winssh.shell`](#config-winssh-shell) (string) - The shell to use when executing SSH commands from Vagrant. By default this is `cmd`. Valid values are `\"cmd\"` or `\"powershell\"`. Note that this has no effect on the shell you get when you run `vagrant ssh`. This configuration option only affects the shell to use when executing commands internally in Vagrant.\n\n- [`config.winssh.export_command_template`](#config-winssh-export_command_template) (string) - The template used to generate exported environment variables in the active session. This can be useful when using a Bourne incompatible shell like C shell. The template supports two variables which are replaced with the desired environment variable key and environment variable value: `%ENV_KEY%` and `%ENV_VALUE%`. The default template for a `cmd` configured shell is:\n\n  ``` ruby\n  config.winssh.export_command_template = 'set %ENV_KEY%=\"%ENV_VALUE%\"'\n  ```\n\n  The default template for a `powershell` configured shell is:\n\n  ``` ruby\n  config.winssh.export_command_template = '$env:%ENV_KEY%=\"%ENV_VALUE%\"'\n  ```\n\n- [`config.winssh.sudo_command`](#config-winssh-sudo_command) (string) - The command to use when executing a command with `sudo`. This defaults to `%c` (assumes vagrant user is an administrator and needs no escalation). The `%c` will be replaced by the command that is being executed.\n\n- [`config.winssh.upload_directory`](#config-winssh-upload_directory) (string) - The upload directory used on the guest to store scripts for execute. This is set to `C:\\Windows\\Temp` by default.\n\n© 2010–2018 Mitchell Hashimoto  \nLicensed under the MPL 2.0 License.  \n[https://www.vagrantup.com/docs/vagrantfile/winssh_settings.html](https://www.vagrantup.com/docs/vagrantfile/winssh_settings.html)"
