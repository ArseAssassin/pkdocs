---
name: Django REST Framework
slug: django_rest_framework
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  Copyright © 2011–present Encode OSS Ltd.
  Licensed under the BSD License.
  https://www.django-rest-framework.org/index.html
homepage: https://www.django-rest-framework.org/

---
- name: '0: Quickstart'
  id: tutorial/quickstart/index
  summary: We're going to create a simple API to allow admin users to view and edit the users and groups in the system
  description: "# Quickstart\n\nWe're going to create a simple API to allow admin users to view and edit the users and groups in the system.\n\n## Project setup\n\nCreate a new Django project named `tutorial`, then start a new app called `quickstart`.\n\n``` python\n# Create the project directory\nmkdir tutorial\ncd tutorial\n\n# Create a virtual environment to isolate our package dependencies locally\npython3 -m venv env\nsource env/bin/activate  # On Windows use `env\\Scripts\\activate`\n\n# Install Django and Django REST framework into the virtual environment\npip install djangorestframework\n\n# Set up a new project with a single application\ndjango-admin startproject tutorial .  # Note the trailing '.' character\ncd tutorial\ndjango-admin startapp quickstart\ncd ..\n```\n\nThe project layout should look like:\n\n``` python\n$ pwd\n<some path>/tutorial\n$ find .\n.\n./tutorial\n./tutorial/asgi.py\n./tutorial/__init__.py\n./tutorial/quickstart\n./tutorial/quickstart/migrations\n./tutorial/quickstart/migrations/__init__.py\n./tutorial/quickstart/models.py\n./tutorial/quickstart/__init__.py\n./tutorial/quickstart/apps.py\n./tutorial/quickstart/admin.py\n./tutorial/quickstart/tests.py\n./tutorial/quickstart/views.py\n./tutorial/settings.py\n./tutorial/urls.py\n./tutorial/wsgi.py\n./env\n./env/...\n./manage.py\n```\n\nIt may look unusual that the application has been created within the project directory. Using the project's namespace avoids name clashes with external modules (a topic that goes outside the scope of the quickstart).\n\nNow sync your database for the first time:\n\n``` python\npython manage.py migrate\n```\n\nWe'll also create an initial user named `admin` with a password. We'll authenticate as that user later in our example.\n\n``` python\npython manage.py createsuperuser --username admin --email admin@example.com\n```\n\nOnce you've set up a database and the initial user is created and ready to go, open up the app's directory and we'll get coding...\n\n## Serializers\n\nFirst up we're going to define some serializers. Let's create a new module named `tutorial/quickstart/serializers.py` that we'll use for our data representations.\n\n``` python\nfrom django.contrib.auth.models import Group, User\nfrom rest_framework import serializers\n\n\nclass UserSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = User\n        fields = ['url', 'username', 'email', 'groups']\n\n\nclass GroupSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = Group\n        fields = ['url', 'name']\n```\n\nNotice that we're using hyperlinked relations in this case with `HyperlinkedModelSerializer`. You can also use primary key and various other relationships, but hyperlinking is good RESTful design.\n\n## Views\n\nRight, we'd better write some views then. Open `tutorial/quickstart/views.py` and get typing.\n\n``` python\nfrom django.contrib.auth.models import Group, User\nfrom rest_framework import permissions, viewsets\n\nfrom tutorial.quickstart.serializers import GroupSerializer, UserSerializer\n\n\nclass UserViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    API endpoint that allows users to be viewed or edited.\n    \"\"\"\n    queryset = User.objects.all().order_by('-date_joined')\n    serializer_class = UserSerializer\n    permission_classes = [permissions.IsAuthenticated]\n\n\nclass GroupViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    API endpoint that allows groups to be viewed or edited.\n    \"\"\"\n    queryset = Group.objects.all().order_by('name')\n    serializer_class = GroupSerializer\n    permission_classes = [permissions.IsAuthenticated]\n```\n\nRather than write multiple views we're grouping together all the common behavior into classes called `ViewSets`.\n\nWe can easily break these down into individual views if we need to, but using viewsets keeps the view logic nicely organized as well as being very concise.\n\n## URLs\n\nOkay, now let's wire up the API URLs. On to `tutorial/urls.py`...\n\n``` python\nfrom django.urls import include, path\nfrom rest_framework import routers\n\nfrom tutorial.quickstart import views\n\nrouter = routers.DefaultRouter()\nrouter.register(r'users', views.UserViewSet)\nrouter.register(r'groups', views.GroupViewSet)\n\n# Wire up our API using automatic URL routing.\n# Additionally, we include login URLs for the browsable API.\nurlpatterns = [\n    path('', include(router.urls)),\n    path('api-auth/', include('rest_framework.urls', namespace='rest_framework'))\n]\n```\n\nBecause we're using viewsets instead of views, we can automatically generate the URL conf for our API, by simply registering the viewsets with a router class.\n\nAgain, if we need more control over the API URLs we can simply drop down to using regular class-based views, and writing the URL conf explicitly.\n\nFinally, we're including default login and logout views for use with the browsable API. That's optional, but useful if your API requires authentication and you want to use the browsable API.\n\n## Pagination\n\nPagination allows you to control how many objects per page are returned. To enable it add the following lines to `tutorial/settings.py`\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',\n    'PAGE_SIZE': 10\n}\n```\n\n## Settings\n\nAdd `'rest_framework'` to `INSTALLED_APPS`. The settings module will be in `tutorial/settings.py`\n\n``` python\nINSTALLED_APPS = [\n    ...\n    'rest_framework',\n]\n```\n\nOkay, we're done.\n\n## Testing our API\n\nWe're now ready to test the API we've built. Let's fire up the server from the command line.\n\n``` python\npython manage.py runserver\n```\n\nWe can now access our API, both from the command-line, using tools like `curl`...\n\n``` python\nbash: curl -u admin -H 'Accept: application/json; indent=4' http://127.0.0.1:8000/users/\nEnter host password for user 'admin':\n{\n    \"count\": 1,\n    \"next\": null,\n    \"previous\": null,\n    \"results\": [\n        {\n            \"url\": \"http://127.0.0.1:8000/users/1/\",\n            \"username\": \"admin\",\n            \"email\": \"admin@example.com\",\n            \"groups\": []\n        }\n    ]\n}\n```\n\nOr using the [httpie](https://httpie.io/docs#installation), command line tool...\n\n``` python\nbash: http -a admin http://127.0.0.1:8000/users/\nhttp: password for admin@127.0.0.1:8000:: \n$HTTP/1.1 200 OK\n...\n{\n    \"count\": 1,\n    \"next\": null,\n    \"previous\": null,\n    \"results\": [\n        {\n            \"email\": \"admin@example.com\",\n            \"groups\": [],\n            \"url\": \"http://127.0.0.1:8000/users/1/\",\n            \"username\": \"admin\"\n        }\n    ]\n}\n```\n\nOr directly through the browser, by going to the URL `http://127.0.0.1:8000/users/`...\n\nIf you're working through the browser, make sure to login using the control in the top right corner.\n\nGreat, that was easy!\n\nIf you want to get a more in depth understanding of how REST framework fits together head on over to [the tutorial](../1-serialization/index), or start browsing the [API guide](../../api-guide/requests/index).\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/tutorial/quickstart/](https://www.django-rest-framework.org/tutorial/quickstart/)"
- name: '1: Serialization'
  id: tutorial/1-serialization/index
  summary: This tutorial will cover creating a simple pastebin code highlighting Web API
  description: "# Tutorial 1: Serialization\n\n## Introduction\n\nThis tutorial will cover creating a simple pastebin code highlighting Web API. Along the way it will introduce the various components that make up REST framework, and give you a comprehensive understanding of how everything fits together.\n\nThe tutorial is fairly in-depth, so you should probably get a cookie and a cup of your favorite brew before getting started. If you just want a quick overview, you should head over to the [quickstart](../quickstart/index) documentation instead.\n\n**Note**: The code for this tutorial is available in the [encode/rest-framework-tutorial](https://github.com/encode/rest-framework-tutorial) repository on GitHub. Feel free to clone the repository and see the code in action.\n\n## Setting up a new environment\n\nBefore we do anything else we'll create a new virtual environment, using [venv](https://docs.python.org/3/library/venv.html). This will make sure our package configuration is kept nicely isolated from any other projects we're working on.\n\n``` python\npython3 -m venv env\nsource env/bin/activate\n```\n\nNow that we're inside a virtual environment, we can install our package requirements.\n\n``` python\npip install django\npip install djangorestframework\npip install pygments  # We'll be using this for the code highlighting\n```\n\n**Note:** To exit the virtual environment at any time, just type `deactivate`. For more information see the [venv documentation](https://docs.python.org/3/library/venv.html).\n\n## Getting started\n\nOkay, we're ready to get coding. To get started, let's create a new project to work with.\n\n``` python\ncd ~\ndjango-admin startproject tutorial\ncd tutorial\n```\n\nOnce that's done we can create an app that we'll use to create a simple Web API.\n\n``` python\npython manage.py startapp snippets\n```\n\nWe'll need to add our new `snippets` app and the `rest_framework` app to `INSTALLED_APPS`. Let's edit the `tutorial/settings.py` file:\n\n``` python\nINSTALLED_APPS = [\n    ...\n    'rest_framework',\n    'snippets',\n]\n```\n\nOkay, we're ready to roll.\n\n## Creating a model to work with\n\nFor the purposes of this tutorial we're going to start by creating a simple `Snippet` model that is used to store code snippets. Go ahead and edit the `snippets/models.py` file. Note: Good programming practices include comments. Although you will find them in our repository version of this tutorial code, we have omitted them here to focus on the code itself.\n\n``` python\nfrom django.db import models\nfrom pygments.lexers import get_all_lexers\nfrom pygments.styles import get_all_styles\n\nLEXERS = [item for item in get_all_lexers() if item[1]]\nLANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS])\nSTYLE_CHOICES = sorted([(item, item) for item in get_all_styles()])\n\n\nclass Snippet(models.Model):\n    created = models.DateTimeField(auto_now_add=True)\n    title = models.CharField(max_length=100, blank=True, default='')\n    code = models.TextField()\n    linenos = models.BooleanField(default=False)\n    language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100)\n    style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100)\n\n    class Meta:\n        ordering = ['created']\n```\n\nWe'll also need to create an initial migration for our snippet model, and sync the database for the first time.\n\n``` python\npython manage.py makemigrations snippets\npython manage.py migrate snippets\n```\n\n## Creating a Serializer class\n\nThe first thing we need to get started on our Web API is to provide a way of serializing and deserializing the snippet instances into representations such as `json`. We can do this by declaring serializers that work very similar to Django's forms. Create a file in the `snippets` directory named `serializers.py` and add the following.\n\n``` python\nfrom rest_framework import serializers\nfrom snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICES\n\n\nclass SnippetSerializer(serializers.Serializer):\n    id = serializers.IntegerField(read_only=True)\n    title = serializers.CharField(required=False, allow_blank=True, max_length=100)\n    code = serializers.CharField(style={'base_template': 'textarea.html'})\n    linenos = serializers.BooleanField(required=False)\n    language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python')\n    style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly')\n\n    def create(self, validated_data):\n        \"\"\"\n        Create and return a new `Snippet` instance, given the validated data.\n        \"\"\"\n        return Snippet.objects.create(**validated_data)\n\n    def update(self, instance, validated_data):\n        \"\"\"\n        Update and return an existing `Snippet` instance, given the validated data.\n        \"\"\"\n        instance.title = validated_data.get('title', instance.title)\n        instance.code = validated_data.get('code', instance.code)\n        instance.linenos = validated_data.get('linenos', instance.linenos)\n        instance.language = validated_data.get('language', instance.language)\n        instance.style = validated_data.get('style', instance.style)\n        instance.save()\n        return instance\n```\n\nThe first part of the serializer class defines the fields that get serialized/deserialized. The `create()` and `update()` methods define how fully fledged instances are created or modified when calling `serializer.save()`\n\nA serializer class is very similar to a Django `Form` class, and includes similar validation flags on the various fields, such as `required`, `max_length` and `default`.\n\nThe field flags can also control how the serializer should be displayed in certain circumstances, such as when rendering to HTML. The `{'base_template': 'textarea.html'}` flag above is equivalent to using `widget=widgets.Textarea` on a Django `Form` class. This is particularly useful for controlling how the browsable API should be displayed, as we'll see later in the tutorial.\n\nWe can actually also save ourselves some time by using the `ModelSerializer` class, as we'll see later, but for now we'll keep our serializer definition explicit.\n\n## Working with Serializers\n\nBefore we go any further we'll familiarize ourselves with using our new Serializer class. Let's drop into the Django shell.\n\n``` python\npython manage.py shell\n```\n\nOkay, once we've got a few imports out of the way, let's create a couple of code snippets to work with.\n\n``` python\nfrom snippets.models import Snippet\nfrom snippets.serializers import SnippetSerializer\nfrom rest_framework.renderers import JSONRenderer\nfrom rest_framework.parsers import JSONParser\n\nsnippet = Snippet(code='foo = \"bar\"\\n')\nsnippet.save()\n\nsnippet = Snippet(code='print(\"hello, world\")\\n')\nsnippet.save()\n```\n\nWe've now got a few snippet instances to play with. Let's take a look at serializing one of those instances.\n\n``` python\nserializer = SnippetSerializer(snippet)\nserializer.data\n# {'id': 2, 'title': '', 'code': 'print(\"hello, world\")\\n', 'linenos': False, 'language': 'python', 'style': 'friendly'}\n```\n\nAt this point we've translated the model instance into Python native datatypes. To finalize the serialization process we render the data into `json`.\n\n``` python\ncontent = JSONRenderer().render(serializer.data)\ncontent\n# b'{\"id\":2,\"title\":\"\",\"code\":\"print(\\\\\"hello, world\\\\\")\\\\n\",\"linenos\":false,\"language\":\"python\",\"style\":\"friendly\"}'\n```\n\nDeserialization is similar. First we parse a stream into Python native datatypes...\n\n``` python\nimport io\n\nstream = io.BytesIO(content)\ndata = JSONParser().parse(stream)\n```\n\n...then we restore those native datatypes into a fully populated object instance.\n\n``` python\nserializer = SnippetSerializer(data=data)\nserializer.is_valid()\n# True\nserializer.validated_data\n# {'title': '', 'code': 'print(\"hello, world\")', 'linenos': False, 'language': 'python', 'style': 'friendly'}\nserializer.save()\n# <Snippet: Snippet object>\n```\n\nNotice how similar the API is to working with forms. The similarity should become even more apparent when we start writing views that use our serializer.\n\nWe can also serialize querysets instead of model instances. To do so we simply add a `many=True` flag to the serializer arguments.\n\n``` python\nserializer = SnippetSerializer(Snippet.objects.all(), many=True)\nserializer.data\n# [{'id': 1, 'title': '', 'code': 'foo = \"bar\"\\n', 'linenos': False, 'language': 'python', 'style': 'friendly'}, {'id': 2, 'title': '', 'code': 'print(\"hello, world\")\\n', 'linenos': False, 'language': 'python', 'style': 'friendly'}, {'id': 3, 'title': '', 'code': 'print(\"hello, world\")', 'linenos': False, 'language': 'python', 'style': 'friendly'}]\n```\n\n## Using ModelSerializers\n\nOur `SnippetSerializer` class is replicating a lot of information that's also contained in the `Snippet` model. It would be nice if we could keep our code a bit more concise.\n\nIn the same way that Django provides both `Form` classes and `ModelForm` classes, REST framework includes both `Serializer` classes, and `ModelSerializer` classes.\n\nLet's look at refactoring our serializer using the `ModelSerializer` class. Open the file `snippets/serializers.py` again, and replace the `SnippetSerializer` class with the following.\n\n``` python\nclass SnippetSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Snippet\n        fields = ['id', 'title', 'code', 'linenos', 'language', 'style']\n```\n\nOne nice property that serializers have is that you can inspect all the fields in a serializer instance, by printing its representation. Open the Django shell with `python manage.py shell`, then try the following:\n\n``` python\nfrom snippets.serializers import SnippetSerializer\nserializer = SnippetSerializer()\nprint(repr(serializer))\n# SnippetSerializer():\n#    id = IntegerField(label='ID', read_only=True)\n#    title = CharField(allow_blank=True, max_length=100, required=False)\n#    code = CharField(style={'base_template': 'textarea.html'})\n#    linenos = BooleanField(required=False)\n#    language = ChoiceField(choices=[('Clipper', 'FoxPro'), ('Cucumber', 'Gherkin'), ('RobotFramework', 'RobotFramework'), ('abap', 'ABAP'), ('ada', 'Ada')...\n#    style = ChoiceField(choices=[('autumn', 'autumn'), ('borland', 'borland'), ('bw', 'bw'), ('colorful', 'colorful')...\n```\n\nIt's important to remember that `ModelSerializer` classes don't do anything particularly magical, they are simply a shortcut for creating serializer classes:\n\n- An automatically determined set of fields.\n- Simple default implementations for the `create()` and `update()` methods.\n\n## Writing regular Django views using our Serializer\n\nLet's see how we can write some API views using our new Serializer class. For the moment we won't use any of REST framework's other features, we'll just write the views as regular Django views.\n\nEdit the `snippets/views.py` file, and add the following.\n\n``` python\nfrom django.http import HttpResponse, JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom rest_framework.parsers import JSONParser\nfrom snippets.models import Snippet\nfrom snippets.serializers import SnippetSerializer\n```\n\nThe root of our API is going to be a view that supports listing all the existing snippets, or creating a new snippet.\n\n``` python\n@csrf_exempt\ndef snippet_list(request):\n    \"\"\"\n    List all code snippets, or create a new snippet.\n    \"\"\"\n    if request.method == 'GET':\n        snippets = Snippet.objects.all()\n        serializer = SnippetSerializer(snippets, many=True)\n        return JsonResponse(serializer.data, safe=False)\n\n    elif request.method == 'POST':\n        data = JSONParser().parse(request)\n        serializer = SnippetSerializer(data=data)\n        if serializer.is_valid():\n            serializer.save()\n            return JsonResponse(serializer.data, status=201)\n        return JsonResponse(serializer.errors, status=400)\n```\n\nNote that because we want to be able to POST to this view from clients that won't have a CSRF token we need to mark the view as `csrf_exempt`. This isn't something that you'd normally want to do, and REST framework views actually use more sensible behavior than this, but it'll do for our purposes right now.\n\nWe'll also need a view which corresponds to an individual snippet, and can be used to retrieve, update or delete the snippet.\n\n``` python\n@csrf_exempt\ndef snippet_detail(request, pk):\n    \"\"\"\n    Retrieve, update or delete a code snippet.\n    \"\"\"\n    try:\n        snippet = Snippet.objects.get(pk=pk)\n    except Snippet.DoesNotExist:\n        return HttpResponse(status=404)\n\n    if request.method == 'GET':\n        serializer = SnippetSerializer(snippet)\n        return JsonResponse(serializer.data)\n\n    elif request.method == 'PUT':\n        data = JSONParser().parse(request)\n        serializer = SnippetSerializer(snippet, data=data)\n        if serializer.is_valid():\n            serializer.save()\n            return JsonResponse(serializer.data)\n        return JsonResponse(serializer.errors, status=400)\n\n    elif request.method == 'DELETE':\n        snippet.delete()\n        return HttpResponse(status=204)\n```\n\nFinally we need to wire these views up. Create the `snippets/urls.py` file:\n\n``` python\nfrom django.urls import path\nfrom snippets import views\n\nurlpatterns = [\n    path('snippets/', views.snippet_list),\n    path('snippets/<int:pk>/', views.snippet_detail),\n]\n```\n\nWe also need to wire up the root urlconf, in the `tutorial/urls.py` file, to include our snippet app's URLs.\n\n``` python\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('', include('snippets.urls')),\n]\n```\n\nIt's worth noting that there are a couple of edge cases we're not dealing with properly at the moment. If we send malformed `json`, or if a request is made with a method that the view doesn't handle, then we'll end up with a 500 \"server error\" response. Still, this'll do for now.\n\n## Testing our first attempt at a Web API\n\nNow we can start up a sample server that serves our snippets.\n\nQuit out of the shell...\n\n``` python\nquit()\n```\n\n...and start up Django's development server.\n\n``` python\npython manage.py runserver\n\nValidating models...\n\n0 errors found\nDjango version 5.0, using settings 'tutorial.settings'\nStarting Development server at http://127.0.0.1:8000/\nQuit the server with CONTROL-C.\n```\n\nIn another terminal window, we can test the server.\n\nWe can test our API using [curl](https://curl.haxx.se/) or [httpie](https://github.com/httpie/httpie#installation). Httpie is a user friendly http client that's written in Python. Let's install that.\n\nYou can install httpie using pip:\n\n``` python\npip install httpie\n```\n\nFinally, we can get a list of all of the snippets:\n\n``` python\nhttp http://127.0.0.1:8000/snippets/ --unsorted\n\nHTTP/1.1 200 OK\n...\n[\n    {\n        \"id\": 1,\n        \"title\": \"\",\n        \"code\": \"foo = \\\"bar\\\"\\n\",\n        \"linenos\": false,\n        \"language\": \"python\",\n        \"style\": \"friendly\"\n    },\n    {\n        \"id\": 2,\n        \"title\": \"\",\n        \"code\": \"print(\\\"hello, world\\\")\\n\",\n        \"linenos\": false,\n        \"language\": \"python\",\n        \"style\": \"friendly\"\n    },\n    {\n        \"id\": 3,\n        \"title\": \"\",\n        \"code\": \"print(\\\"hello, world\\\")\",\n        \"linenos\": false,\n        \"language\": \"python\",\n        \"style\": \"friendly\"\n    }\n]\n```\n\nOr we can get a particular snippet by referencing its id:\n\n``` python\nhttp http://127.0.0.1:8000/snippets/2/ --unsorted\n\nHTTP/1.1 200 OK\n...\n{\n    \"id\": 2,\n    \"title\": \"\",\n    \"code\": \"print(\\\"hello, world\\\")\\n\",\n    \"linenos\": false,\n    \"language\": \"python\",\n    \"style\": \"friendly\"\n}\n```\n\nSimilarly, you can have the same json displayed by visiting these URLs in a web browser.\n\n## Where are we now\n\nWe're doing okay so far, we've got a serialization API that feels pretty similar to Django's Forms API, and some regular Django views.\n\nOur API views don't do anything particularly special at the moment, beyond serving `json` responses, and there are some error handling edge cases we'd still like to clean up, but it's a functioning Web API.\n\nWe'll see how we can start to improve things in [part 2 of the tutorial](../2-requests-and-responses/index).\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/tutorial/1-serialization/](https://www.django-rest-framework.org/tutorial/1-serialization/)"
- name: '2: Requests and Responses'
  id: tutorial/2-requests-and-responses/index
  summary: From this point we're going to really start covering the core of REST framework
  description: "# Tutorial 2: Requests and Responses\n\nFrom this point we're going to really start covering the core of REST framework. Let's introduce a couple of essential building blocks.\n\n## Request objects\n\nREST framework introduces a `Request` object that extends the regular `HttpRequest`, and provides more flexible request parsing. The core functionality of the `Request` object is the `request.data` attribute, which is similar to `request.POST`, but more useful for working with Web APIs.\n\n``` python\nrequest.POST  # Only handles form data.  Only works for 'POST' method.\nrequest.data  # Handles arbitrary data.  Works for 'POST', 'PUT' and 'PATCH' methods.\n```\n\n## Response objects\n\nREST framework also introduces a `Response` object, which is a type of `TemplateResponse` that takes unrendered content and uses content negotiation to determine the correct content type to return to the client.\n\n``` python\nreturn Response(data)  # Renders to content type as requested by the client.\n```\n\n## Status codes\n\nUsing numeric HTTP status codes in your views doesn't always make for obvious reading, and it's easy to not notice if you get an error code wrong. REST framework provides more explicit identifiers for each status code, such as `HTTP_400_BAD_REQUEST` in the `status` module. It's a good idea to use these throughout rather than using numeric identifiers.\n\n## Wrapping API views\n\nREST framework provides two wrappers you can use to write API views.\n\n1.  The `@api_view` decorator for working with function based views.\n2.  The `APIView` class for working with class-based views.\n\nThese wrappers provide a few bits of functionality such as making sure you receive `Request` instances in your view, and adding context to `Response` objects so that content negotiation can be performed.\n\nThe wrappers also provide behavior such as returning `405 Method Not Allowed` responses when appropriate, and handling any `ParseError` exceptions that occur when accessing `request.data` with malformed input.\n\n## Pulling it all together\n\nOkay, let's go ahead and start using these new components to refactor our views slightly.\n\n``` python\nfrom rest_framework import status\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\nfrom snippets.models import Snippet\nfrom snippets.serializers import SnippetSerializer\n\n\n@api_view(['GET', 'POST'])\ndef snippet_list(request):\n    \"\"\"\n    List all code snippets, or create a new snippet.\n    \"\"\"\n    if request.method == 'GET':\n        snippets = Snippet.objects.all()\n        serializer = SnippetSerializer(snippets, many=True)\n        return Response(serializer.data)\n\n    elif request.method == 'POST':\n        serializer = SnippetSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n```\n\nOur instance view is an improvement over the previous example. It's a little more concise, and the code now feels very similar to if we were working with the Forms API. We're also using named status codes, which makes the response meanings more obvious.\n\nHere is the view for an individual snippet, in the `views.py` module.\n\n``` python\n@api_view(['GET', 'PUT', 'DELETE'])\ndef snippet_detail(request, pk):\n    \"\"\"\n    Retrieve, update or delete a code snippet.\n    \"\"\"\n    try:\n        snippet = Snippet.objects.get(pk=pk)\n    except Snippet.DoesNotExist:\n        return Response(status=status.HTTP_404_NOT_FOUND)\n\n    if request.method == 'GET':\n        serializer = SnippetSerializer(snippet)\n        return Response(serializer.data)\n\n    elif request.method == 'PUT':\n        serializer = SnippetSerializer(snippet, data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n    elif request.method == 'DELETE':\n        snippet.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\nThis should all feel very familiar - it is not a lot different from working with regular Django views.\n\nNotice that we're no longer explicitly tying our requests or responses to a given content type. `request.data` can handle incoming `json` requests, but it can also handle other formats. Similarly we're returning response objects with data, but allowing REST framework to render the response into the correct content type for us.\n\n## Adding optional format suffixes to our URLs\n\nTo take advantage of the fact that our responses are no longer hardwired to a single content type let's add support for format suffixes to our API endpoints. Using format suffixes gives us URLs that explicitly refer to a given format, and means our API will be able to handle URLs such as <http://example.com/api/items/4.json>.\n\nStart by adding a `format` keyword argument to both of the views, like so.\n\n``` python\ndef snippet_list(request, format=None):\n```\n\nand\n\n``` python\ndef snippet_detail(request, pk, format=None):\n```\n\nNow update the `snippets/urls.py` file slightly, to append a set of `format_suffix_patterns` in addition to the existing URLs.\n\n``` python\nfrom django.urls import path\nfrom rest_framework.urlpatterns import format_suffix_patterns\nfrom snippets import views\n\nurlpatterns = [\n    path('snippets/', views.snippet_list),\n    path('snippets/<int:pk>/', views.snippet_detail),\n]\n\nurlpatterns = format_suffix_patterns(urlpatterns)\n```\n\nWe don't necessarily need to add these extra url patterns in, but it gives us a simple, clean way of referring to a specific format.\n\n## How's it looking?\n\nGo ahead and test the API from the command line, as we did in [tutorial part 1](../1-serialization/index). Everything is working pretty similarly, although we've got some nicer error handling if we send invalid requests.\n\nWe can get a list of all of the snippets, as before.\n\n``` python\nhttp http://127.0.0.1:8000/snippets/\n\nHTTP/1.1 200 OK\n...\n[\n  {\n    \"id\": 1,\n    \"title\": \"\",\n    \"code\": \"foo = \\\"bar\\\"\\n\",\n    \"linenos\": false,\n    \"language\": \"python\",\n    \"style\": \"friendly\"\n  },\n  {\n    \"id\": 2,\n    \"title\": \"\",\n    \"code\": \"print(\\\"hello, world\\\")\\n\",\n    \"linenos\": false,\n    \"language\": \"python\",\n    \"style\": \"friendly\"\n  }\n]\n```\n\nWe can control the format of the response that we get back, either by using the `Accept` header:\n\n``` python\nhttp http://127.0.0.1:8000/snippets/ Accept:application/json  # Request JSON\nhttp http://127.0.0.1:8000/snippets/ Accept:text/html         # Request HTML\n```\n\nOr by appending a format suffix:\n\n``` python\nhttp http://127.0.0.1:8000/snippets.json  # JSON suffix\nhttp http://127.0.0.1:8000/snippets.api   # Browsable API suffix\n```\n\nSimilarly, we can control the format of the request that we send, using the `Content-Type` header.\n\n``` python\n# POST using form data\nhttp --form POST http://127.0.0.1:8000/snippets/ code=\"print(123)\"\n\n{\n  \"id\": 3,\n  \"title\": \"\",\n  \"code\": \"print(123)\",\n  \"linenos\": false,\n  \"language\": \"python\",\n  \"style\": \"friendly\"\n}\n\n# POST using JSON\nhttp --json POST http://127.0.0.1:8000/snippets/ code=\"print(456)\"\n\n{\n    \"id\": 4,\n    \"title\": \"\",\n    \"code\": \"print(456)\",\n    \"linenos\": false,\n    \"language\": \"python\",\n    \"style\": \"friendly\"\n}\n```\n\nIf you add a `--debug` switch to the `http` requests above, you will be able to see the request type in request headers.\n\nNow go and open the API in a web browser, by visiting <http://127.0.0.1:8000/snippets/>.\n\n### Browsability\n\nBecause the API chooses the content type of the response based on the client request, it will, by default, return an HTML-formatted representation of the resource when that resource is requested by a web browser. This allows for the API to return a fully web-browsable HTML representation.\n\nHaving a web-browsable API is a huge usability win, and makes developing and using your API much easier. It also dramatically lowers the barrier-to-entry for other developers wanting to inspect and work with your API.\n\nSee the [browsable api](https://www.django-rest-framework.org/topics/browsable-api/) topic for more information about the browsable API feature and how to customize it.\n\n## What's next?\n\nIn [tutorial part 3](../3-class-based-views/index), we'll start using class-based views, and see how generic views reduce the amount of code we need to write.\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/tutorial/2-requests-and-responses/](https://www.django-rest-framework.org/tutorial/2-requests-and-responses/)"
- name: '3: Class-based Views'
  id: tutorial/3-class-based-views/index
  summary: We can also write our API views using class-based views, rather than function based views
  description: "# Tutorial 3: Class-based Views\n\nWe can also write our API views using class-based views, rather than function based views. As we'll see this is a powerful pattern that allows us to reuse common functionality, and helps us keep our code [DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself).\n\n## Rewriting our API using class-based views\n\nWe'll start by rewriting the root view as a class-based view. All this involves is a little bit of refactoring of `views.py`.\n\n``` python\nfrom snippets.models import Snippet\nfrom snippets.serializers import SnippetSerializer\nfrom django.http import Http404\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\n\n\nclass SnippetList(APIView):\n    \"\"\"\n    List all snippets, or create a new snippet.\n    \"\"\"\n    def get(self, request, format=None):\n        snippets = Snippet.objects.all()\n        serializer = SnippetSerializer(snippets, many=True)\n        return Response(serializer.data)\n\n    def post(self, request, format=None):\n        serializer = SnippetSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n```\n\nSo far, so good. It looks pretty similar to the previous case, but we've got better separation between the different HTTP methods. We'll also need to update the instance view in `views.py`.\n\n``` python\nclass SnippetDetail(APIView):\n    \"\"\"\n    Retrieve, update or delete a snippet instance.\n    \"\"\"\n    def get_object(self, pk):\n        try:\n            return Snippet.objects.get(pk=pk)\n        except Snippet.DoesNotExist:\n            raise Http404\n\n    def get(self, request, pk, format=None):\n        snippet = self.get_object(pk)\n        serializer = SnippetSerializer(snippet)\n        return Response(serializer.data)\n\n    def put(self, request, pk, format=None):\n        snippet = self.get_object(pk)\n        serializer = SnippetSerializer(snippet, data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n    def delete(self, request, pk, format=None):\n        snippet = self.get_object(pk)\n        snippet.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n```\n\nThat's looking good. Again, it's still pretty similar to the function based view right now.\n\nWe'll also need to refactor our `snippets/urls.py` slightly now that we're using class-based views.\n\n``` python\nfrom django.urls import path\nfrom rest_framework.urlpatterns import format_suffix_patterns\nfrom snippets import views\n\nurlpatterns = [\n    path('snippets/', views.SnippetList.as_view()),\n    path('snippets/<int:pk>/', views.SnippetDetail.as_view()),\n]\n\nurlpatterns = format_suffix_patterns(urlpatterns)\n```\n\nOkay, we're done. If you run the development server everything should be working just as before.\n\n## Using mixins\n\nOne of the big wins of using class-based views is that it allows us to easily compose reusable bits of behavior.\n\nThe create/retrieve/update/delete operations that we've been using so far are going to be pretty similar for any model-backed API views we create. Those bits of common behavior are implemented in REST framework's mixin classes.\n\nLet's take a look at how we can compose the views by using the mixin classes. Here's our `views.py` module again.\n\n``` python\nfrom snippets.models import Snippet\nfrom snippets.serializers import SnippetSerializer\nfrom rest_framework import mixins\nfrom rest_framework import generics\n\nclass SnippetList(mixins.ListModelMixin,\n                  mixins.CreateModelMixin,\n                  generics.GenericAPIView):\n    queryset = Snippet.objects.all()\n    serializer_class = SnippetSerializer\n\n    def get(self, request, *args, **kwargs):\n        return self.list(request, *args, **kwargs)\n\n    def post(self, request, *args, **kwargs):\n        return self.create(request, *args, **kwargs)\n```\n\nWe'll take a moment to examine exactly what's happening here. We're building our view using `GenericAPIView`, and adding in `ListModelMixin` and `CreateModelMixin`.\n\nThe base class provides the core functionality, and the mixin classes provide the `.list()` and `.create()` actions. We're then explicitly binding the `get` and `post` methods to the appropriate actions. Simple enough stuff so far.\n\n``` python\nclass SnippetDetail(mixins.RetrieveModelMixin,\n                    mixins.UpdateModelMixin,\n                    mixins.DestroyModelMixin,\n                    generics.GenericAPIView):\n    queryset = Snippet.objects.all()\n    serializer_class = SnippetSerializer\n\n    def get(self, request, *args, **kwargs):\n        return self.retrieve(request, *args, **kwargs)\n\n    def put(self, request, *args, **kwargs):\n        return self.update(request, *args, **kwargs)\n\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n```\n\nPretty similar. Again we're using the `GenericAPIView` class to provide the core functionality, and adding in mixins to provide the `.retrieve()`, `.update()` and `.destroy()` actions.\n\n## Using generic class-based views\n\nUsing the mixin classes we've rewritten the views to use slightly less code than before, but we can go one step further. REST framework provides a set of already mixed-in generic views that we can use to trim down our `views.py` module even more.\n\n``` python\nfrom snippets.models import Snippet\nfrom snippets.serializers import SnippetSerializer\nfrom rest_framework import generics\n\n\nclass SnippetList(generics.ListCreateAPIView):\n    queryset = Snippet.objects.all()\n    serializer_class = SnippetSerializer\n\n\nclass SnippetDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Snippet.objects.all()\n    serializer_class = SnippetSerializer\n```\n\nWow, that's pretty concise. We've gotten a huge amount for free, and our code looks like good, clean, idiomatic Django.\n\nNext we'll move onto [part 4 of the tutorial](../4-authentication-and-permissions/index), where we'll take a look at how we can deal with authentication and permissions for our API.\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/tutorial/3-class-based-views/](https://www.django-rest-framework.org/tutorial/3-class-based-views/)"
- name: '4: Authentication & Permissions'
  id: tutorial/4-authentication-and-permissions/index
  summary: Currently our API doesn't have any restrictions on who can edit or delete code snippets
  description: "# Tutorial 4: Authentication & Permissions\n\nCurrently our API doesn't have any restrictions on who can edit or delete code snippets. We'd like to have some more advanced behavior in order to make sure that:\n\n- Code snippets are always associated with a creator.\n- Only authenticated users may create snippets.\n- Only the creator of a snippet may update or delete it.\n- Unauthenticated requests should have full read-only access.\n\n## Adding information to our model\n\nWe're going to make a couple of changes to our `Snippet` model class. First, let's add a couple of fields. One of those fields will be used to represent the user who created the code snippet. The other field will be used to store the highlighted HTML representation of the code.\n\nAdd the following two fields to the `Snippet` model in `models.py`.\n\n``` python\nowner = models.ForeignKey('auth.User', related_name='snippets', on_delete=models.CASCADE)\nhighlighted = models.TextField()\n```\n\nWe'd also need to make sure that when the model is saved, that we populate the highlighted field, using the `pygments` code highlighting library.\n\nWe'll need some extra imports:\n\n``` python\nfrom pygments.lexers import get_lexer_by_name\nfrom pygments.formatters.html import HtmlFormatter\nfrom pygments import highlight\n```\n\nAnd now we can add a `.save()` method to our model class:\n\n``` python\ndef save(self, *args, **kwargs):\n    \"\"\"\n    Use the `pygments` library to create a highlighted HTML\n    representation of the code snippet.\n    \"\"\"\n    lexer = get_lexer_by_name(self.language)\n    linenos = 'table' if self.linenos else False\n    options = {'title': self.title} if self.title else {}\n    formatter = HtmlFormatter(style=self.style, linenos=linenos,\n                              full=True, **options)\n    self.highlighted = highlight(self.code, lexer, formatter)\n    super().save(*args, **kwargs)\n```\n\nWhen that's all done we'll need to update our database tables. Normally we'd create a database migration in order to do that, but for the purposes of this tutorial, let's just delete the database and start again.\n\n``` python\nrm -f db.sqlite3\nrm -r snippets/migrations\npython manage.py makemigrations snippets\npython manage.py migrate\n```\n\nYou might also want to create a few different users, to use for testing the API. The quickest way to do this will be with the `createsuperuser` command.\n\n``` python\npython manage.py createsuperuser\n```\n\n## Adding endpoints for our User models\n\nNow that we've got some users to work with, we'd better add representations of those users to our API. Creating a new serializer is easy. In `serializers.py` add:\n\n``` python\nfrom django.contrib.auth.models import User\n\nclass UserSerializer(serializers.ModelSerializer):\n    snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all())\n\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'snippets']\n```\n\nBecause `'snippets'` is a *reverse* relationship on the User model, it will not be included by default when using the `ModelSerializer` class, so we needed to add an explicit field for it.\n\nWe'll also add a couple of views to `views.py`. We'd like to just use read-only views for the user representations, so we'll use the `ListAPIView` and `RetrieveAPIView` generic class-based views.\n\n``` python\nfrom django.contrib.auth.models import User\n\n\nclass UserList(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\n\nclass UserDetail(generics.RetrieveAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n```\n\nMake sure to also import the `UserSerializer` class\n\n``` python\nfrom snippets.serializers import UserSerializer\n```\n\nFinally we need to add those views into the API, by referencing them from the URL conf. Add the following to the patterns in `snippets/urls.py`.\n\n``` python\npath('users/', views.UserList.as_view()),\npath('users/<int:pk>/', views.UserDetail.as_view()),\n```\n\n## Associating Snippets with Users\n\nRight now, if we created a code snippet, there'd be no way of associating the user that created the snippet, with the snippet instance. The user isn't sent as part of the serialized representation, but is instead a property of the incoming request.\n\nThe way we deal with that is by overriding a `.perform_create()` method on our snippet views, that allows us to modify how the instance save is managed, and handle any information that is implicit in the incoming request or requested URL.\n\nOn the `SnippetList` view class, add the following method:\n\n``` python\ndef perform_create(self, serializer):\n    serializer.save(owner=self.request.user)\n```\n\nThe `create()` method of our serializer will now be passed an additional `'owner'` field, along with the validated data from the request.\n\n## Updating our serializer\n\nNow that snippets are associated with the user that created them, let's update our `SnippetSerializer` to reflect that. Add the following field to the serializer definition in `serializers.py`:\n\n``` python\nowner = serializers.ReadOnlyField(source='owner.username')\n```\n\n**Note**: Make sure you also add `'owner',` to the list of fields in the inner `Meta` class.\n\nThis field is doing something quite interesting. The `source` argument controls which attribute is used to populate a field, and can point at any attribute on the serialized instance. It can also take the dotted notation shown above, in which case it will traverse the given attributes, in a similar way as it is used with Django's template language.\n\nThe field we've added is the untyped `ReadOnlyField` class, in contrast to the other typed fields, such as `CharField`, `BooleanField` etc... The untyped `ReadOnlyField` is always read-only, and will be used for serialized representations, but will not be used for updating model instances when they are deserialized. We could have also used `CharField(read_only=True)` here.\n\n## Adding required permissions to views\n\nNow that code snippets are associated with users, we want to make sure that only authenticated users are able to create, update and delete code snippets.\n\nREST framework includes a number of permission classes that we can use to restrict who can access a given view. In this case the one we're looking for is `IsAuthenticatedOrReadOnly`, which will ensure that authenticated requests get read-write access, and unauthenticated requests get read-only access.\n\nFirst add the following import in the views module\n\n``` python\nfrom rest_framework import permissions\n```\n\nThen, add the following property to **both** the `SnippetList` and `SnippetDetail` view classes.\n\n``` python\npermission_classes = [permissions.IsAuthenticatedOrReadOnly]\n```\n\n## Adding login to the Browsable API\n\nIf you open a browser and navigate to the browsable API at the moment, you'll find that you're no longer able to create new code snippets. In order to do so we'd need to be able to login as a user.\n\nWe can add a login view for use with the browsable API, by editing the URLconf in our project-level `urls.py` file.\n\nAdd the following import at the top of the file:\n\n``` python\nfrom django.urls import path, include\n```\n\nAnd, at the end of the file, add a pattern to include the login and logout views for the browsable API.\n\n``` python\nurlpatterns += [\n    path('api-auth/', include('rest_framework.urls')),\n]\n```\n\nThe `'api-auth/'` part of pattern can actually be whatever URL you want to use.\n\nNow if you open up the browser again and refresh the page you'll see a 'Login' link in the top right of the page. If you log in as one of the users you created earlier, you'll be able to create code snippets again.\n\nOnce you've created a few code snippets, navigate to the '/users/' endpoint, and notice that the representation includes a list of the snippet ids that are associated with each user, in each user's 'snippets' field.\n\n## Object level permissions\n\nReally we'd like all code snippets to be visible to anyone, but also make sure that only the user that created a code snippet is able to update or delete it.\n\nTo do that we're going to need to create a custom permission.\n\nIn the snippets app, create a new file, `permissions.py`\n\n``` python\nfrom rest_framework import permissions\n\n\nclass IsOwnerOrReadOnly(permissions.BasePermission):\n    \"\"\"\n    Custom permission to only allow owners of an object to edit it.\n    \"\"\"\n\n    def has_object_permission(self, request, view, obj):\n        # Read permissions are allowed to any request,\n        # so we'll always allow GET, HEAD or OPTIONS requests.\n        if request.method in permissions.SAFE_METHODS:\n            return True\n\n        # Write permissions are only allowed to the owner of the snippet.\n        return obj.owner == request.user\n```\n\nNow we can add that custom permission to our snippet instance endpoint, by editing the `permission_classes` property on the `SnippetDetail` view class:\n\n``` python\npermission_classes = [permissions.IsAuthenticatedOrReadOnly,\n                      IsOwnerOrReadOnly]\n```\n\nMake sure to also import the `IsOwnerOrReadOnly` class.\n\n``` python\nfrom snippets.permissions import IsOwnerOrReadOnly\n```\n\nNow, if you open a browser again, you find that the 'DELETE' and 'PUT' actions only appear on a snippet instance endpoint if you're logged in as the same user that created the code snippet.\n\n## Authenticating with the API\n\nBecause we now have a set of permissions on the API, we need to authenticate our requests to it if we want to edit any snippets. We haven't set up any [authentication classes](../../api-guide/authentication/index), so the defaults are currently applied, which are `SessionAuthentication` and `BasicAuthentication`.\n\nWhen we interact with the API through the web browser, we can login, and the browser session will then provide the required authentication for the requests.\n\nIf we're interacting with the API programmatically we need to explicitly provide the authentication credentials on each request.\n\nIf we try to create a snippet without authenticating, we'll get an error:\n\n``` python\nhttp POST http://127.0.0.1:8000/snippets/ code=\"print(123)\"\n\n{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n```\n\nWe can make a successful request by including the username and password of one of the users we created earlier.\n\n``` python\nhttp -a admin:password123 POST http://127.0.0.1:8000/snippets/ code=\"print(789)\"\n\n{\n    \"id\": 1,\n    \"owner\": \"admin\",\n    \"title\": \"foo\",\n    \"code\": \"print(789)\",\n    \"linenos\": false,\n    \"language\": \"python\",\n    \"style\": \"friendly\"\n}\n```\n\n## Summary\n\nWe've now got a fairly fine-grained set of permissions on our Web API, and end points for users of the system and for the code snippets that they have created.\n\nIn [part 5](../5-relationships-and-hyperlinked-apis/index) of the tutorial we'll look at how we can tie everything together by creating an HTML endpoint for our highlighted snippets, and improve the cohesion of our API by using hyperlinking for the relationships within the system.\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/tutorial/4-authentication-and-permissions/](https://www.django-rest-framework.org/tutorial/4-authentication-and-permissions/)"
- name: '5: Relationships & Hyperlinked APIs'
  id: tutorial/5-relationships-and-hyperlinked-apis/index
  summary: At the moment relationships within our API are represented by using primary keys
  description: "# Tutorial 5: Relationships & Hyperlinked APIs\n\nAt the moment relationships within our API are represented by using primary keys. In this part of the tutorial we'll improve the cohesion and discoverability of our API, by instead using hyperlinking for relationships.\n\n## Creating an endpoint for the root of our API\n\nRight now we have endpoints for 'snippets' and 'users', but we don't have a single entry point to our API. To create one, we'll use a regular function-based view and the `@api_view` decorator we introduced earlier. In your `snippets/views.py` add:\n\n``` python\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\nfrom rest_framework.reverse import reverse\n\n\n@api_view(['GET'])\ndef api_root(request, format=None):\n    return Response({\n        'users': reverse('user-list', request=request, format=format),\n        'snippets': reverse('snippet-list', request=request, format=format)\n    })\n```\n\nTwo things should be noticed here. First, we're using REST framework's `reverse` function in order to return fully-qualified URLs; second, URL patterns are identified by convenience names that we will declare later on in our `snippets/urls.py`.\n\n## Creating an endpoint for the highlighted snippets\n\nThe other obvious thing that's still missing from our pastebin API is the code highlighting endpoints.\n\nUnlike all our other API endpoints, we don't want to use JSON, but instead just present an HTML representation. There are two styles of HTML renderer provided by REST framework, one for dealing with HTML rendered using templates, the other for dealing with pre-rendered HTML. The second renderer is the one we'd like to use for this endpoint.\n\nThe other thing we need to consider when creating the code highlight view is that there's no existing concrete generic view that we can use. We're not returning an object instance, but instead a property of an object instance.\n\nInstead of using a concrete generic view, we'll use the base class for representing instances, and create our own `.get()` method. In your `snippets/views.py` add:\n\n``` python\nfrom rest_framework import renderers\n\nclass SnippetHighlight(generics.GenericAPIView):\n    queryset = Snippet.objects.all()\n    renderer_classes = [renderers.StaticHTMLRenderer]\n\n    def get(self, request, *args, **kwargs):\n        snippet = self.get_object()\n        return Response(snippet.highlighted)\n```\n\nAs usual we need to add the new views that we've created in to our URLconf. We'll add a url pattern for our new API root in `snippets/urls.py`:\n\n``` python\npath('', views.api_root),\n```\n\nAnd then add a url pattern for the snippet highlights:\n\n``` python\npath('snippets/<int:pk>/highlight/', views.SnippetHighlight.as_view()),\n```\n\n## Hyperlinking our API\n\nDealing with relationships between entities is one of the more challenging aspects of Web API design. There are a number of different ways that we might choose to represent a relationship:\n\n- Using primary keys.\n- Using hyperlinking between entities.\n- Using a unique identifying slug field on the related entity.\n- Using the default string representation of the related entity.\n- Nesting the related entity inside the parent representation.\n- Some other custom representation.\n\nREST framework supports all of these styles, and can apply them across forward or reverse relationships, or apply them across custom managers such as generic foreign keys.\n\nIn this case we'd like to use a hyperlinked style between entities. In order to do so, we'll modify our serializers to extend `HyperlinkedModelSerializer` instead of the existing `ModelSerializer`.\n\nThe `HyperlinkedModelSerializer` has the following differences from `ModelSerializer`:\n\n- It does not include the `id` field by default.\n- It includes a `url` field, using `HyperlinkedIdentityField`.\n- Relationships use `HyperlinkedRelatedField`, instead of `PrimaryKeyRelatedField`.\n\nWe can easily re-write our existing serializers to use hyperlinking. In your `snippets/serializers.py` add:\n\n``` python\nclass SnippetSerializer(serializers.HyperlinkedModelSerializer):\n    owner = serializers.ReadOnlyField(source='owner.username')\n    highlight = serializers.HyperlinkedIdentityField(view_name='snippet-highlight', format='html')\n\n    class Meta:\n        model = Snippet\n        fields = ['url', 'id', 'highlight', 'owner',\n                  'title', 'code', 'linenos', 'language', 'style']\n\n\nclass UserSerializer(serializers.HyperlinkedModelSerializer):\n    snippets = serializers.HyperlinkedRelatedField(many=True, view_name='snippet-detail', read_only=True)\n\n    class Meta:\n        model = User\n        fields = ['url', 'id', 'username', 'snippets']\n```\n\nNotice that we've also added a new `'highlight'` field. This field is of the same type as the `url` field, except that it points to the `'snippet-highlight'` url pattern, instead of the `'snippet-detail'` url pattern.\n\nBecause we've included format suffixed URLs such as `'.json'`, we also need to indicate on the `highlight` field that any format suffixed hyperlinks it returns should use the `'.html'` suffix.\n\n## Making sure our URL patterns are named\n\nIf we're going to have a hyperlinked API, we need to make sure we name our URL patterns. Let's take a look at which URL patterns we need to name.\n\n- The root of our API refers to `'user-list'` and `'snippet-list'`.\n- Our snippet serializer includes a field that refers to `'snippet-highlight'`.\n- Our user serializer includes a field that refers to `'snippet-detail'`.\n- Our snippet and user serializers include `'url'` fields that by default will refer to `'{model_name}-detail'`, which in this case will be `'snippet-detail'` and `'user-detail'`.\n\nAfter adding all those names into our URLconf, our final `snippets/urls.py` file should look like this:\n\n``` python\nfrom django.urls import path\nfrom rest_framework.urlpatterns import format_suffix_patterns\nfrom snippets import views\n\n# API endpoints\nurlpatterns = format_suffix_patterns([\n    path('', views.api_root),\n    path('snippets/',\n        views.SnippetList.as_view(),\n        name='snippet-list'),\n    path('snippets/<int:pk>/',\n        views.SnippetDetail.as_view(),\n        name='snippet-detail'),\n    path('snippets/<int:pk>/highlight/',\n        views.SnippetHighlight.as_view(),\n        name='snippet-highlight'),\n    path('users/',\n        views.UserList.as_view(),\n        name='user-list'),\n    path('users/<int:pk>/',\n        views.UserDetail.as_view(),\n        name='user-detail')\n])\n```\n\n## Adding pagination\n\nThe list views for users and code snippets could end up returning quite a lot of instances, so really we'd like to make sure we paginate the results, and allow the API client to step through each of the individual pages.\n\nWe can change the default list style to use pagination, by modifying our `tutorial/settings.py` file slightly. Add the following setting:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',\n    'PAGE_SIZE': 10\n}\n```\n\nNote that settings in REST framework are all namespaced into a single dictionary setting, named `REST_FRAMEWORK`, which helps keep them well separated from your other project settings.\n\nWe could also customize the pagination style if we needed to, but in this case we'll just stick with the default.\n\n## Browsing the API\n\nIf we open a browser and navigate to the browsable API, you'll find that you can now work your way around the API simply by following links.\n\nYou'll also be able to see the 'highlight' links on the snippet instances, that will take you to the highlighted code HTML representations.\n\nIn [part 6](../6-viewsets-and-routers/index) of the tutorial we'll look at how we can use ViewSets and Routers to reduce the amount of code we need to build our API.\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/tutorial/5-relationships-and-hyperlinked-apis/](https://www.django-rest-framework.org/tutorial/5-relationships-and-hyperlinked-apis/)"
- name: '6: ViewSets & Routers'
  id: tutorial/6-viewsets-and-routers/index
  summary: REST framework includes an abstraction for dealing with ViewSets, that allows the developer to concentrate on modeling the state and interactions of the API, and leave the URL construction to be handled automatically, based on common conventions
  description: "# Tutorial 6: ViewSets & Routers\n\nREST framework includes an abstraction for dealing with `ViewSets`, that allows the developer to concentrate on modeling the state and interactions of the API, and leave the URL construction to be handled automatically, based on common conventions.\n\n`ViewSet` classes are almost the same thing as `View` classes, except that they provide operations such as `retrieve`, or `update`, and not method handlers such as `get` or `put`.\n\nA `ViewSet` class is only bound to a set of method handlers at the last moment, when it is instantiated into a set of views, typically by using a `Router` class which handles the complexities of defining the URL conf for you.\n\n## Refactoring to use ViewSets\n\nLet's take our current set of views, and refactor them into view sets.\n\nFirst of all let's refactor our `UserList` and `UserDetail` classes into a single `UserViewSet` class. In the `snippets/views.py` file, we can remove the two view classes and replace them with a single ViewSet class:\n\n``` python\nfrom rest_framework import viewsets\n\n\nclass UserViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    This viewset automatically provides `list` and `retrieve` actions.\n    \"\"\"\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n```\n\nHere we've used the `ReadOnlyModelViewSet` class to automatically provide the default 'read-only' operations. We're still setting the `queryset` and `serializer_class` attributes exactly as we did when we were using regular views, but we no longer need to provide the same information to two separate classes.\n\nNext we're going to replace the `SnippetList`, `SnippetDetail` and `SnippetHighlight` view classes. We can remove the three views, and again replace them with a single class.\n\n``` python\nfrom rest_framework import permissions\nfrom rest_framework import renderers\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\n\n\nclass SnippetViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    This ViewSet automatically provides `list`, `create`, `retrieve`,\n    `update` and `destroy` actions.\n\n    Additionally we also provide an extra `highlight` action.\n    \"\"\"\n    queryset = Snippet.objects.all()\n    serializer_class = SnippetSerializer\n    permission_classes = [permissions.IsAuthenticatedOrReadOnly,\n                          IsOwnerOrReadOnly]\n\n    @action(detail=True, renderer_classes=[renderers.StaticHTMLRenderer])\n    def highlight(self, request, *args, **kwargs):\n        snippet = self.get_object()\n        return Response(snippet.highlighted)\n\n    def perform_create(self, serializer):\n        serializer.save(owner=self.request.user)\n```\n\nThis time we've used the `ModelViewSet` class in order to get the complete set of default read and write operations.\n\nNotice that we've also used the `@action` decorator to create a custom action, named `highlight`. This decorator can be used to add any custom endpoints that don't fit into the standard `create`/`update`/`delete` style.\n\nCustom actions which use the `@action` decorator will respond to `GET` requests by default. We can use the `methods` argument if we wanted an action that responded to `POST` requests.\n\nThe URLs for custom actions by default depend on the method name itself. If you want to change the way url should be constructed, you can include `url_path` as a decorator keyword argument.\n\n## Binding ViewSets to URLs explicitly\n\nThe handler methods only get bound to the actions when we define the URLConf. To see what's going on under the hood let's first explicitly create a set of views from our ViewSets.\n\nIn the `snippets/urls.py` file we bind our `ViewSet` classes into a set of concrete views.\n\n``` python\nfrom rest_framework import renderers\n\nfrom snippets.views import api_root, SnippetViewSet, UserViewSet\n\nsnippet_list = SnippetViewSet.as_view({\n    'get': 'list',\n    'post': 'create'\n})\nsnippet_detail = SnippetViewSet.as_view({\n    'get': 'retrieve',\n    'put': 'update',\n    'patch': 'partial_update',\n    'delete': 'destroy'\n})\nsnippet_highlight = SnippetViewSet.as_view({\n    'get': 'highlight'\n}, renderer_classes=[renderers.StaticHTMLRenderer])\nuser_list = UserViewSet.as_view({\n    'get': 'list'\n})\nuser_detail = UserViewSet.as_view({\n    'get': 'retrieve'\n})\n```\n\nNotice how we're creating multiple views from each `ViewSet` class, by binding the HTTP methods to the required action for each view.\n\nNow that we've bound our resources into concrete views, we can register the views with the URL conf as usual.\n\n``` python\nurlpatterns = format_suffix_patterns([\n    path('', api_root),\n    path('snippets/', snippet_list, name='snippet-list'),\n    path('snippets/<int:pk>/', snippet_detail, name='snippet-detail'),\n    path('snippets/<int:pk>/highlight/', snippet_highlight, name='snippet-highlight'),\n    path('users/', user_list, name='user-list'),\n    path('users/<int:pk>/', user_detail, name='user-detail')\n])\n```\n\n## Using Routers\n\nBecause we're using `ViewSet` classes rather than `View` classes, we actually don't need to design the URL conf ourselves. The conventions for wiring up resources into views and urls can be handled automatically, using a `Router` class. All we need to do is register the appropriate view sets with a router, and let it do the rest.\n\nHere's our re-wired `snippets/urls.py` file.\n\n``` python\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\n\nfrom snippets import views\n\n# Create a router and register our ViewSets with it.\nrouter = DefaultRouter()\nrouter.register(r'snippets', views.SnippetViewSet, basename='snippet')\nrouter.register(r'users', views.UserViewSet, basename='user')\n\n# The API URLs are now determined automatically by the router.\nurlpatterns = [\n    path('', include(router.urls)),\n]\n```\n\nRegistering the ViewSets with the router is similar to providing a urlpattern. We include two arguments - the URL prefix for the views, and the view set itself.\n\nThe `DefaultRouter` class we're using also automatically creates the API root view for us, so we can now delete the `api_root` function from our `views` module.\n\n## Trade-offs between views vs ViewSets\n\nUsing ViewSets can be a really useful abstraction. It helps ensure that URL conventions will be consistent across your API, minimizes the amount of code you need to write, and allows you to concentrate on the interactions and representations your API provides rather than the specifics of the URL conf.\n\nThat doesn't mean it's always the right approach to take. There's a similar set of trade-offs to consider as when using class-based views instead of function-based views. Using ViewSets is less explicit than building your API views individually.\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/tutorial/6-viewsets-and-routers/](https://www.django-rest-framework.org/tutorial/6-viewsets-and-routers/)"
- name: AcceptHeaderVersioning
  id: api-guide/versioning/index#acceptheaderversioning
  summary: This scheme requires the client to specify the version as part of the media type in the Accept header
  belongs_to: Versioning
  description: |-
    ## AcceptHeaderVersioning

    This scheme requires the client to specify the version as part of the media type in the `Accept` header. The version is included as a media type parameter, that supplements the main media type.

    Here's an example HTTP request using the accept header versioning style.

    ``` python
    GET /bookings/ HTTP/1.1
    Host: example.com
    Accept: application/json; version=1.0
    ```

    In the example request above `request.version` attribute would return the string `'1.0'`.

    Versioning based on accept headers is [generally considered](http://blog.steveklabnik.com/posts/2011-07-03-nobody-understands-rest-or-http#i_want_my_api_to_be_versioned) as [best practice](https://github.com/interagent/http-api-design/blob/master/en/foundations/require-versioning-in-the-accepts-header.md), although other styles may be suitable depending on your client requirements.

    #### Using accept headers with vendor media types

    Strictly speaking the `json` media type is not specified as [including additional parameters](https://tools.ietf.org/html/rfc4627#section-6). If you are building a well-specified public API you might consider using a [vendor media type](https://en.wikipedia.org/wiki/Internet_media_type#Vendor_tree). To do so, configure your renderers to use a JSON based renderer with a custom media type:

    ``` python
    class BookingsAPIRenderer(JSONRenderer):
        media_type = 'application/vnd.megacorp.bookings+json'
    ```

    Your client requests would now look like this:

    ``` python
    GET /bookings/ HTTP/1.1
    Host: example.com
    Accept: application/vnd.megacorp.bookings+json; version=1.0
    ```
- name: AdminRenderer
  id: api-guide/renderers/index#adminrenderer
  summary: This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data
  belongs_to: Renderers
  description: |-
    ## AdminRenderer

    Renders data into HTML for an admin-like display:

    This renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.

    Note that views that have nested or list serializers for their input won't work well with the `AdminRenderer`, as the HTML forms are unable to properly support them.

    **Note**: The `AdminRenderer` is only able to include links to detail pages when a properly configured `URL_FIELD_NAME` (`url` by default) attribute is present in the data. For `HyperlinkedModelSerializer` this will be the case, but for `ModelSerializer` or plain `Serializer` classes you'll need to make sure to include the field explicitly. For example here we use models `get_absolute_url` method:

    ``` python
    class AccountSerializer(serializers.ModelSerializer):
        url = serializers.CharField(source='get_absolute_url', read_only=True)

        class Meta:
            model = Account
    ```

    **.media_type**: `text/html`

    **.format**: `'admin'`

    **.charset**: `utf-8`

    **.template**: `'rest_framework/admin.html'`
- name: AllowAny
  id: api-guide/permissions/index#allowany
  summary: The AllowAny permission class will allow unrestricted access, regardless of if the request was authenticated or unauthenticated
  belongs_to: Permissions
  description: |-
    ## AllowAny

    The `AllowAny` permission class will allow unrestricted access, **regardless of if the request was authenticated or unauthenticated**.

    This permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.
- name: AnonRateThrottle
  id: api-guide/throttling/index#anonratethrottle
  summary: The AnonRateThrottle will only ever throttle unauthenticated users
  belongs_to: Throttling
  description: |-
    ## AnonRateThrottle

    The `AnonRateThrottle` will only ever throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.

    The allowed request rate is determined from one of the following (in order of preference).

    - The `rate` property on the class, which may be provided by overriding `AnonRateThrottle` and setting the property.
    - The `DEFAULT_THROTTLE_RATES['anon']` setting.

    `AnonRateThrottle` is suitable if you want to restrict the rate of requests from unknown sources.
- name: API policy settings
  id: api-guide/settings/index#api-policy-settings
  summary: The following settings control the basic API policies, and are applied to every APIView class-based view, or @api_view function based view
  belongs_to: Settings
  description: |-
    ## API policy settings

    *The following settings control the basic API policies, and are applied to every `APIView` class-based view, or `@api_view` function based view.*

    #### DEFAULT_RENDERER_CLASSES

    A list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a `Response` object.

    Default:

    ``` python
    [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ]
    ```

    #### DEFAULT_PARSER_CLASSES

    A list or tuple of parser classes, that determines the default set of parsers used when accessing the `request.data` property.

    Default:

    ``` python
    [
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.FormParser',
        'rest_framework.parsers.MultiPartParser'
    ]
    ```

    #### DEFAULT_AUTHENTICATION_CLASSES

    A list or tuple of authentication classes, that determines the default set of authenticators used when accessing the `request.user` or `request.auth` properties.

    Default:

    ``` python
    [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication'
    ]
    ```

    #### DEFAULT_PERMISSION_CLASSES

    A list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.

    Default:

    ``` python
    [
        'rest_framework.permissions.AllowAny',
    ]
    ```

    #### DEFAULT_THROTTLE_CLASSES

    A list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.

    Default: `[]`

    #### DEFAULT_CONTENT_NEGOTIATION_CLASS

    A content negotiation class, that determines how a renderer is selected for the response, given an incoming request.

    Default: `'rest_framework.negotiation.DefaultContentNegotiation'`

    #### DEFAULT_SCHEMA_CLASS

    A view inspector class that will be used for schema generation.

    Default: `'rest_framework.schemas.openapi.AutoSchema'`
- name: APIException
  id: api-guide/exceptions/index#apiexception
  summary: The base class for all exceptions raised inside an APIView class or @api_view
  belongs_to: Exceptions
  description: |-
    ## APIException

    **Signature:** `APIException()`

    The **base class** for all exceptions raised inside an `APIView` class or `@api_view`.

    To provide a custom exception, subclass `APIException` and set the `.status_code`, `.default_detail`, and `.default_code` attributes on the class.

    For example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the "503 Service Unavailable" HTTP response code. You could do this like so:

    ``` python
    from rest_framework.exceptions import APIException

    class ServiceUnavailable(APIException):
        status_code = 503
        default_detail = 'Service temporarily unavailable, try again later.'
        default_code = 'service_unavailable'
    ```

    #### Inspecting API exceptions

    There are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.

    The available attributes and methods are:

    - `.detail` - Return the textual description of the error.
    - `.get_codes()` - Return the code identifier of the error.
    - `.get_full_details()` - Return both the textual description and the code identifier.

    In most cases the error detail will be a simple item:

    ``` python
    >>> print(exc.detail)
    You do not have permission to perform this action.
    >>> print(exc.get_codes())
    permission_denied
    >>> print(exc.get_full_details())
    {'message':'You do not have permission to perform this action.','code':'permission_denied'}
    ```

    In the case of validation errors the error detail will be either a list or dictionary of items:

    ``` python
    >>> print(exc.detail)
    {"name":"This field is required.","age":"A valid integer is required."}
    >>> print(exc.get_codes())
    {"name":"required","age":"invalid"}
    >>> print(exc.get_full_details())
    {"name":{"message":"This field is required.","code":"required"},"age":{"message":"A valid integer is required.","code":"invalid"}}
    ```
- name: Authentication
  id: api-guide/authentication/index
  summary: Auth needs to be pluggable
  description: "# Authentication\n\n> Auth needs to be pluggable.\n>\n> — Jacob Kaplan-Moss, [\"REST worst practices\"](https://jacobian.org/writing/rest-worst-practices/)\n\nAuthentication is the mechanism of associating an incoming request with a set of identifying credentials, such as the user the request came from, or the token that it was signed with. The [permission](../permissions/index) and [throttling](../throttling/index) policies can then use those credentials to determine if the request should be permitted.\n\nREST framework provides several authentication schemes out of the box, and also allows you to implement custom schemes.\n\nAuthentication always runs at the very start of the view, before the permission and throttling checks occur, and before any other code is allowed to proceed.\n\nThe `request.user` property will typically be set to an instance of the `contrib.auth` package's `User` class.\n\nThe `request.auth` property is used for any additional authentication information, for example, it may be used to represent an authentication token that the request was signed with.\n\n**Note:** Don't forget that **authentication by itself won't allow or disallow an incoming request**, it simply identifies the credentials that the request was made with.\n\nFor information on how to set up the permission policies for your API please see the [permissions documentation](../permissions/index).\n\n## How authentication is determined\n\nThe authentication schemes are always defined as a list of classes. REST framework will attempt to authenticate with each class in the list, and will set `request.user` and `request.auth` using the return value of the first class that successfully authenticates.\n\nIf no class authenticates, `request.user` will be set to an instance of `django.contrib.auth.models.AnonymousUser`, and `request.auth` will be set to `None`.\n\nThe value of `request.user` and `request.auth` for unauthenticated requests can be modified using the `UNAUTHENTICATED_USER` and `UNAUTHENTICATED_TOKEN` settings.\n\n## Setting the authentication scheme\n\nThe default authentication schemes may be set globally, using the `DEFAULT_AUTHENTICATION_CLASSES` setting. For example.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': [\n        'rest_framework.authentication.BasicAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n    ]\n}\n```\n\nYou can also set the authentication scheme on a per-view or per-viewset basis, using the `APIView` class-based views.\n\n``` python\nfrom rest_framework.authentication import SessionAuthentication, BasicAuthentication\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass ExampleView(APIView):\n    authentication_classes = [SessionAuthentication, BasicAuthentication]\n    permission_classes = [IsAuthenticated]\n\n    def get(self, request, format=None):\n        content = {\n            'user': str(request.user),  # `django.contrib.auth.User` instance.\n            'auth': str(request.auth),  # None\n        }\n        return Response(content)\n```\n\nOr, if you're using the `@api_view` decorator with function based views.\n\n``` python\n@api_view(['GET'])\n@authentication_classes([SessionAuthentication, BasicAuthentication])\n@permission_classes([IsAuthenticated])\ndef example_view(request, format=None):\n    content = {\n        'user': str(request.user),  # `django.contrib.auth.User` instance.\n        'auth': str(request.auth),  # None\n    }\n    return Response(content)\n```\n\n## Unauthorized and Forbidden responses\n\nWhen an unauthenticated request is denied permission there are two different error codes that may be appropriate.\n\n- [HTTP 401 Unauthorized](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2)\n- [HTTP 403 Permission Denied](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.4)\n\nHTTP 401 responses must always include a `WWW-Authenticate` header, that instructs the client how to authenticate. HTTP 403 responses do not include the `WWW-Authenticate` header.\n\nThe kind of response that will be used depends on the authentication scheme. Although multiple authentication schemes may be in use, only one scheme may be used to determine the type of response. **The first authentication class set on the view is used when determining the type of response**.\n\nNote that when a request may successfully authenticate, but still be denied permission to perform the request, in which case a `403 Permission Denied` response will always be used, regardless of the authentication scheme.\n\n## Apache mod_wsgi specific configuration\n\nNote that if deploying to [Apache using mod_wsgi](https://modwsgi.readthedocs.io/en/develop/configuration-directives/WSGIPassAuthorization.html), the authorization header is not passed through to a WSGI application by default, as it is assumed that authentication will be handled by Apache, rather than at an application level.\n\nIf you are deploying to Apache, and using any non-session based authentication, you will need to explicitly configure mod_wsgi to pass the required headers through to the application. This can be done by specifying the `WSGIPassAuthorization` directive in the appropriate context and setting it to `'On'`.\n\n``` python\n# this can go in either server config, virtual host, directory or .htaccess\nWSGIPassAuthorization On\n```\n\n# API Reference\n\n## BasicAuthentication\n\nThis authentication scheme uses [HTTP Basic Authentication](https://tools.ietf.org/html/rfc2617), signed against a user's username and password. Basic authentication is generally only appropriate for testing.\n\nIf successfully authenticated, `BasicAuthentication` provides the following credentials.\n\n- `request.user` will be a Django `User` instance.\n- `request.auth` will be `None`.\n\nUnauthenticated responses that are denied permission will result in an `HTTP 401 Unauthorized` response with an appropriate WWW-Authenticate header. For example:\n\n``` python\nWWW-Authenticate: Basic realm=\"api\"\n```\n\n**Note:** If you use `BasicAuthentication` in production you must ensure that your API is only available over `https`. You should also ensure that your API clients will always re-request the username and password at login, and will never store those details to persistent storage.\n\n## TokenAuthentication\n\n**Note:** The token authentication provided by Django REST framework is a fairly simple implementation.\n\nFor an implementation which allows more than one token per user, has some tighter security implementation details, and supports token expiry, please see the [Django REST Knox](https://github.com/James1345/django-rest-knox) third party package.\n\nThis authentication scheme uses a simple token-based HTTP Authentication scheme. Token authentication is appropriate for client-server setups, such as native desktop and mobile clients.\n\nTo use the `TokenAuthentication` scheme you'll need to [configure the authentication classes](#setting-the-authentication-scheme) to include `TokenAuthentication`, and additionally include `rest_framework.authtoken` in your `INSTALLED_APPS` setting:\n\n``` python\nINSTALLED_APPS = [\n    ...\n    'rest_framework.authtoken'\n]\n```\n\nMake sure to run `manage.py migrate` after changing your settings.\n\nThe `rest_framework.authtoken` app provides Django database migrations.\n\nYou'll also need to create tokens for your users.\n\n``` python\nfrom rest_framework.authtoken.models import Token\n\ntoken = Token.objects.create(user=...)\nprint(token.key)\n```\n\nFor clients to authenticate, the token key should be included in the `Authorization` HTTP header. The key should be prefixed by the string literal \"Token\", with whitespace separating the two strings. For example:\n\n``` python\nAuthorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b\n```\n\n*If you want to use a different keyword in the header, such as `Bearer`, simply subclass `TokenAuthentication` and set the `keyword` class variable.*\n\nIf successfully authenticated, `TokenAuthentication` provides the following credentials.\n\n- `request.user` will be a Django `User` instance.\n- `request.auth` will be a `rest_framework.authtoken.models.Token` instance.\n\nUnauthenticated responses that are denied permission will result in an `HTTP 401 Unauthorized` response with an appropriate WWW-Authenticate header. For example:\n\n``` python\nWWW-Authenticate: Token\n```\n\nThe `curl` command line tool may be useful for testing token authenticated APIs. For example:\n\n``` python\ncurl -X GET http://127.0.0.1:8000/api/example/ -H 'Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b'\n```\n\n**Note:** If you use `TokenAuthentication` in production you must ensure that your API is only available over `https`.\n\n### Generating Tokens\n\n#### By using signals\n\nIf you want every user to have an automatically generated Token, you can simply catch the User's `post_save` signal.\n\n``` python\nfrom django.conf import settings\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom rest_framework.authtoken.models import Token\n\n@receiver(post_save, sender=settings.AUTH_USER_MODEL)\ndef create_auth_token(sender, instance=None, created=False, **kwargs):\n    if created:\n        Token.objects.create(user=instance)\n```\n\nNote that you'll want to ensure you place this code snippet in an installed `models.py` module, or some other location that will be imported by Django on startup.\n\nIf you've already created some users, you can generate tokens for all existing users like this:\n\n``` python\nfrom django.contrib.auth.models import User\nfrom rest_framework.authtoken.models import Token\n\nfor user in User.objects.all():\n    Token.objects.get_or_create(user=user)\n```\n\n#### By exposing an api endpoint\n\nWhen using `TokenAuthentication`, you may want to provide a mechanism for clients to obtain a token given the username and password. REST framework provides a built-in view to provide this behavior. To use it, add the `obtain_auth_token` view to your URLconf:\n\n``` python\nfrom rest_framework.authtoken import views\nurlpatterns += [\n    path('api-token-auth/', views.obtain_auth_token)\n]\n```\n\nNote that the URL part of the pattern can be whatever you want to use.\n\nThe `obtain_auth_token` view will return a JSON response when valid `username` and `password` fields are POSTed to the view using form data or JSON:\n\n``` python\n{ 'token' : '9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b' }\n```\n\nNote that the default `obtain_auth_token` view explicitly uses JSON requests and responses, rather than using default renderer and parser classes in your settings.\n\nBy default, there are no permissions or throttling applied to the `obtain_auth_token` view. If you do wish to apply throttling you'll need to override the view class, and include them using the `throttle_classes` attribute.\n\nIf you need a customized version of the `obtain_auth_token` view, you can do so by subclassing the `ObtainAuthToken` view class, and using that in your url conf instead.\n\nFor example, you may return additional user information beyond the `token` value:\n\n``` python\nfrom rest_framework.authtoken.views import ObtainAuthToken\nfrom rest_framework.authtoken.models import Token\nfrom rest_framework.response import Response\n\nclass CustomAuthToken(ObtainAuthToken):\n\n    def post(self, request, *args, **kwargs):\n        serializer = self.serializer_class(data=request.data,\n                                           context={'request': request})\n        serializer.is_valid(raise_exception=True)\n        user = serializer.validated_data['user']\n        token, created = Token.objects.get_or_create(user=user)\n        return Response({\n            'token': token.key,\n            'user_id': user.pk,\n            'email': user.email\n        })\n```\n\nAnd in your `urls.py`:\n\n``` python\nurlpatterns += [\n    path('api-token-auth/', CustomAuthToken.as_view())\n]\n```\n\n#### With Django admin\n\nIt is also possible to create Tokens manually through the admin interface. In case you are using a large user base, we recommend that you monkey patch the `TokenAdmin` class to customize it to your needs, more specifically by declaring the `user` field as `raw_field`.\n\n`your_app/admin.py`:\n\n``` python\nfrom rest_framework.authtoken.admin import TokenAdmin\n\nTokenAdmin.raw_id_fields = ['user']\n```\n\n#### Using Django manage.py command\n\nSince version 3.6.4 it's possible to generate a user token using the following command:\n\n``` python\n./manage.py drf_create_token <username>\n```\n\nthis command will return the API token for the given user, creating it if it doesn't exist:\n\n``` python\nGenerated token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b for user user1\n```\n\nIn case you want to regenerate the token (for example if it has been compromised or leaked) you can pass an additional parameter:\n\n``` python\n./manage.py drf_create_token -r <username>\n```\n\n## SessionAuthentication\n\nThis authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website.\n\nIf successfully authenticated, `SessionAuthentication` provides the following credentials.\n\n- `request.user` will be a Django `User` instance.\n- `request.auth` will be `None`.\n\nUnauthenticated responses that are denied permission will result in an `HTTP 403 Forbidden` response.\n\nIf you're using an AJAX-style API with SessionAuthentication, you'll need to make sure you include a valid CSRF token for any \"unsafe\" HTTP method calls, such as `PUT`, `PATCH`, `POST` or `DELETE` requests. See the [Django CSRF documentation](https://docs.djangoproject.com/en/stable/howto/csrf/#using-csrf-protection-with-ajax) for more details.\n\n**Warning**: Always use Django's standard login view when creating login pages. This will ensure your login views are properly protected.\n\nCSRF validation in REST framework works slightly differently from standard Django due to the need to support both session and non-session based authentication to the same views. This means that only authenticated requests require CSRF tokens, and anonymous requests may be sent without CSRF tokens. This behavior is not suitable for login views, which should always have CSRF validation applied.\n\n## RemoteUserAuthentication\n\nThis authentication scheme allows you to delegate authentication to your web server, which sets the `REMOTE_USER` environment variable.\n\nTo use it, you must have `django.contrib.auth.backends.RemoteUserBackend` (or a subclass) in your `AUTHENTICATION_BACKENDS` setting. By default, `RemoteUserBackend` creates `User` objects for usernames that don't already exist. To change this and other behavior, consult the [Django documentation](https://docs.djangoproject.com/en/stable/howto/auth-remote-user/).\n\nIf successfully authenticated, `RemoteUserAuthentication` provides the following credentials:\n\n- `request.user` will be a Django `User` instance.\n- `request.auth` will be `None`.\n\nConsult your web server's documentation for information about configuring an authentication method, for example:\n\n- [Apache Authentication How-To](https://httpd.apache.org/docs/2.4/howto/auth.html)\n- [NGINX (Restricting Access)](https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/)\n\n# Custom authentication\n\nTo implement a custom authentication scheme, subclass `BaseAuthentication` and override the `.authenticate(self, request)` method. The method should return a two-tuple of `(user, auth)` if authentication succeeds, or `None` otherwise.\n\nIn some circumstances instead of returning `None`, you may want to raise an `AuthenticationFailed` exception from the `.authenticate()` method.\n\nTypically the approach you should take is:\n\n- If authentication is not attempted, return `None`. Any other authentication schemes also in use will still be checked.\n- If authentication is attempted but fails, raise an `AuthenticationFailed` exception. An error response will be returned immediately, regardless of any permissions checks, and without checking any other authentication schemes.\n\nYou *may* also override the `.authenticate_header(self, request)` method. If implemented, it should return a string that will be used as the value of the `WWW-Authenticate` header in a `HTTP 401 Unauthorized` response.\n\nIf the `.authenticate_header()` method is not overridden, the authentication scheme will return `HTTP 403 Forbidden` responses when an unauthenticated request is denied access.\n\n**Note:** When your custom authenticator is invoked by the request object's `.user` or `.auth` properties, you may see an `AttributeError` re-raised as a `WrappedAttributeError`. This is necessary to prevent the original exception from being suppressed by the outer property access. Python will not recognize that the `AttributeError` originates from your custom authenticator and will instead assume that the request object does not have a `.user` or `.auth` property. These errors should be fixed or otherwise handled by your authenticator.\n\n## Example\n\nThe following example will authenticate any incoming request as the user given by the username in a custom request header named 'X-USERNAME'.\n\n``` python\nfrom django.contrib.auth.models import User\nfrom rest_framework import authentication\nfrom rest_framework import exceptions\n\nclass ExampleAuthentication(authentication.BaseAuthentication):\n    def authenticate(self, request):\n        username = request.META.get('HTTP_X_USERNAME')\n        if not username:\n            return None\n\n        try:\n            user = User.objects.get(username=username)\n        except User.DoesNotExist:\n            raise exceptions.AuthenticationFailed('No such user')\n\n        return (user, None)\n```\n\n# Third party packages\n\nThe following third-party packages are also available.\n\n## django-rest-knox\n\n[Django-rest-knox](https://github.com/James1345/django-rest-knox) library provides models and views to handle token-based authentication in a more secure and extensible way than the built-in TokenAuthentication scheme - with Single Page Applications and Mobile clients in mind. It provides per-client tokens, and views to generate them when provided some other authentication (usually basic authentication), to delete the token (providing a server enforced logout) and to delete all tokens (logs out all clients that a user is logged into).\n\n## Django OAuth Toolkit\n\nThe [Django OAuth Toolkit](https://github.com/evonove/django-oauth-toolkit) package provides OAuth 2.0 support and works with Python 3.4+. The package is maintained by [jazzband](https://github.com/jazzband/) and uses the excellent [OAuthLib](https://github.com/idan/oauthlib). The package is well documented, and well supported and is currently our **recommended package for OAuth 2.0 support**.\n\n### Installation & configuration\n\nInstall using `pip`.\n\n``` python\npip install django-oauth-toolkit\n```\n\nAdd the package to your `INSTALLED_APPS` and modify your REST framework settings.\n\n``` python\nINSTALLED_APPS = [\n    ...\n    'oauth2_provider',\n]\n\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': [\n        'oauth2_provider.contrib.rest_framework.OAuth2Authentication',\n    ]\n}\n```\n\nFor more details see the [Django REST framework - Getting started](https://django-oauth-toolkit.readthedocs.io/en/latest/rest-framework/getting_started.html) documentation.\n\n## Django REST framework OAuth\n\nThe [Django REST framework OAuth](https://jpadilla.github.io/django-rest-framework-oauth/) package provides both OAuth1 and OAuth2 support for REST framework.\n\nThis package was previously included directly in the REST framework but is now supported and maintained as a third-party package.\n\n### Installation & configuration\n\nInstall the package using `pip`.\n\n``` python\npip install djangorestframework-oauth\n```\n\nFor details on configuration and usage see the Django REST framework OAuth documentation for [authentication](https://jpadilla.github.io/django-rest-framework-oauth/authentication/) and [permissions](https://jpadilla.github.io/django-rest-framework-oauth/permissions/).\n\n## JSON Web Token Authentication\n\nJSON Web Token is a fairly new standard which can be used for token-based authentication. Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn't need to use a database to validate a token. A package for JWT authentication is [djangorestframework-simplejwt](https://github.com/davesque/django-rest-framework-simplejwt) which provides some features as well as a pluggable token blacklist app.\n\n## Hawk HTTP Authentication\n\nThe [HawkREST](https://hawkrest.readthedocs.io/en/latest/) library builds on the [Mohawk](https://mohawk.readthedocs.io/en/latest/) library to let you work with [Hawk](https://github.com/hueniverse/hawk) signed requests and responses in your API. [Hawk](https://github.com/hueniverse/hawk) lets two parties securely communicate with each other using messages signed by a shared key. It is based on [HTTP MAC access authentication](https://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05) (which was based on parts of [OAuth 1.0](https://oauth.net/core/1.0a/)).\n\n## HTTP Signature Authentication\n\nHTTP Signature (currently a [IETF draft](https://datatracker.ietf.org/doc/draft-cavage-http-signatures/)) provides a way to achieve origin authentication and message integrity for HTTP messages. Similar to [Amazon's HTTP Signature scheme](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html), used by many of its services, it permits stateless, per-request authentication. [Elvio Toccalino](https://github.com/etoccalino/) maintains the [djangorestframework-httpsignature](https://github.com/etoccalino/django-rest-framework-httpsignature) (outdated) package which provides an easy-to-use HTTP Signature Authentication mechanism. You can use the updated fork version of [djangorestframework-httpsignature](https://github.com/etoccalino/django-rest-framework-httpsignature), which is [drf-httpsig](https://github.com/ahknight/drf-httpsig).\n\n## Djoser\n\n[Djoser](https://github.com/sunscrapers/djoser) library provides a set of views to handle basic actions such as registration, login, logout, password reset and account activation. The package works with a custom user model and uses token-based authentication. This is a ready to use REST implementation of the Django authentication system.\n\n## django-rest-auth / dj-rest-auth\n\nThis library provides a set of REST API endpoints for registration, authentication (including social media authentication), password reset, retrieve and update user details, etc. By having these API endpoints, your client apps such as AngularJS, iOS, Android, and others can communicate to your Django backend site independently via REST APIs for user management.\n\nThere are currently two forks of this project.\n\n- [Django-rest-auth](https://github.com/Tivix/django-rest-auth) is the original project, [but is not currently receiving updates](https://github.com/Tivix/django-rest-auth/issues/568).\n- [Dj-rest-auth](https://github.com/jazzband/dj-rest-auth) is a newer fork of the project.\n\n## drf-social-oauth2\n\n[Drf-social-oauth2](https://github.com/wagnerdelima/drf-social-oauth2) is a framework that helps you authenticate with major social oauth2 vendors, such as Facebook, Google, Twitter, Orcid, etc. It generates tokens in a JWTed way with an easy setup.\n\n## drfpasswordless\n\n[drfpasswordless](https://github.com/aaronn/django-rest-framework-passwordless) adds (Medium, Square Cash inspired) passwordless support to Django REST Framework's TokenAuthentication scheme. Users log in and sign up with a token sent to a contact point like an email address or a mobile number.\n\n## django-rest-authemail\n\n[django-rest-authemail](https://github.com/celiao/django-rest-authemail) provides a RESTful API interface for user signup and authentication. Email addresses are used for authentication, rather than usernames. API endpoints are available for signup, signup email verification, login, logout, password reset, password reset verification, email change, email change verification, password change, and user detail. A fully functional example project and detailed instructions are included.\n\n## Django-Rest-Durin\n\n[Django-Rest-Durin](https://github.com/eshaan7/django-rest-durin) is built with the idea to have one library that does token auth for multiple Web/CLI/Mobile API clients via one interface but allows different token configuration for each API Client that consumes the API. It provides support for multiple tokens per user via custom models, views, permissions that work with Django-Rest-Framework. The token expiration time can be different per API client and is customizable via the Django Admin Interface.\n\nMore information can be found in the [Documentation](https://django-rest-durin.readthedocs.io/en/latest/index.html).\n\n[authentication.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/authentication.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/authentication/](https://www.django-rest-framework.org/api-guide/authentication/)"
- name: Authentication settings
  id: api-guide/settings/index#authentication-settings
  summary: The following settings control the behavior of unauthenticated requests
  belongs_to: Settings
  description: |-
    ## Authentication settings

    *The following settings control the behavior of unauthenticated requests.*

    #### UNAUTHENTICATED_USER

    The class that should be used to initialize `request.user` for unauthenticated requests. (If removing authentication entirely, e.g. by removing `django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to `None`.)

    Default: `django.contrib.auth.models.AnonymousUser`

    #### UNAUTHENTICATED_TOKEN

    The class that should be used to initialize `request.auth` for unauthenticated requests.

    Default: `None`
- name: AuthenticationFailed
  id: api-guide/exceptions/index#authenticationfailed
  summary: Raised when an incoming request includes incorrect authentication
  belongs_to: Exceptions
  description: |-
    ## AuthenticationFailed

    **Signature:** `AuthenticationFailed(detail=None, code=None)`

    Raised when an incoming request includes incorrect authentication.

    By default this exception results in a response with the HTTP status code "401 Unauthenticated", but it may also result in a "403 Forbidden" response, depending on the authentication scheme in use. See the [authentication documentation](../authentication/index) for more details.
- name: BaseSerializer
  id: api-guide/serializers/index#baseserializer
  summary: BaseSerializer class that can be used to easily support alternative serialization and deserialization styles
  belongs_to: Serializers
  description: "# BaseSerializer\n\n`BaseSerializer` class that can be used to easily support alternative serialization and deserialization styles.\n\nThis class implements the same basic API as the `Serializer` class:\n\n- `.data` - Returns the outgoing primitive representation.\n- `.is_valid()` - Deserializes and validates incoming data.\n- `.validated_data` - Returns the validated incoming data.\n- `.errors` - Returns any errors during validation.\n- `.save()` - Persists the validated data into an object instance.\n\nThere are four methods that can be overridden, depending on what functionality you want the serializer class to support:\n\n- `.to_representation()` - Override this to support serialization, for read operations.\n- `.to_internal_value()` - Override this to support deserialization, for write operations.\n- `.create()` and `.update()` - Override either or both of these to support saving instances.\n\nBecause this class provides the same interface as the `Serializer` class, you can use it with the existing generic class-based views exactly as you would for a regular `Serializer` or `ModelSerializer`.\n\nThe only difference you'll notice when doing so is the `BaseSerializer` classes will not generate HTML forms in the browsable API. This is because the data they return does not include all the field information that would allow each field to be rendered into a suitable HTML input.\n\n#### Read-only BaseSerializer classes\n\nTo implement a read-only serializer using the `BaseSerializer` class, we just need to override the `.to_representation()` method. Let's take a look at an example using a simple Django model:\n\n``` python\nclass HighScore(models.Model):\n    created = models.DateTimeField(auto_now_add=True)\n    player_name = models.CharField(max_length=10)\n    score = models.IntegerField()\n```\n\nIt's simple to create a read-only serializer for converting `HighScore` instances into primitive data types.\n\n``` python\nclass HighScoreSerializer(serializers.BaseSerializer):\n    def to_representation(self, instance):\n        return {\n            'score': instance.score,\n            'player_name': instance.player_name\n        }\n```\n\nWe can now use this class to serialize single `HighScore` instances:\n\n``` python\n@api_view(['GET'])\ndef high_score(request, pk):\n    instance = HighScore.objects.get(pk=pk)\n    serializer = HighScoreSerializer(instance)\n    return Response(serializer.data)\n```\n\nOr use it to serialize multiple instances:\n\n``` python\n@api_view(['GET'])\ndef all_high_scores(request):\n    queryset = HighScore.objects.order_by('-score')\n    serializer = HighScoreSerializer(queryset, many=True)\n    return Response(serializer.data)\n```\n\n#### Read-write BaseSerializer classes\n\nTo create a read-write serializer we first need to implement a `.to_internal_value()` method. This method returns the validated values that will be used to construct the object instance, and may raise a `serializers.ValidationError` if the supplied data is in an incorrect format.\n\nOnce you've implemented `.to_internal_value()`, the basic validation API will be available on the serializer, and you will be able to use `.is_valid()`, `.validated_data` and `.errors`.\n\nIf you want to also support `.save()` you'll need to also implement either or both of the `.create()` and `.update()` methods.\n\nHere's a complete example of our previous `HighScoreSerializer`, that's been updated to support both read and write operations.\n\n``` python\nclass HighScoreSerializer(serializers.BaseSerializer):\n    def to_internal_value(self, data):\n        score = data.get('score')\n        player_name = data.get('player_name')\n\n        # Perform the data validation.\n        if not score:\n            raise serializers.ValidationError({\n                'score': 'This field is required.'\n            })\n        if not player_name:\n            raise serializers.ValidationError({\n                'player_name': 'This field is required.'\n            })\n        if len(player_name) > 10:\n            raise serializers.ValidationError({\n                'player_name': 'May not be more than 10 characters.'\n            })\n\n        # Return the validated values. This will be available as\n        # the `.validated_data` property.\n        return {\n            'score': int(score),\n            'player_name': player_name\n        }\n\n    def to_representation(self, instance):\n        return {\n            'score': instance.score,\n            'player_name': instance.player_name\n        }\n\n    def create(self, validated_data):\n        return HighScore.objects.create(**validated_data)\n```\n\n#### Creating new base classes\n\nThe `BaseSerializer` class is also useful if you want to implement new generic serializer classes for dealing with particular serialization styles, or for integrating with alternative storage backends.\n\nThe following class is an example of a generic serializer that can handle coercing arbitrary complex objects into primitive representations.\n\n``` python\nclass ObjectSerializer(serializers.BaseSerializer):\n    \"\"\"\n    A read-only serializer that coerces arbitrary complex objects\n    into primitive representations.\n    \"\"\"\n    def to_representation(self, instance):\n        output = {}\n        for attribute_name in dir(instance):\n            attribute = getattr(instance, attribute_name)\n            if attribute_name.startswith('_'):\n                # Ignore private attributes.\n                pass\n            elif hasattr(attribute, '__call__'):\n                # Ignore methods and other callables.\n                pass\n            elif isinstance(attribute, (str, int, bool, float, type(None))):\n                # Primitive types can be passed through unmodified.\n                output[attribute_name] = attribute\n            elif isinstance(attribute, list):\n                # Recursively deal with items in lists.\n                output[attribute_name] = [\n                    self.to_representation(item) for item in attribute\n                ]\n            elif isinstance(attribute, dict):\n                # Recursively deal with items in dictionaries.\n                output[attribute_name] = {\n                    str(key): self.to_representation(value)\n                    for key, value in attribute.items()\n                }\n            else:\n                # Force anything else to its string representation.\n                output[attribute_name] = str(attribute)\n        return output\n```\n\n# Advanced serializer usage\n\n## Overriding serialization and deserialization behavior\n\nIf you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the `.to_representation()` or `.to_internal_value()` methods.\n\nSome reasons this might be useful include...\n\n- Adding new behavior for new serializer base classes.\n- Modifying the behavior slightly for an existing class.\n- Improving serialization performance for a frequently accessed API endpoint that returns lots of data.\n\nThe signatures for these methods are as follows:\n\n#### to_representation(self, instance)\n\nTakes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API.\n\nMay be overridden in order to modify the representation style. For example:\n\n``` python\ndef to_representation(self, instance):\n    \"\"\"Convert `username` to lowercase.\"\"\"\n    ret = super().to_representation(instance)\n    ret['username'] = ret['username'].lower()\n    return ret\n```\n\n#### to_internal_value(self, data)\n\nTakes the unvalidated incoming data as input and should return the validated data that will be made available as `serializer.validated_data`. The return value will also be passed to the `.create()` or `.update()` methods if `.save()` is called on the serializer class.\n\nIf any of the validation fails, then the method should raise a `serializers.ValidationError(errors)`. The `errors` argument should be a dictionary mapping field names (or `settings.NON_FIELD_ERRORS_KEY`) to a list of error messages. If you don't need to alter deserialization behavior and instead want to provide object-level validation, it's recommended that you instead override the [`.validate()`](#object-level-validation) method.\n\nThe `data` argument passed to this method will normally be the value of `request.data`, so the datatype it provides will depend on the parser classes you have configured for your API.\n\n## Serializer Inheritance\n\nSimilar to Django forms, you can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example,\n\n``` python\nclass MyBaseSerializer(Serializer):\n    my_field = serializers.CharField()\n\n    def validate_my_field(self, value):\n        ...\n\nclass MySerializer(MyBaseSerializer):\n    ...\n```\n\nLike Django's `Model` and `ModelForm` classes, the inner `Meta` class on serializers does not implicitly inherit from it's parents' inner `Meta` classes. If you want the `Meta` class to inherit from a parent class you must do so explicitly. For example:\n\n``` python\nclass AccountSerializer(MyBaseSerializer):\n    class Meta(MyBaseSerializer.Meta):\n        model = Account\n```\n\nTypically we would recommend *not* using inheritance on inner Meta classes, but instead declaring all options explicitly.\n\nAdditionally, the following caveats apply to serializer inheritance:\n\n- Normal Python name resolution rules apply. If you have multiple base classes that declare a `Meta` inner class, only the first one will be used. This means the child’s `Meta`, if it exists, otherwise the `Meta` of the first parent, etc.\n\n- It’s possible to declaratively remove a `Field` inherited from a parent class by setting the name to be `None` on the subclass.\n\n  ``` python\n  class MyBaseSerializer(ModelSerializer):\n      my_field = serializers.CharField()\n\n  class MySerializer(MyBaseSerializer):\n      my_field = None\n  ```\n\n  However, you can only use this technique to opt out from a field defined declaratively by a parent class; it won’t prevent the `ModelSerializer` from generating a default field. To opt-out from default fields, see [Specifying which fields to include](#specifying-which-fields-to-include).\n\n## Dynamically modifying fields\n\nOnce a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the `.fields` attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer.\n\nModifying the `fields` argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.\n\n### Example\n\nFor example, if you wanted to be able to set which fields should be used by a serializer at the point of initializing it, you could create a serializer class like so:\n\n``` python\nclass DynamicFieldsModelSerializer(serializers.ModelSerializer):\n    \"\"\"\n    A ModelSerializer that takes an additional `fields` argument that\n    controls which fields should be displayed.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # Don't pass the 'fields' arg up to the superclass\n        fields = kwargs.pop('fields', None)\n\n        # Instantiate the superclass normally\n        super().__init__(*args, **kwargs)\n\n        if fields is not None:\n            # Drop any fields that are not specified in the `fields` argument.\n            allowed = set(fields)\n            existing = set(self.fields)\n            for field_name in existing - allowed:\n                self.fields.pop(field_name)\n```\n\nThis would then allow you to do the following:\n\n``` python\n>>> class UserSerializer(DynamicFieldsModelSerializer):\n>>>     class Meta:\n>>>         model = User\n>>>         fields = ['id', 'username', 'email']\n>>>\n>>> print(UserSerializer(user))\n{'id': 2, 'username': 'jonwatts', 'email': 'jon@example.com'}\n>>>\n>>> print(UserSerializer(user, fields=('id', 'email')))\n{'id': 2, 'email': 'jon@example.com'}\n```\n\n## Customizing the default fields\n\nREST framework 2 provided an API to allow developers to override how a `ModelSerializer` class would automatically generate the default set of fields.\n\nThis API included the `.get_field()`, `.get_pk_field()` and other methods.\n\nBecause the serializers have been fundamentally redesigned with 3.0 this API no longer exists. You can still modify the fields that get created but you'll need to refer to the source code, and be aware that if the changes you make are against private bits of API then they may be subject to change.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## Django REST marshmallow\n\nThe [django-rest-marshmallow](https://marshmallow-code.github.io/django-rest-marshmallow/) package provides an alternative implementation for serializers, using the python [marshmallow](https://marshmallow.readthedocs.io/en/latest/) library. It exposes the same API as the REST framework serializers, and can be used as a drop-in replacement in some use-cases.\n\n## Serpy\n\nThe [serpy](https://github.com/clarkduvall/serpy) package is an alternative implementation for serializers that is built for speed. [Serpy](https://github.com/clarkduvall/serpy) serializes complex datatypes to simple native types. The native types can be easily converted to JSON or any other format needed.\n\n## MongoengineModelSerializer\n\nThe [django-rest-framework-mongoengine](https://github.com/umutbozkurt/django-rest-framework-mongoengine) package provides a `MongoEngineModelSerializer` serializer class that supports using MongoDB as the storage layer for Django REST framework.\n\n## GeoFeatureModelSerializer\n\nThe [django-rest-framework-gis](https://github.com/djangonauts/django-rest-framework-gis) package provides a `GeoFeatureModelSerializer` serializer class that supports GeoJSON both for read and write operations.\n\n## HStoreSerializer\n\nThe [django-rest-framework-hstore](https://github.com/djangonauts/django-rest-framework-hstore) package provides an `HStoreSerializer` to support [django-hstore](https://github.com/djangonauts/django-hstore) `DictionaryField` model field and its `schema-mode` feature.\n\n## Dynamic REST\n\nThe [dynamic-rest](https://github.com/AltSchool/dynamic-rest) package extends the ModelSerializer and ModelViewSet interfaces, adding API query parameters for filtering, sorting, and including / excluding all fields and relationships defined by your serializers.\n\n## Dynamic Fields Mixin\n\nThe [drf-dynamic-fields](https://github.com/dbrgn/drf-dynamic-fields) package provides a mixin to dynamically limit the fields per serializer to a subset specified by an URL parameter.\n\n## DRF FlexFields\n\nThe [drf-flex-fields](https://github.com/rsinger86/drf-flex-fields) package extends the ModelSerializer and ModelViewSet to provide commonly used functionality for dynamically setting fields and expanding primitive fields to nested models, both from URL parameters and your serializer class definitions.\n\n## Serializer Extensions\n\nThe [django-rest-framework-serializer-extensions](https://github.com/evenicoulddoit/django-rest-framework-serializer-extensions) package provides a collection of tools to DRY up your serializers, by allowing fields to be defined on a per-view/request basis. Fields can be whitelisted, blacklisted and child serializers can be optionally expanded.\n\n## HTML JSON Forms\n\nThe [html-json-forms](https://github.com/wq/html-json-forms) package provides an algorithm and serializer for processing `<form>` submissions per the (inactive) [HTML JSON Form specification](https://www.w3.org/TR/html-json-forms/). The serializer facilitates processing of arbitrarily nested JSON structures within HTML. For example, `<input name=\"items[0][id]\" value=\"5\">` will be interpreted as `{\"items\": [{\"id\": \"5\"}]}`.\n\n## DRF-Base64\n\n[DRF-Base64](https://bitbucket.org/levit_scs/drf_base64) provides a set of field and model serializers that handles the upload of base64-encoded files.\n\n## QueryFields\n\n[djangorestframework-queryfields](https://djangorestframework-queryfields.readthedocs.io/) allows API clients to specify which fields will be sent in the response via inclusion/exclusion query parameters.\n\n## DRF Writable Nested\n\nThe [drf-writable-nested](https://github.com/beda-software/drf-writable-nested) package provides writable nested model serializer which allows to create/update models with nested related data.\n\n## DRF Encrypt Content\n\nThe [drf-encrypt-content](https://github.com/oguzhancelikarslan/drf-encrypt-content) package helps you encrypt your data, serialized through ModelSerializer. It also contains some helper functions. Which helps you to encrypt your data.\n\n[serializers.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/serializers.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/serializers/](https://www.django-rest-framework.org/api-guide/serializers/)"
- name: BasicAuthentication
  id: api-guide/authentication/index#basicauthentication
  summary: This authentication scheme uses HTTP Basic Authentication, signed against a user's username and password
  belongs_to: Authentication
  description: |-
    ## BasicAuthentication

    This authentication scheme uses [HTTP Basic Authentication](https://tools.ietf.org/html/rfc2617), signed against a user's username and password. Basic authentication is generally only appropriate for testing.

    If successfully authenticated, `BasicAuthentication` provides the following credentials.

    - `request.user` will be a Django `User` instance.
    - `request.auth` will be `None`.

    Unauthenticated responses that are denied permission will result in an `HTTP 401 Unauthorized` response with an appropriate WWW-Authenticate header. For example:

    ``` python
    WWW-Authenticate: Basic realm="api"
    ```

    **Note:** If you use `BasicAuthentication` in production you must ensure that your API is only available over `https`. You should also ensure that your API clients will always re-request the username and password at login, and will never store those details to persistent storage.
- name: BooleanField
  id: api-guide/fields/index#booleanfield
  summary: A boolean representation
  belongs_to: Serializer fields
  description: |-
    ## BooleanField

    A boolean representation.

    When using HTML encoded form input be aware that omitting a value will always be treated as setting a field to `False`, even if it has a `default=True` option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.

    Note that Django 2.1 removed the `blank` kwarg from `models.BooleanField`. Prior to Django 2.1 `models.BooleanField` fields were always `blank=True`. Thus since Django 2.1 default `serializers.BooleanField` instances will be generated without the `required` kwarg (i.e. equivalent to `required=True`) whereas with previous versions of Django, default `BooleanField` instances will be generated with a `required=False` option. If you want to control this behavior manually, explicitly declare the `BooleanField` on the serializer class, or use the `extra_kwargs` option to set the `required` flag.

    Corresponds to `django.db.models.fields.BooleanField`.

    **Signature:** `BooleanField()`

    # String fields
- name: BrowsableAPIRenderer
  id: api-guide/renderers/index#browsableapirenderer
  summary: This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page
  belongs_to: Renderers
  description: |-
    ## BrowsableAPIRenderer

    Renders data into HTML for the Browsable API:

    This renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.

    **.media_type**: `text/html`

    **.format**: `'api'`

    **.charset**: `utf-8`

    **.template**: `'rest_framework/api.html'`

    #### Customizing BrowsableAPIRenderer

    By default the response content will be rendered with the highest priority renderer apart from `BrowsableAPIRenderer`. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the `get_default_renderer()` method. For example:

    ``` python
    class CustomBrowsableAPIRenderer(BrowsableAPIRenderer):
        def get_default_renderer(self, view):
            return JSONRenderer()
    ```
- name: Caching
  id: api-guide/caching/index
  summary: A certain woman had a very sharp consciousness but almost no memory ... She remembered enough to work, and she worked hard
  description: "# Caching\n\n> A certain woman had a very sharp consciousness but almost no memory ... She remembered enough to work, and she worked hard. - Lydia Davis\n\nCaching in REST Framework works well with the cache utilities provided in Django.\n\n## Using cache with apiview and viewsets\n\nDjango provides a [`method_decorator`](https://docs.djangoproject.com/en/dev/topics/class-based-views/intro/#decorating-the-class) to use decorators with class based views. This can be used with other cache decorators such as [`cache_page`](https://docs.djangoproject.com/en/dev/topics/cache/#the-per-view-cache), [`vary_on_cookie`](https://docs.djangoproject.com/en/dev/topics/http/decorators/#django.views.decorators.vary.vary_on_cookie) and [`vary_on_headers`](https://docs.djangoproject.com/en/dev/topics/http/decorators/#django.views.decorators.vary.vary_on_headers).\n\n``` python\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.vary import vary_on_cookie, vary_on_headers\n\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework import viewsets\n\n\nclass UserViewSet(viewsets.ViewSet):\n    # With cookie: cache requested url for each user for 2 hours\n    @method_decorator(cache_page(60 * 60 * 2))\n    @method_decorator(vary_on_cookie)\n    def list(self, request, format=None):\n        content = {\n            \"user_feed\": request.user.get_user_feed(),\n        }\n        return Response(content)\n\n\nclass ProfileView(APIView):\n    # With auth: cache requested url for each user for 2 hours\n    @method_decorator(cache_page(60 * 60 * 2))\n    @method_decorator(vary_on_headers(\"Authorization\"))\n    def get(self, request, format=None):\n        content = {\n            \"user_feed\": request.user.get_user_feed(),\n        }\n        return Response(content)\n\n\nclass PostView(APIView):\n    # Cache page for the requested url\n    @method_decorator(cache_page(60 * 60 * 2))\n    def get(self, request, format=None):\n        content = {\n            \"title\": \"Post title\",\n            \"body\": \"Post content\",\n        }\n        return Response(content)\n```\n\n## Using cache with @api_view decorator\n\nWhen using @api_view decorator, the Django-provided method-based cache decorators such as [`cache_page`](https://docs.djangoproject.com/en/dev/topics/cache/#the-per-view-cache), [`vary_on_cookie`](https://docs.djangoproject.com/en/dev/topics/http/decorators/#django.views.decorators.vary.vary_on_cookie) and [`vary_on_headers`](https://docs.djangoproject.com/en/dev/topics/http/decorators/#django.views.decorators.vary.vary_on_headers) can be called directly.\n\n``` python\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.vary import vary_on_cookie\n\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\n\n\n@cache_page(60 * 15)\n@vary_on_cookie\n@api_view([\"GET\"])\ndef get_user_list(request):\n    content = {\"user_feed\": request.user.get_user_feed()}\n    return Response(content)\n```\n\n**NOTE:** The [`cache_page`](https://docs.djangoproject.com/en/dev/topics/cache/#the-per-view-cache) decorator only caches the `GET` and `HEAD` responses with status 200.\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/caching/](https://www.django-rest-framework.org/api-guide/caching/)"
- name: CharField
  id: api-guide/fields/index#charfield
  summary: A text representation
  belongs_to: Serializer fields
  description: |-
    ## CharField

    A text representation. Optionally validates the text to be shorter than `max_length` and longer than `min_length`.

    Corresponds to `django.db.models.fields.CharField` or `django.db.models.fields.TextField`.

    **Signature:** `CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)`

    - `max_length` - Validates that the input contains no more than this number of characters.
    - `min_length` - Validates that the input contains no fewer than this number of characters.
    - `allow_blank` - If set to `True` then the empty string should be considered a valid value. If set to `False` then the empty string is considered invalid and will raise a validation error. Defaults to `False`.
    - `trim_whitespace` - If set to `True` then leading and trailing whitespace is trimmed. Defaults to `True`.

    The `allow_null` option is also available for string fields, although its usage is discouraged in favor of `allow_blank`. It is valid to set both `allow_blank=True` and `allow_null=True`, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.
- name: ChoiceField
  id: api-guide/fields/index#choicefield
  summary: A field that can accept a value out of a limited set of choices
  belongs_to: Serializer fields
  description: |-
    ## ChoiceField

    A field that can accept a value out of a limited set of choices.

    Used by `ModelSerializer` to automatically generate fields if the corresponding model field includes a `choices=…` argument.

    **Signature:** `ChoiceField(choices)`

    - `choices` - A list of valid values, or a list of `(key, display_name)` tuples.
    - `allow_blank` - If set to `True` then the empty string should be considered a valid value. If set to `False` then the empty string is considered invalid and will raise a validation error. Defaults to `False`.
    - `html_cutoff` - If set this will be the maximum number of choices that will be displayed by a HTML select drop down. Can be used to ensure that automatically generated ChoiceFields with very large possible selections do not prevent a template from rendering. Defaults to `None`.
    - `html_cutoff_text` - If set this will display a textual indicator if the maximum number of items have been cutoff in an HTML select drop down. Defaults to `"More than {count} items…"`

    Both the `allow_blank` and `allow_null` are valid options on `ChoiceField`, although it is highly recommended that you only use one and not both. `allow_blank` should be preferred for textual choices, and `allow_null` should be preferred for numeric or other non-textual choices.
- name: Class-based Views
  id: api-guide/views/index
  summary: Django's class-based views are a welcome departure from the old-style views
  description: "# Class-based Views\n\n> Django's class-based views are a welcome departure from the old-style views.\n>\n> — [Reinout van Rees](https://reinout.vanrees.org/weblog/2011/08/24/class-based-views-usage.html)\n\nREST framework provides an `APIView` class, which subclasses Django's `View` class.\n\n`APIView` classes are different from regular `View` classes in the following ways:\n\n- Requests passed to the handler methods will be REST framework's `Request` instances, not Django's `HttpRequest` instances.\n- Handler methods may return REST framework's `Response`, instead of Django's `HttpResponse`. The view will manage content negotiation and setting the correct renderer on the response.\n- Any `APIException` exceptions will be caught and mediated into appropriate responses.\n- Incoming requests will be authenticated and appropriate permission and/or throttle checks will be run before dispatching the request to the handler method.\n\nUsing the `APIView` class is pretty much the same as using a regular `View` class, as usual, the incoming request is dispatched to an appropriate handler method such as `.get()` or `.post()`. Additionally, a number of attributes may be set on the class that control various aspects of the API policy.\n\nFor example:\n\n``` python\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import authentication, permissions\nfrom django.contrib.auth.models import User\n\nclass ListUsers(APIView):\n    \"\"\"\n    View to list all users in the system.\n\n    * Requires token authentication.\n    * Only admin users are able to access this view.\n    \"\"\"\n    authentication_classes = [authentication.TokenAuthentication]\n    permission_classes = [permissions.IsAdminUser]\n\n    def get(self, request, format=None):\n        \"\"\"\n        Return a list of all users.\n        \"\"\"\n        usernames = [user.username for user in User.objects.all()]\n        return Response(usernames)\n```\n\n**Note**: The full methods, attributes on, and relations between Django REST Framework's `APIView`, `GenericAPIView`, various `Mixins`, and `Viewsets` can be initially complex. In addition to the documentation here, the [Classy Django REST Framework](http://www.cdrf.co) resource provides a browsable reference, with full methods and attributes, for each of Django REST Framework's class-based views.\n\n## API policy attributes\n\nThe following attributes control the pluggable aspects of API views.\n\n### .renderer_classes\n\n### .parser_classes\n\n### .authentication_classes\n\n### .throttle_classes\n\n### .permission_classes\n\n### .content_negotiation_class\n\n## API policy instantiation methods\n\nThe following methods are used by REST framework to instantiate the various pluggable API policies. You won't typically need to override these methods.\n\n### .get_renderers(self)\n\n### .get_parsers(self)\n\n### .get_authenticators(self)\n\n### .get_throttles(self)\n\n### .get_permissions(self)\n\n### .get_content_negotiator(self)\n\n### .get_exception_handler(self)\n\n## API policy implementation methods\n\nThe following methods are called before dispatching to the handler method.\n\n### .check_permissions(self, request)\n\n### .check_throttles(self, request)\n\n### .perform_content_negotiation(self, request, force=False)\n\n## Dispatch methods\n\nThe following methods are called directly by the view's `.dispatch()` method. These perform any actions that need to occur before or after calling the handler methods such as `.get()`, `.post()`, `put()`, `patch()` and `.delete()`.\n\n### .initial(self, request, \\*args, \\*\\*kwargs)\n\nPerforms any actions that need to occur before the handler method gets called. This method is used to enforce permissions and throttling, and perform content negotiation.\n\nYou won't typically need to override this method.\n\n### .handle_exception(self, exc)\n\nAny exception thrown by the handler method will be passed to this method, which either returns a `Response` instance, or re-raises the exception.\n\nThe default implementation handles any subclass of `rest_framework.exceptions.APIException`, as well as Django's `Http404` and `PermissionDenied` exceptions, and returns an appropriate error response.\n\nIf you need to customize the error responses your API returns you should subclass this method.\n\n### .initialize_request(self, request, \\*args, \\*\\*kwargs)\n\nEnsures that the request object that is passed to the handler method is an instance of `Request`, rather than the usual Django `HttpRequest`.\n\nYou won't typically need to override this method.\n\n### .finalize_response(self, request, response, \\*args, \\*\\*kwargs)\n\nEnsures that any `Response` object returned from the handler method will be rendered into the correct content type, as determined by the content negotiation.\n\nYou won't typically need to override this method.\n\n# Function Based Views\n\n> Saying \\[that class-based views\\] is always the superior solution is a mistake.\n>\n> — [Nick Coghlan](http://www.boredomandlaziness.org/2012/05/djangos-cbvs-are-not-mistake-but.html)\n\nREST framework also allows you to work with regular function based views. It provides a set of simple decorators that wrap your function based views to ensure they receive an instance of `Request` (rather than the usual Django `HttpRequest`) and allows them to return a `Response` (instead of a Django `HttpResponse`), and allow you to configure how the request is processed.\n\n## @api_view()\n\n**Signature:** `@api_view(http_method_names=['GET'])`\n\nThe core of this functionality is the `api_view` decorator, which takes a list of HTTP methods that your view should respond to. For example, this is how you would write a very simple view that just manually returns some data:\n\n``` python\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\n\n@api_view()\ndef hello_world(request):\n    return Response({\"message\": \"Hello, world!\"})\n```\n\nThis view will use the default renderers, parsers, authentication classes etc specified in the [settings](../settings/index).\n\nBy default only `GET` methods will be accepted. Other methods will respond with \"405 Method Not Allowed\". To alter this behavior, specify which methods the view allows, like so:\n\n``` python\n@api_view(['GET', 'POST'])\ndef hello_world(request):\n    if request.method == 'POST':\n        return Response({\"message\": \"Got some data!\", \"data\": request.data})\n    return Response({\"message\": \"Hello, world!\"})\n```\n\n## API policy decorators\n\nTo override the default settings, REST framework provides a set of additional decorators which can be added to your views. These must come *after* (below) the `@api_view` decorator. For example, to create a view that uses a [throttle](../throttling/index) to ensure it can only be called once per day by a particular user, use the `@throttle_classes` decorator, passing a list of throttle classes:\n\n``` python\nfrom rest_framework.decorators import api_view, throttle_classes\nfrom rest_framework.throttling import UserRateThrottle\n\nclass OncePerDayUserThrottle(UserRateThrottle):\n    rate = '1/day'\n\n@api_view(['GET'])\n@throttle_classes([OncePerDayUserThrottle])\ndef view(request):\n    return Response({\"message\": \"Hello for today! See you tomorrow!\"})\n```\n\nThese decorators correspond to the attributes set on `APIView` subclasses, described above.\n\nThe available decorators are:\n\n- `@renderer_classes(...)`\n- `@parser_classes(...)`\n- `@authentication_classes(...)`\n- `@throttle_classes(...)`\n- `@permission_classes(...)`\n\nEach of these decorators takes a single argument which must be a list or tuple of classes.\n\n## View schema decorator\n\nTo override the default schema generation for function based views you may use the `@schema` decorator. This must come *after* (below) the `@api_view` decorator. For example:\n\n``` python\nfrom rest_framework.decorators import api_view, schema\nfrom rest_framework.schemas import AutoSchema\n\nclass CustomAutoSchema(AutoSchema):\n    def get_link(self, path, method, base_url):\n        # override view introspection here...\n\n@api_view(['GET'])\n@schema(CustomAutoSchema())\ndef view(request):\n    return Response({\"message\": \"Hello for today! See you tomorrow!\"})\n```\n\nThis decorator takes a single `AutoSchema` instance, an `AutoSchema` subclass instance or `ManualSchema` instance as described in the [Schemas documentation](../schemas/index). You may pass `None` in order to exclude the view from schema generation.\n\n``` python\n@api_view(['GET'])\n@schema(None)\ndef view(request):\n    return Response({\"message\": \"Will not appear in schema!\"})\n```\n\n[decorators.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/decorators.py)[views.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/views.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/views/](https://www.django-rest-framework.org/api-guide/views/)"
- name: Content negotiation
  id: api-guide/content-negotiation/index
  summary: HTTP has provisions for several mechanisms for "content negotiation" - the process of selecting the best representation for a given response when there are multiple representations available
  description: "# Content negotiation\n\n> HTTP has provisions for several mechanisms for \"content negotiation\" - the process of selecting the best representation for a given response when there are multiple representations available.\n>\n> — [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html), Fielding et al.\n\nContent negotiation is the process of selecting one of multiple possible representations to return to a client, based on client or server preferences.\n\n## Determining the accepted renderer\n\nREST framework uses a simple style of content negotiation to determine which media type should be returned to a client, based on the available renderers, the priorities of each of those renderers, and the client's `Accept:` header. The style used is partly client-driven, and partly server-driven.\n\n1.  More specific media types are given preference to less specific media types.\n2.  If multiple media types have the same specificity, then preference is given to based on the ordering of the renderers configured for the given view.\n\nFor example, given the following `Accept` header:\n\n``` python\napplication/json; indent=4, application/json, application/yaml, text/html, */*\n```\n\nThe priorities for each of the given media types would be:\n\n- `application/json; indent=4`\n- `application/json`, `application/yaml` and `text/html`\n- `*/*`\n\nIf the requested view was only configured with renderers for `YAML` and `HTML`, then REST framework would select whichever renderer was listed first in the `renderer_classes` list or `DEFAULT_RENDERER_CLASSES` setting.\n\nFor more information on the `HTTP Accept` header, see [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)\n\n**Note**: \"q\" values are not taken into account by REST framework when determining preference. The use of \"q\" values negatively impacts caching, and in the author's opinion they are an unnecessary and overcomplicated approach to content negotiation.\n\nThis is a valid approach as the HTTP spec deliberately underspecifies how a server should weight server-based preferences against client-based preferences.\n\n# Custom content negotiation\n\nIt's unlikely that you'll want to provide a custom content negotiation scheme for REST framework, but you can do so if needed. To implement a custom content negotiation scheme override `BaseContentNegotiation`.\n\nREST framework's content negotiation classes handle selection of both the appropriate parser for the request, and the appropriate renderer for the response, so you should implement both the `.select_parser(request, parsers)` and `.select_renderer(request, renderers, format_suffix)` methods.\n\nThe `select_parser()` method should return one of the parser instances from the list of available parsers, or `None` if none of the parsers can handle the incoming request.\n\nThe `select_renderer()` method should return a two-tuple of (renderer instance, media type), or raise a `NotAcceptable` exception.\n\n## Example\n\nThe following is a custom content negotiation class which ignores the client request when selecting the appropriate parser or renderer.\n\n``` python\nfrom rest_framework.negotiation import BaseContentNegotiation\n\nclass IgnoreClientContentNegotiation(BaseContentNegotiation):\n    def select_parser(self, request, parsers):\n        \"\"\"\n        Select the first parser in the `.parser_classes` list.\n        \"\"\"\n        return parsers[0]\n\n    def select_renderer(self, request, renderers, format_suffix):\n        \"\"\"\n        Select the first renderer in the `.renderer_classes` list.\n        \"\"\"\n        return (renderers[0], renderers[0].media_type)\n```\n\n## Setting the content negotiation\n\nThe default content negotiation class may be set globally, using the `DEFAULT_CONTENT_NEGOTIATION_CLASS` setting. For example, the following settings would use our example `IgnoreClientContentNegotiation` class.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_CONTENT_NEGOTIATION_CLASS': 'myapp.negotiation.IgnoreClientContentNegotiation',\n}\n```\n\nYou can also set the content negotiation used for an individual view, or viewset, using the `APIView` class-based views.\n\n``` python\nfrom myapp.negotiation import IgnoreClientContentNegotiation\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass NoNegotiationView(APIView):\n    \"\"\"\n    An example view that does not perform content negotiation.\n    \"\"\"\n    content_negotiation_class = IgnoreClientContentNegotiation\n\n    def get(self, request, format=None):\n        return Response({\n            'accepted media type': request.accepted_renderer.media_type\n        })\n```\n\n[negotiation.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/negotiation.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/content-negotiation/](https://www.django-rest-framework.org/api-guide/content-negotiation/)"
- name: Content type controls
  id: api-guide/settings/index#content-type-controls
  summary: The name of a URL parameter that may be used to override the default content negotiation Accept header behavior, by using a format=… query parameter in the request URL
  belongs_to: Settings
  description: |-
    ## Content type controls

    #### URL_FORMAT_OVERRIDE

    The name of a URL parameter that may be used to override the default content negotiation `Accept` header behavior, by using a `format=…` query parameter in the request URL.

    For example: `http://example.com/organizations/?format=csv`

    If the value of this setting is `None` then URL format overrides will be disabled.

    Default: `'format'`

    #### FORMAT_SUFFIX_KWARG

    The name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using `format_suffix_patterns` to include suffixed URL patterns.

    For example: `http://example.com/organizations.csv/`

    Default: `'format'`
- name: CreateAPIView
  id: api-guide/generic-views/index#createapiview
  summary: Used for create-only endpoints
  belongs_to: Generic views
  description: |-
    ## CreateAPIView

    Used for **create-only** endpoints.

    Provides a `post` method handler.

    Extends: [GenericAPIView](#genericapiview), [CreateModelMixin](#createmodelmixin)
- name: CreateModelMixin
  id: api-guide/generic-views/index#createmodelmixin
  summary: Provides a .create(request, *args, **kwargs) method, that implements creating and saving a new model instance
  belongs_to: Generic views
  description: |-
    ## CreateModelMixin

    Provides a `.create(request, *args, **kwargs)` method, that implements creating and saving a new model instance.

    If an object is created this returns a `201 Created` response, with a serialized representation of the object as the body of the response. If the representation contains a key named `url`, then the `Location` header of the response will be populated with that value.

    If the request data provided for creating the object was invalid, a `400 Bad Request` response will be returned, with the error details as the body of the response.
- name: CursorPagination
  id: api-guide/pagination/index#cursorpagination
  summary: The cursor-based pagination presents an opaque "cursor" indicator that the client may use to page through the result set
  belongs_to: Pagination
  description: "## CursorPagination\n\nThe cursor-based pagination presents an opaque \"cursor\" indicator that the client may use to page through the result set. This pagination style only presents forward and reverse controls, and does not allow the client to navigate to arbitrary positions.\n\nCursor based pagination requires that there is a unique, unchanging ordering of items in the result set. This ordering might typically be a creation timestamp on the records, as this presents a consistent ordering to paginate against.\n\nCursor based pagination is more complex than other schemes. It also requires that the result set presents a fixed ordering, and does not allow the client to arbitrarily index into the result set. However it does provide the following benefits:\n\n- Provides a consistent pagination view. When used properly `CursorPagination` ensures that the client will never see the same item twice when paging through records, even when new items are being inserted by other clients during the pagination process.\n- Supports usage with very large datasets. With extremely large datasets pagination using offset-based pagination styles may become inefficient or unusable. Cursor based pagination schemes instead have fixed-time properties, and do not slow down as the dataset size increases.\n\n#### Details and limitations\n\nProper use of cursor based pagination requires a little attention to detail. You'll need to think about what ordering you want the scheme to be applied against. The default is to order by `\"-created\"`. This assumes that **there must be a 'created' timestamp field** on the model instances, and will present a \"timeline\" style paginated view, with the most recently added items first.\n\nYou can modify the ordering by overriding the `'ordering'` attribute on the pagination class, or by using the `OrderingFilter` filter class together with `CursorPagination`. When used with `OrderingFilter` you should strongly consider restricting the fields that the user may order by.\n\nProper usage of cursor pagination should have an ordering field that satisfies the following:\n\n- Should be an unchanging value, such as a timestamp, slug, or other field that is only set once, on creation.\n- Should be unique, or nearly unique. Millisecond precision timestamps are a good example. This implementation of cursor pagination uses a smart \"position plus offset\" style that allows it to properly support not-strictly-unique values as the ordering.\n- Should be a non-nullable value that can be coerced to a string.\n- Should not be a float. Precision errors easily lead to incorrect results. Hint: use decimals instead. (If you already have a float field and must paginate on that, an [example `CursorPagination` subclass that uses decimals to limit precision is available here](https://gist.github.com/keturn/8bc88525a183fd41c73ffb729b8865be#file-fpcursorpagination-py).)\n- The field should have a database index.\n\nUsing an ordering field that does not satisfy these constraints will generally still work, but you'll be losing some of the benefits of cursor pagination.\n\nFor more technical details on the implementation we use for cursor pagination, the [\"Building cursors for the Disqus API\"](https://cra.mr/2011/03/08/building-cursors-for-the-disqus-api) blog post gives a good overview of the basic approach.\n\n#### Setup\n\nTo enable the `CursorPagination` style globally, use the following configuration, modifying the `PAGE_SIZE` as desired:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.CursorPagination',\n    'PAGE_SIZE': 100\n}\n```\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class` attribute to select `CursorPagination` on a per-view basis.\n\n#### Configuration\n\nThe `CursorPagination` class includes a number of attributes that may be overridden to modify the pagination style.\n\nTo set these attributes you should override the `CursorPagination` class, and then enable your custom pagination class as above.\n\n- `page_size` = A numeric value indicating the page size. If set, this overrides the `PAGE_SIZE` setting. Defaults to the same value as the `PAGE_SIZE` settings key.\n- `cursor_query_param` = A string value indicating the name of the \"cursor\" query parameter. Defaults to `'cursor'`.\n- `ordering` = This should be a string, or list of strings, indicating the field against which the cursor based pagination will be applied. For example: `ordering = 'slug'`. Defaults to `-created`. This value may also be overridden by using `OrderingFilter` on the view.\n- `template` = The name of a template to use when rendering pagination controls in the browsable API. May be overridden to modify the rendering style, or set to `None` to disable HTML pagination controls completely. Defaults to `\"rest_framework/pagination/previous_and_next.html\"`.\n\n# Custom pagination styles\n\nTo create a custom pagination serializer class, you should inherit the subclass `pagination.BasePagination`, override the `paginate_queryset(self, queryset, request, view=None)`, and `get_paginated_response(self, data)` methods:\n\n- The `paginate_queryset` method is passed to the initial queryset and should return an iterable object. That object contains only the data in the requested page.\n- The `get_paginated_response` method is passed to the serialized page data and should return a `Response` instance.\n\nNote that the `paginate_queryset` method may set state on the pagination instance, that may later be used by the `get_paginated_response` method.\n\n## Example\n\nSuppose we want to replace the default pagination output style with a modified format that includes the next and previous links under in a nested 'links' key. We could specify a custom pagination class like so:\n\n``` python\nclass CustomPagination(pagination.PageNumberPagination):\n    def get_paginated_response(self, data):\n        return Response({\n            'links': {\n                'next': self.get_next_link(),\n                'previous': self.get_previous_link()\n            },\n            'count': self.page.paginator.count,\n            'results': data\n        })\n```\n\nWe'd then need to set up the custom class in our configuration:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'my_project.apps.core.pagination.CustomPagination',\n    'PAGE_SIZE': 100\n}\n```\n\nNote that if you care about how the ordering of keys is displayed in responses in the browsable API you might choose to use an `OrderedDict` when constructing the body of paginated responses, but this is optional.\n\n## Using your custom pagination class\n\nTo have your custom pagination class be used by default, use the `DEFAULT_PAGINATION_CLASS` setting:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'my_project.apps.core.pagination.LinkHeaderPagination',\n    'PAGE_SIZE': 100\n}\n```\n\nAPI responses for list endpoints will now include a `Link` header, instead of including the pagination links as part of the body of the response, for example:\n\n*A custom pagination style, using the 'Link' header*\n\n# HTML pagination controls\n\nBy default using the pagination classes will cause HTML pagination controls to be displayed in the browsable API. There are two built-in display styles. The `PageNumberPagination` and `LimitOffsetPagination` classes display a list of page numbers with previous and next controls. The `CursorPagination` class displays a simpler style that only displays a previous and next control.\n\n## Customizing the controls\n\nYou can override the templates that render the HTML pagination controls. The two built-in styles are:\n\n- `rest_framework/pagination/numbers.html`\n- `rest_framework/pagination/previous_and_next.html`\n\nProviding a template with either of these paths in a global template directory will override the default rendering for the relevant pagination classes.\n\nAlternatively you can disable HTML pagination controls completely by subclassing on of the existing classes, setting `template = None` as an attribute on the class. You'll then need to configure your `DEFAULT_PAGINATION_CLASS` settings key to use your custom class as the default pagination style.\n\n#### Low-level API\n\nThe low-level API for determining if a pagination class should display the controls or not is exposed as a `display_page_controls` attribute on the pagination instance. Custom pagination classes should be set to `True` in the `paginate_queryset` method if they require the HTML pagination controls to be displayed.\n\nThe `.to_html()` and `.get_html_context()` methods may also be overridden in a custom pagination class in order to further customize how the controls are rendered.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## DRF-extensions\n\nThe [`DRF-extensions` package](https://chibisov.github.io/drf-extensions/docs/) includes a [`PaginateByMaxMixin` mixin class](https://chibisov.github.io/drf-extensions/docs/#paginatebymaxmixin) that allows your API clients to specify `?page_size=max` to obtain the maximum allowed page size.\n\n## drf-proxy-pagination\n\nThe [`drf-proxy-pagination` package](https://github.com/tuffnatty/drf-proxy-pagination) includes a `ProxyPagination` class which allows to choose pagination class with a query parameter.\n\n## link-header-pagination\n\nThe [`django-rest-framework-link-header-pagination` package](https://github.com/tbeadle/django-rest-framework-link-header-pagination) includes a `LinkHeaderPagination` class which provides pagination via an HTTP `Link` header as described in [GitHub REST API documentation](https://docs.github.com/en/rest/guides/traversing-with-pagination).\n\n[pagination.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/pagination.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/pagination/](https://www.django-rest-framework.org/api-guide/pagination/)"
- name: Date and time formatting
  id: api-guide/settings/index#date-and-time-formatting
  summary: The following settings are used to control how date and time representations may be parsed and rendered
  belongs_to: Settings
  description: |-
    ## Date and time formatting

    *The following settings are used to control how date and time representations may be parsed and rendered.*

    #### DATETIME_FORMAT

    A format string that should be used by default for rendering the output of `DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer fields will return Python `datetime` objects, and the datetime encoding will be determined by the renderer.

    May be any of `None`, `'iso-8601'` or a Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) string.

    Default: `'iso-8601'`

    #### DATETIME_INPUT_FORMATS

    A list of format strings that should be used by default for parsing inputs to `DateTimeField` serializer fields.

    May be a list including the string `'iso-8601'` or Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) strings.

    Default: `['iso-8601']`

    #### DATE_FORMAT

    A format string that should be used by default for rendering the output of `DateField` serializer fields. If `None`, then `DateField` serializer fields will return Python `date` objects, and the date encoding will be determined by the renderer.

    May be any of `None`, `'iso-8601'` or a Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) string.

    Default: `'iso-8601'`

    #### DATE_INPUT_FORMATS

    A list of format strings that should be used by default for parsing inputs to `DateField` serializer fields.

    May be a list including the string `'iso-8601'` or Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) strings.

    Default: `['iso-8601']`

    #### TIME_FORMAT

    A format string that should be used by default for rendering the output of `TimeField` serializer fields. If `None`, then `TimeField` serializer fields will return Python `time` objects, and the time encoding will be determined by the renderer.

    May be any of `None`, `'iso-8601'` or a Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) string.

    Default: `'iso-8601'`

    #### TIME_INPUT_FORMATS

    A list of format strings that should be used by default for parsing inputs to `TimeField` serializer fields.

    May be a list including the string `'iso-8601'` or Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) strings.

    Default: `['iso-8601']`
- name: DateField
  id: api-guide/fields/index#datefield
  summary: A date representation
  belongs_to: Serializer fields
  description: |-
    ## DateField

    A date representation.

    Corresponds to `django.db.models.fields.DateField`

    **Signature:** `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`

    - `format` - A string representing the output format. If not specified, this defaults to the same value as the `DATE_FORMAT` settings key, which will be `'iso-8601'` unless set. Setting to a format string indicates that `to_representation` return values should be coerced to string output. Format strings are described below. Setting this value to `None` indicates that Python `date` objects should be returned by `to_representation`. In this case the date encoding will be determined by the renderer.
    - `input_formats` - A list of strings representing the input formats which may be used to parse the date. If not specified, the `DATE_INPUT_FORMATS` setting will be used, which defaults to `['iso-8601']`.

    #### DateField format strings

    Format strings may either be [Python strftime formats](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) which explicitly specify the format, or the special string `'iso-8601'`, which indicates that [ISO 8601](https://www.w3.org/TR/NOTE-datetime) style dates should be used. (eg `'2013-01-29'`)
- name: DateTimeField
  id: api-guide/fields/index#datetimefield
  summary: A date and time representation
  belongs_to: Serializer fields
  description: |-
    ## DateTimeField

    A date and time representation.

    Corresponds to `django.db.models.fields.DateTimeField`.

    **Signature:** `DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)`

    - `format` - A string representing the output format. If not specified, this defaults to the same value as the `DATETIME_FORMAT` settings key, which will be `'iso-8601'` unless set. Setting to a format string indicates that `to_representation` return values should be coerced to string output. Format strings are described below. Setting this value to `None` indicates that Python `datetime` objects should be returned by `to_representation`. In this case the datetime encoding will be determined by the renderer.
    - `input_formats` - A list of strings representing the input formats which may be used to parse the date. If not specified, the `DATETIME_INPUT_FORMATS` setting will be used, which defaults to `['iso-8601']`.
    - `default_timezone` - A `tzinfo` subclass (`zoneinfo` or `pytz`) representing the timezone. If not specified and the `USE_TZ` setting is enabled, this defaults to the [current timezone](https://docs.djangoproject.com/en/stable/topics/i18n/timezones/#default-time-zone-and-current-time-zone). If `USE_TZ` is disabled, then datetime objects will be naive.

    #### DateTimeField format strings.

    Format strings may either be [Python strftime formats](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) which explicitly specify the format, or the special string `'iso-8601'`, which indicates that [ISO 8601](https://www.w3.org/TR/NOTE-datetime) style datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)

    When a value of `None` is used for the format `datetime` objects will be returned by `to_representation` and the final output representation will be determined by the renderer class.

    #### auto_now and auto_now_add model fields.

    When using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any model fields with `auto_now=True` or `auto_now_add=True` will use serializer fields that are `read_only=True` by default.

    If you want to override this behavior, you'll need to declare the `DateTimeField` explicitly on the serializer. For example:

    ``` python
    class CommentSerializer(serializers.ModelSerializer):
        created = serializers.DateTimeField()

        class Meta:
            model = Comment
    ```
- name: DecimalField
  id: api-guide/fields/index#decimalfield
  summary: A decimal representation, represented in Python by a Decimal instance
  belongs_to: Serializer fields
  description: |-
    ## DecimalField

    A decimal representation, represented in Python by a `Decimal` instance.

    Corresponds to `django.db.models.fields.DecimalField`.

    **Signature**: `DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)`

    - `max_digits` The maximum number of digits allowed in the number. It must be either `None` or an integer greater than or equal to `decimal_places`.
    - `decimal_places` The number of decimal places to store with the number.
    - `coerce_to_string` Set to `True` if string values should be returned for the representation, or `False` if `Decimal` objects should be returned. Defaults to the same value as the `COERCE_DECIMAL_TO_STRING` settings key, which will be `True` unless overridden. If `Decimal` objects are returned by the serializer, then the final output format will be determined by the renderer. Note that setting `localize` will force the value to `True`.
    - `max_value` Validate that the number provided is no greater than this value.
    - `min_value` Validate that the number provided is no less than this value.
    - `localize` Set to `True` to enable localization of input and output based on the current locale. This will also force `coerce_to_string` to `True`. Defaults to `False`. Note that data formatting is enabled if you have set `USE_L10N=True` in your settings file.
    - `rounding` Sets the rounding mode used when quantizing to the configured precision. Valid values are [`decimal` module rounding modes](https://docs.python.org/3/library/decimal.html#rounding-modes). Defaults to `None`.
    - `normalize_output` Will normalize the decimal value when serialized. This will strip all trailing zeroes and change the value's precision to the minimum required precision to be able to represent the value without losing data. Defaults to `False`.

    #### Example usage

    To validate numbers up to 999 with a resolution of 2 decimal places, you would use:

    ``` python
    serializers.DecimalField(max_digits=5, decimal_places=2)
    ```

    And to validate numbers up to anything less than one billion with a resolution of 10 decimal places:

    ``` python
    serializers.DecimalField(max_digits=19, decimal_places=10)
    ```

    # Date and time fields
- name: DefaultRouter
  id: api-guide/routers/index#defaultrouter
  summary: This router is similar to SimpleRouter as above, but additionally includes a default API root view, that returns a response containing hyperlinks to all the list views
  belongs_to: Routers
  description: "## DefaultRouter\n\nThis router is similar to `SimpleRouter` as above, but additionally includes a default API root view, that returns a response containing hyperlinks to all the list views. It also generates routes for optional `.json` style format suffixes.\n\n|                                          |                                              |                                            |                       |\n|------------------------------------------|----------------------------------------------|--------------------------------------------|-----------------------|\n| URL Style                                | HTTP Method                                  | Action                                     | URL Name              |\n| \\[.format\\]                              | GET                                          | automatically generated root view          | api-root              |\n| {prefix}/\\[.format\\]                     | GET                                          | list                                       | {basename}-list       |\n|                                          | POST                                         | create                                     |                       |\n| {prefix}/{url_path}/\\[.format\\]          | GET, or as specified by \\`methods\\` argument | \\`@action(detail=False)\\` decorated method | {basename}-{url_name} |\n| {prefix}/{lookup}/\\[.format\\]            | GET                                          | retrieve                                   | {basename}-detail     |\n|                                          | PUT                                          | update                                     |                       |\n|                                          | PATCH                                        | partial_update                             |                       |\n|                                          | DELETE                                       | destroy                                    |                       |\n| {prefix}/{lookup}/{url_path}/\\[.format\\] | GET, or as specified by \\`methods\\` argument | \\`@action(detail=True)\\` decorated method  | {basename}-{url_name} |\n\nAs with `SimpleRouter` the trailing slashes on the URL routes can be removed by setting the `trailing_slash` argument to `False` when instantiating the router.\n\n``` python\nrouter = DefaultRouter(trailing_slash=False)\n```\n\n# Custom Routers\n\nImplementing a custom router isn't something you'd need to do very often, but it can be useful if you have specific requirements about how the URLs for your API are structured. Doing so allows you to encapsulate the URL structure in a reusable way that ensures you don't have to write your URL patterns explicitly for each new view.\n\nThe simplest way to implement a custom router is to subclass one of the existing router classes. The `.routes` attribute is used to template the URL patterns that will be mapped to each viewset. The `.routes` attribute is a list of `Route` named tuples.\n\nThe arguments to the `Route` named tuple are:\n\n**url**: A string representing the URL to be routed. May include the following format strings:\n\n- `{prefix}` - The URL prefix to use for this set of routes.\n- `{lookup}` - The lookup field used to match against a single instance.\n- `{trailing_slash}` - Either a '/' or an empty string, depending on the `trailing_slash` argument.\n\n**mapping**: A mapping of HTTP method names to the view methods\n\n**name**: The name of the URL as used in `reverse` calls. May include the following format string:\n\n- `{basename}` - The base to use for the URL names that are created.\n\n**initkwargs**: A dictionary of any additional arguments that should be passed when instantiating the view. Note that the `detail`, `basename`, and `suffix` arguments are reserved for viewset introspection and are also used by the browsable API to generate the view name and breadcrumb links.\n\n## Customizing dynamic routes\n\nYou can also customize how the `@action` decorator is routed. Include the `DynamicRoute` named tuple in the `.routes` list, setting the `detail` argument as appropriate for the list-based and detail-based routes. In addition to `detail`, the arguments to `DynamicRoute` are:\n\n**url**: A string representing the URL to be routed. May include the same format strings as `Route`, and additionally accepts the `{url_path}` format string.\n\n**name**: The name of the URL as used in `reverse` calls. May include the following format strings:\n\n- `{basename}` - The base to use for the URL names that are created.\n- `{url_name}` - The `url_name` provided to the `@action`.\n\n**initkwargs**: A dictionary of any additional arguments that should be passed when instantiating the view.\n\n## Example\n\nThe following example will only route to the `list` and `retrieve` actions, and does not use the trailing slash convention.\n\n``` python\nfrom rest_framework.routers import Route, DynamicRoute, SimpleRouter\n\nclass CustomReadOnlyRouter(SimpleRouter):\n    \"\"\"\n    A router for read-only APIs, which doesn't use trailing slashes.\n    \"\"\"\n    routes = [\n        Route(\n            url=r'^{prefix}$',\n            mapping={'get': 'list'},\n            name='{basename}-list',\n            detail=False,\n            initkwargs={'suffix': 'List'}\n        ),\n        Route(\n            url=r'^{prefix}/{lookup}$',\n            mapping={'get': 'retrieve'},\n            name='{basename}-detail',\n            detail=True,\n            initkwargs={'suffix': 'Detail'}\n        ),\n        DynamicRoute(\n            url=r'^{prefix}/{lookup}/{url_path}$',\n            name='{basename}-{url_name}',\n            detail=True,\n            initkwargs={}\n        )\n    ]\n```\n\nLet's take a look at the routes our `CustomReadOnlyRouter` would generate for a simple viewset.\n\n`views.py`:\n\n``` python\nclass UserViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    A viewset that provides the standard actions\n    \"\"\"\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    lookup_field = 'username'\n\n    @action(detail=True)\n    def group_names(self, request, pk=None):\n        \"\"\"\n        Returns a list of all the group names that the given\n        user belongs to.\n        \"\"\"\n        user = self.get_object()\n        groups = user.groups.all()\n        return Response([group.name for group in groups])\n```\n\n`urls.py`:\n\n``` python\nrouter = CustomReadOnlyRouter()\nrouter.register('users', UserViewSet)\nurlpatterns = router.urls\n```\n\nThe following mappings would be generated...\n\n|                               |             |             |                  |\n|-------------------------------|-------------|-------------|------------------|\n| URL                           | HTTP Method | Action      | URL Name         |\n| /users                        | GET         | list        | user-list        |\n| /users/{username}             | GET         | retrieve    | user-detail      |\n| /users/{username}/group_names | GET         | group_names | user-group-names |\n\nFor another example of setting the `.routes` attribute, see the source code for the `SimpleRouter` class.\n\n## Advanced custom routers\n\nIf you want to provide totally custom behavior, you can override `BaseRouter` and override the `get_urls(self)` method. The method should inspect the registered viewsets and return a list of URL patterns. The registered prefix, viewset and basename tuples may be inspected by accessing the `self.registry` attribute.\n\nYou may also want to override the `get_default_basename(self, viewset)` method, or else always explicitly set the `basename` argument when registering your viewsets with the router.\n\n# Third Party Packages\n\nThe following third party packages are also available.\n\n## DRF Nested Routers\n\nThe [drf-nested-routers package](https://github.com/alanjds/drf-nested-routers) provides routers and relationship fields for working with nested resources.\n\n## ModelRouter (wq.db.rest)\n\nThe [wq.db package](https://wq.io/wq.db) provides an advanced [ModelRouter](https://wq.io/docs/router) class (and singleton instance) that extends `DefaultRouter` with a `register_model()` API. Much like Django's `admin.site.register`, the only required argument to `rest.router.register_model` is a model class. Reasonable defaults for a url prefix, serializer, and viewset will be inferred from the model and global configuration.\n\n``` python\nfrom wq.db import rest\nfrom myapp.models import MyModel\n\nrest.router.register_model(MyModel)\n```\n\n## DRF-extensions\n\nThe [`DRF-extensions` package](https://chibisov.github.io/drf-extensions/docs/) provides [routers](https://chibisov.github.io/drf-extensions/docs/#routers) for creating [nested viewsets](https://chibisov.github.io/drf-extensions/docs/#nested-routes), [collection level controllers](https://chibisov.github.io/drf-extensions/docs/#collection-level-controllers) with [customizable endpoint names](https://chibisov.github.io/drf-extensions/docs/#controller-endpoint-name).\n\n[routers.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/routers.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/routers/](https://www.django-rest-framework.org/api-guide/routers/)"
- name: DestroyAPIView
  id: api-guide/generic-views/index#destroyapiview
  summary: Used for delete-only endpoints for a single model instance
  belongs_to: Generic views
  description: |-
    ## DestroyAPIView

    Used for **delete-only** endpoints for a **single model instance**.

    Provides a `delete` method handler.

    Extends: [GenericAPIView](#genericapiview), [DestroyModelMixin](#destroymodelmixin)
- name: DestroyModelMixin
  id: api-guide/generic-views/index#destroymodelmixin
  summary: Provides a .destroy(request, *args, **kwargs) method, that implements deletion of an existing model instance
  belongs_to: Generic views
  description: |-
    ## DestroyModelMixin

    Provides a `.destroy(request, *args, **kwargs)` method, that implements deletion of an existing model instance.

    If an object is deleted this returns a `204 No Content` response, otherwise it will return a `404 Not Found`.

    # Concrete View Classes

    The following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.

    The view classes can be imported from `rest_framework.generics`.
- name: DictField
  id: api-guide/fields/index#dictfield
  summary: A field class that validates a dictionary of objects
  belongs_to: Serializer fields
  description: |-
    ## DictField

    A field class that validates a dictionary of objects. The keys in `DictField` are always assumed to be string values.

    **Signature**: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`

    - `child` - A field instance that should be used for validating the values in the dictionary. If this argument is not provided then values in the mapping will not be validated.
    - `allow_empty` - Designates if empty dictionaries are allowed.

    For example, to create a field that validates a mapping of strings to strings, you would write something like this:

    ``` python
    document = DictField(child=CharField())
    ```

    You can also use the declarative style, as with `ListField`. For example:

    ``` python
    class DocumentField(DictField):
        child = CharField()
    ```
- name: DjangoFilterBackend
  id: api-guide/filtering/index#djangofilterbackend
  summary: The django-filter library includes a DjangoFilterBackend class which supports highly customizable field filtering for REST framework
  belongs_to: Filtering
  description: |-
    ## DjangoFilterBackend

    The [`django-filter`](https://django-filter.readthedocs.io/en/latest/index.html) library includes a `DjangoFilterBackend` class which supports highly customizable field filtering for REST framework.

    To use `DjangoFilterBackend`, first install `django-filter`.

    ``` python
    pip install django-filter
    ```

    Then add `'django_filters'` to Django's `INSTALLED_APPS`:

    ``` python
    INSTALLED_APPS = [
        ...
        'django_filters',
        ...
    ]
    ```

    You should now either add the filter backend to your settings:

    ``` python
    REST_FRAMEWORK = {
        'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']
    }
    ```

    Or add the filter backend to an individual View or ViewSet.

    ``` python
    from django_filters.rest_framework import DjangoFilterBackend

    class UserListView(generics.ListAPIView):
        ...
        filter_backends = [DjangoFilterBackend]
    ```

    If all you need is simple equality-based filtering, you can set a `filterset_fields` attribute on the view, or viewset, listing the set of fields you wish to filter against.

    ``` python
    class ProductList(generics.ListAPIView):
        queryset = Product.objects.all()
        serializer_class = ProductSerializer
        filter_backends = [DjangoFilterBackend]
        filterset_fields = ['category', 'in_stock']
    ```

    This will automatically create a `FilterSet` class for the given fields, and will allow you to make requests such as:

    ``` python
    http://example.com/api/products?category=clothing&in_stock=True
    ```

    For more advanced filtering requirements you can specify a `FilterSet` class that should be used by the view. You can read more about `FilterSet`s in the [django-filter documentation](https://django-filter.readthedocs.io/en/latest/index.html). It's also recommended that you read the section on [DRF integration](https://django-filter.readthedocs.io/en/latest/guide/rest_framework.html).
- name: DjangoModelPermissions
  id: api-guide/permissions/index#djangomodelpermissions
  summary: This permission class ties into Django's standard django.contrib.auth model permissions
  belongs_to: Permissions
  description: |-
    ## DjangoModelPermissions

    This permission class ties into Django's standard `django.contrib.auth` [model permissions](https://docs.djangoproject.com/en/stable/topics/auth/customizing/#custom-permissions). This permission must only be applied to views that have a `.queryset` property or `get_queryset()` method. Authorization will only be granted if the user *is authenticated* and has the *relevant model permissions* assigned. The appropriate model is determined by checking `get_queryset().model` or `queryset.model`.

    - `POST` requests require the user to have the `add` permission on the model.
    - `PUT` and `PATCH` requests require the user to have the `change` permission on the model.
    - `DELETE` requests require the user to have the `delete` permission on the model.

    The default behavior can also be overridden to support custom model permissions. For example, you might want to include a `view` model permission for `GET` requests.

    To use custom model permissions, override `DjangoModelPermissions` and set the `.perms_map` property. Refer to the source code for details.
- name: DjangoModelPermissionsOrAnonReadOnly
  id: api-guide/permissions/index#djangomodelpermissionsoranonreadonly
  summary: Similar to DjangoModelPermissions, but also allows unauthenticated users to have read-only access to the API
  belongs_to: Permissions
  description: |-
    ## DjangoModelPermissionsOrAnonReadOnly

    Similar to `DjangoModelPermissions`, but also allows unauthenticated users to have read-only access to the API.
- name: DjangoObjectPermissions
  id: api-guide/permissions/index#djangoobjectpermissions
  summary: This permission class ties into Django's standard object permissions framework that allows per-object permissions on models
  belongs_to: Permissions
  description: "## DjangoObjectPermissions\n\nThis permission class ties into Django's standard [object permissions framework](https://docs.djangoproject.com/en/stable/topics/auth/customizing/#handling-object-permissions) that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as [django-guardian](https://github.com/lukaszb/django-guardian).\n\nAs with `DjangoModelPermissions`, this permission must only be applied to views that have a `.queryset` property or `.get_queryset()` method. Authorization will only be granted if the user *is authenticated* and has the *relevant per-object permissions* and *relevant model permissions* assigned.\n\n- `POST` requests require the user to have the `add` permission on the model instance.\n- `PUT` and `PATCH` requests require the user to have the `change` permission on the model instance.\n- `DELETE` requests require the user to have the `delete` permission on the model instance.\n\nNote that `DjangoObjectPermissions` **does not** require the `django-guardian` package, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by overriding `DjangoObjectPermissions` and setting the `.perms_map` property. Refer to the source code for details.\n\n**Note**: If you need object level `view` permissions for `GET`, `HEAD` and `OPTIONS` requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the `DjangoObjectPermissionsFilter` class provided by the [`djangorestframework-guardian2` package](https://github.com/johnthagen/django-rest-framework-guardian2). It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.\n\n# Custom permissions\n\nTo implement a custom permission, override `BasePermission` and implement either, or both, of the following methods:\n\n- `.has_permission(self, request, view)`\n- `.has_object_permission(self, request, view, obj)`\n\nThe methods should return `True` if the request should be granted access, and `False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you should check the request method against the constant `SAFE_METHODS`, which is a tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\n``` python\nif request.method in permissions.SAFE_METHODS:\n    # Check permissions for read-only request\nelse:\n    # Check permissions for write request\n```\n\n**Note**: The instance-level `has_object_permission` method will only be called if the view-level `has_permission` checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call `.check_object_permissions(request, obj)`. If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising `PermissionDenied` on failure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test fails. To change the error message associated with the exception, implement a `message` attribute directly on your custom permission. Otherwise the `default_detail` attribute from `PermissionDenied` will be used. Similarly, to change the code identifier associated with the exception, implement a `code` attribute directly on your custom permission - otherwise the `default_code` attribute from `PermissionDenied` will be used.\n\n``` python\nfrom rest_framework import permissions\n\nclass CustomerAccessPermission(permissions.BasePermission):\n    message = 'Adding customers not allowed.'\n\n    def has_permission(self, request, view):\n         ...\n```\n\n## Examples\n\nThe following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.\n\n``` python\nfrom rest_framework import permissions\n\nclass BlocklistPermission(permissions.BasePermission):\n    \"\"\"\n    Global permission check for blocked IPs.\n    \"\"\"\n\n    def has_permission(self, request, view):\n        ip_addr = request.META['REMOTE_ADDR']\n        blocked = Blocklist.objects.filter(ip_addr=ip_addr).exists()\n        return not blocked\n```\n\nAs well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:\n\n``` python\nclass IsOwnerOrReadOnly(permissions.BasePermission):\n    \"\"\"\n    Object-level permission to only allow owners of an object to edit it.\n    Assumes the model instance has an `owner` attribute.\n    \"\"\"\n\n    def has_object_permission(self, request, view, obj):\n        # Read permissions are allowed to any request,\n        # so we'll always allow GET, HEAD or OPTIONS requests.\n        if request.method in permissions.SAFE_METHODS:\n            return True\n\n        # Instance must have an attribute named `owner`.\n        return obj.owner == request.user\n```\n\nNote that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling `self.check_object_permissions(request, obj)` from the view once you have the object instance. This call will raise an appropriate `APIException` if any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the [filtering documentation](../filtering/index) for more details.\n\n# Overview of access restriction methods\n\nREST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.\n\n- `queryset`/`get_queryset()`: Limits the general visibility of existing objects from the database. The queryset limits which objects will be listed and which objects can be modified or deleted. The `get_queryset()` method can apply different querysets based on the current action.\n- `permission_classes`/`get_permissions()`: General permission checks based on the current action, request and targeted object. Object level permissions can only be applied to retrieve, modify and deletion actions. Permission checks for list and create will be applied to the entire object type. (In case of list: subject to restrictions in the queryset.)\n- `serializer_class`/`get_serializer()`: Instance level restrictions that apply to all objects on input and output. The serializer may have access to the request context. The `get_serializer()` method can apply different serializers based on the current action.\n\nThe following table lists the access restriction methods and the level of control they offer over which actions.\n\n|                                   | `queryset` | `permission_classes` | `serializer_class` |\n|-----------------------------------|------------|----------------------|--------------------|\n| Action: list                      | global     | global               | object-level\\*     |\n| Action: create                    | no         | global               | object-level       |\n| Action: retrieve                  | global     | object-level         | object-level       |\n| Action: update                    | global     | object-level         | object-level       |\n| Action: partial_update            | global     | object-level         | object-level       |\n| Action: destroy                   | global     | object-level         | no                 |\n| Can reference action in decision  | no\\*\\*     | yes                  | no\\*\\*             |\n| Can reference request in decision | no\\*\\*     | yes                  | yes                |\n\n\\* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  \n\\*\\* The `get_*()` methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## DRF - Access Policy\n\nThe [Django REST - Access Policy](https://github.com/rsinger86/drf-access-policy) package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies.\n\n## Composed Permissions\n\nThe [Composed Permissions](https://github.com/niwibe/djangorestframework-composed-permissions) package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.\n\n## REST Condition\n\nThe [REST Condition](https://github.com/caxap/rest_condition) package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.\n\n## DRY Rest Permissions\n\nThe [DRY Rest Permissions](https://github.com/FJNR-inc/dry-rest-permissions) package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.\n\n## Django Rest Framework Roles\n\nThe [Django Rest Framework Roles](https://github.com/computer-lab/django-rest-framework-roles) package makes it easier to parameterize your API over multiple types of users.\n\n## Rest Framework Roles\n\nThe [Rest Framework Roles](https://github.com/Pithikos/rest-framework-roles) makes it super easy to protect views based on roles. Most importantly allows you to decouple accessibility logic from models and views in a clean human-readable way.\n\n## Django REST Framework API Key\n\nThe [Django REST Framework API Key](https://florimondmanca.github.io/djangorestframework-api-key/) package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. *machines*) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.\n\n## Django Rest Framework Role Filters\n\nThe [Django Rest Framework Role Filters](https://github.com/allisson/django-rest-framework-role-filters) package provides simple filtering over multiple types of roles.\n\n## Django Rest Framework PSQ\n\nThe [Django Rest Framework PSQ](https://github.com/drf-psq/drf-psq) package is an extension that gives support for having action-based **permission_classes**, **serializer_class**, and **queryset** dependent on permission-based rules.\n\n[permissions.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/permissions.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/permissions/](https://www.django-rest-framework.org/api-guide/permissions/)"
- name: DurationField
  id: api-guide/fields/index#durationfield
  summary: A Duration representation
  belongs_to: Serializer fields
  description: |-
    ## DurationField

    A Duration representation. Corresponds to `django.db.models.fields.DurationField`

    The `validated_data` for these fields will contain a `datetime.timedelta` instance. The representation is a string following this format `'[DD] [HH:[MM:]]ss[.uuuuuu]'`.

    **Signature:** `DurationField(max_value=None, min_value=None)`

    - `max_value` Validate that the duration provided is no greater than this value.
    - `min_value` Validate that the duration provided is no less than this value.

    # Choice selection fields
- name: EmailField
  id: api-guide/fields/index#emailfield
  summary: A text representation, validates the text to be a valid e-mail address
  belongs_to: Serializer fields
  description: |-
    ## EmailField

    A text representation, validates the text to be a valid e-mail address.

    Corresponds to `django.db.models.fields.EmailField`

    **Signature:** `EmailField(max_length=None, min_length=None, allow_blank=False)`
- name: Encodings
  id: api-guide/settings/index#encodings
  summary: When set to True, JSON responses will allow unicode characters in responses
  belongs_to: Settings
  description: |-
    ## Encodings

    #### UNICODE_JSON

    When set to `True`, JSON responses will allow unicode characters in responses. For example:

    ``` python
    {"unicode black star":"★"}
    ```

    When set to `False`, JSON responses will escape non-ascii characters, like so:

    ``` python
    {"unicode black star":"\u2605"}
    ```

    Both styles conform to [RFC 4627](https://www.ietf.org/rfc/rfc4627.txt), and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.

    Default: `True`

    #### COMPACT_JSON

    When set to `True`, JSON responses will return compact representations, with no spacing after `':'` and `','` characters. For example:

    ``` python
    {"is_admin":false,"email":"jane@example"}
    ```

    When set to `False`, JSON responses will return slightly more verbose representations, like so:

    ``` python
    {"is_admin": false, "email": "jane@example"}
    ```

    The default style is to return minified responses, in line with [Heroku's API design guidelines](https://github.com/interagent/http-api-design#keep-json-minified-in-all-responses).

    Default: `True`

    #### STRICT_JSON

    When set to `True`, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (`nan`, `inf`, `-inf`) accepted by Python's `json` module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's `JSON.Parse` nor PostgreSQL's JSON data type accept these values.

    When set to `False`, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.

    Default: `True`

    #### COERCE_DECIMAL_TO_STRING

    When returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.

    When set to `True`, the serializer `DecimalField` class will return strings instead of `Decimal` objects. When set to `False`, serializers will return `Decimal` objects, which the default JSON encoder will return as floats.

    Default: `True`
- name: Exceptions
  id: api-guide/exceptions/index
  summary: Exceptions… allow error handling to be organized cleanly in a central or high-level place within the program structure
  description: "# Exceptions\n\n> Exceptions… allow error handling to be organized cleanly in a central or high-level place within the program structure.\n>\n> — Doug Hellmann, [Python Exception Handling Techniques](https://doughellmann.com/blog/2009/06/19/python-exception-handling-techniques/)\n\n## Exception handling in REST framework views\n\nREST framework's views handle various exceptions, and deal with returning appropriate error responses.\n\nThe handled exceptions are:\n\n- Subclasses of `APIException` raised inside REST framework.\n- Django's `Http404` exception.\n- Django's `PermissionDenied` exception.\n\nIn each case, REST framework will return a response with an appropriate status code and content-type. The body of the response will include any additional details regarding the nature of the error.\n\nMost error responses will include a key `detail` in the body of the response.\n\nFor example, the following request:\n\n``` python\nDELETE http://api.example.com/foo/bar HTTP/1.1\nAccept: application/json\n```\n\nMight receive an error response indicating that the `DELETE` method is not allowed on that resource:\n\n``` python\nHTTP/1.1 405 Method Not Allowed\nContent-Type: application/json\nContent-Length: 42\n\n{\"detail\": \"Method 'DELETE' not allowed.\"}\n```\n\nValidation errors are handled slightly differently, and will include the field names as the keys in the response. If the validation error was not specific to a particular field then it will use the \"non_field_errors\" key, or whatever string value has been set for the `NON_FIELD_ERRORS_KEY` setting.\n\nAn example validation error might look like this:\n\n``` python\nHTTP/1.1 400 Bad Request\nContent-Type: application/json\nContent-Length: 94\n\n{\"amount\": [\"A valid integer is required.\"], \"description\": [\"This field may not be blank.\"]}\n```\n\n## Custom exception handling\n\nYou can implement custom exception handling by creating a handler function that converts exceptions raised in your API views into response objects. This allows you to control the style of error responses used by your API.\n\nThe function must take a pair of arguments, the first is the exception to be handled, and the second is a dictionary containing any extra context such as the view currently being handled. The exception handler function should either return a `Response` object, or return `None` if the exception cannot be handled. If the handler returns `None` then the exception will be re-raised and Django will return a standard HTTP 500 'server error' response.\n\nFor example, you might want to ensure that all error responses include the HTTP status code in the body of the response, like so:\n\n``` python\nHTTP/1.1 405 Method Not Allowed\nContent-Type: application/json\nContent-Length: 62\n\n{\"status_code\": 405, \"detail\": \"Method 'DELETE' not allowed.\"}\n```\n\nIn order to alter the style of the response, you could write the following custom exception handler:\n\n``` python\nfrom rest_framework.views import exception_handler\n\ndef custom_exception_handler(exc, context):\n    # Call REST framework's default exception handler first,\n    # to get the standard error response.\n    response = exception_handler(exc, context)\n\n    # Now add the HTTP status code to the response.\n    if response is not None:\n        response.data['status_code'] = response.status_code\n\n    return response\n```\n\nThe context argument is not used by the default handler, but can be useful if the exception handler needs further information such as the view currently being handled, which can be accessed as `context['view']`.\n\nThe exception handler must also be configured in your settings, using the `EXCEPTION_HANDLER` setting key. For example:\n\n``` python\nREST_FRAMEWORK = {\n    'EXCEPTION_HANDLER': 'my_project.my_app.utils.custom_exception_handler'\n}\n```\n\nIf not specified, the `'EXCEPTION_HANDLER'` setting defaults to the standard exception handler provided by REST framework:\n\n``` python\nREST_FRAMEWORK = {\n    'EXCEPTION_HANDLER': 'rest_framework.views.exception_handler'\n}\n```\n\nNote that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the `HTTP_400_BAD_REQUEST` responses that are returned by the generic views when serializer validation fails.\n\n# API Reference\n\n## APIException\n\n**Signature:** `APIException()`\n\nThe **base class** for all exceptions raised inside an `APIView` class or `@api_view`.\n\nTo provide a custom exception, subclass `APIException` and set the `.status_code`, `.default_detail`, and `.default_code` attributes on the class.\n\nFor example, if your API relies on a third party service that may sometimes be unreachable, you might want to implement an exception for the \"503 Service Unavailable\" HTTP response code. You could do this like so:\n\n``` python\nfrom rest_framework.exceptions import APIException\n\nclass ServiceUnavailable(APIException):\n    status_code = 503\n    default_detail = 'Service temporarily unavailable, try again later.'\n    default_code = 'service_unavailable'\n```\n\n#### Inspecting API exceptions\n\nThere are a number of different properties available for inspecting the status of an API exception. You can use these to build custom exception handling for your project.\n\nThe available attributes and methods are:\n\n- `.detail` - Return the textual description of the error.\n- `.get_codes()` - Return the code identifier of the error.\n- `.get_full_details()` - Return both the textual description and the code identifier.\n\nIn most cases the error detail will be a simple item:\n\n``` python\n>>> print(exc.detail)\nYou do not have permission to perform this action.\n>>> print(exc.get_codes())\npermission_denied\n>>> print(exc.get_full_details())\n{'message':'You do not have permission to perform this action.','code':'permission_denied'}\n```\n\nIn the case of validation errors the error detail will be either a list or dictionary of items:\n\n``` python\n>>> print(exc.detail)\n{\"name\":\"This field is required.\",\"age\":\"A valid integer is required.\"}\n>>> print(exc.get_codes())\n{\"name\":\"required\",\"age\":\"invalid\"}\n>>> print(exc.get_full_details())\n{\"name\":{\"message\":\"This field is required.\",\"code\":\"required\"},\"age\":{\"message\":\"A valid integer is required.\",\"code\":\"invalid\"}}\n```\n\n## ParseError\n\n**Signature:** `ParseError(detail=None, code=None)`\n\nRaised if the request contains malformed data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"400 Bad Request\".\n\n## AuthenticationFailed\n\n**Signature:** `AuthenticationFailed(detail=None, code=None)`\n\nRaised when an incoming request includes incorrect authentication.\n\nBy default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the [authentication documentation](../authentication/index) for more details.\n\n## NotAuthenticated\n\n**Signature:** `NotAuthenticated(detail=None, code=None)`\n\nRaised when an unauthenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"401 Unauthenticated\", but it may also result in a \"403 Forbidden\" response, depending on the authentication scheme in use. See the [authentication documentation](../authentication/index) for more details.\n\n## PermissionDenied\n\n**Signature:** `PermissionDenied(detail=None, code=None)`\n\nRaised when an authenticated request fails the permission checks.\n\nBy default this exception results in a response with the HTTP status code \"403 Forbidden\".\n\n## NotFound\n\n**Signature:** `NotFound(detail=None, code=None)`\n\nRaised when a resource does not exist at the given URL. This exception is equivalent to the standard `Http404` Django exception.\n\nBy default this exception results in a response with the HTTP status code \"404 Not Found\".\n\n## MethodNotAllowed\n\n**Signature:** `MethodNotAllowed(method, detail=None, code=None)`\n\nRaised when an incoming request occurs that does not map to a handler method on the view.\n\nBy default this exception results in a response with the HTTP status code \"405 Method Not Allowed\".\n\n## NotAcceptable\n\n**Signature:** `NotAcceptable(detail=None, code=None)`\n\nRaised when an incoming request occurs with an `Accept` header that cannot be satisfied by any of the available renderers.\n\nBy default this exception results in a response with the HTTP status code \"406 Not Acceptable\".\n\n## UnsupportedMediaType\n\n**Signature:** `UnsupportedMediaType(media_type, detail=None, code=None)`\n\nRaised if there are no parsers that can handle the content type of the request data when accessing `request.data`.\n\nBy default this exception results in a response with the HTTP status code \"415 Unsupported Media Type\".\n\n## Throttled\n\n**Signature:** `Throttled(wait=None, detail=None, code=None)`\n\nRaised when an incoming request fails the throttling checks.\n\nBy default this exception results in a response with the HTTP status code \"429 Too Many Requests\".\n\n## ValidationError\n\n**Signature:** `ValidationError(detail=None, code=None)`\n\nThe `ValidationError` exception is slightly different from the other `APIException` classes:\n\n- The `detail` argument may be a list or dictionary of error details, and may also be a nested data structure. By using a dictionary, you can specify field-level errors while performing object-level validation in the `validate()` method of a serializer. For example. `raise serializers.ValidationError({'name': 'Please enter a valid name.'})`\n- By convention you should import the serializers module and use a fully qualified `ValidationError` style, in order to differentiate it from Django's built-in validation error. For example. `raise serializers.ValidationError('This field must be an integer value.')`\n\nThe `ValidationError` class should be used for serializer and field validation, and by validator classes. It is also raised when calling `serializer.is_valid` with the `raise_exception` keyword argument:\n\n``` python\nserializer.is_valid(raise_exception=True)\n```\n\nThe generic views use the `raise_exception=True` flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400 Bad Request\".\n\n# Generic Error Views\n\nDjango REST Framework provides two error views suitable for providing generic JSON `500` Server Error and `400` Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)\n\nUse these as per [Django's Customizing error views documentation](https://docs.djangoproject.com/en/dev/topics/http/views/#customizing-error-views).\n\n## rest_framework.exceptions.server_error\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\n``` python\nhandler500 = 'rest_framework.exceptions.server_error'\n```\n\n## rest_framework.exceptions.bad_request\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\n``` python\nhandler400 = 'rest_framework.exceptions.bad_request'\n```\n\n# Third party packages\n\nThe following third-party packages are also available.\n\n## DRF Standardized Errors\n\nThe [drf-standardized-errors](https://github.com/ghazi-git/drf-standardized-errors) package provides an exception handler that generates the same format for all 4xx and 5xx responses. It is a drop-in replacement for the default exception handler and allows customizing the error response format without rewriting the whole exception handler. The standardized error response format is easier to document and easier to handle by API consumers.\n\n[exceptions.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/exceptions.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/exceptions/](https://www.django-rest-framework.org/api-guide/exceptions/)"
- name: FileField
  id: api-guide/fields/index#filefield
  summary: A file representation
  belongs_to: Serializer fields
  description: |-
    ## FileField

    A file representation. Performs Django's standard FileField validation.

    Corresponds to `django.forms.fields.FileField`.

    **Signature:** `FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)`

    - `max_length` - Designates the maximum length for the file name.
    - `allow_empty_file` - Designates if empty files are allowed.
    - `use_url` - If set to `True` then URL string values will be used for the output representation. If set to `False` then filename string values will be used for the output representation. Defaults to the value of the `UPLOADED_FILES_USE_URL` settings key, which is `True` unless set otherwise.

    &nbsp;
- name: FilePathField
  id: api-guide/fields/index#filepathfield
  summary: Corresponds to django.forms.fields.FilePathField
  belongs_to: Serializer fields
  description: |-
    ## FilePathField

    A field whose choices are limited to the filenames in a certain directory on the filesystem

    Corresponds to `django.forms.fields.FilePathField`.

    **Signature:** `FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)`

    - `path` - The absolute filesystem path to a directory from which this FilePathField should get its choice.
    - `match` - A regular expression, as a string, that FilePathField will use to filter filenames.
    - `recursive` - Specifies whether all subdirectories of path should be included. Default is `False`.
    - `allow_files` - Specifies whether files in the specified location should be included. Default is `True`. Either this or `allow_folders` must be `True`.
    - `allow_folders` - Specifies whether folders in the specified location should be included. Default is `False`. Either this or `allow_files` must be `True`.

    &nbsp;
- name: FileUploadParser
  id: api-guide/parsers/index#fileuploadparser
  summary: Parses raw file upload content
  belongs_to: Parsers
  description: "## FileUploadParser\n\nParses raw file upload content. The `request.data` property will be a dictionary with a single key `'file'` containing the uploaded file.\n\nIf the view used with `FileUploadParser` is called with a `filename` URL keyword argument, then that argument will be used as the filename.\n\nIf it is called without a `filename` URL keyword argument, then the client must set the filename in the `Content-Disposition` HTTP header. For example `Content-Disposition: attachment; filename=upload.jpg`.\n\n**.media_type**: `*/*`\n\n##### Notes:\n\n- The `FileUploadParser` is for usage with native clients that can upload the file as a raw data request. For web-based uploads, or for native clients with multipart upload support, you should use the `MultiPartParser` instead.\n- Since this parser's `media_type` matches any content type, `FileUploadParser` should generally be the only parser set on an API view.\n- `FileUploadParser` respects Django's standard `FILE_UPLOAD_HANDLERS` setting, and the `request.upload_handlers` attribute. See the [Django documentation](https://docs.djangoproject.com/en/stable/topics/http/file-uploads/#upload-handlers) for more details.\n\n##### Basic usage example:\n\n``` python\n# views.py\nclass FileUploadView(views.APIView):\n    parser_classes = [FileUploadParser]\n\n    def put(self, request, filename, format=None):\n        file_obj = request.data['file']\n        # ...\n        # do some stuff with uploaded file\n        # ...\n        return Response(status=204)\n\n# urls.py\nurlpatterns = [\n    # ...\n    re_path(r'^upload/(?P<filename>[^/]+)$', FileUploadView.as_view())\n]\n```\n\n# Custom parsers\n\nTo implement a custom parser, you should override `BaseParser`, set the `.media_type` property, and implement the `.parse(self, stream, media_type, parser_context)` method.\n\nThe method should return the data that will be used to populate the `request.data` property.\n\nThe arguments passed to `.parse()` are:\n\n### stream\n\nA stream-like object representing the body of the request.\n\n### media_type\n\nOptional. If provided, this is the media type of the incoming request content.\n\nDepending on the request's `Content-Type:` header, this may be more specific than the renderer's `media_type` attribute, and may include media type parameters. For example `\"text/plain; charset=utf-8\"`.\n\n### parser_context\n\nOptional. If supplied, this argument will be a dictionary containing any additional context that may be required to parse the request content.\n\nBy default this will include the following keys: `view`, `request`, `args`, `kwargs`.\n\n## Example\n\nThe following is an example plaintext parser that will populate the `request.data` property with a string representing the body of the request.\n\n``` python\nclass PlainTextParser(BaseParser):\n    \"\"\"\n    Plain text parser.\n    \"\"\"\n    media_type = 'text/plain'\n\n    def parse(self, stream, media_type=None, parser_context=None):\n        \"\"\"\n        Simply return a string representing the body of the request.\n        \"\"\"\n        return stream.read()\n```\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## YAML\n\n[REST framework YAML](https://jpadilla.github.io/django-rest-framework-yaml/) provides [YAML](http://www.yaml.org/) parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-yaml\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework_yaml.parsers.YAMLParser',\n    ],\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_yaml.renderers.YAMLRenderer',\n    ],\n}\n```\n\n## XML\n\n[REST Framework XML](https://jpadilla.github.io/django-rest-framework-xml/) provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-xml\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework_xml.parsers.XMLParser',\n    ],\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_xml.renderers.XMLRenderer',\n    ],\n}\n```\n\n## MessagePack\n\n[MessagePack](https://github.com/juanriaza/django-rest-framework-msgpack) is a fast, efficient binary serialization format. [Juan Riaza](https://github.com/juanriaza) maintains the [djangorestframework-msgpack](https://github.com/juanriaza/django-rest-framework-msgpack) package which provides MessagePack renderer and parser support for REST framework.\n\n## CamelCase JSON\n\n[djangorestframework-camel-case](https://github.com/vbabiy/djangorestframework-camel-case) provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by [Vitaly Babiy](https://github.com/vbabiy).\n\n[parsers.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/parsers.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/parsers/](https://www.django-rest-framework.org/api-guide/parsers/)"
- name: Filtering
  id: api-guide/filtering/index
  summary: The root QuerySet provided by the Manager describes all objects in the database table
  description: "# Filtering\n\n> The root QuerySet provided by the Manager describes all objects in the database table. Usually, though, you'll need to select only a subset of the complete set of objects.\n>\n> — [Django documentation](https://docs.djangoproject.com/en/stable/topics/db/queries/#retrieving-specific-objects-with-filters)\n\nThe default behavior of REST framework's generic list views is to return the entire queryset for a model manager. Often you will want your API to restrict the items that are returned by the queryset.\n\nThe simplest way to filter the queryset of any view that subclasses `GenericAPIView` is to override the `.get_queryset()` method.\n\nOverriding this method allows you to customize the queryset returned by the view in a number of different ways.\n\n## Filtering against the current user\n\nYou might want to filter the queryset to ensure that only results relevant to the currently authenticated user making the request are returned.\n\nYou can do so by filtering based on the value of `request.user`.\n\nFor example:\n\n``` python\nfrom myapp.models import Purchase\nfrom myapp.serializers import PurchaseSerializer\nfrom rest_framework import generics\n\nclass PurchaseList(generics.ListAPIView):\n    serializer_class = PurchaseSerializer\n\n    def get_queryset(self):\n        \"\"\"\n        This view should return a list of all the purchases\n        for the currently authenticated user.\n        \"\"\"\n        user = self.request.user\n        return Purchase.objects.filter(purchaser=user)\n```\n\n## Filtering against the URL\n\nAnother style of filtering might involve restricting the queryset based on some part of the URL.\n\nFor example if your URL config contained an entry like this:\n\n``` python\nre_path('^purchases/(?P<username>.+)/$', PurchaseList.as_view()),\n```\n\nYou could then write a view that returned a purchase queryset filtered by the username portion of the URL:\n\n``` python\nclass PurchaseList(generics.ListAPIView):\n    serializer_class = PurchaseSerializer\n\n    def get_queryset(self):\n        \"\"\"\n        This view should return a list of all the purchases for\n        the user as determined by the username portion of the URL.\n        \"\"\"\n        username = self.kwargs['username']\n        return Purchase.objects.filter(purchaser__username=username)\n```\n\n## Filtering against query parameters\n\nA final example of filtering the initial queryset would be to determine the initial queryset based on query parameters in the url.\n\nWe can override `.get_queryset()` to deal with URLs such as `http://example.com/api/purchases?username=denvercoder9`, and filter the queryset only if the `username` parameter is included in the URL:\n\n``` python\nclass PurchaseList(generics.ListAPIView):\n    serializer_class = PurchaseSerializer\n\n    def get_queryset(self):\n        \"\"\"\n        Optionally restricts the returned purchases to a given user,\n        by filtering against a `username` query parameter in the URL.\n        \"\"\"\n        queryset = Purchase.objects.all()\n        username = self.request.query_params.get('username')\n        if username is not None:\n            queryset = queryset.filter(purchaser__username=username)\n        return queryset\n```\n\n# Generic Filtering\n\nAs well as being able to override the default queryset, REST framework also includes support for generic filtering backends that allow you to easily construct complex searches and filters.\n\nGeneric filters can also present themselves as HTML controls in the browsable API and admin API.\n\n## Setting filter backends\n\nThe default filter backends may be set globally, using the `DEFAULT_FILTER_BACKENDS` setting. For example.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']\n}\n```\n\nYou can also set the filter backends on a per-view, or per-viewset basis, using the `GenericAPIView` class-based views.\n\n``` python\nimport django_filters.rest_framework\nfrom django.contrib.auth.models import User\nfrom myapp.serializers import UserSerializer\nfrom rest_framework import generics\n\nclass UserListView(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    filter_backends = [django_filters.rest_framework.DjangoFilterBackend]\n```\n\n## Filtering and object lookups\n\nNote that if a filter backend is configured for a view, then as well as being used to filter list views, it will also be used to filter the querysets used for returning a single object.\n\nFor instance, given the previous example, and a product with an id of `4675`, the following URL would either return the corresponding object, or return a 404 response, depending on if the filtering conditions were met by the given product instance:\n\n``` python\nhttp://example.com/api/products/4675/?category=clothing&max_price=10.00\n```\n\n## Overriding the initial queryset\n\nNote that you can use both an overridden `.get_queryset()` and generic filtering together, and everything will work as expected. For example, if `Product` had a many-to-many relationship with `User`, named `purchase`, you might want to write a view like this:\n\n``` python\nclass PurchasedProductsList(generics.ListAPIView):\n    \"\"\"\n    Return a list of all the products that the authenticated\n    user has ever purchased, with optional filtering.\n    \"\"\"\n    model = Product\n    serializer_class = ProductSerializer\n    filterset_class = ProductFilter\n\n    def get_queryset(self):\n        user = self.request.user\n        return user.purchase_set.all()\n```\n\n# API Guide\n\n## DjangoFilterBackend\n\nThe [`django-filter`](https://django-filter.readthedocs.io/en/latest/index.html) library includes a `DjangoFilterBackend` class which supports highly customizable field filtering for REST framework.\n\nTo use `DjangoFilterBackend`, first install `django-filter`.\n\n``` python\npip install django-filter\n```\n\nThen add `'django_filters'` to Django's `INSTALLED_APPS`:\n\n``` python\nINSTALLED_APPS = [\n    ...\n    'django_filters',\n    ...\n]\n```\n\nYou should now either add the filter backend to your settings:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend']\n}\n```\n\nOr add the filter backend to an individual View or ViewSet.\n\n``` python\nfrom django_filters.rest_framework import DjangoFilterBackend\n\nclass UserListView(generics.ListAPIView):\n    ...\n    filter_backends = [DjangoFilterBackend]\n```\n\nIf all you need is simple equality-based filtering, you can set a `filterset_fields` attribute on the view, or viewset, listing the set of fields you wish to filter against.\n\n``` python\nclass ProductList(generics.ListAPIView):\n    queryset = Product.objects.all()\n    serializer_class = ProductSerializer\n    filter_backends = [DjangoFilterBackend]\n    filterset_fields = ['category', 'in_stock']\n```\n\nThis will automatically create a `FilterSet` class for the given fields, and will allow you to make requests such as:\n\n``` python\nhttp://example.com/api/products?category=clothing&in_stock=True\n```\n\nFor more advanced filtering requirements you can specify a `FilterSet` class that should be used by the view. You can read more about `FilterSet`s in the [django-filter documentation](https://django-filter.readthedocs.io/en/latest/index.html). It's also recommended that you read the section on [DRF integration](https://django-filter.readthedocs.io/en/latest/guide/rest_framework.html).\n\n## SearchFilter\n\nThe `SearchFilter` class supports simple single query parameter based searching, and is based on the [Django admin's search functionality](https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields).\n\nWhen in use, the browsable API will include a `SearchFilter` control:\n\nThe `SearchFilter` class will only be applied if the view has a `search_fields` attribute set. The `search_fields` attribute should be a list of names of text type fields on the model, such as `CharField` or `TextField`.\n\n``` python\nfrom rest_framework import filters\n\nclass UserListView(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    filter_backends = [filters.SearchFilter]\n    search_fields = ['username', 'email']\n```\n\nThis will allow the client to filter the items in the list by making queries such as:\n\n``` python\nhttp://example.com/api/users?search=russell\n```\n\nYou can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation:\n\n``` python\nsearch_fields = ['username', 'email', 'profile__profession']\n```\n\nFor [JSONField](https://docs.djangoproject.com/en/3.0/ref/contrib/postgres/fields/#jsonfield) and [HStoreField](https://docs.djangoproject.com/en/3.0/ref/contrib/postgres/fields/#hstorefield) fields you can filter based on nested values within the data structure using the same double-underscore notation:\n\n``` python\nsearch_fields = ['data__breed', 'data__owner__other_pets__0__name']\n```\n\nBy default, searches will use case-insensitive partial matches. The search parameter may contain multiple search terms, which should be whitespace and/or comma separated. If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched. Searches may contain *quoted phrases* with spaces, each phrase is considered as a single search term.\n\nThe search behavior may be specified by prefixing field names in `search_fields` with one of the following characters (which is equivalent to adding `__<lookup>` to the field):\n\n| Prefix | Lookup        |                                                                                                                                                   |\n|--------|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------|\n| `^`    | `istartswith` | Starts-with search.                                                                                                                               |\n| `=`    | `iexact`      | Exact matches.                                                                                                                                    |\n| `$`    | `iregex`      | Regex search.                                                                                                                                     |\n| `@`    | `search`      | Full-text search (Currently only supported Django's [PostgreSQL backend](https://docs.djangoproject.com/en/stable/ref/contrib/postgres/search/)). |\n| None   | `icontains`   | Contains search (Default).                                                                                                                        |\n\nFor example:\n\n``` python\nsearch_fields = ['=username', '=email']\n```\n\nBy default, the search parameter is named `'search'`, but this may be overridden with the `SEARCH_PARAM` setting.\n\nTo dynamically change search fields based on request content, it's possible to subclass the `SearchFilter` and override the `get_search_fields()` function. For example, the following subclass will only search on `title` if the query parameter `title_only` is in the request:\n\n``` python\nfrom rest_framework import filters\n\nclass CustomSearchFilter(filters.SearchFilter):\n    def get_search_fields(self, view, request):\n        if request.query_params.get('title_only'):\n            return ['title']\n        return super().get_search_fields(view, request)\n```\n\nFor more details, see the [Django documentation](https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields).\n\n## OrderingFilter\n\nThe `OrderingFilter` class supports simple query parameter controlled ordering of results.\n\nBy default, the query parameter is named `'ordering'`, but this may be overridden with the `ORDERING_PARAM` setting.\n\nFor example, to order users by username:\n\n``` python\nhttp://example.com/api/users?ordering=username\n```\n\nThe client may also specify reverse orderings by prefixing the field name with '-', like so:\n\n``` python\nhttp://example.com/api/users?ordering=-username\n```\n\nMultiple orderings may also be specified:\n\n``` python\nhttp://example.com/api/users?ordering=account,username\n```\n\n### Specifying which fields may be ordered against\n\nIt's recommended that you explicitly specify which fields the API should allow in the ordering filter. You can do this by setting an `ordering_fields` attribute on the view, like so:\n\n``` python\nclass UserListView(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    filter_backends = [filters.OrderingFilter]\n    ordering_fields = ['username', 'email']\n```\n\nThis helps prevent unexpected data leakage, such as allowing users to order against a password hash field or other sensitive data.\n\nIf you *don't* specify an `ordering_fields` attribute on the view, the filter class will default to allowing the user to filter on any readable fields on the serializer specified by the `serializer_class` attribute.\n\nIf you are confident that the queryset being used by the view doesn't contain any sensitive data, you can also explicitly specify that a view should allow ordering on *any* model field or queryset aggregate, by using the special value `'__all__'`.\n\n``` python\nclass BookingsListView(generics.ListAPIView):\n    queryset = Booking.objects.all()\n    serializer_class = BookingSerializer\n    filter_backends = [filters.OrderingFilter]\n    ordering_fields = '__all__'\n```\n\n### Specifying a default ordering\n\nIf an `ordering` attribute is set on the view, this will be used as the default ordering.\n\nTypically you'd instead control this by setting `order_by` on the initial queryset, but using the `ordering` parameter on the view allows you to specify the ordering in a way that it can then be passed automatically as context to a rendered template. This makes it possible to automatically render column headers differently if they are being used to order the results.\n\n``` python\nclass UserListView(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    filter_backends = [filters.OrderingFilter]\n    ordering_fields = ['username', 'email']\n    ordering = ['username']\n```\n\nThe `ordering` attribute may be either a string or a list/tuple of strings.\n\n# Custom generic filtering\n\nYou can also provide your own generic filtering backend, or write an installable app for other developers to use.\n\nTo do so override `BaseFilterBackend`, and override the `.filter_queryset(self, request, queryset, view)` method. The method should return a new, filtered queryset.\n\nAs well as allowing clients to perform searches and filtering, generic filter backends can be useful for restricting which objects should be visible to any given request or user.\n\n## Example\n\nFor example, you might need to restrict users to only being able to see objects they created.\n\n``` python\nclass IsOwnerFilterBackend(filters.BaseFilterBackend):\n    \"\"\"\n    Filter that only allows users to see their own objects.\n    \"\"\"\n    def filter_queryset(self, request, queryset, view):\n        return queryset.filter(owner=request.user)\n```\n\nWe could achieve the same behavior by overriding `get_queryset()` on the views, but using a filter backend allows you to more easily add this restriction to multiple views, or to apply it across the entire API.\n\n## Customizing the interface\n\nGeneric filters may also present an interface in the browsable API. To do so you should implement a `to_html()` method which returns a rendered HTML representation of the filter. This method should have the following signature:\n\n`to_html(self, request, queryset, view)`\n\nThe method should return a rendered HTML string.\n\n# Third party packages\n\nThe following third party packages provide additional filter implementations.\n\n## Django REST framework filters package\n\nThe [django-rest-framework-filters package](https://github.com/philipn/django-rest-framework-filters) works together with the `DjangoFilterBackend` class, and allows you to easily create filters across relationships, or create multiple filter lookup types for a given field.\n\n## Django REST framework full word search filter\n\nThe [djangorestframework-word-filter](https://github.com/trollknurr/django-rest-framework-word-search-filter) developed as alternative to `filters.SearchFilter` which will search full word in text, or exact match.\n\n## Django URL Filter\n\n[django-url-filter](https://github.com/miki725/django-url-filter) provides a safe way to filter data via human-friendly URLs. It works very similar to DRF serializers and fields in a sense that they can be nested except they are called filtersets and filters. That provides easy way to filter related data. Also this library is generic-purpose so it can be used to filter other sources of data and not only Django `QuerySet`s.\n\n## drf-url-filters\n\n[drf-url-filter](https://github.com/manjitkumar/drf-url-filters) is a simple Django app to apply filters on drf `ModelViewSet`'s `Queryset` in a clean, simple and configurable way. It also supports validations on incoming query params and their values. A beautiful python package `Voluptuous` is being used for validations on the incoming query parameters. The best part about voluptuous is you can define your own validations as per your query params requirements.\n\n[filters.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/filters.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/filtering/](https://www.django-rest-framework.org/api-guide/filtering/)"
- name: FloatField
  id: api-guide/fields/index#floatfield
  summary: A floating point representation
  belongs_to: Serializer fields
  description: |-
    ## FloatField

    A floating point representation.

    Corresponds to `django.db.models.fields.FloatField`.

    **Signature**: `FloatField(max_value=None, min_value=None)`

    - `max_value` Validate that the number provided is no greater than this value.
    - `min_value` Validate that the number provided is no less than this value.

    &nbsp;
- name: Format suffixes
  id: api-guide/format-suffixes/index
  summary: Section 6.2.1 does not say that content negotiation should be used all the time
  description: "# Format suffixes\n\n> Section 6.2.1 does not say that content negotiation should be used all the time.\n>\n> — Roy Fielding, [REST discuss mailing list](http://tech.groups.yahoo.com/group/rest-discuss/message/5857)\n\nA common pattern for Web APIs is to use filename extensions on URLs to provide an endpoint for a given media type. For example, 'http://example.com/api/users.json' to serve a JSON representation.\n\nAdding format-suffix patterns to each individual entry in the URLconf for your API is error-prone and non-DRY, so REST framework provides a shortcut to adding these patterns to your URLConf.\n\n## format_suffix_patterns\n\n**Signature**: format_suffix_patterns(urlpatterns, suffix_required=False, allowed=None)\n\nReturns a URL pattern list which includes format suffix patterns appended to each of the URL patterns provided.\n\nArguments:\n\n- **urlpatterns**: Required. A URL pattern list.\n- **suffix_required**: Optional. A boolean indicating if suffixes in the URLs should be optional or mandatory. Defaults to `False`, meaning that suffixes are optional by default.\n- **allowed**: Optional. A list or tuple of valid format suffixes. If not provided, a wildcard format suffix pattern will be used.\n\nExample:\n\n``` python\nfrom rest_framework.urlpatterns import format_suffix_patterns\nfrom blog import views\n\nurlpatterns = [\n    path('', views.apt_root),\n    path('comments/', views.comment_list),\n    path('comments/<int:pk>/', views.comment_detail)\n]\n\nurlpatterns = format_suffix_patterns(urlpatterns, allowed=['json', 'html'])\n```\n\nWhen using `format_suffix_patterns`, you must make sure to add the `'format'` keyword argument to the corresponding views. For example:\n\n``` python\n@api_view(['GET', 'POST'])\ndef comment_list(request, format=None):\n    # do stuff...\n```\n\nOr with class-based views:\n\n``` python\nclass CommentList(APIView):\n    def get(self, request, format=None):\n        # do stuff...\n\n    def post(self, request, format=None):\n        # do stuff...\n```\n\nThe name of the kwarg used may be modified by using the `FORMAT_SUFFIX_KWARG` setting.\n\nAlso note that `format_suffix_patterns` does not support descending into `include` URL patterns.\n\n### Using with i18n_patterns\n\nIf using the `i18n_patterns` function provided by Django, as well as `format_suffix_patterns` you should make sure that the `i18n_patterns` function is applied as the final, or outermost function. For example:\n\n``` python\nurlpatterns = [\n    …\n]\n\nurlpatterns = i18n_patterns(\n    format_suffix_patterns(urlpatterns, allowed=['json', 'html'])\n)\n```\n\n## Query parameter formats\n\nAn alternative to the format suffixes is to include the requested format in a query parameter. REST framework provides this option by default, and it is used in the browsable API to switch between differing available representations.\n\nTo select a representation using its short format, use the `format` query parameter. For example: `http://example.com/organizations/?format=csv`.\n\nThe name of this query parameter can be modified using the `URL_FORMAT_OVERRIDE` setting. Set the value to `None` to disable this behavior.\n\n## Accept headers vs. format suffixes\n\nThere seems to be a view among some of the Web community that filename extensions are not a RESTful pattern, and that `HTTP Accept` headers should always be used instead.\n\nIt is actually a misconception. For example, take the following quote from Roy Fielding discussing the relative merits of query parameter media-type indicators vs. file extension media-type indicators:\n\n“That's why I always prefer extensions. Neither choice has anything to do with REST.” — Roy Fielding, [REST discuss mailing list](https://groups.yahoo.com/neo/groups/rest-discuss/conversations/topics/14844)\n\nThe quote does not mention Accept headers, but it does make it clear that format suffixes should be considered an acceptable pattern.\n\n[urlpatterns.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/urlpatterns.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/format-suffixes/](https://www.django-rest-framework.org/api-guide/format-suffixes/)"
- name: FormParser
  id: api-guide/parsers/index#formparser
  summary: Parses HTML form content
  belongs_to: Parsers
  description: |-
    ## FormParser

    Parses HTML form content. `request.data` will be populated with a `QueryDict` of data.

    You will typically want to use both `FormParser` and `MultiPartParser` together in order to fully support HTML form data.

    **.media_type**: `application/x-www-form-urlencoded`
- name: Generic view settings
  id: api-guide/settings/index#generic-view-settings
  summary: The following settings control the behavior of the generic class-based views
  belongs_to: Settings
  description: |-
    ## Generic view settings

    *The following settings control the behavior of the generic class-based views.*

    #### DEFAULT_FILTER_BACKENDS

    A list of filter backend classes that should be used for generic filtering. If set to `None` then generic filtering is disabled.

    #### DEFAULT_PAGINATION_CLASS

    The default class to use for queryset pagination. If set to `None`, pagination is disabled by default. See the pagination documentation for further guidance on [setting](../pagination/index#setting-the-pagination-style) and [modifying](../pagination/index#modifying-the-pagination-style) the pagination style.

    Default: `None`

    #### PAGE_SIZE

    The default page size to use for pagination. If set to `None`, pagination is disabled by default.

    Default: `None`

    ### SEARCH_PARAM

    The name of a query parameter, which can be used to specify the search term used by `SearchFilter`.

    Default: `search`

    #### ORDERING_PARAM

    The name of a query parameter, which can be used to specify the ordering of results returned by `OrderingFilter`.

    Default: `ordering`
- name: Generic views
  id: api-guide/generic-views/index
  summary: Django’s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself
  description: "# Generic views\n\n> Django’s generic views... were developed as a shortcut for common usage patterns... They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.\n>\n> — [Django Documentation](https://docs.djangoproject.com/en/stable/ref/class-based-views/#base-vs-generic-views)\n\nOne of the key benefits of class-based views is the way they allow you to compose bits of reusable behavior. REST framework takes advantage of this by providing a number of pre-built views that provide for commonly used patterns.\n\nThe generic views provided by REST framework allow you to quickly build API views that map closely to your database models.\n\nIf the generic views don't suit the needs of your API, you can drop down to using the regular `APIView` class, or reuse the mixins and base classes used by the generic views to compose your own set of reusable generic views.\n\n## Examples\n\nTypically when using the generic views, you'll override the view, and set several class attributes.\n\n``` python\nfrom django.contrib.auth.models import User\nfrom myapp.serializers import UserSerializer\nfrom rest_framework import generics\nfrom rest_framework.permissions import IsAdminUser\n\nclass UserList(generics.ListCreateAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    permission_classes = [IsAdminUser]\n```\n\nFor more complex cases you might also want to override various methods on the view class. For example.\n\n``` python\nclass UserList(generics.ListCreateAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    permission_classes = [IsAdminUser]\n\n    def list(self, request):\n        # Note the use of `get_queryset()` instead of `self.queryset`\n        queryset = self.get_queryset()\n        serializer = UserSerializer(queryset, many=True)\n        return Response(serializer.data)\n```\n\nFor very simple cases you might want to pass through any class attributes using the `.as_view()` method. For example, your URLconf might include something like the following entry:\n\n``` python\npath('users/', ListCreateAPIView.as_view(queryset=User.objects.all(), serializer_class=UserSerializer), name='user-list')\n```\n\n# API Reference\n\n## GenericAPIView\n\nThis class extends REST framework's `APIView` class, adding commonly required behavior for standard list and detail views.\n\nEach of the concrete generic views provided is built by combining `GenericAPIView`, with one or more mixin classes.\n\n### Attributes\n\n**Basic settings**:\n\nThe following attributes control the basic view behavior.\n\n- `queryset` - The queryset that should be used for returning objects from this view. Typically, you must either set this attribute, or override the `get_queryset()` method. If you are overriding a view method, it is important that you call `get_queryset()` instead of accessing this property directly, as `queryset` will get evaluated once, and those results will be cached for all subsequent requests.\n- `serializer_class` - The serializer class that should be used for validating and deserializing input, and for serializing output. Typically, you must either set this attribute, or override the `get_serializer_class()` method.\n- `lookup_field` - The model field that should be used for performing object lookup of individual model instances. Defaults to `'pk'`. Note that when using hyperlinked APIs you'll need to ensure that *both* the API views *and* the serializer classes set the lookup fields if you need to use a custom value.\n- `lookup_url_kwarg` - The URL keyword argument that should be used for object lookup. The URL conf should include a keyword argument corresponding to this value. If unset this defaults to using the same value as `lookup_field`.\n\n**Pagination**:\n\nThe following attributes are used to control pagination when used with list views.\n\n- `pagination_class` - The pagination class that should be used when paginating list results. Defaults to the same value as the `DEFAULT_PAGINATION_CLASS` setting, which is `'rest_framework.pagination.PageNumberPagination'`. Setting `pagination_class=None` will disable pagination on this view.\n\n**Filtering**:\n\n- `filter_backends` - A list of filter backend classes that should be used for filtering the queryset. Defaults to the same value as the `DEFAULT_FILTER_BACKENDS` setting.\n\n### Methods\n\n**Base methods**:\n\n#### get_queryset(self)\n\nReturns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the `queryset` attribute.\n\nThis method should always be used rather than accessing `self.queryset` directly, as `self.queryset` gets evaluated only once, and those results are cached for all subsequent requests.\n\nMay be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.\n\nFor example:\n\n``` python\ndef get_queryset(self):\n    user = self.request.user\n    return user.accounts.all()\n```\n\n**Note:** If the `serializer_class` used in the generic view spans orm relations, leading to an n+1 problem, you could optimize your queryset in this method using `select_related` and `prefetch_related`. To get more information about n+1 problem and use cases of the mentioned methods refer to related section in [django documentation](https://docs.djangoproject.com/en/3.1/ref/models/querysets/#django.db.models.query.QuerySet.select_related).\n\n#### get_object(self)\n\nReturns an object instance that should be used for detail views. Defaults to using the `lookup_field` parameter to filter the base queryset.\n\nMay be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.\n\nFor example:\n\n``` python\ndef get_object(self):\n    queryset = self.get_queryset()\n    filter = {}\n    for field in self.multiple_lookup_fields:\n        filter[field] = self.kwargs[field]\n\n    obj = get_object_or_404(queryset, **filter)\n    self.check_object_permissions(self.request, obj)\n    return obj\n```\n\nNote that if your API doesn't include any object level permissions, you may optionally exclude the `self.check_object_permissions`, and simply return the object from the `get_object_or_404` lookup.\n\n#### filter_queryset(self, queryset)\n\nGiven a queryset, filter it with whichever filter backends are in use, returning a new queryset.\n\nFor example:\n\n``` python\ndef filter_queryset(self, queryset):\n    filter_backends = [CategoryFilter]\n\n    if 'geo_route' in self.request.query_params:\n        filter_backends = [GeoRouteFilter, CategoryFilter]\n    elif 'geo_point' in self.request.query_params:\n        filter_backends = [GeoPointFilter, CategoryFilter]\n\n    for backend in list(filter_backends):\n        queryset = backend().filter_queryset(self.request, queryset, view=self)\n\n    return queryset\n```\n\n#### get_serializer_class(self)\n\nReturns the class that should be used for the serializer. Defaults to returning the `serializer_class` attribute.\n\nMay be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.\n\nFor example:\n\n``` python\ndef get_serializer_class(self):\n    if self.request.user.is_staff:\n        return FullAccountSerializer\n    return BasicAccountSerializer\n```\n\n**Save and deletion hooks**:\n\nThe following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.\n\n- `perform_create(self, serializer)` - Called by `CreateModelMixin` when saving a new object instance.\n- `perform_update(self, serializer)` - Called by `UpdateModelMixin` when saving an existing object instance.\n- `perform_destroy(self, instance)` - Called by `DestroyModelMixin` when deleting an object instance.\n\nThese hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.\n\n``` python\ndef perform_create(self, serializer):\n    serializer.save(user=self.request.user)\n```\n\nThese override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.\n\n``` python\ndef perform_update(self, serializer):\n    instance = serializer.save()\n    send_email_confirmation(user=self.request.user, modified=instance)\n```\n\nYou can also use these hooks to provide additional validation, by raising a `ValidationError()`. This can be useful if you need some validation logic to apply at the point of database save. For example:\n\n``` python\ndef perform_create(self, serializer):\n    queryset = SignupRequest.objects.filter(user=self.request.user)\n    if queryset.exists():\n        raise ValidationError('You have already signed up')\n    serializer.save(user=self.request.user)\n```\n\n**Other methods**:\n\nYou won't typically need to override the following methods, although you might need to call into them if you're writing custom views using `GenericAPIView`.\n\n- `get_serializer_context(self)` - Returns a dictionary containing any extra context that should be supplied to the serializer. Defaults to including `'request'`, `'view'` and `'format'` keys.\n- `get_serializer(self, instance=None, data=None, many=False, partial=False)` - Returns a serializer instance.\n- `get_paginated_response(self, data)` - Returns a paginated style `Response` object.\n- `paginate_queryset(self, queryset)` - Paginate a queryset if required, either returning a page object, or `None` if pagination is not configured for this view.\n- `filter_queryset(self, queryset)` - Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.\n\n# Mixins\n\nThe mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as `.get()` and `.post()`, directly. This allows for more flexible composition of behavior.\n\nThe mixin classes can be imported from `rest_framework.mixins`.\n\n## ListModelMixin\n\nProvides a `.list(request, *args, **kwargs)` method, that implements listing a queryset.\n\nIf the queryset is populated, this returns a `200 OK` response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.\n\n## CreateModelMixin\n\nProvides a `.create(request, *args, **kwargs)` method, that implements creating and saving a new model instance.\n\nIf an object is created this returns a `201 Created` response, with a serialized representation of the object as the body of the response. If the representation contains a key named `url`, then the `Location` header of the response will be populated with that value.\n\nIf the request data provided for creating the object was invalid, a `400 Bad Request` response will be returned, with the error details as the body of the response.\n\n## RetrieveModelMixin\n\nProvides a `.retrieve(request, *args, **kwargs)` method, that implements returning an existing model instance in a response.\n\nIf an object can be retrieved this returns a `200 OK` response, with a serialized representation of the object as the body of the response. Otherwise, it will return a `404 Not Found`.\n\n## UpdateModelMixin\n\nProvides a `.update(request, *args, **kwargs)` method, that implements updating and saving an existing model instance.\n\nAlso provides a `.partial_update(request, *args, **kwargs)` method, which is similar to the `update` method, except that all fields for the update will be optional. This allows support for HTTP `PATCH` requests.\n\nIf an object is updated this returns a `200 OK` response, with a serialized representation of the object as the body of the response.\n\nIf the request data provided for updating the object was invalid, a `400 Bad Request` response will be returned, with the error details as the body of the response.\n\n## DestroyModelMixin\n\nProvides a `.destroy(request, *args, **kwargs)` method, that implements deletion of an existing model instance.\n\nIf an object is deleted this returns a `204 No Content` response, otherwise it will return a `404 Not Found`.\n\n# Concrete View Classes\n\nThe following classes are the concrete generic views. If you're using generic views this is normally the level you'll be working at unless you need heavily customized behavior.\n\nThe view classes can be imported from `rest_framework.generics`.\n\n## CreateAPIView\n\nUsed for **create-only** endpoints.\n\nProvides a `post` method handler.\n\nExtends: [GenericAPIView](#genericapiview), [CreateModelMixin](#createmodelmixin)\n\n## ListAPIView\n\nUsed for **read-only** endpoints to represent a **collection of model instances**.\n\nProvides a `get` method handler.\n\nExtends: [GenericAPIView](#genericapiview), [ListModelMixin](#listmodelmixin)\n\n## RetrieveAPIView\n\nUsed for **read-only** endpoints to represent a **single model instance**.\n\nProvides a `get` method handler.\n\nExtends: [GenericAPIView](#genericapiview), [RetrieveModelMixin](#retrievemodelmixin)\n\n## DestroyAPIView\n\nUsed for **delete-only** endpoints for a **single model instance**.\n\nProvides a `delete` method handler.\n\nExtends: [GenericAPIView](#genericapiview), [DestroyModelMixin](#destroymodelmixin)\n\n## UpdateAPIView\n\nUsed for **update-only** endpoints for a **single model instance**.\n\nProvides `put` and `patch` method handlers.\n\nExtends: [GenericAPIView](#genericapiview), [UpdateModelMixin](#updatemodelmixin)\n\n## ListCreateAPIView\n\nUsed for **read-write** endpoints to represent a **collection of model instances**.\n\nProvides `get` and `post` method handlers.\n\nExtends: [GenericAPIView](#genericapiview), [ListModelMixin](#listmodelmixin), [CreateModelMixin](#createmodelmixin)\n\n## RetrieveUpdateAPIView\n\nUsed for **read or update** endpoints to represent a **single model instance**.\n\nProvides `get`, `put` and `patch` method handlers.\n\nExtends: [GenericAPIView](#genericapiview), [RetrieveModelMixin](#retrievemodelmixin), [UpdateModelMixin](#updatemodelmixin)\n\n## RetrieveDestroyAPIView\n\nUsed for **read or delete** endpoints to represent a **single model instance**.\n\nProvides `get` and `delete` method handlers.\n\nExtends: [GenericAPIView](#genericapiview), [RetrieveModelMixin](#retrievemodelmixin), [DestroyModelMixin](#destroymodelmixin)\n\n## RetrieveUpdateDestroyAPIView\n\nUsed for **read-write-delete** endpoints to represent a **single model instance**.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: [GenericAPIView](#genericapiview), [RetrieveModelMixin](#retrievemodelmixin), [UpdateModelMixin](#updatemodelmixin), [DestroyModelMixin](#destroymodelmixin)\n\n# Customizing the generic views\n\nOften you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.\n\n## Creating custom mixins\n\nFor example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:\n\n``` python\nclass MultipleFieldLookupMixin:\n    \"\"\"\n    Apply this mixin to any view or viewset to get multiple field filtering\n    based on a `lookup_fields` attribute, instead of the default single field filtering.\n    \"\"\"\n    def get_object(self):\n        queryset = self.get_queryset()             # Get the base queryset\n        queryset = self.filter_queryset(queryset)  # Apply any filter backends\n        filter = {}\n        for field in self.lookup_fields:\n            if self.kwargs.get(field): # Ignore empty fields.\n                filter[field] = self.kwargs[field]\n        obj = get_object_or_404(queryset, **filter)  # Lookup the object\n        self.check_object_permissions(self.request, obj)\n        return obj\n```\n\nYou can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.\n\n``` python\nclass RetrieveUserView(MultipleFieldLookupMixin, generics.RetrieveAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    lookup_fields = ['account', 'username']\n```\n\nUsing custom mixins is a good option if you have custom behavior that needs to be used.\n\n## Creating custom base classes\n\nIf you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:\n\n``` python\nclass BaseRetrieveView(MultipleFieldLookupMixin,\n                       generics.RetrieveAPIView):\n    pass\n\nclass BaseRetrieveUpdateDestroyView(MultipleFieldLookupMixin,\n                                    generics.RetrieveUpdateDestroyAPIView):\n    pass\n```\n\nUsing custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.\n\n# PUT as create\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an update or a create operation, depending on if the object already existed or not.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning `404` responses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include something like [this `AllowPUTAsCreateMixin` class](https://gist.github.com/tomchristie/a2ace4577eff2c603b1b) as a mixin to your views.\n\n# Third party packages\n\nThe following third party packages provide additional generic view implementations.\n\n## Django Rest Multiple Models\n\n[Django Rest Multiple Models](https://github.com/MattBroach/DjangoRestMultipleModels) provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.\n\n[mixins.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/mixins.py)[generics.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/generics.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/generic-views/](https://www.django-rest-framework.org/api-guide/generic-views/)"
- name: GenericAPIView
  id: api-guide/generic-views/index#genericapiview
  summary: This class extends REST framework's APIView class, adding commonly required behavior for standard list and detail views
  belongs_to: Generic views
  description: |-
    ## GenericAPIView

    This class extends REST framework's `APIView` class, adding commonly required behavior for standard list and detail views.

    Each of the concrete generic views provided is built by combining `GenericAPIView`, with one or more mixin classes.

    ### Attributes

    **Basic settings**:

    The following attributes control the basic view behavior.

    - `queryset` - The queryset that should be used for returning objects from this view. Typically, you must either set this attribute, or override the `get_queryset()` method. If you are overriding a view method, it is important that you call `get_queryset()` instead of accessing this property directly, as `queryset` will get evaluated once, and those results will be cached for all subsequent requests.
    - `serializer_class` - The serializer class that should be used for validating and deserializing input, and for serializing output. Typically, you must either set this attribute, or override the `get_serializer_class()` method.
    - `lookup_field` - The model field that should be used for performing object lookup of individual model instances. Defaults to `'pk'`. Note that when using hyperlinked APIs you'll need to ensure that *both* the API views *and* the serializer classes set the lookup fields if you need to use a custom value.
    - `lookup_url_kwarg` - The URL keyword argument that should be used for object lookup. The URL conf should include a keyword argument corresponding to this value. If unset this defaults to using the same value as `lookup_field`.

    **Pagination**:

    The following attributes are used to control pagination when used with list views.

    - `pagination_class` - The pagination class that should be used when paginating list results. Defaults to the same value as the `DEFAULT_PAGINATION_CLASS` setting, which is `'rest_framework.pagination.PageNumberPagination'`. Setting `pagination_class=None` will disable pagination on this view.

    **Filtering**:

    - `filter_backends` - A list of filter backend classes that should be used for filtering the queryset. Defaults to the same value as the `DEFAULT_FILTER_BACKENDS` setting.

    ### Methods

    **Base methods**:

    #### get_queryset(self)

    Returns the queryset that should be used for list views, and that should be used as the base for lookups in detail views. Defaults to returning the queryset specified by the `queryset` attribute.

    This method should always be used rather than accessing `self.queryset` directly, as `self.queryset` gets evaluated only once, and those results are cached for all subsequent requests.

    May be overridden to provide dynamic behavior, such as returning a queryset, that is specific to the user making the request.

    For example:

    ``` python
    def get_queryset(self):
        user = self.request.user
        return user.accounts.all()
    ```

    **Note:** If the `serializer_class` used in the generic view spans orm relations, leading to an n+1 problem, you could optimize your queryset in this method using `select_related` and `prefetch_related`. To get more information about n+1 problem and use cases of the mentioned methods refer to related section in [django documentation](https://docs.djangoproject.com/en/3.1/ref/models/querysets/#django.db.models.query.QuerySet.select_related).

    #### get_object(self)

    Returns an object instance that should be used for detail views. Defaults to using the `lookup_field` parameter to filter the base queryset.

    May be overridden to provide more complex behavior, such as object lookups based on more than one URL kwarg.

    For example:

    ``` python
    def get_object(self):
        queryset = self.get_queryset()
        filter = {}
        for field in self.multiple_lookup_fields:
            filter[field] = self.kwargs[field]

        obj = get_object_or_404(queryset, **filter)
        self.check_object_permissions(self.request, obj)
        return obj
    ```

    Note that if your API doesn't include any object level permissions, you may optionally exclude the `self.check_object_permissions`, and simply return the object from the `get_object_or_404` lookup.

    #### filter_queryset(self, queryset)

    Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.

    For example:

    ``` python
    def filter_queryset(self, queryset):
        filter_backends = [CategoryFilter]

        if 'geo_route' in self.request.query_params:
            filter_backends = [GeoRouteFilter, CategoryFilter]
        elif 'geo_point' in self.request.query_params:
            filter_backends = [GeoPointFilter, CategoryFilter]

        for backend in list(filter_backends):
            queryset = backend().filter_queryset(self.request, queryset, view=self)

        return queryset
    ```

    #### get_serializer_class(self)

    Returns the class that should be used for the serializer. Defaults to returning the `serializer_class` attribute.

    May be overridden to provide dynamic behavior, such as using different serializers for read and write operations, or providing different serializers to different types of users.

    For example:

    ``` python
    def get_serializer_class(self):
        if self.request.user.is_staff:
            return FullAccountSerializer
        return BasicAccountSerializer
    ```

    **Save and deletion hooks**:

    The following methods are provided by the mixin classes, and provide easy overriding of the object save or deletion behavior.

    - `perform_create(self, serializer)` - Called by `CreateModelMixin` when saving a new object instance.
    - `perform_update(self, serializer)` - Called by `UpdateModelMixin` when saving an existing object instance.
    - `perform_destroy(self, instance)` - Called by `DestroyModelMixin` when deleting an object instance.

    These hooks are particularly useful for setting attributes that are implicit in the request, but are not part of the request data. For instance, you might set an attribute on the object based on the request user, or based on a URL keyword argument.

    ``` python
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)
    ```

    These override points are also particularly useful for adding behavior that occurs before or after saving an object, such as emailing a confirmation, or logging the update.

    ``` python
    def perform_update(self, serializer):
        instance = serializer.save()
        send_email_confirmation(user=self.request.user, modified=instance)
    ```

    You can also use these hooks to provide additional validation, by raising a `ValidationError()`. This can be useful if you need some validation logic to apply at the point of database save. For example:

    ``` python
    def perform_create(self, serializer):
        queryset = SignupRequest.objects.filter(user=self.request.user)
        if queryset.exists():
            raise ValidationError('You have already signed up')
        serializer.save(user=self.request.user)
    ```

    **Other methods**:

    You won't typically need to override the following methods, although you might need to call into them if you're writing custom views using `GenericAPIView`.

    - `get_serializer_context(self)` - Returns a dictionary containing any extra context that should be supplied to the serializer. Defaults to including `'request'`, `'view'` and `'format'` keys.
    - `get_serializer(self, instance=None, data=None, many=False, partial=False)` - Returns a serializer instance.
    - `get_paginated_response(self, data)` - Returns a paginated style `Response` object.
    - `paginate_queryset(self, queryset)` - Paginate a queryset if required, either returning a page object, or `None` if pagination is not configured for this view.
    - `filter_queryset(self, queryset)` - Given a queryset, filter it with whichever filter backends are in use, returning a new queryset.

    # Mixins

    The mixin classes provide the actions that are used to provide the basic view behavior. Note that the mixin classes provide action methods rather than defining the handler methods, such as `.get()` and `.post()`, directly. This allows for more flexible composition of behavior.

    The mixin classes can be imported from `rest_framework.mixins`.
- name: GenericViewSet
  id: api-guide/viewsets/index#genericviewset
  summary: The GenericViewSet class inherits from GenericAPIView, and provides the default set of get_object, get_queryset methods and other generic view base behavior, but does not include any actions by default
  belongs_to: ViewSets
  description: |-
    ## GenericViewSet

    The `GenericViewSet` class inherits from `GenericAPIView`, and provides the default set of `get_object`, `get_queryset` methods and other generic view base behavior, but does not include any actions by default.

    In order to use a `GenericViewSet` class you'll override the class and either mixin the required mixin classes, or define the action implementations explicitly.
- name: HiddenField
  id: api-guide/fields/index#hiddenfield
  summary: A field class that does not take a value based on user input, but instead takes its value from a default value or callable
  belongs_to: Serializer fields
  description: |-
    ## HiddenField

    A field class that does not take a value based on user input, but instead takes its value from a default value or callable.

    **Signature**: `HiddenField()`

    For example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:

    ``` python
    modified = serializers.HiddenField(default=timezone.now)
    ```

    The `HiddenField` class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.

    For further examples on `HiddenField` see the [validators](../validators/index) documentation.

    **Note:**`HiddenField()` does not appear in `partial=True` serializer (when making `PATCH` request). This behavior might change in future, follow updates on [github discussion](https://github.com/encode/django-rest-framework/discussions/8259).
- name: HostNameVersioning
  id: api-guide/versioning/index#hostnameversioning
  summary: The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL
  belongs_to: Versioning
  description: |-
    ## HostNameVersioning

    The hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.

    For example the following is an HTTP request to the `http://v1.example.com/bookings/` URL:

    ``` python
    GET /bookings/ HTTP/1.1
    Host: v1.example.com
    Accept: application/json
    ```

    By default this implementation expects the hostname to match this simple regular expression:

    ``` python
    ^([a-zA-Z0-9]+)\.[a-zA-Z0-9]+\.[a-zA-Z0-9]+$
    ```

    Note that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.

    The `HostNameVersioning` scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as `127.0.0.1`. There are various online tutorials on how to [access localhost with a custom subdomain](https://reinteractive.net/posts/199-developing-and-testing-rails-applications-with-subdomains) which you may find helpful in this case.

    Hostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.
- name: HStoreField
  id: api-guide/fields/index#hstorefield
  summary: A preconfigured DictField that is compatible with Django's postgres HStoreField
  belongs_to: Serializer fields
  description: |-
    ## HStoreField

    A preconfigured `DictField` that is compatible with Django's postgres `HStoreField`.

    **Signature**: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`

    - `child` - A field instance that is used for validating the values in the dictionary. The default child field accepts both empty strings and null values.
    - `allow_empty` - Designates if empty dictionaries are allowed.

    Note that the child field **must** be an instance of `CharField`, as the hstore extension stores values as strings.
- name: HTML Select Field cutoffs
  id: api-guide/settings/index#html-select-field-cutoffs
  summary: Global settings for select field cutoffs for rendering relational fields in the browsable API
  belongs_to: Settings
  description: |-
    ## HTML Select Field cutoffs

    Global settings for [select field cutoffs for rendering relational fields](../relations/index#select-field-cutoffs) in the browsable API.

    #### HTML_SELECT_CUTOFF

    Global setting for the `html_cutoff` value. Must be an integer.

    Default: 1000

    #### HTML_SELECT_CUTOFF_TEXT

    A string representing a global setting for `html_cutoff_text`.

    Default: `"More than {count} items..."`
- name: HTMLFormRenderer
  id: api-guide/renderers/index#htmlformrenderer
  summary: Renders data returned by a serializer into an HTML form
  belongs_to: Renderers
  description: |-
    ## HTMLFormRenderer

    Renders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing `<form>` tags, a hidden CSRF input or any submit buttons.

    This renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the `render_form` template tag.

    ``` python
    {% load rest_framework %}

    <form action="/submit-report/" method="post">
        {% csrf_token %}
        {% render_form serializer %}
        <input type="submit" value="Save" />
    </form>
    ```

    For more information see the [HTML & Forms](https://www.django-rest-framework.org/topics/html-and-forms/) documentation.

    **.media_type**: `text/html`

    **.format**: `'form'`

    **.charset**: `utf-8`

    **.template**: `'rest_framework/horizontal/form.html'`
- name: HyperlinkedIdentityField
  id: api-guide/relations/index#hyperlinkedidentityfield
  summary: This field can be applied as an identity relationship, such as the 'url' field on a HyperlinkedModelSerializer
  belongs_to: Serializer relations
  description: "## HyperlinkedIdentityField\n\nThis field can be applied as an identity relationship, such as the `'url'` field on a HyperlinkedModelSerializer. It can also be used for an attribute on the object. For example, the following serializer:\n\n``` python\nclass AlbumSerializer(serializers.HyperlinkedModelSerializer):\n    track_listing = serializers.HyperlinkedIdentityField(view_name='track-list')\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'track_listing']\n```\n\nWould serialize to a representation like this:\n\n``` python\n{\n    'album_name': 'The Eraser',\n    'artist': 'Thom Yorke',\n    'track_listing': 'http://www.example.com/api/track_list/12/',\n}\n```\n\nThis field is always read-only.\n\n**Arguments**:\n\n- `view_name` - The view name that should be used as the target of the relationship. If you're using [the standard router classes](../routers#defaultrouter) this will be a string with the format `<model_name>-detail`. **required**.\n- `lookup_field` - The field on the target that should be used for the lookup. Should correspond to a URL keyword argument on the referenced view. Default is `'pk'`.\n- `lookup_url_kwarg` - The name of the keyword argument defined in the URL conf that corresponds to the lookup field. Defaults to using the same value as `lookup_field`.\n- `format` - If using format suffixes, hyperlinked fields will use the same format suffix for the target unless overridden by using the `format` argument.\n\n# Nested relationships\n\nAs opposed to previously discussed *references* to another entity, the referred entity can instead also be embedded or *nested* in the representation of the object that refers to it. Such nested relationships can be expressed by using serializers as fields.\n\nIf the field is used to represent a to-many relationship, you should add the `many=True` flag to the serializer field.\n\n## Example\n\nFor example, the following serializer:\n\n``` python\nclass TrackSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Track\n        fields = ['order', 'title', 'duration']\n\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = TrackSerializer(many=True, read_only=True)\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n```\n\nWould serialize to a nested representation like this:\n\n``` python\n>>> album = Album.objects.create(album_name=\"The Grey Album\", artist='Danger Mouse')\n>>> Track.objects.create(album=album, order=1, title='Public Service Announcement', duration=245)\n<Track: Track object>\n>>> Track.objects.create(album=album, order=2, title='What More Can I Say', duration=264)\n<Track: Track object>\n>>> Track.objects.create(album=album, order=3, title='Encore', duration=159)\n<Track: Track object>\n>>> serializer = AlbumSerializer(instance=album)\n>>> serializer.data\n{\n    'album_name': 'The Grey Album',\n    'artist': 'Danger Mouse',\n    'tracks': [\n        {'order': 1, 'title': 'Public Service Announcement', 'duration': 245},\n        {'order': 2, 'title': 'What More Can I Say', 'duration': 264},\n        {'order': 3, 'title': 'Encore', 'duration': 159},\n        ...\n    ],\n}\n```\n\n## Writable nested serializers\n\nBy default nested serializers are read-only. If you want to support write-operations to a nested serializer field you'll need to create `create()` and/or `update()` methods in order to explicitly specify how the child relationships should be saved:\n\n``` python\nclass TrackSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Track\n        fields = ['order', 'title', 'duration']\n\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = TrackSerializer(many=True)\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n\n    def create(self, validated_data):\n        tracks_data = validated_data.pop('tracks')\n        album = Album.objects.create(**validated_data)\n        for track_data in tracks_data:\n            Track.objects.create(album=album, **track_data)\n        return album\n\n>>> data = {\n    'album_name': 'The Grey Album',\n    'artist': 'Danger Mouse',\n    'tracks': [\n        {'order': 1, 'title': 'Public Service Announcement', 'duration': 245},\n        {'order': 2, 'title': 'What More Can I Say', 'duration': 264},\n        {'order': 3, 'title': 'Encore', 'duration': 159},\n    ],\n}\n>>> serializer = AlbumSerializer(data=data)\n>>> serializer.is_valid()\nTrue\n>>> serializer.save()\n<Album: Album object>\n```\n\n# Custom relational fields\n\nIn rare cases where none of the existing relational styles fit the representation you need, you can implement a completely custom relational field, that describes exactly how the output representation should be generated from the model instance.\n\nTo implement a custom relational field, you should override `RelatedField`, and implement the `.to_representation(self, value)` method. This method takes the target of the field as the `value` argument, and should return the representation that should be used to serialize the target. The `value` argument will typically be a model instance.\n\nIf you want to implement a read-write relational field, you must also implement the [`.to_internal_value(self, data)` method](../serializers/index#to_internal_valueself-data).\n\nTo provide a dynamic queryset based on the `context`, you can also override `.get_queryset(self)` instead of specifying `.queryset` on the class or when initializing the field.\n\n## Example\n\nFor example, we could define a relational field to serialize a track to a custom string representation, using its ordering, title, and duration:\n\n``` python\nimport time\n\nclass TrackListingField(serializers.RelatedField):\n    def to_representation(self, value):\n        duration = time.strftime('%M:%S', time.gmtime(value.duration))\n        return 'Track %d: %s (%s)' % (value.order, value.name, duration)\n\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = TrackListingField(many=True)\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n```\n\nThis custom field would then serialize to the following representation:\n\n``` python\n{\n    'album_name': 'Sometimes I Wish We Were an Eagle',\n    'artist': 'Bill Callahan',\n    'tracks': [\n        'Track 1: Jim Cain (04:39)',\n        'Track 2: Eid Ma Clack Shaw (04:19)',\n        'Track 3: The Wind and the Dove (04:34)',\n        ...\n    ]\n}\n```\n\n# Custom hyperlinked fields\n\nIn some cases you may need to customize the behavior of a hyperlinked field, in order to represent URLs that require more than a single lookup field.\n\nYou can achieve this by overriding `HyperlinkedRelatedField`. There are two methods that may be overridden:\n\n**get_url(self, obj, view_name, request, format)**\n\nThe `get_url` method is used to map the object instance to its URL representation.\n\nMay raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes are not configured to correctly match the URL conf.\n\n**get_object(self, view_name, view_args, view_kwargs)**\n\nIf you want to support a writable hyperlinked field then you'll also want to override `get_object`, in order to map incoming URLs back to the object they represent. For read-only hyperlinked fields there is no need to override this method.\n\nThe return value of this method should the object that corresponds to the matched URL conf arguments.\n\nMay raise an `ObjectDoesNotExist` exception.\n\n## Example\n\nSay we have a URL for a customer object that takes two keyword arguments, like so:\n\n``` python\n/api/<organization_slug>/customers/<customer_pk>/\n```\n\nThis cannot be represented with the default implementation, which accepts only a single lookup field.\n\nIn this case we'd need to override `HyperlinkedRelatedField` to get the behavior we want:\n\n``` python\nfrom rest_framework import serializers\nfrom rest_framework.reverse import reverse\n\nclass CustomerHyperlink(serializers.HyperlinkedRelatedField):\n    # We define these as class attributes, so we don't need to pass them as arguments.\n    view_name = 'customer-detail'\n    queryset = Customer.objects.all()\n\n    def get_url(self, obj, view_name, request, format):\n        url_kwargs = {\n            'organization_slug': obj.organization.slug,\n            'customer_pk': obj.pk\n        }\n        return reverse(view_name, kwargs=url_kwargs, request=request, format=format)\n\n    def get_object(self, view_name, view_args, view_kwargs):\n        lookup_kwargs = {\n           'organization__slug': view_kwargs['organization_slug'],\n           'pk': view_kwargs['customer_pk']\n        }\n        return self.get_queryset().get(**lookup_kwargs)\n```\n\nNote that if you wanted to use this style together with the generic views then you'd also need to override `.get_object` on the view in order to get the correct lookup behavior.\n\nGenerally we recommend a flat style for API representations where possible, but the nested URL style can also be reasonable when used in moderation.\n\n# Further notes\n\n## The queryset argument\n\nThe `queryset` argument is only ever required for *writable* relationship field, in which case it is used for performing the model instance lookup, that maps from the primitive user input, into a model instance.\n\nIn version 2.x a serializer class could *sometimes* automatically determine the `queryset` argument *if* a `ModelSerializer` class was being used.\n\nThis behavior is now replaced with *always* using an explicit `queryset` argument for writable relational fields.\n\nDoing so reduces the amount of hidden 'magic' that `ModelSerializer` provides, makes the behavior of the field more clear, and ensures that it is trivial to move between using the `ModelSerializer` shortcut, or using fully explicit `Serializer` classes.\n\n## Customizing the HTML display\n\nThe built-in `__str__` method of the model will be used to generate string representations of the objects used to populate the `choices` property. These choices are used to populate select HTML inputs in the browsable API.\n\nTo provide customized representations for such inputs, override `display_value()` of a `RelatedField` subclass. This method will receive a model object, and should return a string suitable for representing it. For example:\n\n``` python\nclass TrackPrimaryKeyRelatedField(serializers.PrimaryKeyRelatedField):\n    def display_value(self, instance):\n        return 'Track: %s' % (instance.title)\n```\n\n## Select field cutoffs\n\nWhen rendered in the browsable API relational fields will default to only displaying a maximum of 1000 selectable items. If more items are present then a disabled option with \"More than 1000 items…\" will be displayed.\n\nThis behavior is intended to prevent a template from being unable to render in an acceptable timespan due to a very large number of relationships being displayed.\n\nThere are two keyword arguments you can use to control this behavior:\n\n- `html_cutoff` - If set this will be the maximum number of choices that will be displayed by a HTML select drop down. Set to `None` to disable any limiting. Defaults to `1000`.\n- `html_cutoff_text` - If set this will display a textual indicator if the maximum number of items have been cutoff in an HTML select drop down. Defaults to `\"More than {count} items…\"`\n\nYou can also control these globally using the settings `HTML_SELECT_CUTOFF` and `HTML_SELECT_CUTOFF_TEXT`.\n\nIn cases where the cutoff is being enforced you may want to instead use a plain input field in the HTML form. You can do so using the `style` keyword argument. For example:\n\n``` python\nassigned_to = serializers.SlugRelatedField(\n   queryset=User.objects.all(),\n   slug_field='username',\n   style={'base_template': 'input.html'}\n)\n```\n\n## Reverse relations\n\nNote that reverse relationships are not automatically included by the `ModelSerializer` and `HyperlinkedModelSerializer` classes. To include a reverse relationship, you must explicitly add it to the fields list. For example:\n\n``` python\nclass AlbumSerializer(serializers.ModelSerializer):\n    class Meta:\n        fields = ['tracks', ...]\n```\n\nYou'll normally want to ensure that you've set an appropriate `related_name` argument on the relationship, that you can use as the field name. For example:\n\n``` python\nclass Track(models.Model):\n    album = models.ForeignKey(Album, related_name='tracks', on_delete=models.CASCADE)\n    ...\n```\n\nIf you have not set a related name for the reverse relationship, you'll need to use the automatically generated related name in the `fields` argument. For example:\n\n``` python\nclass AlbumSerializer(serializers.ModelSerializer):\n    class Meta:\n        fields = ['track_set', ...]\n```\n\nSee the Django documentation on [reverse relationships](https://docs.djangoproject.com/en/stable/topics/db/queries/#following-relationships-backward) for more details.\n\n## Generic relationships\n\nIf you want to serialize a generic foreign key, you need to define a custom field, to determine explicitly how you want to serialize the targets of the relationship.\n\nFor example, given the following model for a tag, which has a generic relationship with other arbitrary models:\n\n``` python\nclass TaggedItem(models.Model):\n    \"\"\"\n    Tags arbitrary model instances using a generic relation.\n\n    See: https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/\n    \"\"\"\n    tag_name = models.SlugField()\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    tagged_object = GenericForeignKey('content_type', 'object_id')\n\n    def __str__(self):\n        return self.tag_name\n```\n\nAnd the following two models, which may have associated tags:\n\n``` python\nclass Bookmark(models.Model):\n    \"\"\"\n    A bookmark consists of a URL, and 0 or more descriptive tags.\n    \"\"\"\n    url = models.URLField()\n    tags = GenericRelation(TaggedItem)\n\n\nclass Note(models.Model):\n    \"\"\"\n    A note consists of some text, and 0 or more descriptive tags.\n    \"\"\"\n    text = models.CharField(max_length=1000)\n    tags = GenericRelation(TaggedItem)\n```\n\nWe could define a custom field that could be used to serialize tagged instances, using the type of each instance to determine how it should be serialized:\n\n``` python\nclass TaggedObjectRelatedField(serializers.RelatedField):\n    \"\"\"\n    A custom field to use for the `tagged_object` generic relationship.\n    \"\"\"\n\n    def to_representation(self, value):\n        \"\"\"\n        Serialize tagged objects to a simple textual representation.\n        \"\"\"\n        if isinstance(value, Bookmark):\n            return 'Bookmark: ' + value.url\n        elif isinstance(value, Note):\n            return 'Note: ' + value.text\n        raise Exception('Unexpected type of tagged object')\n```\n\nIf you need the target of the relationship to have a nested representation, you can use the required serializers inside the `.to_representation()` method:\n\n``` python\n    def to_representation(self, value):\n        \"\"\"\n        Serialize bookmark instances using a bookmark serializer,\n        and note instances using a note serializer.\n        \"\"\"\n        if isinstance(value, Bookmark):\n            serializer = BookmarkSerializer(value)\n        elif isinstance(value, Note):\n            serializer = NoteSerializer(value)\n        else:\n            raise Exception('Unexpected type of tagged object')\n\n        return serializer.data\n```\n\nNote that reverse generic keys, expressed using the `GenericRelation` field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.\n\nFor more information see [the Django documentation on generic relations](https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/#id1).\n\n## ManyToManyFields with a Through Model\n\nBy default, relational fields that target a `ManyToManyField` with a `through` model specified are set to read-only.\n\nIf you explicitly specify a relational field pointing to a `ManyToManyField` with a through model, be sure to set `read_only` to `True`.\n\nIf you wish to represent [extra fields on a through model](https://docs.djangoproject.com/en/stable/topics/db/models/#intermediary-manytomany) then you may serialize the through model as [a nested object](../serializers/index#dealing-with-nested-objects).\n\n# Third Party Packages\n\nThe following third party packages are also available.\n\n## DRF Nested Routers\n\nThe [drf-nested-routers package](https://github.com/alanjds/drf-nested-routers) provides routers and relationship fields for working with nested resources.\n\n## Rest Framework Generic Relations\n\nThe [rest-framework-generic-relations](https://github.com/Ian-Foote/rest-framework-generic-relations) library provides read/write serialization for generic foreign keys.\n\n[relations.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/relations.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/relations/](https://www.django-rest-framework.org/api-guide/relations/)"
- name: HyperlinkedModelSerializer
  id: api-guide/serializers/index#hyperlinkedmodelserializer
  summary: The HyperlinkedModelSerializer class is similar to the ModelSerializer class except that it uses hyperlinks to represent relationships, rather than primary keys
  belongs_to: Serializers
  description: |-
    # HyperlinkedModelSerializer

    The `HyperlinkedModelSerializer` class is similar to the `ModelSerializer` class except that it uses hyperlinks to represent relationships, rather than primary keys.

    By default the serializer will include a `url` field instead of a primary key field.

    The url field will be represented using a `HyperlinkedIdentityField` serializer field, and any relationships on the model will be represented using a `HyperlinkedRelatedField` serializer field.

    You can explicitly include the primary key by adding it to the `fields` option, for example:

    ``` python
    class AccountSerializer(serializers.HyperlinkedModelSerializer):
        class Meta:
            model = Account
            fields = ['url', 'id', 'account_name', 'users', 'created']
    ```

    ## Absolute and relative URLs

    When instantiating a `HyperlinkedModelSerializer` you must include the current `request` in the serializer context, for example:

    ``` python
    serializer = AccountSerializer(queryset, context={'request': request})
    ```

    Doing so will ensure that the hyperlinks can include an appropriate hostname, so that the resulting representation uses fully qualified URLs, such as:

    ``` python
    http://api.example.com/accounts/1/
    ```

    Rather than relative URLs, such as:

    ``` python
    /accounts/1/
    ```

    If you *do* want to use relative URLs, you should explicitly pass `{'request': None}` in the serializer context.

    ## How hyperlinked views are determined

    There needs to be a way of determining which views should be used for hyperlinking to model instances.

    By default hyperlinks are expected to correspond to a view name that matches the style `'{model_name}-detail'`, and looks up the instance by a `pk` keyword argument.

    You can override a URL field view name and lookup field by using either, or both of, the `view_name` and `lookup_field` options in the `extra_kwargs` setting, like so:

    ``` python
    class AccountSerializer(serializers.HyperlinkedModelSerializer):
        class Meta:
            model = Account
            fields = ['account_url', 'account_name', 'users', 'created']
            extra_kwargs = {
                'url': {'view_name': 'accounts', 'lookup_field': 'account_name'},
                'users': {'lookup_field': 'username'}
            }
    ```

    Alternatively you can set the fields on the serializer explicitly. For example:

    ``` python
    class AccountSerializer(serializers.HyperlinkedModelSerializer):
        url = serializers.HyperlinkedIdentityField(
            view_name='accounts',
            lookup_field='slug'
        )
        users = serializers.HyperlinkedRelatedField(
            view_name='user-detail',
            lookup_field='username',
            many=True,
            read_only=True
        )

        class Meta:
            model = Account
            fields = ['url', 'account_name', 'users', 'created']
    ```

    **Tip**: Properly matching together hyperlinked representations and your URL conf can sometimes be a bit fiddly. Printing the `repr` of a `HyperlinkedModelSerializer` instance is a particularly useful way to inspect exactly which view names and lookup fields the relationships are expected to map too.

    ## Changing the URL field name

    The name of the URL field defaults to 'url'. You can override this globally, by using the `URL_FIELD_NAME` setting.
- name: HyperlinkedRelatedField
  id: api-guide/relations/index#hyperlinkedrelatedfield
  summary: HyperlinkedRelatedField may be used to represent the target of the relationship using a hyperlink
  belongs_to: Serializer relations
  description: |-
    ## HyperlinkedRelatedField

    `HyperlinkedRelatedField` may be used to represent the target of the relationship using a hyperlink.

    For example, the following serializer:

    ``` python
    class AlbumSerializer(serializers.ModelSerializer):
        tracks = serializers.HyperlinkedRelatedField(
            many=True,
            read_only=True,
            view_name='track-detail'
        )

        class Meta:
            model = Album
            fields = ['album_name', 'artist', 'tracks']
    ```

    Would serialize to a representation like this:

    ``` python
    {
        'album_name': 'Graceland',
        'artist': 'Paul Simon',
        'tracks': [
            'http://www.example.com/api/tracks/45/',
            'http://www.example.com/api/tracks/46/',
            'http://www.example.com/api/tracks/47/',
            ...
        ]
    }
    ```

    By default this field is read-write, although you can change this behavior using the `read_only` flag.

    **Note**: This field is designed for objects that map to a URL that accepts a single URL keyword argument, as set using the `lookup_field` and `lookup_url_kwarg` arguments.

    This is suitable for URLs that contain a single primary key or slug argument as part of the URL.

    If you require more complex hyperlinked representation you'll need to customize the field, as described in the [custom hyperlinked fields](#custom-hyperlinked-fields) section, below.

    **Arguments**:

    - `view_name` - The view name that should be used as the target of the relationship. If you're using [the standard router classes](../routers#defaultrouter) this will be a string with the format `<modelname>-detail`. **required**.
    - `queryset` - The queryset used for model instance lookups when validating the field input. Relationships must either set a queryset explicitly, or set `read_only=True`.
    - `many` - If applied to a to-many relationship, you should set this argument to `True`.
    - `allow_null` - If set to `True`, the field will accept values of `None` or the empty string for nullable relationships. Defaults to `False`.
    - `lookup_field` - The field on the target that should be used for the lookup. Should correspond to a URL keyword argument on the referenced view. Default is `'pk'`.
    - `lookup_url_kwarg` - The name of the keyword argument defined in the URL conf that corresponds to the lookup field. Defaults to using the same value as `lookup_field`.
    - `format` - If using format suffixes, hyperlinked fields will use the same format suffix for the target unless overridden by using the `format` argument.

    &nbsp;
- name: ImageField
  id: api-guide/fields/index#imagefield
  summary: An image representation
  belongs_to: Serializer fields
  description: |-
    ## ImageField

    An image representation. Validates the uploaded file content as matching a known image format.

    Corresponds to `django.forms.fields.ImageField`.

    **Signature:** `ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)`

    - `max_length` - Designates the maximum length for the file name.
    - `allow_empty_file` - Designates if empty files are allowed.
    - `use_url` - If set to `True` then URL string values will be used for the output representation. If set to `False` then filename string values will be used for the output representation. Defaults to the value of the `UPLOADED_FILES_USE_URL` settings key, which is `True` unless set otherwise.

    Requires either the `Pillow` package or `PIL` package. The `Pillow` package is recommended, as `PIL` is no longer actively maintained.

    # Composite fields
- name: IntegerField
  id: api-guide/fields/index#integerfield
  summary: An integer representation
  belongs_to: Serializer fields
  description: |-
    ## IntegerField

    An integer representation.

    Corresponds to `django.db.models.fields.IntegerField`, `django.db.models.fields.SmallIntegerField`, `django.db.models.fields.PositiveIntegerField` and `django.db.models.fields.PositiveSmallIntegerField`.

    **Signature**: `IntegerField(max_value=None, min_value=None)`

    - `max_value` Validate that the number provided is no greater than this value.
    - `min_value` Validate that the number provided is no less than this value.

    &nbsp;
- name: IPAddressField
  id: api-guide/fields/index#ipaddressfield
  summary: A field that ensures the input is a valid IPv4 or IPv6 string
  belongs_to: Serializer fields
  description: |-
    ## IPAddressField

    A field that ensures the input is a valid IPv4 or IPv6 string.

    Corresponds to `django.forms.fields.IPAddressField` and `django.forms.fields.GenericIPAddressField`.

    **Signature**: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`

    - `protocol` Limits valid inputs to the specified protocol. Accepted values are 'both' (default), 'IPv4' or 'IPv6'. Matching is case-insensitive.
    - `unpack_ipv4` Unpacks IPv4 mapped addresses like ::ffff:192.0.2.1. If this option is enabled that address would be unpacked to 192.0.2.1. Default is disabled. Can only be used when protocol is set to 'both'.

    # Numeric fields
- name: IsAdminUser
  id: api-guide/permissions/index#isadminuser
  summary: The IsAdminUser permission class will deny permission to any user, unless user.is_staff is True in which case permission will be allowed
  belongs_to: Permissions
  description: |-
    ## IsAdminUser

    The `IsAdminUser` permission class will deny permission to any user, unless `user.is_staff` is `True` in which case permission will be allowed.

    This permission is suitable if you want your API to only be accessible to a subset of trusted administrators.
- name: IsAuthenticated
  id: api-guide/permissions/index#isauthenticated
  summary: The IsAuthenticated permission class will deny permission to any unauthenticated user, and allow permission otherwise
  belongs_to: Permissions
  description: |-
    ## IsAuthenticated

    The `IsAuthenticated` permission class will deny permission to any unauthenticated user, and allow permission otherwise.

    This permission is suitable if you want your API to only be accessible to registered users.
- name: IsAuthenticatedOrReadOnly
  id: api-guide/permissions/index#isauthenticatedorreadonly
  summary: The IsAuthenticatedOrReadOnly will allow authenticated users to perform any request
  belongs_to: Permissions
  description: |-
    ## IsAuthenticatedOrReadOnly

    The `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any request. Requests for unauthenticated users will only be permitted if the request method is one of the "safe" methods; `GET`, `HEAD` or `OPTIONS`.

    This permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.
- name: JSONField
  id: api-guide/fields/index#jsonfield
  summary: A field class that validates that the incoming data structure consists of valid JSON primitives
  belongs_to: Serializer fields
  description: |-
    ## JSONField

    A field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.

    **Signature**: `JSONField(binary, encoder)`

    - `binary` - If set to `True` then the field will output and validate a JSON encoded string, rather than a primitive data structure. Defaults to `False`.
    - `encoder` - Use this JSON encoder to serialize input object. Defaults to `None`.

    # Miscellaneous fields
- name: JSONParser
  id: api-guide/parsers/index#jsonparser
  summary: Parses JSON request content
  belongs_to: Parsers
  description: |-
    ## JSONParser

    Parses `JSON` request content. `request.data` will be populated with a dictionary of data.

    **.media_type**: `application/json`
- name: JSONRenderer
  id: api-guide/renderers/index#jsonrenderer
  summary: Renders the request data into JSON, using utf-8 encoding
  belongs_to: Renderers
  description: |-
    ## JSONRenderer

    Renders the request data into `JSON`, using utf-8 encoding.

    Note that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:

    ``` python
    {"unicode black star":"★","value":999}
    ```

    The client may additionally include an `'indent'` media type parameter, in which case the returned `JSON` will be indented. For example `Accept: application/json; indent=4`.

    ``` python
    {
        "unicode black star": "★",
        "value": 999
    }
    ```

    The default JSON encoding style can be altered using the `UNICODE_JSON` and `COMPACT_JSON` settings keys.

    **.media_type**: `application/json`

    **.format**: `'json'`

    **.charset**: `None`
- name: LimitOffsetPagination
  id: api-guide/pagination/index#limitoffsetpagination
  summary: This pagination style mirrors the syntax used when looking up multiple database records
  belongs_to: Pagination
  description: |-
    ## LimitOffsetPagination

    This pagination style mirrors the syntax used when looking up multiple database records. The client includes both a "limit" and an "offset" query parameter. The limit indicates the maximum number of items to return, and is equivalent to the `page_size` in other styles. The offset indicates the starting position of the query in relation to the complete set of unpaginated items.

    **Request**:

    ``` python
    GET https://api.example.org/accounts/?limit=100&offset=400
    ```

    **Response**:

    ``` python
    HTTP 200 OK
    {
        "count": 1023,
        "next": "https://api.example.org/accounts/?limit=100&offset=500",
        "previous": "https://api.example.org/accounts/?limit=100&offset=300",
        "results": [
           …
        ]
    }
    ```

    #### Setup

    To enable the `LimitOffsetPagination` style globally, use the following configuration:

    ``` python
    REST_FRAMEWORK = {
        'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination'
    }
    ```

    Optionally, you may also set a `PAGE_SIZE` key. If the `PAGE_SIZE` parameter is also used then the `limit` query parameter will be optional, and may be omitted by the client.

    On `GenericAPIView` subclasses you may also set the `pagination_class` attribute to select `LimitOffsetPagination` on a per-view basis.

    #### Configuration

    The `LimitOffsetPagination` class includes a number of attributes that may be overridden to modify the pagination style.

    To set these attributes you should override the `LimitOffsetPagination` class, and then enable your custom pagination class as above.

    - `default_limit` - A numeric value indicating the limit to use if one is not provided by the client in a query parameter. Defaults to the same value as the `PAGE_SIZE` settings key.
    - `limit_query_param` - A string value indicating the name of the "limit" query parameter. Defaults to `'limit'`.
    - `offset_query_param` - A string value indicating the name of the "offset" query parameter. Defaults to `'offset'`.
    - `max_limit` - If set this is a numeric value indicating the maximum allowable limit that may be requested by the client. Defaults to `None`.
    - `template` - The name of a template to use when rendering pagination controls in the browsable API. May be overridden to modify the rendering style, or set to `None` to disable HTML pagination controls completely. Defaults to `"rest_framework/pagination/numbers.html"`.

    &nbsp;
- name: ListAPIView
  id: api-guide/generic-views/index#listapiview
  summary: Used for read-only endpoints to represent a collection of model instances
  belongs_to: Generic views
  description: |-
    ## ListAPIView

    Used for **read-only** endpoints to represent a **collection of model instances**.

    Provides a `get` method handler.

    Extends: [GenericAPIView](#genericapiview), [ListModelMixin](#listmodelmixin)
- name: ListCreateAPIView
  id: api-guide/generic-views/index#listcreateapiview
  summary: Used for read-write endpoints to represent a collection of model instances
  belongs_to: Generic views
  description: |-
    ## ListCreateAPIView

    Used for **read-write** endpoints to represent a **collection of model instances**.

    Provides `get` and `post` method handlers.

    Extends: [GenericAPIView](#genericapiview), [ListModelMixin](#listmodelmixin), [CreateModelMixin](#createmodelmixin)
- name: ListField
  id: api-guide/fields/index#listfield
  summary: A field class that validates a list of objects
  belongs_to: Serializer fields
  description: |-
    ## ListField

    A field class that validates a list of objects.

    **Signature**: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)`

    - `child` - A field instance that should be used for validating the objects in the list. If this argument is not provided then objects in the list will not be validated.
    - `allow_empty` - Designates if empty lists are allowed.
    - `min_length` - Validates that the list contains no fewer than this number of elements.
    - `max_length` - Validates that the list contains no more than this number of elements.

    For example, to validate a list of integers you might use something like the following:

    ``` python
    scores = serializers.ListField(
       child=serializers.IntegerField(min_value=0, max_value=100)
    )
    ```

    The `ListField` class also supports a declarative style that allows you to write reusable list field classes.

    ``` python
    class StringListField(serializers.ListField):
        child = serializers.CharField()
    ```

    We can now reuse our custom `StringListField` class throughout our application, without having to provide a `child` argument to it.
- name: ListModelMixin
  id: api-guide/generic-views/index#listmodelmixin
  summary: Provides a .list(request, *args, **kwargs) method, that implements listing a queryset
  belongs_to: Generic views
  description: |-
    ## ListModelMixin

    Provides a `.list(request, *args, **kwargs)` method, that implements listing a queryset.

    If the queryset is populated, this returns a `200 OK` response, with a serialized representation of the queryset as the body of the response. The response data may optionally be paginated.
- name: ListSerializer
  id: api-guide/serializers/index#listserializer
  summary: The ListSerializer class provides the behavior for serializing and validating multiple objects at once
  belongs_to: Serializers
  description: |-
    # ListSerializer

    The `ListSerializer` class provides the behavior for serializing and validating multiple objects at once. You won't *typically* need to use `ListSerializer` directly, but should instead simply pass `many=True` when instantiating a serializer.

    When a serializer is instantiated and `many=True` is passed, a `ListSerializer` instance will be created. The serializer class then becomes a child of the parent `ListSerializer`

    The following argument can also be passed to a `ListSerializer` field or a serializer that is passed `many=True`:

    ### allow_empty

    This is `True` by default, but can be set to `False` if you want to disallow empty lists as valid input.

    ### max_length

    This is `None` by default, but can be set to a positive integer if you want to validate that the list contains no more than this number of elements.

    ### min_length

    This is `None` by default, but can be set to a positive integer if you want to validate that the list contains no fewer than this number of elements.

    ### Customizing ListSerializer behavior

    There *are* a few use cases when you might want to customize the `ListSerializer` behavior. For example:

    - You want to provide particular validation of the lists, such as checking that one element does not conflict with another element in a list.
    - You want to customize the create or update behavior of multiple objects.

    For these cases you can modify the class that is used when `many=True` is passed, by using the `list_serializer_class` option on the serializer `Meta` class.

    For example:

    ``` python
    class CustomListSerializer(serializers.ListSerializer):
        ...

    class CustomSerializer(serializers.Serializer):
        ...
        class Meta:
            list_serializer_class = CustomListSerializer
    ```

    #### Customizing multiple create

    The default implementation for multiple object creation is to simply call `.create()` for each item in the list. If you want to customize this behavior, you'll need to customize the `.create()` method on `ListSerializer` class that is used when `many=True` is passed.

    For example:

    ``` python
    class BookListSerializer(serializers.ListSerializer):
        def create(self, validated_data):
            books = [Book(**item) for item in validated_data]
            return Book.objects.bulk_create(books)

    class BookSerializer(serializers.Serializer):
        ...
        class Meta:
            list_serializer_class = BookListSerializer
    ```

    #### Customizing multiple update

    By default the `ListSerializer` class does not support multiple updates. This is because the behavior that should be expected for insertions and deletions is ambiguous.

    To support multiple updates you'll need to do so explicitly. When writing your multiple update code make sure to keep the following in mind:

    - How do you determine which instance should be updated for each item in the list of data?
    - How should insertions be handled? Are they invalid, or do they create new objects?
    - How should removals be handled? Do they imply object deletion, or removing a relationship? Should they be silently ignored, or are they invalid?
    - How should ordering be handled? Does changing the position of two items imply any state change or is it ignored?

    You will need to add an explicit `id` field to the instance serializer. The default implicitly-generated `id` field is marked as `read_only`. This causes it to be removed on updates. Once you declare it explicitly, it will be available in the list serializer's `update` method.

    Here's an example of how you might choose to implement multiple updates:

    ``` python
    class BookListSerializer(serializers.ListSerializer):
        def update(self, instance, validated_data):
            # Maps for id->instance and id->data item.
            book_mapping = {book.id: book for book in instance}
            data_mapping = {item['id']: item for item in validated_data}

            # Perform creations and updates.
            ret = []
            for book_id, data in data_mapping.items():
                book = book_mapping.get(book_id, None)
                if book is None:
                    ret.append(self.child.create(data))
                else:
                    ret.append(self.child.update(book, data))

            # Perform deletions.
            for book_id, book in book_mapping.items():
                if book_id not in data_mapping:
                    book.delete()

            return ret

    class BookSerializer(serializers.Serializer):
        # We need to identify elements in the list using their primary key,
        # so use a writable field here, rather than the default which would be read-only.
        id = serializers.IntegerField()
        ...

        class Meta:
            list_serializer_class = BookListSerializer
    ```

    #### Customizing ListSerializer initialization

    When a serializer with `many=True` is instantiated, we need to determine which arguments and keyword arguments should be passed to the `.__init__()` method for both the child `Serializer` class, and for the parent `ListSerializer` class.

    The default implementation is to pass all arguments to both classes, except for `validators`, and any custom keyword arguments, both of which are assumed to be intended for the child serializer class.

    Occasionally you might need to explicitly specify how the child and parent classes should be instantiated when `many=True` is passed. You can do so by using the `many_init` class method.

    ``` python
        @classmethod
        def many_init(cls, *args, **kwargs):
            # Instantiate the child serializer.
            kwargs['child'] = cls()
            # Instantiate the parent list serializer.
            return CustomListSerializer(*args, **kwargs)
    ```
- name: Metadata
  id: api-guide/metadata/index
  summary: '[The OPTIONS] method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval'
  description: "# Metadata\n\n> \\[The `OPTIONS`\\] method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.\n>\n> — [RFC7231, Section 4.3.7.](https://tools.ietf.org/html/rfc7231#section-4.3.7)\n\nREST framework includes a configurable mechanism for determining how your API should respond to `OPTIONS` requests. This allows you to return API schema or other resource information.\n\nThere are not currently any widely adopted conventions for exactly what style of response should be returned for HTTP `OPTIONS` requests, so we provide an ad-hoc style that returns some useful information.\n\nHere's an example response that demonstrates the information that is returned by default.\n\n``` python\nHTTP 200 OK\nAllow: GET, POST, HEAD, OPTIONS\nContent-Type: application/json\n\n{\n    \"name\": \"To Do List\",\n    \"description\": \"List existing 'To Do' items, or create a new item.\",\n    \"renders\": [\n        \"application/json\",\n        \"text/html\"\n    ],\n    \"parses\": [\n        \"application/json\",\n        \"application/x-www-form-urlencoded\",\n        \"multipart/form-data\"\n    ],\n    \"actions\": {\n        \"POST\": {\n            \"note\": {\n                \"type\": \"string\",\n                \"required\": false,\n                \"read_only\": false,\n                \"label\": \"title\",\n                \"max_length\": 100\n            }\n        }\n    }\n}\n```\n\n## Setting the metadata scheme\n\nYou can set the metadata class globally using the `'DEFAULT_METADATA_CLASS'` settings key:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_METADATA_CLASS': 'rest_framework.metadata.SimpleMetadata'\n}\n```\n\nOr you can set the metadata class individually for a view:\n\n``` python\nclass APIRoot(APIView):\n    metadata_class = APIRootMetadata\n\n    def get(self, request, format=None):\n        return Response({\n            ...\n        })\n```\n\nThe REST framework package only includes a single metadata class implementation, named `SimpleMetadata`. If you want to use an alternative style you'll need to implement a custom metadata class.\n\n## Creating schema endpoints\n\nIf you have specific requirements for creating schema endpoints that are accessed with regular `GET` requests, you might consider re-using the metadata API for doing so.\n\nFor example, the following additional route could be used on a viewset to provide a linkable schema endpoint.\n\n``` python\n@action(methods=['GET'], detail=False)\ndef api_schema(self, request):\n    meta = self.metadata_class()\n    data = meta.determine_metadata(request, self)\n    return Response(data)\n```\n\nThere are a couple of reasons that you might choose to take this approach, including that `OPTIONS` responses [are not cacheable](https://www.mnot.net/blog/2012/10/29/NO_OPTIONS).\n\n# Custom metadata classes\n\nIf you want to provide a custom metadata class you should override `BaseMetadata` and implement the `determine_metadata(self, request, view)` method.\n\nUseful things that you might want to do could include returning schema information, using a format such as [JSON schema](https://json-schema.org/), or returning debug information to admin users.\n\n## Example\n\nThe following class could be used to limit the information that is returned to `OPTIONS` requests.\n\n``` python\nclass MinimalMetadata(BaseMetadata):\n    \"\"\"\n    Don't include field and other information for `OPTIONS` requests.\n    Just return the name and description.\n    \"\"\"\n    def determine_metadata(self, request, view):\n        return {\n            'name': view.get_view_name(),\n            'description': view.get_view_description()\n        }\n```\n\nThen configure your settings to use this custom class:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_METADATA_CLASS': 'myproject.apps.core.MinimalMetadata'\n}\n```\n\n# Third party packages\n\nThe following third party packages provide additional metadata implementations.\n\n## DRF-schema-adapter\n\n[drf-schema-adapter](https://github.com/drf-forms/drf-schema-adapter) is a set of tools that makes it easier to provide schema information to frontend frameworks and libraries. It provides a metadata mixin as well as 2 metadata classes and several adapters suitable to generate [json-schema](https://json-schema.org/) as well as schema information readable by various libraries.\n\nYou can also write your own adapter to work with your specific frontend. If you wish to do so, it also provides an exporter that can export those schema information to json files.\n\n[metadata.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/metadata.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/metadata/](https://www.django-rest-framework.org/api-guide/metadata/)"
- name: MethodNotAllowed
  id: api-guide/exceptions/index#methodnotallowed
  summary: Raised when an incoming request occurs that does not map to a handler method on the view
  belongs_to: Exceptions
  description: |-
    ## MethodNotAllowed

    **Signature:** `MethodNotAllowed(method, detail=None, code=None)`

    Raised when an incoming request occurs that does not map to a handler method on the view.

    By default this exception results in a response with the HTTP status code "405 Method Not Allowed".
- name: Miscellaneous settings
  id: api-guide/settings/index#miscellaneous-settings
  summary: A string representing the function that should be used when returning a response for any given exception
  belongs_to: Settings
  description: "## Miscellaneous settings\n\n#### EXCEPTION_HANDLER\n\nA string representing the function that should be used when returning a response for any given exception. If the function returns `None`, a 500 error will be raised.\n\nThis setting can be changed to support error responses other than the default `{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide API responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\n``` python\nexception_handler(exc, context)\n```\n\n- `exc`: The exception.\n\nDefault: `'rest_framework.views.exception_handler'`\n\n#### NON_FIELD_ERRORS_KEY\n\nA string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\n#### URL_FIELD_NAME\n\nA string representing the key that should be used for the URL fields generated by `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\n#### NUM_PROXIES\n\nAn integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to `None` then less strict IP matching will be used by the throttle classes.\n\nDefault: `None`\n\n[settings.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/settings.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/settings/](https://www.django-rest-framework.org/api-guide/settings/)"
- name: ModelField
  id: api-guide/fields/index#modelfield
  summary: A generic field that can be tied to any arbitrary model field
  belongs_to: Serializer fields
  description: |-
    ## ModelField

    A generic field that can be tied to any arbitrary model field. The `ModelField` class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.

    This field is used by `ModelSerializer` to correspond to custom model field classes.

    **Signature:** `ModelField(model_field=<Django ModelField instance>)`

    The `ModelField` class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a `ModelField`, it must be passed a field that is attached to an instantiated model. For example: `ModelField(model_field=MyModel()._meta.get_field('custom_field'))`
- name: ModelSerializer
  id: api-guide/serializers/index#modelserializer
  summary: Often you'll want serializer classes that map closely to Django model definitions
  belongs_to: Serializers
  description: |-
    # ModelSerializer

    Often you'll want serializer classes that map closely to Django model definitions.

    The `ModelSerializer` class provides a shortcut that lets you automatically create a `Serializer` class with fields that correspond to the Model fields.

    **The `ModelSerializer` class is the same as a regular `Serializer` class, except that**:

    - It will automatically generate a set of fields for you, based on the model.
    - It will automatically generate validators for the serializer, such as unique_together validators.
    - It includes simple default implementations of `.create()` and `.update()`.

    Declaring a `ModelSerializer` looks like this:

    ``` python
    class AccountSerializer(serializers.ModelSerializer):
        class Meta:
            model = Account
            fields = ['id', 'account_name', 'users', 'created']
    ```

    By default, all the model fields on the class will be mapped to a corresponding serializer fields.

    Any relationships such as foreign keys on the model will be mapped to `PrimaryKeyRelatedField`. Reverse relationships are not included by default unless explicitly included as specified in the [serializer relations](../relations/index) documentation.

    #### Inspecting a ModelSerializer

    Serializer classes generate helpful verbose representation strings, that allow you to fully inspect the state of their fields. This is particularly useful when working with `ModelSerializers` where you want to determine what set of fields and validators are being automatically created for you.

    To do so, open the Django shell, using `python manage.py shell`, then import the serializer class, instantiate it, and print the object representation…

    ``` python
    >>> from myapp.serializers import AccountSerializer
    >>> serializer = AccountSerializer()
    >>> print(repr(serializer))
    AccountSerializer():
        id = IntegerField(label='ID', read_only=True)
        name = CharField(allow_blank=True, max_length=100, required=False)
        owner = PrimaryKeyRelatedField(queryset=User.objects.all())
    ```

    ## Specifying which fields to include

    If you only want a subset of the default fields to be used in a model serializer, you can do so using `fields` or `exclude` options, just as you would with a `ModelForm`. It is strongly recommended that you explicitly set all fields that should be serialized using the `fields` attribute. This will make it less likely to result in unintentionally exposing data when your models change.

    For example:

    ``` python
    class AccountSerializer(serializers.ModelSerializer):
        class Meta:
            model = Account
            fields = ['id', 'account_name', 'users', 'created']
    ```

    You can also set the `fields` attribute to the special value `'__all__'` to indicate that all fields in the model should be used.

    For example:

    ``` python
    class AccountSerializer(serializers.ModelSerializer):
        class Meta:
            model = Account
            fields = '__all__'
    ```

    You can set the `exclude` attribute to a list of fields to be excluded from the serializer.

    For example:

    ``` python
    class AccountSerializer(serializers.ModelSerializer):
        class Meta:
            model = Account
            exclude = ['users']
    ```

    In the example above, if the `Account` model had 3 fields `account_name`, `users`, and `created`, this will result in the fields `account_name` and `created` to be serialized.

    The names in the `fields` and `exclude` attributes will normally map to model fields on the model class.

    Alternatively names in the `fields` options can map to properties or methods which take no arguments that exist on the model class.

    Since version 3.3.0, it is **mandatory** to provide one of the attributes `fields` or `exclude`.

    ## Specifying nested serialization

    The default `ModelSerializer` uses primary keys for relationships, but you can also easily generate nested representations using the `depth` option:

    ``` python
    class AccountSerializer(serializers.ModelSerializer):
        class Meta:
            model = Account
            fields = ['id', 'account_name', 'users', 'created']
            depth = 1
    ```

    The `depth` option should be set to an integer value that indicates the depth of relationships that should be traversed before reverting to a flat representation.

    If you want to customize the way the serialization is done you'll need to define the field yourself.

    ## Specifying fields explicitly

    You can add extra fields to a `ModelSerializer` or override the default fields by declaring fields on the class, just as you would for a `Serializer` class.

    ``` python
    class AccountSerializer(serializers.ModelSerializer):
        url = serializers.CharField(source='get_absolute_url', read_only=True)
        groups = serializers.PrimaryKeyRelatedField(many=True)

        class Meta:
            model = Account
            fields = ['url', 'groups']
    ```

    Extra fields can correspond to any property or callable on the model.

    ## Specifying read only fields

    You may wish to specify multiple fields as read-only. Instead of adding each field explicitly with the `read_only=True` attribute, you may use the shortcut Meta option, `read_only_fields`.

    This option should be a list or tuple of field names, and is declared as follows:

    ``` python
    class AccountSerializer(serializers.ModelSerializer):
        class Meta:
            model = Account
            fields = ['id', 'account_name', 'users', 'created']
            read_only_fields = ['account_name']
    ```

    Model fields which have `editable=False` set, and `AutoField` fields will be set to read-only by default, and do not need to be added to the `read_only_fields` option.

    **Note**: There is a special-case where a read-only field is part of a `unique_together` constraint at the model level. In this case the field is required by the serializer class in order to validate the constraint, but should also not be editable by the user.

    The right way to deal with this is to specify the field explicitly on the serializer, providing both the `read_only=True` and `default=…` keyword arguments.

    One example of this is a read-only relation to the currently authenticated `User` which is `unique_together` with another identifier. In this case you would declare the user field like so:

    ``` python
    user = serializers.PrimaryKeyRelatedField(read_only=True, default=serializers.CurrentUserDefault())
    ```

    Please review the [Validators Documentation](../validators/index) for details on the [UniqueTogetherValidator](../validators/index#uniquetogethervalidator) and [CurrentUserDefault](../validators/index#currentuserdefault) classes.

    ## Additional keyword arguments

    There is also a shortcut allowing you to specify arbitrary additional keyword arguments on fields, using the `extra_kwargs` option. As in the case of `read_only_fields`, this means you do not need to explicitly declare the field on the serializer.

    This option is a dictionary, mapping field names to a dictionary of keyword arguments. For example:

    ``` python
    class CreateUserSerializer(serializers.ModelSerializer):
        class Meta:
            model = User
            fields = ['email', 'username', 'password']
            extra_kwargs = {'password': {'write_only': True}}

        def create(self, validated_data):
            user = User(
                email=validated_data['email'],
                username=validated_data['username']
            )
            user.set_password(validated_data['password'])
            user.save()
            return user
    ```

    Please keep in mind that, if the field has already been explicitly declared on the serializer class, then the `extra_kwargs` option will be ignored.

    ## Relational fields

    When serializing model instances, there are a number of different ways you might choose to represent relationships. The default representation for `ModelSerializer` is to use the primary keys of the related instances.

    Alternative representations include serializing using hyperlinks, serializing complete nested representations, or serializing with a custom representation.

    For full details see the [serializer relations](../relations/index) documentation.

    ## Customizing field mappings

    The ModelSerializer class also exposes an API that you can override in order to alter how serializer fields are automatically determined when instantiating the serializer.

    Normally if a `ModelSerializer` does not generate the fields you need by default then you should either add them to the class explicitly, or simply use a regular `Serializer` class instead. However in some cases you may want to create a new base class that defines how the serializer fields are created for any given model.

    ### serializer_field_mapping

    A mapping of Django model fields to REST framework serializer fields. You can override this mapping to alter the default serializer fields that should be used for each model field.

    ### serializer_related_field

    This property should be the serializer field class, that is used for relational fields by default.

    For `ModelSerializer` this defaults to `serializers.PrimaryKeyRelatedField`.

    For `HyperlinkedModelSerializer` this defaults to `serializers.HyperlinkedRelatedField`.

    ### serializer_url_field

    The serializer field class that should be used for any `url` field on the serializer.

    Defaults to `serializers.HyperlinkedIdentityField`

    ### serializer_choice_field

    The serializer field class that should be used for any choice fields on the serializer.

    Defaults to `serializers.ChoiceField`

    ### The field_class and field_kwargs API

    The following methods are called to determine the class and keyword arguments for each field that should be automatically included on the serializer. Each of these methods should return a two tuple of `(field_class, field_kwargs)`.

    ### build_standard_field(self, field_name, model_field)

    Called to generate a serializer field that maps to a standard model field.

    The default implementation returns a serializer class based on the `serializer_field_mapping` attribute.

    ### build_relational_field(self, field_name, relation_info)

    Called to generate a serializer field that maps to a relational model field.

    The default implementation returns a serializer class based on the `serializer_related_field` attribute.

    The `relation_info` argument is a named tuple, that contains `model_field`, `related_model`, `to_many` and `has_through_model` properties.

    ### build_nested_field(self, field_name, relation_info, nested_depth)

    Called to generate a serializer field that maps to a relational model field, when the `depth` option has been set.

    The default implementation dynamically creates a nested serializer class based on either `ModelSerializer` or `HyperlinkedModelSerializer`.

    The `nested_depth` will be the value of the `depth` option, minus one.

    The `relation_info` argument is a named tuple, that contains `model_field`, `related_model`, `to_many` and `has_through_model` properties.

    ### build_property_field(self, field_name, model_class)

    Called to generate a serializer field that maps to a property or zero-argument method on the model class.

    The default implementation returns a `ReadOnlyField` class.

    ### build_url_field(self, field_name, model_class)

    Called to generate a serializer field for the serializer's own `url` field. The default implementation returns a `HyperlinkedIdentityField` class.

    ### build_unknown_field(self, field_name, model_class)

    Called when the field name did not map to any model field or model property. The default implementation raises an error, although subclasses may customize this behavior.
- name: ModelViewSet
  id: api-guide/viewsets/index#modelviewset
  summary: The ModelViewSet class inherits from GenericAPIView and includes implementations for various actions, by mixing in the behavior of the various mixin classes
  belongs_to: ViewSets
  description: |-
    ## ModelViewSet

    The `ModelViewSet` class inherits from `GenericAPIView` and includes implementations for various actions, by mixing in the behavior of the various mixin classes.

    The actions provided by the `ModelViewSet` class are `.list()`, `.retrieve()`, `.create()`, `.update()`, `.partial_update()`, and `.destroy()`.

    #### Example

    Because `ModelViewSet` extends `GenericAPIView`, you'll normally need to provide at least the `queryset` and `serializer_class` attributes. For example:

    ``` python
    class AccountViewSet(viewsets.ModelViewSet):
        """
        A simple ViewSet for viewing and editing accounts.
        """
        queryset = Account.objects.all()
        serializer_class = AccountSerializer
        permission_classes = [IsAccountAdminOrReadOnly]
    ```

    Note that you can use any of the standard attributes or method overrides provided by `GenericAPIView`. For example, to use a `ViewSet` that dynamically determines the queryset it should operate on, you might do something like this:

    ``` python
    class AccountViewSet(viewsets.ModelViewSet):
        """
        A simple ViewSet for viewing and editing the accounts
        associated with the user.
        """
        serializer_class = AccountSerializer
        permission_classes = [IsAccountAdminOrReadOnly]

        def get_queryset(self):
            return self.request.user.accounts.all()
    ```

    Note however that upon removal of the `queryset` property from your `ViewSet`, any associated [router](../routers/index) will be unable to derive the basename of your Model automatically, and so you will have to specify the `basename` kwarg as part of your [router registration](../routers/index).

    Also note that although this class provides the complete set of create/list/retrieve/update/destroy actions by default, you can restrict the available operations by using the standard permission classes.
- name: MultiPartParser
  id: api-guide/parsers/index#multipartparser
  summary: Parses multipart HTML form content, which supports file uploads
  belongs_to: Parsers
  description: |-
    ## MultiPartParser

    Parses multipart HTML form content, which supports file uploads. `request.data` and `request.FILES` will be populated with a `QueryDict` and `MultiValueDict` respectively.

    You will typically want to use both `FormParser` and `MultiPartParser` together in order to fully support HTML form data.

    **.media_type**: `multipart/form-data`
- name: MultiPartRenderer
  id: api-guide/renderers/index#multipartrenderer
  summary: This renderer is used for rendering HTML multipart form data
  belongs_to: Renderers
  description: "## MultiPartRenderer\n\nThis renderer is used for rendering HTML multipart form data. **It is not suitable as a response renderer**, but is instead used for creating test requests, using REST framework's [test client and test request factory](../testing/index).\n\n**.media_type**: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n**.format**: `'multipart'`\n\n**.charset**: `utf-8`\n\n# Custom renderers\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the `.media_type` and `.format` properties, and implement the `.render(self, data, accepted_media_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the HTTP response.\n\nThe arguments passed to the `.render()` method are:\n\n### data\n\nThe request data, as set by the `Response()` instantiation.\n\n### accepted_media_type=None\n\nOptional. If provided, this is the accepted media type, as determined by the content negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the renderer's `media_type` attribute, and may include media type parameters. For example `\"application/json; nested=true\"`.\n\n### renderer_context=None\n\nOptional. If provided, this is a dictionary of contextual information provided by the view.\n\nBy default this will include the following keys: `view`, `request`, `response`, `args`, `kwargs`.\n\n## Example\n\nThe following is an example plaintext renderer that will return a response with the `data` parameter as the content of the response.\n\n``` python\nfrom django.utils.encoding import smart_str\nfrom rest_framework import renderers\n\n\nclass PlainTextRenderer(renderers.BaseRenderer):\n    media_type = 'text/plain'\n    format = 'txt'\n\n    def render(self, data, accepted_media_type=None, renderer_context=None):\n        return smart_str(data, encoding=self.charset)\n```\n\n## Setting the character set\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To use a different encoding, set the `charset` attribute on the renderer.\n\n``` python\nclass PlainTextRenderer(renderers.BaseRenderer):\n    media_type = 'text/plain'\n    format = 'txt'\n    charset = 'iso-8859-1'\n\n    def render(self, data, accepted_media_type=None, renderer_context=None):\n        return data.encode(self.charset)\n```\n\nNote that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the `Response` class, with the `charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you should set a charset value of `None`, which will ensure the `Content-Type` header of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to `'binary'`. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.\n\n``` python\nclass JPEGRenderer(renderers.BaseRenderer):\n    media_type = 'image/jpeg'\n    format = 'jpg'\n    charset = None\n    render_style = 'binary'\n\n    def render(self, data, accepted_media_type=None, renderer_context=None):\n        return data\n```\n\n# Advanced renderer usage\n\nYou can do some pretty flexible things using REST framework's renderers. Some examples...\n\n- Provide either flat or nested representations from the same endpoint, depending on the requested media type.\n- Serve both regular HTML webpages, and JSON based API responses from the same endpoints.\n- Specify multiple types of HTML representation for API clients to use.\n- Underspecify a renderer's media type, such as using `media_type = 'image/*'`, and use the `Accept` header to vary the encoding of the response.\n\n## Varying behavior by media type\n\nIn some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access `request.accepted_renderer` to determine the negotiated renderer that will be used for the response.\n\nFor example:\n\n``` python\n@api_view(['GET'])\n@renderer_classes([TemplateHTMLRenderer, JSONRenderer])\ndef list_users(request):\n    \"\"\"\n    A view that can return JSON or HTML representations\n    of the users in the system.\n    \"\"\"\n    queryset = Users.objects.filter(active=True)\n\n    if request.accepted_renderer.format == 'html':\n        # TemplateHTMLRenderer takes a context dict,\n        # and additionally requires a 'template_name'.\n        # It does not require serialization.\n        data = {'users': queryset}\n        return Response(data, template_name='list_users.html')\n\n    # JSONRenderer requires serialized data as normal.\n    serializer = UserSerializer(instance=queryset)\n    data = serializer.data\n    return Response(data)\n```\n\n## Underspecifying the media type\n\nIn some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the `content_type` attribute. For example:\n\n``` python\nreturn Response(data, content_type='image/png')\n```\n\n## Designing your media types\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and [HATEOAS](http://timelessrepo.com/haters-gonna-hateoas) you'll need to consider the design and usage of your media types in more detail.\n\nIn [the words of Roy Fielding](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven), \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom [application/vnd.github+json](https://developer.github.com/v3/media/) media type, and Mike Amundsen's IANA approved [application/vnd.collection+json](http://www.amundsen.com/media-types/collection/) JSON-based hypermedia.\n\n## HTML error views\n\nTypically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an `Http404` or `PermissionDenied` exception, or a subclass of `APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer` and an exception is raised, the behavior is slightly different, and mirrors [Django's default handling of error views](https://docs.djangoproject.com/en/stable/topics/http/views/#customizing-error-views).\n\nExceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.\n\n- Load and render a template named `{status_code}.html`.\n- Load and render a template named `api_exception.html`.\n- Render the HTTP status code and text, for example \"404 Not Found\".\n\nTemplates will render with a `RequestContext` which includes the `status_code` and `details` keys.\n\n**Note**: If `DEBUG=True`, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## YAML\n\n[REST framework YAML](https://jpadilla.github.io/django-rest-framework-yaml/) provides [YAML](http://www.yaml.org/) parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-yaml\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework_yaml.parsers.YAMLParser',\n    ],\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_yaml.renderers.YAMLRenderer',\n    ],\n}\n```\n\n## XML\n\n[REST Framework XML](https://jpadilla.github.io/django-rest-framework-xml/) provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-xml\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework_xml.parsers.XMLParser',\n    ],\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_xml.renderers.XMLRenderer',\n    ],\n}\n```\n\n## JSONP\n\n[REST framework JSONP](https://jpadilla.github.io/django-rest-framework-jsonp/) provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n**Warning**: If you require cross-domain AJAX requests, you should generally be using the more modern approach of [CORS](https://www.w3.org/TR/cors/) as an alternative to `JSONP`. See the [CORS documentation](https://www.django-rest-framework.org/topics/ajax-csrf-cors/) for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is [only appropriate for globally readable API endpoints](https://stackoverflow.com/questions/613962/is-jsonp-safe-to-use), where `GET` requests are unauthenticated and do not require any user permissions.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-jsonp\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_jsonp.renderers.JSONPRenderer',\n    ],\n}\n```\n\n## MessagePack\n\n[MessagePack](https://msgpack.org/) is a fast, efficient binary serialization format. [Juan Riaza](https://github.com/juanriaza) maintains the [djangorestframework-msgpack](https://github.com/juanriaza/django-rest-framework-msgpack) package which provides MessagePack renderer and parser support for REST framework.\n\n## Microsoft Excel: XLSX (Binary Spreadsheet Endpoints)\n\nXLSX is the world's most popular binary spreadsheet format. [Tim Allen](https://github.com/flipperpa) of [The Wharton School](https://github.com/wharton) maintains [drf-excel](https://github.com/wharton/drf-excel), which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install drf-excel\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    ...\n\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework.renderers.JSONRenderer',\n        'rest_framework.renderers.BrowsableAPIRenderer',\n        'drf_excel.renderers.XLSXRenderer',\n    ],\n}\n```\n\nTo avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the `Content-Disposition` header. If no filename is provided, it will default to `export.xlsx`. For example:\n\n``` python\nfrom rest_framework.viewsets import ReadOnlyModelViewSet\nfrom drf_excel.mixins import XLSXFileMixin\nfrom drf_excel.renderers import XLSXRenderer\n\nfrom .models import MyExampleModel\nfrom .serializers import MyExampleSerializer\n\nclass MyExampleViewSet(XLSXFileMixin, ReadOnlyModelViewSet):\n    queryset = MyExampleModel.objects.all()\n    serializer_class = MyExampleSerializer\n    renderer_classes = [XLSXRenderer]\n    filename = 'my_export.xlsx'\n```\n\n## CSV\n\nComma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. [Mjumbe Poe](https://github.com/mjumbewu) maintains the [djangorestframework-csv](https://github.com/mjumbewu/django-rest-framework-csv) package which provides CSV renderer support for REST framework.\n\n## UltraJSON\n\n[UltraJSON](https://github.com/esnme/ultrajson) is an optimized C JSON encoder which can give significantly faster JSON rendering. [Adam Mertz](https://github.com/Amertz08) maintains [drf_ujson2](https://github.com/Amertz08/drf_ujson2), a fork of the now unmaintained [drf-ujson-renderer](https://github.com/gizmag/drf-ujson-renderer), which implements JSON rendering using the UJSON package.\n\n## CamelCase JSON\n\n[djangorestframework-camel-case](https://github.com/vbabiy/djangorestframework-camel-case) provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by [Vitaly Babiy](https://github.com/vbabiy).\n\n## Pandas (CSV, Excel, PNG)\n\n[Django REST Pandas](https://github.com/wq/django-rest-pandas) provides a serializer and renderers that support additional data processing and output via the [Pandas](https://pandas.pydata.org/) DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both `.xls` and `.xlsx`), and a number of [other formats](https://github.com/wq/django-rest-pandas#supported-formats). It is maintained by [S. Andrew Sheppard](https://github.com/sheppard) as part of the [wq Project](https://github.com/wq).\n\n## LaTeX\n\n[Rest Framework Latex](https://github.com/mypebble/rest-framework-latex) provides a renderer that outputs PDFs using Laulatex. It is maintained by [Pebble (S/F Software)](https://github.com/mypebble).\n\n[renderers.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/renderers.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/renderers/](https://www.django-rest-framework.org/api-guide/renderers/)"
- name: MultipleChoiceField
  id: api-guide/fields/index#multiplechoicefield
  summary: A field that can accept a set of zero, one or many values, chosen from a limited set of choices
  belongs_to: Serializer fields
  description: |-
    ## MultipleChoiceField

    A field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. `to_internal_value` returns a `set` containing the selected values.

    **Signature:** `MultipleChoiceField(choices)`

    - `choices` - A list of valid values, or a list of `(key, display_name)` tuples.
    - `allow_blank` - If set to `True` then the empty string should be considered a valid value. If set to `False` then the empty string is considered invalid and will raise a validation error. Defaults to `False`.
    - `html_cutoff` - If set this will be the maximum number of choices that will be displayed by a HTML select drop down. Can be used to ensure that automatically generated ChoiceFields with very large possible selections do not prevent a template from rendering. Defaults to `None`.
    - `html_cutoff_text` - If set this will display a textual indicator if the maximum number of items have been cutoff in an HTML select drop down. Defaults to `"More than {count} items…"`

    As with `ChoiceField`, both the `allow_blank` and `allow_null` options are valid, although it is highly recommended that you only use one and not both. `allow_blank` should be preferred for textual choices, and `allow_null` should be preferred for numeric or other non-textual choices.

    # File upload fields

    #### Parsers and file uploads.

    The `FileField` and `ImageField` classes are only suitable for use with `MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't support file uploads. Django's regular [FILE_UPLOAD_HANDLERS](https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-FILE_UPLOAD_HANDLERS) are used for handling uploaded files.
- name: NamespaceVersioning
  id: api-guide/versioning/index#namespaceversioning
  summary: To the client, this scheme is the same as URLPathVersioning
  belongs_to: Versioning
  description: |-
    ## NamespaceVersioning

    To the client, this scheme is the same as `URLPathVersioning`. The only difference is how it is configured in your Django application, as it uses URL namespacing, instead of URL keyword arguments.

    ``` python
    GET /v1/something/ HTTP/1.1
    Host: example.com
    Accept: application/json
    ```

    With this scheme the `request.version` attribute is determined based on the `namespace` that matches the incoming request path.

    In the following example we're giving a set of views two different possible URL prefixes, each under a different namespace:

    ``` python
    # bookings/urls.py
    urlpatterns = [
        re_path(r'^$', bookings_list, name='bookings-list'),
        re_path(r'^(?P<pk>[0-9]+)/$', bookings_detail, name='bookings-detail')
    ]

    # urls.py
    urlpatterns = [
        re_path(r'^v1/bookings/', include('bookings.urls', namespace='v1')),
        re_path(r'^v2/bookings/', include('bookings.urls', namespace='v2'))
    ]
    ```

    Both `URLPathVersioning` and `NamespaceVersioning` are reasonable if you just need a simple versioning scheme. The `URLPathVersioning` approach might be better suitable for small ad-hoc projects, and the `NamespaceVersioning` is probably easier to manage for larger projects.
- name: NotAcceptable
  id: api-guide/exceptions/index#notacceptable
  summary: Raised when an incoming request occurs with an Accept header that cannot be satisfied by any of the available renderers
  belongs_to: Exceptions
  description: |-
    ## NotAcceptable

    **Signature:** `NotAcceptable(detail=None, code=None)`

    Raised when an incoming request occurs with an `Accept` header that cannot be satisfied by any of the available renderers.

    By default this exception results in a response with the HTTP status code "406 Not Acceptable".
- name: NotAuthenticated
  id: api-guide/exceptions/index#notauthenticated
  summary: Raised when an unauthenticated request fails the permission checks
  belongs_to: Exceptions
  description: |-
    ## NotAuthenticated

    **Signature:** `NotAuthenticated(detail=None, code=None)`

    Raised when an unauthenticated request fails the permission checks.

    By default this exception results in a response with the HTTP status code "401 Unauthenticated", but it may also result in a "403 Forbidden" response, depending on the authentication scheme in use. See the [authentication documentation](../authentication/index) for more details.
- name: NotFound
  id: api-guide/exceptions/index#notfound
  summary: Raised when a resource does not exist at the given URL
  belongs_to: Exceptions
  description: |-
    ## NotFound

    **Signature:** `NotFound(detail=None, code=None)`

    Raised when a resource does not exist at the given URL. This exception is equivalent to the standard `Http404` Django exception.

    By default this exception results in a response with the HTTP status code "404 Not Found".
- name: OrderingFilter
  id: api-guide/filtering/index#orderingfilter
  summary: The OrderingFilter class supports simple query parameter controlled ordering of results
  belongs_to: Filtering
  description: "## OrderingFilter\n\nThe `OrderingFilter` class supports simple query parameter controlled ordering of results.\n\nBy default, the query parameter is named `'ordering'`, but this may be overridden with the `ORDERING_PARAM` setting.\n\nFor example, to order users by username:\n\n``` python\nhttp://example.com/api/users?ordering=username\n```\n\nThe client may also specify reverse orderings by prefixing the field name with '-', like so:\n\n``` python\nhttp://example.com/api/users?ordering=-username\n```\n\nMultiple orderings may also be specified:\n\n``` python\nhttp://example.com/api/users?ordering=account,username\n```\n\n### Specifying which fields may be ordered against\n\nIt's recommended that you explicitly specify which fields the API should allow in the ordering filter. You can do this by setting an `ordering_fields` attribute on the view, like so:\n\n``` python\nclass UserListView(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    filter_backends = [filters.OrderingFilter]\n    ordering_fields = ['username', 'email']\n```\n\nThis helps prevent unexpected data leakage, such as allowing users to order against a password hash field or other sensitive data.\n\nIf you *don't* specify an `ordering_fields` attribute on the view, the filter class will default to allowing the user to filter on any readable fields on the serializer specified by the `serializer_class` attribute.\n\nIf you are confident that the queryset being used by the view doesn't contain any sensitive data, you can also explicitly specify that a view should allow ordering on *any* model field or queryset aggregate, by using the special value `'__all__'`.\n\n``` python\nclass BookingsListView(generics.ListAPIView):\n    queryset = Booking.objects.all()\n    serializer_class = BookingSerializer\n    filter_backends = [filters.OrderingFilter]\n    ordering_fields = '__all__'\n```\n\n### Specifying a default ordering\n\nIf an `ordering` attribute is set on the view, this will be used as the default ordering.\n\nTypically you'd instead control this by setting `order_by` on the initial queryset, but using the `ordering` parameter on the view allows you to specify the ordering in a way that it can then be passed automatically as context to a rendered template. This makes it possible to automatically render column headers differently if they are being used to order the results.\n\n``` python\nclass UserListView(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    filter_backends = [filters.OrderingFilter]\n    ordering_fields = ['username', 'email']\n    ordering = ['username']\n```\n\nThe `ordering` attribute may be either a string or a list/tuple of strings.\n\n# Custom generic filtering\n\nYou can also provide your own generic filtering backend, or write an installable app for other developers to use.\n\nTo do so override `BaseFilterBackend`, and override the `.filter_queryset(self, request, queryset, view)` method. The method should return a new, filtered queryset.\n\nAs well as allowing clients to perform searches and filtering, generic filter backends can be useful for restricting which objects should be visible to any given request or user.\n\n## Example\n\nFor example, you might need to restrict users to only being able to see objects they created.\n\n``` python\nclass IsOwnerFilterBackend(filters.BaseFilterBackend):\n    \"\"\"\n    Filter that only allows users to see their own objects.\n    \"\"\"\n    def filter_queryset(self, request, queryset, view):\n        return queryset.filter(owner=request.user)\n```\n\nWe could achieve the same behavior by overriding `get_queryset()` on the views, but using a filter backend allows you to more easily add this restriction to multiple views, or to apply it across the entire API.\n\n## Customizing the interface\n\nGeneric filters may also present an interface in the browsable API. To do so you should implement a `to_html()` method which returns a rendered HTML representation of the filter. This method should have the following signature:\n\n`to_html(self, request, queryset, view)`\n\nThe method should return a rendered HTML string.\n\n# Third party packages\n\nThe following third party packages provide additional filter implementations.\n\n## Django REST framework filters package\n\nThe [django-rest-framework-filters package](https://github.com/philipn/django-rest-framework-filters) works together with the `DjangoFilterBackend` class, and allows you to easily create filters across relationships, or create multiple filter lookup types for a given field.\n\n## Django REST framework full word search filter\n\nThe [djangorestframework-word-filter](https://github.com/trollknurr/django-rest-framework-word-search-filter) developed as alternative to `filters.SearchFilter` which will search full word in text, or exact match.\n\n## Django URL Filter\n\n[django-url-filter](https://github.com/miki725/django-url-filter) provides a safe way to filter data via human-friendly URLs. It works very similar to DRF serializers and fields in a sense that they can be nested except they are called filtersets and filters. That provides easy way to filter related data. Also this library is generic-purpose so it can be used to filter other sources of data and not only Django `QuerySet`s.\n\n## drf-url-filters\n\n[drf-url-filter](https://github.com/manjitkumar/drf-url-filters) is a simple Django app to apply filters on drf `ModelViewSet`'s `Queryset` in a clean, simple and configurable way. It also supports validations on incoming query params and their values. A beautiful python package `Voluptuous` is being used for validations on the incoming query parameters. The best part about voluptuous is you can define your own validations as per your query params requirements.\n\n[filters.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/filters.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/filtering/](https://www.django-rest-framework.org/api-guide/filtering/)"
- name: PageNumberPagination
  id: api-guide/pagination/index#pagenumberpagination
  summary: This pagination style accepts a single number page number in the request query parameters
  belongs_to: Pagination
  description: |-
    ## PageNumberPagination

    This pagination style accepts a single number page number in the request query parameters.

    **Request**:

    ``` python
    GET https://api.example.org/accounts/?page=4
    ```

    **Response**:

    ``` python
    HTTP 200 OK
    {
        "count": 1023,
        "next": "https://api.example.org/accounts/?page=5",
        "previous": "https://api.example.org/accounts/?page=3",
        "results": [
           …
        ]
    }
    ```

    #### Setup

    To enable the `PageNumberPagination` style globally, use the following configuration, and set the `PAGE_SIZE` as desired:

    ``` python
    REST_FRAMEWORK = {
        'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
        'PAGE_SIZE': 100
    }
    ```

    On `GenericAPIView` subclasses you may also set the `pagination_class` attribute to select `PageNumberPagination` on a per-view basis.

    #### Configuration

    The `PageNumberPagination` class includes a number of attributes that may be overridden to modify the pagination style.

    To set these attributes you should override the `PageNumberPagination` class, and then enable your custom pagination class as above.

    - `django_paginator_class` - The Django Paginator class to use. Default is `django.core.paginator.Paginator`, which should be fine for most use cases.
    - `page_size` - A numeric value indicating the page size. If set, this overrides the `PAGE_SIZE` setting. Defaults to the same value as the `PAGE_SIZE` settings key.
    - `page_query_param` - A string value indicating the name of the query parameter to use for the pagination control.
    - `page_size_query_param` - If set, this is a string value indicating the name of a query parameter that allows the client to set the page size on a per-request basis. Defaults to `None`, indicating that the client may not control the requested page size.
    - `max_page_size` - If set, this is a numeric value indicating the maximum allowable requested page size. This attribute is only valid if `page_size_query_param` is also set.
    - `last_page_strings` - A list or tuple of string values indicating values that may be used with the `page_query_param` to request the final page in the set. Defaults to `('last',)`
    - `template` - The name of a template to use when rendering pagination controls in the browsable API. May be overridden to modify the rendering style, or set to `None` to disable HTML pagination controls completely. Defaults to `"rest_framework/pagination/numbers.html"`.
- name: Pagination
  id: api-guide/pagination/index
  summary: Django provides a few classes that help you manage paginated data – that is, data that’s split across several pages, with “Previous/Next” links
  description: "# Pagination\n\n> Django provides a few classes that help you manage paginated data – that is, data that’s split across several pages, with “Previous/Next” links.\n>\n> — [Django documentation](https://docs.djangoproject.com/en/stable/topics/pagination/)\n\nREST framework includes support for customizable pagination styles. This allows you to modify how large result sets are split into individual pages of data.\n\nThe pagination API can support either:\n\n- Pagination links that are provided as part of the content of the response.\n- Pagination links that are included in response headers, such as `Content-Range` or `Link`.\n\nThe built-in styles currently all use links included as part of the content of the response. This style is more accessible when using the browsable API.\n\nPagination is only performed automatically if you're using the generic views or viewsets. If you're using a regular `APIView`, you'll need to call into the pagination API yourself to ensure you return a paginated response. See the source code for the `mixins.ListModelMixin` and `generics.GenericAPIView` classes for an example.\n\nPagination can be turned off by setting the pagination class to `None`.\n\n## Setting the pagination style\n\nThe pagination style may be set globally, using the `DEFAULT_PAGINATION_CLASS` and `PAGE_SIZE` setting keys. For example, to use the built-in limit/offset pagination, you would do something like this:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',\n    'PAGE_SIZE': 100\n}\n```\n\nNote that you need to set both the pagination class, and the page size that should be used. Both `DEFAULT_PAGINATION_CLASS` and `PAGE_SIZE` are `None` by default.\n\nYou can also set the pagination class on an individual view by using the `pagination_class` attribute. Typically you'll want to use the same pagination style throughout your API, although you might want to vary individual aspects of the pagination, such as default or maximum page size, on a per-view basis.\n\n## Modifying the pagination style\n\nIf you want to modify particular aspects of the pagination style, you'll want to override one of the pagination classes, and set the attributes that you want to change.\n\n``` python\nclass LargeResultsSetPagination(PageNumberPagination):\n    page_size = 1000\n    page_size_query_param = 'page_size'\n    max_page_size = 10000\n\nclass StandardResultsSetPagination(PageNumberPagination):\n    page_size = 100\n    page_size_query_param = 'page_size'\n    max_page_size = 1000\n```\n\nYou can then apply your new style to a view using the `pagination_class` attribute:\n\n``` python\nclass BillingRecordsView(generics.ListAPIView):\n    queryset = Billing.objects.all()\n    serializer_class = BillingRecordsSerializer\n    pagination_class = LargeResultsSetPagination\n```\n\nOr apply the style globally, using the `DEFAULT_PAGINATION_CLASS` settings key. For example:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'apps.core.pagination.StandardResultsSetPagination'\n}\n```\n\n# API Reference\n\n## PageNumberPagination\n\nThis pagination style accepts a single number page number in the request query parameters.\n\n**Request**:\n\n``` python\nGET https://api.example.org/accounts/?page=4\n```\n\n**Response**:\n\n``` python\nHTTP 200 OK\n{\n    \"count\": 1023,\n    \"next\": \"https://api.example.org/accounts/?page=5\",\n    \"previous\": \"https://api.example.org/accounts/?page=3\",\n    \"results\": [\n       …\n    ]\n}\n```\n\n#### Setup\n\nTo enable the `PageNumberPagination` style globally, use the following configuration, and set the `PAGE_SIZE` as desired:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',\n    'PAGE_SIZE': 100\n}\n```\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class` attribute to select `PageNumberPagination` on a per-view basis.\n\n#### Configuration\n\nThe `PageNumberPagination` class includes a number of attributes that may be overridden to modify the pagination style.\n\nTo set these attributes you should override the `PageNumberPagination` class, and then enable your custom pagination class as above.\n\n- `django_paginator_class` - The Django Paginator class to use. Default is `django.core.paginator.Paginator`, which should be fine for most use cases.\n- `page_size` - A numeric value indicating the page size. If set, this overrides the `PAGE_SIZE` setting. Defaults to the same value as the `PAGE_SIZE` settings key.\n- `page_query_param` - A string value indicating the name of the query parameter to use for the pagination control.\n- `page_size_query_param` - If set, this is a string value indicating the name of a query parameter that allows the client to set the page size on a per-request basis. Defaults to `None`, indicating that the client may not control the requested page size.\n- `max_page_size` - If set, this is a numeric value indicating the maximum allowable requested page size. This attribute is only valid if `page_size_query_param` is also set.\n- `last_page_strings` - A list or tuple of string values indicating values that may be used with the `page_query_param` to request the final page in the set. Defaults to `('last',)`\n- `template` - The name of a template to use when rendering pagination controls in the browsable API. May be overridden to modify the rendering style, or set to `None` to disable HTML pagination controls completely. Defaults to `\"rest_framework/pagination/numbers.html\"`.\n\n## LimitOffsetPagination\n\nThis pagination style mirrors the syntax used when looking up multiple database records. The client includes both a \"limit\" and an \"offset\" query parameter. The limit indicates the maximum number of items to return, and is equivalent to the `page_size` in other styles. The offset indicates the starting position of the query in relation to the complete set of unpaginated items.\n\n**Request**:\n\n``` python\nGET https://api.example.org/accounts/?limit=100&offset=400\n```\n\n**Response**:\n\n``` python\nHTTP 200 OK\n{\n    \"count\": 1023,\n    \"next\": \"https://api.example.org/accounts/?limit=100&offset=500\",\n    \"previous\": \"https://api.example.org/accounts/?limit=100&offset=300\",\n    \"results\": [\n       …\n    ]\n}\n```\n\n#### Setup\n\nTo enable the `LimitOffsetPagination` style globally, use the following configuration:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination'\n}\n```\n\nOptionally, you may also set a `PAGE_SIZE` key. If the `PAGE_SIZE` parameter is also used then the `limit` query parameter will be optional, and may be omitted by the client.\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class` attribute to select `LimitOffsetPagination` on a per-view basis.\n\n#### Configuration\n\nThe `LimitOffsetPagination` class includes a number of attributes that may be overridden to modify the pagination style.\n\nTo set these attributes you should override the `LimitOffsetPagination` class, and then enable your custom pagination class as above.\n\n- `default_limit` - A numeric value indicating the limit to use if one is not provided by the client in a query parameter. Defaults to the same value as the `PAGE_SIZE` settings key.\n- `limit_query_param` - A string value indicating the name of the \"limit\" query parameter. Defaults to `'limit'`.\n- `offset_query_param` - A string value indicating the name of the \"offset\" query parameter. Defaults to `'offset'`.\n- `max_limit` - If set this is a numeric value indicating the maximum allowable limit that may be requested by the client. Defaults to `None`.\n- `template` - The name of a template to use when rendering pagination controls in the browsable API. May be overridden to modify the rendering style, or set to `None` to disable HTML pagination controls completely. Defaults to `\"rest_framework/pagination/numbers.html\"`.\n\n## CursorPagination\n\nThe cursor-based pagination presents an opaque \"cursor\" indicator that the client may use to page through the result set. This pagination style only presents forward and reverse controls, and does not allow the client to navigate to arbitrary positions.\n\nCursor based pagination requires that there is a unique, unchanging ordering of items in the result set. This ordering might typically be a creation timestamp on the records, as this presents a consistent ordering to paginate against.\n\nCursor based pagination is more complex than other schemes. It also requires that the result set presents a fixed ordering, and does not allow the client to arbitrarily index into the result set. However it does provide the following benefits:\n\n- Provides a consistent pagination view. When used properly `CursorPagination` ensures that the client will never see the same item twice when paging through records, even when new items are being inserted by other clients during the pagination process.\n- Supports usage with very large datasets. With extremely large datasets pagination using offset-based pagination styles may become inefficient or unusable. Cursor based pagination schemes instead have fixed-time properties, and do not slow down as the dataset size increases.\n\n#### Details and limitations\n\nProper use of cursor based pagination requires a little attention to detail. You'll need to think about what ordering you want the scheme to be applied against. The default is to order by `\"-created\"`. This assumes that **there must be a 'created' timestamp field** on the model instances, and will present a \"timeline\" style paginated view, with the most recently added items first.\n\nYou can modify the ordering by overriding the `'ordering'` attribute on the pagination class, or by using the `OrderingFilter` filter class together with `CursorPagination`. When used with `OrderingFilter` you should strongly consider restricting the fields that the user may order by.\n\nProper usage of cursor pagination should have an ordering field that satisfies the following:\n\n- Should be an unchanging value, such as a timestamp, slug, or other field that is only set once, on creation.\n- Should be unique, or nearly unique. Millisecond precision timestamps are a good example. This implementation of cursor pagination uses a smart \"position plus offset\" style that allows it to properly support not-strictly-unique values as the ordering.\n- Should be a non-nullable value that can be coerced to a string.\n- Should not be a float. Precision errors easily lead to incorrect results. Hint: use decimals instead. (If you already have a float field and must paginate on that, an [example `CursorPagination` subclass that uses decimals to limit precision is available here](https://gist.github.com/keturn/8bc88525a183fd41c73ffb729b8865be#file-fpcursorpagination-py).)\n- The field should have a database index.\n\nUsing an ordering field that does not satisfy these constraints will generally still work, but you'll be losing some of the benefits of cursor pagination.\n\nFor more technical details on the implementation we use for cursor pagination, the [\"Building cursors for the Disqus API\"](https://cra.mr/2011/03/08/building-cursors-for-the-disqus-api) blog post gives a good overview of the basic approach.\n\n#### Setup\n\nTo enable the `CursorPagination` style globally, use the following configuration, modifying the `PAGE_SIZE` as desired:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.CursorPagination',\n    'PAGE_SIZE': 100\n}\n```\n\nOn `GenericAPIView` subclasses you may also set the `pagination_class` attribute to select `CursorPagination` on a per-view basis.\n\n#### Configuration\n\nThe `CursorPagination` class includes a number of attributes that may be overridden to modify the pagination style.\n\nTo set these attributes you should override the `CursorPagination` class, and then enable your custom pagination class as above.\n\n- `page_size` = A numeric value indicating the page size. If set, this overrides the `PAGE_SIZE` setting. Defaults to the same value as the `PAGE_SIZE` settings key.\n- `cursor_query_param` = A string value indicating the name of the \"cursor\" query parameter. Defaults to `'cursor'`.\n- `ordering` = This should be a string, or list of strings, indicating the field against which the cursor based pagination will be applied. For example: `ordering = 'slug'`. Defaults to `-created`. This value may also be overridden by using `OrderingFilter` on the view.\n- `template` = The name of a template to use when rendering pagination controls in the browsable API. May be overridden to modify the rendering style, or set to `None` to disable HTML pagination controls completely. Defaults to `\"rest_framework/pagination/previous_and_next.html\"`.\n\n# Custom pagination styles\n\nTo create a custom pagination serializer class, you should inherit the subclass `pagination.BasePagination`, override the `paginate_queryset(self, queryset, request, view=None)`, and `get_paginated_response(self, data)` methods:\n\n- The `paginate_queryset` method is passed to the initial queryset and should return an iterable object. That object contains only the data in the requested page.\n- The `get_paginated_response` method is passed to the serialized page data and should return a `Response` instance.\n\nNote that the `paginate_queryset` method may set state on the pagination instance, that may later be used by the `get_paginated_response` method.\n\n## Example\n\nSuppose we want to replace the default pagination output style with a modified format that includes the next and previous links under in a nested 'links' key. We could specify a custom pagination class like so:\n\n``` python\nclass CustomPagination(pagination.PageNumberPagination):\n    def get_paginated_response(self, data):\n        return Response({\n            'links': {\n                'next': self.get_next_link(),\n                'previous': self.get_previous_link()\n            },\n            'count': self.page.paginator.count,\n            'results': data\n        })\n```\n\nWe'd then need to set up the custom class in our configuration:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'my_project.apps.core.pagination.CustomPagination',\n    'PAGE_SIZE': 100\n}\n```\n\nNote that if you care about how the ordering of keys is displayed in responses in the browsable API you might choose to use an `OrderedDict` when constructing the body of paginated responses, but this is optional.\n\n## Using your custom pagination class\n\nTo have your custom pagination class be used by default, use the `DEFAULT_PAGINATION_CLASS` setting:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'my_project.apps.core.pagination.LinkHeaderPagination',\n    'PAGE_SIZE': 100\n}\n```\n\nAPI responses for list endpoints will now include a `Link` header, instead of including the pagination links as part of the body of the response, for example:\n\n*A custom pagination style, using the 'Link' header*\n\n# HTML pagination controls\n\nBy default using the pagination classes will cause HTML pagination controls to be displayed in the browsable API. There are two built-in display styles. The `PageNumberPagination` and `LimitOffsetPagination` classes display a list of page numbers with previous and next controls. The `CursorPagination` class displays a simpler style that only displays a previous and next control.\n\n## Customizing the controls\n\nYou can override the templates that render the HTML pagination controls. The two built-in styles are:\n\n- `rest_framework/pagination/numbers.html`\n- `rest_framework/pagination/previous_and_next.html`\n\nProviding a template with either of these paths in a global template directory will override the default rendering for the relevant pagination classes.\n\nAlternatively you can disable HTML pagination controls completely by subclassing on of the existing classes, setting `template = None` as an attribute on the class. You'll then need to configure your `DEFAULT_PAGINATION_CLASS` settings key to use your custom class as the default pagination style.\n\n#### Low-level API\n\nThe low-level API for determining if a pagination class should display the controls or not is exposed as a `display_page_controls` attribute on the pagination instance. Custom pagination classes should be set to `True` in the `paginate_queryset` method if they require the HTML pagination controls to be displayed.\n\nThe `.to_html()` and `.get_html_context()` methods may also be overridden in a custom pagination class in order to further customize how the controls are rendered.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## DRF-extensions\n\nThe [`DRF-extensions` package](https://chibisov.github.io/drf-extensions/docs/) includes a [`PaginateByMaxMixin` mixin class](https://chibisov.github.io/drf-extensions/docs/#paginatebymaxmixin) that allows your API clients to specify `?page_size=max` to obtain the maximum allowed page size.\n\n## drf-proxy-pagination\n\nThe [`drf-proxy-pagination` package](https://github.com/tuffnatty/drf-proxy-pagination) includes a `ProxyPagination` class which allows to choose pagination class with a query parameter.\n\n## link-header-pagination\n\nThe [`django-rest-framework-link-header-pagination` package](https://github.com/tbeadle/django-rest-framework-link-header-pagination) includes a `LinkHeaderPagination` class which provides pagination via an HTTP `Link` header as described in [GitHub REST API documentation](https://docs.github.com/en/rest/guides/traversing-with-pagination).\n\n[pagination.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/pagination.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/pagination/](https://www.django-rest-framework.org/api-guide/pagination/)"
- name: ParseError
  id: api-guide/exceptions/index#parseerror
  summary: Raised if the request contains malformed data when accessing request.data
  belongs_to: Exceptions
  description: |-
    ## ParseError

    **Signature:** `ParseError(detail=None, code=None)`

    Raised if the request contains malformed data when accessing `request.data`.

    By default this exception results in a response with the HTTP status code "400 Bad Request".
- name: Parsers
  id: api-guide/parsers/index
  summary: REST framework includes a number of built-in Parser classes, that allow you to accept requests with various media types
  description: "# Parsers\n\n> Machine interacting web services tend to use more structured formats for sending data than form-encoded, since they're sending more complex data than simple forms\n>\n> — Malcom Tredinnick, [Django developers group](https://groups.google.com/d/topic/django-developers/dxI4qVzrBY4/discussion)\n\nREST framework includes a number of built-in Parser classes, that allow you to accept requests with various media types. There is also support for defining your own custom parsers, which gives you the flexibility to design the media types that your API accepts.\n\n## How the parser is determined\n\nThe set of valid parsers for a view is always defined as a list of classes. When `request.data` is accessed, REST framework will examine the `Content-Type` header on the incoming request, and determine which parser to use to parse the request content.\n\n**Note**: When developing client applications always remember to make sure you're setting the `Content-Type` header when sending data in an HTTP request.\n\nIf you don't set the content type, most clients will default to using `'application/x-www-form-urlencoded'`, which may not be what you wanted.\n\nAs an example, if you are sending `json` encoded data using jQuery with the [.ajax() method](https://api.jquery.com/jQuery.ajax/), you should make sure to include the `contentType: 'application/json'` setting.\n\n## Setting the parsers\n\nThe default set of parsers may be set globally, using the `DEFAULT_PARSER_CLASSES` setting. For example, the following settings would allow only requests with `JSON` content, instead of the default of JSON or form data.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework.parsers.JSONParser',\n    ]\n}\n```\n\nYou can also set the parsers used for an individual view, or viewset, using the `APIView` class-based views.\n\n``` python\nfrom rest_framework.parsers import JSONParser\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass ExampleView(APIView):\n    \"\"\"\n    A view that can accept POST requests with JSON content.\n    \"\"\"\n    parser_classes = [JSONParser]\n\n    def post(self, request, format=None):\n        return Response({'received data': request.data})\n```\n\nOr, if you're using the `@api_view` decorator with function based views.\n\n``` python\nfrom rest_framework.decorators import api_view\nfrom rest_framework.decorators import parser_classes\nfrom rest_framework.parsers import JSONParser\n\n@api_view(['POST'])\n@parser_classes([JSONParser])\ndef example_view(request, format=None):\n    \"\"\"\n    A view that can accept POST requests with JSON content.\n    \"\"\"\n    return Response({'received data': request.data})\n```\n\n# API Reference\n\n## JSONParser\n\nParses `JSON` request content. `request.data` will be populated with a dictionary of data.\n\n**.media_type**: `application/json`\n\n## FormParser\n\nParses HTML form content. `request.data` will be populated with a `QueryDict` of data.\n\nYou will typically want to use both `FormParser` and `MultiPartParser` together in order to fully support HTML form data.\n\n**.media_type**: `application/x-www-form-urlencoded`\n\n## MultiPartParser\n\nParses multipart HTML form content, which supports file uploads. `request.data` and `request.FILES` will be populated with a `QueryDict` and `MultiValueDict` respectively.\n\nYou will typically want to use both `FormParser` and `MultiPartParser` together in order to fully support HTML form data.\n\n**.media_type**: `multipart/form-data`\n\n## FileUploadParser\n\nParses raw file upload content. The `request.data` property will be a dictionary with a single key `'file'` containing the uploaded file.\n\nIf the view used with `FileUploadParser` is called with a `filename` URL keyword argument, then that argument will be used as the filename.\n\nIf it is called without a `filename` URL keyword argument, then the client must set the filename in the `Content-Disposition` HTTP header. For example `Content-Disposition: attachment; filename=upload.jpg`.\n\n**.media_type**: `*/*`\n\n##### Notes:\n\n- The `FileUploadParser` is for usage with native clients that can upload the file as a raw data request. For web-based uploads, or for native clients with multipart upload support, you should use the `MultiPartParser` instead.\n- Since this parser's `media_type` matches any content type, `FileUploadParser` should generally be the only parser set on an API view.\n- `FileUploadParser` respects Django's standard `FILE_UPLOAD_HANDLERS` setting, and the `request.upload_handlers` attribute. See the [Django documentation](https://docs.djangoproject.com/en/stable/topics/http/file-uploads/#upload-handlers) for more details.\n\n##### Basic usage example:\n\n``` python\n# views.py\nclass FileUploadView(views.APIView):\n    parser_classes = [FileUploadParser]\n\n    def put(self, request, filename, format=None):\n        file_obj = request.data['file']\n        # ...\n        # do some stuff with uploaded file\n        # ...\n        return Response(status=204)\n\n# urls.py\nurlpatterns = [\n    # ...\n    re_path(r'^upload/(?P<filename>[^/]+)$', FileUploadView.as_view())\n]\n```\n\n# Custom parsers\n\nTo implement a custom parser, you should override `BaseParser`, set the `.media_type` property, and implement the `.parse(self, stream, media_type, parser_context)` method.\n\nThe method should return the data that will be used to populate the `request.data` property.\n\nThe arguments passed to `.parse()` are:\n\n### stream\n\nA stream-like object representing the body of the request.\n\n### media_type\n\nOptional. If provided, this is the media type of the incoming request content.\n\nDepending on the request's `Content-Type:` header, this may be more specific than the renderer's `media_type` attribute, and may include media type parameters. For example `\"text/plain; charset=utf-8\"`.\n\n### parser_context\n\nOptional. If supplied, this argument will be a dictionary containing any additional context that may be required to parse the request content.\n\nBy default this will include the following keys: `view`, `request`, `args`, `kwargs`.\n\n## Example\n\nThe following is an example plaintext parser that will populate the `request.data` property with a string representing the body of the request.\n\n``` python\nclass PlainTextParser(BaseParser):\n    \"\"\"\n    Plain text parser.\n    \"\"\"\n    media_type = 'text/plain'\n\n    def parse(self, stream, media_type=None, parser_context=None):\n        \"\"\"\n        Simply return a string representing the body of the request.\n        \"\"\"\n        return stream.read()\n```\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## YAML\n\n[REST framework YAML](https://jpadilla.github.io/django-rest-framework-yaml/) provides [YAML](http://www.yaml.org/) parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-yaml\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework_yaml.parsers.YAMLParser',\n    ],\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_yaml.renderers.YAMLRenderer',\n    ],\n}\n```\n\n## XML\n\n[REST Framework XML](https://jpadilla.github.io/django-rest-framework-xml/) provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-xml\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework_xml.parsers.XMLParser',\n    ],\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_xml.renderers.XMLRenderer',\n    ],\n}\n```\n\n## MessagePack\n\n[MessagePack](https://github.com/juanriaza/django-rest-framework-msgpack) is a fast, efficient binary serialization format. [Juan Riaza](https://github.com/juanriaza) maintains the [djangorestframework-msgpack](https://github.com/juanriaza/django-rest-framework-msgpack) package which provides MessagePack renderer and parser support for REST framework.\n\n## CamelCase JSON\n\n[djangorestframework-camel-case](https://github.com/vbabiy/djangorestframework-camel-case) provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by [Vitaly Babiy](https://github.com/vbabiy).\n\n[parsers.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/parsers.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/parsers/](https://www.django-rest-framework.org/api-guide/parsers/)"
- name: PermissionDenied
  id: api-guide/exceptions/index#permissiondenied
  summary: Raised when an authenticated request fails the permission checks
  belongs_to: Exceptions
  description: |-
    ## PermissionDenied

    **Signature:** `PermissionDenied(detail=None, code=None)`

    Raised when an authenticated request fails the permission checks.

    By default this exception results in a response with the HTTP status code "403 Forbidden".
- name: Permissions
  id: api-guide/permissions/index
  summary: Authentication or identification by itself is not usually sufficient to gain access to information or code
  description: "# Permissions\n\n> Authentication or identification by itself is not usually sufficient to gain access to information or code. For that, the entity requesting access must have authorization.\n>\n> — [Apple Developer Documentation](https://developer.apple.com/library/mac/#documentation/security/Conceptual/AuthenticationAndAuthorizationGuide/Authorization/Authorization.html)\n\nTogether with [authentication](../authentication/index) and [throttling](../throttling/index), permissions determine whether a request should be granted or denied access.\n\nPermission checks are always run at the very start of the view, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the `request.user` and `request.auth` properties to determine if the incoming request should be permitted.\n\nPermissions are used to grant or deny access for different classes of users to different parts of the API.\n\nThe simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the `IsAuthenticated` class in REST framework.\n\nA slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the `IsAuthenticatedOrReadOnly` class in REST framework.\n\n## How permissions are determined\n\nPermissions in REST framework are always defined as a list of permission classes.\n\nBefore running the main body of the view each permission in the list is checked. If any permission check fails, an `exceptions.PermissionDenied` or `exceptions.NotAuthenticated` exception will be raised, and the main body of the view will not run.\n\nWhen the permission checks fail, either a \"403 Forbidden\" or a \"401 Unauthorized\" response will be returned, according to the following rules:\n\n- The request was successfully authenticated, but permission was denied. *— An HTTP 403 Forbidden response will be returned.*\n- The request was not successfully authenticated, and the highest priority authentication class *does not* use `WWW-Authenticate` headers. *— An HTTP 403 Forbidden response will be returned.*\n- The request was not successfully authenticated, and the highest priority authentication class *does* use `WWW-Authenticate` headers. *— An HTTP 401 Unauthorized response, with an appropriate `WWW-Authenticate` header will be returned.*\n\n## Object level permissions\n\nREST framework permissions also support object-level permissioning. Object level permissions are used to determine if a user should be allowed to act on a particular object, which will typically be a model instance.\n\nObject level permissions are run by REST framework's generic views when `.get_object()` is called. As with view level permissions, an `exceptions.PermissionDenied` exception will be raised if the user is not allowed to act on the given object.\n\nIf you're writing your own views and want to enforce object level permissions, or if you override the `get_object` method on a generic view, then you'll need to explicitly call the `.check_object_permissions(request, obj)` method on the view at the point at which you've retrieved the object.\n\nThis will either raise a `PermissionDenied` or `NotAuthenticated` exception, or simply return if the view has the appropriate permissions.\n\nFor example:\n\n``` python\ndef get_object(self):\n    obj = get_object_or_404(self.get_queryset(), pk=self.kwargs[\"pk\"])\n    self.check_object_permissions(self.request, obj)\n    return obj\n```\n\n**Note**: With the exception of `DjangoObjectPermissions`, the provided permission classes in `rest_framework.permissions` **do not** implement the methods necessary to check object permissions.\n\nIf you wish to use the provided permission classes in order to check object permissions, **you must** subclass them and implement the `has_object_permission()` method described in the [*Custom permissions*](#custom-permissions) section (below).\n\n#### Limitations of object level permissions\n\nFor performance reasons the generic views will not automatically apply object level permissions to each instance in a queryset when returning a list of objects.\n\nOften when you're using object level permissions you'll also want to [filter the queryset](../filtering/index) appropriately, to ensure that users only have visibility onto instances that they are permitted to view.\n\nBecause the `get_object()` method is not called, object level permissions from the `has_object_permission()` method **are not applied** when creating objects. In order to restrict object creation you need to implement the permission check either in your Serializer class or override the `perform_create()` method of your ViewSet class.\n\n## Setting the permission policy\n\nThe default permission policy may be set globally, using the `DEFAULT_PERMISSION_CLASSES` setting. For example.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PERMISSION_CLASSES': [\n        'rest_framework.permissions.IsAuthenticated',\n    ]\n}\n```\n\nIf not specified, this setting defaults to allowing unrestricted access:\n\n``` python\n'DEFAULT_PERMISSION_CLASSES': [\n   'rest_framework.permissions.AllowAny',\n]\n```\n\nYou can also set the authentication policy on a per-view, or per-viewset basis, using the `APIView` class-based views.\n\n``` python\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass ExampleView(APIView):\n    permission_classes = [IsAuthenticated]\n\n    def get(self, request, format=None):\n        content = {\n            'status': 'request was permitted'\n        }\n        return Response(content)\n```\n\nOr, if you're using the `@api_view` decorator with function based views.\n\n``` python\nfrom rest_framework.decorators import api_view, permission_classes\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\n\n@api_view(['GET'])\n@permission_classes([IsAuthenticated])\ndef example_view(request, format=None):\n    content = {\n        'status': 'request was permitted'\n    }\n    return Response(content)\n```\n\n**Note:** when you set new permission classes via the class attribute or decorators you're telling the view to ignore the default list set in the **settings.py** file.\n\nProvided they inherit from `rest_framework.permissions.BasePermission`, permissions can be composed using standard Python bitwise operators. For example, `IsAuthenticatedOrReadOnly` could be written:\n\n``` python\nfrom rest_framework.permissions import BasePermission, IsAuthenticated, SAFE_METHODS\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass ReadOnly(BasePermission):\n    def has_permission(self, request, view):\n        return request.method in SAFE_METHODS\n\nclass ExampleView(APIView):\n    permission_classes = [IsAuthenticated|ReadOnly]\n\n    def get(self, request, format=None):\n        content = {\n            'status': 'request was permitted'\n        }\n        return Response(content)\n```\n\n**Note:** it supports & (and), \\| (or) and ~ (not).\n\n# API Reference\n\n## AllowAny\n\nThe `AllowAny` permission class will allow unrestricted access, **regardless of if the request was authenticated or unauthenticated**.\n\nThis permission is not strictly required, since you can achieve the same result by using an empty list or tuple for the permissions setting, but you may find it useful to specify this class because it makes the intention explicit.\n\n## IsAuthenticated\n\nThe `IsAuthenticated` permission class will deny permission to any unauthenticated user, and allow permission otherwise.\n\nThis permission is suitable if you want your API to only be accessible to registered users.\n\n## IsAdminUser\n\nThe `IsAdminUser` permission class will deny permission to any user, unless `user.is_staff` is `True` in which case permission will be allowed.\n\nThis permission is suitable if you want your API to only be accessible to a subset of trusted administrators.\n\n## IsAuthenticatedOrReadOnly\n\nThe `IsAuthenticatedOrReadOnly` will allow authenticated users to perform any request. Requests for unauthenticated users will only be permitted if the request method is one of the \"safe\" methods; `GET`, `HEAD` or `OPTIONS`.\n\nThis permission is suitable if you want to your API to allow read permissions to anonymous users, and only allow write permissions to authenticated users.\n\n## DjangoModelPermissions\n\nThis permission class ties into Django's standard `django.contrib.auth` [model permissions](https://docs.djangoproject.com/en/stable/topics/auth/customizing/#custom-permissions). This permission must only be applied to views that have a `.queryset` property or `get_queryset()` method. Authorization will only be granted if the user *is authenticated* and has the *relevant model permissions* assigned. The appropriate model is determined by checking `get_queryset().model` or `queryset.model`.\n\n- `POST` requests require the user to have the `add` permission on the model.\n- `PUT` and `PATCH` requests require the user to have the `change` permission on the model.\n- `DELETE` requests require the user to have the `delete` permission on the model.\n\nThe default behavior can also be overridden to support custom model permissions. For example, you might want to include a `view` model permission for `GET` requests.\n\nTo use custom model permissions, override `DjangoModelPermissions` and set the `.perms_map` property. Refer to the source code for details.\n\n## DjangoModelPermissionsOrAnonReadOnly\n\nSimilar to `DjangoModelPermissions`, but also allows unauthenticated users to have read-only access to the API.\n\n## DjangoObjectPermissions\n\nThis permission class ties into Django's standard [object permissions framework](https://docs.djangoproject.com/en/stable/topics/auth/customizing/#handling-object-permissions) that allows per-object permissions on models. In order to use this permission class, you'll also need to add a permission backend that supports object-level permissions, such as [django-guardian](https://github.com/lukaszb/django-guardian).\n\nAs with `DjangoModelPermissions`, this permission must only be applied to views that have a `.queryset` property or `.get_queryset()` method. Authorization will only be granted if the user *is authenticated* and has the *relevant per-object permissions* and *relevant model permissions* assigned.\n\n- `POST` requests require the user to have the `add` permission on the model instance.\n- `PUT` and `PATCH` requests require the user to have the `change` permission on the model instance.\n- `DELETE` requests require the user to have the `delete` permission on the model instance.\n\nNote that `DjangoObjectPermissions` **does not** require the `django-guardian` package, and should support other object-level backends equally well.\n\nAs with `DjangoModelPermissions` you can use custom model permissions by overriding `DjangoObjectPermissions` and setting the `.perms_map` property. Refer to the source code for details.\n\n**Note**: If you need object level `view` permissions for `GET`, `HEAD` and `OPTIONS` requests and are using django-guardian for your object-level permissions backend, you'll want to consider using the `DjangoObjectPermissionsFilter` class provided by the [`djangorestframework-guardian2` package](https://github.com/johnthagen/django-rest-framework-guardian2). It ensures that list endpoints only return results including objects for which the user has appropriate view permissions.\n\n# Custom permissions\n\nTo implement a custom permission, override `BasePermission` and implement either, or both, of the following methods:\n\n- `.has_permission(self, request, view)`\n- `.has_object_permission(self, request, view, obj)`\n\nThe methods should return `True` if the request should be granted access, and `False` otherwise.\n\nIf you need to test if a request is a read operation or a write operation, you should check the request method against the constant `SAFE_METHODS`, which is a tuple containing `'GET'`, `'OPTIONS'` and `'HEAD'`. For example:\n\n``` python\nif request.method in permissions.SAFE_METHODS:\n    # Check permissions for read-only request\nelse:\n    # Check permissions for write request\n```\n\n**Note**: The instance-level `has_object_permission` method will only be called if the view-level `has_permission` checks have already passed. Also note that in order for the instance-level checks to run, the view code should explicitly call `.check_object_permissions(request, obj)`. If you are using the generic views then this will be handled for you by default. (Function-based views will need to check object permissions explicitly, raising `PermissionDenied` on failure.)\n\nCustom permissions will raise a `PermissionDenied` exception if the test fails. To change the error message associated with the exception, implement a `message` attribute directly on your custom permission. Otherwise the `default_detail` attribute from `PermissionDenied` will be used. Similarly, to change the code identifier associated with the exception, implement a `code` attribute directly on your custom permission - otherwise the `default_code` attribute from `PermissionDenied` will be used.\n\n``` python\nfrom rest_framework import permissions\n\nclass CustomerAccessPermission(permissions.BasePermission):\n    message = 'Adding customers not allowed.'\n\n    def has_permission(self, request, view):\n         ...\n```\n\n## Examples\n\nThe following is an example of a permission class that checks the incoming request's IP address against a blocklist, and denies the request if the IP has been blocked.\n\n``` python\nfrom rest_framework import permissions\n\nclass BlocklistPermission(permissions.BasePermission):\n    \"\"\"\n    Global permission check for blocked IPs.\n    \"\"\"\n\n    def has_permission(self, request, view):\n        ip_addr = request.META['REMOTE_ADDR']\n        blocked = Blocklist.objects.filter(ip_addr=ip_addr).exists()\n        return not blocked\n```\n\nAs well as global permissions, that are run against all incoming requests, you can also create object-level permissions, that are only run against operations that affect a particular object instance. For example:\n\n``` python\nclass IsOwnerOrReadOnly(permissions.BasePermission):\n    \"\"\"\n    Object-level permission to only allow owners of an object to edit it.\n    Assumes the model instance has an `owner` attribute.\n    \"\"\"\n\n    def has_object_permission(self, request, view, obj):\n        # Read permissions are allowed to any request,\n        # so we'll always allow GET, HEAD or OPTIONS requests.\n        if request.method in permissions.SAFE_METHODS:\n            return True\n\n        # Instance must have an attribute named `owner`.\n        return obj.owner == request.user\n```\n\nNote that the generic views will check the appropriate object level permissions, but if you're writing your own custom views, you'll need to make sure you check the object level permission checks yourself. You can do so by calling `self.check_object_permissions(request, obj)` from the view once you have the object instance. This call will raise an appropriate `APIException` if any object-level permission checks fail, and will otherwise simply return.\n\nAlso note that the generic views will only check the object-level permissions for views that retrieve a single model instance. If you require object-level filtering of list views, you'll need to filter the queryset separately. See the [filtering documentation](../filtering/index) for more details.\n\n# Overview of access restriction methods\n\nREST framework offers three different methods to customize access restrictions on a case-by-case basis. These apply in different scenarios and have different effects and limitations.\n\n- `queryset`/`get_queryset()`: Limits the general visibility of existing objects from the database. The queryset limits which objects will be listed and which objects can be modified or deleted. The `get_queryset()` method can apply different querysets based on the current action.\n- `permission_classes`/`get_permissions()`: General permission checks based on the current action, request and targeted object. Object level permissions can only be applied to retrieve, modify and deletion actions. Permission checks for list and create will be applied to the entire object type. (In case of list: subject to restrictions in the queryset.)\n- `serializer_class`/`get_serializer()`: Instance level restrictions that apply to all objects on input and output. The serializer may have access to the request context. The `get_serializer()` method can apply different serializers based on the current action.\n\nThe following table lists the access restriction methods and the level of control they offer over which actions.\n\n|                                   | `queryset` | `permission_classes` | `serializer_class` |\n|-----------------------------------|------------|----------------------|--------------------|\n| Action: list                      | global     | global               | object-level\\*     |\n| Action: create                    | no         | global               | object-level       |\n| Action: retrieve                  | global     | object-level         | object-level       |\n| Action: update                    | global     | object-level         | object-level       |\n| Action: partial_update            | global     | object-level         | object-level       |\n| Action: destroy                   | global     | object-level         | no                 |\n| Can reference action in decision  | no\\*\\*     | yes                  | no\\*\\*             |\n| Can reference request in decision | no\\*\\*     | yes                  | yes                |\n\n\\* A Serializer class should not raise PermissionDenied in a list action, or the entire list would not be returned.  \n\\*\\* The `get_*()` methods have access to the current view and can return different Serializer or QuerySet instances based on the request or action.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## DRF - Access Policy\n\nThe [Django REST - Access Policy](https://github.com/rsinger86/drf-access-policy) package provides a way to define complex access rules in declarative policy classes that are attached to view sets or function-based views. The policies are defined in JSON in a format similar to AWS' Identity & Access Management policies.\n\n## Composed Permissions\n\nThe [Composed Permissions](https://github.com/niwibe/djangorestframework-composed-permissions) package provides a simple way to define complex and multi-depth (with logic operators) permission objects, using small and reusable components.\n\n## REST Condition\n\nThe [REST Condition](https://github.com/caxap/rest_condition) package is another extension for building complex permissions in a simple and convenient way. The extension allows you to combine permissions with logical operators.\n\n## DRY Rest Permissions\n\nThe [DRY Rest Permissions](https://github.com/FJNR-inc/dry-rest-permissions) package provides the ability to define different permissions for individual default and custom actions. This package is made for apps with permissions that are derived from relationships defined in the app's data model. It also supports permission checks being returned to a client app through the API's serializer. Additionally it supports adding permissions to the default and custom list actions to restrict the data they retrieve per user.\n\n## Django Rest Framework Roles\n\nThe [Django Rest Framework Roles](https://github.com/computer-lab/django-rest-framework-roles) package makes it easier to parameterize your API over multiple types of users.\n\n## Rest Framework Roles\n\nThe [Rest Framework Roles](https://github.com/Pithikos/rest-framework-roles) makes it super easy to protect views based on roles. Most importantly allows you to decouple accessibility logic from models and views in a clean human-readable way.\n\n## Django REST Framework API Key\n\nThe [Django REST Framework API Key](https://florimondmanca.github.io/djangorestframework-api-key/) package provides permissions classes, models and helpers to add API key authorization to your API. It can be used to authorize internal or third-party backends and services (i.e. *machines*) which do not have a user account. API keys are stored securely using Django's password hashing infrastructure, and they can be viewed, edited and revoked at anytime in the Django admin.\n\n## Django Rest Framework Role Filters\n\nThe [Django Rest Framework Role Filters](https://github.com/allisson/django-rest-framework-role-filters) package provides simple filtering over multiple types of roles.\n\n## Django Rest Framework PSQ\n\nThe [Django Rest Framework PSQ](https://github.com/drf-psq/drf-psq) package is an extension that gives support for having action-based **permission_classes**, **serializer_class**, and **queryset** dependent on permission-based rules.\n\n[permissions.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/permissions.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/permissions/](https://www.django-rest-framework.org/api-guide/permissions/)"
- name: PrimaryKeyRelatedField
  id: api-guide/relations/index#primarykeyrelatedfield
  summary: PrimaryKeyRelatedField may be used to represent the target of the relationship using its primary key
  belongs_to: Serializer relations
  description: |-
    ## PrimaryKeyRelatedField

    `PrimaryKeyRelatedField` may be used to represent the target of the relationship using its primary key.

    For example, the following serializer:

    ``` python
    class AlbumSerializer(serializers.ModelSerializer):
        tracks = serializers.PrimaryKeyRelatedField(many=True, read_only=True)

        class Meta:
            model = Album
            fields = ['album_name', 'artist', 'tracks']
    ```

    Would serialize to a representation like this:

    ``` python
    {
        'album_name': 'Undun',
        'artist': 'The Roots',
        'tracks': [
            89,
            90,
            91,
            ...
        ]
    }
    ```

    By default this field is read-write, although you can change this behavior using the `read_only` flag.

    **Arguments**:

    - `queryset` - The queryset used for model instance lookups when validating the field input. Relationships must either set a queryset explicitly, or set `read_only=True`.
    - `many` - If applied to a to-many relationship, you should set this argument to `True`.
    - `allow_null` - If set to `True`, the field will accept values of `None` or the empty string for nullable relationships. Defaults to `False`.
    - `pk_field` - Set to a field to control serialization/deserialization of the primary key's value. For example, `pk_field=UUIDField(format='hex')` would serialize a UUID primary key into its compact hex representation.

    &nbsp;
- name: QueryParameterVersioning
  id: api-guide/versioning/index#queryparameterversioning
  summary: This scheme is a simple style that includes the version as a query parameter in the URL
  belongs_to: Versioning
  description: "## QueryParameterVersioning\n\nThis scheme is a simple style that includes the version as a query parameter in the URL. For example:\n\n``` python\nGET /something/?version=0.1 HTTP/1.1\nHost: example.com\nAccept: application/json\n```\n\n# Custom versioning schemes\n\nTo implement a custom versioning scheme, subclass `BaseVersioning` and override the `.determine_version` method.\n\n## Example\n\nThe following example uses a custom `X-API-Version` header to determine the requested version.\n\n``` python\nclass XAPIVersionScheme(versioning.BaseVersioning):\n    def determine_version(self, request, *args, **kwargs):\n        return request.META.get('HTTP_X_API_VERSION', None)\n```\n\nIf your versioning scheme is based on the request URL, you will also want to alter how versioned URLs are determined. In order to do so you should override the `.reverse()` method on the class. See the source code for examples.\n\n[versioning.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/versioning.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/versioning/](https://www.django-rest-framework.org/api-guide/versioning/)"
- name: ReadOnlyField
  id: api-guide/fields/index#readonlyfield
  summary: A field class that simply returns the value of the field without modification
  belongs_to: Serializer fields
  description: |-
    ## ReadOnlyField

    A field class that simply returns the value of the field without modification.

    This field is used by default with `ModelSerializer` when including field names that relate to an attribute rather than a model field.

    **Signature**: `ReadOnlyField()`

    For example, if `has_expired` was a property on the `Account` model, then the following serializer would automatically generate it as a `ReadOnlyField`:

    ``` python
    class AccountSerializer(serializers.ModelSerializer):
        class Meta:
            model = Account
            fields = ['id', 'account_name', 'has_expired']
    ```
- name: ReadOnlyModelViewSet
  id: api-guide/viewsets/index#readonlymodelviewset
  summary: The ReadOnlyModelViewSet class also inherits from GenericAPIView
  belongs_to: ViewSets
  description: "## ReadOnlyModelViewSet\n\nThe `ReadOnlyModelViewSet` class also inherits from `GenericAPIView`. As with `ModelViewSet` it also includes implementations for various actions, but unlike `ModelViewSet` only provides the 'read-only' actions, `.list()` and `.retrieve()`.\n\n#### Example\n\nAs with `ModelViewSet`, you'll normally need to provide at least the `queryset` and `serializer_class` attributes. For example:\n\n``` python\nclass AccountViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    A simple ViewSet for viewing accounts.\n    \"\"\"\n    queryset = Account.objects.all()\n    serializer_class = AccountSerializer\n```\n\nAgain, as with `ModelViewSet`, you can use any of the standard attributes and method overrides available to `GenericAPIView`.\n\n# Custom ViewSet base classes\n\nYou may need to provide custom `ViewSet` classes that do not have the full set of `ModelViewSet` actions, or that customize the behavior in some other way.\n\n## Example\n\nTo create a base viewset class that provides `create`, `list` and `retrieve` operations, inherit from `GenericViewSet`, and mixin the required actions:\n\n``` python\nfrom rest_framework import mixins, viewsets\n\nclass CreateListRetrieveViewSet(mixins.CreateModelMixin,\n                                mixins.ListModelMixin,\n                                mixins.RetrieveModelMixin,\n                                viewsets.GenericViewSet):\n    \"\"\"\n    A viewset that provides `retrieve`, `create`, and `list` actions.\n\n    To use it, override the class and set the `.queryset` and\n    `.serializer_class` attributes.\n    \"\"\"\n    pass\n```\n\nBy creating your own base `ViewSet` classes, you can provide common behavior that can be reused in multiple viewsets across your API.\n\n[viewsets.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/viewsets.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/viewsets/](https://www.django-rest-framework.org/api-guide/viewsets/)"
- name: RegexField
  id: api-guide/fields/index#regexfield
  summary: A text representation, that validates the given value matches against a certain regular expression
  belongs_to: Serializer fields
  description: |-
    ## RegexField

    A text representation, that validates the given value matches against a certain regular expression.

    Corresponds to `django.forms.fields.RegexField`.

    **Signature:** `RegexField(regex, max_length=None, min_length=None, allow_blank=False)`

    The mandatory `regex` argument may either be a string, or a compiled python regular expression object.

    Uses Django's `django.core.validators.RegexValidator` for validation.
- name: RemoteUserAuthentication
  id: api-guide/authentication/index#remoteuserauthentication
  summary: This authentication scheme allows you to delegate authentication to your web server, which sets the REMOTE_USER environment variable
  belongs_to: Authentication
  description: "## RemoteUserAuthentication\n\nThis authentication scheme allows you to delegate authentication to your web server, which sets the `REMOTE_USER` environment variable.\n\nTo use it, you must have `django.contrib.auth.backends.RemoteUserBackend` (or a subclass) in your `AUTHENTICATION_BACKENDS` setting. By default, `RemoteUserBackend` creates `User` objects for usernames that don't already exist. To change this and other behavior, consult the [Django documentation](https://docs.djangoproject.com/en/stable/howto/auth-remote-user/).\n\nIf successfully authenticated, `RemoteUserAuthentication` provides the following credentials:\n\n- `request.user` will be a Django `User` instance.\n- `request.auth` will be `None`.\n\nConsult your web server's documentation for information about configuring an authentication method, for example:\n\n- [Apache Authentication How-To](https://httpd.apache.org/docs/2.4/howto/auth.html)\n- [NGINX (Restricting Access)](https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/)\n\n# Custom authentication\n\nTo implement a custom authentication scheme, subclass `BaseAuthentication` and override the `.authenticate(self, request)` method. The method should return a two-tuple of `(user, auth)` if authentication succeeds, or `None` otherwise.\n\nIn some circumstances instead of returning `None`, you may want to raise an `AuthenticationFailed` exception from the `.authenticate()` method.\n\nTypically the approach you should take is:\n\n- If authentication is not attempted, return `None`. Any other authentication schemes also in use will still be checked.\n- If authentication is attempted but fails, raise an `AuthenticationFailed` exception. An error response will be returned immediately, regardless of any permissions checks, and without checking any other authentication schemes.\n\nYou *may* also override the `.authenticate_header(self, request)` method. If implemented, it should return a string that will be used as the value of the `WWW-Authenticate` header in a `HTTP 401 Unauthorized` response.\n\nIf the `.authenticate_header()` method is not overridden, the authentication scheme will return `HTTP 403 Forbidden` responses when an unauthenticated request is denied access.\n\n**Note:** When your custom authenticator is invoked by the request object's `.user` or `.auth` properties, you may see an `AttributeError` re-raised as a `WrappedAttributeError`. This is necessary to prevent the original exception from being suppressed by the outer property access. Python will not recognize that the `AttributeError` originates from your custom authenticator and will instead assume that the request object does not have a `.user` or `.auth` property. These errors should be fixed or otherwise handled by your authenticator.\n\n## Example\n\nThe following example will authenticate any incoming request as the user given by the username in a custom request header named 'X-USERNAME'.\n\n``` python\nfrom django.contrib.auth.models import User\nfrom rest_framework import authentication\nfrom rest_framework import exceptions\n\nclass ExampleAuthentication(authentication.BaseAuthentication):\n    def authenticate(self, request):\n        username = request.META.get('HTTP_X_USERNAME')\n        if not username:\n            return None\n\n        try:\n            user = User.objects.get(username=username)\n        except User.DoesNotExist:\n            raise exceptions.AuthenticationFailed('No such user')\n\n        return (user, None)\n```\n\n# Third party packages\n\nThe following third-party packages are also available.\n\n## django-rest-knox\n\n[Django-rest-knox](https://github.com/James1345/django-rest-knox) library provides models and views to handle token-based authentication in a more secure and extensible way than the built-in TokenAuthentication scheme - with Single Page Applications and Mobile clients in mind. It provides per-client tokens, and views to generate them when provided some other authentication (usually basic authentication), to delete the token (providing a server enforced logout) and to delete all tokens (logs out all clients that a user is logged into).\n\n## Django OAuth Toolkit\n\nThe [Django OAuth Toolkit](https://github.com/evonove/django-oauth-toolkit) package provides OAuth 2.0 support and works with Python 3.4+. The package is maintained by [jazzband](https://github.com/jazzband/) and uses the excellent [OAuthLib](https://github.com/idan/oauthlib). The package is well documented, and well supported and is currently our **recommended package for OAuth 2.0 support**.\n\n### Installation & configuration\n\nInstall using `pip`.\n\n``` python\npip install django-oauth-toolkit\n```\n\nAdd the package to your `INSTALLED_APPS` and modify your REST framework settings.\n\n``` python\nINSTALLED_APPS = [\n    ...\n    'oauth2_provider',\n]\n\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': [\n        'oauth2_provider.contrib.rest_framework.OAuth2Authentication',\n    ]\n}\n```\n\nFor more details see the [Django REST framework - Getting started](https://django-oauth-toolkit.readthedocs.io/en/latest/rest-framework/getting_started.html) documentation.\n\n## Django REST framework OAuth\n\nThe [Django REST framework OAuth](https://jpadilla.github.io/django-rest-framework-oauth/) package provides both OAuth1 and OAuth2 support for REST framework.\n\nThis package was previously included directly in the REST framework but is now supported and maintained as a third-party package.\n\n### Installation & configuration\n\nInstall the package using `pip`.\n\n``` python\npip install djangorestframework-oauth\n```\n\nFor details on configuration and usage see the Django REST framework OAuth documentation for [authentication](https://jpadilla.github.io/django-rest-framework-oauth/authentication/) and [permissions](https://jpadilla.github.io/django-rest-framework-oauth/permissions/).\n\n## JSON Web Token Authentication\n\nJSON Web Token is a fairly new standard which can be used for token-based authentication. Unlike the built-in TokenAuthentication scheme, JWT Authentication doesn't need to use a database to validate a token. A package for JWT authentication is [djangorestframework-simplejwt](https://github.com/davesque/django-rest-framework-simplejwt) which provides some features as well as a pluggable token blacklist app.\n\n## Hawk HTTP Authentication\n\nThe [HawkREST](https://hawkrest.readthedocs.io/en/latest/) library builds on the [Mohawk](https://mohawk.readthedocs.io/en/latest/) library to let you work with [Hawk](https://github.com/hueniverse/hawk) signed requests and responses in your API. [Hawk](https://github.com/hueniverse/hawk) lets two parties securely communicate with each other using messages signed by a shared key. It is based on [HTTP MAC access authentication](https://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05) (which was based on parts of [OAuth 1.0](https://oauth.net/core/1.0a/)).\n\n## HTTP Signature Authentication\n\nHTTP Signature (currently a [IETF draft](https://datatracker.ietf.org/doc/draft-cavage-http-signatures/)) provides a way to achieve origin authentication and message integrity for HTTP messages. Similar to [Amazon's HTTP Signature scheme](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html), used by many of its services, it permits stateless, per-request authentication. [Elvio Toccalino](https://github.com/etoccalino/) maintains the [djangorestframework-httpsignature](https://github.com/etoccalino/django-rest-framework-httpsignature) (outdated) package which provides an easy-to-use HTTP Signature Authentication mechanism. You can use the updated fork version of [djangorestframework-httpsignature](https://github.com/etoccalino/django-rest-framework-httpsignature), which is [drf-httpsig](https://github.com/ahknight/drf-httpsig).\n\n## Djoser\n\n[Djoser](https://github.com/sunscrapers/djoser) library provides a set of views to handle basic actions such as registration, login, logout, password reset and account activation. The package works with a custom user model and uses token-based authentication. This is a ready to use REST implementation of the Django authentication system.\n\n## django-rest-auth / dj-rest-auth\n\nThis library provides a set of REST API endpoints for registration, authentication (including social media authentication), password reset, retrieve and update user details, etc. By having these API endpoints, your client apps such as AngularJS, iOS, Android, and others can communicate to your Django backend site independently via REST APIs for user management.\n\nThere are currently two forks of this project.\n\n- [Django-rest-auth](https://github.com/Tivix/django-rest-auth) is the original project, [but is not currently receiving updates](https://github.com/Tivix/django-rest-auth/issues/568).\n- [Dj-rest-auth](https://github.com/jazzband/dj-rest-auth) is a newer fork of the project.\n\n## drf-social-oauth2\n\n[Drf-social-oauth2](https://github.com/wagnerdelima/drf-social-oauth2) is a framework that helps you authenticate with major social oauth2 vendors, such as Facebook, Google, Twitter, Orcid, etc. It generates tokens in a JWTed way with an easy setup.\n\n## drfpasswordless\n\n[drfpasswordless](https://github.com/aaronn/django-rest-framework-passwordless) adds (Medium, Square Cash inspired) passwordless support to Django REST Framework's TokenAuthentication scheme. Users log in and sign up with a token sent to a contact point like an email address or a mobile number.\n\n## django-rest-authemail\n\n[django-rest-authemail](https://github.com/celiao/django-rest-authemail) provides a RESTful API interface for user signup and authentication. Email addresses are used for authentication, rather than usernames. API endpoints are available for signup, signup email verification, login, logout, password reset, password reset verification, email change, email change verification, password change, and user detail. A fully functional example project and detailed instructions are included.\n\n## Django-Rest-Durin\n\n[Django-Rest-Durin](https://github.com/eshaan7/django-rest-durin) is built with the idea to have one library that does token auth for multiple Web/CLI/Mobile API clients via one interface but allows different token configuration for each API Client that consumes the API. It provides support for multiple tokens per user via custom models, views, permissions that work with Django-Rest-Framework. The token expiration time can be different per API client and is customizable via the Django Admin Interface.\n\nMore information can be found in the [Documentation](https://django-rest-durin.readthedocs.io/en/latest/index.html).\n\n[authentication.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/authentication.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/authentication/](https://www.django-rest-framework.org/api-guide/authentication/)"
- name: Renderers
  id: api-guide/renderers/index
  summary: Before a TemplateResponse instance can be returned to the client, it must be rendered
  description: "# Renderers\n\n> Before a TemplateResponse instance can be returned to the client, it must be rendered. The rendering process takes the intermediate representation of template and context, and turns it into the final byte stream that can be served to the client.\n>\n> — [Django documentation](https://docs.djangoproject.com/en/stable/ref/template-response/#the-rendering-process)\n\nREST framework includes a number of built in Renderer classes, that allow you to return responses with various media types. There is also support for defining your own custom renderers, which gives you the flexibility to design your own media types.\n\n## How the renderer is determined\n\nThe set of valid renderers for a view is always defined as a list of classes. When a view is entered REST framework will perform content negotiation on the incoming request, and determine the most appropriate renderer to satisfy the request.\n\nThe basic process of content negotiation involves examining the request's `Accept` header, to determine which media types it expects in the response. Optionally, format suffixes on the URL may be used to explicitly request a particular representation. For example the URL `http://example.com/api/users_count.json` might be an endpoint that always returns JSON data.\n\nFor more information see the documentation on [content negotiation](../content-negotiation/index).\n\n## Setting the renderers\n\nThe default set of renderers may be set globally, using the `DEFAULT_RENDERER_CLASSES` setting. For example, the following settings would use `JSON` as the main media type and also include the self describing API.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework.renderers.JSONRenderer',\n        'rest_framework.renderers.BrowsableAPIRenderer',\n    ]\n}\n```\n\nYou can also set the renderers used for an individual view, or viewset, using the `APIView` class-based views.\n\n``` python\nfrom django.contrib.auth.models import User\nfrom rest_framework.renderers import JSONRenderer\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass UserCountView(APIView):\n    \"\"\"\n    A view that returns the count of active users in JSON.\n    \"\"\"\n    renderer_classes = [JSONRenderer]\n\n    def get(self, request, format=None):\n        user_count = User.objects.filter(active=True).count()\n        content = {'user_count': user_count}\n        return Response(content)\n```\n\nOr, if you're using the `@api_view` decorator with function based views.\n\n``` python\n@api_view(['GET'])\n@renderer_classes([JSONRenderer])\ndef user_count_view(request, format=None):\n    \"\"\"\n    A view that returns the count of active users in JSON.\n    \"\"\"\n    user_count = User.objects.filter(active=True).count()\n    content = {'user_count': user_count}\n    return Response(content)\n```\n\n## Ordering of renderer classes\n\nIt's important when specifying the renderer classes for your API to think about what priority you want to assign to each media type. If a client underspecifies the representations it can accept, such as sending an `Accept: */*` header, or not including an `Accept` header at all, then REST framework will select the first renderer in the list to use for the response.\n\nFor example if your API serves JSON responses and the HTML browsable API, you might want to make `JSONRenderer` your default renderer, in order to send `JSON` responses to clients that do not specify an `Accept` header.\n\nIf your API includes views that can serve both regular webpages and API responses depending on the request, then you might consider making `TemplateHTMLRenderer` your default renderer, in order to play nicely with older browsers that send [broken accept headers](http://www.gethifi.com/blog/browser-rest-http-accept-headers).\n\n# API Reference\n\n## JSONRenderer\n\nRenders the request data into `JSON`, using utf-8 encoding.\n\nNote that the default style is to include unicode characters, and render the response using a compact style with no unnecessary whitespace:\n\n``` python\n{\"unicode black star\":\"★\",\"value\":999}\n```\n\nThe client may additionally include an `'indent'` media type parameter, in which case the returned `JSON` will be indented. For example `Accept: application/json; indent=4`.\n\n``` python\n{\n    \"unicode black star\": \"★\",\n    \"value\": 999\n}\n```\n\nThe default JSON encoding style can be altered using the `UNICODE_JSON` and `COMPACT_JSON` settings keys.\n\n**.media_type**: `application/json`\n\n**.format**: `'json'`\n\n**.charset**: `None`\n\n## TemplateHTMLRenderer\n\nRenders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the `Response` does not need to be serialized. Also, unlike other renderers, you may want to include a `template_name` argument when creating the `Response`.\n\nThe TemplateHTMLRenderer will create a `RequestContext`, using the `response.data` as the context dict, and determine a template name to use to render the context.\n\n**Note:** When used with a view that makes use of a serializer the `Response` sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the `TemplateHTMLRenderer` to render it. For example:\n\n``` python\nresponse.data = {'results': response.data}\n```\n\nThe template name is determined by (in order of preference):\n\n1.  An explicit `template_name` argument passed to the response.\n2.  An explicit `.template_name` attribute set on this class.\n3.  The return result of calling `view.get_template_names()`.\n\nAn example of a view that uses `TemplateHTMLRenderer`:\n\n``` python\nclass UserDetail(generics.RetrieveAPIView):\n    \"\"\"\n    A view that returns a templated HTML representation of a given user.\n    \"\"\"\n    queryset = User.objects.all()\n    renderer_classes = [TemplateHTMLRenderer]\n\n    def get(self, request, *args, **kwargs):\n        self.object = self.get_object()\n        return Response({'user': self.object}, template_name='user_detail.html')\n```\n\nYou can use `TemplateHTMLRenderer` either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.\n\nIf you're building websites that use `TemplateHTMLRenderer` along with other renderer classes, you should consider listing `TemplateHTMLRenderer` as the first class in the `renderer_classes` list, so that it will be prioritised first even for browsers that send poorly formed `ACCEPT:` headers.\n\nSee the [*HTML & Forms* Topic Page](https://www.django-rest-framework.org/topics/html-and-forms/) for further examples of `TemplateHTMLRenderer` usage.\n\n**.media_type**: `text/html`\n\n**.format**: `'html'`\n\n**.charset**: `utf-8`\n\nSee also: `StaticHTMLRenderer`\n\n## StaticHTMLRenderer\n\nA simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.\n\nAn example of a view that uses `StaticHTMLRenderer`:\n\n``` python\n@api_view(['GET'])\n@renderer_classes([StaticHTMLRenderer])\ndef simple_html_view(request):\n    data = '<html><body><h1>Hello, world</h1></body></html>'\n    return Response(data)\n```\n\nYou can use `StaticHTMLRenderer` either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.\n\n**.media_type**: `text/html`\n\n**.format**: `'html'`\n\n**.charset**: `utf-8`\n\nSee also: `TemplateHTMLRenderer`\n\n## BrowsableAPIRenderer\n\nRenders data into HTML for the Browsable API:\n\nThis renderer will determine which other renderer would have been given highest priority, and use that to display an API style response within the HTML page.\n\n**.media_type**: `text/html`\n\n**.format**: `'api'`\n\n**.charset**: `utf-8`\n\n**.template**: `'rest_framework/api.html'`\n\n#### Customizing BrowsableAPIRenderer\n\nBy default the response content will be rendered with the highest priority renderer apart from `BrowsableAPIRenderer`. If you need to customize this behavior, for example to use HTML as the default return format, but use JSON in the browsable API, you can do so by overriding the `get_default_renderer()` method. For example:\n\n``` python\nclass CustomBrowsableAPIRenderer(BrowsableAPIRenderer):\n    def get_default_renderer(self, view):\n        return JSONRenderer()\n```\n\n## AdminRenderer\n\nRenders data into HTML for an admin-like display:\n\nThis renderer is suitable for CRUD-style web APIs that should also present a user-friendly interface for managing the data.\n\nNote that views that have nested or list serializers for their input won't work well with the `AdminRenderer`, as the HTML forms are unable to properly support them.\n\n**Note**: The `AdminRenderer` is only able to include links to detail pages when a properly configured `URL_FIELD_NAME` (`url` by default) attribute is present in the data. For `HyperlinkedModelSerializer` this will be the case, but for `ModelSerializer` or plain `Serializer` classes you'll need to make sure to include the field explicitly. For example here we use models `get_absolute_url` method:\n\n``` python\nclass AccountSerializer(serializers.ModelSerializer):\n    url = serializers.CharField(source='get_absolute_url', read_only=True)\n\n    class Meta:\n        model = Account\n```\n\n**.media_type**: `text/html`\n\n**.format**: `'admin'`\n\n**.charset**: `utf-8`\n\n**.template**: `'rest_framework/admin.html'`\n\n## HTMLFormRenderer\n\nRenders data returned by a serializer into an HTML form. The output of this renderer does not include the enclosing `<form>` tags, a hidden CSRF input or any submit buttons.\n\nThis renderer is not intended to be used directly, but can instead be used in templates by passing a serializer instance to the `render_form` template tag.\n\n``` python\n{% load rest_framework %}\n\n<form action=\"/submit-report/\" method=\"post\">\n    {% csrf_token %}\n    {% render_form serializer %}\n    <input type=\"submit\" value=\"Save\" />\n</form>\n```\n\nFor more information see the [HTML & Forms](https://www.django-rest-framework.org/topics/html-and-forms/) documentation.\n\n**.media_type**: `text/html`\n\n**.format**: `'form'`\n\n**.charset**: `utf-8`\n\n**.template**: `'rest_framework/horizontal/form.html'`\n\n## MultiPartRenderer\n\nThis renderer is used for rendering HTML multipart form data. **It is not suitable as a response renderer**, but is instead used for creating test requests, using REST framework's [test client and test request factory](../testing/index).\n\n**.media_type**: `multipart/form-data; boundary=BoUnDaRyStRiNg`\n\n**.format**: `'multipart'`\n\n**.charset**: `utf-8`\n\n# Custom renderers\n\nTo implement a custom renderer, you should override `BaseRenderer`, set the `.media_type` and `.format` properties, and implement the `.render(self, data, accepted_media_type=None, renderer_context=None)` method.\n\nThe method should return a bytestring, which will be used as the body of the HTTP response.\n\nThe arguments passed to the `.render()` method are:\n\n### data\n\nThe request data, as set by the `Response()` instantiation.\n\n### accepted_media_type=None\n\nOptional. If provided, this is the accepted media type, as determined by the content negotiation stage.\n\nDepending on the client's `Accept:` header, this may be more specific than the renderer's `media_type` attribute, and may include media type parameters. For example `\"application/json; nested=true\"`.\n\n### renderer_context=None\n\nOptional. If provided, this is a dictionary of contextual information provided by the view.\n\nBy default this will include the following keys: `view`, `request`, `response`, `args`, `kwargs`.\n\n## Example\n\nThe following is an example plaintext renderer that will return a response with the `data` parameter as the content of the response.\n\n``` python\nfrom django.utils.encoding import smart_str\nfrom rest_framework import renderers\n\n\nclass PlainTextRenderer(renderers.BaseRenderer):\n    media_type = 'text/plain'\n    format = 'txt'\n\n    def render(self, data, accepted_media_type=None, renderer_context=None):\n        return smart_str(data, encoding=self.charset)\n```\n\n## Setting the character set\n\nBy default renderer classes are assumed to be using the `UTF-8` encoding. To use a different encoding, set the `charset` attribute on the renderer.\n\n``` python\nclass PlainTextRenderer(renderers.BaseRenderer):\n    media_type = 'text/plain'\n    format = 'txt'\n    charset = 'iso-8859-1'\n\n    def render(self, data, accepted_media_type=None, renderer_context=None):\n        return data.encode(self.charset)\n```\n\nNote that if a renderer class returns a unicode string, then the response content will be coerced into a bytestring by the `Response` class, with the `charset` attribute set on the renderer used to determine the encoding.\n\nIf the renderer returns a bytestring representing raw binary content, you should set a charset value of `None`, which will ensure the `Content-Type` header of the response will not have a `charset` value set.\n\nIn some cases you may also want to set the `render_style` attribute to `'binary'`. Doing so will also ensure that the browsable API will not attempt to display the binary content as a string.\n\n``` python\nclass JPEGRenderer(renderers.BaseRenderer):\n    media_type = 'image/jpeg'\n    format = 'jpg'\n    charset = None\n    render_style = 'binary'\n\n    def render(self, data, accepted_media_type=None, renderer_context=None):\n        return data\n```\n\n# Advanced renderer usage\n\nYou can do some pretty flexible things using REST framework's renderers. Some examples...\n\n- Provide either flat or nested representations from the same endpoint, depending on the requested media type.\n- Serve both regular HTML webpages, and JSON based API responses from the same endpoints.\n- Specify multiple types of HTML representation for API clients to use.\n- Underspecify a renderer's media type, such as using `media_type = 'image/*'`, and use the `Accept` header to vary the encoding of the response.\n\n## Varying behavior by media type\n\nIn some cases you might want your view to use different serialization styles depending on the accepted media type. If you need to do this you can access `request.accepted_renderer` to determine the negotiated renderer that will be used for the response.\n\nFor example:\n\n``` python\n@api_view(['GET'])\n@renderer_classes([TemplateHTMLRenderer, JSONRenderer])\ndef list_users(request):\n    \"\"\"\n    A view that can return JSON or HTML representations\n    of the users in the system.\n    \"\"\"\n    queryset = Users.objects.filter(active=True)\n\n    if request.accepted_renderer.format == 'html':\n        # TemplateHTMLRenderer takes a context dict,\n        # and additionally requires a 'template_name'.\n        # It does not require serialization.\n        data = {'users': queryset}\n        return Response(data, template_name='list_users.html')\n\n    # JSONRenderer requires serialized data as normal.\n    serializer = UserSerializer(instance=queryset)\n    data = serializer.data\n    return Response(data)\n```\n\n## Underspecifying the media type\n\nIn some cases you might want a renderer to serve a range of media types. In this case you can underspecify the media types it should respond to, by using a `media_type` value such as `image/*`, or `*/*`.\n\nIf you underspecify the renderer's media type, you should make sure to specify the media type explicitly when you return the response, using the `content_type` attribute. For example:\n\n``` python\nreturn Response(data, content_type='image/png')\n```\n\n## Designing your media types\n\nFor the purposes of many Web APIs, simple `JSON` responses with hyperlinked relations may be sufficient. If you want to fully embrace RESTful design and [HATEOAS](http://timelessrepo.com/haters-gonna-hateoas) you'll need to consider the design and usage of your media types in more detail.\n\nIn [the words of Roy Fielding](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven), \"A REST API should spend almost all of its descriptive effort in defining the media type(s) used for representing resources and driving application state, or in defining extended relation names and/or hypertext-enabled mark-up for existing standard media types.\".\n\nFor good examples of custom media types, see GitHub's use of a custom [application/vnd.github+json](https://developer.github.com/v3/media/) media type, and Mike Amundsen's IANA approved [application/vnd.collection+json](http://www.amundsen.com/media-types/collection/) JSON-based hypermedia.\n\n## HTML error views\n\nTypically a renderer will behave the same regardless of if it's dealing with a regular response, or with a response caused by an exception being raised, such as an `Http404` or `PermissionDenied` exception, or a subclass of `APIException`.\n\nIf you're using either the `TemplateHTMLRenderer` or the `StaticHTMLRenderer` and an exception is raised, the behavior is slightly different, and mirrors [Django's default handling of error views](https://docs.djangoproject.com/en/stable/topics/http/views/#customizing-error-views).\n\nExceptions raised and handled by an HTML renderer will attempt to render using one of the following methods, by order of precedence.\n\n- Load and render a template named `{status_code}.html`.\n- Load and render a template named `api_exception.html`.\n- Render the HTTP status code and text, for example \"404 Not Found\".\n\nTemplates will render with a `RequestContext` which includes the `status_code` and `details` keys.\n\n**Note**: If `DEBUG=True`, Django's standard traceback error page will be displayed instead of rendering the HTTP status code and text.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## YAML\n\n[REST framework YAML](https://jpadilla.github.io/django-rest-framework-yaml/) provides [YAML](http://www.yaml.org/) parsing and rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-yaml\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework_yaml.parsers.YAMLParser',\n    ],\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_yaml.renderers.YAMLRenderer',\n    ],\n}\n```\n\n## XML\n\n[REST Framework XML](https://jpadilla.github.io/django-rest-framework-xml/) provides a simple informal XML format. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-xml\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework_xml.parsers.XMLParser',\n    ],\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_xml.renderers.XMLRenderer',\n    ],\n}\n```\n\n## JSONP\n\n[REST framework JSONP](https://jpadilla.github.io/django-rest-framework-jsonp/) provides JSONP rendering support. It was previously included directly in the REST framework package, and is now instead supported as a third-party package.\n\n**Warning**: If you require cross-domain AJAX requests, you should generally be using the more modern approach of [CORS](https://www.w3.org/TR/cors/) as an alternative to `JSONP`. See the [CORS documentation](https://www.django-rest-framework.org/topics/ajax-csrf-cors/) for more details.\n\nThe `jsonp` approach is essentially a browser hack, and is [only appropriate for globally readable API endpoints](https://stackoverflow.com/questions/613962/is-jsonp-safe-to-use), where `GET` requests are unauthenticated and do not require any user permissions.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install djangorestframework-jsonp\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework_jsonp.renderers.JSONPRenderer',\n    ],\n}\n```\n\n## MessagePack\n\n[MessagePack](https://msgpack.org/) is a fast, efficient binary serialization format. [Juan Riaza](https://github.com/juanriaza) maintains the [djangorestframework-msgpack](https://github.com/juanriaza/django-rest-framework-msgpack) package which provides MessagePack renderer and parser support for REST framework.\n\n## Microsoft Excel: XLSX (Binary Spreadsheet Endpoints)\n\nXLSX is the world's most popular binary spreadsheet format. [Tim Allen](https://github.com/flipperpa) of [The Wharton School](https://github.com/wharton) maintains [drf-excel](https://github.com/wharton/drf-excel), which renders an endpoint as an XLSX spreadsheet using OpenPyXL, and allows the client to download it. Spreadsheets can be styled on a per-view basis.\n\n#### Installation & configuration\n\nInstall using pip.\n\n``` python\n$ pip install drf-excel\n```\n\nModify your REST framework settings.\n\n``` python\nREST_FRAMEWORK = {\n    ...\n\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework.renderers.JSONRenderer',\n        'rest_framework.renderers.BrowsableAPIRenderer',\n        'drf_excel.renderers.XLSXRenderer',\n    ],\n}\n```\n\nTo avoid having a file streamed without a filename (which the browser will often default to the filename \"download\", with no extension), we need to use a mixin to override the `Content-Disposition` header. If no filename is provided, it will default to `export.xlsx`. For example:\n\n``` python\nfrom rest_framework.viewsets import ReadOnlyModelViewSet\nfrom drf_excel.mixins import XLSXFileMixin\nfrom drf_excel.renderers import XLSXRenderer\n\nfrom .models import MyExampleModel\nfrom .serializers import MyExampleSerializer\n\nclass MyExampleViewSet(XLSXFileMixin, ReadOnlyModelViewSet):\n    queryset = MyExampleModel.objects.all()\n    serializer_class = MyExampleSerializer\n    renderer_classes = [XLSXRenderer]\n    filename = 'my_export.xlsx'\n```\n\n## CSV\n\nComma-separated values are a plain-text tabular data format, that can be easily imported into spreadsheet applications. [Mjumbe Poe](https://github.com/mjumbewu) maintains the [djangorestframework-csv](https://github.com/mjumbewu/django-rest-framework-csv) package which provides CSV renderer support for REST framework.\n\n## UltraJSON\n\n[UltraJSON](https://github.com/esnme/ultrajson) is an optimized C JSON encoder which can give significantly faster JSON rendering. [Adam Mertz](https://github.com/Amertz08) maintains [drf_ujson2](https://github.com/Amertz08/drf_ujson2), a fork of the now unmaintained [drf-ujson-renderer](https://github.com/gizmag/drf-ujson-renderer), which implements JSON rendering using the UJSON package.\n\n## CamelCase JSON\n\n[djangorestframework-camel-case](https://github.com/vbabiy/djangorestframework-camel-case) provides camel case JSON renderers and parsers for REST framework. This allows serializers to use Python-style underscored field names, but be exposed in the API as Javascript-style camel case field names. It is maintained by [Vitaly Babiy](https://github.com/vbabiy).\n\n## Pandas (CSV, Excel, PNG)\n\n[Django REST Pandas](https://github.com/wq/django-rest-pandas) provides a serializer and renderers that support additional data processing and output via the [Pandas](https://pandas.pydata.org/) DataFrame API. Django REST Pandas includes renderers for Pandas-style CSV files, Excel workbooks (both `.xls` and `.xlsx`), and a number of [other formats](https://github.com/wq/django-rest-pandas#supported-formats). It is maintained by [S. Andrew Sheppard](https://github.com/sheppard) as part of the [wq Project](https://github.com/wq).\n\n## LaTeX\n\n[Rest Framework Latex](https://github.com/mypebble/rest-framework-latex) provides a renderer that outputs PDFs using Laulatex. It is maintained by [Pebble (S/F Software)](https://github.com/mypebble).\n\n[renderers.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/renderers.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/renderers/](https://www.django-rest-framework.org/api-guide/renderers/)"
- name: Requests
  id: api-guide/requests/index
  summary: If you're doing REST-based web service stuff ... you should ignore request.POST
  description: "# Requests\n\n> If you're doing REST-based web service stuff ... you should ignore request.POST.\n>\n> — Malcom Tredinnick, [Django developers group](https://groups.google.com/d/topic/django-developers/dxI4qVzrBY4/discussion)\n\nREST framework's `Request` class extends the standard `HttpRequest`, adding support for REST framework's flexible request parsing and request authentication.\n\n# Request parsing\n\nREST framework's Request objects provide flexible request parsing that allows you to treat requests with JSON data or other media types in the same way that you would normally deal with form data.\n\n## .data\n\n`request.data` returns the parsed content of the request body. This is similar to the standard `request.POST` and `request.FILES` attributes except that:\n\n- It includes all parsed content, including *file and non-file* inputs.\n- It supports parsing the content of HTTP methods other than `POST`, meaning that you can access the content of `PUT` and `PATCH` requests.\n- It supports REST framework's flexible request parsing, rather than just supporting form data. For example you can handle incoming [JSON data](../parsers/index#jsonparser) similarly to how you handle incoming [form data](../parsers/index#formparser).\n\nFor more details see the [parsers documentation](../parsers/index).\n\n## .query_params\n\n`request.query_params` is a more correctly named synonym for `request.GET`.\n\nFor clarity inside your code, we recommend using `request.query_params` instead of the Django's standard `request.GET`. Doing so will help keep your codebase more correct and obvious - any HTTP method type may include query parameters, not just `GET` requests.\n\n## .parsers\n\nThe `APIView` class or `@api_view` decorator will ensure that this property is automatically set to a list of `Parser` instances, based on the `parser_classes` set on the view or based on the `DEFAULT_PARSER_CLASSES` setting.\n\nYou won't typically need to access this property.\n\n**Note:** If a client sends malformed content, then accessing `request.data` may raise a `ParseError`. By default REST framework's `APIView` class or `@api_view` decorator will catch the error and return a `400 Bad Request` response.\n\nIf a client sends a request with a content-type that cannot be parsed then a `UnsupportedMediaType` exception will be raised, which by default will be caught and return a `415 Unsupported Media Type` response.\n\n# Content negotiation\n\nThe request exposes some properties that allow you to determine the result of the content negotiation stage. This allows you to implement behavior such as selecting a different serialization schemes for different media types.\n\n## .accepted_renderer\n\nThe renderer instance that was selected by the content negotiation stage.\n\n## .accepted_media_type\n\nA string representing the media type that was accepted by the content negotiation stage.\n\n# Authentication\n\nREST framework provides flexible, per-request authentication, that gives you the ability to:\n\n- Use different authentication policies for different parts of your API.\n- Support the use of multiple authentication policies.\n- Provide both user and token information associated with the incoming request.\n\n## .user\n\n`request.user` typically returns an instance of `django.contrib.auth.models.User`, although the behavior depends on the authentication policy being used.\n\nIf the request is unauthenticated the default value of `request.user` is an instance of `django.contrib.auth.models.AnonymousUser`.\n\nFor more details see the [authentication documentation](../authentication/index).\n\n## .auth\n\n`request.auth` returns any additional authentication context. The exact behavior of `request.auth` depends on the authentication policy being used, but it may typically be an instance of the token that the request was authenticated against.\n\nIf the request is unauthenticated, or if no additional context is present, the default value of `request.auth` is `None`.\n\nFor more details see the [authentication documentation](../authentication/index).\n\n## .authenticators\n\nThe `APIView` class or `@api_view` decorator will ensure that this property is automatically set to a list of `Authentication` instances, based on the `authentication_classes` set on the view or based on the `DEFAULT_AUTHENTICATORS` setting.\n\nYou won't typically need to access this property.\n\n**Note:** You may see a `WrappedAttributeError` raised when calling the `.user` or `.auth` properties. These errors originate from an authenticator as a standard `AttributeError`, however it's necessary that they be re-raised as a different exception type in order to prevent them from being suppressed by the outer property access. Python will not recognize that the `AttributeError` originates from the authenticator and will instead assume that the request object does not have a `.user` or `.auth` property. The authenticator will need to be fixed.\n\n# Browser enhancements\n\nREST framework supports a few browser enhancements such as browser-based `PUT`, `PATCH` and `DELETE` forms.\n\n## .method\n\n`request.method` returns the **uppercased** string representation of the request's HTTP method.\n\nBrowser-based `PUT`, `PATCH` and `DELETE` forms are transparently supported.\n\nFor more information see the [browser enhancements documentation](https://www.django-rest-framework.org/topics/browser-enhancements/).\n\n## .content_type\n\n`request.content_type`, returns a string object representing the media type of the HTTP request's body, or an empty string if no media type was provided.\n\nYou won't typically need to directly access the request's content type, as you'll normally rely on REST framework's default request parsing behavior.\n\nIf you do need to access the content type of the request you should use the `.content_type` property in preference to using `request.META.get('HTTP_CONTENT_TYPE')`, as it provides transparent support for browser-based non-form content.\n\nFor more information see the [browser enhancements documentation](https://www.django-rest-framework.org/topics/browser-enhancements/).\n\n## .stream\n\n`request.stream` returns a stream representing the content of the request body.\n\nYou won't typically need to directly access the request's content, as you'll normally rely on REST framework's default request parsing behavior.\n\n# Standard HttpRequest attributes\n\nAs REST framework's `Request` extends Django's `HttpRequest`, all the other standard attributes and methods are also available. For example the `request.META` and `request.session` dictionaries are available as normal.\n\nNote that due to implementation reasons the `Request` class does not inherit from `HttpRequest` class, but instead extends the class using composition.\n\n[request.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/request.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/requests/](https://www.django-rest-framework.org/api-guide/requests/)"
- name: Responses
  id: api-guide/responses/index
  summary: Unlike basic HttpResponse objects, TemplateResponse objects retain the details of the context that was provided by the view to compute the response
  description: "# Responses\n\n> Unlike basic HttpResponse objects, TemplateResponse objects retain the details of the context that was provided by the view to compute the response. The final output of the response is not computed until it is needed, later in the response process.\n>\n> — [Django documentation](https://docs.djangoproject.com/en/stable/ref/template-response/)\n\nREST framework supports HTTP content negotiation by providing a `Response` class which allows you to return content that can be rendered into multiple content types, depending on the client request.\n\nThe `Response` class subclasses Django's `SimpleTemplateResponse`. `Response` objects are initialised with data, which should consist of native Python primitives. REST framework then uses standard HTTP content negotiation to determine how it should render the final response content.\n\nThere's no requirement for you to use the `Response` class, you can also return regular `HttpResponse` or `StreamingHttpResponse` objects from your views if required. Using the `Response` class simply provides a nicer interface for returning content-negotiated Web API responses, that can be rendered to multiple formats.\n\nUnless you want to heavily customize REST framework for some reason, you should always use an `APIView` class or `@api_view` function for views that return `Response` objects. Doing so ensures that the view can perform content negotiation and select the appropriate renderer for the response, before it is returned from the view.\n\n# Creating responses\n\n## Response()\n\n**Signature:** `Response(data, status=None, template_name=None, headers=None, content_type=None)`\n\nUnlike regular `HttpResponse` objects, you do not instantiate `Response` objects with rendered content. Instead you pass in unrendered data, which may consist of any Python primitives.\n\nThe renderers used by the `Response` class cannot natively handle complex datatypes such as Django model instances, so you need to serialize the data into primitive datatypes before creating the `Response` object.\n\nYou can use REST framework's `Serializer` classes to perform this data serialization, or use your own custom serialization.\n\nArguments:\n\n- `data`: The serialized data for the response.\n- `status`: A status code for the response. Defaults to 200. See also [status codes](../status-codes/index).\n- `template_name`: A template name to use if `HTMLRenderer` is selected.\n- `headers`: A dictionary of HTTP headers to use in the response.\n- `content_type`: The content type of the response. Typically, this will be set automatically by the renderer as determined by content negotiation, but there may be some cases where you need to specify the content type explicitly.\n\n# Attributes\n\n## .data\n\nThe unrendered, serialized data of the response.\n\n## .status_code\n\nThe numeric status code of the HTTP response.\n\n## .content\n\nThe rendered content of the response. The `.render()` method must have been called before `.content` can be accessed.\n\n## .template_name\n\nThe `template_name`, if supplied. Only required if `HTMLRenderer` or some other custom template renderer is the accepted renderer for the response.\n\n## .accepted_renderer\n\nThe renderer instance that will be used to render the response.\n\nSet automatically by the `APIView` or `@api_view` immediately before the response is returned from the view.\n\n## .accepted_media_type\n\nThe media type that was selected by the content negotiation stage.\n\nSet automatically by the `APIView` or `@api_view` immediately before the response is returned from the view.\n\n## .renderer_context\n\nA dictionary of additional context information that will be passed to the renderer's `.render()` method.\n\nSet automatically by the `APIView` or `@api_view` immediately before the response is returned from the view.\n\n# Standard HttpResponse attributes\n\nThe `Response` class extends `SimpleTemplateResponse`, and all the usual attributes and methods are also available on the response. For example you can set headers on the response in the standard way:\n\n``` python\nresponse = Response()\nresponse['Cache-Control'] = 'no-cache'\n```\n\n## .render()\n\n**Signature:** `.render()`\n\nAs with any other `TemplateResponse`, this method is called to render the serialized data of the response into the final response content. When `.render()` is called, the response content will be set to the result of calling the `.render(data, accepted_media_type, renderer_context)` method on the `accepted_renderer` instance.\n\nYou won't typically need to call `.render()` yourself, as it's handled by Django's standard response cycle.\n\n[response.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/response.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/responses/](https://www.django-rest-framework.org/api-guide/responses/)"
- name: RetrieveAPIView
  id: api-guide/generic-views/index#retrieveapiview
  summary: Used for read-only endpoints to represent a single model instance
  belongs_to: Generic views
  description: |-
    ## RetrieveAPIView

    Used for **read-only** endpoints to represent a **single model instance**.

    Provides a `get` method handler.

    Extends: [GenericAPIView](#genericapiview), [RetrieveModelMixin](#retrievemodelmixin)
- name: RetrieveDestroyAPIView
  id: api-guide/generic-views/index#retrievedestroyapiview
  summary: Used for read or delete endpoints to represent a single model instance
  belongs_to: Generic views
  description: |-
    ## RetrieveDestroyAPIView

    Used for **read or delete** endpoints to represent a **single model instance**.

    Provides `get` and `delete` method handlers.

    Extends: [GenericAPIView](#genericapiview), [RetrieveModelMixin](#retrievemodelmixin), [DestroyModelMixin](#destroymodelmixin)
- name: RetrieveModelMixin
  id: api-guide/generic-views/index#retrievemodelmixin
  summary: Provides a .retrieve(request, *args, **kwargs) method, that implements returning an existing model instance in a response
  belongs_to: Generic views
  description: |-
    ## RetrieveModelMixin

    Provides a `.retrieve(request, *args, **kwargs)` method, that implements returning an existing model instance in a response.

    If an object can be retrieved this returns a `200 OK` response, with a serialized representation of the object as the body of the response. Otherwise, it will return a `404 Not Found`.
- name: RetrieveUpdateAPIView
  id: api-guide/generic-views/index#retrieveupdateapiview
  summary: Used for read or update endpoints to represent a single model instance
  belongs_to: Generic views
  description: |-
    ## RetrieveUpdateAPIView

    Used for **read or update** endpoints to represent a **single model instance**.

    Provides `get`, `put` and `patch` method handlers.

    Extends: [GenericAPIView](#genericapiview), [RetrieveModelMixin](#retrievemodelmixin), [UpdateModelMixin](#updatemodelmixin)
- name: RetrieveUpdateDestroyAPIView
  id: api-guide/generic-views/index#retrieveupdatedestroyapiview
  summary: Used for read-write-delete endpoints to represent a single model instance
  belongs_to: Generic views
  description: "## RetrieveUpdateDestroyAPIView\n\nUsed for **read-write-delete** endpoints to represent a **single model instance**.\n\nProvides `get`, `put`, `patch` and `delete` method handlers.\n\nExtends: [GenericAPIView](#genericapiview), [RetrieveModelMixin](#retrievemodelmixin), [UpdateModelMixin](#updatemodelmixin), [DestroyModelMixin](#destroymodelmixin)\n\n# Customizing the generic views\n\nOften you'll want to use the existing generic views, but use some slightly customized behavior. If you find yourself reusing some bit of customized behavior in multiple places, you might want to refactor the behavior into a common class that you can then just apply to any view or viewset as needed.\n\n## Creating custom mixins\n\nFor example, if you need to lookup objects based on multiple fields in the URL conf, you could create a mixin class like the following:\n\n``` python\nclass MultipleFieldLookupMixin:\n    \"\"\"\n    Apply this mixin to any view or viewset to get multiple field filtering\n    based on a `lookup_fields` attribute, instead of the default single field filtering.\n    \"\"\"\n    def get_object(self):\n        queryset = self.get_queryset()             # Get the base queryset\n        queryset = self.filter_queryset(queryset)  # Apply any filter backends\n        filter = {}\n        for field in self.lookup_fields:\n            if self.kwargs.get(field): # Ignore empty fields.\n                filter[field] = self.kwargs[field]\n        obj = get_object_or_404(queryset, **filter)  # Lookup the object\n        self.check_object_permissions(self.request, obj)\n        return obj\n```\n\nYou can then simply apply this mixin to a view or viewset anytime you need to apply the custom behavior.\n\n``` python\nclass RetrieveUserView(MultipleFieldLookupMixin, generics.RetrieveAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    lookup_fields = ['account', 'username']\n```\n\nUsing custom mixins is a good option if you have custom behavior that needs to be used.\n\n## Creating custom base classes\n\nIf you are using a mixin across multiple views, you can take this a step further and create your own set of base views that can then be used throughout your project. For example:\n\n``` python\nclass BaseRetrieveView(MultipleFieldLookupMixin,\n                       generics.RetrieveAPIView):\n    pass\n\nclass BaseRetrieveUpdateDestroyView(MultipleFieldLookupMixin,\n                                    generics.RetrieveUpdateDestroyAPIView):\n    pass\n```\n\nUsing custom base classes is a good option if you have custom behavior that consistently needs to be repeated across a large number of views throughout your project.\n\n# PUT as create\n\nPrior to version 3.0 the REST framework mixins treated `PUT` as either an update or a create operation, depending on if the object already existed or not.\n\nAllowing `PUT` as create operations is problematic, as it necessarily exposes information about the existence or non-existence of objects. It's also not obvious that transparently allowing re-creating of previously deleted instances is necessarily a better default behavior than simply returning `404` responses.\n\nBoth styles \"`PUT` as 404\" and \"`PUT` as create\" can be valid in different circumstances, but from version 3.0 onwards we now use 404 behavior as the default, due to it being simpler and more obvious.\n\nIf you need to generic PUT-as-create behavior you may want to include something like [this `AllowPUTAsCreateMixin` class](https://gist.github.com/tomchristie/a2ace4577eff2c603b1b) as a mixin to your views.\n\n# Third party packages\n\nThe following third party packages provide additional generic view implementations.\n\n## Django Rest Multiple Models\n\n[Django Rest Multiple Models](https://github.com/MattBroach/DjangoRestMultipleModels) provides a generic view (and mixin) for sending multiple serialized models and/or querysets via a single API request.\n\n[mixins.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/mixins.py) [generics.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/generics.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/generic-views/](https://www.django-rest-framework.org/api-guide/generic-views/)"
- name: Returning URLs
  id: api-guide/reverse/index
  summary: The central feature that distinguishes the REST architectural style from other network-based styles is its emphasis on a uniform interface between components
  description: "# Returning URLs\n\n> The central feature that distinguishes the REST architectural style from other network-based styles is its emphasis on a uniform interface between components.\n>\n> — Roy Fielding, [Architectural Styles and the Design of Network-based Software Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_5)\n\nAs a rule, it's probably better practice to return absolute URIs from your Web APIs, such as `http://example.com/foobar`, rather than returning relative URIs, such as `/foobar`.\n\nThe advantages of doing so are:\n\n- It's more explicit.\n- It leaves less work for your API clients.\n- There's no ambiguity about the meaning of the string when it's found in representations such as JSON that do not have a native URI type.\n- It makes it easy to do things like markup HTML representations with hyperlinks.\n\nREST framework provides two utility functions to make it more simple to return absolute URIs from your Web API.\n\nThere's no requirement for you to use them, but if you do then the self-describing API will be able to automatically hyperlink its output for you, which makes browsing the API much easier.\n\n## reverse\n\n**Signature:** `reverse(viewname, *args, **kwargs)`\n\nHas the same behavior as [`django.urls.reverse`](https://docs.djangoproject.com/en/stable/ref/urlresolvers/#reverse), except that it returns a fully qualified URL, using the request to determine the host and port.\n\nYou should **include the request as a keyword argument** to the function, for example:\n\n``` python\nfrom rest_framework.reverse import reverse\nfrom rest_framework.views import APIView\nfrom django.utils.timezone import now\n\nclass APIRootView(APIView):\n    def get(self, request):\n        year = now().year\n        data = {\n            ...\n            'year-summary-url': reverse('year-summary', args=[year], request=request)\n        }\n        return Response(data)\n```\n\n## reverse_lazy\n\n**Signature:** `reverse_lazy(viewname, *args, **kwargs)`\n\nHas the same behavior as [`django.urls.reverse_lazy`](https://docs.djangoproject.com/en/stable/ref/urlresolvers/#reverse-lazy), except that it returns a fully qualified URL, using the request to determine the host and port.\n\nAs with the `reverse` function, you should **include the request as a keyword argument** to the function, for example:\n\n``` python\napi_root = reverse_lazy('api-root', request=request)\n```\n\n[reverse.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/reverse.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/reverse/](https://www.django-rest-framework.org/api-guide/reverse/)"
- name: Routers
  id: api-guide/routers/index
  summary: Resource routing allows you to quickly declare all of the common routes for a given resourceful controller
  description: "# Routers\n\n> Resource routing allows you to quickly declare all of the common routes for a given resourceful controller. Instead of declaring separate routes for your index... a resourceful route declares them in a single line of code.\n>\n> — [Ruby on Rails Documentation](https://guides.rubyonrails.org/routing.html)\n\nSome Web frameworks such as Rails provide functionality for automatically determining how the URLs for an application should be mapped to the logic that deals with handling incoming requests.\n\nREST framework adds support for automatic URL routing to Django, and provides you with a simple, quick and consistent way of wiring your view logic to a set of URLs.\n\n## Usage\n\nHere's an example of a simple URL conf, that uses `SimpleRouter`.\n\n``` python\nfrom rest_framework import routers\n\nrouter = routers.SimpleRouter()\nrouter.register(r'users', UserViewSet)\nrouter.register(r'accounts', AccountViewSet)\nurlpatterns = router.urls\n```\n\nThere are two mandatory arguments to the `register()` method:\n\n- `prefix` - The URL prefix to use for this set of routes.\n- `viewset` - The viewset class.\n\nOptionally, you may also specify an additional argument:\n\n- `basename` - The base to use for the URL names that are created. If unset the basename will be automatically generated based on the `queryset` attribute of the viewset, if it has one. Note that if the viewset does not include a `queryset` attribute then you must set `basename` when registering the viewset.\n\nThe example above would generate the following URL patterns:\n\n- URL pattern: `^users/$` Name: `'user-list'`\n- URL pattern: `^users/{pk}/$` Name: `'user-detail'`\n- URL pattern: `^accounts/$` Name: `'account-list'`\n- URL pattern: `^accounts/{pk}/$` Name: `'account-detail'`\n\n**Note**: The `basename` argument is used to specify the initial part of the view name pattern. In the example above, that's the `user` or `account` part.\n\nTypically you won't *need* to specify the `basename` argument, but if you have a viewset where you've defined a custom `get_queryset` method, then the viewset may not have a `.queryset` attribute set. If you try to register that viewset you'll see an error like this:\n\n``` python\n'basename' argument not specified, and could not automatically determine the name from the viewset, as it does not have a '.queryset' attribute.\n```\n\nThis means you'll need to explicitly set the `basename` argument when registering the viewset, as it could not be automatically determined from the model name.\n\n### Using include with routers\n\nThe `.urls` attribute on a router instance is simply a standard list of URL patterns. There are a number of different styles for how you can include these URLs.\n\nFor example, you can append `router.urls` to a list of existing views...\n\n``` python\nrouter = routers.SimpleRouter()\nrouter.register(r'users', UserViewSet)\nrouter.register(r'accounts', AccountViewSet)\n\nurlpatterns = [\n    path('forgot-password/', ForgotPasswordFormView.as_view()),\n]\n\nurlpatterns += router.urls\n```\n\nAlternatively you can use Django's `include` function, like so...\n\n``` python\nurlpatterns = [\n    path('forgot-password', ForgotPasswordFormView.as_view()),\n    path('', include(router.urls)),\n]\n```\n\nYou may use `include` with an application namespace:\n\n``` python\nurlpatterns = [\n    path('forgot-password/', ForgotPasswordFormView.as_view()),\n    path('api/', include((router.urls, 'app_name'))),\n]\n```\n\nOr both an application and instance namespace:\n\n``` python\nurlpatterns = [\n    path('forgot-password/', ForgotPasswordFormView.as_view()),\n    path('api/', include((router.urls, 'app_name'), namespace='instance_name')),\n]\n```\n\nSee Django's [URL namespaces docs](https://docs.djangoproject.com/en/4.0/topics/http/urls/#url-namespaces) and the [`include` API reference](https://docs.djangoproject.com/en/4.0/ref/urls/#include) for more details.\n\n**Note**: If using namespacing with hyperlinked serializers you'll also need to ensure that any `view_name` parameters on the serializers correctly reflect the namespace. In the examples above you'd need to include a parameter such as `view_name='app_name:user-detail'` for serializer fields hyperlinked to the user detail view.\n\nThe automatic `view_name` generation uses a pattern like `%(model_name)-detail`. Unless your models names actually clash you may be better off **not** namespacing your Django REST Framework views when using hyperlinked serializers.\n\n### Routing for extra actions\n\nA viewset may [mark extra actions for routing](../viewsets/index#marking-extra-actions-for-routing) by decorating a method with the `@action` decorator. These extra actions will be included in the generated routes. For example, given the `set_password` method on the `UserViewSet` class:\n\n``` python\nfrom myapp.permissions import IsAdminOrIsSelf\nfrom rest_framework.decorators import action\n\nclass UserViewSet(ModelViewSet):\n    ...\n\n    @action(methods=['post'], detail=True, permission_classes=[IsAdminOrIsSelf])\n    def set_password(self, request, pk=None):\n        ...\n```\n\nThe following route would be generated:\n\n- URL pattern: `^users/{pk}/set_password/$`\n- URL name: `'user-set-password'`\n\nBy default, the URL pattern is based on the method name, and the URL name is the combination of the `ViewSet.basename` and the hyphenated method name. If you don't want to use the defaults for either of these values, you can instead provide the `url_path` and `url_name` arguments to the `@action` decorator.\n\nFor example, if you want to change the URL for our custom action to `^users/{pk}/change-password/$`, you could write:\n\n``` python\nfrom myapp.permissions import IsAdminOrIsSelf\nfrom rest_framework.decorators import action\n\nclass UserViewSet(ModelViewSet):\n    ...\n\n    @action(methods=['post'], detail=True, permission_classes=[IsAdminOrIsSelf],\n            url_path='change-password', url_name='change_password')\n    def set_password(self, request, pk=None):\n        ...\n```\n\nThe above example would now generate the following URL pattern:\n\n- URL path: `^users/{pk}/change-password/$`\n- URL name: `'user-change_password'`\n\n# API Guide\n\n## SimpleRouter\n\nThis router includes routes for the standard set of `list`, `create`, `retrieve`, `update`, `partial_update` and `destroy` actions. The viewset can also mark additional methods to be routed, using the `@action` decorator.\n\n|                               |                                              |                                            |                       |\n|-------------------------------|----------------------------------------------|--------------------------------------------|-----------------------|\n| URL Style                     | HTTP Method                                  | Action                                     | URL Name              |\n| {prefix}/                     | GET                                          | list                                       | {basename}-list       |\n|                               | POST                                         | create                                     |                       |\n| {prefix}/{url_path}/          | GET, or as specified by \\`methods\\` argument | \\`@action(detail=False)\\` decorated method | {basename}-{url_name} |\n| {prefix}/{lookup}/            | GET                                          | retrieve                                   | {basename}-detail     |\n|                               | PUT                                          | update                                     |                       |\n|                               | PATCH                                        | partial_update                             |                       |\n|                               | DELETE                                       | destroy                                    |                       |\n| {prefix}/{lookup}/{url_path}/ | GET, or as specified by \\`methods\\` argument | \\`@action(detail=True)\\` decorated method  | {basename}-{url_name} |\n\nBy default the URLs created by `SimpleRouter` are appended with a trailing slash. This behavior can be modified by setting the `trailing_slash` argument to `False` when instantiating the router. For example:\n\n``` python\nrouter = SimpleRouter(trailing_slash=False)\n```\n\nTrailing slashes are conventional in Django, but are not used by default in some other frameworks such as Rails. Which style you choose to use is largely a matter of preference, although some javascript frameworks may expect a particular routing style.\n\nBy default the URLs created by `SimpleRouter` use regular expressions. This behavior can be modified by setting the `use_regex_path` argument to `False` when instantiating the router, in this case [path converters](https://docs.djangoproject.com/en/2.0/topics/http/urls/#path-converters) are used. For example:\n\n``` python\nrouter = SimpleRouter(use_regex_path=False)\n```\n\n**Note**: `use_regex_path=False` only works with Django 2.x or above, since this feature was introduced in 2.0.0. See [release note](https://docs.djangoproject.com/en/2.0/releases/2.0/#simplified-url-routing-syntax)\n\nThe router will match lookup values containing any characters except slashes and period characters. For a more restrictive (or lenient) lookup pattern, set the `lookup_value_regex` attribute on the viewset or `lookup_value_converter` if using path converters. For example, you can limit the lookup to valid UUIDs:\n\n``` python\nclass MyModelViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet):\n    lookup_field = 'my_model_id'\n    lookup_value_regex = '[0-9a-f]{32}'\n\nclass MyPathModelViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet):\n    lookup_field = 'my_model_uuid'\n    lookup_value_converter = 'uuid'\n```\n\n## DefaultRouter\n\nThis router is similar to `SimpleRouter` as above, but additionally includes a default API root view, that returns a response containing hyperlinks to all the list views. It also generates routes for optional `.json` style format suffixes.\n\n|                                          |                                              |                                            |                       |\n|------------------------------------------|----------------------------------------------|--------------------------------------------|-----------------------|\n| URL Style                                | HTTP Method                                  | Action                                     | URL Name              |\n| \\[.format\\]                              | GET                                          | automatically generated root view          | api-root              |\n| {prefix}/\\[.format\\]                     | GET                                          | list                                       | {basename}-list       |\n|                                          | POST                                         | create                                     |                       |\n| {prefix}/{url_path}/\\[.format\\]          | GET, or as specified by \\`methods\\` argument | \\`@action(detail=False)\\` decorated method | {basename}-{url_name} |\n| {prefix}/{lookup}/\\[.format\\]            | GET                                          | retrieve                                   | {basename}-detail     |\n|                                          | PUT                                          | update                                     |                       |\n|                                          | PATCH                                        | partial_update                             |                       |\n|                                          | DELETE                                       | destroy                                    |                       |\n| {prefix}/{lookup}/{url_path}/\\[.format\\] | GET, or as specified by \\`methods\\` argument | \\`@action(detail=True)\\` decorated method  | {basename}-{url_name} |\n\nAs with `SimpleRouter` the trailing slashes on the URL routes can be removed by setting the `trailing_slash` argument to `False` when instantiating the router.\n\n``` python\nrouter = DefaultRouter(trailing_slash=False)\n```\n\n# Custom Routers\n\nImplementing a custom router isn't something you'd need to do very often, but it can be useful if you have specific requirements about how the URLs for your API are structured. Doing so allows you to encapsulate the URL structure in a reusable way that ensures you don't have to write your URL patterns explicitly for each new view.\n\nThe simplest way to implement a custom router is to subclass one of the existing router classes. The `.routes` attribute is used to template the URL patterns that will be mapped to each viewset. The `.routes` attribute is a list of `Route` named tuples.\n\nThe arguments to the `Route` named tuple are:\n\n**url**: A string representing the URL to be routed. May include the following format strings:\n\n- `{prefix}` - The URL prefix to use for this set of routes.\n- `{lookup}` - The lookup field used to match against a single instance.\n- `{trailing_slash}` - Either a '/' or an empty string, depending on the `trailing_slash` argument.\n\n**mapping**: A mapping of HTTP method names to the view methods\n\n**name**: The name of the URL as used in `reverse` calls. May include the following format string:\n\n- `{basename}` - The base to use for the URL names that are created.\n\n**initkwargs**: A dictionary of any additional arguments that should be passed when instantiating the view. Note that the `detail`, `basename`, and `suffix` arguments are reserved for viewset introspection and are also used by the browsable API to generate the view name and breadcrumb links.\n\n## Customizing dynamic routes\n\nYou can also customize how the `@action` decorator is routed. Include the `DynamicRoute` named tuple in the `.routes` list, setting the `detail` argument as appropriate for the list-based and detail-based routes. In addition to `detail`, the arguments to `DynamicRoute` are:\n\n**url**: A string representing the URL to be routed. May include the same format strings as `Route`, and additionally accepts the `{url_path}` format string.\n\n**name**: The name of the URL as used in `reverse` calls. May include the following format strings:\n\n- `{basename}` - The base to use for the URL names that are created.\n- `{url_name}` - The `url_name` provided to the `@action`.\n\n**initkwargs**: A dictionary of any additional arguments that should be passed when instantiating the view.\n\n## Example\n\nThe following example will only route to the `list` and `retrieve` actions, and does not use the trailing slash convention.\n\n``` python\nfrom rest_framework.routers import Route, DynamicRoute, SimpleRouter\n\nclass CustomReadOnlyRouter(SimpleRouter):\n    \"\"\"\n    A router for read-only APIs, which doesn't use trailing slashes.\n    \"\"\"\n    routes = [\n        Route(\n            url=r'^{prefix}$',\n            mapping={'get': 'list'},\n            name='{basename}-list',\n            detail=False,\n            initkwargs={'suffix': 'List'}\n        ),\n        Route(\n            url=r'^{prefix}/{lookup}$',\n            mapping={'get': 'retrieve'},\n            name='{basename}-detail',\n            detail=True,\n            initkwargs={'suffix': 'Detail'}\n        ),\n        DynamicRoute(\n            url=r'^{prefix}/{lookup}/{url_path}$',\n            name='{basename}-{url_name}',\n            detail=True,\n            initkwargs={}\n        )\n    ]\n```\n\nLet's take a look at the routes our `CustomReadOnlyRouter` would generate for a simple viewset.\n\n`views.py`:\n\n``` python\nclass UserViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    A viewset that provides the standard actions\n    \"\"\"\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    lookup_field = 'username'\n\n    @action(detail=True)\n    def group_names(self, request, pk=None):\n        \"\"\"\n        Returns a list of all the group names that the given\n        user belongs to.\n        \"\"\"\n        user = self.get_object()\n        groups = user.groups.all()\n        return Response([group.name for group in groups])\n```\n\n`urls.py`:\n\n``` python\nrouter = CustomReadOnlyRouter()\nrouter.register('users', UserViewSet)\nurlpatterns = router.urls\n```\n\nThe following mappings would be generated...\n\n|                               |             |             |                  |\n|-------------------------------|-------------|-------------|------------------|\n| URL                           | HTTP Method | Action      | URL Name         |\n| /users                        | GET         | list        | user-list        |\n| /users/{username}             | GET         | retrieve    | user-detail      |\n| /users/{username}/group_names | GET         | group_names | user-group-names |\n\nFor another example of setting the `.routes` attribute, see the source code for the `SimpleRouter` class.\n\n## Advanced custom routers\n\nIf you want to provide totally custom behavior, you can override `BaseRouter` and override the `get_urls(self)` method. The method should inspect the registered viewsets and return a list of URL patterns. The registered prefix, viewset and basename tuples may be inspected by accessing the `self.registry` attribute.\n\nYou may also want to override the `get_default_basename(self, viewset)` method, or else always explicitly set the `basename` argument when registering your viewsets with the router.\n\n# Third Party Packages\n\nThe following third party packages are also available.\n\n## DRF Nested Routers\n\nThe [drf-nested-routers package](https://github.com/alanjds/drf-nested-routers) provides routers and relationship fields for working with nested resources.\n\n## ModelRouter (wq.db.rest)\n\nThe [wq.db package](https://wq.io/wq.db) provides an advanced [ModelRouter](https://wq.io/docs/router) class (and singleton instance) that extends `DefaultRouter` with a `register_model()` API. Much like Django's `admin.site.register`, the only required argument to `rest.router.register_model` is a model class. Reasonable defaults for a url prefix, serializer, and viewset will be inferred from the model and global configuration.\n\n``` python\nfrom wq.db import rest\nfrom myapp.models import MyModel\n\nrest.router.register_model(MyModel)\n```\n\n## DRF-extensions\n\nThe [`DRF-extensions` package](https://chibisov.github.io/drf-extensions/docs/) provides [routers](https://chibisov.github.io/drf-extensions/docs/#routers) for creating [nested viewsets](https://chibisov.github.io/drf-extensions/docs/#nested-routes), [collection level controllers](https://chibisov.github.io/drf-extensions/docs/#collection-level-controllers) with [customizable endpoint names](https://chibisov.github.io/drf-extensions/docs/#controller-endpoint-name).\n\n[routers.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/routers.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/routers/](https://www.django-rest-framework.org/api-guide/routers/)"
- name: Schema
  id: api-guide/schemas/index
  summary: A machine-readable [schema] describes what resources are available via the API, what their URLs are, how they are represented and what operations they support
  description: "# Schema\n\n> A machine-readable \\[schema\\] describes what resources are available via the API, what their URLs are, how they are represented and what operations they support.\n>\n> — Heroku, [JSON Schema for the Heroku Platform API](https://blog.heroku.com/archives/2014/1/8/json_schema_for_heroku_platform_api)\n\n**Deprecation notice:**\n\nREST framework's built-in support for generating OpenAPI schemas is **deprecated** in favor of 3rd party packages that can provide this functionality instead. The built-in support will be moved into a separate package and then subsequently retired over the next releases.\n\nAs a full-fledged replacement, we recommend the [drf-spectacular](https://drf-spectacular.readthedocs.io/en/latest/readme.html) package. It has extensive support for generating OpenAPI 3 schemas from REST framework APIs, with both automatic and customisable options available. For further information please refer to [Documenting your API](https://www.django-rest-framework.org/topics/documenting-your-api/#drf-spectacular).\n\nAPI schemas are a useful tool that allow for a range of use cases, including generating reference documentation, or driving dynamic client libraries that can interact with your API.\n\nDjango REST Framework provides support for automatic generation of [OpenAPI](https://github.com/OAI/OpenAPI-Specification) schemas.\n\n## Overview\n\nSchema generation has several moving parts. It's worth having an overview:\n\n- `SchemaGenerator` is a top-level class that is responsible for walking your configured URL patterns, finding `APIView` subclasses, enquiring for their schema representation, and compiling the final schema object.\n- `AutoSchema` encapsulates all the details necessary for per-view schema introspection. Is attached to each view via the `schema` attribute. You subclass `AutoSchema` in order to customize your schema.\n- The `generateschema` management command allows you to generate a static schema offline.\n- Alternatively, you can route `SchemaView` to dynamically generate and serve your schema.\n- `settings.DEFAULT_SCHEMA_CLASS` allows you to specify an `AutoSchema` subclass to serve as your project's default.\n\nThe following sections explain more.\n\n## Generating an OpenAPI Schema\n\n### Install dependencies\n\n``` python\npip install pyyaml uritemplate inflection\n```\n\n- `pyyaml` is used to generate schema into YAML-based OpenAPI format.\n- `uritemplate` is used internally to get parameters in path.\n- `inflection` is used to pluralize operations more appropriately in the list endpoints.\n\n### Generating a static schema with the generateschema management command\n\nIf your schema is static, you can use the `generateschema` management command:\n\n``` python\n./manage.py generateschema --file openapi-schema.yml\n```\n\nOnce you've generated a schema in this way you can annotate it with any additional information that cannot be automatically inferred by the schema generator.\n\nYou might want to check your API schema into version control and update it with each new release, or serve the API schema from your site's static media.\n\n### Generating a dynamic schema with SchemaView\n\nIf you require a dynamic schema, because foreign key choices depend on database values, for example, you can route a `SchemaView` that will generate and serve your schema on demand.\n\nTo route a `SchemaView`, use the `get_schema_view()` helper.\n\nIn `urls.py`:\n\n``` python\nfrom rest_framework.schemas import get_schema_view\n\nurlpatterns = [\n    # ...\n    # Use the `get_schema_view()` helper to add a `SchemaView` to project URLs.\n    #   * `title` and `description` parameters are passed to `SchemaGenerator`.\n    #   * Provide view name for use with `reverse()`.\n    path(\n        \"openapi\",\n        get_schema_view(\n            title=\"Your Project\", description=\"API for all things …\", version=\"1.0.0\"\n        ),\n        name=\"openapi-schema\",\n    ),\n    # ...\n]\n```\n\n#### get_schema_view()\n\nThe `get_schema_view()` helper takes the following keyword arguments:\n\n- `title`: May be used to provide a descriptive title for the schema definition.\n\n- `description`: Longer descriptive text.\n\n- `version`: The version of the API.\n\n- `url`: May be used to pass a canonical base URL for the schema.\n\n  ``` python\n  schema_view = get_schema_view(\n      title='Server Monitoring API',\n      url='https://www.example.org/api/'\n  )\n  ```\n\n- `urlconf`: A string representing the import path to the URL conf that you want to generate an API schema for. This defaults to the value of Django's `ROOT_URLCONF` setting.\n\n  ``` python\n  schema_view = get_schema_view(\n      title='Server Monitoring API',\n      url='https://www.example.org/api/',\n      urlconf='myproject.urls'\n  )\n  ```\n\n- `patterns`: List of url patterns to limit the schema introspection to. If you only want the `myproject.api` urls to be exposed in the schema:\n\n  ``` python\n  schema_url_patterns = [\n      path('api/', include('myproject.api.urls')),\n  ]\n\n  schema_view = get_schema_view(\n      title='Server Monitoring API',\n      url='https://www.example.org/api/',\n      patterns=schema_url_patterns,\n  )\n  ```\n\n  - `public`: May be used to specify if schema should bypass views permissions. Default to False\n\n- `generator_class`: May be used to specify a `SchemaGenerator` subclass to be passed to the `SchemaView`.\n\n- `authentication_classes`: May be used to specify the list of authentication classes that will apply to the schema endpoint. Defaults to `settings.DEFAULT_AUTHENTICATION_CLASSES`\n\n- `permission_classes`: May be used to specify the list of permission classes that will apply to the schema endpoint. Defaults to `settings.DEFAULT_PERMISSION_CLASSES`.\n\n- `renderer_classes`: May be used to pass the set of renderer classes that can be used to render the API root endpoint.\n\n## SchemaGenerator\n\n**Schema-level customization**\n\n``` python\nfrom rest_framework.schemas.openapi import SchemaGenerator\n```\n\n`SchemaGenerator` is a class that walks a list of routed URL patterns, requests the schema for each view and collates the resulting OpenAPI schema.\n\nTypically you won't need to instantiate `SchemaGenerator` yourself, but you can do so like so:\n\n``` python\ngenerator = SchemaGenerator(title='Stock Prices API')\n```\n\nArguments:\n\n- `title` **required**: The name of the API.\n- `description`: Longer descriptive text.\n- `version`: The version of the API. Defaults to `0.1.0`.\n- `url`: The root URL of the API schema. This option is not required unless the schema is included under path prefix.\n- `patterns`: A list of URLs to inspect when generating the schema. Defaults to the project's URL conf.\n- `urlconf`: A URL conf module name to use when generating the schema. Defaults to `settings.ROOT_URLCONF`.\n\nIn order to customize the top-level schema, subclass `rest_framework.schemas.openapi.SchemaGenerator` and provide your subclass as an argument to the `generateschema` command or `get_schema_view()` helper function.\n\n### get_schema(self, request=None, public=False)\n\nReturns a dictionary that represents the OpenAPI schema:\n\n``` python\ngenerator = SchemaGenerator(title='Stock Prices API')\nschema = generator.get_schema()\n```\n\nThe `request` argument is optional, and may be used if you want to apply per-user permissions to the resulting schema generation.\n\nThis is a good point to override if you want to customize the generated dictionary For example you might wish to add terms of service to the [top-level `info` object](https://swagger.io/specification/#infoObject):\n\n``` python\nclass TOSSchemaGenerator(SchemaGenerator):\n    def get_schema(self, *args, **kwargs):\n        schema = super().get_schema(*args, **kwargs)\n        schema[\"info\"][\"termsOfService\"] = \"https://example.com/tos.html\"\n        return schema\n```\n\n## AutoSchema\n\n**Per-View Customization**\n\n``` python\nfrom rest_framework.schemas.openapi import AutoSchema\n```\n\nBy default, view introspection is performed by an `AutoSchema` instance accessible via the `schema` attribute on `APIView`.\n\n``` python\nauto_schema = some_view.schema\n```\n\n`AutoSchema` provides the OpenAPI elements needed for each view, request method and path:\n\n- A list of [OpenAPI components](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#componentsObject). In DRF terms these are mappings of serializers that describe request and response bodies.\n- The appropriate [OpenAPI operation object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#operationObject) that describes the endpoint, including path and query parameters for pagination, filtering, and so on.\n\n``` python\ncomponents = auto_schema.get_components(...)\noperation = auto_schema.get_operation(...)\n```\n\nIn compiling the schema, `SchemaGenerator` calls `get_components()` and `get_operation()` for each view, allowed method, and path.\n\n**Note**: The automatic introspection of components, and many operation parameters relies on the relevant attributes and methods of `GenericAPIView`: `get_serializer()`, `pagination_class`, `filter_backends`, etc. For basic `APIView` subclasses, default introspection is essentially limited to the URL kwarg path parameters for this reason.\n\n`AutoSchema` encapsulates the view introspection needed for schema generation. Because of this all the schema generation logic is kept in a single place, rather than being spread around the already extensive view, serializer and field APIs.\n\nKeeping with this pattern, try not to let schema logic leak into your own views, serializers, or fields when customizing the schema generation. You might be tempted to do something like this:\n\n``` python\nclass CustomSchema(AutoSchema):\n    \"\"\"\n    AutoSchema subclass using schema_extra_info on the view.\n    \"\"\"\n\n    ...\n\n\nclass CustomView(APIView):\n    schema = CustomSchema()\n    schema_extra_info = ...  # some extra info\n```\n\nHere, the `AutoSchema` subclass goes looking for `schema_extra_info` on the view. This is *OK* (it doesn't actually hurt) but it means you'll end up with your schema logic spread out in a number of different places.\n\nInstead try to subclass `AutoSchema` such that the `extra_info` doesn't leak out into the view:\n\n``` python\nclass BaseSchema(AutoSchema):\n    \"\"\"\n    AutoSchema subclass that knows how to use extra_info.\n    \"\"\"\n\n    ...\n\n\nclass CustomSchema(BaseSchema):\n    extra_info = ...  # some extra info\n\n\nclass CustomView(APIView):\n    schema = CustomSchema()\n```\n\nThis style is slightly more verbose but maintains the encapsulation of the schema related code. It's more *cohesive* in the *parlance*. It'll keep the rest of your API code more tidy.\n\nIf an option applies to many view classes, rather than creating a specific subclass per-view, you may find it more convenient to allow specifying the option as an `__init__()` kwarg to your base `AutoSchema` subclass:\n\n``` python\nclass CustomSchema(BaseSchema):\n    def __init__(self, **kwargs):\n        # store extra_info for later\n        self.extra_info = kwargs.pop(\"extra_info\")\n        super().__init__(**kwargs)\n\n\nclass CustomView(APIView):\n    schema = CustomSchema(extra_info=...)  # some extra info\n```\n\nThis saves you having to create a custom subclass per-view for a commonly used option.\n\nNot all `AutoSchema` methods expose related `__init__()` kwargs, but those for the more commonly needed options do.\n\n### AutoSchema methods\n\n#### get_components()\n\nGenerates the OpenAPI components that describe request and response bodies, deriving their properties from the serializer.\n\nReturns a dictionary mapping the component name to the generated representation. By default this has just a single pair but you may override `get_components()` to return multiple pairs if your view uses multiple serializers.\n\n#### get_component_name()\n\nComputes the component's name from the serializer.\n\nYou may see warnings if your API has duplicate component names. If so you can override `get_component_name()` or pass the `component_name` `__init__()` kwarg (see below) to provide different names.\n\n#### get_reference()\n\nReturns a reference to the serializer component. This may be useful if you override `get_schema()`.\n\n#### map_serializer()\n\nMaps serializers to their OpenAPI representations.\n\nMost serializers should conform to the standard OpenAPI `object` type, but you may wish to override `map_serializer()` in order to customize this or other serializer-level fields.\n\n#### map_field()\n\nMaps individual serializer fields to their schema representation. The base implementation will handle the default fields that Django REST Framework provides.\n\nFor `SerializerMethodField` instances, for which the schema is unknown, or custom field subclasses you should override `map_field()` to generate the correct schema:\n\n``` python\nclass CustomSchema(AutoSchema):\n    \"\"\"Extension of ``AutoSchema`` to add support for custom field schemas.\"\"\"\n\n    def map_field(self, field):\n        # Handle SerializerMethodFields or custom fields here...\n        # ...\n        return super().map_field(field)\n```\n\nAuthors of third-party packages should aim to provide an `AutoSchema` subclass, and a mixin, overriding `map_field()` so that users can easily generate schemas for their custom fields.\n\n#### get_tags()\n\nOpenAPI groups operations by tags. By default tags taken from the first path segment of the routed URL. For example, a URL like `/users/{id}/` will generate the tag `users`.\n\nYou can pass an `__init__()` kwarg to manually specify tags (see below), or override `get_tags()` to provide custom logic.\n\n#### get_operation()\n\nReturns the [OpenAPI operation object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#operationObject) that describes the endpoint, including path and query parameters for pagination, filtering, and so on.\n\nTogether with `get_components()`, this is the main entry point to the view introspection.\n\n#### get_operation_id()\n\nThere must be a unique [operationid](openapi-operationid) for each operation. By default the `operationId` is deduced from the model name, serializer name or view name. The operationId looks like \"listItems\", \"retrieveItem\", \"updateItem\", etc. The `operationId` is camelCase by convention.\n\n#### get_operation_id_base()\n\nIf you have several views with the same model name, you may see duplicate operationIds.\n\nIn order to work around this, you can override `get_operation_id_base()` to provide a different base for name part of the ID.\n\n#### get_serializer()\n\nIf the view has implemented `get_serializer()`, returns the result.\n\n#### get_request_serializer()\n\nBy default returns `get_serializer()` but can be overridden to differentiate between request and response objects.\n\n#### get_response_serializer()\n\nBy default returns `get_serializer()` but can be overridden to differentiate between request and response objects.\n\n### AutoSchema.\\_\\_init\\_\\_() kwargs\n\n`AutoSchema` provides a number of `__init__()` kwargs that can be used for common customizations, if the default generated values are not appropriate.\n\nThe available kwargs are:\n\n- `tags`: Specify a list of tags.\n- `component_name`: Specify the component name.\n- `operation_id_base`: Specify the resource-name part of operation IDs.\n\nYou pass the kwargs when declaring the `AutoSchema` instance on your view:\n\n``` python\nclass PetDetailView(generics.RetrieveUpdateDestroyAPIView):\n    schema = AutoSchema(\n        tags=['Pets'],\n        component_name='Pet',\n        operation_id_base='Pet',\n    )\n    ...\n```\n\nAssuming a `Pet` model and `PetSerializer` serializer, the kwargs in this example are probably not needed. Often, though, you'll need to pass the kwargs if you have multiple view targeting the same model, or have multiple views with identically named serializers.\n\nIf your views have related customizations that are needed frequently, you can create a base `AutoSchema` subclass for your project that takes additional `__init__()` kwargs to save subclassing `AutoSchema` for each view.\n\n[schemas](https://github.com/encode/django-rest-framework/tree/master/rest_framework/schemas)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/schemas/](https://www.django-rest-framework.org/api-guide/schemas/)"
- name: Schema generation controls
  id: api-guide/settings/index#schema-generation-controls
  summary: If set, this maps the 'pk' identifier in the URL conf onto the actual field name when generating a schema path parameter
  belongs_to: Settings
  description: |-
    ## Schema generation controls

    #### SCHEMA_COERCE_PATH_PK

    If set, this maps the `'pk'` identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be `'id'`. This gives a more suitable representation as "primary key" is an implementation detail, whereas "identifier" is a more general concept.

    Default: `True`

    #### SCHEMA_COERCE_METHOD_NAMES

    If set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.

    Default: `{'retrieve': 'read', 'destroy': 'delete'}`
- name: ScopedRateThrottle
  id: api-guide/throttling/index#scopedratethrottle
  summary: The ScopedRateThrottle class can be used to restrict access to specific parts of the API
  belongs_to: Throttling
  description: "## ScopedRateThrottle\n\nThe `ScopedRateThrottle` class can be used to restrict access to specific parts of the API. This throttle will only be applied if the view that is being accessed includes a `.throttle_scope` property. The unique throttle key will then be formed by concatenating the \"scope\" of the request with the unique user id or IP address.\n\nThe allowed request rate is determined by the `DEFAULT_THROTTLE_RATES` setting using a key from the request \"scope\".\n\nFor example, given the following views...\n\n``` python\nclass ContactListView(APIView):\n    throttle_scope = 'contacts'\n    ...\n\nclass ContactDetailView(APIView):\n    throttle_scope = 'contacts'\n    ...\n\nclass UploadView(APIView):\n    throttle_scope = 'uploads'\n    ...\n```\n\n...and the following settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_THROTTLE_CLASSES': [\n        'rest_framework.throttling.ScopedRateThrottle',\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'contacts': '1000/day',\n        'uploads': '20/day'\n    }\n}\n```\n\nUser requests to either `ContactListView` or `ContactDetailView` would be restricted to a total of 1000 requests per-day. User requests to `UploadView` would be restricted to 20 requests per day.\n\n# Custom throttles\n\nTo create a custom throttle, override `BaseThrottle` and implement `.allow_request(self, request, view)`. The method should return `True` if the request should be allowed, and `False` otherwise.\n\nOptionally you may also override the `.wait()` method. If implemented, `.wait()` should return a recommended number of seconds to wait before attempting the next request, or `None`. The `.wait()` method will only be called if `.allow_request()` has previously returned `False`.\n\nIf the `.wait()` method is implemented and the request is throttled, then a `Retry-After` header will be included in the response.\n\n## Example\n\nThe following is an example of a rate throttle, that will randomly throttle 1 in every 10 requests.\n\n``` python\nimport random\n\nclass RandomRateThrottle(throttling.BaseThrottle):\n    def allow_request(self, request, view):\n        return random.randint(1, 10) != 1\n```\n\n[throttling.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/throttling.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/throttling/](https://www.django-rest-framework.org/api-guide/throttling/)"
- name: SearchFilter
  id: api-guide/filtering/index#searchfilter
  summary: The SearchFilter class supports simple single query parameter based searching, and is based on the Django admin's search functionality
  belongs_to: Filtering
  description: |-
    ## SearchFilter

    The `SearchFilter` class supports simple single query parameter based searching, and is based on the [Django admin's search functionality](https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields).

    When in use, the browsable API will include a `SearchFilter` control:

    The `SearchFilter` class will only be applied if the view has a `search_fields` attribute set. The `search_fields` attribute should be a list of names of text type fields on the model, such as `CharField` or `TextField`.

    ``` python
    from rest_framework import filters

    class UserListView(generics.ListAPIView):
        queryset = User.objects.all()
        serializer_class = UserSerializer
        filter_backends = [filters.SearchFilter]
        search_fields = ['username', 'email']
    ```

    This will allow the client to filter the items in the list by making queries such as:

    ``` python
    http://example.com/api/users?search=russell
    ```

    You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation:

    ``` python
    search_fields = ['username', 'email', 'profile__profession']
    ```

    For [JSONField](https://docs.djangoproject.com/en/3.0/ref/contrib/postgres/fields/#jsonfield) and [HStoreField](https://docs.djangoproject.com/en/3.0/ref/contrib/postgres/fields/#hstorefield) fields you can filter based on nested values within the data structure using the same double-underscore notation:

    ``` python
    search_fields = ['data__breed', 'data__owner__other_pets__0__name']
    ```

    By default, searches will use case-insensitive partial matches. The search parameter may contain multiple search terms, which should be whitespace and/or comma separated. If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched. Searches may contain *quoted phrases* with spaces, each phrase is considered as a single search term.

    The search behavior may be specified by prefixing field names in `search_fields` with one of the following characters (which is equivalent to adding `__<lookup>` to the field):

    | Prefix | Lookup        |                                                                                                                                                   |
    |--------|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
    | `^`    | `istartswith` | Starts-with search.                                                                                                                               |
    | `=`    | `iexact`      | Exact matches.                                                                                                                                    |
    | `$`    | `iregex`      | Regex search.                                                                                                                                     |
    | `@`    | `search`      | Full-text search (Currently only supported Django's [PostgreSQL backend](https://docs.djangoproject.com/en/stable/ref/contrib/postgres/search/)). |
    | None   | `icontains`   | Contains search (Default).                                                                                                                        |

    For example:

    ``` python
    search_fields = ['=username', '=email']
    ```

    By default, the search parameter is named `'search'`, but this may be overridden with the `SEARCH_PARAM` setting.

    To dynamically change search fields based on request content, it's possible to subclass the `SearchFilter` and override the `get_search_fields()` function. For example, the following subclass will only search on `title` if the query parameter `title_only` is in the request:

    ``` python
    from rest_framework import filters

    class CustomSearchFilter(filters.SearchFilter):
        def get_search_fields(self, view, request):
            if request.query_params.get('title_only'):
                return ['title']
            return super().get_search_fields(view, request)
    ```

    For more details, see the [Django documentation](https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields).
- name: Serializer fields
  id: api-guide/fields/index
  summary: Each field in a Form class is responsible not only for validating data, but also for "cleaning" it — normalizing it to a consistent format
  description: "# Serializer fields\n\n> Each field in a Form class is responsible not only for validating data, but also for \"cleaning\" it — normalizing it to a consistent format.\n>\n> — [Django documentation](https://docs.djangoproject.com/en/stable/ref/forms/api/#django.forms.Form.cleaned_data)\n\nSerializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.\n\n**Note:** The serializer fields are declared in `fields.py`, but by convention you should import them using `from rest_framework import serializers` and refer to fields as `serializers.<FieldName>`.\n\n## Core arguments\n\nEach serializer field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted:\n\n### read_only\n\nRead-only fields are included in the API output, but should not be included in the input during create or update operations. Any 'read_only' fields that are incorrectly included in the serializer input will be ignored.\n\nSet this to `True` to ensure that the field is used when serializing a representation, but is not used when creating or updating an instance during deserialization.\n\nDefaults to `False`\n\n### write_only\n\nSet this to `True` to ensure that the field may be used when updating or creating an instance, but is not included when serializing the representation.\n\nDefaults to `False`\n\n### required\n\nNormally an error will be raised if a field is not supplied during deserialization. Set to false if this field is not required to be present during deserialization.\n\nSetting this to `False` also allows the object attribute or dictionary key to be omitted from output when serializing the instance. If the key is not present it will simply not be included in the output representation.\n\nDefaults to `True`. If you're using [Model Serializer](../serializers/index#modelserializer) default value will be `False` if you have specified `blank=True` or `default` or `null=True` at your field in your `Model`.\n\n### default\n\nIf set, this gives the default value that will be used for the field if no input value is supplied. If not set the default behavior is to not populate the attribute at all.\n\nThe `default` is not applied during partial update operations. In the partial update case only fields that are provided in the incoming data will have a validated value returned.\n\nMay be set to a function or other callable, in which case the value will be evaluated each time it is used. When called, it will receive no arguments. If the callable has a `requires_context = True` attribute, then the serializer field will be passed as an argument.\n\nFor example:\n\n``` python\nclass CurrentUserDefault:\n    \"\"\"\n    May be applied as a `default=...` value on a serializer field.\n    Returns the current user.\n    \"\"\"\n    requires_context = True\n\n    def __call__(self, serializer_field):\n        return serializer_field.context['request'].user\n```\n\nWhen serializing the instance, default will be used if the object attribute or dictionary key is not present in the instance.\n\nNote that setting a `default` value implies that the field is not required. Including both the `default` and `required` keyword arguments is invalid and will raise an error.\n\n### allow_null\n\nNormally an error will be raised if `None` is passed to a serializer field. Set this keyword argument to `True` if `None` should be considered a valid value.\n\nNote that, without an explicit `default`, setting this argument to `True` will imply a `default` value of `null` for serialization output, but does not imply a default for input deserialization.\n\nDefaults to `False`\n\n### source\n\nThe name of the attribute that will be used to populate the field. May be a method that only takes a `self` argument, such as `URLField(source='get_absolute_url')`, or may use dotted notation to traverse attributes, such as `EmailField(source='user.email')`.\n\nWhen serializing fields with dotted notation, it may be necessary to provide a `default` value if any object is not present or is empty during attribute traversal. Beware of possible n+1 problems when using source attribute if you are accessing a relational orm model. For example:\n\n``` python\nclass CommentSerializer(serializers.Serializer):\n    email = serializers.EmailField(source=\"user.email\")\n```\n\nThis case would require user object to be fetched from database when it is not prefetched. If that is not wanted, be sure to be using `prefetch_related` and `select_related` methods appropriately. For more information about the methods refer to [django documentation](https://docs.djangoproject.com/en/3.1/ref/models/querysets/#django.db.models.query.QuerySet.select_related).\n\nThe value `source='*'` has a special meaning, and is used to indicate that the entire object should be passed through to the field. This can be useful for creating nested representations, or for fields which require access to the complete object in order to determine the output representation.\n\nDefaults to the name of the field.\n\n### validators\n\nA list of validator functions which should be applied to the incoming field input, and which either raise a validation error or simply return. Validator functions should typically raise `serializers.ValidationError`, but Django's built-in `ValidationError` is also supported for compatibility with validators defined in the Django codebase or third party Django packages.\n\n### error_messages\n\nA dictionary of error codes to error messages.\n\n### label\n\nA short text string that may be used as the name of the field in HTML form fields or other descriptive elements.\n\n### help_text\n\nA text string that may be used as a description of the field in HTML form fields or other descriptive elements.\n\n### initial\n\nA value that should be used for pre-populating the value of HTML form fields. You may pass a callable to it, just as you may do with any regular Django `Field`:\n\n``` python\nimport datetime\nfrom rest_framework import serializers\nclass ExampleSerializer(serializers.Serializer):\n    day = serializers.DateField(initial=datetime.date.today)\n```\n\n### style\n\nA dictionary of key-value pairs that can be used to control how renderers should render the field.\n\nTwo examples here are `'input_type'` and `'base_template'`:\n\n``` python\n# Use <input type=\"password\"> for the input.\npassword = serializers.CharField(\n    style={'input_type': 'password'}\n)\n\n# Use a radio input instead of a select input.\ncolor_channel = serializers.ChoiceField(\n    choices=['red', 'green', 'blue'],\n    style={'base_template': 'radio.html'}\n)\n```\n\nFor more details see the [HTML & Forms](https://www.django-rest-framework.org/topics/html-and-forms/) documentation.\n\n# Boolean fields\n\n## BooleanField\n\nA boolean representation.\n\nWhen using HTML encoded form input be aware that omitting a value will always be treated as setting a field to `False`, even if it has a `default=True` option specified. This is because HTML checkbox inputs represent the unchecked state by omitting the value, so REST framework treats omission as if it is an empty checkbox input.\n\nNote that Django 2.1 removed the `blank` kwarg from `models.BooleanField`. Prior to Django 2.1 `models.BooleanField` fields were always `blank=True`. Thus since Django 2.1 default `serializers.BooleanField` instances will be generated without the `required` kwarg (i.e. equivalent to `required=True`) whereas with previous versions of Django, default `BooleanField` instances will be generated with a `required=False` option. If you want to control this behavior manually, explicitly declare the `BooleanField` on the serializer class, or use the `extra_kwargs` option to set the `required` flag.\n\nCorresponds to `django.db.models.fields.BooleanField`.\n\n**Signature:** `BooleanField()`\n\n# String fields\n\n## CharField\n\nA text representation. Optionally validates the text to be shorter than `max_length` and longer than `min_length`.\n\nCorresponds to `django.db.models.fields.CharField` or `django.db.models.fields.TextField`.\n\n**Signature:** `CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)`\n\n- `max_length` - Validates that the input contains no more than this number of characters.\n- `min_length` - Validates that the input contains no fewer than this number of characters.\n- `allow_blank` - If set to `True` then the empty string should be considered a valid value. If set to `False` then the empty string is considered invalid and will raise a validation error. Defaults to `False`.\n- `trim_whitespace` - If set to `True` then leading and trailing whitespace is trimmed. Defaults to `True`.\n\nThe `allow_null` option is also available for string fields, although its usage is discouraged in favor of `allow_blank`. It is valid to set both `allow_blank=True` and `allow_null=True`, but doing so means that there will be two differing types of empty value permissible for string representations, which can lead to data inconsistencies and subtle application bugs.\n\n## EmailField\n\nA text representation, validates the text to be a valid e-mail address.\n\nCorresponds to `django.db.models.fields.EmailField`\n\n**Signature:** `EmailField(max_length=None, min_length=None, allow_blank=False)`\n\n## RegexField\n\nA text representation, that validates the given value matches against a certain regular expression.\n\nCorresponds to `django.forms.fields.RegexField`.\n\n**Signature:** `RegexField(regex, max_length=None, min_length=None, allow_blank=False)`\n\nThe mandatory `regex` argument may either be a string, or a compiled python regular expression object.\n\nUses Django's `django.core.validators.RegexValidator` for validation.\n\n## SlugField\n\nA `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.\n\nCorresponds to `django.db.models.fields.SlugField`.\n\n**Signature:** `SlugField(max_length=50, min_length=None, allow_blank=False)`\n\n## URLField\n\nA `RegexField` that validates the input against a URL matching pattern. Expects fully qualified URLs of the form `http://<host>/<path>`.\n\nCorresponds to `django.db.models.fields.URLField`. Uses Django's `django.core.validators.URLValidator` for validation.\n\n**Signature:** `URLField(max_length=200, min_length=None, allow_blank=False)`\n\n## UUIDField\n\nA field that ensures the input is a valid UUID string. The `to_internal_value` method will return a `uuid.UUID` instance. On output the field will return a string in the canonical hyphenated format, for example:\n\n``` python\n\"de305d54-75b4-431b-adb2-eb6b9e546013\"\n```\n\n**Signature:** `UUIDField(format='hex_verbose')`\n\n- `format`: Determines the representation format of the uuid value\n  - `'hex_verbose'` - The canonical hex representation, including hyphens: `\"5ce0e9a5-5ffa-654b-cee0-1238041fb31a\"`\n  - `'hex'` - The compact hex representation of the UUID, not including hyphens: `\"5ce0e9a55ffa654bcee01238041fb31a\"`\n  - `'int'` - A 128 bit integer representation of the UUID: `\"123456789012312313134124512351145145114\"`\n  - `'urn'` - RFC 4122 URN representation of the UUID: `\"urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a\"` Changing the `format` parameters only affects representation values. All formats are accepted by `to_internal_value`\n\n## FilePathField\n\nA field whose choices are limited to the filenames in a certain directory on the filesystem\n\nCorresponds to `django.forms.fields.FilePathField`.\n\n**Signature:** `FilePathField(path, match=None, recursive=False, allow_files=True, allow_folders=False, required=None, **kwargs)`\n\n- `path` - The absolute filesystem path to a directory from which this FilePathField should get its choice.\n- `match` - A regular expression, as a string, that FilePathField will use to filter filenames.\n- `recursive` - Specifies whether all subdirectories of path should be included. Default is `False`.\n- `allow_files` - Specifies whether files in the specified location should be included. Default is `True`. Either this or `allow_folders` must be `True`.\n- `allow_folders` - Specifies whether folders in the specified location should be included. Default is `False`. Either this or `allow_files` must be `True`.\n\n## IPAddressField\n\nA field that ensures the input is a valid IPv4 or IPv6 string.\n\nCorresponds to `django.forms.fields.IPAddressField` and `django.forms.fields.GenericIPAddressField`.\n\n**Signature**: `IPAddressField(protocol='both', unpack_ipv4=False, **options)`\n\n- `protocol` Limits valid inputs to the specified protocol. Accepted values are 'both' (default), 'IPv4' or 'IPv6'. Matching is case-insensitive.\n- `unpack_ipv4` Unpacks IPv4 mapped addresses like ::ffff:192.0.2.1. If this option is enabled that address would be unpacked to 192.0.2.1. Default is disabled. Can only be used when protocol is set to 'both'.\n\n# Numeric fields\n\n## IntegerField\n\nAn integer representation.\n\nCorresponds to `django.db.models.fields.IntegerField`, `django.db.models.fields.SmallIntegerField`, `django.db.models.fields.PositiveIntegerField` and `django.db.models.fields.PositiveSmallIntegerField`.\n\n**Signature**: `IntegerField(max_value=None, min_value=None)`\n\n- `max_value` Validate that the number provided is no greater than this value.\n- `min_value` Validate that the number provided is no less than this value.\n\n## FloatField\n\nA floating point representation.\n\nCorresponds to `django.db.models.fields.FloatField`.\n\n**Signature**: `FloatField(max_value=None, min_value=None)`\n\n- `max_value` Validate that the number provided is no greater than this value.\n- `min_value` Validate that the number provided is no less than this value.\n\n## DecimalField\n\nA decimal representation, represented in Python by a `Decimal` instance.\n\nCorresponds to `django.db.models.fields.DecimalField`.\n\n**Signature**: `DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None)`\n\n- `max_digits` The maximum number of digits allowed in the number. It must be either `None` or an integer greater than or equal to `decimal_places`.\n- `decimal_places` The number of decimal places to store with the number.\n- `coerce_to_string` Set to `True` if string values should be returned for the representation, or `False` if `Decimal` objects should be returned. Defaults to the same value as the `COERCE_DECIMAL_TO_STRING` settings key, which will be `True` unless overridden. If `Decimal` objects are returned by the serializer, then the final output format will be determined by the renderer. Note that setting `localize` will force the value to `True`.\n- `max_value` Validate that the number provided is no greater than this value.\n- `min_value` Validate that the number provided is no less than this value.\n- `localize` Set to `True` to enable localization of input and output based on the current locale. This will also force `coerce_to_string` to `True`. Defaults to `False`. Note that data formatting is enabled if you have set `USE_L10N=True` in your settings file.\n- `rounding` Sets the rounding mode used when quantizing to the configured precision. Valid values are [`decimal` module rounding modes](https://docs.python.org/3/library/decimal.html#rounding-modes). Defaults to `None`.\n- `normalize_output` Will normalize the decimal value when serialized. This will strip all trailing zeroes and change the value's precision to the minimum required precision to be able to represent the value without losing data. Defaults to `False`.\n\n#### Example usage\n\nTo validate numbers up to 999 with a resolution of 2 decimal places, you would use:\n\n``` python\nserializers.DecimalField(max_digits=5, decimal_places=2)\n```\n\nAnd to validate numbers up to anything less than one billion with a resolution of 10 decimal places:\n\n``` python\nserializers.DecimalField(max_digits=19, decimal_places=10)\n```\n\n# Date and time fields\n\n## DateTimeField\n\nA date and time representation.\n\nCorresponds to `django.db.models.fields.DateTimeField`.\n\n**Signature:** `DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None, default_timezone=None)`\n\n- `format` - A string representing the output format. If not specified, this defaults to the same value as the `DATETIME_FORMAT` settings key, which will be `'iso-8601'` unless set. Setting to a format string indicates that `to_representation` return values should be coerced to string output. Format strings are described below. Setting this value to `None` indicates that Python `datetime` objects should be returned by `to_representation`. In this case the datetime encoding will be determined by the renderer.\n- `input_formats` - A list of strings representing the input formats which may be used to parse the date. If not specified, the `DATETIME_INPUT_FORMATS` setting will be used, which defaults to `['iso-8601']`.\n- `default_timezone` - A `tzinfo` subclass (`zoneinfo` or `pytz`) representing the timezone. If not specified and the `USE_TZ` setting is enabled, this defaults to the [current timezone](https://docs.djangoproject.com/en/stable/topics/i18n/timezones/#default-time-zone-and-current-time-zone). If `USE_TZ` is disabled, then datetime objects will be naive.\n\n#### DateTimeField format strings.\n\nFormat strings may either be [Python strftime formats](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) which explicitly specify the format, or the special string `'iso-8601'`, which indicates that [ISO 8601](https://www.w3.org/TR/NOTE-datetime) style datetimes should be used. (eg `'2013-01-29T12:34:56.000000Z'`)\n\nWhen a value of `None` is used for the format `datetime` objects will be returned by `to_representation` and the final output representation will be determined by the renderer class.\n\n#### auto_now and auto_now_add model fields.\n\nWhen using `ModelSerializer` or `HyperlinkedModelSerializer`, note that any model fields with `auto_now=True` or `auto_now_add=True` will use serializer fields that are `read_only=True` by default.\n\nIf you want to override this behavior, you'll need to declare the `DateTimeField` explicitly on the serializer. For example:\n\n``` python\nclass CommentSerializer(serializers.ModelSerializer):\n    created = serializers.DateTimeField()\n\n    class Meta:\n        model = Comment\n```\n\n## DateField\n\nA date representation.\n\nCorresponds to `django.db.models.fields.DateField`\n\n**Signature:** `DateField(format=api_settings.DATE_FORMAT, input_formats=None)`\n\n- `format` - A string representing the output format. If not specified, this defaults to the same value as the `DATE_FORMAT` settings key, which will be `'iso-8601'` unless set. Setting to a format string indicates that `to_representation` return values should be coerced to string output. Format strings are described below. Setting this value to `None` indicates that Python `date` objects should be returned by `to_representation`. In this case the date encoding will be determined by the renderer.\n- `input_formats` - A list of strings representing the input formats which may be used to parse the date. If not specified, the `DATE_INPUT_FORMATS` setting will be used, which defaults to `['iso-8601']`.\n\n#### DateField format strings\n\nFormat strings may either be [Python strftime formats](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) which explicitly specify the format, or the special string `'iso-8601'`, which indicates that [ISO 8601](https://www.w3.org/TR/NOTE-datetime) style dates should be used. (eg `'2013-01-29'`)\n\n## TimeField\n\nA time representation.\n\nCorresponds to `django.db.models.fields.TimeField`\n\n**Signature:** `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`\n\n- `format` - A string representing the output format. If not specified, this defaults to the same value as the `TIME_FORMAT` settings key, which will be `'iso-8601'` unless set. Setting to a format string indicates that `to_representation` return values should be coerced to string output. Format strings are described below. Setting this value to `None` indicates that Python `time` objects should be returned by `to_representation`. In this case the time encoding will be determined by the renderer.\n- `input_formats` - A list of strings representing the input formats which may be used to parse the date. If not specified, the `TIME_INPUT_FORMATS` setting will be used, which defaults to `['iso-8601']`.\n\n#### TimeField format strings\n\nFormat strings may either be [Python strftime formats](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) which explicitly specify the format, or the special string `'iso-8601'`, which indicates that [ISO 8601](https://www.w3.org/TR/NOTE-datetime) style times should be used. (eg `'12:34:56.000000'`)\n\n## DurationField\n\nA Duration representation. Corresponds to `django.db.models.fields.DurationField`\n\nThe `validated_data` for these fields will contain a `datetime.timedelta` instance. The representation is a string following this format `'[DD] [HH:[MM:]]ss[.uuuuuu]'`.\n\n**Signature:** `DurationField(max_value=None, min_value=None)`\n\n- `max_value` Validate that the duration provided is no greater than this value.\n- `min_value` Validate that the duration provided is no less than this value.\n\n# Choice selection fields\n\n## ChoiceField\n\nA field that can accept a value out of a limited set of choices.\n\nUsed by `ModelSerializer` to automatically generate fields if the corresponding model field includes a `choices=…` argument.\n\n**Signature:** `ChoiceField(choices)`\n\n- `choices` - A list of valid values, or a list of `(key, display_name)` tuples.\n- `allow_blank` - If set to `True` then the empty string should be considered a valid value. If set to `False` then the empty string is considered invalid and will raise a validation error. Defaults to `False`.\n- `html_cutoff` - If set this will be the maximum number of choices that will be displayed by a HTML select drop down. Can be used to ensure that automatically generated ChoiceFields with very large possible selections do not prevent a template from rendering. Defaults to `None`.\n- `html_cutoff_text` - If set this will display a textual indicator if the maximum number of items have been cutoff in an HTML select drop down. Defaults to `\"More than {count} items…\"`\n\nBoth the `allow_blank` and `allow_null` are valid options on `ChoiceField`, although it is highly recommended that you only use one and not both. `allow_blank` should be preferred for textual choices, and `allow_null` should be preferred for numeric or other non-textual choices.\n\n## MultipleChoiceField\n\nA field that can accept a set of zero, one or many values, chosen from a limited set of choices. Takes a single mandatory argument. `to_internal_value` returns a `set` containing the selected values.\n\n**Signature:** `MultipleChoiceField(choices)`\n\n- `choices` - A list of valid values, or a list of `(key, display_name)` tuples.\n- `allow_blank` - If set to `True` then the empty string should be considered a valid value. If set to `False` then the empty string is considered invalid and will raise a validation error. Defaults to `False`.\n- `html_cutoff` - If set this will be the maximum number of choices that will be displayed by a HTML select drop down. Can be used to ensure that automatically generated ChoiceFields with very large possible selections do not prevent a template from rendering. Defaults to `None`.\n- `html_cutoff_text` - If set this will display a textual indicator if the maximum number of items have been cutoff in an HTML select drop down. Defaults to `\"More than {count} items…\"`\n\nAs with `ChoiceField`, both the `allow_blank` and `allow_null` options are valid, although it is highly recommended that you only use one and not both. `allow_blank` should be preferred for textual choices, and `allow_null` should be preferred for numeric or other non-textual choices.\n\n# File upload fields\n\n#### Parsers and file uploads.\n\nThe `FileField` and `ImageField` classes are only suitable for use with `MultiPartParser` or `FileUploadParser`. Most parsers, such as e.g. JSON don't support file uploads. Django's regular [FILE_UPLOAD_HANDLERS](https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-FILE_UPLOAD_HANDLERS) are used for handling uploaded files.\n\n## FileField\n\nA file representation. Performs Django's standard FileField validation.\n\nCorresponds to `django.forms.fields.FileField`.\n\n**Signature:** `FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)`\n\n- `max_length` - Designates the maximum length for the file name.\n- `allow_empty_file` - Designates if empty files are allowed.\n- `use_url` - If set to `True` then URL string values will be used for the output representation. If set to `False` then filename string values will be used for the output representation. Defaults to the value of the `UPLOADED_FILES_USE_URL` settings key, which is `True` unless set otherwise.\n\n## ImageField\n\nAn image representation. Validates the uploaded file content as matching a known image format.\n\nCorresponds to `django.forms.fields.ImageField`.\n\n**Signature:** `ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)`\n\n- `max_length` - Designates the maximum length for the file name.\n- `allow_empty_file` - Designates if empty files are allowed.\n- `use_url` - If set to `True` then URL string values will be used for the output representation. If set to `False` then filename string values will be used for the output representation. Defaults to the value of the `UPLOADED_FILES_USE_URL` settings key, which is `True` unless set otherwise.\n\nRequires either the `Pillow` package or `PIL` package. The `Pillow` package is recommended, as `PIL` is no longer actively maintained.\n\n# Composite fields\n\n## ListField\n\nA field class that validates a list of objects.\n\n**Signature**: `ListField(child=<A_FIELD_INSTANCE>, allow_empty=True, min_length=None, max_length=None)`\n\n- `child` - A field instance that should be used for validating the objects in the list. If this argument is not provided then objects in the list will not be validated.\n- `allow_empty` - Designates if empty lists are allowed.\n- `min_length` - Validates that the list contains no fewer than this number of elements.\n- `max_length` - Validates that the list contains no more than this number of elements.\n\nFor example, to validate a list of integers you might use something like the following:\n\n``` python\nscores = serializers.ListField(\n   child=serializers.IntegerField(min_value=0, max_value=100)\n)\n```\n\nThe `ListField` class also supports a declarative style that allows you to write reusable list field classes.\n\n``` python\nclass StringListField(serializers.ListField):\n    child = serializers.CharField()\n```\n\nWe can now reuse our custom `StringListField` class throughout our application, without having to provide a `child` argument to it.\n\n## DictField\n\nA field class that validates a dictionary of objects. The keys in `DictField` are always assumed to be string values.\n\n**Signature**: `DictField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\n- `child` - A field instance that should be used for validating the values in the dictionary. If this argument is not provided then values in the mapping will not be validated.\n- `allow_empty` - Designates if empty dictionaries are allowed.\n\nFor example, to create a field that validates a mapping of strings to strings, you would write something like this:\n\n``` python\ndocument = DictField(child=CharField())\n```\n\nYou can also use the declarative style, as with `ListField`. For example:\n\n``` python\nclass DocumentField(DictField):\n    child = CharField()\n```\n\n## HStoreField\n\nA preconfigured `DictField` that is compatible with Django's postgres `HStoreField`.\n\n**Signature**: `HStoreField(child=<A_FIELD_INSTANCE>, allow_empty=True)`\n\n- `child` - A field instance that is used for validating the values in the dictionary. The default child field accepts both empty strings and null values.\n- `allow_empty` - Designates if empty dictionaries are allowed.\n\nNote that the child field **must** be an instance of `CharField`, as the hstore extension stores values as strings.\n\n## JSONField\n\nA field class that validates that the incoming data structure consists of valid JSON primitives. In its alternate binary mode, it will represent and validate JSON-encoded binary strings.\n\n**Signature**: `JSONField(binary, encoder)`\n\n- `binary` - If set to `True` then the field will output and validate a JSON encoded string, rather than a primitive data structure. Defaults to `False`.\n- `encoder` - Use this JSON encoder to serialize input object. Defaults to `None`.\n\n# Miscellaneous fields\n\n## ReadOnlyField\n\nA field class that simply returns the value of the field without modification.\n\nThis field is used by default with `ModelSerializer` when including field names that relate to an attribute rather than a model field.\n\n**Signature**: `ReadOnlyField()`\n\nFor example, if `has_expired` was a property on the `Account` model, then the following serializer would automatically generate it as a `ReadOnlyField`:\n\n``` python\nclass AccountSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Account\n        fields = ['id', 'account_name', 'has_expired']\n```\n\n## HiddenField\n\nA field class that does not take a value based on user input, but instead takes its value from a default value or callable.\n\n**Signature**: `HiddenField()`\n\nFor example, to include a field that always provides the current time as part of the serializer validated data, you would use the following:\n\n``` python\nmodified = serializers.HiddenField(default=timezone.now)\n```\n\nThe `HiddenField` class is usually only needed if you have some validation that needs to run based on some pre-provided field values, but you do not want to expose all of those fields to the end user.\n\nFor further examples on `HiddenField` see the [validators](../validators/index) documentation.\n\n**Note:** `HiddenField()` does not appear in `partial=True` serializer (when making `PATCH` request). This behavior might change in future, follow updates on [github discussion](https://github.com/encode/django-rest-framework/discussions/8259).\n\n## ModelField\n\nA generic field that can be tied to any arbitrary model field. The `ModelField` class delegates the task of serialization/deserialization to its associated model field. This field can be used to create serializer fields for custom model fields, without having to create a new custom serializer field.\n\nThis field is used by `ModelSerializer` to correspond to custom model field classes.\n\n**Signature:** `ModelField(model_field=<Django ModelField instance>)`\n\nThe `ModelField` class is generally intended for internal use, but can be used by your API if needed. In order to properly instantiate a `ModelField`, it must be passed a field that is attached to an instantiated model. For example: `ModelField(model_field=MyModel()._meta.get_field('custom_field'))`\n\n## SerializerMethodField\n\nThis is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.\n\n**Signature**: `SerializerMethodField(method_name=None)`\n\n- `method_name` - The name of the method on the serializer to be called. If not included this defaults to `get_<field_name>`.\n\nThe serializer method referred to by the `method_name` argument should accept a single argument (in addition to `self`), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:\n\n``` python\nfrom django.contrib.auth.models import User\nfrom django.utils.timezone import now\nfrom rest_framework import serializers\n\nclass UserSerializer(serializers.ModelSerializer):\n    days_since_joined = serializers.SerializerMethodField()\n\n    class Meta:\n        model = User\n        fields = '__all__'\n\n    def get_days_since_joined(self, obj):\n        return (now() - obj.date_joined).days\n```\n\n# Custom fields\n\nIf you want to create a custom field, you'll need to subclass `Field` and then override either one or both of the `.to_representation()` and `.to_internal_value()` methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, `date`/`time`/`datetime` or `None`. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype into a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype into its internal python representation. This method should raise a `serializers.ValidationError` if the data is invalid.\n\n## Examples\n\n### A Basic Custom Field\n\nLet's look at an example of serializing a class that represents an RGB color value:\n\n``` python\nclass Color:\n    \"\"\"\n    A color represented in the RGB colorspace.\n    \"\"\"\n    def __init__(self, red, green, blue):\n        assert(red >= 0 and green >= 0 and blue >= 0)\n        assert(red < 256 and green < 256 and blue < 256)\n        self.red, self.green, self.blue = red, green, blue\n\nclass ColorField(serializers.Field):\n    \"\"\"\n    Color objects are serialized into 'rgb(#, #, #)' notation.\n    \"\"\"\n    def to_representation(self, value):\n        return \"rgb(%d, %d, %d)\" % (value.red, value.green, value.blue)\n\n    def to_internal_value(self, data):\n        data = data.strip('rgb(').rstrip(')')\n        red, green, blue = [int(col) for col in data.split(',')]\n        return Color(red, green, blue)\n```\n\nBy default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class name of the object being serialized:\n\n``` python\nclass ClassNameField(serializers.Field):\n    def get_attribute(self, instance):\n        # We pass the object instance onto `to_representation`,\n        # not just the field attribute.\n        return instance\n\n    def to_representation(self, value):\n        \"\"\"\n        Serialize the value's class name.\n        \"\"\"\n        return value.__class__.__name__\n```\n\n### Raising validation errors\n\nOur `ColorField` class above currently does not perform any data validation. To indicate invalid data, we should raise a `serializers.ValidationError`, like so:\n\n``` python\ndef to_internal_value(self, data):\n    if not isinstance(data, str):\n        msg = 'Incorrect type. Expected a string, but got %s'\n        raise ValidationError(msg % type(data).__name__)\n\n    if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data):\n        raise ValidationError('Incorrect format. Expected `rgb(#,#,#)`.')\n\n    data = data.strip('rgb(').rstrip(')')\n    red, green, blue = [int(col) for col in data.split(',')]\n\n    if any([col > 255 or col < 0 for col in (red, green, blue)]):\n        raise ValidationError('Value out of range. Must be between 0 and 255.')\n\n    return Color(red, green, blue)\n```\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a message string from the `error_messages` dictionary. For example:\n\n``` python\ndefault_error_messages = {\n    'incorrect_type': 'Incorrect type. Expected a string, but got {input_type}',\n    'incorrect_format': 'Incorrect format. Expected `rgb(#,#,#)`.',\n    'out_of_range': 'Value out of range. Must be between 0 and 255.'\n}\n\ndef to_internal_value(self, data):\n    if not isinstance(data, str):\n        self.fail('incorrect_type', input_type=type(data).__name__)\n\n    if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data):\n        self.fail('incorrect_format')\n\n    data = data.strip('rgb(').rstrip(')')\n    red, green, blue = [int(col) for col in data.split(',')]\n\n    if any([col > 255 or col < 0 for col in (red, green, blue)]):\n        self.fail('out_of_range')\n\n    return Color(red, green, blue)\n```\n\nThis style keeps your error messages cleaner and more separated from your code, and should be preferred.\n\n### Using source='\\*'\n\nHere we'll take an example of a *flat* `DataPoint` model with `x_coordinate` and `y_coordinate` attributes.\n\n``` python\nclass DataPoint(models.Model):\n    label = models.CharField(max_length=50)\n    x_coordinate = models.SmallIntegerField()\n    y_coordinate = models.SmallIntegerField()\n```\n\nUsing a custom field and `source='*'` we can provide a nested representation of the coordinate pair:\n\n``` python\nclass CoordinateField(serializers.Field):\n\n    def to_representation(self, value):\n        ret = {\n            \"x\": value.x_coordinate,\n            \"y\": value.y_coordinate\n        }\n        return ret\n\n    def to_internal_value(self, data):\n        ret = {\n            \"x_coordinate\": data[\"x\"],\n            \"y_coordinate\": data[\"y\"],\n        }\n        return ret\n\n\nclass DataPointSerializer(serializers.ModelSerializer):\n    coordinates = CoordinateField(source='*')\n\n    class Meta:\n        model = DataPoint\n        fields = ['label', 'coordinates']\n```\n\nNote that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using `source='*'`, with two `IntegerField` instances, each with their own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n- `to_representation` is passed the entire `DataPoint` object and must map from that to the desired output.\n\n  ``` python\n  >>> instance = DataPoint(label='Example', x_coordinate=1, y_coordinate=2)\n  >>> out_serializer = DataPointSerializer(instance)\n  >>> out_serializer.data\n  ReturnDict([('label', 'Example'), ('coordinates', {'x': 1, 'y': 2})])\n  ```\n\n- Unless our field is to be read-only, `to_internal_value` must map back to a dict suitable for updating our target object. With `source='*'`, the return from `to_internal_value` will update the root validated data dictionary, rather than a single key.\n\n  ``` python\n  >>> data = {\n  ...     \"label\": \"Second Example\",\n  ...     \"coordinates\": {\n  ...         \"x\": 3,\n  ...         \"y\": 4,\n  ...     }\n  ... }\n  >>> in_serializer = DataPointSerializer(data=data)\n  >>> in_serializer.is_valid()\n  True\n  >>> in_serializer.validated_data\n  OrderedDict([('label', 'Second Example'),\n               ('y_coordinate', 4),\n               ('x_coordinate', 3)])\n  ```\n\nFor completeness lets do the same thing again but with the nested serializer approach suggested above:\n\n``` python\nclass NestedCoordinateSerializer(serializers.Serializer):\n    x = serializers.IntegerField(source='x_coordinate')\n    y = serializers.IntegerField(source='y_coordinate')\n\n\nclass DataPointSerializer(serializers.ModelSerializer):\n    coordinates = NestedCoordinateSerializer(source='*')\n\n    class Meta:\n        model = DataPoint\n        fields = ['label', 'coordinates']\n```\n\nHere the mapping between the target and source attribute pairs (`x` and `x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField` declarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behavior as the custom field approach.\n\nSerializing:\n\n``` python\n>>> out_serializer = DataPointSerializer(instance)\n>>> out_serializer.data\nReturnDict([('label', 'testing'),\n            ('coordinates', OrderedDict([('x', 1), ('y', 2)]))])\n```\n\nDeserializing:\n\n``` python\n>>> in_serializer = DataPointSerializer(data=data)\n>>> in_serializer.is_valid()\nTrue\n>>> in_serializer.validated_data\nOrderedDict([('label', 'still testing'),\n             ('x_coordinate', 3),\n             ('y_coordinate', 4)])\n```\n\nBut we also get the built-in validation for free:\n\n``` python\n>>> invalid_data = {\n...     \"label\": \"still testing\",\n...     \"coordinates\": {\n...         \"x\": 'a',\n...         \"y\": 'b',\n...     }\n... }\n>>> invalid_serializer = DataPointSerializer(data=invalid_data)\n>>> invalid_serializer.is_valid()\nFalse\n>>> invalid_serializer.errors\nReturnDict([('coordinates',\n             {'x': ['A valid integer is required.'],\n              'y': ['A valid integer is required.']})])\n```\n\nFor this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## DRF Compound Fields\n\nThe [drf-compound-fields](https://drf-compound-fields.readthedocs.io) package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the `many=True` option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.\n\n## DRF Extra Fields\n\nThe [drf-extra-fields](https://github.com/Hipo/drf-extra-fields) package provides extra serializer fields for REST framework, including `Base64ImageField` and `PointField` classes.\n\n## djangorestframework-recursive\n\nthe [djangorestframework-recursive](https://github.com/heywbj/django-rest-framework-recursive) package provides a `RecursiveField` for serializing and deserializing recursive structures\n\n## django-rest-framework-gis\n\nThe [django-rest-framework-gis](https://github.com/djangonauts/django-rest-framework-gis) package provides geographic addons for django rest framework like a `GeometryField` field and a GeoJSON serializer.\n\n## django-rest-framework-hstore\n\nThe [django-rest-framework-hstore](https://github.com/djangonauts/django-rest-framework-hstore) package provides an `HStoreField` to support [django-hstore](https://github.com/djangonauts/django-hstore) `DictionaryField` model field.\n\n[fields.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/fields.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/fields/](https://www.django-rest-framework.org/api-guide/fields/)"
- name: Serializer relations
  id: api-guide/relations/index
  summary: Data structures, not algorithms, are central to programming
  description: "# Serializer relations\n\n> Data structures, not algorithms, are central to programming.\n>\n> — [Rob Pike](http://users.ece.utexas.edu/~adnan/pike.html)\n\nRelational fields are used to represent model relationships. They can be applied to `ForeignKey`, `ManyToManyField` and `OneToOneField` relationships, as well as to reverse relationships, and custom relationships such as `GenericForeignKey`.\n\n**Note:** The relational fields are declared in `relations.py`, but by convention you should import them from the `serializers` module, using `from rest_framework import serializers` and refer to fields as `serializers.<FieldName>`.\n\n**Note:** REST Framework does not attempt to automatically optimize querysets passed to serializers in terms of `select_related` and `prefetch_related` since it would be too much magic. A serializer with a field spanning an orm relation through its source attribute could require an additional database hit to fetch related objects from the database. It is the programmer's responsibility to optimize queries to avoid additional database hits which could occur while using such a serializer.\n\nFor example, the following serializer would lead to a database hit each time evaluating the tracks field if it is not prefetched:\n\n``` python\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = serializers.SlugRelatedField(\n        many=True,\n        read_only=True,\n        slug_field='title'\n    )\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n\n# For each album object, tracks should be fetched from database\nqs = Album.objects.all()\nprint(AlbumSerializer(qs, many=True).data)\n```\n\nIf `AlbumSerializer` is used to serialize a fairly large queryset with `many=True` then it could be a serious performance problem. Optimizing the queryset passed to `AlbumSerializer` with:\n\n``` python\nqs = Album.objects.prefetch_related('tracks')\n# No additional database hits required\nprint(AlbumSerializer(qs, many=True).data)\n```\n\nwould solve the issue.\n\n#### Inspecting relationships.\n\nWhen using the `ModelSerializer` class, serializer fields and relationships will be automatically generated for you. Inspecting these automatically generated fields can be a useful tool for determining how to customize the relationship style.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import the serializer class, instantiate it, and print the object representation…\n\n``` python\n>>> from myapp.serializers import AccountSerializer\n>>> serializer = AccountSerializer()\n>>> print(repr(serializer))\nAccountSerializer():\n    id = IntegerField(label='ID', read_only=True)\n    name = CharField(allow_blank=True, max_length=100, required=False)\n    owner = PrimaryKeyRelatedField(queryset=User.objects.all())\n```\n\n# API Reference\n\nIn order to explain the various types of relational fields, we'll use a couple of simple models for our examples. Our models will be for music albums, and the tracks listed on each album.\n\n``` python\nclass Album(models.Model):\n    album_name = models.CharField(max_length=100)\n    artist = models.CharField(max_length=100)\n\nclass Track(models.Model):\n    album = models.ForeignKey(Album, related_name='tracks', on_delete=models.CASCADE)\n    order = models.IntegerField()\n    title = models.CharField(max_length=100)\n    duration = models.IntegerField()\n\n    class Meta:\n        unique_together = ['album', 'order']\n        ordering = ['order']\n\n    def __str__(self):\n        return '%d: %s' % (self.order, self.title)\n```\n\n## StringRelatedField\n\n`StringRelatedField` may be used to represent the target of the relationship using its `__str__` method.\n\nFor example, the following serializer:\n\n``` python\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = serializers.StringRelatedField(many=True)\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n```\n\nWould serialize to the following representation:\n\n``` python\n{\n    'album_name': 'Things We Lost In The Fire',\n    'artist': 'Low',\n    'tracks': [\n        '1: Sunflower',\n        '2: Whitetail',\n        '3: Dinosaur Act',\n        ...\n    ]\n}\n```\n\nThis field is read only.\n\n**Arguments**:\n\n- `many` - If applied to a to-many relationship, you should set this argument to `True`.\n\n## PrimaryKeyRelatedField\n\n`PrimaryKeyRelatedField` may be used to represent the target of the relationship using its primary key.\n\nFor example, the following serializer:\n\n``` python\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = serializers.PrimaryKeyRelatedField(many=True, read_only=True)\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n```\n\nWould serialize to a representation like this:\n\n``` python\n{\n    'album_name': 'Undun',\n    'artist': 'The Roots',\n    'tracks': [\n        89,\n        90,\n        91,\n        ...\n    ]\n}\n```\n\nBy default this field is read-write, although you can change this behavior using the `read_only` flag.\n\n**Arguments**:\n\n- `queryset` - The queryset used for model instance lookups when validating the field input. Relationships must either set a queryset explicitly, or set `read_only=True`.\n- `many` - If applied to a to-many relationship, you should set this argument to `True`.\n- `allow_null` - If set to `True`, the field will accept values of `None` or the empty string for nullable relationships. Defaults to `False`.\n- `pk_field` - Set to a field to control serialization/deserialization of the primary key's value. For example, `pk_field=UUIDField(format='hex')` would serialize a UUID primary key into its compact hex representation.\n\n## HyperlinkedRelatedField\n\n`HyperlinkedRelatedField` may be used to represent the target of the relationship using a hyperlink.\n\nFor example, the following serializer:\n\n``` python\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = serializers.HyperlinkedRelatedField(\n        many=True,\n        read_only=True,\n        view_name='track-detail'\n    )\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n```\n\nWould serialize to a representation like this:\n\n``` python\n{\n    'album_name': 'Graceland',\n    'artist': 'Paul Simon',\n    'tracks': [\n        'http://www.example.com/api/tracks/45/',\n        'http://www.example.com/api/tracks/46/',\n        'http://www.example.com/api/tracks/47/',\n        ...\n    ]\n}\n```\n\nBy default this field is read-write, although you can change this behavior using the `read_only` flag.\n\n**Note**: This field is designed for objects that map to a URL that accepts a single URL keyword argument, as set using the `lookup_field` and `lookup_url_kwarg` arguments.\n\nThis is suitable for URLs that contain a single primary key or slug argument as part of the URL.\n\nIf you require more complex hyperlinked representation you'll need to customize the field, as described in the [custom hyperlinked fields](#custom-hyperlinked-fields) section, below.\n\n**Arguments**:\n\n- `view_name` - The view name that should be used as the target of the relationship. If you're using [the standard router classes](../routers#defaultrouter) this will be a string with the format `<modelname>-detail`. **required**.\n- `queryset` - The queryset used for model instance lookups when validating the field input. Relationships must either set a queryset explicitly, or set `read_only=True`.\n- `many` - If applied to a to-many relationship, you should set this argument to `True`.\n- `allow_null` - If set to `True`, the field will accept values of `None` or the empty string for nullable relationships. Defaults to `False`.\n- `lookup_field` - The field on the target that should be used for the lookup. Should correspond to a URL keyword argument on the referenced view. Default is `'pk'`.\n- `lookup_url_kwarg` - The name of the keyword argument defined in the URL conf that corresponds to the lookup field. Defaults to using the same value as `lookup_field`.\n- `format` - If using format suffixes, hyperlinked fields will use the same format suffix for the target unless overridden by using the `format` argument.\n\n## SlugRelatedField\n\n`SlugRelatedField` may be used to represent the target of the relationship using a field on the target.\n\nFor example, the following serializer:\n\n``` python\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = serializers.SlugRelatedField(\n        many=True,\n        read_only=True,\n        slug_field='title'\n     )\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n```\n\nWould serialize to a representation like this:\n\n``` python\n{\n    'album_name': 'Dear John',\n    'artist': 'Loney Dear',\n    'tracks': [\n        'Airport Surroundings',\n        'Everything Turns to You',\n        'I Was Only Going Out',\n        ...\n    ]\n}\n```\n\nBy default this field is read-write, although you can change this behavior using the `read_only` flag.\n\nWhen using `SlugRelatedField` as a read-write field, you will normally want to ensure that the slug field corresponds to a model field with `unique=True`.\n\n**Arguments**:\n\n- `slug_field` - The field on the target that should be used to represent it. This should be a field that uniquely identifies any given instance. For example, `username`. **required**\n- `queryset` - The queryset used for model instance lookups when validating the field input. Relationships must either set a queryset explicitly, or set `read_only=True`.\n- `many` - If applied to a to-many relationship, you should set this argument to `True`.\n- `allow_null` - If set to `True`, the field will accept values of `None` or the empty string for nullable relationships. Defaults to `False`.\n\n## HyperlinkedIdentityField\n\nThis field can be applied as an identity relationship, such as the `'url'` field on a HyperlinkedModelSerializer. It can also be used for an attribute on the object. For example, the following serializer:\n\n``` python\nclass AlbumSerializer(serializers.HyperlinkedModelSerializer):\n    track_listing = serializers.HyperlinkedIdentityField(view_name='track-list')\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'track_listing']\n```\n\nWould serialize to a representation like this:\n\n``` python\n{\n    'album_name': 'The Eraser',\n    'artist': 'Thom Yorke',\n    'track_listing': 'http://www.example.com/api/track_list/12/',\n}\n```\n\nThis field is always read-only.\n\n**Arguments**:\n\n- `view_name` - The view name that should be used as the target of the relationship. If you're using [the standard router classes](../routers#defaultrouter) this will be a string with the format `<model_name>-detail`. **required**.\n- `lookup_field` - The field on the target that should be used for the lookup. Should correspond to a URL keyword argument on the referenced view. Default is `'pk'`.\n- `lookup_url_kwarg` - The name of the keyword argument defined in the URL conf that corresponds to the lookup field. Defaults to using the same value as `lookup_field`.\n- `format` - If using format suffixes, hyperlinked fields will use the same format suffix for the target unless overridden by using the `format` argument.\n\n# Nested relationships\n\nAs opposed to previously discussed *references* to another entity, the referred entity can instead also be embedded or *nested* in the representation of the object that refers to it. Such nested relationships can be expressed by using serializers as fields.\n\nIf the field is used to represent a to-many relationship, you should add the `many=True` flag to the serializer field.\n\n## Example\n\nFor example, the following serializer:\n\n``` python\nclass TrackSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Track\n        fields = ['order', 'title', 'duration']\n\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = TrackSerializer(many=True, read_only=True)\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n```\n\nWould serialize to a nested representation like this:\n\n``` python\n>>> album = Album.objects.create(album_name=\"The Grey Album\", artist='Danger Mouse')\n>>> Track.objects.create(album=album, order=1, title='Public Service Announcement', duration=245)\n<Track: Track object>\n>>> Track.objects.create(album=album, order=2, title='What More Can I Say', duration=264)\n<Track: Track object>\n>>> Track.objects.create(album=album, order=3, title='Encore', duration=159)\n<Track: Track object>\n>>> serializer = AlbumSerializer(instance=album)\n>>> serializer.data\n{\n    'album_name': 'The Grey Album',\n    'artist': 'Danger Mouse',\n    'tracks': [\n        {'order': 1, 'title': 'Public Service Announcement', 'duration': 245},\n        {'order': 2, 'title': 'What More Can I Say', 'duration': 264},\n        {'order': 3, 'title': 'Encore', 'duration': 159},\n        ...\n    ],\n}\n```\n\n## Writable nested serializers\n\nBy default nested serializers are read-only. If you want to support write-operations to a nested serializer field you'll need to create `create()` and/or `update()` methods in order to explicitly specify how the child relationships should be saved:\n\n``` python\nclass TrackSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Track\n        fields = ['order', 'title', 'duration']\n\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = TrackSerializer(many=True)\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n\n    def create(self, validated_data):\n        tracks_data = validated_data.pop('tracks')\n        album = Album.objects.create(**validated_data)\n        for track_data in tracks_data:\n            Track.objects.create(album=album, **track_data)\n        return album\n\n>>> data = {\n    'album_name': 'The Grey Album',\n    'artist': 'Danger Mouse',\n    'tracks': [\n        {'order': 1, 'title': 'Public Service Announcement', 'duration': 245},\n        {'order': 2, 'title': 'What More Can I Say', 'duration': 264},\n        {'order': 3, 'title': 'Encore', 'duration': 159},\n    ],\n}\n>>> serializer = AlbumSerializer(data=data)\n>>> serializer.is_valid()\nTrue\n>>> serializer.save()\n<Album: Album object>\n```\n\n# Custom relational fields\n\nIn rare cases where none of the existing relational styles fit the representation you need, you can implement a completely custom relational field, that describes exactly how the output representation should be generated from the model instance.\n\nTo implement a custom relational field, you should override `RelatedField`, and implement the `.to_representation(self, value)` method. This method takes the target of the field as the `value` argument, and should return the representation that should be used to serialize the target. The `value` argument will typically be a model instance.\n\nIf you want to implement a read-write relational field, you must also implement the [`.to_internal_value(self, data)` method](../serializers/index#to_internal_valueself-data).\n\nTo provide a dynamic queryset based on the `context`, you can also override `.get_queryset(self)` instead of specifying `.queryset` on the class or when initializing the field.\n\n## Example\n\nFor example, we could define a relational field to serialize a track to a custom string representation, using its ordering, title, and duration:\n\n``` python\nimport time\n\nclass TrackListingField(serializers.RelatedField):\n    def to_representation(self, value):\n        duration = time.strftime('%M:%S', time.gmtime(value.duration))\n        return 'Track %d: %s (%s)' % (value.order, value.name, duration)\n\nclass AlbumSerializer(serializers.ModelSerializer):\n    tracks = TrackListingField(many=True)\n\n    class Meta:\n        model = Album\n        fields = ['album_name', 'artist', 'tracks']\n```\n\nThis custom field would then serialize to the following representation:\n\n``` python\n{\n    'album_name': 'Sometimes I Wish We Were an Eagle',\n    'artist': 'Bill Callahan',\n    'tracks': [\n        'Track 1: Jim Cain (04:39)',\n        'Track 2: Eid Ma Clack Shaw (04:19)',\n        'Track 3: The Wind and the Dove (04:34)',\n        ...\n    ]\n}\n```\n\n# Custom hyperlinked fields\n\nIn some cases you may need to customize the behavior of a hyperlinked field, in order to represent URLs that require more than a single lookup field.\n\nYou can achieve this by overriding `HyperlinkedRelatedField`. There are two methods that may be overridden:\n\n**get_url(self, obj, view_name, request, format)**\n\nThe `get_url` method is used to map the object instance to its URL representation.\n\nMay raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes are not configured to correctly match the URL conf.\n\n**get_object(self, view_name, view_args, view_kwargs)**\n\nIf you want to support a writable hyperlinked field then you'll also want to override `get_object`, in order to map incoming URLs back to the object they represent. For read-only hyperlinked fields there is no need to override this method.\n\nThe return value of this method should the object that corresponds to the matched URL conf arguments.\n\nMay raise an `ObjectDoesNotExist` exception.\n\n## Example\n\nSay we have a URL for a customer object that takes two keyword arguments, like so:\n\n``` python\n/api/<organization_slug>/customers/<customer_pk>/\n```\n\nThis cannot be represented with the default implementation, which accepts only a single lookup field.\n\nIn this case we'd need to override `HyperlinkedRelatedField` to get the behavior we want:\n\n``` python\nfrom rest_framework import serializers\nfrom rest_framework.reverse import reverse\n\nclass CustomerHyperlink(serializers.HyperlinkedRelatedField):\n    # We define these as class attributes, so we don't need to pass them as arguments.\n    view_name = 'customer-detail'\n    queryset = Customer.objects.all()\n\n    def get_url(self, obj, view_name, request, format):\n        url_kwargs = {\n            'organization_slug': obj.organization.slug,\n            'customer_pk': obj.pk\n        }\n        return reverse(view_name, kwargs=url_kwargs, request=request, format=format)\n\n    def get_object(self, view_name, view_args, view_kwargs):\n        lookup_kwargs = {\n           'organization__slug': view_kwargs['organization_slug'],\n           'pk': view_kwargs['customer_pk']\n        }\n        return self.get_queryset().get(**lookup_kwargs)\n```\n\nNote that if you wanted to use this style together with the generic views then you'd also need to override `.get_object` on the view in order to get the correct lookup behavior.\n\nGenerally we recommend a flat style for API representations where possible, but the nested URL style can also be reasonable when used in moderation.\n\n# Further notes\n\n## The queryset argument\n\nThe `queryset` argument is only ever required for *writable* relationship field, in which case it is used for performing the model instance lookup, that maps from the primitive user input, into a model instance.\n\nIn version 2.x a serializer class could *sometimes* automatically determine the `queryset` argument *if* a `ModelSerializer` class was being used.\n\nThis behavior is now replaced with *always* using an explicit `queryset` argument for writable relational fields.\n\nDoing so reduces the amount of hidden 'magic' that `ModelSerializer` provides, makes the behavior of the field more clear, and ensures that it is trivial to move between using the `ModelSerializer` shortcut, or using fully explicit `Serializer` classes.\n\n## Customizing the HTML display\n\nThe built-in `__str__` method of the model will be used to generate string representations of the objects used to populate the `choices` property. These choices are used to populate select HTML inputs in the browsable API.\n\nTo provide customized representations for such inputs, override `display_value()` of a `RelatedField` subclass. This method will receive a model object, and should return a string suitable for representing it. For example:\n\n``` python\nclass TrackPrimaryKeyRelatedField(serializers.PrimaryKeyRelatedField):\n    def display_value(self, instance):\n        return 'Track: %s' % (instance.title)\n```\n\n## Select field cutoffs\n\nWhen rendered in the browsable API relational fields will default to only displaying a maximum of 1000 selectable items. If more items are present then a disabled option with \"More than 1000 items…\" will be displayed.\n\nThis behavior is intended to prevent a template from being unable to render in an acceptable timespan due to a very large number of relationships being displayed.\n\nThere are two keyword arguments you can use to control this behavior:\n\n- `html_cutoff` - If set this will be the maximum number of choices that will be displayed by a HTML select drop down. Set to `None` to disable any limiting. Defaults to `1000`.\n- `html_cutoff_text` - If set this will display a textual indicator if the maximum number of items have been cutoff in an HTML select drop down. Defaults to `\"More than {count} items…\"`\n\nYou can also control these globally using the settings `HTML_SELECT_CUTOFF` and `HTML_SELECT_CUTOFF_TEXT`.\n\nIn cases where the cutoff is being enforced you may want to instead use a plain input field in the HTML form. You can do so using the `style` keyword argument. For example:\n\n``` python\nassigned_to = serializers.SlugRelatedField(\n   queryset=User.objects.all(),\n   slug_field='username',\n   style={'base_template': 'input.html'}\n)\n```\n\n## Reverse relations\n\nNote that reverse relationships are not automatically included by the `ModelSerializer` and `HyperlinkedModelSerializer` classes. To include a reverse relationship, you must explicitly add it to the fields list. For example:\n\n``` python\nclass AlbumSerializer(serializers.ModelSerializer):\n    class Meta:\n        fields = ['tracks', ...]\n```\n\nYou'll normally want to ensure that you've set an appropriate `related_name` argument on the relationship, that you can use as the field name. For example:\n\n``` python\nclass Track(models.Model):\n    album = models.ForeignKey(Album, related_name='tracks', on_delete=models.CASCADE)\n    ...\n```\n\nIf you have not set a related name for the reverse relationship, you'll need to use the automatically generated related name in the `fields` argument. For example:\n\n``` python\nclass AlbumSerializer(serializers.ModelSerializer):\n    class Meta:\n        fields = ['track_set', ...]\n```\n\nSee the Django documentation on [reverse relationships](https://docs.djangoproject.com/en/stable/topics/db/queries/#following-relationships-backward) for more details.\n\n## Generic relationships\n\nIf you want to serialize a generic foreign key, you need to define a custom field, to determine explicitly how you want to serialize the targets of the relationship.\n\nFor example, given the following model for a tag, which has a generic relationship with other arbitrary models:\n\n``` python\nclass TaggedItem(models.Model):\n    \"\"\"\n    Tags arbitrary model instances using a generic relation.\n\n    See: https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/\n    \"\"\"\n    tag_name = models.SlugField()\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    tagged_object = GenericForeignKey('content_type', 'object_id')\n\n    def __str__(self):\n        return self.tag_name\n```\n\nAnd the following two models, which may have associated tags:\n\n``` python\nclass Bookmark(models.Model):\n    \"\"\"\n    A bookmark consists of a URL, and 0 or more descriptive tags.\n    \"\"\"\n    url = models.URLField()\n    tags = GenericRelation(TaggedItem)\n\n\nclass Note(models.Model):\n    \"\"\"\n    A note consists of some text, and 0 or more descriptive tags.\n    \"\"\"\n    text = models.CharField(max_length=1000)\n    tags = GenericRelation(TaggedItem)\n```\n\nWe could define a custom field that could be used to serialize tagged instances, using the type of each instance to determine how it should be serialized:\n\n``` python\nclass TaggedObjectRelatedField(serializers.RelatedField):\n    \"\"\"\n    A custom field to use for the `tagged_object` generic relationship.\n    \"\"\"\n\n    def to_representation(self, value):\n        \"\"\"\n        Serialize tagged objects to a simple textual representation.\n        \"\"\"\n        if isinstance(value, Bookmark):\n            return 'Bookmark: ' + value.url\n        elif isinstance(value, Note):\n            return 'Note: ' + value.text\n        raise Exception('Unexpected type of tagged object')\n```\n\nIf you need the target of the relationship to have a nested representation, you can use the required serializers inside the `.to_representation()` method:\n\n``` python\n    def to_representation(self, value):\n        \"\"\"\n        Serialize bookmark instances using a bookmark serializer,\n        and note instances using a note serializer.\n        \"\"\"\n        if isinstance(value, Bookmark):\n            serializer = BookmarkSerializer(value)\n        elif isinstance(value, Note):\n            serializer = NoteSerializer(value)\n        else:\n            raise Exception('Unexpected type of tagged object')\n\n        return serializer.data\n```\n\nNote that reverse generic keys, expressed using the `GenericRelation` field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.\n\nFor more information see [the Django documentation on generic relations](https://docs.djangoproject.com/en/stable/ref/contrib/contenttypes/#id1).\n\n## ManyToManyFields with a Through Model\n\nBy default, relational fields that target a `ManyToManyField` with a `through` model specified are set to read-only.\n\nIf you explicitly specify a relational field pointing to a `ManyToManyField` with a through model, be sure to set `read_only` to `True`.\n\nIf you wish to represent [extra fields on a through model](https://docs.djangoproject.com/en/stable/topics/db/models/#intermediary-manytomany) then you may serialize the through model as [a nested object](../serializers/index#dealing-with-nested-objects).\n\n# Third Party Packages\n\nThe following third party packages are also available.\n\n## DRF Nested Routers\n\nThe [drf-nested-routers package](https://github.com/alanjds/drf-nested-routers) provides routers and relationship fields for working with nested resources.\n\n## Rest Framework Generic Relations\n\nThe [rest-framework-generic-relations](https://github.com/Ian-Foote/rest-framework-generic-relations) library provides read/write serialization for generic foreign keys.\n\n[relations.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/relations.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/relations/](https://www.django-rest-framework.org/api-guide/relations/)"
- name: SerializerMethodField
  id: api-guide/fields/index#serializermethodfield
  summary: This is a read-only field
  belongs_to: Serializer fields
  description: "## SerializerMethodField\n\nThis is a read-only field. It gets its value by calling a method on the serializer class it is attached to. It can be used to add any sort of data to the serialized representation of your object.\n\n**Signature**: `SerializerMethodField(method_name=None)`\n\n- `method_name` - The name of the method on the serializer to be called. If not included this defaults to `get_<field_name>`.\n\nThe serializer method referred to by the `method_name` argument should accept a single argument (in addition to `self`), which is the object being serialized. It should return whatever you want to be included in the serialized representation of the object. For example:\n\n``` python\nfrom django.contrib.auth.models import User\nfrom django.utils.timezone import now\nfrom rest_framework import serializers\n\nclass UserSerializer(serializers.ModelSerializer):\n    days_since_joined = serializers.SerializerMethodField()\n\n    class Meta:\n        model = User\n        fields = '__all__'\n\n    def get_days_since_joined(self, obj):\n        return (now() - obj.date_joined).days\n```\n\n# Custom fields\n\nIf you want to create a custom field, you'll need to subclass `Field` and then override either one or both of the `.to_representation()` and `.to_internal_value()` methods. These two methods are used to convert between the initial datatype, and a primitive, serializable datatype. Primitive datatypes will typically be any of a number, string, boolean, `date`/`time`/`datetime` or `None`. They may also be any list or dictionary like object that only contains other primitive objects. Other types might be supported, depending on the renderer that you are using.\n\nThe `.to_representation()` method is called to convert the initial datatype into a primitive, serializable datatype.\n\nThe `.to_internal_value()` method is called to restore a primitive datatype into its internal python representation. This method should raise a `serializers.ValidationError` if the data is invalid.\n\n## Examples\n\n### A Basic Custom Field\n\nLet's look at an example of serializing a class that represents an RGB color value:\n\n``` python\nclass Color:\n    \"\"\"\n    A color represented in the RGB colorspace.\n    \"\"\"\n    def __init__(self, red, green, blue):\n        assert(red >= 0 and green >= 0 and blue >= 0)\n        assert(red < 256 and green < 256 and blue < 256)\n        self.red, self.green, self.blue = red, green, blue\n\nclass ColorField(serializers.Field):\n    \"\"\"\n    Color objects are serialized into 'rgb(#, #, #)' notation.\n    \"\"\"\n    def to_representation(self, value):\n        return \"rgb(%d, %d, %d)\" % (value.red, value.green, value.blue)\n\n    def to_internal_value(self, data):\n        data = data.strip('rgb(').rstrip(')')\n        red, green, blue = [int(col) for col in data.split(',')]\n        return Color(red, green, blue)\n```\n\nBy default field values are treated as mapping to an attribute on the object. If you need to customize how the field value is accessed and set you need to override `.get_attribute()` and/or `.get_value()`.\n\nAs an example, let's create a field that can be used to represent the class name of the object being serialized:\n\n``` python\nclass ClassNameField(serializers.Field):\n    def get_attribute(self, instance):\n        # We pass the object instance onto `to_representation`,\n        # not just the field attribute.\n        return instance\n\n    def to_representation(self, value):\n        \"\"\"\n        Serialize the value's class name.\n        \"\"\"\n        return value.__class__.__name__\n```\n\n### Raising validation errors\n\nOur `ColorField` class above currently does not perform any data validation. To indicate invalid data, we should raise a `serializers.ValidationError`, like so:\n\n``` python\ndef to_internal_value(self, data):\n    if not isinstance(data, str):\n        msg = 'Incorrect type. Expected a string, but got %s'\n        raise ValidationError(msg % type(data).__name__)\n\n    if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data):\n        raise ValidationError('Incorrect format. Expected `rgb(#,#,#)`.')\n\n    data = data.strip('rgb(').rstrip(')')\n    red, green, blue = [int(col) for col in data.split(',')]\n\n    if any([col > 255 or col < 0 for col in (red, green, blue)]):\n        raise ValidationError('Value out of range. Must be between 0 and 255.')\n\n    return Color(red, green, blue)\n```\n\nThe `.fail()` method is a shortcut for raising `ValidationError` that takes a message string from the `error_messages` dictionary. For example:\n\n``` python\ndefault_error_messages = {\n    'incorrect_type': 'Incorrect type. Expected a string, but got {input_type}',\n    'incorrect_format': 'Incorrect format. Expected `rgb(#,#,#)`.',\n    'out_of_range': 'Value out of range. Must be between 0 and 255.'\n}\n\ndef to_internal_value(self, data):\n    if not isinstance(data, str):\n        self.fail('incorrect_type', input_type=type(data).__name__)\n\n    if not re.match(r'^rgb\\([0-9]+,[0-9]+,[0-9]+\\)$', data):\n        self.fail('incorrect_format')\n\n    data = data.strip('rgb(').rstrip(')')\n    red, green, blue = [int(col) for col in data.split(',')]\n\n    if any([col > 255 or col < 0 for col in (red, green, blue)]):\n        self.fail('out_of_range')\n\n    return Color(red, green, blue)\n```\n\nThis style keeps your error messages cleaner and more separated from your code, and should be preferred.\n\n### Using source='\\*'\n\nHere we'll take an example of a *flat* `DataPoint` model with `x_coordinate` and `y_coordinate` attributes.\n\n``` python\nclass DataPoint(models.Model):\n    label = models.CharField(max_length=50)\n    x_coordinate = models.SmallIntegerField()\n    y_coordinate = models.SmallIntegerField()\n```\n\nUsing a custom field and `source='*'` we can provide a nested representation of the coordinate pair:\n\n``` python\nclass CoordinateField(serializers.Field):\n\n    def to_representation(self, value):\n        ret = {\n            \"x\": value.x_coordinate,\n            \"y\": value.y_coordinate\n        }\n        return ret\n\n    def to_internal_value(self, data):\n        ret = {\n            \"x_coordinate\": data[\"x\"],\n            \"y_coordinate\": data[\"y\"],\n        }\n        return ret\n\n\nclass DataPointSerializer(serializers.ModelSerializer):\n    coordinates = CoordinateField(source='*')\n\n    class Meta:\n        model = DataPoint\n        fields = ['label', 'coordinates']\n```\n\nNote that this example doesn't handle validation. Partly for that reason, in a real project, the coordinate nesting might be better handled with a nested serializer using `source='*'`, with two `IntegerField` instances, each with their own `source` pointing to the relevant field.\n\nThe key points from the example, though, are:\n\n- `to_representation` is passed the entire `DataPoint` object and must map from that to the desired output.\n\n  ``` python\n  >>> instance = DataPoint(label='Example', x_coordinate=1, y_coordinate=2)\n  >>> out_serializer = DataPointSerializer(instance)\n  >>> out_serializer.data\n  ReturnDict([('label', 'Example'), ('coordinates', {'x': 1, 'y': 2})])\n  ```\n\n- Unless our field is to be read-only, `to_internal_value` must map back to a dict suitable for updating our target object. With `source='*'`, the return from `to_internal_value` will update the root validated data dictionary, rather than a single key.\n\n  ``` python\n  >>> data = {\n  ...     \"label\": \"Second Example\",\n  ...     \"coordinates\": {\n  ...         \"x\": 3,\n  ...         \"y\": 4,\n  ...     }\n  ... }\n  >>> in_serializer = DataPointSerializer(data=data)\n  >>> in_serializer.is_valid()\n  True\n  >>> in_serializer.validated_data\n  OrderedDict([('label', 'Second Example'),\n               ('y_coordinate', 4),\n               ('x_coordinate', 3)])\n  ```\n\nFor completeness lets do the same thing again but with the nested serializer approach suggested above:\n\n``` python\nclass NestedCoordinateSerializer(serializers.Serializer):\n    x = serializers.IntegerField(source='x_coordinate')\n    y = serializers.IntegerField(source='y_coordinate')\n\n\nclass DataPointSerializer(serializers.ModelSerializer):\n    coordinates = NestedCoordinateSerializer(source='*')\n\n    class Meta:\n        model = DataPoint\n        fields = ['label', 'coordinates']\n```\n\nHere the mapping between the target and source attribute pairs (`x` and `x_coordinate`, `y` and `y_coordinate`) is handled in the `IntegerField` declarations. It's our `NestedCoordinateSerializer` that takes `source='*'`.\n\nOur new `DataPointSerializer` exhibits the same behavior as the custom field approach.\n\nSerializing:\n\n``` python\n>>> out_serializer = DataPointSerializer(instance)\n>>> out_serializer.data\nReturnDict([('label', 'testing'),\n            ('coordinates', OrderedDict([('x', 1), ('y', 2)]))])\n```\n\nDeserializing:\n\n``` python\n>>> in_serializer = DataPointSerializer(data=data)\n>>> in_serializer.is_valid()\nTrue\n>>> in_serializer.validated_data\nOrderedDict([('label', 'still testing'),\n             ('x_coordinate', 3),\n             ('y_coordinate', 4)])\n```\n\nBut we also get the built-in validation for free:\n\n``` python\n>>> invalid_data = {\n...     \"label\": \"still testing\",\n...     \"coordinates\": {\n...         \"x\": 'a',\n...         \"y\": 'b',\n...     }\n... }\n>>> invalid_serializer = DataPointSerializer(data=invalid_data)\n>>> invalid_serializer.is_valid()\nFalse\n>>> invalid_serializer.errors\nReturnDict([('coordinates',\n             {'x': ['A valid integer is required.'],\n              'y': ['A valid integer is required.']})])\n```\n\nFor this reason, the nested serializer approach would be the first to try. You would use the custom field approach when the nested serializer becomes infeasible or overly complex.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## DRF Compound Fields\n\nThe [drf-compound-fields](https://drf-compound-fields.readthedocs.io) package provides \"compound\" serializer fields, such as lists of simple values, which can be described by other fields rather than serializers with the `many=True` option. Also provided are fields for typed dictionaries and values that can be either a specific type or a list of items of that type.\n\n## DRF Extra Fields\n\nThe [drf-extra-fields](https://github.com/Hipo/drf-extra-fields) package provides extra serializer fields for REST framework, including `Base64ImageField` and `PointField` classes.\n\n## djangorestframework-recursive\n\nthe [djangorestframework-recursive](https://github.com/heywbj/django-rest-framework-recursive) package provides a `RecursiveField` for serializing and deserializing recursive structures\n\n## django-rest-framework-gis\n\nThe [django-rest-framework-gis](https://github.com/djangonauts/django-rest-framework-gis) package provides geographic addons for django rest framework like a `GeometryField` field and a GeoJSON serializer.\n\n## django-rest-framework-hstore\n\nThe [django-rest-framework-hstore](https://github.com/djangonauts/django-rest-framework-hstore) package provides an `HStoreField` to support [django-hstore](https://github.com/djangonauts/django-hstore) `DictionaryField` model field.\n\n[fields.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/fields.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/fields/](https://www.django-rest-framework.org/api-guide/fields/)"
- name: Serializers
  id: api-guide/serializers/index
  summary: Expanding the usefulness of the serializers is something that we would like to address
  description: "# Serializers\n\n> Expanding the usefulness of the serializers is something that we would like to address. However, it's not a trivial problem, and it will take some serious design work.\n>\n> — Russell Keith-Magee, [Django users group](https://groups.google.com/d/topic/django-users/sVFaOfQi4wY/discussion)\n\nSerializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into `JSON`, `XML` or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.\n\nThe serializers in REST framework work very similarly to Django's `Form` and `ModelForm` classes. We provide a `Serializer` class which gives you a powerful, generic way to control the output of your responses, as well as a `ModelSerializer` class which provides a useful shortcut for creating serializers that deal with model instances and querysets.\n\n## Declaring Serializers\n\nLet's start by creating a simple object we can use for example purposes:\n\n``` python\nfrom datetime import datetime\n\nclass Comment:\n    def __init__(self, email, content, created=None):\n        self.email = email\n        self.content = content\n        self.created = created or datetime.now()\n\ncomment = Comment(email='leila@example.com', content='foo bar')\n```\n\nWe'll declare a serializer that we can use to serialize and deserialize data that corresponds to `Comment` objects.\n\nDeclaring a serializer looks very similar to declaring a form:\n\n``` python\nfrom rest_framework import serializers\n\nclass CommentSerializer(serializers.Serializer):\n    email = serializers.EmailField()\n    content = serializers.CharField(max_length=200)\n    created = serializers.DateTimeField()\n```\n\n## Serializing objects\n\nWe can now use `CommentSerializer` to serialize a comment, or list of comments. Again, using the `Serializer` class looks a lot like using a `Form` class.\n\n``` python\nserializer = CommentSerializer(comment)\nserializer.data\n# {'email': 'leila@example.com', 'content': 'foo bar', 'created': '2016-01-27T15:17:10.375877'}\n```\n\nAt this point we've translated the model instance into Python native datatypes. To finalise the serialization process we render the data into `json`.\n\n``` python\nfrom rest_framework.renderers import JSONRenderer\n\njson = JSONRenderer().render(serializer.data)\njson\n# b'{\"email\":\"leila@example.com\",\"content\":\"foo bar\",\"created\":\"2016-01-27T15:17:10.375877\"}'\n```\n\n## Deserializing objects\n\nDeserialization is similar. First we parse a stream into Python native datatypes...\n\n``` python\nimport io\nfrom rest_framework.parsers import JSONParser\n\nstream = io.BytesIO(json)\ndata = JSONParser().parse(stream)\n```\n\n...then we restore those native datatypes into a dictionary of validated data.\n\n``` python\nserializer = CommentSerializer(data=data)\nserializer.is_valid()\n# True\nserializer.validated_data\n# {'content': 'foo bar', 'email': 'leila@example.com', 'created': datetime.datetime(2012, 08, 22, 16, 20, 09, 822243)}\n```\n\n## Saving instances\n\nIf we want to be able to return complete object instances based on the validated data we need to implement one or both of the `.create()` and `.update()` methods. For example:\n\n``` python\nclass CommentSerializer(serializers.Serializer):\n    email = serializers.EmailField()\n    content = serializers.CharField(max_length=200)\n    created = serializers.DateTimeField()\n\n    def create(self, validated_data):\n        return Comment(**validated_data)\n\n    def update(self, instance, validated_data):\n        instance.email = validated_data.get('email', instance.email)\n        instance.content = validated_data.get('content', instance.content)\n        instance.created = validated_data.get('created', instance.created)\n        return instance\n```\n\nIf your object instances correspond to Django models you'll also want to ensure that these methods save the object to the database. For example, if `Comment` was a Django model, the methods might look like this:\n\n``` python\n    def create(self, validated_data):\n        return Comment.objects.create(**validated_data)\n\n    def update(self, instance, validated_data):\n        instance.email = validated_data.get('email', instance.email)\n        instance.content = validated_data.get('content', instance.content)\n        instance.created = validated_data.get('created', instance.created)\n        instance.save()\n        return instance\n```\n\nNow when deserializing data, we can call `.save()` to return an object instance, based on the validated data.\n\n``` python\ncomment = serializer.save()\n```\n\nCalling `.save()` will either create a new instance, or update an existing instance, depending on if an existing instance was passed when instantiating the serializer class:\n\n``` python\n# .save() will create a new instance.\nserializer = CommentSerializer(data=data)\n\n# .save() will update the existing `comment` instance.\nserializer = CommentSerializer(comment, data=data)\n```\n\nBoth the `.create()` and `.update()` methods are optional. You can implement either none, one, or both of them, depending on the use-case for your serializer class.\n\n#### Passing additional attributes to .save()\n\nSometimes you'll want your view code to be able to inject additional data at the point of saving the instance. This additional data might include information like the current user, the current time, or anything else that is not part of the request data.\n\nYou can do so by including additional keyword arguments when calling `.save()`. For example:\n\n``` python\nserializer.save(owner=request.user)\n```\n\nAny additional keyword arguments will be included in the `validated_data` argument when `.create()` or `.update()` are called.\n\n#### Overriding .save() directly.\n\nIn some cases the `.create()` and `.update()` method names may not be meaningful. For example, in a contact form we may not be creating new instances, but instead sending an email or other message.\n\nIn these cases you might instead choose to override `.save()` directly, as being more readable and meaningful.\n\nFor example:\n\n``` python\nclass ContactForm(serializers.Serializer):\n    email = serializers.EmailField()\n    message = serializers.CharField()\n\n    def save(self):\n        email = self.validated_data['email']\n        message = self.validated_data['message']\n        send_email(from=email, message=message)\n```\n\nNote that in the case above we're now having to access the serializer `.validated_data` property directly.\n\n## Validation\n\nWhen deserializing data, you always need to call `is_valid()` before attempting to access the validated data, or save an object instance. If any validation errors occur, the `.errors` property will contain a dictionary representing the resulting error messages. For example:\n\n``` python\nserializer = CommentSerializer(data={'email': 'foobar', 'content': 'baz'})\nserializer.is_valid()\n# False\nserializer.errors\n# {'email': ['Enter a valid e-mail address.'], 'created': ['This field is required.']}\n```\n\nEach key in the dictionary will be the field name, and the values will be lists of strings of any error messages corresponding to that field. The `non_field_errors` key may also be present, and will list any general validation errors. The name of the `non_field_errors` key may be customized using the `NON_FIELD_ERRORS_KEY` REST framework setting.\n\nWhen deserializing a list of items, errors will be returned as a list of dictionaries representing each of the deserialized items.\n\n#### Raising an exception on invalid data\n\nThe `.is_valid()` method takes an optional `raise_exception` flag that will cause it to raise a `serializers.ValidationError` exception if there are validation errors.\n\nThese exceptions are automatically dealt with by the default exception handler that REST framework provides, and will return `HTTP 400 Bad Request` responses by default.\n\n``` python\n# Return a 400 response if the data was invalid.\nserializer.is_valid(raise_exception=True)\n```\n\n#### Field-level validation\n\nYou can specify custom field-level validation by adding `.validate_<field_name>` methods to your `Serializer` subclass. These are similar to the `.clean_<field_name>` methods on Django forms.\n\nThese methods take a single argument, which is the field value that requires validation.\n\nYour `validate_<field_name>` methods should return the validated value or raise a `serializers.ValidationError`. For example:\n\n``` python\nfrom rest_framework import serializers\n\nclass BlogPostSerializer(serializers.Serializer):\n    title = serializers.CharField(max_length=100)\n    content = serializers.CharField()\n\n    def validate_title(self, value):\n        \"\"\"\n        Check that the blog post is about Django.\n        \"\"\"\n        if 'django' not in value.lower():\n            raise serializers.ValidationError(\"Blog post is not about Django\")\n        return value\n```\n\n**Note:** If your `<field_name>` is declared on your serializer with the parameter `required=False` then this validation step will not take place if the field is not included.\n\n#### Object-level validation\n\nTo do any other validation that requires access to multiple fields, add a method called `.validate()` to your `Serializer` subclass. This method takes a single argument, which is a dictionary of field values. It should raise a `serializers.ValidationError` if necessary, or just return the validated values. For example:\n\n``` python\nfrom rest_framework import serializers\n\nclass EventSerializer(serializers.Serializer):\n    description = serializers.CharField(max_length=100)\n    start = serializers.DateTimeField()\n    finish = serializers.DateTimeField()\n\n    def validate(self, data):\n        \"\"\"\n        Check that start is before finish.\n        \"\"\"\n        if data['start'] > data['finish']:\n            raise serializers.ValidationError(\"finish must occur after start\")\n        return data\n```\n\n#### Validators\n\nIndividual fields on a serializer can include validators, by declaring them on the field instance, for example:\n\n``` python\ndef multiple_of_ten(value):\n    if value % 10 != 0:\n        raise serializers.ValidationError('Not a multiple of ten')\n\nclass GameRecord(serializers.Serializer):\n    score = serializers.IntegerField(validators=[multiple_of_ten])\n    ...\n```\n\nSerializer classes can also include reusable validators that are applied to the complete set of field data. These validators are included by declaring them on an inner `Meta` class, like so:\n\n``` python\nclass EventSerializer(serializers.Serializer):\n    name = serializers.CharField()\n    room_number = serializers.IntegerField(choices=[101, 102, 103, 201])\n    date = serializers.DateField()\n\n    class Meta:\n        # Each room only has one event per day.\n        validators = [\n            UniqueTogetherValidator(\n                queryset=Event.objects.all(),\n                fields=['room_number', 'date']\n            )\n        ]\n```\n\nFor more information see the [validators documentation](../validators/index).\n\n## Accessing the initial data and instance\n\nWhen passing an initial object or queryset to a serializer instance, the object will be made available as `.instance`. If no initial object is passed then the `.instance` attribute will be `None`.\n\nWhen passing data to a serializer instance, the unmodified data will be made available as `.initial_data`. If the `data` keyword argument is not passed then the `.initial_data` attribute will not exist.\n\n## Partial updates\n\nBy default, serializers must be passed values for all required fields or they will raise validation errors. You can use the `partial` argument in order to allow partial updates.\n\n``` python\n# Update `comment` with partial data\nserializer = CommentSerializer(comment, data={'content': 'foo bar'}, partial=True)\n```\n\n## Dealing with nested objects\n\nThe previous examples are fine for dealing with objects that only have simple datatypes, but sometimes we also need to be able to represent more complex objects, where some of the attributes of an object might not be simple datatypes such as strings, dates or integers.\n\nThe `Serializer` class is itself a type of `Field`, and can be used to represent relationships where one object type is nested inside another.\n\n``` python\nclass UserSerializer(serializers.Serializer):\n    email = serializers.EmailField()\n    username = serializers.CharField(max_length=100)\n\nclass CommentSerializer(serializers.Serializer):\n    user = UserSerializer()\n    content = serializers.CharField(max_length=200)\n    created = serializers.DateTimeField()\n```\n\nIf a nested representation may optionally accept the `None` value you should pass the `required=False` flag to the nested serializer.\n\n``` python\nclass CommentSerializer(serializers.Serializer):\n    user = UserSerializer(required=False)  # May be an anonymous user.\n    content = serializers.CharField(max_length=200)\n    created = serializers.DateTimeField()\n```\n\nSimilarly if a nested representation should be a list of items, you should pass the `many=True` flag to the nested serializer.\n\n``` python\nclass CommentSerializer(serializers.Serializer):\n    user = UserSerializer(required=False)\n    edits = EditItemSerializer(many=True)  # A nested list of 'edit' items.\n    content = serializers.CharField(max_length=200)\n    created = serializers.DateTimeField()\n```\n\n## Writable nested representations\n\nWhen dealing with nested representations that support deserializing the data, any errors with nested objects will be nested under the field name of the nested object.\n\n``` python\nserializer = CommentSerializer(data={'user': {'email': 'foobar', 'username': 'doe'}, 'content': 'baz'})\nserializer.is_valid()\n# False\nserializer.errors\n# {'user': {'email': ['Enter a valid e-mail address.']}, 'created': ['This field is required.']}\n```\n\nSimilarly, the `.validated_data` property will include nested data structures.\n\n#### Writing .create() methods for nested representations\n\nIf you're supporting writable nested representations you'll need to write `.create()` or `.update()` methods that handle saving multiple objects.\n\nThe following example demonstrates how you might handle creating a user with a nested profile object.\n\n``` python\nclass UserSerializer(serializers.ModelSerializer):\n    profile = ProfileSerializer()\n\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'profile']\n\n    def create(self, validated_data):\n        profile_data = validated_data.pop('profile')\n        user = User.objects.create(**validated_data)\n        Profile.objects.create(user=user, **profile_data)\n        return user\n```\n\n#### Writing .update() methods for nested representations\n\nFor updates you'll want to think carefully about how to handle updates to relationships. For example if the data for the relationship is `None`, or not provided, which of the following should occur?\n\n- Set the relationship to `NULL` in the database.\n- Delete the associated instance.\n- Ignore the data and leave the instance as it is.\n- Raise a validation error.\n\nHere's an example for an `.update()` method on our previous `UserSerializer` class.\n\n``` python\n    def update(self, instance, validated_data):\n        profile_data = validated_data.pop('profile')\n        # Unless the application properly enforces that this field is\n        # always set, the following could raise a `DoesNotExist`, which\n        # would need to be handled.\n        profile = instance.profile\n\n        instance.username = validated_data.get('username', instance.username)\n        instance.email = validated_data.get('email', instance.email)\n        instance.save()\n\n        profile.is_premium_member = profile_data.get(\n            'is_premium_member',\n            profile.is_premium_member\n        )\n        profile.has_support_contract = profile_data.get(\n            'has_support_contract',\n            profile.has_support_contract\n         )\n        profile.save()\n\n        return instance\n```\n\nBecause the behavior of nested creates and updates can be ambiguous, and may require complex dependencies between related models, REST framework 3 requires you to always write these methods explicitly. The default `ModelSerializer` `.create()` and `.update()` methods do not include support for writable nested representations.\n\nThere are however, third-party packages available such as [DRF Writable Nested](index#drf-writable-nested) that support automatic writable nested representations.\n\n#### Handling saving related instances in model manager classes\n\nAn alternative to saving multiple related instances in the serializer is to write custom model manager classes that handle creating the correct instances.\n\nFor example, suppose we wanted to ensure that `User` instances and `Profile` instances are always created together as a pair. We might write a custom manager class that looks something like this:\n\n``` python\nclass UserManager(models.Manager):\n    ...\n\n    def create(self, username, email, is_premium_member=False, has_support_contract=False):\n        user = User(username=username, email=email)\n        user.save()\n        profile = Profile(\n            user=user,\n            is_premium_member=is_premium_member,\n            has_support_contract=has_support_contract\n        )\n        profile.save()\n        return user\n```\n\nThis manager class now more nicely encapsulates that user instances and profile instances are always created at the same time. Our `.create()` method on the serializer class can now be re-written to use the new manager method.\n\n``` python\ndef create(self, validated_data):\n    return User.objects.create(\n        username=validated_data['username'],\n        email=validated_data['email'],\n        is_premium_member=validated_data['profile']['is_premium_member'],\n        has_support_contract=validated_data['profile']['has_support_contract']\n    )\n```\n\nFor more details on this approach see the Django documentation on [model managers](https://docs.djangoproject.com/en/stable/topics/db/managers/), and [this blogpost on using model and manager classes](https://www.dabapps.com/blog/django-models-and-encapsulation/).\n\n## Dealing with multiple objects\n\nThe `Serializer` class can also handle serializing or deserializing lists of objects.\n\n#### Serializing multiple objects\n\nTo serialize a queryset or list of objects instead of a single object instance, you should pass the `many=True` flag when instantiating the serializer. You can then pass a queryset or list of objects to be serialized.\n\n``` python\nqueryset = Book.objects.all()\nserializer = BookSerializer(queryset, many=True)\nserializer.data\n# [\n#     {'id': 0, 'title': 'The electric kool-aid acid test', 'author': 'Tom Wolfe'},\n#     {'id': 1, 'title': 'If this is a man', 'author': 'Primo Levi'},\n#     {'id': 2, 'title': 'The wind-up bird chronicle', 'author': 'Haruki Murakami'}\n# ]\n```\n\n#### Deserializing multiple objects\n\nThe default behavior for deserializing multiple objects is to support multiple object creation, but not support multiple object updates. For more information on how to support or customize either of these cases, see the [ListSerializer](#listserializer) documentation below.\n\n## Including extra context\n\nThere are some cases where you need to provide extra context to the serializer in addition to the object being serialized. One common case is if you're using a serializer that includes hyperlinked relations, which requires the serializer to have access to the current request so that it can properly generate fully qualified URLs.\n\nYou can provide arbitrary additional context by passing a `context` argument when instantiating the serializer. For example:\n\n``` python\nserializer = AccountSerializer(account, context={'request': request})\nserializer.data\n# {'id': 6, 'owner': 'denvercoder9', 'created': datetime.datetime(2013, 2, 12, 09, 44, 56, 678870), 'details': 'http://example.com/accounts/6/details'}\n```\n\nThe context dictionary can be used within any serializer field logic, such as a custom `.to_representation()` method, by accessing the `self.context` attribute.\n\n# ModelSerializer\n\nOften you'll want serializer classes that map closely to Django model definitions.\n\nThe `ModelSerializer` class provides a shortcut that lets you automatically create a `Serializer` class with fields that correspond to the Model fields.\n\n**The `ModelSerializer` class is the same as a regular `Serializer` class, except that**:\n\n- It will automatically generate a set of fields for you, based on the model.\n- It will automatically generate validators for the serializer, such as unique_together validators.\n- It includes simple default implementations of `.create()` and `.update()`.\n\nDeclaring a `ModelSerializer` looks like this:\n\n``` python\nclass AccountSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Account\n        fields = ['id', 'account_name', 'users', 'created']\n```\n\nBy default, all the model fields on the class will be mapped to a corresponding serializer fields.\n\nAny relationships such as foreign keys on the model will be mapped to `PrimaryKeyRelatedField`. Reverse relationships are not included by default unless explicitly included as specified in the [serializer relations](../relations/index) documentation.\n\n#### Inspecting a ModelSerializer\n\nSerializer classes generate helpful verbose representation strings, that allow you to fully inspect the state of their fields. This is particularly useful when working with `ModelSerializers` where you want to determine what set of fields and validators are being automatically created for you.\n\nTo do so, open the Django shell, using `python manage.py shell`, then import the serializer class, instantiate it, and print the object representation…\n\n``` python\n>>> from myapp.serializers import AccountSerializer\n>>> serializer = AccountSerializer()\n>>> print(repr(serializer))\nAccountSerializer():\n    id = IntegerField(label='ID', read_only=True)\n    name = CharField(allow_blank=True, max_length=100, required=False)\n    owner = PrimaryKeyRelatedField(queryset=User.objects.all())\n```\n\n## Specifying which fields to include\n\nIf you only want a subset of the default fields to be used in a model serializer, you can do so using `fields` or `exclude` options, just as you would with a `ModelForm`. It is strongly recommended that you explicitly set all fields that should be serialized using the `fields` attribute. This will make it less likely to result in unintentionally exposing data when your models change.\n\nFor example:\n\n``` python\nclass AccountSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Account\n        fields = ['id', 'account_name', 'users', 'created']\n```\n\nYou can also set the `fields` attribute to the special value `'__all__'` to indicate that all fields in the model should be used.\n\nFor example:\n\n``` python\nclass AccountSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Account\n        fields = '__all__'\n```\n\nYou can set the `exclude` attribute to a list of fields to be excluded from the serializer.\n\nFor example:\n\n``` python\nclass AccountSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Account\n        exclude = ['users']\n```\n\nIn the example above, if the `Account` model had 3 fields `account_name`, `users`, and `created`, this will result in the fields `account_name` and `created` to be serialized.\n\nThe names in the `fields` and `exclude` attributes will normally map to model fields on the model class.\n\nAlternatively names in the `fields` options can map to properties or methods which take no arguments that exist on the model class.\n\nSince version 3.3.0, it is **mandatory** to provide one of the attributes `fields` or `exclude`.\n\n## Specifying nested serialization\n\nThe default `ModelSerializer` uses primary keys for relationships, but you can also easily generate nested representations using the `depth` option:\n\n``` python\nclass AccountSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Account\n        fields = ['id', 'account_name', 'users', 'created']\n        depth = 1\n```\n\nThe `depth` option should be set to an integer value that indicates the depth of relationships that should be traversed before reverting to a flat representation.\n\nIf you want to customize the way the serialization is done you'll need to define the field yourself.\n\n## Specifying fields explicitly\n\nYou can add extra fields to a `ModelSerializer` or override the default fields by declaring fields on the class, just as you would for a `Serializer` class.\n\n``` python\nclass AccountSerializer(serializers.ModelSerializer):\n    url = serializers.CharField(source='get_absolute_url', read_only=True)\n    groups = serializers.PrimaryKeyRelatedField(many=True)\n\n    class Meta:\n        model = Account\n        fields = ['url', 'groups']\n```\n\nExtra fields can correspond to any property or callable on the model.\n\n## Specifying read only fields\n\nYou may wish to specify multiple fields as read-only. Instead of adding each field explicitly with the `read_only=True` attribute, you may use the shortcut Meta option, `read_only_fields`.\n\nThis option should be a list or tuple of field names, and is declared as follows:\n\n``` python\nclass AccountSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Account\n        fields = ['id', 'account_name', 'users', 'created']\n        read_only_fields = ['account_name']\n```\n\nModel fields which have `editable=False` set, and `AutoField` fields will be set to read-only by default, and do not need to be added to the `read_only_fields` option.\n\n**Note**: There is a special-case where a read-only field is part of a `unique_together` constraint at the model level. In this case the field is required by the serializer class in order to validate the constraint, but should also not be editable by the user.\n\nThe right way to deal with this is to specify the field explicitly on the serializer, providing both the `read_only=True` and `default=…` keyword arguments.\n\nOne example of this is a read-only relation to the currently authenticated `User` which is `unique_together` with another identifier. In this case you would declare the user field like so:\n\n``` python\nuser = serializers.PrimaryKeyRelatedField(read_only=True, default=serializers.CurrentUserDefault())\n```\n\nPlease review the [Validators Documentation](../validators/index) for details on the [UniqueTogetherValidator](../validators/index#uniquetogethervalidator) and [CurrentUserDefault](../validators/index#currentuserdefault) classes.\n\n## Additional keyword arguments\n\nThere is also a shortcut allowing you to specify arbitrary additional keyword arguments on fields, using the `extra_kwargs` option. As in the case of `read_only_fields`, this means you do not need to explicitly declare the field on the serializer.\n\nThis option is a dictionary, mapping field names to a dictionary of keyword arguments. For example:\n\n``` python\nclass CreateUserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['email', 'username', 'password']\n        extra_kwargs = {'password': {'write_only': True}}\n\n    def create(self, validated_data):\n        user = User(\n            email=validated_data['email'],\n            username=validated_data['username']\n        )\n        user.set_password(validated_data['password'])\n        user.save()\n        return user\n```\n\nPlease keep in mind that, if the field has already been explicitly declared on the serializer class, then the `extra_kwargs` option will be ignored.\n\n## Relational fields\n\nWhen serializing model instances, there are a number of different ways you might choose to represent relationships. The default representation for `ModelSerializer` is to use the primary keys of the related instances.\n\nAlternative representations include serializing using hyperlinks, serializing complete nested representations, or serializing with a custom representation.\n\nFor full details see the [serializer relations](../relations/index) documentation.\n\n## Customizing field mappings\n\nThe ModelSerializer class also exposes an API that you can override in order to alter how serializer fields are automatically determined when instantiating the serializer.\n\nNormally if a `ModelSerializer` does not generate the fields you need by default then you should either add them to the class explicitly, or simply use a regular `Serializer` class instead. However in some cases you may want to create a new base class that defines how the serializer fields are created for any given model.\n\n### serializer_field_mapping\n\nA mapping of Django model fields to REST framework serializer fields. You can override this mapping to alter the default serializer fields that should be used for each model field.\n\n### serializer_related_field\n\nThis property should be the serializer field class, that is used for relational fields by default.\n\nFor `ModelSerializer` this defaults to `serializers.PrimaryKeyRelatedField`.\n\nFor `HyperlinkedModelSerializer` this defaults to `serializers.HyperlinkedRelatedField`.\n\n### serializer_url_field\n\nThe serializer field class that should be used for any `url` field on the serializer.\n\nDefaults to `serializers.HyperlinkedIdentityField`\n\n### serializer_choice_field\n\nThe serializer field class that should be used for any choice fields on the serializer.\n\nDefaults to `serializers.ChoiceField`\n\n### The field_class and field_kwargs API\n\nThe following methods are called to determine the class and keyword arguments for each field that should be automatically included on the serializer. Each of these methods should return a two tuple of `(field_class, field_kwargs)`.\n\n### build_standard_field(self, field_name, model_field)\n\nCalled to generate a serializer field that maps to a standard model field.\n\nThe default implementation returns a serializer class based on the `serializer_field_mapping` attribute.\n\n### build_relational_field(self, field_name, relation_info)\n\nCalled to generate a serializer field that maps to a relational model field.\n\nThe default implementation returns a serializer class based on the `serializer_related_field` attribute.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`, `related_model`, `to_many` and `has_through_model` properties.\n\n### build_nested_field(self, field_name, relation_info, nested_depth)\n\nCalled to generate a serializer field that maps to a relational model field, when the `depth` option has been set.\n\nThe default implementation dynamically creates a nested serializer class based on either `ModelSerializer` or `HyperlinkedModelSerializer`.\n\nThe `nested_depth` will be the value of the `depth` option, minus one.\n\nThe `relation_info` argument is a named tuple, that contains `model_field`, `related_model`, `to_many` and `has_through_model` properties.\n\n### build_property_field(self, field_name, model_class)\n\nCalled to generate a serializer field that maps to a property or zero-argument method on the model class.\n\nThe default implementation returns a `ReadOnlyField` class.\n\n### build_url_field(self, field_name, model_class)\n\nCalled to generate a serializer field for the serializer's own `url` field. The default implementation returns a `HyperlinkedIdentityField` class.\n\n### build_unknown_field(self, field_name, model_class)\n\nCalled when the field name did not map to any model field or model property. The default implementation raises an error, although subclasses may customize this behavior.\n\n# HyperlinkedModelSerializer\n\nThe `HyperlinkedModelSerializer` class is similar to the `ModelSerializer` class except that it uses hyperlinks to represent relationships, rather than primary keys.\n\nBy default the serializer will include a `url` field instead of a primary key field.\n\nThe url field will be represented using a `HyperlinkedIdentityField` serializer field, and any relationships on the model will be represented using a `HyperlinkedRelatedField` serializer field.\n\nYou can explicitly include the primary key by adding it to the `fields` option, for example:\n\n``` python\nclass AccountSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = Account\n        fields = ['url', 'id', 'account_name', 'users', 'created']\n```\n\n## Absolute and relative URLs\n\nWhen instantiating a `HyperlinkedModelSerializer` you must include the current `request` in the serializer context, for example:\n\n``` python\nserializer = AccountSerializer(queryset, context={'request': request})\n```\n\nDoing so will ensure that the hyperlinks can include an appropriate hostname, so that the resulting representation uses fully qualified URLs, such as:\n\n``` python\nhttp://api.example.com/accounts/1/\n```\n\nRather than relative URLs, such as:\n\n``` python\n/accounts/1/\n```\n\nIf you *do* want to use relative URLs, you should explicitly pass `{'request': None}` in the serializer context.\n\n## How hyperlinked views are determined\n\nThere needs to be a way of determining which views should be used for hyperlinking to model instances.\n\nBy default hyperlinks are expected to correspond to a view name that matches the style `'{model_name}-detail'`, and looks up the instance by a `pk` keyword argument.\n\nYou can override a URL field view name and lookup field by using either, or both of, the `view_name` and `lookup_field` options in the `extra_kwargs` setting, like so:\n\n``` python\nclass AccountSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = Account\n        fields = ['account_url', 'account_name', 'users', 'created']\n        extra_kwargs = {\n            'url': {'view_name': 'accounts', 'lookup_field': 'account_name'},\n            'users': {'lookup_field': 'username'}\n        }\n```\n\nAlternatively you can set the fields on the serializer explicitly. For example:\n\n``` python\nclass AccountSerializer(serializers.HyperlinkedModelSerializer):\n    url = serializers.HyperlinkedIdentityField(\n        view_name='accounts',\n        lookup_field='slug'\n    )\n    users = serializers.HyperlinkedRelatedField(\n        view_name='user-detail',\n        lookup_field='username',\n        many=True,\n        read_only=True\n    )\n\n    class Meta:\n        model = Account\n        fields = ['url', 'account_name', 'users', 'created']\n```\n\n**Tip**: Properly matching together hyperlinked representations and your URL conf can sometimes be a bit fiddly. Printing the `repr` of a `HyperlinkedModelSerializer` instance is a particularly useful way to inspect exactly which view names and lookup fields the relationships are expected to map too.\n\n## Changing the URL field name\n\nThe name of the URL field defaults to 'url'. You can override this globally, by using the `URL_FIELD_NAME` setting.\n\n# ListSerializer\n\nThe `ListSerializer` class provides the behavior for serializing and validating multiple objects at once. You won't *typically* need to use `ListSerializer` directly, but should instead simply pass `many=True` when instantiating a serializer.\n\nWhen a serializer is instantiated and `many=True` is passed, a `ListSerializer` instance will be created. The serializer class then becomes a child of the parent `ListSerializer`\n\nThe following argument can also be passed to a `ListSerializer` field or a serializer that is passed `many=True`:\n\n### allow_empty\n\nThis is `True` by default, but can be set to `False` if you want to disallow empty lists as valid input.\n\n### max_length\n\nThis is `None` by default, but can be set to a positive integer if you want to validate that the list contains no more than this number of elements.\n\n### min_length\n\nThis is `None` by default, but can be set to a positive integer if you want to validate that the list contains no fewer than this number of elements.\n\n### Customizing ListSerializer behavior\n\nThere *are* a few use cases when you might want to customize the `ListSerializer` behavior. For example:\n\n- You want to provide particular validation of the lists, such as checking that one element does not conflict with another element in a list.\n- You want to customize the create or update behavior of multiple objects.\n\nFor these cases you can modify the class that is used when `many=True` is passed, by using the `list_serializer_class` option on the serializer `Meta` class.\n\nFor example:\n\n``` python\nclass CustomListSerializer(serializers.ListSerializer):\n    ...\n\nclass CustomSerializer(serializers.Serializer):\n    ...\n    class Meta:\n        list_serializer_class = CustomListSerializer\n```\n\n#### Customizing multiple create\n\nThe default implementation for multiple object creation is to simply call `.create()` for each item in the list. If you want to customize this behavior, you'll need to customize the `.create()` method on `ListSerializer` class that is used when `many=True` is passed.\n\nFor example:\n\n``` python\nclass BookListSerializer(serializers.ListSerializer):\n    def create(self, validated_data):\n        books = [Book(**item) for item in validated_data]\n        return Book.objects.bulk_create(books)\n\nclass BookSerializer(serializers.Serializer):\n    ...\n    class Meta:\n        list_serializer_class = BookListSerializer\n```\n\n#### Customizing multiple update\n\nBy default the `ListSerializer` class does not support multiple updates. This is because the behavior that should be expected for insertions and deletions is ambiguous.\n\nTo support multiple updates you'll need to do so explicitly. When writing your multiple update code make sure to keep the following in mind:\n\n- How do you determine which instance should be updated for each item in the list of data?\n- How should insertions be handled? Are they invalid, or do they create new objects?\n- How should removals be handled? Do they imply object deletion, or removing a relationship? Should they be silently ignored, or are they invalid?\n- How should ordering be handled? Does changing the position of two items imply any state change or is it ignored?\n\nYou will need to add an explicit `id` field to the instance serializer. The default implicitly-generated `id` field is marked as `read_only`. This causes it to be removed on updates. Once you declare it explicitly, it will be available in the list serializer's `update` method.\n\nHere's an example of how you might choose to implement multiple updates:\n\n``` python\nclass BookListSerializer(serializers.ListSerializer):\n    def update(self, instance, validated_data):\n        # Maps for id->instance and id->data item.\n        book_mapping = {book.id: book for book in instance}\n        data_mapping = {item['id']: item for item in validated_data}\n\n        # Perform creations and updates.\n        ret = []\n        for book_id, data in data_mapping.items():\n            book = book_mapping.get(book_id, None)\n            if book is None:\n                ret.append(self.child.create(data))\n            else:\n                ret.append(self.child.update(book, data))\n\n        # Perform deletions.\n        for book_id, book in book_mapping.items():\n            if book_id not in data_mapping:\n                book.delete()\n\n        return ret\n\nclass BookSerializer(serializers.Serializer):\n    # We need to identify elements in the list using their primary key,\n    # so use a writable field here, rather than the default which would be read-only.\n    id = serializers.IntegerField()\n    ...\n\n    class Meta:\n        list_serializer_class = BookListSerializer\n```\n\n#### Customizing ListSerializer initialization\n\nWhen a serializer with `many=True` is instantiated, we need to determine which arguments and keyword arguments should be passed to the `.__init__()` method for both the child `Serializer` class, and for the parent `ListSerializer` class.\n\nThe default implementation is to pass all arguments to both classes, except for `validators`, and any custom keyword arguments, both of which are assumed to be intended for the child serializer class.\n\nOccasionally you might need to explicitly specify how the child and parent classes should be instantiated when `many=True` is passed. You can do so by using the `many_init` class method.\n\n``` python\n    @classmethod\n    def many_init(cls, *args, **kwargs):\n        # Instantiate the child serializer.\n        kwargs['child'] = cls()\n        # Instantiate the parent list serializer.\n        return CustomListSerializer(*args, **kwargs)\n```\n\n# BaseSerializer\n\n`BaseSerializer` class that can be used to easily support alternative serialization and deserialization styles.\n\nThis class implements the same basic API as the `Serializer` class:\n\n- `.data` - Returns the outgoing primitive representation.\n- `.is_valid()` - Deserializes and validates incoming data.\n- `.validated_data` - Returns the validated incoming data.\n- `.errors` - Returns any errors during validation.\n- `.save()` - Persists the validated data into an object instance.\n\nThere are four methods that can be overridden, depending on what functionality you want the serializer class to support:\n\n- `.to_representation()` - Override this to support serialization, for read operations.\n- `.to_internal_value()` - Override this to support deserialization, for write operations.\n- `.create()` and `.update()` - Override either or both of these to support saving instances.\n\nBecause this class provides the same interface as the `Serializer` class, you can use it with the existing generic class-based views exactly as you would for a regular `Serializer` or `ModelSerializer`.\n\nThe only difference you'll notice when doing so is the `BaseSerializer` classes will not generate HTML forms in the browsable API. This is because the data they return does not include all the field information that would allow each field to be rendered into a suitable HTML input.\n\n#### Read-only BaseSerializer classes\n\nTo implement a read-only serializer using the `BaseSerializer` class, we just need to override the `.to_representation()` method. Let's take a look at an example using a simple Django model:\n\n``` python\nclass HighScore(models.Model):\n    created = models.DateTimeField(auto_now_add=True)\n    player_name = models.CharField(max_length=10)\n    score = models.IntegerField()\n```\n\nIt's simple to create a read-only serializer for converting `HighScore` instances into primitive data types.\n\n``` python\nclass HighScoreSerializer(serializers.BaseSerializer):\n    def to_representation(self, instance):\n        return {\n            'score': instance.score,\n            'player_name': instance.player_name\n        }\n```\n\nWe can now use this class to serialize single `HighScore` instances:\n\n``` python\n@api_view(['GET'])\ndef high_score(request, pk):\n    instance = HighScore.objects.get(pk=pk)\n    serializer = HighScoreSerializer(instance)\n    return Response(serializer.data)\n```\n\nOr use it to serialize multiple instances:\n\n``` python\n@api_view(['GET'])\ndef all_high_scores(request):\n    queryset = HighScore.objects.order_by('-score')\n    serializer = HighScoreSerializer(queryset, many=True)\n    return Response(serializer.data)\n```\n\n#### Read-write BaseSerializer classes\n\nTo create a read-write serializer we first need to implement a `.to_internal_value()` method. This method returns the validated values that will be used to construct the object instance, and may raise a `serializers.ValidationError` if the supplied data is in an incorrect format.\n\nOnce you've implemented `.to_internal_value()`, the basic validation API will be available on the serializer, and you will be able to use `.is_valid()`, `.validated_data` and `.errors`.\n\nIf you want to also support `.save()` you'll need to also implement either or both of the `.create()` and `.update()` methods.\n\nHere's a complete example of our previous `HighScoreSerializer`, that's been updated to support both read and write operations.\n\n``` python\nclass HighScoreSerializer(serializers.BaseSerializer):\n    def to_internal_value(self, data):\n        score = data.get('score')\n        player_name = data.get('player_name')\n\n        # Perform the data validation.\n        if not score:\n            raise serializers.ValidationError({\n                'score': 'This field is required.'\n            })\n        if not player_name:\n            raise serializers.ValidationError({\n                'player_name': 'This field is required.'\n            })\n        if len(player_name) > 10:\n            raise serializers.ValidationError({\n                'player_name': 'May not be more than 10 characters.'\n            })\n\n        # Return the validated values. This will be available as\n        # the `.validated_data` property.\n        return {\n            'score': int(score),\n            'player_name': player_name\n        }\n\n    def to_representation(self, instance):\n        return {\n            'score': instance.score,\n            'player_name': instance.player_name\n        }\n\n    def create(self, validated_data):\n        return HighScore.objects.create(**validated_data)\n```\n\n#### Creating new base classes\n\nThe `BaseSerializer` class is also useful if you want to implement new generic serializer classes for dealing with particular serialization styles, or for integrating with alternative storage backends.\n\nThe following class is an example of a generic serializer that can handle coercing arbitrary complex objects into primitive representations.\n\n``` python\nclass ObjectSerializer(serializers.BaseSerializer):\n    \"\"\"\n    A read-only serializer that coerces arbitrary complex objects\n    into primitive representations.\n    \"\"\"\n    def to_representation(self, instance):\n        output = {}\n        for attribute_name in dir(instance):\n            attribute = getattr(instance, attribute_name)\n            if attribute_name.startswith('_'):\n                # Ignore private attributes.\n                pass\n            elif hasattr(attribute, '__call__'):\n                # Ignore methods and other callables.\n                pass\n            elif isinstance(attribute, (str, int, bool, float, type(None))):\n                # Primitive types can be passed through unmodified.\n                output[attribute_name] = attribute\n            elif isinstance(attribute, list):\n                # Recursively deal with items in lists.\n                output[attribute_name] = [\n                    self.to_representation(item) for item in attribute\n                ]\n            elif isinstance(attribute, dict):\n                # Recursively deal with items in dictionaries.\n                output[attribute_name] = {\n                    str(key): self.to_representation(value)\n                    for key, value in attribute.items()\n                }\n            else:\n                # Force anything else to its string representation.\n                output[attribute_name] = str(attribute)\n        return output\n```\n\n# Advanced serializer usage\n\n## Overriding serialization and deserialization behavior\n\nIf you need to alter the serialization or deserialization behavior of a serializer class, you can do so by overriding the `.to_representation()` or `.to_internal_value()` methods.\n\nSome reasons this might be useful include...\n\n- Adding new behavior for new serializer base classes.\n- Modifying the behavior slightly for an existing class.\n- Improving serialization performance for a frequently accessed API endpoint that returns lots of data.\n\nThe signatures for these methods are as follows:\n\n#### to_representation(self, instance)\n\nTakes the object instance that requires serialization, and should return a primitive representation. Typically this means returning a structure of built-in Python datatypes. The exact types that can be handled will depend on the render classes you have configured for your API.\n\nMay be overridden in order to modify the representation style. For example:\n\n``` python\ndef to_representation(self, instance):\n    \"\"\"Convert `username` to lowercase.\"\"\"\n    ret = super().to_representation(instance)\n    ret['username'] = ret['username'].lower()\n    return ret\n```\n\n#### to_internal_value(self, data)\n\nTakes the unvalidated incoming data as input and should return the validated data that will be made available as `serializer.validated_data`. The return value will also be passed to the `.create()` or `.update()` methods if `.save()` is called on the serializer class.\n\nIf any of the validation fails, then the method should raise a `serializers.ValidationError(errors)`. The `errors` argument should be a dictionary mapping field names (or `settings.NON_FIELD_ERRORS_KEY`) to a list of error messages. If you don't need to alter deserialization behavior and instead want to provide object-level validation, it's recommended that you instead override the [`.validate()`](#object-level-validation) method.\n\nThe `data` argument passed to this method will normally be the value of `request.data`, so the datatype it provides will depend on the parser classes you have configured for your API.\n\n## Serializer Inheritance\n\nSimilar to Django forms, you can extend and reuse serializers through inheritance. This allows you to declare a common set of fields or methods on a parent class that can then be used in a number of serializers. For example,\n\n``` python\nclass MyBaseSerializer(Serializer):\n    my_field = serializers.CharField()\n\n    def validate_my_field(self, value):\n        ...\n\nclass MySerializer(MyBaseSerializer):\n    ...\n```\n\nLike Django's `Model` and `ModelForm` classes, the inner `Meta` class on serializers does not implicitly inherit from it's parents' inner `Meta` classes. If you want the `Meta` class to inherit from a parent class you must do so explicitly. For example:\n\n``` python\nclass AccountSerializer(MyBaseSerializer):\n    class Meta(MyBaseSerializer.Meta):\n        model = Account\n```\n\nTypically we would recommend *not* using inheritance on inner Meta classes, but instead declaring all options explicitly.\n\nAdditionally, the following caveats apply to serializer inheritance:\n\n- Normal Python name resolution rules apply. If you have multiple base classes that declare a `Meta` inner class, only the first one will be used. This means the child’s `Meta`, if it exists, otherwise the `Meta` of the first parent, etc.\n\n- It’s possible to declaratively remove a `Field` inherited from a parent class by setting the name to be `None` on the subclass.\n\n  ``` python\n  class MyBaseSerializer(ModelSerializer):\n      my_field = serializers.CharField()\n\n  class MySerializer(MyBaseSerializer):\n      my_field = None\n  ```\n\n  However, you can only use this technique to opt out from a field defined declaratively by a parent class; it won’t prevent the `ModelSerializer` from generating a default field. To opt-out from default fields, see [Specifying which fields to include](#specifying-which-fields-to-include).\n\n## Dynamically modifying fields\n\nOnce a serializer has been initialized, the dictionary of fields that are set on the serializer may be accessed using the `.fields` attribute. Accessing and modifying this attribute allows you to dynamically modify the serializer.\n\nModifying the `fields` argument directly allows you to do interesting things such as changing the arguments on serializer fields at runtime, rather than at the point of declaring the serializer.\n\n### Example\n\nFor example, if you wanted to be able to set which fields should be used by a serializer at the point of initializing it, you could create a serializer class like so:\n\n``` python\nclass DynamicFieldsModelSerializer(serializers.ModelSerializer):\n    \"\"\"\n    A ModelSerializer that takes an additional `fields` argument that\n    controls which fields should be displayed.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # Don't pass the 'fields' arg up to the superclass\n        fields = kwargs.pop('fields', None)\n\n        # Instantiate the superclass normally\n        super().__init__(*args, **kwargs)\n\n        if fields is not None:\n            # Drop any fields that are not specified in the `fields` argument.\n            allowed = set(fields)\n            existing = set(self.fields)\n            for field_name in existing - allowed:\n                self.fields.pop(field_name)\n```\n\nThis would then allow you to do the following:\n\n``` python\n>>> class UserSerializer(DynamicFieldsModelSerializer):\n>>>     class Meta:\n>>>         model = User\n>>>         fields = ['id', 'username', 'email']\n>>>\n>>> print(UserSerializer(user))\n{'id': 2, 'username': 'jonwatts', 'email': 'jon@example.com'}\n>>>\n>>> print(UserSerializer(user, fields=('id', 'email')))\n{'id': 2, 'email': 'jon@example.com'}\n```\n\n## Customizing the default fields\n\nREST framework 2 provided an API to allow developers to override how a `ModelSerializer` class would automatically generate the default set of fields.\n\nThis API included the `.get_field()`, `.get_pk_field()` and other methods.\n\nBecause the serializers have been fundamentally redesigned with 3.0 this API no longer exists. You can still modify the fields that get created but you'll need to refer to the source code, and be aware that if the changes you make are against private bits of API then they may be subject to change.\n\n# Third party packages\n\nThe following third party packages are also available.\n\n## Django REST marshmallow\n\nThe [django-rest-marshmallow](https://marshmallow-code.github.io/django-rest-marshmallow/) package provides an alternative implementation for serializers, using the python [marshmallow](https://marshmallow.readthedocs.io/en/latest/) library. It exposes the same API as the REST framework serializers, and can be used as a drop-in replacement in some use-cases.\n\n## Serpy\n\nThe [serpy](https://github.com/clarkduvall/serpy) package is an alternative implementation for serializers that is built for speed. [Serpy](https://github.com/clarkduvall/serpy) serializes complex datatypes to simple native types. The native types can be easily converted to JSON or any other format needed.\n\n## MongoengineModelSerializer\n\nThe [django-rest-framework-mongoengine](https://github.com/umutbozkurt/django-rest-framework-mongoengine) package provides a `MongoEngineModelSerializer` serializer class that supports using MongoDB as the storage layer for Django REST framework.\n\n## GeoFeatureModelSerializer\n\nThe [django-rest-framework-gis](https://github.com/djangonauts/django-rest-framework-gis) package provides a `GeoFeatureModelSerializer` serializer class that supports GeoJSON both for read and write operations.\n\n## HStoreSerializer\n\nThe [django-rest-framework-hstore](https://github.com/djangonauts/django-rest-framework-hstore) package provides an `HStoreSerializer` to support [django-hstore](https://github.com/djangonauts/django-hstore) `DictionaryField` model field and its `schema-mode` feature.\n\n## Dynamic REST\n\nThe [dynamic-rest](https://github.com/AltSchool/dynamic-rest) package extends the ModelSerializer and ModelViewSet interfaces, adding API query parameters for filtering, sorting, and including / excluding all fields and relationships defined by your serializers.\n\n## Dynamic Fields Mixin\n\nThe [drf-dynamic-fields](https://github.com/dbrgn/drf-dynamic-fields) package provides a mixin to dynamically limit the fields per serializer to a subset specified by an URL parameter.\n\n## DRF FlexFields\n\nThe [drf-flex-fields](https://github.com/rsinger86/drf-flex-fields) package extends the ModelSerializer and ModelViewSet to provide commonly used functionality for dynamically setting fields and expanding primitive fields to nested models, both from URL parameters and your serializer class definitions.\n\n## Serializer Extensions\n\nThe [django-rest-framework-serializer-extensions](https://github.com/evenicoulddoit/django-rest-framework-serializer-extensions) package provides a collection of tools to DRY up your serializers, by allowing fields to be defined on a per-view/request basis. Fields can be whitelisted, blacklisted and child serializers can be optionally expanded.\n\n## HTML JSON Forms\n\nThe [html-json-forms](https://github.com/wq/html-json-forms) package provides an algorithm and serializer for processing `<form>` submissions per the (inactive) [HTML JSON Form specification](https://www.w3.org/TR/html-json-forms/). The serializer facilitates processing of arbitrarily nested JSON structures within HTML. For example, `<input name=\"items[0][id]\" value=\"5\">` will be interpreted as `{\"items\": [{\"id\": \"5\"}]}`.\n\n## DRF-Base64\n\n[DRF-Base64](https://bitbucket.org/levit_scs/drf_base64) provides a set of field and model serializers that handles the upload of base64-encoded files.\n\n## QueryFields\n\n[djangorestframework-queryfields](https://djangorestframework-queryfields.readthedocs.io/) allows API clients to specify which fields will be sent in the response via inclusion/exclusion query parameters.\n\n## DRF Writable Nested\n\nThe [drf-writable-nested](https://github.com/beda-software/drf-writable-nested) package provides writable nested model serializer which allows to create/update models with nested related data.\n\n## DRF Encrypt Content\n\nThe [drf-encrypt-content](https://github.com/oguzhancelikarslan/drf-encrypt-content) package helps you encrypt your data, serialized through ModelSerializer. It also contains some helper functions. Which helps you to encrypt your data.\n\n[serializers.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/serializers.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/serializers/](https://www.django-rest-framework.org/api-guide/serializers/)"
- name: SessionAuthentication
  id: api-guide/authentication/index#sessionauthentication
  summary: This authentication scheme uses Django's default session backend for authentication
  belongs_to: Authentication
  description: |-
    ## SessionAuthentication

    This authentication scheme uses Django's default session backend for authentication. Session authentication is appropriate for AJAX clients that are running in the same session context as your website.

    If successfully authenticated, `SessionAuthentication` provides the following credentials.

    - `request.user` will be a Django `User` instance.
    - `request.auth` will be `None`.

    Unauthenticated responses that are denied permission will result in an `HTTP 403 Forbidden` response.

    If you're using an AJAX-style API with SessionAuthentication, you'll need to make sure you include a valid CSRF token for any "unsafe" HTTP method calls, such as `PUT`, `PATCH`, `POST` or `DELETE` requests. See the [Django CSRF documentation](https://docs.djangoproject.com/en/stable/howto/csrf/#using-csrf-protection-with-ajax) for more details.

    **Warning**: Always use Django's standard login view when creating login pages. This will ensure your login views are properly protected.

    CSRF validation in REST framework works slightly differently from standard Django due to the need to support both session and non-session based authentication to the same views. This means that only authenticated requests require CSRF tokens, and anonymous requests may be sent without CSRF tokens. This behavior is not suitable for login views, which should always have CSRF validation applied.
- name: Settings
  id: api-guide/settings/index
  summary: Configuration for REST framework is all namespaced inside a single Django setting, named REST_FRAMEWORK
  description: "# Settings\n\n> Namespaces are one honking great idea - let's do more of those!\n>\n> — [The Zen of Python](https://www.python.org/dev/peps/pep-0020/)\n\nConfiguration for REST framework is all namespaced inside a single Django setting, named `REST_FRAMEWORK`.\n\nFor example your project's `settings.py` file might include something like this:\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_RENDERER_CLASSES': [\n        'rest_framework.renderers.JSONRenderer',\n    ],\n    'DEFAULT_PARSER_CLASSES': [\n        'rest_framework.parsers.JSONParser',\n    ]\n}\n```\n\n## Accessing settings\n\nIf you need to access the values of REST framework's API settings in your project, you should use the `api_settings` object. For example.\n\n``` python\nfrom rest_framework.settings import api_settings\n\nprint(api_settings.DEFAULT_AUTHENTICATION_CLASSES)\n```\n\nThe `api_settings` object will check for any user-defined settings, and otherwise fall back to the default values. Any setting that uses string import paths to refer to a class will automatically import and return the referenced class, instead of the string literal.\n\n# API Reference\n\n## API policy settings\n\n*The following settings control the basic API policies, and are applied to every `APIView` class-based view, or `@api_view` function based view.*\n\n#### DEFAULT_RENDERER_CLASSES\n\nA list or tuple of renderer classes, that determines the default set of renderers that may be used when returning a `Response` object.\n\nDefault:\n\n``` python\n[\n    'rest_framework.renderers.JSONRenderer',\n    'rest_framework.renderers.BrowsableAPIRenderer',\n]\n```\n\n#### DEFAULT_PARSER_CLASSES\n\nA list or tuple of parser classes, that determines the default set of parsers used when accessing the `request.data` property.\n\nDefault:\n\n``` python\n[\n    'rest_framework.parsers.JSONParser',\n    'rest_framework.parsers.FormParser',\n    'rest_framework.parsers.MultiPartParser'\n]\n```\n\n#### DEFAULT_AUTHENTICATION_CLASSES\n\nA list or tuple of authentication classes, that determines the default set of authenticators used when accessing the `request.user` or `request.auth` properties.\n\nDefault:\n\n``` python\n[\n    'rest_framework.authentication.SessionAuthentication',\n    'rest_framework.authentication.BasicAuthentication'\n]\n```\n\n#### DEFAULT_PERMISSION_CLASSES\n\nA list or tuple of permission classes, that determines the default set of permissions checked at the start of a view. Permission must be granted by every class in the list.\n\nDefault:\n\n``` python\n[\n    'rest_framework.permissions.AllowAny',\n]\n```\n\n#### DEFAULT_THROTTLE_CLASSES\n\nA list or tuple of throttle classes, that determines the default set of throttles checked at the start of a view.\n\nDefault: `[]`\n\n#### DEFAULT_CONTENT_NEGOTIATION_CLASS\n\nA content negotiation class, that determines how a renderer is selected for the response, given an incoming request.\n\nDefault: `'rest_framework.negotiation.DefaultContentNegotiation'`\n\n#### DEFAULT_SCHEMA_CLASS\n\nA view inspector class that will be used for schema generation.\n\nDefault: `'rest_framework.schemas.openapi.AutoSchema'`\n\n## Generic view settings\n\n*The following settings control the behavior of the generic class-based views.*\n\n#### DEFAULT_FILTER_BACKENDS\n\nA list of filter backend classes that should be used for generic filtering. If set to `None` then generic filtering is disabled.\n\n#### DEFAULT_PAGINATION_CLASS\n\nThe default class to use for queryset pagination. If set to `None`, pagination is disabled by default. See the pagination documentation for further guidance on [setting](../pagination/index#setting-the-pagination-style) and [modifying](../pagination/index#modifying-the-pagination-style) the pagination style.\n\nDefault: `None`\n\n#### PAGE_SIZE\n\nThe default page size to use for pagination. If set to `None`, pagination is disabled by default.\n\nDefault: `None`\n\n### SEARCH_PARAM\n\nThe name of a query parameter, which can be used to specify the search term used by `SearchFilter`.\n\nDefault: `search`\n\n#### ORDERING_PARAM\n\nThe name of a query parameter, which can be used to specify the ordering of results returned by `OrderingFilter`.\n\nDefault: `ordering`\n\n## Versioning settings\n\n#### DEFAULT_VERSION\n\nThe value that should be used for `request.version` when no versioning information is present.\n\nDefault: `None`\n\n#### ALLOWED_VERSIONS\n\nIf set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.\n\nDefault: `None`\n\n#### VERSION_PARAM\n\nThe string that should used for any versioning parameters, such as in the media type or URL query parameters.\n\nDefault: `'version'`\n\n#### DEFAULT_VERSIONING_CLASS\n\nThe default versioning scheme to use.\n\nDefault: `None`\n\n## Authentication settings\n\n*The following settings control the behavior of unauthenticated requests.*\n\n#### UNAUTHENTICATED_USER\n\nThe class that should be used to initialize `request.user` for unauthenticated requests. (If removing authentication entirely, e.g. by removing `django.contrib.auth` from `INSTALLED_APPS`, set `UNAUTHENTICATED_USER` to `None`.)\n\nDefault: `django.contrib.auth.models.AnonymousUser`\n\n#### UNAUTHENTICATED_TOKEN\n\nThe class that should be used to initialize `request.auth` for unauthenticated requests.\n\nDefault: `None`\n\n## Test settings\n\n*The following settings control the behavior of APIRequestFactory and APIClient*\n\n#### TEST_REQUEST_DEFAULT_FORMAT\n\nThe default format that should be used when making test requests.\n\nThis should match up with the format of one of the renderer classes in the `TEST_REQUEST_RENDERER_CLASSES` setting.\n\nDefault: `'multipart'`\n\n#### TEST_REQUEST_RENDERER_CLASSES\n\nThe renderer classes that are supported when building test requests.\n\nThe format of any of these renderer classes may be used when constructing a test request, for example: `client.post('/users', {'username': 'jamie'}, format='json')`\n\nDefault:\n\n``` python\n[\n    'rest_framework.renderers.MultiPartRenderer',\n    'rest_framework.renderers.JSONRenderer'\n]\n```\n\n## Schema generation controls\n\n#### SCHEMA_COERCE_PATH_PK\n\nIf set, this maps the `'pk'` identifier in the URL conf onto the actual field name when generating a schema path parameter. Typically this will be `'id'`. This gives a more suitable representation as \"primary key\" is an implementation detail, whereas \"identifier\" is a more general concept.\n\nDefault: `True`\n\n#### SCHEMA_COERCE_METHOD_NAMES\n\nIf set, this is used to map internal viewset method names onto external action names used in the schema generation. This allows us to generate names that are more suitable for an external representation than those that are used internally in the codebase.\n\nDefault: `{'retrieve': 'read', 'destroy': 'delete'}`\n\n## Content type controls\n\n#### URL_FORMAT_OVERRIDE\n\nThe name of a URL parameter that may be used to override the default content negotiation `Accept` header behavior, by using a `format=…` query parameter in the request URL.\n\nFor example: `http://example.com/organizations/?format=csv`\n\nIf the value of this setting is `None` then URL format overrides will be disabled.\n\nDefault: `'format'`\n\n#### FORMAT_SUFFIX_KWARG\n\nThe name of a parameter in the URL conf that may be used to provide a format suffix. This setting is applied when using `format_suffix_patterns` to include suffixed URL patterns.\n\nFor example: `http://example.com/organizations.csv/`\n\nDefault: `'format'`\n\n## Date and time formatting\n\n*The following settings are used to control how date and time representations may be parsed and rendered.*\n\n#### DATETIME_FORMAT\n\nA format string that should be used by default for rendering the output of `DateTimeField` serializer fields. If `None`, then `DateTimeField` serializer fields will return Python `datetime` objects, and the datetime encoding will be determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) string.\n\nDefault: `'iso-8601'`\n\n#### DATETIME_INPUT_FORMATS\n\nA list of format strings that should be used by default for parsing inputs to `DateTimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) strings.\n\nDefault: `['iso-8601']`\n\n#### DATE_FORMAT\n\nA format string that should be used by default for rendering the output of `DateField` serializer fields. If `None`, then `DateField` serializer fields will return Python `date` objects, and the date encoding will be determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) string.\n\nDefault: `'iso-8601'`\n\n#### DATE_INPUT_FORMATS\n\nA list of format strings that should be used by default for parsing inputs to `DateField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) strings.\n\nDefault: `['iso-8601']`\n\n#### TIME_FORMAT\n\nA format string that should be used by default for rendering the output of `TimeField` serializer fields. If `None`, then `TimeField` serializer fields will return Python `time` objects, and the time encoding will be determined by the renderer.\n\nMay be any of `None`, `'iso-8601'` or a Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) string.\n\nDefault: `'iso-8601'`\n\n#### TIME_INPUT_FORMATS\n\nA list of format strings that should be used by default for parsing inputs to `TimeField` serializer fields.\n\nMay be a list including the string `'iso-8601'` or Python [strftime format](https://docs.python.org/3/library/time.html#time.strftime) strings.\n\nDefault: `['iso-8601']`\n\n## Encodings\n\n#### UNICODE_JSON\n\nWhen set to `True`, JSON responses will allow unicode characters in responses. For example:\n\n``` python\n{\"unicode black star\":\"★\"}\n```\n\nWhen set to `False`, JSON responses will escape non-ascii characters, like so:\n\n``` python\n{\"unicode black star\":\"\\u2605\"}\n```\n\nBoth styles conform to [RFC 4627](https://www.ietf.org/rfc/rfc4627.txt), and are syntactically valid JSON. The unicode style is preferred as being more user-friendly when inspecting API responses.\n\nDefault: `True`\n\n#### COMPACT_JSON\n\nWhen set to `True`, JSON responses will return compact representations, with no spacing after `':'` and `','` characters. For example:\n\n``` python\n{\"is_admin\":false,\"email\":\"jane@example\"}\n```\n\nWhen set to `False`, JSON responses will return slightly more verbose representations, like so:\n\n``` python\n{\"is_admin\": false, \"email\": \"jane@example\"}\n```\n\nThe default style is to return minified responses, in line with [Heroku's API design guidelines](https://github.com/interagent/http-api-design#keep-json-minified-in-all-responses).\n\nDefault: `True`\n\n#### STRICT_JSON\n\nWhen set to `True`, JSON rendering and parsing will only observe syntactically valid JSON, raising an exception for the extended float values (`nan`, `inf`, `-inf`) accepted by Python's `json` module. This is the recommended setting, as these values are not generally supported. e.g., neither Javascript's `JSON.Parse` nor PostgreSQL's JSON data type accept these values.\n\nWhen set to `False`, JSON rendering and parsing will be permissive. However, these values are still invalid and will need to be specially handled in your code.\n\nDefault: `True`\n\n#### COERCE_DECIMAL_TO_STRING\n\nWhen returning decimal objects in API representations that do not support a native decimal type, it is normally best to return the value as a string. This avoids the loss of precision that occurs with binary floating point implementations.\n\nWhen set to `True`, the serializer `DecimalField` class will return strings instead of `Decimal` objects. When set to `False`, serializers will return `Decimal` objects, which the default JSON encoder will return as floats.\n\nDefault: `True`\n\n## View names and descriptions\n\n**The following settings are used to generate the view names and descriptions, as used in responses to `OPTIONS` requests, and as used in the browsable API.**\n\n#### VIEW_NAME_FUNCTION\n\nA string representing the function that should be used when generating view names.\n\nThis should be a function with the following signature:\n\n``` python\nview_name(self)\n```\n\n- `self`: The view instance. Typically the name function would inspect the name of the class when generating a descriptive name, by accessing `self.__class__.__name__`.\n\nIf the view instance inherits `ViewSet`, it may have been initialized with several optional arguments:\n\n- `name`: A name explicitly provided to a view in the viewset. Typically, this value should be used as-is when provided.\n- `suffix`: Text used when differentiating individual views in a viewset. This argument is mutually exclusive to `name`.\n- `detail`: Boolean that differentiates an individual view in a viewset as either being a 'list' or 'detail' view.\n\nDefault: `'rest_framework.views.get_view_name'`\n\n#### VIEW_DESCRIPTION_FUNCTION\n\nA string representing the function that should be used when generating view descriptions.\n\nThis setting can be changed to support markup styles other than the default markdown. For example, you can use it to support `rst` markup in your view docstrings being output in the browsable API.\n\nThis should be a function with the following signature:\n\n``` python\nview_description(self, html=False)\n```\n\n- `self`: The view instance. Typically the description function would inspect the docstring of the class when generating a description, by accessing `self.__class__.__doc__`\n- `html`: A boolean indicating if HTML output is required. `True` when used in the browsable API, and `False` when used in generating `OPTIONS` responses.\n\nIf the view instance inherits `ViewSet`, it may have been initialized with several optional arguments:\n\n- `description`: A description explicitly provided to the view in the viewset. Typically, this is set by extra viewset `action`s, and should be used as-is.\n\nDefault: `'rest_framework.views.get_view_description'`\n\n## HTML Select Field cutoffs\n\nGlobal settings for [select field cutoffs for rendering relational fields](../relations/index#select-field-cutoffs) in the browsable API.\n\n#### HTML_SELECT_CUTOFF\n\nGlobal setting for the `html_cutoff` value. Must be an integer.\n\nDefault: 1000\n\n#### HTML_SELECT_CUTOFF_TEXT\n\nA string representing a global setting for `html_cutoff_text`.\n\nDefault: `\"More than {count} items...\"`\n\n## Miscellaneous settings\n\n#### EXCEPTION_HANDLER\n\nA string representing the function that should be used when returning a response for any given exception. If the function returns `None`, a 500 error will be raised.\n\nThis setting can be changed to support error responses other than the default `{\"detail\": \"Failure...\"}` responses. For example, you can use it to provide API responses like `{\"errors\": [{\"message\": \"Failure...\", \"code\": \"\"} ...]}`.\n\nThis should be a function with the following signature:\n\n``` python\nexception_handler(exc, context)\n```\n\n- `exc`: The exception.\n\nDefault: `'rest_framework.views.exception_handler'`\n\n#### NON_FIELD_ERRORS_KEY\n\nA string representing the key that should be used for serializer errors that do not refer to a specific field, but are instead general errors.\n\nDefault: `'non_field_errors'`\n\n#### URL_FIELD_NAME\n\nA string representing the key that should be used for the URL fields generated by `HyperlinkedModelSerializer`.\n\nDefault: `'url'`\n\n#### NUM_PROXIES\n\nAn integer of 0 or more, that may be used to specify the number of application proxies that the API runs behind. This allows throttling to more accurately identify client IP addresses. If set to `None` then less strict IP matching will be used by the throttle classes.\n\nDefault: `None`\n\n[settings.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/settings.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/settings/](https://www.django-rest-framework.org/api-guide/settings/)"
- name: SimpleRouter
  id: api-guide/routers/index#simplerouter
  summary: This router includes routes for the standard set of list, create, retrieve, update, partial_update and destroy actions
  belongs_to: Routers
  description: |-
    ## SimpleRouter

    This router includes routes for the standard set of `list`, `create`, `retrieve`, `update`, `partial_update` and `destroy` actions. The viewset can also mark additional methods to be routed, using the `@action` decorator.

    |                               |                                              |                                            |                       |
    |-------------------------------|----------------------------------------------|--------------------------------------------|-----------------------|
    | URL Style                     | HTTP Method                                  | Action                                     | URL Name              |
    | {prefix}/                     | GET                                          | list                                       | {basename}-list       |
    |                               | POST                                         | create                                     |                       |
    | {prefix}/{url_path}/          | GET, or as specified by \`methods\` argument | \`@action(detail=False)\` decorated method | {basename}-{url_name} |
    | {prefix}/{lookup}/            | GET                                          | retrieve                                   | {basename}-detail     |
    |                               | PUT                                          | update                                     |                       |
    |                               | PATCH                                        | partial_update                             |                       |
    |                               | DELETE                                       | destroy                                    |                       |
    | {prefix}/{lookup}/{url_path}/ | GET, or as specified by \`methods\` argument | \`@action(detail=True)\` decorated method  | {basename}-{url_name} |

    By default the URLs created by `SimpleRouter` are appended with a trailing slash. This behavior can be modified by setting the `trailing_slash` argument to `False` when instantiating the router. For example:

    ``` python
    router = SimpleRouter(trailing_slash=False)
    ```

    Trailing slashes are conventional in Django, but are not used by default in some other frameworks such as Rails. Which style you choose to use is largely a matter of preference, although some javascript frameworks may expect a particular routing style.

    By default the URLs created by `SimpleRouter` use regular expressions. This behavior can be modified by setting the `use_regex_path` argument to `False` when instantiating the router, in this case [path converters](https://docs.djangoproject.com/en/2.0/topics/http/urls/#path-converters) are used. For example:

    ``` python
    router = SimpleRouter(use_regex_path=False)
    ```

    **Note**: `use_regex_path=False` only works with Django 2.x or above, since this feature was introduced in 2.0.0. See [release note](https://docs.djangoproject.com/en/2.0/releases/2.0/#simplified-url-routing-syntax)

    The router will match lookup values containing any characters except slashes and period characters. For a more restrictive (or lenient) lookup pattern, set the `lookup_value_regex` attribute on the viewset or `lookup_value_converter` if using path converters. For example, you can limit the lookup to valid UUIDs:

    ``` python
    class MyModelViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet):
        lookup_field = 'my_model_id'
        lookup_value_regex = '[0-9a-f]{32}'

    class MyPathModelViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet):
        lookup_field = 'my_model_uuid'
        lookup_value_converter = 'uuid'
    ```
- name: SlugField
  id: api-guide/fields/index#slugfield
  summary: Corresponds to django.db.models.fields.SlugField
  belongs_to: Serializer fields
  description: |-
    ## SlugField

    A `RegexField` that validates the input against the pattern `[a-zA-Z0-9_-]+`.

    Corresponds to `django.db.models.fields.SlugField`.

    **Signature:** `SlugField(max_length=50, min_length=None, allow_blank=False)`
- name: SlugRelatedField
  id: api-guide/relations/index#slugrelatedfield
  summary: SlugRelatedField may be used to represent the target of the relationship using a field on the target
  belongs_to: Serializer relations
  description: |-
    ## SlugRelatedField

    `SlugRelatedField` may be used to represent the target of the relationship using a field on the target.

    For example, the following serializer:

    ``` python
    class AlbumSerializer(serializers.ModelSerializer):
        tracks = serializers.SlugRelatedField(
            many=True,
            read_only=True,
            slug_field='title'
         )

        class Meta:
            model = Album
            fields = ['album_name', 'artist', 'tracks']
    ```

    Would serialize to a representation like this:

    ``` python
    {
        'album_name': 'Dear John',
        'artist': 'Loney Dear',
        'tracks': [
            'Airport Surroundings',
            'Everything Turns to You',
            'I Was Only Going Out',
            ...
        ]
    }
    ```

    By default this field is read-write, although you can change this behavior using the `read_only` flag.

    When using `SlugRelatedField` as a read-write field, you will normally want to ensure that the slug field corresponds to a model field with `unique=True`.

    **Arguments**:

    - `slug_field` - The field on the target that should be used to represent it. This should be a field that uniquely identifies any given instance. For example, `username`. **required**
    - `queryset` - The queryset used for model instance lookups when validating the field input. Relationships must either set a queryset explicitly, or set `read_only=True`.
    - `many` - If applied to a to-many relationship, you should set this argument to `True`.
    - `allow_null` - If set to `True`, the field will accept values of `None` or the empty string for nullable relationships. Defaults to `False`.

    &nbsp;
- name: StaticHTMLRenderer
  id: api-guide/renderers/index#statichtmlrenderer
  summary: A simple renderer that simply returns pre-rendered HTML
  belongs_to: Renderers
  description: |-
    ## StaticHTMLRenderer

    A simple renderer that simply returns pre-rendered HTML. Unlike other renderers, the data passed to the response object should be a string representing the content to be returned.

    An example of a view that uses `StaticHTMLRenderer`:

    ``` python
    @api_view(['GET'])
    @renderer_classes([StaticHTMLRenderer])
    def simple_html_view(request):
        data = '<html><body><h1>Hello, world</h1></body></html>'
        return Response(data)
    ```

    You can use `StaticHTMLRenderer` either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.

    **.media_type**: `text/html`

    **.format**: `'html'`

    **.charset**: `utf-8`

    See also: `TemplateHTMLRenderer`
- name: Status Codes
  id: api-guide/status-codes/index
  summary: 418 I'm a teapot - Any attempt to brew coffee with a teapot should result in the error code "418 I'm a teapot". The resulting entity body MAY be short and stout
  description: "# Status Codes\n\n> 418 I'm a teapot - Any attempt to brew coffee with a teapot should result in the error code \"418 I'm a teapot\". The resulting entity body MAY be short and stout.\n>\n> — [RFC 2324](https://www.ietf.org/rfc/rfc2324.txt), Hyper Text Coffee Pot Control Protocol\n\nUsing bare status codes in your responses isn't recommended. REST framework includes a set of named constants that you can use to make your code more obvious and readable.\n\n``` python\nfrom rest_framework import status\nfrom rest_framework.response import Response\n\ndef empty_view(self):\n    content = {'please move along': 'nothing to see here'}\n    return Response(content, status=status.HTTP_404_NOT_FOUND)\n```\n\nThe full set of HTTP status codes included in the `status` module is listed below.\n\nThe module also includes a set of helper functions for testing if a status code is in a given range.\n\n``` python\nfrom rest_framework import status\nfrom rest_framework.test import APITestCase\n\nclass ExampleTestCase(APITestCase):\n    def test_url_root(self):\n        url = reverse('index')\n        response = self.client.get(url)\n        self.assertTrue(status.is_success(response.status_code))\n```\n\nFor more information on proper usage of HTTP status codes see [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) and [RFC 6585](https://tools.ietf.org/html/rfc6585).\n\n## Informational - 1xx\n\nThis class of status code indicates a provisional response. There are no 1xx status codes used in REST framework by default.\n\n``` python\nHTTP_100_CONTINUE\nHTTP_101_SWITCHING_PROTOCOLS\nHTTP_102_PROCESSING\nHTTP_103_EARLY_HINTS\n```\n\n## Successful - 2xx\n\nThis class of status code indicates that the client's request was successfully received, understood, and accepted.\n\n``` python\nHTTP_200_OK\nHTTP_201_CREATED\nHTTP_202_ACCEPTED\nHTTP_203_NON_AUTHORITATIVE_INFORMATION\nHTTP_204_NO_CONTENT\nHTTP_205_RESET_CONTENT\nHTTP_206_PARTIAL_CONTENT\nHTTP_207_MULTI_STATUS\nHTTP_208_ALREADY_REPORTED\nHTTP_226_IM_USED\n```\n\n## Redirection - 3xx\n\nThis class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.\n\n``` python\nHTTP_300_MULTIPLE_CHOICES\nHTTP_301_MOVED_PERMANENTLY\nHTTP_302_FOUND\nHTTP_303_SEE_OTHER\nHTTP_304_NOT_MODIFIED\nHTTP_305_USE_PROXY\nHTTP_306_RESERVED\nHTTP_307_TEMPORARY_REDIRECT\nHTTP_308_PERMANENT_REDIRECT\n```\n\n## Client Error - 4xx\n\nThe 4xx class of status code is intended for cases in which the client seems to have erred. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.\n\n``` python\nHTTP_400_BAD_REQUEST\nHTTP_401_UNAUTHORIZED\nHTTP_402_PAYMENT_REQUIRED\nHTTP_403_FORBIDDEN\nHTTP_404_NOT_FOUND\nHTTP_405_METHOD_NOT_ALLOWED\nHTTP_406_NOT_ACCEPTABLE\nHTTP_407_PROXY_AUTHENTICATION_REQUIRED\nHTTP_408_REQUEST_TIMEOUT\nHTTP_409_CONFLICT\nHTTP_410_GONE\nHTTP_411_LENGTH_REQUIRED\nHTTP_412_PRECONDITION_FAILED\nHTTP_413_REQUEST_ENTITY_TOO_LARGE\nHTTP_414_REQUEST_URI_TOO_LONG\nHTTP_415_UNSUPPORTED_MEDIA_TYPE\nHTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE\nHTTP_417_EXPECTATION_FAILED\nHTTP_421_MISDIRECTED_REQUEST\nHTTP_422_UNPROCESSABLE_ENTITY\nHTTP_423_LOCKED\nHTTP_424_FAILED_DEPENDENCY\nHTTP_425_TOO_EARLY\nHTTP_426_UPGRADE_REQUIRED\nHTTP_428_PRECONDITION_REQUIRED\nHTTP_429_TOO_MANY_REQUESTS\nHTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE\nHTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS\n```\n\n## Server Error - 5xx\n\nResponse status codes beginning with the digit \"5\" indicate cases in which the server is aware that it has erred or is incapable of performing the request. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.\n\n``` python\nHTTP_500_INTERNAL_SERVER_ERROR\nHTTP_501_NOT_IMPLEMENTED\nHTTP_502_BAD_GATEWAY\nHTTP_503_SERVICE_UNAVAILABLE\nHTTP_504_GATEWAY_TIMEOUT\nHTTP_505_HTTP_VERSION_NOT_SUPPORTED\nHTTP_506_VARIANT_ALSO_NEGOTIATES\nHTTP_507_INSUFFICIENT_STORAGE\nHTTP_508_LOOP_DETECTED\nHTTP_509_BANDWIDTH_LIMIT_EXCEEDED\nHTTP_510_NOT_EXTENDED\nHTTP_511_NETWORK_AUTHENTICATION_REQUIRED\n```\n\n## Helper functions\n\nThe following helper functions are available for identifying the category of the response code.\n\n``` python\nis_informational()  # 1xx\nis_success()        # 2xx\nis_redirect()       # 3xx\nis_client_error()   # 4xx\nis_server_error()   # 5xx\n```\n\n[status.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/status.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/status-codes/](https://www.django-rest-framework.org/api-guide/status-codes/)"
- name: StringRelatedField
  id: api-guide/relations/index#stringrelatedfield
  summary: StringRelatedField may be used to represent the target of the relationship using its __str__ method
  belongs_to: Serializer relations
  description: |-
    ## StringRelatedField

    `StringRelatedField` may be used to represent the target of the relationship using its `__str__` method.

    For example, the following serializer:

    ``` python
    class AlbumSerializer(serializers.ModelSerializer):
        tracks = serializers.StringRelatedField(many=True)

        class Meta:
            model = Album
            fields = ['album_name', 'artist', 'tracks']
    ```

    Would serialize to the following representation:

    ``` python
    {
        'album_name': 'Things We Lost In The Fire',
        'artist': 'Low',
        'tracks': [
            '1: Sunflower',
            '2: Whitetail',
            '3: Dinosaur Act',
            ...
        ]
    }
    ```

    This field is read only.

    **Arguments**:

    - `many` - If applied to a to-many relationship, you should set this argument to `True`.
- name: TemplateHTMLRenderer
  id: api-guide/renderers/index#templatehtmlrenderer
  summary: Renders data to HTML, using Django's standard template rendering
  belongs_to: Renderers
  description: |-
    ## TemplateHTMLRenderer

    Renders data to HTML, using Django's standard template rendering. Unlike other renderers, the data passed to the `Response` does not need to be serialized. Also, unlike other renderers, you may want to include a `template_name` argument when creating the `Response`.

    The TemplateHTMLRenderer will create a `RequestContext`, using the `response.data` as the context dict, and determine a template name to use to render the context.

    **Note:** When used with a view that makes use of a serializer the `Response` sent for rendering may not be a dictionary and will need to be wrapped in a dict before returning to allow the `TemplateHTMLRenderer` to render it. For example:

    ``` python
    response.data = {'results': response.data}
    ```

    The template name is determined by (in order of preference):

    1.  An explicit `template_name` argument passed to the response.
    2.  An explicit `.template_name` attribute set on this class.
    3.  The return result of calling `view.get_template_names()`.

    An example of a view that uses `TemplateHTMLRenderer`:

    ``` python
    class UserDetail(generics.RetrieveAPIView):
        """
        A view that returns a templated HTML representation of a given user.
        """
        queryset = User.objects.all()
        renderer_classes = [TemplateHTMLRenderer]

        def get(self, request, *args, **kwargs):
            self.object = self.get_object()
            return Response({'user': self.object}, template_name='user_detail.html')
    ```

    You can use `TemplateHTMLRenderer` either to return regular HTML pages using REST framework, or to return both HTML and API responses from a single endpoint.

    If you're building websites that use `TemplateHTMLRenderer` along with other renderer classes, you should consider listing `TemplateHTMLRenderer` as the first class in the `renderer_classes` list, so that it will be prioritised first even for browsers that send poorly formed `ACCEPT:` headers.

    See the [*HTML & Forms* Topic Page](https://www.django-rest-framework.org/topics/html-and-forms/) for further examples of `TemplateHTMLRenderer` usage.

    **.media_type**: `text/html`

    **.format**: `'html'`

    **.charset**: `utf-8`

    See also: `StaticHTMLRenderer`
- name: Test settings
  id: api-guide/settings/index#test-settings
  summary: The default format that should be used when making test requests
  belongs_to: Settings
  description: |-
    ## Test settings

    *The following settings control the behavior of APIRequestFactory and APIClient*

    #### TEST_REQUEST_DEFAULT_FORMAT

    The default format that should be used when making test requests.

    This should match up with the format of one of the renderer classes in the `TEST_REQUEST_RENDERER_CLASSES` setting.

    Default: `'multipart'`

    #### TEST_REQUEST_RENDERER_CLASSES

    The renderer classes that are supported when building test requests.

    The format of any of these renderer classes may be used when constructing a test request, for example: `client.post('/users', {'username': 'jamie'}, format='json')`

    Default:

    ``` python
    [
        'rest_framework.renderers.MultiPartRenderer',
        'rest_framework.renderers.JSONRenderer'
    ]
    ```
- name: Testing
  id: api-guide/testing/index
  summary: Code without tests is broken as designed
  description: "# Testing\n\n> Code without tests is broken as designed.\n>\n> — [Jacob Kaplan-Moss](https://jacobian.org/writing/django-apps-with-buildout/#s-create-a-test-wrapper)\n\nREST framework includes a few helper classes that extend Django's existing test framework, and improve support for making API requests.\n\n# APIRequestFactory\n\nExtends [Django's existing `RequestFactory` class](https://docs.djangoproject.com/en/stable/topics/testing/advanced/#django.test.client.RequestFactory).\n\n## Creating test requests\n\nThe `APIRequestFactory` class supports an almost identical API to Django's standard `RequestFactory` class. This means that the standard `.get()`, `.post()`, `.put()`, `.patch()`, `.delete()`, `.head()` and `.options()` methods are all available.\n\n``` python\nfrom rest_framework.test import APIRequestFactory\n\n# Using the standard RequestFactory API to create a form POST request\nfactory = APIRequestFactory()\nrequest = factory.post('/notes/', {'title': 'new idea'})\n```\n\n#### Using the format argument\n\nMethods which create a request body, such as `post`, `put` and `patch`, include a `format` argument, which make it easy to generate requests using a content type other than multipart form data. For example:\n\n``` python\n# Create a JSON POST request\nfactory = APIRequestFactory()\nrequest = factory.post('/notes/', {'title': 'new idea'}, format='json')\n```\n\nBy default the available formats are `'multipart'` and `'json'`. For compatibility with Django's existing `RequestFactory` the default format is `'multipart'`.\n\nTo support a wider set of request formats, or change the default format, [see the configuration section](#configuration).\n\n#### Explicitly encoding the request body\n\nIf you need to explicitly encode the request body, you can do so by setting the `content_type` flag. For example:\n\n``` python\nrequest = factory.post('/notes/', json.dumps({'title': 'new idea'}), content_type='application/json')\n```\n\n#### PUT and PATCH with form data\n\nOne difference worth noting between Django's `RequestFactory` and REST framework's `APIRequestFactory` is that multipart form data will be encoded for methods other than just `.post()`.\n\nFor example, using `APIRequestFactory`, you can make a form PUT request like so:\n\n``` python\nfactory = APIRequestFactory()\nrequest = factory.put('/notes/547/', {'title': 'remember to email dave'})\n```\n\nUsing Django's `RequestFactory`, you'd need to explicitly encode the data yourself:\n\n``` python\nfrom django.test.client import encode_multipart, RequestFactory\n\nfactory = RequestFactory()\ndata = {'title': 'remember to email dave'}\ncontent = encode_multipart('BoUnDaRyStRiNg', data)\ncontent_type = 'multipart/form-data; boundary=BoUnDaRyStRiNg'\nrequest = factory.put('/notes/547/', content, content_type=content_type)\n```\n\n## Forcing authentication\n\nWhen testing views directly using a request factory, it's often convenient to be able to directly authenticate the request, rather than having to construct the correct authentication credentials.\n\nTo forcibly authenticate a request, use the `force_authenticate()` method.\n\n``` python\nfrom rest_framework.test import force_authenticate\n\nfactory = APIRequestFactory()\nuser = User.objects.get(username='olivia')\nview = AccountDetail.as_view()\n\n# Make an authenticated request to the view...\nrequest = factory.get('/accounts/django-superstars/')\nforce_authenticate(request, user=user)\nresponse = view(request)\n```\n\nThe signature for the method is `force_authenticate(request, user=None, token=None)`. When making the call, either or both of the user and token may be set.\n\nFor example, when forcibly authenticating using a token, you might do something like the following:\n\n``` python\nuser = User.objects.get(username='olivia')\nrequest = factory.get('/accounts/django-superstars/')\nforce_authenticate(request, user=user, token=user.auth_token)\n```\n\n**Note**: `force_authenticate` directly sets `request.user` to the in-memory `user` instance. If you are re-using the same `user` instance across multiple tests that update the saved `user` state, you may need to call [`refresh_from_db()`](https://docs.djangoproject.com/en/stable/ref/models/instances/#django.db.models.Model.refresh_from_db) between tests.\n\n**Note**: When using `APIRequestFactory`, the object that is returned is Django's standard `HttpRequest`, and not REST framework's `Request` object, which is only generated once the view is called.\n\nThis means that setting attributes directly on the request object may not always have the effect you expect. For example, setting `.token` directly will have no effect, and setting `.user` directly will only work if session authentication is being used.\n\n``` python\n# Request will only authenticate if `SessionAuthentication` is in use.\nrequest = factory.get('/accounts/django-superstars/')\nrequest.user = user\nresponse = view(request)\n```\n\n## Forcing CSRF validation\n\nBy default, requests created with `APIRequestFactory` will not have CSRF validation applied when passed to a REST framework view. If you need to explicitly turn CSRF validation on, you can do so by setting the `enforce_csrf_checks` flag when instantiating the factory.\n\n``` python\nfactory = APIRequestFactory(enforce_csrf_checks=True)\n```\n\n**Note**: It's worth noting that Django's standard `RequestFactory` doesn't need to include this option, because when using regular Django the CSRF validation takes place in middleware, which is not run when testing views directly. When using REST framework, CSRF validation takes place inside the view, so the request factory needs to disable view-level CSRF checks.\n\n# APIClient\n\nExtends [Django's existing `Client` class](https://docs.djangoproject.com/en/stable/topics/testing/tools/#the-test-client).\n\n## Making requests\n\nThe `APIClient` class supports the same request interface as Django's standard `Client` class. This means that the standard `.get()`, `.post()`, `.put()`, `.patch()`, `.delete()`, `.head()` and `.options()` methods are all available. For example:\n\n``` python\nfrom rest_framework.test import APIClient\n\nclient = APIClient()\nclient.post('/notes/', {'title': 'new idea'}, format='json')\n```\n\nTo support a wider set of request formats, or change the default format, [see the configuration section](#configuration).\n\n## Authenticating\n\n#### .login(\\*\\*kwargs)\n\nThe `login` method functions exactly as it does with Django's regular `Client` class. This allows you to authenticate requests against any views which include `SessionAuthentication`.\n\n``` python\n# Make all requests in the context of a logged in session.\nclient = APIClient()\nclient.login(username='lauren', password='secret')\n```\n\nTo logout, call the `logout` method as usual.\n\n``` python\n# Log out\nclient.logout()\n```\n\nThe `login` method is appropriate for testing APIs that use session authentication, for example web sites which include AJAX interaction with the API.\n\n#### .credentials(\\*\\*kwargs)\n\nThe `credentials` method can be used to set headers that will then be included on all subsequent requests by the test client.\n\n``` python\nfrom rest_framework.authtoken.models import Token\nfrom rest_framework.test import APIClient\n\n# Include an appropriate `Authorization:` header on all requests.\ntoken = Token.objects.get(user__username='lauren')\nclient = APIClient()\nclient.credentials(HTTP_AUTHORIZATION='Token ' + token.key)\n```\n\nNote that calling `credentials` a second time overwrites any existing credentials. You can unset any existing credentials by calling the method with no arguments.\n\n``` python\n# Stop including any credentials\nclient.credentials()\n```\n\nThe `credentials` method is appropriate for testing APIs that require authentication headers, such as basic authentication, OAuth1a and OAuth2 authentication, and simple token authentication schemes.\n\n#### .force_authenticate(user=None, token=None)\n\nSometimes you may want to bypass authentication entirely and force all requests by the test client to be automatically treated as authenticated.\n\nThis can be a useful shortcut if you're testing the API but don't want to have to construct valid authentication credentials in order to make test requests.\n\n``` python\nuser = User.objects.get(username='lauren')\nclient = APIClient()\nclient.force_authenticate(user=user)\n```\n\nTo unauthenticate subsequent requests, call `force_authenticate` setting the user and/or token to `None`.\n\n``` python\nclient.force_authenticate(user=None)\n```\n\n## CSRF validation\n\nBy default CSRF validation is not applied when using `APIClient`. If you need to explicitly enable CSRF validation, you can do so by setting the `enforce_csrf_checks` flag when instantiating the client.\n\n``` python\nclient = APIClient(enforce_csrf_checks=True)\n```\n\nAs usual CSRF validation will only apply to any session authenticated views. This means CSRF validation will only occur if the client has been logged in by calling `login()`.\n\n# RequestsClient\n\nREST framework also includes a client for interacting with your application using the popular Python library, `requests`. This may be useful if:\n\n- You are expecting to interface with the API primarily from another Python service, and want to test the service at the same level as the client will see.\n- You want to write tests in such a way that they can also be run against a staging or live environment. (See \"Live tests\" below.)\n\nThis exposes exactly the same interface as if you were using a requests session directly.\n\n``` python\nfrom rest_framework.test import RequestsClient\n\nclient = RequestsClient()\nresponse = client.get('http://testserver/users/')\nassert response.status_code == 200\n```\n\nNote that the requests client requires you to pass fully qualified URLs.\n\n## RequestsClient and working with the database\n\nThe `RequestsClient` class is useful if you want to write tests that solely interact with the service interface. This is a little stricter than using the standard Django test client, as it means that all interactions should be via the API.\n\nIf you're using `RequestsClient` you'll want to ensure that test setup, and results assertions are performed as regular API calls, rather than interacting with the database models directly. For example, rather than checking that `Customer.objects.count() == 3` you would list the customers endpoint, and ensure that it contains three records.\n\n## Headers & Authentication\n\nCustom headers and authentication credentials can be provided in the same way as [when using a standard `requests.Session` instance](https://requests.readthedocs.io/en/master/user/advanced/#session-objects).\n\n``` python\nfrom requests.auth import HTTPBasicAuth\n\nclient.auth = HTTPBasicAuth('user', 'pass')\nclient.headers.update({'x-test': 'true'})\n```\n\n## CSRF\n\nIf you're using `SessionAuthentication` then you'll need to include a CSRF token for any `POST`, `PUT`, `PATCH` or `DELETE` requests.\n\nYou can do so by following the same flow that a JavaScript based client would use. First, make a `GET` request in order to obtain a CSRF token, then present that token in the following request.\n\nFor example...\n\n``` python\nclient = RequestsClient()\n\n# Obtain a CSRF token.\nresponse = client.get('http://testserver/homepage/')\nassert response.status_code == 200\ncsrftoken = response.cookies['csrftoken']\n\n# Interact with the API.\nresponse = client.post('http://testserver/organisations/', json={\n    'name': 'MegaCorp',\n    'status': 'active'\n}, headers={'X-CSRFToken': csrftoken})\nassert response.status_code == 200\n```\n\n## Live tests\n\nWith careful usage both the `RequestsClient` and the `CoreAPIClient` provide the ability to write test cases that can run either in development, or be run directly against your staging server or production environment.\n\nUsing this style to create basic tests of a few core pieces of functionality is a powerful way to validate your live service. Doing so may require some careful attention to setup and teardown to ensure that the tests run in a way that they do not directly affect customer data.\n\n# CoreAPIClient\n\nThe CoreAPIClient allows you to interact with your API using the Python `coreapi` client library.\n\n``` python\n# Fetch the API schema\nclient = CoreAPIClient()\nschema = client.get('http://testserver/schema/')\n\n# Create a new organisation\nparams = {'name': 'MegaCorp', 'status': 'active'}\nclient.action(schema, ['organisations', 'create'], params)\n\n# Ensure that the organisation exists in the listing\ndata = client.action(schema, ['organisations', 'list'])\nassert(len(data) == 1)\nassert(data == [{'name': 'MegaCorp', 'status': 'active'}])\n```\n\n## Headers & Authentication\n\nCustom headers and authentication may be used with `CoreAPIClient` in a similar way as with `RequestsClient`.\n\n``` python\nfrom requests.auth import HTTPBasicAuth\n\nclient = CoreAPIClient()\nclient.session.auth = HTTPBasicAuth('user', 'pass')\nclient.session.headers.update({'x-test': 'true'})\n```\n\n# API Test cases\n\nREST framework includes the following test case classes, that mirror the existing [Django's test case classes](https://docs.djangoproject.com/en/stable/topics/testing/tools/#provided-test-case-classes), but use `APIClient` instead of Django's default `Client`.\n\n- `APISimpleTestCase`\n- `APITransactionTestCase`\n- `APITestCase`\n- `APILiveServerTestCase`\n\n## Example\n\nYou can use any of REST framework's test case classes as you would for the regular Django test case classes. The `self.client` attribute will be an `APIClient` instance.\n\n``` python\nfrom django.urls import reverse\nfrom rest_framework import status\nfrom rest_framework.test import APITestCase\nfrom myproject.apps.core.models import Account\n\nclass AccountTests(APITestCase):\n    def test_create_account(self):\n        \"\"\"\n        Ensure we can create a new account object.\n        \"\"\"\n        url = reverse('account-list')\n        data = {'name': 'DabApps'}\n        response = self.client.post(url, data, format='json')\n        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n        self.assertEqual(Account.objects.count(), 1)\n        self.assertEqual(Account.objects.get().name, 'DabApps')\n```\n\n# URLPatternsTestCase\n\nREST framework also provides a test case class for isolating `urlpatterns` on a per-class basis. Note that this inherits from Django's `SimpleTestCase`, and will most likely need to be mixed with another test case class.\n\n## Example\n\n``` python\nfrom django.urls import include, path, reverse\nfrom rest_framework.test import APITestCase, URLPatternsTestCase\n\n\nclass AccountTests(APITestCase, URLPatternsTestCase):\n    urlpatterns = [\n        path('api/', include('api.urls')),\n    ]\n\n    def test_create_account(self):\n        \"\"\"\n        Ensure we can create a new account object.\n        \"\"\"\n        url = reverse('account-list')\n        response = self.client.get(url, format='json')\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(len(response.data), 1)\n```\n\n# Testing responses\n\n## Checking the response data\n\nWhen checking the validity of test responses it's often more convenient to inspect the data that the response was created with, rather than inspecting the fully rendered response.\n\nFor example, it's easier to inspect `response.data`:\n\n``` python\nresponse = self.client.get('/users/4/')\nself.assertEqual(response.data, {'id': 4, 'username': 'lauren'})\n```\n\nInstead of inspecting the result of parsing `response.content`:\n\n``` python\nresponse = self.client.get('/users/4/')\nself.assertEqual(json.loads(response.content), {'id': 4, 'username': 'lauren'})\n```\n\n## Rendering responses\n\nIf you're testing views directly using `APIRequestFactory`, the responses that are returned will not yet be rendered, as rendering of template responses is performed by Django's internal request-response cycle. In order to access `response.content`, you'll first need to render the response.\n\n``` python\nview = UserDetail.as_view()\nrequest = factory.get('/users/4')\nresponse = view(request, pk='4')\nresponse.render()  # Cannot access `response.content` without this.\nself.assertEqual(response.content, '{\"username\": \"lauren\", \"id\": 4}')\n```\n\n# Configuration\n\n## Setting the default format\n\nThe default format used to make test requests may be set using the `TEST_REQUEST_DEFAULT_FORMAT` setting key. For example, to always use JSON for test requests by default instead of standard multipart form requests, set the following in your `settings.py` file:\n\n``` python\nREST_FRAMEWORK = {\n    ...\n    'TEST_REQUEST_DEFAULT_FORMAT': 'json'\n}\n```\n\n## Setting the available formats\n\nIf you need to test requests using something other than multipart or json requests, you can do so by setting the `TEST_REQUEST_RENDERER_CLASSES` setting.\n\nFor example, to add support for using `format='html'` in test requests, you might have something like this in your `settings.py` file.\n\n``` python\nREST_FRAMEWORK = {\n    ...\n    'TEST_REQUEST_RENDERER_CLASSES': [\n        'rest_framework.renderers.MultiPartRenderer',\n        'rest_framework.renderers.JSONRenderer',\n        'rest_framework.renderers.TemplateHTMLRenderer'\n    ]\n}\n```\n\n[test.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/test.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/testing/](https://www.django-rest-framework.org/api-guide/testing/)"
- name: Throttled
  id: api-guide/exceptions/index#throttled
  summary: Raised when an incoming request fails the throttling checks
  belongs_to: Exceptions
  description: |-
    ## Throttled

    **Signature:** `Throttled(wait=None, detail=None, code=None)`

    Raised when an incoming request fails the throttling checks.

    By default this exception results in a response with the HTTP status code "429 Too Many Requests".
- name: Throttling
  id: api-guide/throttling/index
  summary: Throttling is similar to permissions, in that it determines if a request should be authorized
  description: "# Throttling\n\n> HTTP/1.1 420 Enhance Your Calm\n>\n> [Twitter API rate limiting response](https://developer.twitter.com/en/docs/basics/rate-limiting)\n\nThrottling is similar to [permissions](../permissions/index), in that it determines if a request should be authorized. Throttles indicate a temporary state, and are used to control the rate of requests that clients can make to an API.\n\nAs with permissions, multiple throttles may be used. Your API might have a restrictive throttle for unauthenticated requests, and a less restrictive throttle for authenticated requests.\n\nAnother scenario where you might want to use multiple throttles would be if you need to impose different constraints on different parts of the API, due to some services being particularly resource-intensive.\n\nMultiple throttles can also be used if you want to impose both burst throttling rates, and sustained throttling rates. For example, you might want to limit a user to a maximum of 60 requests per minute, and 1000 requests per day.\n\nThrottles do not necessarily only refer to rate-limiting requests. For example a storage service might also need to throttle against bandwidth, and a paid data service might want to throttle against a certain number of a records being accessed.\n\n\\*\\*The application-level throttling that REST framework provides should not be considered a security measure or protection against brute forcing or denial-of-service attacks. Deliberately malicious actors will always be able to spoof IP origins. In addition to this, the built-in throttling implementations are implemented using Django's cache framework, and use non-atomic operations to determine the request rate, which may sometimes result in some fuzziness.\n\nThe application-level throttling provided by REST framework is intended for implementing policies such as different business tiers and basic protections against service over-use.\\*\\*\n\n## How throttling is determined\n\nAs with permissions and authentication, throttling in REST framework is always defined as a list of classes.\n\nBefore running the main body of the view each throttle in the list is checked. If any throttle check fails an `exceptions.Throttled` exception will be raised, and the main body of the view will not run.\n\n## Setting the throttling policy\n\nThe default throttling policy may be set globally, using the `DEFAULT_THROTTLE_CLASSES` and `DEFAULT_THROTTLE_RATES` settings. For example.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_THROTTLE_CLASSES': [\n        'rest_framework.throttling.AnonRateThrottle',\n        'rest_framework.throttling.UserRateThrottle'\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'anon': '100/day',\n        'user': '1000/day'\n    }\n}\n```\n\nThe rate descriptions used in `DEFAULT_THROTTLE_RATES` may include `second`, `minute`, `hour` or `day` as the throttle period.\n\nYou can also set the throttling policy on a per-view or per-viewset basis, using the `APIView` class-based views.\n\n``` python\nfrom rest_framework.response import Response\nfrom rest_framework.throttling import UserRateThrottle\nfrom rest_framework.views import APIView\n\nclass ExampleView(APIView):\n    throttle_classes = [UserRateThrottle]\n\n    def get(self, request, format=None):\n        content = {\n            'status': 'request was permitted'\n        }\n        return Response(content)\n```\n\nIf you're using the `@api_view` decorator with function based views you can use the following decorator.\n\n``` python\n@api_view(['GET'])\n@throttle_classes([UserRateThrottle])\ndef example_view(request, format=None):\n    content = {\n        'status': 'request was permitted'\n    }\n    return Response(content)\n```\n\nIt's also possible to set throttle classes for routes that are created using the `@action` decorator. Throttle classes set in this way will override any viewset level class settings.\n\n``` python\n@action(detail=True, methods=[\"post\"], throttle_classes=[UserRateThrottle])\ndef example_adhoc_method(request, pk=None):\n    content = {\n        'status': 'request was permitted'\n    }\n    return Response(content)\n```\n\n## How clients are identified\n\nThe `X-Forwarded-For` HTTP header and `REMOTE_ADDR` WSGI variable are used to uniquely identify client IP addresses for throttling. If the `X-Forwarded-For` header is present then it will be used, otherwise the value of the `REMOTE_ADDR` variable from the WSGI environment will be used.\n\nIf you need to strictly identify unique client IP addresses, you'll need to first configure the number of application proxies that the API runs behind by setting the `NUM_PROXIES` setting. This setting should be an integer of zero or more. If set to non-zero then the client IP will be identified as being the last IP address in the `X-Forwarded-For` header, once any application proxy IP addresses have first been excluded. If set to zero, then the `REMOTE_ADDR` value will always be used as the identifying IP address.\n\nIt is important to understand that if you configure the `NUM_PROXIES` setting, then all clients behind a unique [NAT'd](https://en.wikipedia.org/wiki/Network_address_translation) gateway will be treated as a single client.\n\nFurther context on how the `X-Forwarded-For` header works, and identifying a remote client IP can be [found here](http://oxpedia.org/wiki/index.php?title=AppSuite:Grizzly#Multiple_Proxies_in_front_of_the_cluster).\n\n## Setting up the cache\n\nThe throttle classes provided by REST framework use Django's cache backend. You should make sure that you've set appropriate [cache settings](https://docs.djangoproject.com/en/stable/ref/settings/#caches). The default value of `LocMemCache` backend should be okay for simple setups. See Django's [cache documentation](https://docs.djangoproject.com/en/stable/topics/cache/#setting-up-the-cache) for more details.\n\nIf you need to use a cache other than `'default'`, you can do so by creating a custom throttle class and setting the `cache` attribute. For example:\n\n``` python\nfrom django.core.cache import caches\n\nclass CustomAnonRateThrottle(AnonRateThrottle):\n    cache = caches['alternate']\n```\n\nYou'll need to remember to also set your custom throttle class in the `'DEFAULT_THROTTLE_CLASSES'` settings key, or using the `throttle_classes` view attribute.\n\n## A note on concurrency\n\nThe built-in throttle implementations are open to [race conditions](https://en.wikipedia.org/wiki/Race_condition#Data_race), so under high concurrency they may allow a few extra requests through.\n\nIf your project relies on guaranteeing the number of requests during concurrent requests, you will need to implement your own throttle class. See [issue \\#5181](https://github.com/encode/django-rest-framework/issues/5181) for more details.\n\n# API Reference\n\n## AnonRateThrottle\n\nThe `AnonRateThrottle` will only ever throttle unauthenticated users. The IP address of the incoming request is used to generate a unique key to throttle against.\n\nThe allowed request rate is determined from one of the following (in order of preference).\n\n- The `rate` property on the class, which may be provided by overriding `AnonRateThrottle` and setting the property.\n- The `DEFAULT_THROTTLE_RATES['anon']` setting.\n\n`AnonRateThrottle` is suitable if you want to restrict the rate of requests from unknown sources.\n\n## UserRateThrottle\n\nThe `UserRateThrottle` will throttle users to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.\n\nThe allowed request rate is determined from one of the following (in order of preference).\n\n- The `rate` property on the class, which may be provided by overriding `UserRateThrottle` and setting the property.\n- The `DEFAULT_THROTTLE_RATES['user']` setting.\n\nAn API may have multiple `UserRateThrottles` in place at the same time. To do so, override `UserRateThrottle` and set a unique \"scope\" for each class.\n\nFor example, multiple user throttle rates could be implemented by using the following classes...\n\n``` python\nclass BurstRateThrottle(UserRateThrottle):\n    scope = 'burst'\n\nclass SustainedRateThrottle(UserRateThrottle):\n    scope = 'sustained'\n```\n\n...and the following settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_THROTTLE_CLASSES': [\n        'example.throttles.BurstRateThrottle',\n        'example.throttles.SustainedRateThrottle'\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'burst': '60/min',\n        'sustained': '1000/day'\n    }\n}\n```\n\n`UserRateThrottle` is suitable if you want simple global rate restrictions per-user.\n\n## ScopedRateThrottle\n\nThe `ScopedRateThrottle` class can be used to restrict access to specific parts of the API. This throttle will only be applied if the view that is being accessed includes a `.throttle_scope` property. The unique throttle key will then be formed by concatenating the \"scope\" of the request with the unique user id or IP address.\n\nThe allowed request rate is determined by the `DEFAULT_THROTTLE_RATES` setting using a key from the request \"scope\".\n\nFor example, given the following views...\n\n``` python\nclass ContactListView(APIView):\n    throttle_scope = 'contacts'\n    ...\n\nclass ContactDetailView(APIView):\n    throttle_scope = 'contacts'\n    ...\n\nclass UploadView(APIView):\n    throttle_scope = 'uploads'\n    ...\n```\n\n...and the following settings.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_THROTTLE_CLASSES': [\n        'rest_framework.throttling.ScopedRateThrottle',\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'contacts': '1000/day',\n        'uploads': '20/day'\n    }\n}\n```\n\nUser requests to either `ContactListView` or `ContactDetailView` would be restricted to a total of 1000 requests per-day. User requests to `UploadView` would be restricted to 20 requests per day.\n\n# Custom throttles\n\nTo create a custom throttle, override `BaseThrottle` and implement `.allow_request(self, request, view)`. The method should return `True` if the request should be allowed, and `False` otherwise.\n\nOptionally you may also override the `.wait()` method. If implemented, `.wait()` should return a recommended number of seconds to wait before attempting the next request, or `None`. The `.wait()` method will only be called if `.allow_request()` has previously returned `False`.\n\nIf the `.wait()` method is implemented and the request is throttled, then a `Retry-After` header will be included in the response.\n\n## Example\n\nThe following is an example of a rate throttle, that will randomly throttle 1 in every 10 requests.\n\n``` python\nimport random\n\nclass RandomRateThrottle(throttling.BaseThrottle):\n    def allow_request(self, request, view):\n        return random.randint(1, 10) != 1\n```\n\n[throttling.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/throttling.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/throttling/](https://www.django-rest-framework.org/api-guide/throttling/)"
- name: TimeField
  id: api-guide/fields/index#timefield
  summary: A time representation
  belongs_to: Serializer fields
  description: |-
    ## TimeField

    A time representation.

    Corresponds to `django.db.models.fields.TimeField`

    **Signature:** `TimeField(format=api_settings.TIME_FORMAT, input_formats=None)`

    - `format` - A string representing the output format. If not specified, this defaults to the same value as the `TIME_FORMAT` settings key, which will be `'iso-8601'` unless set. Setting to a format string indicates that `to_representation` return values should be coerced to string output. Format strings are described below. Setting this value to `None` indicates that Python `time` objects should be returned by `to_representation`. In this case the time encoding will be determined by the renderer.
    - `input_formats` - A list of strings representing the input formats which may be used to parse the date. If not specified, the `TIME_INPUT_FORMATS` setting will be used, which defaults to `['iso-8601']`.

    #### TimeField format strings

    Format strings may either be [Python strftime formats](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior) which explicitly specify the format, or the special string `'iso-8601'`, which indicates that [ISO 8601](https://www.w3.org/TR/NOTE-datetime) style times should be used. (eg `'12:34:56.000000'`)
- name: TokenAuthentication
  id: api-guide/authentication/index#tokenauthentication
  summary: 'Note: The token authentication provided by Django REST framework is a fairly simple implementation'
  belongs_to: Authentication
  description: |-
    ## TokenAuthentication

    **Note:** The token authentication provided by Django REST framework is a fairly simple implementation.

    For an implementation which allows more than one token per user, has some tighter security implementation details, and supports token expiry, please see the [Django REST Knox](https://github.com/James1345/django-rest-knox) third party package.

    This authentication scheme uses a simple token-based HTTP Authentication scheme. Token authentication is appropriate for client-server setups, such as native desktop and mobile clients.

    To use the `TokenAuthentication` scheme you'll need to [configure the authentication classes](#setting-the-authentication-scheme) to include `TokenAuthentication`, and additionally include `rest_framework.authtoken` in your `INSTALLED_APPS` setting:

    ``` python
    INSTALLED_APPS = [
        ...
        'rest_framework.authtoken'
    ]
    ```

    Make sure to run `manage.py migrate` after changing your settings.

    The `rest_framework.authtoken` app provides Django database migrations.

    You'll also need to create tokens for your users.

    ``` python
    from rest_framework.authtoken.models import Token

    token = Token.objects.create(user=...)
    print(token.key)
    ```

    For clients to authenticate, the token key should be included in the `Authorization` HTTP header. The key should be prefixed by the string literal "Token", with whitespace separating the two strings. For example:

    ``` python
    Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b
    ```

    *If you want to use a different keyword in the header, such as `Bearer`, simply subclass `TokenAuthentication` and set the `keyword` class variable.*

    If successfully authenticated, `TokenAuthentication` provides the following credentials.

    - `request.user` will be a Django `User` instance.
    - `request.auth` will be a `rest_framework.authtoken.models.Token` instance.

    Unauthenticated responses that are denied permission will result in an `HTTP 401 Unauthorized` response with an appropriate WWW-Authenticate header. For example:

    ``` python
    WWW-Authenticate: Token
    ```

    The `curl` command line tool may be useful for testing token authenticated APIs. For example:

    ``` python
    curl -X GET http://127.0.0.1:8000/api/example/ -H 'Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b'
    ```

    **Note:** If you use `TokenAuthentication` in production you must ensure that your API is only available over `https`.

    ### Generating Tokens

    #### By using signals

    If you want every user to have an automatically generated Token, you can simply catch the User's `post_save` signal.

    ``` python
    from django.conf import settings
    from django.db.models.signals import post_save
    from django.dispatch import receiver
    from rest_framework.authtoken.models import Token

    @receiver(post_save, sender=settings.AUTH_USER_MODEL)
    def create_auth_token(sender, instance=None, created=False, **kwargs):
        if created:
            Token.objects.create(user=instance)
    ```

    Note that you'll want to ensure you place this code snippet in an installed `models.py` module, or some other location that will be imported by Django on startup.

    If you've already created some users, you can generate tokens for all existing users like this:

    ``` python
    from django.contrib.auth.models import User
    from rest_framework.authtoken.models import Token

    for user in User.objects.all():
        Token.objects.get_or_create(user=user)
    ```

    #### By exposing an api endpoint

    When using `TokenAuthentication`, you may want to provide a mechanism for clients to obtain a token given the username and password. REST framework provides a built-in view to provide this behavior. To use it, add the `obtain_auth_token` view to your URLconf:

    ``` python
    from rest_framework.authtoken import views
    urlpatterns += [
        path('api-token-auth/', views.obtain_auth_token)
    ]
    ```

    Note that the URL part of the pattern can be whatever you want to use.

    The `obtain_auth_token` view will return a JSON response when valid `username` and `password` fields are POSTed to the view using form data or JSON:

    ``` python
    { 'token' : '9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b' }
    ```

    Note that the default `obtain_auth_token` view explicitly uses JSON requests and responses, rather than using default renderer and parser classes in your settings.

    By default, there are no permissions or throttling applied to the `obtain_auth_token` view. If you do wish to apply throttling you'll need to override the view class, and include them using the `throttle_classes` attribute.

    If you need a customized version of the `obtain_auth_token` view, you can do so by subclassing the `ObtainAuthToken` view class, and using that in your url conf instead.

    For example, you may return additional user information beyond the `token` value:

    ``` python
    from rest_framework.authtoken.views import ObtainAuthToken
    from rest_framework.authtoken.models import Token
    from rest_framework.response import Response

    class CustomAuthToken(ObtainAuthToken):

        def post(self, request, *args, **kwargs):
            serializer = self.serializer_class(data=request.data,
                                               context={'request': request})
            serializer.is_valid(raise_exception=True)
            user = serializer.validated_data['user']
            token, created = Token.objects.get_or_create(user=user)
            return Response({
                'token': token.key,
                'user_id': user.pk,
                'email': user.email
            })
    ```

    And in your `urls.py`:

    ``` python
    urlpatterns += [
        path('api-token-auth/', CustomAuthToken.as_view())
    ]
    ```

    #### With Django admin

    It is also possible to create Tokens manually through the admin interface. In case you are using a large user base, we recommend that you monkey patch the `TokenAdmin` class to customize it to your needs, more specifically by declaring the `user` field as `raw_field`.

    `your_app/admin.py`:

    ``` python
    from rest_framework.authtoken.admin import TokenAdmin

    TokenAdmin.raw_id_fields = ['user']
    ```

    #### Using Django manage.py command

    Since version 3.6.4 it's possible to generate a user token using the following command:

    ``` python
    ./manage.py drf_create_token <username>
    ```

    this command will return the API token for the given user, creating it if it doesn't exist:

    ``` python
    Generated token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b for user user1
    ```

    In case you want to regenerate the token (for example if it has been compromised or leaked) you can pass an additional parameter:

    ``` python
    ./manage.py drf_create_token -r <username>
    ```
- name: UniqueForDateValidator
  id: api-guide/validators/index#uniquefordatevalidator
  summary: null
  belongs_to: Validators
  description: '## UniqueForDateValidator'
- name: UniqueForMonthValidator
  id: api-guide/validators/index#uniqueformonthvalidator
  summary: null
  belongs_to: Validators
  description: '## UniqueForMonthValidator'
- name: UniqueForYearValidator
  id: api-guide/validators/index#uniqueforyearvalidator
  summary: These validators can be used to enforce the unique_for_date, unique_for_month and unique_for_year constraints on model instances
  belongs_to: Validators
  description: "## UniqueForYearValidator\n\nThese validators can be used to enforce the `unique_for_date`, `unique_for_month` and `unique_for_year` constraints on model instances. They take the following arguments:\n\n- `queryset`*required* - This is the queryset against which uniqueness should be enforced.\n- `field`*required* - A field name against which uniqueness in the given date range will be validated. This must exist as a field on the serializer class.\n- `date_field`*required* - A field name which will be used to determine date range for the uniqueness constrain. This must exist as a field on the serializer class.\n- `message` - The error message that should be used when validation fails.\n\nThe validator should be applied to *serializer classes*, like so:\n\n``` python\nfrom rest_framework.validators import UniqueForYearValidator\n\nclass ExampleSerializer(serializers.Serializer):\n    # ...\n    class Meta:\n        # Blog posts should have a slug that is unique for the current year.\n        validators = [\n            UniqueForYearValidator(\n                queryset=BlogPostItem.objects.all(),\n                field='slug',\n                date_field='published'\n            )\n        ]\n```\n\nThe date field that is used for the validation is always required to be present on the serializer class. You can't simply rely on a model class `default=...`, because the value being used for the default wouldn't be generated until after the validation has run.\n\nThere are a couple of styles you may want to use for this depending on how you want your API to behave. If you're using `ModelSerializer` you'll probably simply rely on the defaults that REST framework generates for you, but if you are using `Serializer` or simply want more explicit control, use on of the styles demonstrated below.\n\n#### Using with a writable date field.\n\nIf you want the date field to be writable the only thing worth noting is that you should ensure that it is always available in the input data, either by setting a `default` argument, or by setting `required=True`.\n\n``` python\npublished = serializers.DateTimeField(required=True)\n```\n\n#### Using with a read-only date field.\n\nIf you want the date field to be visible, but not editable by the user, then set `read_only=True` and additionally set a `default=...` argument.\n\n``` python\npublished = serializers.DateTimeField(read_only=True, default=timezone.now)\n```\n\n#### Using with a hidden date field.\n\nIf you want the date field to be entirely hidden from the user, then use `HiddenField`. This field type does not accept user input, but instead always returns its default value to the `validated_data` in the serializer.\n\n``` python\npublished = serializers.HiddenField(default=timezone.now)\n```\n\n**Note**: The `UniqueFor<Range>Validator` classes impose an implicit constraint that the fields they are applied to are always treated as required. Fields with `default` values are an exception to this as they always supply a value even when omitted from user input.\n\n**Note:**`HiddenField()` does not appear in `partial=True` serializer (when making `PATCH` request). This behavior might change in future, follow updates on [github discussion](https://github.com/encode/django-rest-framework/discussions/8259).\n\n# Advanced field defaults\n\nValidators that are applied across multiple fields in the serializer can sometimes require a field input that should not be provided by the API client, but that *is* available as input to the validator. For this purposes use `HiddenField`. This field will be present in `validated_data` but *will not* be used in the serializer output representation.\n\n**Note:** Using a `read_only=True` field is excluded from writable fields so it won't use a `default=…` argument. Look [3.8 announcement](https://www.django-rest-framework.org/community/3.8-announcement/#altered-the-behaviour-of-read_only-plus-default-on-field).\n\nREST framework includes a couple of defaults that may be useful in this context.\n\n#### CurrentUserDefault\n\nA default class that can be used to represent the current user. In order to use this, the 'request' must have been provided as part of the context dictionary when instantiating the serializer.\n\n``` python\nowner = serializers.HiddenField(\n    default=serializers.CurrentUserDefault()\n)\n```\n\n#### CreateOnlyDefault\n\nA default class that can be used to *only set a default argument during create operations*. During updates the field is omitted.\n\nIt takes a single argument, which is the default value or callable that should be used during create operations.\n\n``` python\ncreated_at = serializers.DateTimeField(\n    default=serializers.CreateOnlyDefault(timezone.now)\n)\n```\n\n# Limitations of validators\n\nThere are some ambiguous cases where you'll need to instead handle validation explicitly, rather than relying on the default serializer classes that `ModelSerializer` generates.\n\nIn these cases you may want to disable the automatically generated validators, by specifying an empty list for the serializer `Meta.validators` attribute.\n\n## Optional fields\n\nBy default \"unique together\" validation enforces that all fields be `required=True`. In some cases, you might want to explicit apply `required=False` to one of the fields, in which case the desired behavior of the validation is ambiguous.\n\nIn this case you will typically need to exclude the validator from the serializer class, and instead write any validation logic explicitly, either in the `.validate()` method, or else in the view.\n\nFor example:\n\n``` python\nclass BillingRecordSerializer(serializers.ModelSerializer):\n    def validate(self, attrs):\n        # Apply custom validation either here, or in the view.\n\n    class Meta:\n        fields = ['client', 'date', 'amount']\n        extra_kwargs = {'client': {'required': False}}\n        validators = []  # Remove a default \"unique together\" constraint.\n```\n\n## Updating nested serializers\n\nWhen applying an update to an existing instance, uniqueness validators will exclude the current instance from the uniqueness check. The current instance is available in the context of the uniqueness check, because it exists as an attribute on the serializer, having initially been passed using `instance=...` when instantiating the serializer.\n\nIn the case of update operations on *nested* serializers there's no way of applying this exclusion, because the instance is not available.\n\nAgain, you'll probably want to explicitly remove the validator from the serializer class, and write the code for the validation constraint explicitly, in a `.validate()` method, or in the view.\n\n## Debugging complex cases\n\nIf you're not sure exactly what behavior a `ModelSerializer` class will generate it is usually a good idea to run `manage.py shell`, and print an instance of the serializer, so that you can inspect the fields and validators that it automatically generates for you.\n\n``` python\n>>> serializer = MyComplexModelSerializer()\n>>> print(serializer)\nclass MyComplexModelSerializer:\n    my_fields = ...\n```\n\nAlso keep in mind that with complex cases it can often be better to explicitly define your serializer classes, rather than relying on the default `ModelSerializer` behavior. This involves a little more code, but ensures that the resulting behavior is more transparent.\n\n# Writing custom validators\n\nYou can use any of Django's existing validators, or write your own custom validators.\n\n## Function based\n\nA validator may be any callable that raises a `serializers.ValidationError` on failure.\n\n``` python\ndef even_number(value):\n    if value % 2 != 0:\n        raise serializers.ValidationError('This field must be an even number.')\n```\n\n#### Field-level validation\n\nYou can specify custom field-level validation by adding `.validate_<field_name>` methods to your `Serializer` subclass. This is documented in the [Serializer docs](../serializers/index#field-level-validation)\n\n## Class-based\n\nTo write a class-based validator, use the `__call__` method. Class-based validators are useful as they allow you to parameterize and reuse behavior.\n\n``` python\nclass MultipleOf:\n    def __init__(self, base):\n        self.base = base\n\n    def __call__(self, value):\n        if value % self.base != 0:\n            message = 'This field must be a multiple of %d.' % self.base\n            raise serializers.ValidationError(message)\n```\n\n#### Accessing the context\n\nIn some advanced cases you might want a validator to be passed the serializer field it is being used with as additional context. You can do so by setting a `requires_context = True` attribute on the validator class. The `__call__` method will then be called with the `serializer_field` or `serializer` as an additional argument.\n\n``` python\nclass MultipleOf:\n    requires_context = True\n\n    def __call__(self, value, serializer_field):\n        ...\n```\n\n[validators.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/validators.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/validators/](https://www.django-rest-framework.org/api-guide/validators/)"
- name: UniqueTogetherValidator
  id: api-guide/validators/index#uniquetogethervalidator
  summary: This validator can be used to enforce unique_together constraints on model instances
  belongs_to: Validators
  description: |-
    ## UniqueTogetherValidator

    This validator can be used to enforce `unique_together` constraints on model instances. It has two required arguments, and a single optional `messages` argument:

    - `queryset`*required* - This is the queryset against which uniqueness should be enforced.
    - `fields`*required* - A list or tuple of field names which should make a unique set. These must exist as fields on the serializer class.
    - `message` - The error message that should be used when validation fails.

    The validator should be applied to *serializer classes*, like so:

    ``` python
    from rest_framework.validators import UniqueTogetherValidator

    class ExampleSerializer(serializers.Serializer):
        # ...
        class Meta:
            # ToDo items belong to a parent list, and have an ordering defined
            # by the 'position' field. No two items in a given list may share
            # the same position.
            validators = [
                UniqueTogetherValidator(
                    queryset=ToDoItem.objects.all(),
                    fields=['list', 'position']
                )
            ]
    ```

    **Note**: The `UniqueTogetherValidator` class always imposes an implicit constraint that all the fields it applies to are always treated as required. Fields with `default` values are an exception to this as they always supply a value even when omitted from user input.
- name: UniqueValidator
  id: api-guide/validators/index#uniquevalidator
  summary: This validator can be used to enforce the unique=True constraint on model fields
  belongs_to: Validators
  description: |-
    ## UniqueValidator

    This validator can be used to enforce the `unique=True` constraint on model fields. It takes a single required argument, and an optional `messages` argument:

    - `queryset`*required* - This is the queryset against which uniqueness should be enforced.
    - `message` - The error message that should be used when validation fails.
    - `lookup` - The lookup used to find an existing instance with the value being validated. Defaults to `'exact'`.

    This validator should be applied to *serializer fields*, like so:

    ``` python
    from rest_framework.validators import UniqueValidator

    slug = SlugField(
        max_length=100,
        validators=[UniqueValidator(queryset=BlogPost.objects.all())]
    )
    ```
- name: UnsupportedMediaType
  id: api-guide/exceptions/index#unsupportedmediatype
  summary: Raised if there are no parsers that can handle the content type of the request data when accessing request.data
  belongs_to: Exceptions
  description: |-
    ## UnsupportedMediaType

    **Signature:** `UnsupportedMediaType(media_type, detail=None, code=None)`

    Raised if there are no parsers that can handle the content type of the request data when accessing `request.data`.

    By default this exception results in a response with the HTTP status code "415 Unsupported Media Type".
- name: UpdateAPIView
  id: api-guide/generic-views/index#updateapiview
  summary: Used for update-only endpoints for a single model instance
  belongs_to: Generic views
  description: |-
    ## UpdateAPIView

    Used for **update-only** endpoints for a **single model instance**.

    Provides `put` and `patch` method handlers.

    Extends: [GenericAPIView](#genericapiview), [UpdateModelMixin](#updatemodelmixin)
- name: UpdateModelMixin
  id: api-guide/generic-views/index#updatemodelmixin
  summary: Provides a .update(request, *args, **kwargs) method, that implements updating and saving an existing model instance
  belongs_to: Generic views
  description: |-
    ## UpdateModelMixin

    Provides a `.update(request, *args, **kwargs)` method, that implements updating and saving an existing model instance.

    Also provides a `.partial_update(request, *args, **kwargs)` method, which is similar to the `update` method, except that all fields for the update will be optional. This allows support for HTTP `PATCH` requests.

    If an object is updated this returns a `200 OK` response, with a serialized representation of the object as the body of the response.

    If the request data provided for updating the object was invalid, a `400 Bad Request` response will be returned, with the error details as the body of the response.
- name: URLField
  id: api-guide/fields/index#urlfield
  summary: A RegexField that validates the input against a URL matching pattern
  belongs_to: Serializer fields
  description: |-
    ## URLField

    A `RegexField` that validates the input against a URL matching pattern. Expects fully qualified URLs of the form `http://<host>/<path>`.

    Corresponds to `django.db.models.fields.URLField`. Uses Django's `django.core.validators.URLValidator` for validation.

    **Signature:** `URLField(max_length=200, min_length=None, allow_blank=False)`
- name: URLPathVersioning
  id: api-guide/versioning/index#urlpathversioning
  summary: This scheme requires the client to specify the version as part of the URL path
  belongs_to: Versioning
  description: |-
    ## URLPathVersioning

    This scheme requires the client to specify the version as part of the URL path.

    ``` python
    GET /v1/bookings/ HTTP/1.1
    Host: example.com
    Accept: application/json
    ```

    Your URL conf must include a pattern that matches the version with a `'version'` keyword argument, so that this information is available to the versioning scheme.

    ``` python
    urlpatterns = [
        re_path(
            r'^(?P<version>(v1|v2))/bookings/$',
            bookings_list,
            name='bookings-list'
        ),
        re_path(
            r'^(?P<version>(v1|v2))/bookings/(?P<pk>[0-9]+)/$',
            bookings_detail,
            name='bookings-detail'
        )
    ]
    ```
- name: UserRateThrottle
  id: api-guide/throttling/index#userratethrottle
  summary: The UserRateThrottle will throttle users to a given rate of requests across the API
  belongs_to: Throttling
  description: |-
    ## UserRateThrottle

    The `UserRateThrottle` will throttle users to a given rate of requests across the API. The user id is used to generate a unique key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against.

    The allowed request rate is determined from one of the following (in order of preference).

    - The `rate` property on the class, which may be provided by overriding `UserRateThrottle` and setting the property.
    - The `DEFAULT_THROTTLE_RATES['user']` setting.

    An API may have multiple `UserRateThrottles` in place at the same time. To do so, override `UserRateThrottle` and set a unique "scope" for each class.

    For example, multiple user throttle rates could be implemented by using the following classes...

    ``` python
    class BurstRateThrottle(UserRateThrottle):
        scope = 'burst'

    class SustainedRateThrottle(UserRateThrottle):
        scope = 'sustained'
    ```

    ...and the following settings.

    ``` python
    REST_FRAMEWORK = {
        'DEFAULT_THROTTLE_CLASSES': [
            'example.throttles.BurstRateThrottle',
            'example.throttles.SustainedRateThrottle'
        ],
        'DEFAULT_THROTTLE_RATES': {
            'burst': '60/min',
            'sustained': '1000/day'
        }
    }
    ```

    `UserRateThrottle` is suitable if you want simple global rate restrictions per-user.
- name: UUIDField
  id: api-guide/fields/index#uuidfield
  summary: A field that ensures the input is a valid UUID string
  belongs_to: Serializer fields
  description: |-
    ## UUIDField

    A field that ensures the input is a valid UUID string. The `to_internal_value` method will return a `uuid.UUID` instance. On output the field will return a string in the canonical hyphenated format, for example:

    ``` python
    "de305d54-75b4-431b-adb2-eb6b9e546013"
    ```

    **Signature:** `UUIDField(format='hex_verbose')`

    - `format`: Determines the representation format of the uuid value
      - `'hex_verbose'` - The canonical hex representation, including hyphens: `"5ce0e9a5-5ffa-654b-cee0-1238041fb31a"`
      - `'hex'` - The compact hex representation of the UUID, not including hyphens: `"5ce0e9a55ffa654bcee01238041fb31a"`
      - `'int'` - A 128 bit integer representation of the UUID: `"123456789012312313134124512351145145114"`
      - `'urn'` - RFC 4122 URN representation of the UUID: `"urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a"` Changing the `format` parameters only affects representation values. All formats are accepted by `to_internal_value`
- name: ValidationError
  id: api-guide/exceptions/index#validationerror
  summary: The ValidationError class should be used for serializer and field validation, and by validator classes
  belongs_to: Exceptions
  description: "## ValidationError\n\n**Signature:** `ValidationError(detail=None, code=None)`\n\nThe `ValidationError` exception is slightly different from the other `APIException` classes:\n\n- The `detail` argument may be a list or dictionary of error details, and may also be a nested data structure. By using a dictionary, you can specify field-level errors while performing object-level validation in the `validate()` method of a serializer. For example. `raise serializers.ValidationError({'name': 'Please enter a valid name.'})`\n- By convention you should import the serializers module and use a fully qualified `ValidationError` style, in order to differentiate it from Django's built-in validation error. For example. `raise serializers.ValidationError('This field must be an integer value.')`\n\nThe `ValidationError` class should be used for serializer and field validation, and by validator classes. It is also raised when calling `serializer.is_valid` with the `raise_exception` keyword argument:\n\n``` python\nserializer.is_valid(raise_exception=True)\n```\n\nThe generic views use the `raise_exception=True` flag, which means that you can override the style of validation error responses globally in your API. To do so, use a custom exception handler, as described above.\n\nBy default this exception results in a response with the HTTP status code \"400 Bad Request\".\n\n# Generic Error Views\n\nDjango REST Framework provides two error views suitable for providing generic JSON `500` Server Error and `400` Bad Request responses. (Django's default error views provide HTML responses, which may not be appropriate for an API-only application.)\n\nUse these as per [Django's Customizing error views documentation](https://docs.djangoproject.com/en/dev/topics/http/views/#customizing-error-views).\n\n## rest_framework.exceptions.server_error\n\nReturns a response with status code `500` and `application/json` content type.\n\nSet as `handler500`:\n\n``` python\nhandler500 = 'rest_framework.exceptions.server_error'\n```\n\n## rest_framework.exceptions.bad_request\n\nReturns a response with status code `400` and `application/json` content type.\n\nSet as `handler400`:\n\n``` python\nhandler400 = 'rest_framework.exceptions.bad_request'\n```\n\n# Third party packages\n\nThe following third-party packages are also available.\n\n## DRF Standardized Errors\n\nThe [drf-standardized-errors](https://github.com/ghazi-git/drf-standardized-errors) package provides an exception handler that generates the same format for all 4xx and 5xx responses. It is a drop-in replacement for the default exception handler and allows customizing the error response format without rewriting the whole exception handler. The standardized error response format is easier to document and easier to handle by API consumers.\n\n[exceptions.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/exceptions.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/exceptions/](https://www.django-rest-framework.org/api-guide/exceptions/)"
- name: Validators
  id: api-guide/validators/index
  summary: Validators can be useful for re-using validation logic between different types of fields
  description: "# Validators\n\n> Validators can be useful for re-using validation logic between different types of fields.\n>\n> — [Django documentation](https://docs.djangoproject.com/en/stable/ref/validators/)\n\nMost of the time you're dealing with validation in REST framework you'll simply be relying on the default field validation, or writing explicit validation methods on serializer or field classes.\n\nHowever, sometimes you'll want to place your validation logic into reusable components, so that it can easily be reused throughout your codebase. This can be achieved by using validator functions and validator classes.\n\n## Validation in REST framework\n\nValidation in Django REST framework serializers is handled a little differently to how validation works in Django's `ModelForm` class.\n\nWith `ModelForm` the validation is performed partially on the form, and partially on the model instance. With REST framework the validation is performed entirely on the serializer class. This is advantageous for the following reasons:\n\n- It introduces a proper separation of concerns, making your code behavior more obvious.\n- It is easy to switch between using shortcut `ModelSerializer` classes and using explicit `Serializer` classes. Any validation behavior being used for `ModelSerializer` is simple to replicate.\n- Printing the `repr` of a serializer instance will show you exactly what validation rules it applies. There's no extra hidden validation behavior being called on the model instance.\n\nWhen you're using `ModelSerializer` all of this is handled automatically for you. If you want to drop down to using `Serializer` classes instead, then you need to define the validation rules explicitly.\n\n#### Example\n\nAs an example of how REST framework uses explicit validation, we'll take a simple model class that has a field with a uniqueness constraint.\n\n``` python\nclass CustomerReportRecord(models.Model):\n    time_raised = models.DateTimeField(default=timezone.now, editable=False)\n    reference = models.CharField(unique=True, max_length=20)\n    description = models.TextField()\n```\n\nHere's a basic `ModelSerializer` that we can use for creating or updating instances of `CustomerReportRecord`:\n\n``` python\nclass CustomerReportSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = CustomerReportRecord\n```\n\nIf we open up the Django shell using `manage.py shell` we can now\n\n``` python\n>>> from project.example.serializers import CustomerReportSerializer\n>>> serializer = CustomerReportSerializer()\n>>> print(repr(serializer))\nCustomerReportSerializer():\n    id = IntegerField(label='ID', read_only=True)\n    time_raised = DateTimeField(read_only=True)\n    reference = CharField(max_length=20, validators=[<UniqueValidator(queryset=CustomerReportRecord.objects.all())>])\n    description = CharField(style={'type': 'textarea'})\n```\n\nThe interesting bit here is the `reference` field. We can see that the uniqueness constraint is being explicitly enforced by a validator on the serializer field.\n\nBecause of this more explicit style REST framework includes a few validator classes that are not available in core Django. These classes are detailed below. REST framework validators, like their Django counterparts, implement the `__eq__` method, allowing you to compare instances for equality.\n\n## UniqueValidator\n\nThis validator can be used to enforce the `unique=True` constraint on model fields. It takes a single required argument, and an optional `messages` argument:\n\n- `queryset` *required* - This is the queryset against which uniqueness should be enforced.\n- `message` - The error message that should be used when validation fails.\n- `lookup` - The lookup used to find an existing instance with the value being validated. Defaults to `'exact'`.\n\nThis validator should be applied to *serializer fields*, like so:\n\n``` python\nfrom rest_framework.validators import UniqueValidator\n\nslug = SlugField(\n    max_length=100,\n    validators=[UniqueValidator(queryset=BlogPost.objects.all())]\n)\n```\n\n## UniqueTogetherValidator\n\nThis validator can be used to enforce `unique_together` constraints on model instances. It has two required arguments, and a single optional `messages` argument:\n\n- `queryset` *required* - This is the queryset against which uniqueness should be enforced.\n- `fields` *required* - A list or tuple of field names which should make a unique set. These must exist as fields on the serializer class.\n- `message` - The error message that should be used when validation fails.\n\nThe validator should be applied to *serializer classes*, like so:\n\n``` python\nfrom rest_framework.validators import UniqueTogetherValidator\n\nclass ExampleSerializer(serializers.Serializer):\n    # ...\n    class Meta:\n        # ToDo items belong to a parent list, and have an ordering defined\n        # by the 'position' field. No two items in a given list may share\n        # the same position.\n        validators = [\n            UniqueTogetherValidator(\n                queryset=ToDoItem.objects.all(),\n                fields=['list', 'position']\n            )\n        ]\n```\n\n**Note**: The `UniqueTogetherValidator` class always imposes an implicit constraint that all the fields it applies to are always treated as required. Fields with `default` values are an exception to this as they always supply a value even when omitted from user input.\n\n## UniqueForDateValidator\n\n## UniqueForMonthValidator\n\n## UniqueForYearValidator\n\nThese validators can be used to enforce the `unique_for_date`, `unique_for_month` and `unique_for_year` constraints on model instances. They take the following arguments:\n\n- `queryset` *required* - This is the queryset against which uniqueness should be enforced.\n- `field` *required* - A field name against which uniqueness in the given date range will be validated. This must exist as a field on the serializer class.\n- `date_field` *required* - A field name which will be used to determine date range for the uniqueness constrain. This must exist as a field on the serializer class.\n- `message` - The error message that should be used when validation fails.\n\nThe validator should be applied to *serializer classes*, like so:\n\n``` python\nfrom rest_framework.validators import UniqueForYearValidator\n\nclass ExampleSerializer(serializers.Serializer):\n    # ...\n    class Meta:\n        # Blog posts should have a slug that is unique for the current year.\n        validators = [\n            UniqueForYearValidator(\n                queryset=BlogPostItem.objects.all(),\n                field='slug',\n                date_field='published'\n            )\n        ]\n```\n\nThe date field that is used for the validation is always required to be present on the serializer class. You can't simply rely on a model class `default=...`, because the value being used for the default wouldn't be generated until after the validation has run.\n\nThere are a couple of styles you may want to use for this depending on how you want your API to behave. If you're using `ModelSerializer` you'll probably simply rely on the defaults that REST framework generates for you, but if you are using `Serializer` or simply want more explicit control, use on of the styles demonstrated below.\n\n#### Using with a writable date field.\n\nIf you want the date field to be writable the only thing worth noting is that you should ensure that it is always available in the input data, either by setting a `default` argument, or by setting `required=True`.\n\n``` python\npublished = serializers.DateTimeField(required=True)\n```\n\n#### Using with a read-only date field.\n\nIf you want the date field to be visible, but not editable by the user, then set `read_only=True` and additionally set a `default=...` argument.\n\n``` python\npublished = serializers.DateTimeField(read_only=True, default=timezone.now)\n```\n\n#### Using with a hidden date field.\n\nIf you want the date field to be entirely hidden from the user, then use `HiddenField`. This field type does not accept user input, but instead always returns its default value to the `validated_data` in the serializer.\n\n``` python\npublished = serializers.HiddenField(default=timezone.now)\n```\n\n**Note**: The `UniqueFor<Range>Validator` classes impose an implicit constraint that the fields they are applied to are always treated as required. Fields with `default` values are an exception to this as they always supply a value even when omitted from user input.\n\n**Note:** `HiddenField()` does not appear in `partial=True` serializer (when making `PATCH` request). This behavior might change in future, follow updates on [github discussion](https://github.com/encode/django-rest-framework/discussions/8259).\n\n# Advanced field defaults\n\nValidators that are applied across multiple fields in the serializer can sometimes require a field input that should not be provided by the API client, but that *is* available as input to the validator. For this purposes use `HiddenField`. This field will be present in `validated_data` but *will not* be used in the serializer output representation.\n\n**Note:** Using a `read_only=True` field is excluded from writable fields so it won't use a `default=…` argument. Look [3.8 announcement](https://www.django-rest-framework.org/community/3.8-announcement/#altered-the-behaviour-of-read_only-plus-default-on-field).\n\nREST framework includes a couple of defaults that may be useful in this context.\n\n#### CurrentUserDefault\n\nA default class that can be used to represent the current user. In order to use this, the 'request' must have been provided as part of the context dictionary when instantiating the serializer.\n\n``` python\nowner = serializers.HiddenField(\n    default=serializers.CurrentUserDefault()\n)\n```\n\n#### CreateOnlyDefault\n\nA default class that can be used to *only set a default argument during create operations*. During updates the field is omitted.\n\nIt takes a single argument, which is the default value or callable that should be used during create operations.\n\n``` python\ncreated_at = serializers.DateTimeField(\n    default=serializers.CreateOnlyDefault(timezone.now)\n)\n```\n\n# Limitations of validators\n\nThere are some ambiguous cases where you'll need to instead handle validation explicitly, rather than relying on the default serializer classes that `ModelSerializer` generates.\n\nIn these cases you may want to disable the automatically generated validators, by specifying an empty list for the serializer `Meta.validators` attribute.\n\n## Optional fields\n\nBy default \"unique together\" validation enforces that all fields be `required=True`. In some cases, you might want to explicit apply `required=False` to one of the fields, in which case the desired behavior of the validation is ambiguous.\n\nIn this case you will typically need to exclude the validator from the serializer class, and instead write any validation logic explicitly, either in the `.validate()` method, or else in the view.\n\nFor example:\n\n``` python\nclass BillingRecordSerializer(serializers.ModelSerializer):\n    def validate(self, attrs):\n        # Apply custom validation either here, or in the view.\n\n    class Meta:\n        fields = ['client', 'date', 'amount']\n        extra_kwargs = {'client': {'required': False}}\n        validators = []  # Remove a default \"unique together\" constraint.\n```\n\n## Updating nested serializers\n\nWhen applying an update to an existing instance, uniqueness validators will exclude the current instance from the uniqueness check. The current instance is available in the context of the uniqueness check, because it exists as an attribute on the serializer, having initially been passed using `instance=...` when instantiating the serializer.\n\nIn the case of update operations on *nested* serializers there's no way of applying this exclusion, because the instance is not available.\n\nAgain, you'll probably want to explicitly remove the validator from the serializer class, and write the code for the validation constraint explicitly, in a `.validate()` method, or in the view.\n\n## Debugging complex cases\n\nIf you're not sure exactly what behavior a `ModelSerializer` class will generate it is usually a good idea to run `manage.py shell`, and print an instance of the serializer, so that you can inspect the fields and validators that it automatically generates for you.\n\n``` python\n>>> serializer = MyComplexModelSerializer()\n>>> print(serializer)\nclass MyComplexModelSerializer:\n    my_fields = ...\n```\n\nAlso keep in mind that with complex cases it can often be better to explicitly define your serializer classes, rather than relying on the default `ModelSerializer` behavior. This involves a little more code, but ensures that the resulting behavior is more transparent.\n\n# Writing custom validators\n\nYou can use any of Django's existing validators, or write your own custom validators.\n\n## Function based\n\nA validator may be any callable that raises a `serializers.ValidationError` on failure.\n\n``` python\ndef even_number(value):\n    if value % 2 != 0:\n        raise serializers.ValidationError('This field must be an even number.')\n```\n\n#### Field-level validation\n\nYou can specify custom field-level validation by adding `.validate_<field_name>` methods to your `Serializer` subclass. This is documented in the [Serializer docs](../serializers/index#field-level-validation)\n\n## Class-based\n\nTo write a class-based validator, use the `__call__` method. Class-based validators are useful as they allow you to parameterize and reuse behavior.\n\n``` python\nclass MultipleOf:\n    def __init__(self, base):\n        self.base = base\n\n    def __call__(self, value):\n        if value % self.base != 0:\n            message = 'This field must be a multiple of %d.' % self.base\n            raise serializers.ValidationError(message)\n```\n\n#### Accessing the context\n\nIn some advanced cases you might want a validator to be passed the serializer field it is being used with as additional context. You can do so by setting a `requires_context = True` attribute on the validator class. The `__call__` method will then be called with the `serializer_field` or `serializer` as an additional argument.\n\n``` python\nclass MultipleOf:\n    requires_context = True\n\n    def __call__(self, value, serializer_field):\n        ...\n```\n\n[validators.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/validators.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/validators/](https://www.django-rest-framework.org/api-guide/validators/)"
- name: Versioning
  id: api-guide/versioning/index
  summary: Versioning an interface is just a "polite" way to kill deployed clients
  description: "# Versioning\n\n> Versioning an interface is just a \"polite\" way to kill deployed clients.\n>\n> — [Roy Fielding](https://www.slideshare.net/evolve_conference/201308-fielding-evolve/31).\n\nAPI versioning allows you to alter behavior between different clients. REST framework provides for a number of different versioning schemes.\n\nVersioning is determined by the incoming client request, and may either be based on the request URL, or based on the request headers.\n\nThere are a number of valid approaches to approaching versioning. [Non-versioned systems can also be appropriate](https://www.infoq.com/articles/roy-fielding-on-versioning), particularly if you're engineering for very long-term systems with multiple clients outside of your control.\n\n## Versioning with REST framework\n\nWhen API versioning is enabled, the `request.version` attribute will contain a string that corresponds to the version requested in the incoming client request.\n\nBy default, versioning is not enabled, and `request.version` will always return `None`.\n\n#### Varying behavior based on the version\n\nHow you vary the API behavior is up to you, but one example you might typically want is to switch to a different serialization style in a newer version. For example:\n\n``` python\ndef get_serializer_class(self):\n    if self.request.version == 'v1':\n        return AccountSerializerVersion1\n    return AccountSerializer\n```\n\n#### Reversing URLs for versioned APIs\n\nThe `reverse` function included by REST framework ties in with the versioning scheme. You need to make sure to include the current `request` as a keyword argument, like so.\n\n``` python\nfrom rest_framework.reverse import reverse\n\nreverse('bookings-list', request=request)\n```\n\nThe above function will apply any URL transformations appropriate to the request version. For example:\n\n- If `NamespaceVersioning` was being used, and the API version was 'v1', then the URL lookup used would be `'v1:bookings-list'`, which might resolve to a URL like `http://example.org/v1/bookings/`.\n- If `QueryParameterVersioning` was being used, and the API version was `1.0`, then the returned URL might be something like `http://example.org/bookings/?version=1.0`\n\n#### Versioned APIs and hyperlinked serializers\n\nWhen using hyperlinked serialization styles together with a URL based versioning scheme make sure to include the request as context to the serializer.\n\n``` python\ndef get(self, request):\n    queryset = Booking.objects.all()\n    serializer = BookingsSerializer(queryset, many=True, context={'request': request})\n    return Response({'all_bookings': serializer.data})\n```\n\nDoing so will allow any returned URLs to include the appropriate versioning.\n\n## Configuring the versioning scheme\n\nThe versioning scheme is defined by the `DEFAULT_VERSIONING_CLASS` settings key.\n\n``` python\nREST_FRAMEWORK = {\n    'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning'\n}\n```\n\nUnless it is explicitly set, the value for `DEFAULT_VERSIONING_CLASS` will be `None`. In this case the `request.version` attribute will always return `None`.\n\nYou can also set the versioning scheme on an individual view. Typically you won't need to do this, as it makes more sense to have a single versioning scheme used globally. If you do need to do so, use the `versioning_class` attribute.\n\n``` python\nclass ProfileList(APIView):\n    versioning_class = versioning.QueryParameterVersioning\n```\n\n#### Other versioning settings\n\nThe following settings keys are also used to control versioning:\n\n- `DEFAULT_VERSION`. The value that should be used for `request.version` when no versioning information is present. Defaults to `None`.\n- `ALLOWED_VERSIONS`. If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version is not in this set. Note that the value used for the `DEFAULT_VERSION` setting is always considered to be part of the `ALLOWED_VERSIONS` set (unless it is `None`). Defaults to `None`.\n- `VERSION_PARAM`. The string that should be used for any versioning parameters, such as in the media type or URL query parameters. Defaults to `'version'`.\n\nYou can also set your versioning class plus those three values on a per-view or a per-viewset basis by defining your own versioning scheme and using the `default_version`, `allowed_versions` and `version_param` class variables. For example, if you want to use `URLPathVersioning`:\n\n``` python\nfrom rest_framework.versioning import URLPathVersioning\nfrom rest_framework.views import APIView\n\nclass ExampleVersioning(URLPathVersioning):\n    default_version = ...\n    allowed_versions = ...\n    version_param = ...\n\nclass ExampleView(APIVIew):\n    versioning_class = ExampleVersioning\n```\n\n# API Reference\n\n## AcceptHeaderVersioning\n\nThis scheme requires the client to specify the version as part of the media type in the `Accept` header. The version is included as a media type parameter, that supplements the main media type.\n\nHere's an example HTTP request using the accept header versioning style.\n\n``` python\nGET /bookings/ HTTP/1.1\nHost: example.com\nAccept: application/json; version=1.0\n```\n\nIn the example request above `request.version` attribute would return the string `'1.0'`.\n\nVersioning based on accept headers is [generally considered](http://blog.steveklabnik.com/posts/2011-07-03-nobody-understands-rest-or-http#i_want_my_api_to_be_versioned) as [best practice](https://github.com/interagent/http-api-design/blob/master/en/foundations/require-versioning-in-the-accepts-header.md), although other styles may be suitable depending on your client requirements.\n\n#### Using accept headers with vendor media types\n\nStrictly speaking the `json` media type is not specified as [including additional parameters](https://tools.ietf.org/html/rfc4627#section-6). If you are building a well-specified public API you might consider using a [vendor media type](https://en.wikipedia.org/wiki/Internet_media_type#Vendor_tree). To do so, configure your renderers to use a JSON based renderer with a custom media type:\n\n``` python\nclass BookingsAPIRenderer(JSONRenderer):\n    media_type = 'application/vnd.megacorp.bookings+json'\n```\n\nYour client requests would now look like this:\n\n``` python\nGET /bookings/ HTTP/1.1\nHost: example.com\nAccept: application/vnd.megacorp.bookings+json; version=1.0\n```\n\n## URLPathVersioning\n\nThis scheme requires the client to specify the version as part of the URL path.\n\n``` python\nGET /v1/bookings/ HTTP/1.1\nHost: example.com\nAccept: application/json\n```\n\nYour URL conf must include a pattern that matches the version with a `'version'` keyword argument, so that this information is available to the versioning scheme.\n\n``` python\nurlpatterns = [\n    re_path(\n        r'^(?P<version>(v1|v2))/bookings/$',\n        bookings_list,\n        name='bookings-list'\n    ),\n    re_path(\n        r'^(?P<version>(v1|v2))/bookings/(?P<pk>[0-9]+)/$',\n        bookings_detail,\n        name='bookings-detail'\n    )\n]\n```\n\n## NamespaceVersioning\n\nTo the client, this scheme is the same as `URLPathVersioning`. The only difference is how it is configured in your Django application, as it uses URL namespacing, instead of URL keyword arguments.\n\n``` python\nGET /v1/something/ HTTP/1.1\nHost: example.com\nAccept: application/json\n```\n\nWith this scheme the `request.version` attribute is determined based on the `namespace` that matches the incoming request path.\n\nIn the following example we're giving a set of views two different possible URL prefixes, each under a different namespace:\n\n``` python\n# bookings/urls.py\nurlpatterns = [\n    re_path(r'^$', bookings_list, name='bookings-list'),\n    re_path(r'^(?P<pk>[0-9]+)/$', bookings_detail, name='bookings-detail')\n]\n\n# urls.py\nurlpatterns = [\n    re_path(r'^v1/bookings/', include('bookings.urls', namespace='v1')),\n    re_path(r'^v2/bookings/', include('bookings.urls', namespace='v2'))\n]\n```\n\nBoth `URLPathVersioning` and `NamespaceVersioning` are reasonable if you just need a simple versioning scheme. The `URLPathVersioning` approach might be better suitable for small ad-hoc projects, and the `NamespaceVersioning` is probably easier to manage for larger projects.\n\n## HostNameVersioning\n\nThe hostname versioning scheme requires the client to specify the requested version as part of the hostname in the URL.\n\nFor example the following is an HTTP request to the `http://v1.example.com/bookings/` URL:\n\n``` python\nGET /bookings/ HTTP/1.1\nHost: v1.example.com\nAccept: application/json\n```\n\nBy default this implementation expects the hostname to match this simple regular expression:\n\n``` python\n^([a-zA-Z0-9]+)\\.[a-zA-Z0-9]+\\.[a-zA-Z0-9]+$\n```\n\nNote that the first group is enclosed in brackets, indicating that this is the matched portion of the hostname.\n\nThe `HostNameVersioning` scheme can be awkward to use in debug mode as you will typically be accessing a raw IP address such as `127.0.0.1`. There are various online tutorials on how to [access localhost with a custom subdomain](https://reinteractive.net/posts/199-developing-and-testing-rails-applications-with-subdomains) which you may find helpful in this case.\n\nHostname based versioning can be particularly useful if you have requirements to route incoming requests to different servers based on the version, as you can configure different DNS records for different API versions.\n\n## QueryParameterVersioning\n\nThis scheme is a simple style that includes the version as a query parameter in the URL. For example:\n\n``` python\nGET /something/?version=0.1 HTTP/1.1\nHost: example.com\nAccept: application/json\n```\n\n# Custom versioning schemes\n\nTo implement a custom versioning scheme, subclass `BaseVersioning` and override the `.determine_version` method.\n\n## Example\n\nThe following example uses a custom `X-API-Version` header to determine the requested version.\n\n``` python\nclass XAPIVersionScheme(versioning.BaseVersioning):\n    def determine_version(self, request, *args, **kwargs):\n        return request.META.get('HTTP_X_API_VERSION', None)\n```\n\nIf your versioning scheme is based on the request URL, you will also want to alter how versioned URLs are determined. In order to do so you should override the `.reverse()` method on the class. See the source code for examples.\n\n[versioning.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/versioning.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/versioning/](https://www.django-rest-framework.org/api-guide/versioning/)"
- name: Versioning settings
  id: api-guide/settings/index#versioning-settings
  summary: The value that should be used for request.version when no versioning information is present
  belongs_to: Settings
  description: |-
    ## Versioning settings

    #### DEFAULT_VERSION

    The value that should be used for `request.version` when no versioning information is present.

    Default: `None`

    #### ALLOWED_VERSIONS

    If set, this value will restrict the set of versions that may be returned by the versioning scheme, and will raise an error if the provided version if not in this set.

    Default: `None`

    #### VERSION_PARAM

    The string that should used for any versioning parameters, such as in the media type or URL query parameters.

    Default: `'version'`

    #### DEFAULT_VERSIONING_CLASS

    The default versioning scheme to use.

    Default: `None`
- name: View names and descriptions
  id: api-guide/settings/index#view-names-and-descriptions
  summary: The following settings are used to generate the view names and descriptions, as used in responses to OPTIONS requests, and as used in the browsable API
  belongs_to: Settings
  description: |-
    ## View names and descriptions

    **The following settings are used to generate the view names and descriptions, as used in responses to `OPTIONS` requests, and as used in the browsable API.**

    #### VIEW_NAME_FUNCTION

    A string representing the function that should be used when generating view names.

    This should be a function with the following signature:

    ``` python
    view_name(self)
    ```

    - `self`: The view instance. Typically the name function would inspect the name of the class when generating a descriptive name, by accessing `self.__class__.__name__`.

    If the view instance inherits `ViewSet`, it may have been initialized with several optional arguments:

    - `name`: A name explicitly provided to a view in the viewset. Typically, this value should be used as-is when provided.
    - `suffix`: Text used when differentiating individual views in a viewset. This argument is mutually exclusive to `name`.
    - `detail`: Boolean that differentiates an individual view in a viewset as either being a 'list' or 'detail' view.

    Default: `'rest_framework.views.get_view_name'`

    #### VIEW_DESCRIPTION_FUNCTION

    A string representing the function that should be used when generating view descriptions.

    This setting can be changed to support markup styles other than the default markdown. For example, you can use it to support `rst` markup in your view docstrings being output in the browsable API.

    This should be a function with the following signature:

    ``` python
    view_description(self, html=False)
    ```

    - `self`: The view instance. Typically the description function would inspect the docstring of the class when generating a description, by accessing `self.__class__.__doc__`
    - `html`: A boolean indicating if HTML output is required. `True` when used in the browsable API, and `False` when used in generating `OPTIONS` responses.

    If the view instance inherits `ViewSet`, it may have been initialized with several optional arguments:

    - `description`: A description explicitly provided to the view in the viewset. Typically, this is set by extra viewset `action`s, and should be used as-is.

    Default: `'rest_framework.views.get_view_description'`
- name: ViewSet
  id: api-guide/viewsets/index#viewset
  summary: The ViewSet class inherits from APIView
  belongs_to: ViewSets
  description: |-
    ## ViewSet

    The `ViewSet` class inherits from `APIView`. You can use any of the standard attributes such as `permission_classes`, `authentication_classes` in order to control the API policy on the viewset.

    The `ViewSet` class does not provide any implementations of actions. In order to use a `ViewSet` class you'll override the class and define the action implementations explicitly.
- name: ViewSets
  id: api-guide/viewsets/index
  summary: After routing has determined which controller to use for a request, your controller is responsible for making sense of the request and producing the appropriate output
  description: "# ViewSets\n\n> After routing has determined which controller to use for a request, your controller is responsible for making sense of the request and producing the appropriate output.\n>\n> — [Ruby on Rails Documentation](https://guides.rubyonrails.org/action_controller_overview.html)\n\nDjango REST framework allows you to combine the logic for a set of related views in a single class, called a `ViewSet`. In other frameworks you may also find conceptually similar implementations named something like 'Resources' or 'Controllers'.\n\nA `ViewSet` class is simply **a type of class-based View, that does not provide any method handlers** such as `.get()` or `.post()`, and instead provides actions such as `.list()` and `.create()`.\n\nThe method handlers for a `ViewSet` are only bound to the corresponding actions at the point of finalizing the view, using the `.as_view()` method.\n\nTypically, rather than explicitly registering the views in a viewset in the urlconf, you'll register the viewset with a router class, that automatically determines the urlconf for you.\n\n## Example\n\nLet's define a simple viewset that can be used to list or retrieve all the users in the system.\n\n``` python\nfrom django.contrib.auth.models import User\nfrom django.shortcuts import get_object_or_404\nfrom myapps.serializers import UserSerializer\nfrom rest_framework import viewsets\nfrom rest_framework.response import Response\n\nclass UserViewSet(viewsets.ViewSet):\n    \"\"\"\n    A simple ViewSet for listing or retrieving users.\n    \"\"\"\n    def list(self, request):\n        queryset = User.objects.all()\n        serializer = UserSerializer(queryset, many=True)\n        return Response(serializer.data)\n\n    def retrieve(self, request, pk=None):\n        queryset = User.objects.all()\n        user = get_object_or_404(queryset, pk=pk)\n        serializer = UserSerializer(user)\n        return Response(serializer.data)\n```\n\nIf we need to, we can bind this viewset into two separate views, like so:\n\n``` python\nuser_list = UserViewSet.as_view({'get': 'list'})\nuser_detail = UserViewSet.as_view({'get': 'retrieve'})\n```\n\nTypically we wouldn't do this, but would instead register the viewset with a router, and allow the urlconf to be automatically generated.\n\n``` python\nfrom myapp.views import UserViewSet\nfrom rest_framework.routers import DefaultRouter\n\nrouter = DefaultRouter()\nrouter.register(r'users', UserViewSet, basename='user')\nurlpatterns = router.urls\n```\n\nRather than writing your own viewsets, you'll often want to use the existing base classes that provide a default set of behavior. For example:\n\n``` python\nclass UserViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    A viewset for viewing and editing user instances.\n    \"\"\"\n    serializer_class = UserSerializer\n    queryset = User.objects.all()\n```\n\nThere are two main advantages of using a `ViewSet` class over using a `View` class.\n\n- Repeated logic can be combined into a single class. In the above example, we only need to specify the `queryset` once, and it'll be used across multiple views.\n- By using routers, we no longer need to deal with wiring up the URL conf ourselves.\n\nBoth of these come with a trade-off. Using regular views and URL confs is more explicit and gives you more control. ViewSets are helpful if you want to get up and running quickly, or when you have a large API and you want to enforce a consistent URL configuration throughout.\n\n## ViewSet actions\n\nThe default routers included with REST framework will provide routes for a standard set of create/retrieve/update/destroy style actions, as shown below:\n\n``` python\nclass UserViewSet(viewsets.ViewSet):\n    \"\"\"\n    Example empty viewset demonstrating the standard\n    actions that will be handled by a router class.\n\n    If you're using format suffixes, make sure to also include\n    the `format=None` keyword argument for each action.\n    \"\"\"\n\n    def list(self, request):\n        pass\n\n    def create(self, request):\n        pass\n\n    def retrieve(self, request, pk=None):\n        pass\n\n    def update(self, request, pk=None):\n        pass\n\n    def partial_update(self, request, pk=None):\n        pass\n\n    def destroy(self, request, pk=None):\n        pass\n```\n\n## Introspecting ViewSet actions\n\nDuring dispatch, the following attributes are available on the `ViewSet`.\n\n- `basename` - the base to use for the URL names that are created.\n- `action` - the name of the current action (e.g., `list`, `create`).\n- `detail` - boolean indicating if the current action is configured for a list or detail view.\n- `suffix` - the display suffix for the viewset type - mirrors the `detail` attribute.\n- `name` - the display name for the viewset. This argument is mutually exclusive to `suffix`.\n- `description` - the display description for the individual view of a viewset.\n\nYou may inspect these attributes to adjust behavior based on the current action. For example, you could restrict permissions to everything except the `list` action similar to this:\n\n``` python\ndef get_permissions(self):\n    \"\"\"\n    Instantiates and returns the list of permissions that this view requires.\n    \"\"\"\n    if self.action == 'list':\n        permission_classes = [IsAuthenticated]\n    else:\n        permission_classes = [IsAdminUser]\n    return [permission() for permission in permission_classes]\n```\n\n## Marking extra actions for routing\n\nIf you have ad-hoc methods that should be routable, you can mark them as such with the `@action` decorator. Like regular actions, extra actions may be intended for either a single object, or an entire collection. To indicate this, set the `detail` argument to `True` or `False`. The router will configure its URL patterns accordingly. e.g., the `DefaultRouter` will configure detail actions to contain `pk` in their URL patterns.\n\nA more complete example of extra actions:\n\n``` python\nfrom django.contrib.auth.models import User\nfrom rest_framework import status, viewsets\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\nfrom myapp.serializers import UserSerializer, PasswordSerializer\n\nclass UserViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    A viewset that provides the standard actions\n    \"\"\"\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\n    @action(detail=True, methods=['post'])\n    def set_password(self, request, pk=None):\n        user = self.get_object()\n        serializer = PasswordSerializer(data=request.data)\n        if serializer.is_valid():\n            user.set_password(serializer.validated_data['password'])\n            user.save()\n            return Response({'status': 'password set'})\n        else:\n            return Response(serializer.errors,\n                            status=status.HTTP_400_BAD_REQUEST)\n\n    @action(detail=False)\n    def recent_users(self, request):\n        recent_users = User.objects.all().order_by('-last_login')\n\n        page = self.paginate_queryset(recent_users)\n        if page is not None:\n            serializer = self.get_serializer(page, many=True)\n            return self.get_paginated_response(serializer.data)\n\n        serializer = self.get_serializer(recent_users, many=True)\n        return Response(serializer.data)\n```\n\nThe `action` decorator will route `GET` requests by default, but may also accept other HTTP methods by setting the `methods` argument. For example:\n\n``` python\n    @action(detail=True, methods=['post', 'delete'])\n    def unset_password(self, request, pk=None):\n       ...\n```\n\nArgument `methods` also supports HTTP methods defined as [HTTPMethod](https://docs.python.org/3/library/http.html#http.HTTPMethod). Example below is identical to the one above:\n\n``` python\n    from http import HTTPMethod\n\n    @action(detail=True, methods=[HTTPMethod.POST, HTTPMethod.DELETE])\n    def unset_password(self, request, pk=None):\n       ...\n```\n\nThe decorator allows you to override any viewset-level configuration such as `permission_classes`, `serializer_class`, `filter_backends`...:\n\n``` python\n    @action(detail=True, methods=['post'], permission_classes=[IsAdminOrIsSelf])\n    def set_password(self, request, pk=None):\n       ...\n```\n\nThe two new actions will then be available at the urls `^users/{pk}/set_password/$` and `^users/{pk}/unset_password/$`. Use the `url_path` and `url_name` parameters to change the URL segment and the reverse URL name of the action.\n\nTo view all extra actions, call the `.get_extra_actions()` method.\n\n### Routing additional HTTP methods for extra actions\n\nExtra actions can map additional HTTP methods to separate `ViewSet` methods. For example, the above password set/unset methods could be consolidated into a single route. Note that additional mappings do not accept arguments.\n\n``` python\n@action(detail=True, methods=[\"put\"], name=\"Change Password\")\ndef password(self, request, pk=None):\n    \"\"\"Update the user's password.\"\"\"\n    ...\n\n\n@password.mapping.delete\ndef delete_password(self, request, pk=None):\n    \"\"\"Delete the user's password.\"\"\"\n    ...\n```\n\n## Reversing action URLs\n\nIf you need to get the URL of an action, use the `.reverse_action()` method. This is a convenience wrapper for `reverse()`, automatically passing the view's `request` object and prepending the `url_name` with the `.basename` attribute.\n\nNote that the `basename` is provided by the router during `ViewSet` registration. If you are not using a router, then you must provide the `basename` argument to the `.as_view()` method.\n\nUsing the example from the previous section:\n\n``` python\n>>> view.reverse_action(\"set-password\", args=[\"1\"])\n'http://localhost:8000/api/users/1/set_password'\n```\n\nAlternatively, you can use the `url_name` attribute set by the `@action` decorator.\n\n``` python\n>>> view.reverse_action(view.set_password.url_name, args=['1'])\n'http://localhost:8000/api/users/1/set_password'\n```\n\nThe `url_name` argument for `.reverse_action()` should match the same argument to the `@action` decorator. Additionally, this method can be used to reverse the default actions, such as `list` and `create`.\n\n# API Reference\n\n## ViewSet\n\nThe `ViewSet` class inherits from `APIView`. You can use any of the standard attributes such as `permission_classes`, `authentication_classes` in order to control the API policy on the viewset.\n\nThe `ViewSet` class does not provide any implementations of actions. In order to use a `ViewSet` class you'll override the class and define the action implementations explicitly.\n\n## GenericViewSet\n\nThe `GenericViewSet` class inherits from `GenericAPIView`, and provides the default set of `get_object`, `get_queryset` methods and other generic view base behavior, but does not include any actions by default.\n\nIn order to use a `GenericViewSet` class you'll override the class and either mixin the required mixin classes, or define the action implementations explicitly.\n\n## ModelViewSet\n\nThe `ModelViewSet` class inherits from `GenericAPIView` and includes implementations for various actions, by mixing in the behavior of the various mixin classes.\n\nThe actions provided by the `ModelViewSet` class are `.list()`, `.retrieve()`, `.create()`, `.update()`, `.partial_update()`, and `.destroy()`.\n\n#### Example\n\nBecause `ModelViewSet` extends `GenericAPIView`, you'll normally need to provide at least the `queryset` and `serializer_class` attributes. For example:\n\n``` python\nclass AccountViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    A simple ViewSet for viewing and editing accounts.\n    \"\"\"\n    queryset = Account.objects.all()\n    serializer_class = AccountSerializer\n    permission_classes = [IsAccountAdminOrReadOnly]\n```\n\nNote that you can use any of the standard attributes or method overrides provided by `GenericAPIView`. For example, to use a `ViewSet` that dynamically determines the queryset it should operate on, you might do something like this:\n\n``` python\nclass AccountViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    A simple ViewSet for viewing and editing the accounts\n    associated with the user.\n    \"\"\"\n    serializer_class = AccountSerializer\n    permission_classes = [IsAccountAdminOrReadOnly]\n\n    def get_queryset(self):\n        return self.request.user.accounts.all()\n```\n\nNote however that upon removal of the `queryset` property from your `ViewSet`, any associated [router](../routers/index) will be unable to derive the basename of your Model automatically, and so you will have to specify the `basename` kwarg as part of your [router registration](../routers/index).\n\nAlso note that although this class provides the complete set of create/list/retrieve/update/destroy actions by default, you can restrict the available operations by using the standard permission classes.\n\n## ReadOnlyModelViewSet\n\nThe `ReadOnlyModelViewSet` class also inherits from `GenericAPIView`. As with `ModelViewSet` it also includes implementations for various actions, but unlike `ModelViewSet` only provides the 'read-only' actions, `.list()` and `.retrieve()`.\n\n#### Example\n\nAs with `ModelViewSet`, you'll normally need to provide at least the `queryset` and `serializer_class` attributes. For example:\n\n``` python\nclass AccountViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    A simple ViewSet for viewing accounts.\n    \"\"\"\n    queryset = Account.objects.all()\n    serializer_class = AccountSerializer\n```\n\nAgain, as with `ModelViewSet`, you can use any of the standard attributes and method overrides available to `GenericAPIView`.\n\n# Custom ViewSet base classes\n\nYou may need to provide custom `ViewSet` classes that do not have the full set of `ModelViewSet` actions, or that customize the behavior in some other way.\n\n## Example\n\nTo create a base viewset class that provides `create`, `list` and `retrieve` operations, inherit from `GenericViewSet`, and mixin the required actions:\n\n``` python\nfrom rest_framework import mixins, viewsets\n\nclass CreateListRetrieveViewSet(mixins.CreateModelMixin,\n                                mixins.ListModelMixin,\n                                mixins.RetrieveModelMixin,\n                                viewsets.GenericViewSet):\n    \"\"\"\n    A viewset that provides `retrieve`, `create`, and `list` actions.\n\n    To use it, override the class and set the `.queryset` and\n    `.serializer_class` attributes.\n    \"\"\"\n    pass\n```\n\nBy creating your own base `ViewSet` classes, you can provide common behavior that can be reused in multiple viewsets across your API.\n\n[viewsets.py](https://github.com/encode/django-rest-framework/tree/master/rest_framework/viewsets.py)\n\nCopyright © 2011–present Encode OSS Ltd.  \nLicensed under the BSD License.  \n[https://www.django-rest-framework.org/api-guide/viewsets/](https://www.django-rest-framework.org/api-guide/viewsets/)"
