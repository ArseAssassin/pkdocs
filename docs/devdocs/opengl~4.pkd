---
name: OpenGL
slug: opengl~4
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: '4'
copyright: https://registry.khronos.org/OpenGL-Refpages/gl4/index.php
homepage: https://registry.khronos.org/OpenGL-Refpages/

---
- name: abs
  id: abs.xhtml
  summary: x Specify the value of which to return the absolute
  description: "## Name\n\nabs — return the absolute value of the parameter\n\n## Declaration\n\n`genType `**`abs`**`(` genType `x``)`;\n\n`genIType `**`abs`**`(` genIType `x``)`;\n\n`genDType `**`abs`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value of which to return the absolute.\n\n## Description\n\n`abs` returns the absolute value of *`x`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| abs (genType)     |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| abs (genIType)    |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| abs (genDType)    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sign](sign.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/abs.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/abs.xhtml)"
- name: acos
  id: acos.xhtml
  summary: x Specify the value whose arccosine to return
  description: "## Name\n\nacos — return the arccosine of the parameter\n\n## Declaration\n\n`genType `**`acos`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value whose arccosine to return.\n\n## Description\n\n`acos` returns the angle whose trigonometric cosine is $x$. The range of values returned by `acos` is $\\[0,\\pi\\]$. The result is undefined if $\\left\\| x \\right\\| \\> 1$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| acos              |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [asin](asin.xhtml), [tan](tan.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/acos.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/acos.xhtml)"
- name: acosh
  id: acosh.xhtml
  summary: x Specify the value whose arc hyperbolic cosine to return
  description: "## Name\n\nacosh — return the arc hyperbolic cosine of the parameter\n\n## Declaration\n\n`genType `**`acosh`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value whose arc hyperbolic cosine to return.\n\n## Description\n\n`acosh` returns the arc hyperbolic cosine of $x$; the non-negative inverse of [cosh](cosh.xhtml). The result is undefined if $x \\< 1$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| acosh             |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [sinh](sinh.xhtml), [cosh](cosh.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/acosh.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/acosh.xhtml)"
- name: all
  id: all.xhtml
  summary: x Specifies the vector to be tested for truth
  description: "## Name\n\nall — check whether all elements of a boolean vector are true\n\n## Declaration\n\n`bool `**`all`**`(` bvec `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the vector to be tested for truth.\n\n## Description\n\n`all` returns true if all elements of *`x`* are true and false otherwise. It is functionally equivalent to:\n\n``` programlisting\n    bool all(bvec x)       // bvec can be bvec2, bvec3 or bvec4\n    {\n        bool result = true;\n        int i;\n        for (i = 0; i < x.length(); ++i)\n        {\n            result &= x[i];\n        }\n        return result;\n    }\n```\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| all               |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[any](any.xhtml), [not](not.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/all.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/all.xhtml)"
- name: any
  id: any.xhtml
  summary: x Specifies the vector to be tested for truth
  description: "## Name\n\nany — check whether any element of a boolean vector is true\n\n## Declaration\n\n`bool `**`any`**`(` bvec `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the vector to be tested for truth.\n\n## Description\n\n`any` returns true if any element of *`x`* is true and false otherwise. It is functionally equivalent to:\n\n``` programlisting\n    bool any(bvec x) {     // bvec can be bvec2, bvec3 or bvec4\n        bool result = false;\n        int i;\n        for (i = 0; i < x.length(); ++i) {\n            result |= x[i];\n        }\n        return result;\n    }\n```\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| any               |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[all](all.xhtml), [not](not.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/any.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/any.xhtml)"
- name: asin
  id: asin.xhtml
  summary: x Specify the value whose arcsine to return
  description: "## Name\n\nasin — return the arcsine of the parameter\n\n## Declaration\n\n`genType `**`asin`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value whose arcsine to return.\n\n## Description\n\n`asin` returns the angle whose trigonometric sine is $x$. The range of values returned by `asin` is $\\[-{\\pi \\over 2}, {\\pi \\over 2}\\]$. The result is undefined if $\\left\\| x \\right\\| \\> 1$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| asin              |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [acos](acos.xhtml), [tan](tan.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/asin.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/asin.xhtml)"
- name: asinh
  id: asinh.xhtml
  summary: x Specify the value whose arc hyperbolic sine to return
  description: "## Name\n\nasinh — return the arc hyperbolic sine of the parameter\n\n## Declaration\n\n`genType `**`asinh`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value whose arc hyperbolic sine to return.\n\n## Description\n\n`asinh` returns the arc hyperbolic sine of *x*; the inverse of [sinh](sinh.xhtml).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| asinh             |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [sinh](sinh.xhtml), [cosh](cosh.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/asinh.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/asinh.xhtml)"
- name: atan
  id: atan.xhtml
  summary: y Specify the numerator of the fraction whose arctangent to return
  description: "## Name\n\natan — return the arc-tangent of the parameters\n\n## Declaration\n\n`genType `**`atan`**`(` genType `y`, genType `x``)`;\n\n`genType `**`atan`**`(` genType `y_over_x``)`;\n\n## Parameters\n\n *`y`*  \nSpecify the numerator of the fraction whose arctangent to return.\n\n *`x`*  \nSpecify the denominator of the fraction whose arctangent to return.\n\n *`y_over_x`*  \nSpecify the fraction whose arctangent to return.\n\n## Description\n\n`atan` returns either the angle whose trigonometric arctangent is $y \\over x$ or *`y_over_x`*, depending on which overload is invoked. In the first overload, the signs of $y$ and $x$ are used to determine the quadrant that the angle lies in. The value returned by `atan` in this case is in the range $\\[-\\pi,\\pi\\]$. The result is undefined if $x = 0$.\n\nFor the second overload, `atan` returns the angle whose tangent is *`y_over_x`*. The value returned in this case is in the range $\\[-{\\pi \\over 2 },{\\pi \\over 2}\\]$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atan              |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [tan](tan.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atan.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atan.xhtml)"
- name: atanh
  id: atanh.xhtml
  summary: x Specify the value whose arc hyperbolic tangent to return
  description: "## Name\n\natanh — return the arc hyperbolic tangent of the parameter\n\n## Declaration\n\n`genType `**`atanh`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value whose arc hyperbolic tangent to return.\n\n## Description\n\n`atanh` returns the arc hyperbolic tangent of $x$; the inverse of [tanh](tanh.xhtml). The result is undefined if $\\left\\| x \\right\\| \\> 1$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atanh             |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [sinh](sinh.xhtml), [cosh](cosh.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atanh.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atanh.xhtml)"
- name: atomicAdd
  id: atomicadd.xhtml
  summary: mem The variable to use as the target of the operation
  description: "## Name\n\natomicAdd — perform an atomic addition to a variable\n\n## Declaration\n\n`int `**`atomicAdd`**`(` inout int `mem`, int `data``)`;\n\n`uint `**`atomicAdd`**`(` inout uint `mem`, uint `data``)`;\n\n## Parameters\n\n *`mem`*  \nThe variable to use as the target of the operation.\n\n *`data`*  \nThe data to be added to *`mem`*.\n\n## Description\n\n`atomicAdd` performs an atomic addition of *`data`* to the contents of *`mem`* and returns the original contents of *`mem`* from before the addition occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.\n\nAtomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicAdd         |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicAnd](atomicand.xhtml), [atomicOr](atomicor.xhtml), [atomicXor](atomicxor.xhtml), [atomicMin](atomicmin.xhtml), [atomicMax](atomicmax.xhtml), [atomicExchange](atomicexchange.xhtml), [atomicCompSwap](atomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicAdd.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicAdd.xhtml)"
- name: atomicAnd
  id: atomicand.xhtml
  summary: mem The variable to use as the target of the operation
  description: "## Name\n\natomicAnd — perform an atomic logical AND operation to a variable\n\n## Declaration\n\n`int `**`atomicAnd`**`(` inout int `mem`, int `data``)`;\n\n`uint `**`atomicAnd`**`(` inout uint `mem`, uint `data``)`;\n\n## Parameters\n\n *`mem`*  \nThe variable to use as the target of the operation.\n\n *`data`*  \nThe data to be logically ANDed with to *`mem`*.\n\n## Description\n\n`atomicAnd` performs an atomic logical AND with *`data`* to the contents of *`mem`* and returns the original contents of *`mem`* from before the logical operation occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.\n\nAtomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicAnd         |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicAdd](atomicadd.xhtml), [atomicOr](atomicor.xhtml), [atomicXor](atomicxor.xhtml), [atomicMin](atomicmin.xhtml), [atomicMax](atomicmax.xhtml), [atomicExchange](atomicexchange.xhtml), [atomicCompSwap](atomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicAnd.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicAnd.xhtml)"
- name: atomicCompSwap
  id: atomiccompswap.xhtml
  summary: mem The variable to use as the target of the operation
  description: "## Name\n\natomicCompSwap — perform an atomic compare-exchange operation to a variable\n\n## Declaration\n\n`int `**`atomicCompSwap`**`(` inout int `mem`, uint `compare`, uint `data``)`;\n\n`uint `**`atomicCompSwap`**`(` inout uint `mem`, uint `compare`, uint `data``)`;\n\n## Parameters\n\n *`mem`*  \nThe variable to use as the target of the operation.\n\n *`data`*  \nThe data to be compared and potentially exchanged with *`mem`*.\n\n## Description\n\n`atomicCompSwap` performs an atomic comparison of *`compare`* with the contents of *`mem`*. If the content of *`mem`* is equal to *`compare`*, then the content of *`data`* is written into *`mem`*, otherwise the content of *`mem`* is unmodifed. The function returns the original content of *`mem`* regardless of the outcome of the comparison. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.\n\nAtomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicCompSwap    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicAdd](atomicadd.xhtml), [atomicAnd](atomicand.xhtml), [atomicOr](atomicor.xhtml), [atomicXor](atomicxor.xhtml), [atomicMin](atomicmin.xhtml), [atomicMax](atomicmax.xhtml), [atomicExchange](atomicexchange.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicCompSwap.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicCompSwap.xhtml)"
- name: atomicCounter
  id: atomiccounter.xhtml
  summary: c Specify the handle to the atomic counter whose value to return
  description: "## Name\n\natomicCounter — return the current value of an atomic counter\n\n## Declaration\n\n`uint `**`atomicCounter`**`(` atomic_uint `c``)`;\n\n## Parameters\n\n *`c`*  \nSpecify the handle to the atomic counter whose value to return.\n\n## Description\n\n`atomicCounter` returns the current value of the atomic counter *`c`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicCounter     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicCounterIncrement](atomiccounterincrement.xhtml), [atomicCounterDecrement](atomiccounterdecrement.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicCounter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicCounter.xhtml)"
- name: atomicCounterDecrement
  id: atomiccounterdecrement.xhtml
  summary: c Specify the handle to the atomic counter to decrement
  description: "## Name\n\natomicCounterDecrement — atomically decrement a counter and return the prior value\n\n## Declaration\n\n`uint `**`atomicCounterDecrement`**`(` atomic_uint `c``)`;\n\n## Parameters\n\n *`c`*  \nSpecify the handle to the atomic counter to decrement.\n\n## Description\n\n`atomicCounterDecrement` atomically decrements the value of the atomic counter *`c`* and returns its new value.\n\n## Version Support\n\n|                        | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-----------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**      |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicCounterDecrement |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicCounterIncrement](atomiccounterincrement.xhtml), [atomicCounter](atomiccounter.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicCounterDecrement.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicCounterDecrement.xhtml)"
- name: atomicCounterIncrement
  id: atomiccounterincrement.xhtml
  summary: c Specify the handle to the atomic counter to increment
  description: "## Name\n\natomicCounterIncrement — atomically increment a counter and return the prior value\n\n## Declaration\n\n`uint `**`atomicCounterIncrement`**`(` atomic_uint `c``)`;\n\n## Parameters\n\n *`c`*  \nSpecify the handle to the atomic counter to increment.\n\n## Description\n\n`atomicCounterIncrement` atomically increments the value of the atomic counter *`c`* and returns its prior value.\n\n## Version Support\n\n|                        | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-----------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**      |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicCounterIncrement |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicCounterDecrement](atomiccounterdecrement.xhtml), [atomicCounter](atomiccounter.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicCounterIncrement.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicCounterIncrement.xhtml)"
- name: atomicExchange
  id: atomicexchange.xhtml
  summary: mem The variable to use as the target of the operation
  description: "## Name\n\natomicExchange — perform an atomic exchange operation to a variable\n\n## Declaration\n\n`int `**`atomicExchange`**`(` inout int `mem`, int `data``)`;\n\n`uint `**`atomicExchange`**`(` inout uint `mem`, uint `data``)`;\n\n## Parameters\n\n *`mem`*  \nThe variable to use as the target of the operation.\n\n *`data`*  \nThe data to be exchanged with *`mem`*.\n\n## Description\n\n`atomicExchange` performs an atomic exhange of *`data`* with the contents of *`mem`*. The content of *`data`* is written into *`mem`* and the original contents of *`mem`* are returned. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.\n\nAtomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicExchange    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicAdd](atomicadd.xhtml), [atomicAnd](atomicand.xhtml), [atomicOr](atomicor.xhtml), [atomicXor](atomicxor.xhtml), [atomicMin](atomicmin.xhtml), [atomicMax](atomicmax.xhtml), [atomicCompSwap](atomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicExchange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicExchange.xhtml)"
- name: atomicMax
  id: atomicmax.xhtml
  summary: mem The variable to use as the target of the operation
  description: "## Name\n\natomicMax — perform an atomic max operation to a variable\n\n## Declaration\n\n`int `**`atomicMax`**`(` inout int `mem`, int `data``)`;\n\n`uint `**`atomicMax`**`(` inout uint `mem`, uint `data``)`;\n\n## Parameters\n\n *`mem`*  \nThe variable to use as the target of the operation.\n\n *`data`*  \nThe data to be compared to *`mem`*.\n\n## Description\n\n`atomicMax` performs an atomic comparison of *`data`* to the contents of *`mem`*, writes the maximum value into *`mem`* and returns the original contents of *`mem`* from before the comparison occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.\n\nAtomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicMax         |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicAdd](atomicadd.xhtml), [atomicAnd](atomicand.xhtml), [atomicOr](atomicor.xhtml), [atomicXor](atomicxor.xhtml), [atomicMin](atomicmin.xhtml), [atomicExchange](atomicexchange.xhtml), [atomicCompSwap](atomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicMax.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicMax.xhtml)"
- name: atomicMin
  id: atomicmin.xhtml
  summary: mem The variable to use as the target of the operation
  description: "## Name\n\natomicMin — perform an atomic min operation to a variable\n\n## Declaration\n\n`int `**`atomicMin`**`(` inout int `mem`, int `data``)`;\n\n`uint `**`atomicMin`**`(` inout uint `mem`, uint `data``)`;\n\n## Parameters\n\n *`mem`*  \nThe variable to use as the target of the operation.\n\n *`data`*  \nThe data to be compared to *`mem`*.\n\n## Description\n\n`atomicMin` performs an atomic comparison of *`data`* to the contents of *`mem`*, writes the minimum value into *`mem`* and returns the original contents of *`mem`* from before the comparison occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.\n\nAtomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicMin         |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicAdd](atomicadd.xhtml), [atomicAnd](atomicand.xhtml), [atomicOr](atomicor.xhtml), [atomicXor](atomicxor.xhtml), [atomicMax](atomicmax.xhtml), [atomicExchange](atomicexchange.xhtml), [atomicCompSwap](atomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicMin.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicMin.xhtml)"
- name: atomicOr
  id: atomicor.xhtml
  summary: mem The variable to use as the target of the operation
  description: "## Name\n\natomicOr — perform an atomic logical OR operation to a variable\n\n## Declaration\n\n`int `**`atomicOr`**`(` inout int `mem`, int `data``)`;\n\n`uint `**`atomicOr`**`(` inout uint `mem`, uint `data``)`;\n\n## Parameters\n\n *`mem`*  \nThe variable to use as the target of the operation.\n\n *`data`*  \nThe data to be logically ORed with to *`mem`*.\n\n## Description\n\n`atomicOr` performs an atomic logical OR with *`data`* to the contents of *`mem`* and returns the original contents of *`mem`* from before the logical operation occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.\n\nAtomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicOr          |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicAdd](atomicadd.xhtml), [atomicAnd](atomicand.xhtml), [atomicXor](atomicxor.xhtml), [atomicMin](atomicmin.xhtml), [atomicMax](atomicmax.xhtml), [atomicExchange](atomicexchange.xhtml), [atomicCompSwap](atomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicOr.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicOr.xhtml)"
- name: atomicXor
  id: atomicxor.xhtml
  summary: mem The variable to use as the target of the operation
  description: "## Name\n\natomicXor — perform an atomic logical exclusive OR operation to a variable\n\n## Declaration\n\n`int `**`atomicXor`**`(` inout int `mem`, int `data``)`;\n\n`uint `**`atomicXor`**`(` inout uint `mem`, uint `data``)`;\n\n## Parameters\n\n *`mem`*  \nThe variable to use as the target of the operation.\n\n *`data`*  \nThe data to be logically exclusive ORed with to *`mem`*.\n\n## Description\n\n`atomicXor` performs an atomic logical exclusive OR with *`data`* to the contents of *`mem`* and returns the original contents of *`mem`* from before the logical operation occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.\n\nAtomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| atomicXor         |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[atomicAdd](atomicadd.xhtml), [atomicAnd](atomicand.xhtml), [atomicOr](atomicor.xhtml), [atomicMin](atomicmin.xhtml), [atomicMax](atomicmax.xhtml), [atomicExchange](atomicexchange.xhtml), [atomicCompSwap](atomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/atomicXor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/atomicXor.xhtml)"
- name: barrier
  id: barrier.xhtml
  summary: Available only in the Tessellation Control and Compute Shaders, barrier provides a partially defined order of execution between shader invocations
  description: "## Name\n\nbarrier — synchronize execution of multiple shader invocations\n\n## Declaration\n\n`void `**`barrier`**`(` void`)`;\n\n## Description\n\n*Available only in the Tessellation Control and Compute Shaders*, `barrier` provides a partially defined order of execution between shader invocations. For any given static instance of `barrier`, in a tessellation control shader, all invocations for a single input patch must enter it before any will be allowed to continue beyond it. For any given static instance of `barrier` in a compute shader, all invocations within a single work group must enter it before any are allowed to continue beyond it. This ensures that values written by one invocation prior to a given static instance of `barrier` can be safely read by other invocations after their call to the same static instance of `barrier`. Because invocations may execute in undefined order between these `barrier` calls, the values of a per-vertex or per-patch output variable, or any shared variable will be undefined in a number of cases.\n\n`barrier` may only be placed inside the function `main()` of the tessellation control shader, but may be placed anywhere in a compute shader. Calls to `barrier` may not be placed within any control flow. Barriers are also disallowed after a return statement in the function `main()`.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| barrier           |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/barrier.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/barrier.xhtml)"
- name: bitCount
  id: bitcount.xhtml
  summary: value Specifies the value whose bits to count
  description: "## Name\n\nbitCount — counts the number of 1 bits in an integer\n\n## Declaration\n\n`genIType `**`bitCount`**`(` genIType `value``)`;\n\n`genIType `**`bitCount`**`(` genUType `value``)`;\n\n## Parameters\n\n *`value`*  \nSpecifies the value whose bits to count.\n\n## Description\n\n`bitCount` returns the number of bits that are set to 1 in the binary representation of *`value`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| bitCount          |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[findLSB](findlsb.xhtml), [findMSB](findmsb.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/bitCount.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/bitCount.xhtml)"
- name: bitfieldExtract
  id: bitfieldextract.xhtml
  summary: value Specifies the integer from which to extract bits
  description: "## Name\n\nbitfieldExtract — extract a range of bits from an integer\n\n## Declaration\n\n`genIType `**`bitfieldExtract`**`(` genIType `value`, int `offset`, int `bits``)`;\n\n`genUType `**`bitfieldExtract`**`(` genUType `value`, int `offset`, int `bits``)`;\n\n## Parameters\n\n *`value`*  \nSpecifies the integer from which to extract bits.\n\n *`offset`*  \nSpecifies the index of the first bit to extract.\n\n *`bits`*  \nSpecifies the number of bits to extract.\n\n## Description\n\n`bitfieldExtract` extracts a subset of the bits of *`value`* and returns it in the least significant bits of the result. The range of bits extracted is \\[*`offset`*, *`offset`* + *`bits`* - 1\\].\n\nFor unsigned data types, the most significant bits of the result will be set to zero. For signed data types, the most significant bits will be set to the value of bit *`offset`* + *`base`* - 1 (i.e., it is *sign extended* to the width of the return type).\n\nIf *`bits`* is zero, the result will be zero. The result will be undefined if *`offset`* or *`bits`* is negative, or if the sum of *`offset`* and *`bits`* is greater than the number of bits used to store the operand.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| bitfieldInsert    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[bitfieldExtract](bitfieldextract.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/bitfieldExtract.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/bitfieldExtract.xhtml)"
- name: bitfieldInsert
  id: bitfieldinsert.xhtml
  summary: base Specifies the integer into which to insert insert
  description: "## Name\n\nbitfieldInsert — insert a range of bits into an integer\n\n## Declaration\n\n`genIType `**`bitfieldInsert`**`(` genIType `base`, genIType `insert`, int `offset`, int `bits``)`;\n\n`genUType `**`bitfieldInsert`**`(` genUType `base`, genUType `insert`, int `offset`, int `bits``)`;\n\n## Parameters\n\n *`base`*  \nSpecifies the integer into which to insert *`insert`*.\n\n *`insert`*  \nSpecifies the value of the bits to insert.\n\n *`offset`*  \nSpecifies the index of the first bit to insert.\n\n *`bits`*  \nSpecifies the number of bits to insert.\n\n## Description\n\n`bitfieldInsert` inserts the *`bits`* least significant bits of *`insert`* into *`base`* at offset *`offset`*. The returned value will have bits \\[*`offset`*, *`offset`* + *`bits`* + 1\\] taken from \\[0, *`bits`* - 1\\] of *`insert`* and all other bits taken directly from the corresponding bits of *`base`*. If *`bits`* is zero, the result will simply be the original value of *`base`*. The result will be undefined if *`offset`* or *`bits`* is negative, or if the sum of *`offset`* and *`bits`* is greater than the number of bits used to store the operand.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| bitfieldInsert    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[bitfieldExtract](bitfieldextract.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/bitfieldInsert.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/bitfieldInsert.xhtml)"
- name: bitfieldReverse
  id: bitfieldreverse.xhtml
  summary: value Specifies the value whose bits to reverse
  description: "## Name\n\nbitfieldReverse — reverse the order of bits in an integer\n\n## Declaration\n\n`genIType `**`bitfieldReverse`**`(` genIType `value``)`;\n\n`genUType `**`bitfieldReverse`**`(` genUType `value``)`;\n\n## Parameters\n\n *`value`*  \nSpecifies the value whose bits to reverse.\n\n## Description\n\n`bitfieldReverse` returns the reversal of the bits of value. The bit numbered *n* will be taken from bit (*bits* - 1) - *n* of *`value`*, where *bits* is the total number of bits used to represent *`value`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| bitfieldReverse   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[bitfieldExtract](bitfieldextract.xhtml), [bitfieldInsert](bitfieldinsert.xhtml), [bitCount](bitcount.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/bitfieldReverse.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/bitfieldReverse.xhtml)"
- name: ceil
  id: ceil.xhtml
  summary: x Specify the value to evaluate
  description: "## Name\n\nceil — find the nearest integer that is greater than or equal to the parameter\n\n## Declaration\n\n`genType `**`ceil`**`(` genType `x``)`;\n\n`genDType `**`ceil`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to evaluate.\n\n## Description\n\n`ceil` returns a value equal to the nearest integer that is greater than or equal to *`x`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| ceil (genType)    |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| ceil (genDType)   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[floor](floor.xhtml), [round](round.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/ceil.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/ceil.xhtml)"
- name: clamp
  id: clamp.xhtml
  summary: x Specify the value to constrain
  description: "## Name\n\nclamp — constrain a value to lie between two further values\n\n## Declaration\n\n`genType `**`clamp`**`(` genType `x`, genType `minVal`, genType `maxVal``)`;\n\n`genType `**`clamp`**`(` genType `x`, float `minVal`, float `maxVal``)`;\n\n`genDType `**`clamp`**`(` genDType `x`, genDType `minVal`, genDType `maxVal``)`;\n\n`genDType `**`clamp`**`(` genDType `x`, double `minVal`, double `maxVal``)`;\n\n`genIType `**`clamp`**`(` genIType `x`, genIType `minVal`, genIType `maxVal``)`;\n\n`genIType `**`clamp`**`(` genIType `x`, int `minVal`, int `maxVal``)`;\n\n`genUType `**`clamp`**`(` genUType `x`, genUType `minVal`, genUType `maxVal``)`;\n\n`genUType `**`clamp`**`(` genUType `x`, uint `minVal`, uint `maxVal``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to constrain.\n\n *`minVal`*  \nSpecify the lower end of the range into which to constrain *`x`*.\n\n *`maxVal`*  \nSpecify the upper end of the range into which to constrain *`x`*.\n\n## Description\n\n`clamp` returns the value of *`x`* constrained to the range *`minVal`* to *`maxVal`*. The returned value is computed as [min](min.xhtml)([max](max.xhtml)(*`x`*, *`minVal`*), *`maxVal`*).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| clamp (genType)   |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| clamp (genIType)  |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| clamp (genUType)  |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| clamp (genDType)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[min](min.xhtml), [max](max.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/clamp.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/clamp.xhtml)"
- name: cos
  id: cos.xhtml
  summary: angle Specify the quantity, in radians, of which to return the cosine
  description: "## Name\n\ncos — return the cosine of the parameter\n\n## Declaration\n\n`genType `**`cos`**`(` genType `angle``)`;\n\n## Parameters\n\n *`angle`*  \nSpecify the quantity, in radians, of which to return the cosine.\n\n## Description\n\n`cos` returns the trigonometric cosine of *`angle`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| cos               |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/cos.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/cos.xhtml)"
- name: cosh
  id: cosh.xhtml
  summary: x Specify the value whose hyperbolic cosine to return
  description: "## Name\n\ncosh — return the hyperbolic cosine of the parameter\n\n## Declaration\n\n`genType `**`cosh`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value whose hyperbolic cosine to return.\n\n## Description\n\n`cosh` returns the hyperbolic cosine of *x*. The hyperbolic cosine of *x* is computed as $\\frac{e^{x} + e^{- x}}{2}$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| cosh              |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [sinh](sinh.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/cosh.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/cosh.xhtml)"
- name: cross
  id: cross.xhtml
  summary: cross returns the cross product of two vectors, x and y, i.e
  description: "## Name\n\ncross — calculate the cross product of two vectors\n\n## Declaration\n\n`vec3 `**`cross`**`(` vec3 `x`, vec3 `y``)`;\n\n`dvec3 `**`cross`**`(` dvec3 `x`, dvec3 `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first of two vectors\n\n *`y`*  \nSpecifies the second of two vectors\n\n## Description\n\n`cross` returns the cross product of two vectors, *`x`* and *`y`*, i.e. $\\begin{pmatrix} { x\\[1\\] \\times y\\[2\\] - y\\[1\\] \\times x\\[2\\] } \\\\ { x\\[2\\] \\times y\\[0\\] - y\\[2\\] \\times x\\[0\\] } \\\\ { x\\[0\\] \\times y\\[1\\] - y\\[0\\] \\times x\\[1\\] } \\end{pmatrix}$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| cross (vec3)      |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| cross (dvec3)     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[dot](dot.xhtml)\n\n## Copyright\n\nCopyright © 2011-2016 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2016 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/cross.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/cross.xhtml)"
- name: degrees
  id: degrees.xhtml
  summary: radians Specify the quantity, in radians, to be converted to degrees
  description: "## Name\n\ndegrees — convert a quantity in radians to degrees\n\n## Declaration\n\n`genType `**`degrees`**`(` genType `radians``)`;\n\n## Parameters\n\n *`radians`*  \nSpecify the quantity, in radians, to be converted to degrees.\n\n## Description\n\n`degrees` converts a quantity specified in radians into degrees. The return value is ${ 180 \\times radians } \\over \\pi$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| degrees           |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[radians](radians.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/degrees.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/degrees.xhtml)"
- name: determinant
  id: determinant.xhtml
  summary: m Specifies the matrix of which to take the determinant
  description: "## Name\n\ndeterminant — calculate the determinant of a matrix\n\n## Declaration\n\n`float `**`determinant`**`(` mat2 `m``)`;\n\n`float `**`determinant`**`(` mat3 `m``)`;\n\n`float `**`determinant`**`(` mat4 `m``)`;\n\n`double `**`determinant`**`(` dmat2 `m``)`;\n\n`double `**`determinant`**`(` dmat3 `m``)`;\n\n`double `**`determinant`**`(` dmat4 `m``)`;\n\n## Parameters\n\n *`m`*  \nSpecifies the matrix of which to take the determinant.\n\n## Description\n\n`determinant` returns the determinant of the matrix *`m`*.\n\n## Version Support\n\n|                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| determinant (float)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| determinant (double) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[transpose](transpose.xhtml), [inverse](inverse.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/determinant.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/determinant.xhtml)"
- name: dFdx
  id: dfdx.xhtml
  summary: p Specifies the expression of which to take the partial derivative
  description: "## Name\n\ndFdx, dFdy — return the partial derivative of an argument with respect to x or y\n\n## Declaration\n\n`genType `**`dFdx`**`(` genType `p``)`;\n\n`genType `**`dFdy`**`(` genType `p``)`;\n\n`genType `**`dFdxCoarse`**`(` genType `p``)`;\n\n`genType `**`dFdyCoarse`**`(` genType `p``)`;\n\n`genType `**`dFdxFine`**`(` genType `p``)`;\n\n`genType `**`dFdyFine`**`(` genType `p``)`;\n\n## Parameters\n\n *`p`*  \nSpecifies the expression of which to take the partial derivative.\n\n## Description\n\n*Available only in the fragment shader*, these functions return the partial derivative of expression *`p`* with respect to the window $x$ coordinate (for `dFdx*`) and $y$ coordinate (for `dFdy*`).\n\n`dFdxFine` and `dFdyFine` calculate derivatives using local differencing based on the value of *`p`* for the current fragment and its immediate neighbor(s).\n\n`dFdxCoarse` and `dFdyCoarse` calculate derivatives using local differencing based on the value of *`p`* for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding `dFdxFine` and `dFdyFine` functions.\n\n`dFdx` returns either `dFdxCoarse` or `dFdxFine`. `dFdy` returns either `dFdyCoarse` or `dFdyFine`. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` hint.\n\nExpressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as `dFdx(dFdy(n))`. It is assumed that the expression *`p`* is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n\n## Version Support\n\n|                                            | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                          |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| dFdx                                       |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| dFdy                                       |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| dFdxCoarse, dFdxFine, dFdyCoarse, dFdyFine |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |\n\n## See Also\n\n[fwidth](fwidth.xhtml), [glHint](glhint.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/dFdx.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/dFdx.xhtml)"
- name: dFdxCoarse
  id: dfdx.xhtml#dFdxCoarse
  summary: null
  belongs_to: dFdx
  description: '`genType `**`dFdxCoarse`**`(` genType `p``)`;'
- name: dFdxFine
  id: dfdx.xhtml#dFdxFine
  summary: null
  belongs_to: dFdx
  description: '`genType `**`dFdxFine`**`(` genType `p``)`;'
- name: dFdy
  id: dfdx.xhtml#dFdy
  summary: null
  belongs_to: dFdx
  description: '`genType `**`dFdy`**`(` genType `p``)`;'
- name: dFdyCoarse
  id: dfdx.xhtml#dFdyCoarse
  summary: null
  belongs_to: dFdx
  description: '`genType `**`dFdyCoarse`**`(` genType `p``)`;'
- name: dFdyFine
  id: dfdx.xhtml#dFdyFine
  summary: Specifies the expression of which to take the partial derivative
  belongs_to: dFdx
  description: "`genType `**`dFdyFine`**`(` genType `p``)`;\n\n## Parameters\n\n*`p`*\n\nSpecifies the expression of which to take the partial derivative.\n\n## Description\n\n*Available only in the fragment shader*, these functions return the partial derivative of expression *`p`* with respect to the window $x$ coordinate (for `dFdx*`) and $y$ coordinate (for `dFdy*`).\n\n`dFdxFine` and `dFdyFine` calculate derivatives using local differencing based on the value of *`p`* for the current fragment and its immediate neighbor(s).\n\n`dFdxCoarse` and `dFdyCoarse` calculate derivatives using local differencing based on the value of *`p`* for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding `dFdxFine` and `dFdyFine` functions.\n\n`dFdx` returns either `dFdxCoarse` or `dFdxFine`. `dFdy` returns either `dFdyCoarse` or `dFdyFine`. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` hint.\n\nExpressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as `dFdx(dFdy(n))`. It is assumed that the expression *`p`* is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n\n## Version Support\n\n|                                            |  **OpenGL Shading Language Version**  |            |            |            |            |            |            |            |            |            |            |            |\n|:-------------------------------------------|:-------------------------------------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|\n|  **Function Name**                         |                **1.10**               |  **1.20**  |  **1.30**  |  **1.40**  |  **1.50**  |  **3.30**  |  **4.00**  |  **4.10**  |  **4.20**  |  **4.30**  |  **4.40**  |  **4.50**  |\n| dFdx                                       |                   ✔                   |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| dFdy                                       |                   ✔                   |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| dFdxCoarse, dFdxFine, dFdyCoarse, dFdyFine |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |\n\n## See Also\n\n[fwidth](fwidth.xhtml), [glHint](glhint.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/dFdx.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/dFdx.xhtml)"
- name: distance
  id: distance.xhtml
  summary: distance returns the distance between the two points p0 and p1
  description: "## Name\n\ndistance — calculate the distance between two points\n\n## Declaration\n\n`float `**`distance`**`(` genType `p0`, genType `p1``)`;\n\n`double `**`distance`**`(` genDType `p0`, genDType `p1``)`;\n\n## Parameters\n\n *`p0`*  \nSpecifies the first of two points\n\n *`p1`*  \nSpecifies the second of two points\n\n## Description\n\n`distance` returns the distance between the two points *`p0`* and *`p1`*. i.e., `length``(`*`p0`*` - `*`p1`*`);`\n\n## Version Support\n\n|                     | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**   |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| distance (genType)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| distance (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[length](length.xhtml), [normalize](normalize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/distance.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/distance.xhtml)"
- name: dot
  id: dot.xhtml
  summary: dot returns the dot product of two vectors, x and y
  description: "## Name\n\ndot — calculate the dot product of two vectors\n\n## Declaration\n\n`float `**`dot`**`(` genType `x`, genType `y``)`;\n\n`double `**`dot`**`(` genDType `x`, genDType `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first of two vectors\n\n *`y`*  \nSpecifies the second of two vectors\n\n## Description\n\n`dot` returns the dot product of two vectors, *`x`* and *`y`*. i.e., *x*\\[0\\] ⋅ *y*\\[0\\] + *x*\\[1\\] ⋅ *y*\\[1\\] + ...\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| dot (genType)     |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| dot (genDType)    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[cross](cross.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/dot.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/dot.xhtml)"
- name: EmitStreamVertex
  id: emitstreamvertex.xhtml
  summary: stream Specifies the stream upon which the vertex will be emitted
  description: "## Name\n\nEmitStreamVertex — emit a vertex to a specified stream\n\n## Declaration\n\n`void `**`EmitStreamVertex`**`(` int `stream``)`;\n\n## Parameters\n\n *`stream`*  \nSpecifies the stream upon which the vertex will be emitted.\n\n## Description\n\n*Available only in the Geometry Shader*, `EmitStreamVertex` emits the current values of output variables to the current output primitive on stream *`stream`*. The argument *`stream`* must be a constant integral expression. On return from this call, the value of all output variables for all streams are undefined.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| EmitStreamVertex  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[EmitVertex](emitvertex.xhtml), [EndStreamPrimitive](endstreamprimitive.xhtml), [EndPrimitive](endprimitive.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/EmitStreamVertex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/EmitStreamVertex.xhtml)"
- name: EmitVertex
  id: emitvertex.xhtml
  summary: Available only in the Geometry Shader, EmitVertex emits the current values of output variables to the current output primitive on the first (and possibly only) primitive stream
  description: "## Name\n\nEmitVertex — emit a vertex to the first vertex stream\n\n## Declaration\n\n`void `**`EmitVertex`**`(` void`)`;\n\n## Description\n\n*Available only in the Geometry Shader*, `EmitVertex` emits the current values of output variables to the current output primitive on the first (and possibly only) primitive stream. It is equivalent to calling [EmitStreamVertex](emitstreamvertex.xhtml) with *`stream`* set to 0.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| EmitVertex        |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[EmitStreamVertex](emitstreamvertex.xhtml), [EndStreamPrimitive](endstreamprimitive.xhtml), [EndPrimitive](endprimitive.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/EmitVertex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/EmitVertex.xhtml)"
- name: EndPrimitive
  id: endprimitive.xhtml
  summary: Available only in the Geometry Shader, EndPrimitive completes the current output primitive on the first (and possibly only) vertex stream and starts a new one.No vertex is emitted
  description: "## Name\n\nEndPrimitive — complete the current output primitive on the first vertex stream\n\n## Declaration\n\n`void `**`EndPrimitive`**`(` void`)`;\n\n## Description\n\n*Available only in the Geometry Shader*, `EndPrimitive` completes the current output primitive on the first (and possibly only) vertex stream and starts a new one.No vertex is emitted. Calling `EndPrimitive` is equivalent to calling [EmitStreamVertex](emitstreamvertex.xhtml) with *`stream`* set to 0.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| EndPrimitive      |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[EmitVertex](emitvertex.xhtml), [EmitStreamVertex](emitstreamvertex.xhtml), [EndStreamPrimitive](endstreamprimitive.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/EndPrimitive.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/EndPrimitive.xhtml)"
- name: EndStreamPrimitive
  id: endstreamprimitive.xhtml
  summary: stream Specifies the stream upon which the current primitive will be ended
  description: "## Name\n\nEndStreamPrimitive — complete the current output primitive on a specified stream\n\n## Declaration\n\n`void `**`EndStreamPrimitive`**`(` int `stream``)`;\n\n## Parameters\n\n *`stream`*  \nSpecifies the stream upon which the current primitive will be ended.\n\n## Description\n\n*Available only in the Geometry Shader*, `EndStreamPrimitive` completes the current output primitive on stream *`stream`* and starts a new one. The argument to *`stream`* must be a constant integral expression. No vertex is emitted.\n\n## Version Support\n\n|                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| EndStreamPrimitive |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[EmitVertex](emitvertex.xhtml), [EmitStreamVertex](emitstreamvertex.xhtml), [EndPrimitive](endprimitive.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/EndStreamPrimitive.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/EndStreamPrimitive.xhtml)"
- name: equal
  id: equal.xhtml
  summary: x Specifies the first vector to be used in the comparison operation
  description: "## Name\n\nequal — perform a component-wise equal-to comparison of two vectors\n\n## Declaration\n\n`bvec `**`equal`**`(` vec `x`, vec `y``)`;\n\n`bvec `**`equal`**`(` ivec `x`, ivec `y``)`;\n\n`bvec `**`equal`**`(` uvec `x`, uvec `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first vector to be used in the comparison operation.\n\n *`x`*  \nSpecifies the second vector to be used in the comparison operation.\n\n## Description\n\n`equal` returns a boolean vector in which each element *i* is computed as *`x`*\\[*i*\\] == *`y`*\\[*i*\\].\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| equal             |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[lessThan](lessthan.xhtml), [lessThanEqual](lessthanequal.xhtml), [greaterThan](greaterthan.xhtml), [greaterThanEqual](greaterthanequal.xhtml), [notEqual](notequal.xhtml), [any](any.xhtml), [all](all.xhtml), [not](not.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/equal.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/equal.xhtml)"
- name: exp
  id: exp.xhtml
  summary: x Specify the value to exponentiate
  description: "## Name\n\nexp — return the natural exponentiation of the parameter\n\n## Declaration\n\n`genType `**`exp`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to exponentiate.\n\n## Description\n\n`exp` returns the natural exponentiation of *`x`*. i.e., *e*^(*x*).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| exp               |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [sinh](sinh.xhtml), [cosh](cosh.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/exp.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/exp.xhtml)"
- name: exp2
  id: exp2.xhtml
  summary: x Specify the value of the power to which 2 will be raised
  description: "## Name\n\nexp2 — return 2 raised to the power of the parameter\n\n## Declaration\n\n`genType `**`exp2`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value of the power to which 2 will be raised.\n\n## Description\n\n`exp2` returns 2 raised to the power of *`x`*. i.e., 2^(*x*).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| exp2              |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[exp](exp.xhtml), [log](log.xhtml), [log2](log2.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/exp2.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/exp2.xhtml)"
- name: faceforward
  id: faceforward.xhtml
  summary: N Specifies the vector to orient
  description: "## Name\n\nfaceforward — return a vector pointing in the same direction as another\n\n## Declaration\n\n`genType `**`faceforward`**`(` genType `N`, genType `I`, genType `Nref``)`;\n\n`genDType `**`faceforward`**`(` genDType `N`, genDType `I`, genDType `Nref``)`;\n\n## Parameters\n\n *`N`*  \nSpecifies the vector to orient.\n\n *`I`*  \nSpecifies the incident vector.\n\n *`Nref`*  \nSpecifies the reference vector.\n\n## Description\n\n`faceforward` orients a vector to point away from a surface as defined by its normal. If [dot](dot.xhtml)`(`*`Nref`*`, `*`I`*`) < 0` `faceforward` returns *`N`*, otherwise it returns `-`*`N`*.\n\n## Version Support\n\n|                        | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-----------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**      |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| faceforward (genType)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| faceforward (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[reflect](reflect.xhtml), [refract](refract.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/faceforward.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/faceforward.xhtml)"
- name: findLSB
  id: findlsb.xhtml
  summary: value Specifies the value whose bits to scan
  description: "## Name\n\nfindLSB — find the index of the least significant bit set to 1 in an integer\n\n## Declaration\n\n`genIType `**`findLSB`**`(` genIType `value``)`;\n\n`genIType `**`findLSB`**`(` genUType `value``)`;\n\n## Parameters\n\n *`value`*  \nSpecifies the value whose bits to scan.\n\n## Description\n\n`findLSB` returns the bit number of the least significant bit that is set to 1 in the binary representation of *`value`*. If *`value`* is zero, -1 will be returned.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| findLSB           |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[findMSB](findmsb.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/findLSB.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/findLSB.xhtml)"
- name: findMSB
  id: findmsb.xhtml
  summary: value Specifies the value whose bits to scan
  description: "## Name\n\nfindMSB — find the index of the most significant bit set to 1 in an integer\n\n## Declaration\n\n`genIType `**`findMSB`**`(` genIType `value``)`;\n\n`genIType `**`findMSB`**`(` genUType `value``)`;\n\n## Parameters\n\n *`value`*  \nSpecifies the value whose bits to scan.\n\n## Description\n\n`findMSB` returns the bit number of the most significant bit that is set to 1 in the binary representation of *`value`*. For positive integers, the result will be the bit number of the most significant bit that is set to 1. For negative integers, the result will be the bit number of the most significant bit set to 0. For a *`value`* of zero or negative 1, -1 will be returned.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| findMSB           |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[findLSB](findlsb.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/findMSB.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/findMSB.xhtml)"
- name: floatBitsToInt
  id: floatbitstoint.xhtml
  summary: x Specifies the value whose floating point encoding to return
  description: "## Name\n\nfloatBitsToInt — produce the encoding of a floating point value as an integer\n\n## Declaration\n\n`genIType `**`floatBitsToInt`**`(` genType `x``)`;\n\n`genUType `**`floatBitsToUint`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the value whose floating point encoding to return.\n\n## Description\n\n`floatBitsToInt` and `floatBitsToUint` return the encoding of their floating-point parameters as `int` or `uint`, respectively. The floating-point bit-level representation is preserved.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| floatBitsToInt    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| floatBitsToUInt   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[intBitsToFloat](intbitstofloat.xhtml), `uintBitsToFloat`\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/floatBitsToInt.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/floatBitsToInt.xhtml)"
- name: floatBitsToUint
  id: floatbitstoint.xhtml#floatBitsToUint
  summary: Specifies the value whose floating point encoding to return
  belongs_to: floatBitsToInt
  description: "`genUType `**`floatBitsToUint`**`(` genType `x``)`;\n\n## Parameters\n\n*`x`*\n\nSpecifies the value whose floating point encoding to return.\n\n## Description\n\n`floatBitsToInt` and `floatBitsToUint` return the encoding of their floating-point parameters as `int` or `uint`, respectively. The floating-point bit-level representation is preserved.\n\n## Version Support\n\n|                     |  **OpenGL Shading Language Version**  |            |            |            |            |            |            |            |            |            |            |            |\n|:--------------------|:-------------------------------------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|\n|  **Function Name**  |                **1.10**               |  **1.20**  |  **1.30**  |  **1.40**  |  **1.50**  |  **3.30**  |  **4.00**  |  **4.10**  |  **4.20**  |  **4.30**  |  **4.40**  |  **4.50**  |\n| floatBitsToInt      |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| floatBitsToUInt     |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n\n## See Also\n\n[intBitsToFloat](intbitstofloat.xhtml), `uintBitsToFloat`\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/floatBitsToInt.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/floatBitsToInt.xhtml)"
- name: floor
  id: floor.xhtml
  summary: x Specify the value to evaluate
  description: "## Name\n\nfloor — find the nearest integer less than or equal to the parameter\n\n## Declaration\n\n`genType `**`floor`**`(` genType `x``)`;\n\n`genDType `**`floor`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to evaluate.\n\n## Description\n\n`floor` returns a value equal to the nearest integer that is less than or equal to *`x`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| floor (genType)   |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| floor (genDType)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[trunc](trunc.xhtml), [round](round.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/floor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/floor.xhtml)"
- name: fma
  id: fma.xhtml
  summary: a Specifies the first multiplicand
  description: "## Name\n\nfma — perform a fused multiply-add operation\n\n## Declaration\n\n`genType `**`fma`**`(` genType `a`, genType `b`, genType `c``)`;\n\n`genDType `**`fma`**`(` genDType `a`, genDType `b`, genDType `c``)`;\n\n## Parameters\n\n *`a`*  \nSpecifies the first multiplicand.\n\n *`b`*  \nSpecifies the second multiplicand.\n\n *`c`*  \nSpecifies the value to be added to the result.\n\n## Description\n\n`fma` performs, where possible, a fused multiply-add operation, returning `a * b + c`. In use cases where the return value is eventually consumed by a variable declared as `precise`:\n\n- `fma`() is considered a single operation, whereas the expression `a * b + c` consumed by a variable declared as `precise` is considered two operations.\n\n- The precision of `fma`() can differ from the precision of the expression `a * b + c`.\n\n- `fma`() will be computed with the same precision as any other `fma`() consumed by a `precise` variable, giving invariant results for the same input values of *`a`*, *`b`* and *`c`*.\n\nOtherwise, in the absence of `precise` consumption, there are no special constraints on the number of operations or difference in precision between `fma`() and the expression `a * b + c`.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| fma (genType)     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| fma (genDType)    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/fma.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/fma.xhtml)"
- name: fract
  id: fract.xhtml
  summary: x Specify the value to evaluate
  description: "## Name\n\nfract — compute the fractional part of the argument\n\n## Declaration\n\n`genType `**`fract`**`(` genType `x``)`;\n\n`genDType `**`fract`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to evaluate.\n\n## Description\n\n`fract` returns the fractional part of *`x`*. This is calculated as *`x`* - [floor](floor.xhtml)(*`x`*).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| fract (genType)   |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| fract (genDType)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[floor](floor.xhtml), [round](round.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/fract.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/fract.xhtml)"
- name: frexp
  id: frexp.xhtml
  summary: x Specifies the value from which significand and exponent are to be extracted
  description: "## Name\n\nfrexp — split a floating point number\n\n## Declaration\n\n`genType `**`frexp`**`(` genType `x`, out genIType `exp``)`;\n\n`genDType `**`frexp`**`(` genDType `x`, out genIType `exp``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the value from which significand and exponent are to be extracted.\n\n *`out exp`*  \nSpecifies the variable into which to place the exponent\n\n## Description\n\n`frexp` extracts *`x`* into a floating-point significand in the range \\[0.5, 1.0) and in integral exponent of two, such that:\n\n*x* = *s**i**g**n**i**f**i**c**a**n**d* ⋅ 2^(*e**x**p**o**n**e**n**t*)\n\nThe significand is returned by the function and the exponent is returned in the output parameter *`exp`*. For a floating-point value of zero, the significand and exponent are both zero. For a floating-point value that is an infinity or a floating-point NaN, the results are undefined.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| frexp (genType)   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| frexp (genDType)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[ldexp](ldexp.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/frexp.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/frexp.xhtml)"
- name: fwidth
  id: fwidth.xhtml
  summary: p Specifies the expression of which to take the partial derivative
  description: "## Name\n\nfwidth — return the sum of the absolute value of derivatives in x and y\n\n## Declaration\n\n`genType `**`fwidth`**`(` genType `p``)`;\n\n`genType `**`fwidthCoarse`**`(` genType `p``)`;\n\n`genType `**`fwidthFine`**`(` genType `p``)`;\n\n## Parameters\n\n *`p`*  \nSpecifies the expression of which to take the partial derivative.\n\n## Description\n\n*Available only in the fragment shader*, these functions return the sum of the absolute derivatives in $x$ and $y$ using local differencing for the input argument *`p`*. `fwidth` is equivalent to ` ``abs``(`*`dFdx`*`(p)) + ``abs``(`*`dFdy`*`(p)) `. `fwidthCoarse` is equivalent to ` ``abs``(`*`dFdxCoarse`*`(p)) + ``abs``(`*`dFdyCoarse`*`(p)) `. `fwidthFine` is equivalent to ` ``abs``(`*`dFdxFine`*`(p)) + ``abs``(`*`dFdyFine`*`(p)) `.\n\n## Version Support\n\n|                          | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**        |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| fwidth                   |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| fwidthCoarse, fwidthFine |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |\n\n## See Also\n\n[dFdx](dfdx.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/fwidth.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/fwidth.xhtml)"
- name: fwidthCoarse
  id: fwidth.xhtml#fwidthCoarse
  summary: null
  belongs_to: fwidth
  description: '`genType `**`fwidthCoarse`**`(` genType `p``)`;'
- name: fwidthFine
  id: fwidth.xhtml#fwidthFine
  summary: Specifies the expression of which to take the partial derivative
  belongs_to: fwidth
  description: "`genType `**`fwidthFine`**`(` genType `p``)`;\n\n## Parameters\n\n*`p`*\n\nSpecifies the expression of which to take the partial derivative.\n\n## Description\n\n*Available only in the fragment shader*, these functions return the sum of the absolute derivatives in $x$ and $y$ using local differencing for the input argument *`p`*. `fwidth` is equivalent to `abs``(`*`dFdx`*`(p)) + ``abs``(`*`dFdy`*`(p)) `. `fwidthCoarse` is equivalent to `abs``(`*`dFdxCoarse`*`(p)) + ``abs``(`*`dFdyCoarse`*`(p)) `. `fwidthFine` is equivalent to `abs``(`*`dFdxFine`*`(p)) + ``abs``(`*`dFdyFine`*`(p)) `.\n\n## Version Support\n\n|                          |  **OpenGL Shading Language Version**  |            |            |            |            |            |            |            |            |            |            |            |\n|:-------------------------|:-------------------------------------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|\n|  **Function Name**       |                **1.10**               |  **1.20**  |  **1.30**  |  **1.40**  |  **1.50**  |  **3.30**  |  **4.00**  |  **4.10**  |  **4.20**  |  **4.30**  |  **4.40**  |  **4.50**  |\n| fwidth                   |                   ✔                   |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| fwidthCoarse, fwidthFine |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |\n\n## See Also\n\n[ dFdx ](dfdx.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/fwidth.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/fwidth.xhtml)"
- name: gl_ClipDistance
  id: gl_clipdistance.xhtml
  summary: The gl_ClipDistance variable provides a forward compatible mechanism for controlling user clipping
  description: "## Name\n\ngl_ClipDistance — provides a forward-compatible mechanism for vertex clipping\n\n## Declaration\n\n`gl_ClipDistance` is a member of the `gl_PerVertex` named block:\n\n``` programlisting\n    out gl_PerVertex {\n        vec4 gl_Position;\n        float gl_PointSize;\n        float gl_ClipDistance[];\n    };\n```\n\nIn fragment shaders, it is intrinsically declared as: `in ``float ``gl_ClipDistance[] ``;`\n\n## Description\n\nThe `gl_ClipDistance` variable provides a forward compatible mechanism for controlling user clipping. The element *`gl_ClipDistance`*\\[*i*\\] specifies a clip distance for each user clip plane *i*. A distance of 0.0 means that the vertex is on the plane, a positive distance means that the vertex is inside the clip plane, and a negative distance means that the point is outside the clip plane. The clip distances will be linearly interpolated across the primitive and the portion of the primitive with interpolated distances less than 0.0 will be clipped.\n\nThe `gl_ClipDistance` array is initially predeclared as unsized and must be sized by the shader either by redeclaring it with an explicit size, or by indexing it with only integral constant expressions. The array must be sized to include all clip planes that are enabled via the OpenGL API; if the size does not include all enabled planes, results are undefined. The size may be at most `gl_MaxClipDistances`. The number of varying components consumed by `gl_ClipDistance` will match the size of the array, no matter how many planes are enabled. The shader must also set all values in `gl_ClipDistance` that have been enabled via the OpenGL API, or results are undefined. Values written into `gl_ClipDistance` planes that are not enabled have no effect.\n\nIn the vertex, tessellation evaluation and geometry languages, a single global instance of the `gl_PerVertex` named block is available and its `gl_ClipDistance` member is an output that receives the clip distances for the current vertex. It may be written at any time during shader execution. The value written to `gl_ClipDistance` will be used by primitive assembly, clipping, culling and other fixed functionality operations, if present, that operate on primitives after vertex processing has occurred.\n\nIn the tessellation control language, the `gl_PerVertex` named block is used to construct an array, `gl_out[]`, whose `gl_ClipDistance` members hold clip distances for each of the control points, which become available as inputs to the subsequent tessellation evaluation shader.\n\nThe value of `gl_ClipDistance` (or the `gl_ClipDistance` member of the `gl_out[]` array, in the case of the tessellation control shader) is undefined after the vertex, tessellation control, and tessellation evaluation shading stages if the corresponding shader executable does not write to gl_ClipDistance. It is also undefined after the geometry processing stage if the geometry shader executable calls [EmitVertex](emitvertex.xhtml) without having written `gl_ClipDistance` since the last call to [EmitVertex](emitvertex.xhtml) (or hasn't written it at all).\n\nIn the tessellation control, tessellation evaluation and geoemetry languages, the `gl_PerVertex` named block is used to construct an array, `gl_in[]` of per-vertex or per-control point inputs whose content represents the corresponding outputs written by the previous stage. Only elements of the `gl_ClipDistance` array that correspond to enabled clip planes have defined values.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_ClipDistance   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\nVersions 1.30 to 1.40 - vertex shader only.\n\nVersions 1.50 to 3.30 - vertex and geometry shaders only.\n\n## See Also\n\n[gl_CullDistance](gl_culldistance.xhtml), [gl_PointSize](gl_pointsize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_ClipDistance.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_ClipDistance.xhtml)"
- name: gl_CullDistance
  id: gl_culldistance.xhtml
  summary: The gl_CullDistance variable provides a mechanism for controlling user culling
  description: "## Name\n\ngl_CullDistance — provides a mechanism for controlling user culling\n\n## Declaration\n\n`gl_CullDistance` is a member of the `gl_PerVertex` named block:\n\n``` programlisting\n    out gl_PerVertex {\n        vec4 gl_Position;\n        float gl_PointSize;\n        float gl_ClipDistance[];\n        float gl_CullDistance[];\n    };\n```\n\nIn fragment shaders, it is intrinsically declared as: `in ``float ``gl_CullDistance[] ``;`\n\n## Description\n\nThe `gl_CullDistance` variable provides a mechanism for controlling user culling. The element *`gl_CullDistance`*\\[*i*\\] specifies a cull distance for each plane *i*. A distance of 0.0 means that the vertex is on the plane, a positive distance means that the vertex is inside the cull volume, and a negative distance means that the point is outside the cull volume. Primitives whose vertices all have a negative clip distance for plane *i* will be discarded.\n\nThe `gl_CullDistance` array is predeclared as unsized and must be sized by the shader either by redeclaring it with an size or by indexing it only with integral constant expressions. The size determines the number and set of enabled cull distances and can be at most `gl_MaxCullDistances`. The number of varying components consumed by `gl_CullDistance` will match the size of the array. Shaders writing `gl_CullDistance` must write all enabled distances, or culling results are undefined.\n\nAs an output variable, `gl_CullDistance` provides the place for the shader to write these distances. As an input in all but the fragment language, it reads the values written in the previous shader stage. In the fragment language, the `gl_CullDistance` array contains linearly interpolated values for the vertex values written by a shader to the `gl_CullDistance` vertex output variable.\n\nIt is a compile-time or link-time error for the set of shaders forming a program to have the sum of the sizes of the `gl_ClipDistance` and `gl_CullDistance` arrays to be larger than `gl_MaxCombinedClipAndCullDistances`.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_CullDistance   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |\n\n## See Also\n\n[gl_ClipDistance](gl_clipdistance.xhtml), [gl_PointSize](gl_pointsize.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_CullDistance.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_CullDistance.xhtml)"
- name: gl_FragCoord
  id: gl_fragcoord.xhtml
  summary: Available only in the fragment language, gl_FragCoord is an input variable that contains the window relative coordinate (x, y, z, 1/w) values for the fragment
  description: "## Name\n\ngl_FragCoord — contains the window-relative coordinates of the current fragment\n\n## Declaration\n\n`in ``vec4 ``gl_FragCoord ``;`\n\n## Description\n\nAvailable only in the fragment language, `gl_FragCoord` is an input variable that contains the window relative coordinate (x, y, z, 1/w) values for the fragment. If multi-sampling, this value can be for any location within the pixel, or one of the fragment samples. This value is the result of fixed functionality that interpolates primitives after vertex processing to generate fragments. The z component is the depth value that would be used for the fragment's depth if no shader contained any writes to [gl_FragDepth](gl_fragdepth.xhtml).\n\n`gl_FragCoord` may be redeclared with the additional layout qualifier identifiers `origin_upper_left` or `pixel_center_integer`. By default, `gl_FragCoord` assumes a lower-left origin for window coordinates and assumes pixel centers are located at half-pixel centers. For example, the (x, y) location (0.5, 0.5) is returned for the lower-left-most pixel in a window. The origin of `gl_FragCoord` may be changed by redeclaring `gl_FragCoord` with the `origin_upper_left` identifier. The values returned can also be shifted by half a pixel in both x and y by `pixel_center_integer` so it appears the pixels are centered at whole number pixel offsets. This moves the (x, y) value returned by `gl_FragCoord` of (0.5, 0.5) by default to (0.0, 0.0) with `pixel_center_integer`.\n\nIf `gl_FragCoord` is redeclared in any fragment shader in a program, it must be redeclared in all fragment shaders in that program that have static use of `gl_FragCoord`. Redeclaring `gl_FragCoord` with any accepted qualifier affects only `gl_FragCoord.x` and `gl_FragCoord.y`. It has no effect on rasterization, transformation or any other part of the OpenGL pipeline or language features.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_FragCoord      |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_FragDepth](gl_fragdepth.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_FragCoord.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_FragCoord.xhtml)"
- name: gl_FragDepth
  id: gl_fragdepth.xhtml
  summary: Available only in the fragment language, gl_FragDepth is an output variable that is used to establish the depth value for the current fragment
  description: "## Name\n\ngl_FragDepth — establishes a depth value for the current fragment\n\n## Declaration\n\n`out ``float ``gl_FragDepth ``;`\n\n## Description\n\nAvailable only in the fragment language, `gl_FragDepth` is an output variable that is used to establish the depth value for the current fragment. If depth buffering is enabled and no shader writes to `gl_FragDepth`, then the fixed function value for depth will be used (this value is contained in the z component of [gl_FragCoord](gl_fragcoord.xhtml)) otherwise, the value written to `gl_FragDepth` is used. If a shader statically assigns to `gl_FragDepth`, then the value of the fragment's depth may be undefined for executions of the shader that don't take that path. That is, if the set of linked fragment shaders statically contain a write to `gl_FragDepth`, then it is responsible for always writing it.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_FragDepth      |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_FragCoord](gl_fragcoord.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_FragDepth.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_FragDepth.xhtml)"
- name: gl_FrontFacing
  id: gl_frontfacing.xhtml
  summary: Available only in the fragment language, gl_FrontFacing is an input variable whose value is true if the fragment belongs to a front-facing primitive and false otherwise
  description: "## Name\n\ngl_FrontFacing — indicates whether a primitive is front or back facing\n\n## Declaration\n\n`in ``bool ``gl_FrontFacing ``;`\n\n## Description\n\nAvailable only in the fragment language, `gl_FrontFacing` is an input variable whose value is `true` if the fragment belongs to a front-facing primitive and false otherwise. The determination of whether a triangle primitive is front-facing is made by examining the sign of the area of the triangle, including a possible reversal of this sign as controlled by `glFrontFace`. One way to compute this area is:\n\n$a = \\frac{1}{2}\\sum\\_{j = 0}^{n - 1}x\\_{w}^{i}y\\_{w}^{i + 1} - x\\_{w}^{i + 1}y\\_{w}^{i}$\n\nwhere *x*_(*w*)^(*i*) and *y*_(*w*)^(*i*) are the x and y window coordinates of the *i*th vertex of the n-vertex polygon.\n\nThe sign of this computation is negated when the value of `GL_CLIP_ORIGIN` (the clip volume origin, set with [glClipControl](glclipcontrol.xhtml)) is `GL_UPPER_LEFT`.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_FrontFacing    |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_FragCoord](gl_fragcoord.xhtml), [glClipControl](glclipcontrol.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_FrontFacing.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_FrontFacing.xhtml)"
- name: gl_GlobalInvocationID
  id: gl_globalinvocationid.xhtml
  summary: In the compute language, gl_GlobalInvocationID is a derived input variable containing the n-dimensional index of the work invocation within the global work group that the current shader is executing on
  description: "## Name\n\ngl_GlobalInvocationID — contains the global index of work item currently being operated on by a compute shader\n\n## Declaration\n\n`in ``uvec3 ``gl_GlobalInvocationID ``;`\n\n## Description\n\nIn the compute language, `gl_GlobalInvocationID` is a derived input variable containing the n-dimensional index of the work invocation within the global work group that the current shader is executing on. The value of `gl_GlobalInvocationID` is equal to `gl_WorkGroupID` \\* `gl_WorkGroupSize` + `gl_LocalInvocationID`.\n\n## Version Support\n\n|                       | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:----------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name**     |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_GlobalInvocationID |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_NumWorkGroups](gl_numworkgroups.xhtml), [gl_WorkGroupID](gl_workgroupid.xhtml), [gl_WorkGroupSize](gl_workgroupsize.xhtml), [gl_LocalInvocationID](gl_localinvocationid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_GlobalInvocationID.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_GlobalInvocationID.xhtml)"
- name: gl_HelperInvocation
  id: gl_helperinvocation.xhtml
  summary: The value gl_HelperInvocation is true if the fragment shader invocation is considered a helper invocation and is false otherwise
  description: "## Name\n\ngl_HelperInvocation — indicates whether a fragment shader invocation is a helper invocation\n\n## Declaration\n\n`in ``bool ``gl_HelperInvocation ``;`\n\n## Description\n\nThe value `gl_HelperInvocation` is true if the fragment shader invocation is considered a helper invocation and is false otherwise. A helper invocation is a fragment-shader invocation that is created solely for the purposes of evaluating derivatives for use in non-helper fragment-shader invocations. Such derivatives are computed implicitly in the built-in function [texture](texture.xhtml)(), and explicitly in the derivative functions [dFdx](dfdx.xhtml)() and `dFdy`.\n\nFragment shader helper invocations execute the same shader code as non-helper invocations, but will not have side effects that modify the framebuffer or other shader-accessible memory. In particular:\n\n- Fragments corresponding to helper invocations are discarded when shader execution is complete, without updating the framebuffer.\n\n- Stores to image and buffer variables performed by helper invocations have no effect on the underlying image or buffer memory.\n\n- Atomic operations to image, buffer, or atomic counter variables performed by helper invocations have no effect on the underlying image or buffer memory. The values returned by such atomic operations are undefined.\n\nHelper invocations may be generated for pixels not covered by a primitive being rendered. While fragment shader inputs qualified with centroid are normally required to be sampled in the intersection of the pixel and the primitive, the requirement is ignored for such pixels since there is no intersection between the pixel and primitive.\n\nHelper invocations may also be generated for fragments that are covered by a primitive being rendered when the fragment is killed by early fragment tests (using the early_fragment_tests qualifier) or where the implementation is able to determine that executing the fragment shader would have no effect other than assisting in computing derivatives for other fragment shader invocations.\n\nThe set of helper invocations generated when processing any set of primitives is implementation dependent.\n\n## Version Support\n\n|                     | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name**   |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_HelperInvocation |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |\n\n## See Also\n\n[dFdx](dfdx.xhtml), [texture](texture.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_HelperInvocation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_HelperInvocation.xhtml)"
- name: gl_InstanceID
  id: gl_instanceid.xhtml
  summary: gl_InstanceID is a vertex language input variable that holds the integer index of the current primitive in an instanced draw command such as glDrawArraysInstanced
  description: "## Name\n\ngl_InstanceID — contains the index of the current primitive in an instanced draw command\n\n## Declaration\n\n`in ``int ``gl_InstanceID ``;`\n\n## Description\n\n`gl_InstanceID` is a vertex language input variable that holds the integer index of the current primitive in an instanced draw command such as `glDrawArraysInstanced`. If the current primitive does not originate from an instanced draw command, the value of `gl_InstanceID` is zero.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_InstanceID     |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_VertexID](gl_vertexid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_InstanceID.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_InstanceID.xhtml)"
- name: gl_InvocationID
  id: gl_invocationid.xhtml
  summary: In the tessellation control language, gl_InvocationID contains the index of the output patch vertex assigned to the shader invocation
  description: "## Name\n\ngl_InvocationID — contains the invocation index of the current shader\n\n## Declaration\n\n`in ``int ``gl_InvocationID ``;`\n\n## Description\n\nIn the tessellation control language, `gl_InvocationID` contains the index of the output patch vertex assigned to the shader invocation. It is assigned an integer value in the range \\[0, N-1\\] where N is the number of output patch vertices.\n\nIn the geometry language, `gl_InvocationID` identifies the invocation number assigned to the geometry shader invocation. It is assigned an integer value in the range \\[0, N-1\\] where N is the number of geometry shader invocations per primitive.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_InvocationID   |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n\\[1\\] Versions 1.50 to 3.30 - geometry shaders only.\n\n## See Also\n\n[gl_InstanceID](gl_instanceid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_InvocationID.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_InvocationID.xhtml)"
- name: gl_Layer
  id: gl_layer.xhtml
  summary: In the geometry language, gl_Layer is used to select a specific layer (or face and layer of cube map) in a multi-layer framebuffer attachment
  description: "## Name\n\ngl_Layer — contains the selected layer of a multi-layer framebuffer attachment\n\n## Declaration\n\n``` programlisting\n// Geometry stage\n```\n\n`out ``int ``gl_Layer ``;`\n\n``` programlisting\n// Fragment stage\n```\n\n`in ``int ``gl_Layer ``;`\n\n## Description\n\nIn the geometry language, `gl_Layer` is used to select a specific layer (or face and layer of cube map) in a multi-layer framebuffer attachment. The actual layer used will come from one of the vertices in the primitive being shaded. Which vertex the layer comes from is undefined and as such it is recommended to write the same value to `gl_Layer` for all vertices in the primitive. If a shader statically assigns a value to `gl_Layer`, layered rendering mode is enabled. If a shader statically assigns a value to `gl_Layer`, and there is an execution path through the shader that does not set `gl_Layer`, then the value of `gl_Layer` is undefined for invocations of the shader that take that path.\n\nWhen used with an array of cube map textures, the `gl_Layer` output variable takes on a special value. Instead of referring to only the layer, it is used to select a cube map face and a layer. Setting `gl_Layer` to the value *l**a**y**e**r* \\* 6 + *f**a**c**e* will render to *f**a**c**e* of the cube defined in *l**a**y**e**r*. The face values are as follows:\n\n|  **Face Value**  |       **Resulting Target**      |\n|:-----------------|:-------------------------------:|\n| 0                | `GL_TEXTURE_CUBEMAP_POSITIVE_X` |\n| 1                | `GL_TEXTURE_CUBEMAP_NEGATIVE_X` |\n| 2                | `GL_TEXTURE_CUBEMAP_POSITIVE_Y` |\n| 3                | `GL_TEXTURE_CUBEMAP_NEGATIVE_Y` |\n| 4                | `GL_TEXTURE_CUBEMAP_POSITIVE_Z` |\n| 5                | `GL_TEXTURE_CUBEMAP_NEGATIVE_Z` |\n\nFor example, to render to the positive y cube map face located in the 5^(th) layer of the cube map array, `gl_Layer` should be set to 5 \\* 6 + 2.\n\nThe input variable `gl_Layer` in the fragment language will have the same value that was written to the output variable `gl_Layer` in the geometry language. If the geometry stage does not dynamically assign a value to `gl_Layer`, the value of `gl_Layer` in the fragment stage will be undefined. If the geometry stage makes no static assignment to `gl_Layer`, the input `gl_Layer` in the fragment stage will be zero. Otherwise, the fragment stage will read the same value written by the geometry stage, even if that value is out of range. If a fragment shader contains a static access to `gl_Layer`, it will count against the implementation defined limit for the maximum number of inputs to the fragment stage.\n\n## Version Support\n\n|                           | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**         |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_Layer (geometry stage) |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| gl_Layer (fragment stage) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_ViewportIndex](gl_viewportindex.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_Layer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_Layer.xhtml)"
- name: gl_LocalInvocationID
  id: gl_localinvocationid.xhtml
  summary: In the compute language, gl_LocalInvocationID is an input variable containing the n-dimensional index of the local work invocation within the work group that the current shader is executing in
  description: "## Name\n\ngl_LocalInvocationID — contains the index of work item currently being operated on by a compute shader\n\n## Declaration\n\n`in ``uvec3 ``gl_LocalInvocationID ``;`\n\n## Description\n\nIn the compute language, `gl_LocalInvocationID` is an input variable containing the n-dimensional index of the local work invocation within the work group that the current shader is executing in. The possible values for this variable range across the local work group size, i.e., (0,0,0) to (`gl_WorkGroupSize.x` - 1, `gl_WorkGroupSize.y` - 1, `gl_WorkGroupSize.z` - 1).\n\n## Version Support\n\n|                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name**    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_LocalInvocationID |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_NumWorkGroups](gl_numworkgroups.xhtml), [gl_WorkGroupID](gl_workgroupid.xhtml), [gl_WorkGroupSize](gl_workgroupsize.xhtml), [gl_GlobalInvocationID](gl_globalinvocationid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_LocalInvocationID.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_LocalInvocationID.xhtml)"
- name: gl_LocalInvocationIndex
  id: gl_localinvocationindex.xhtml
  summary: In the compute language, gl_LocalInvocationIndex is a derived input variable containing the 1-dimensional linearized index of the work invocation within the work group that the current shader is executing on
  description: "## Name\n\ngl_LocalInvocationIndex — contains the local linear index of work item currently being operated on by a compute shader\n\n## Declaration\n\n`in ``uint ``gl_LocalInvocationIndex ``;`\n\n## Description\n\nIn the compute language, `gl_LocalInvocationIndex` is a derived input variable containing the 1-dimensional linearized index of the work invocation within the work group that the current shader is executing on. The value of `gl_LocalInvocationIndex` is equal to `gl_LocalInvocationID.z` \\* `gl_WorkGroupSize.x` \\* `gl_WorkGroupSize.y` + `gl_LocalInvocationID.y` \\* `gl_WorkGroupSize.x` + `gl_LocalInvocationID.x`.\n\n## Version Support\n\n|                         | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name**       |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_LocalInvocationIndex |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_NumWorkGroups](gl_numworkgroups.xhtml), [gl_WorkGroupID](gl_workgroupid.xhtml), [gl_WorkGroupSize](gl_workgroupsize.xhtml), [gl_LocalInvocationID](gl_localinvocationid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_LocalInvocationIndex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_LocalInvocationIndex.xhtml)"
- name: gl_NumSamples
  id: gl_numsamples.xhtml
  summary: gl_NumSamples is a fragment language input variable that contains the number of samples in the framebuffer, or 1 if rendering to a non-multisample framebuffer
  description: "## Name\n\ngl_NumSamples — contains the total number of samples in the framebuffer\n\n## Declaration\n\n`in ``bool ``gl_NumSamples ``;`\n\n## Description\n\n`gl_NumSamples` is a fragment language input variable that contains the number of samples in the framebuffer, or 1 if rendering to a non-multisample framebuffer. `gl_NumSamples` is the sample count of the framebuffer regardless of whether multisample rasterization is enabled or not.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_NumSamples     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_SamplePosition](gl_sampleposition.xhtml), [gl_SampleID](gl_sampleid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_NumSamples.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_NumSamples.xhtml)"
- name: gl_NumWorkGroups
  id: gl_numworkgroups.xhtml
  summary: In the compute language, gl_NumWorkGroups contains the total number of work groups that will execute the compute shader
  description: "## Name\n\ngl_NumWorkGroups — contains the number of workgroups that have been dispatched to a compute shader\n\n## Declaration\n\n`in ``uvec3 ``gl_NumWorkGroups ``;`\n\n## Description\n\nIn the compute language, `gl_NumWorkGroups` contains the total number of work groups that will execute the compute shader. The components of `gl_NumWorkGroups` are equal to the *`num_groups_x`*, *`num_groups_y`*, and *`num_groups_z`* parameters passed to the `glDispatchCompute` command.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_NumWorkGroups  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_WorkGroupSize](gl_workgroupsize.xhtml), [gl_WorkGroupID](gl_workgroupid.xhtml), [gl_LocalInvocationID](gl_localinvocationid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_NumWorkGroups.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_NumWorkGroups.xhtml)"
- name: gl_PatchVerticesIn
  id: gl_patchverticesin.xhtml
  summary: Available only in the tessellation control and evaluation languages, gl_PatchVerticesIn contains the number of vertices in the input being processed by the shader
  description: "## Name\n\ngl_PatchVerticesIn — contains the number of vertices in the current patch\n\n## Declaration\n\n`in ``int ``gl_PatchVerticesIn ``;`\n\n## Description\n\nAvailable only in the tessellation control and evaluation languages, `gl_PatchVerticesIn` contains the number of vertices in the input being processed by the shader. A single tessellation control or evaluation shader can read patches of differing sizes, and so th value of `gl_PatchVertexIn` may differ between patches.\n\n## Version Support\n\n|                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name**  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_PatchVerticesIn |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_TessLevelOuter](gl_tesslevelouter.xhtml), [gl_TessLevelInner](gl_tesslevelinner.xhtml), [gl_TessCoord](gl_tesscoord.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PatchVerticesIn.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PatchVerticesIn.xhtml)"
- name: gl_PointCoord
  id: gl_pointcoord.xhtml
  summary: gl_PointCoord is a fragment language input variable that contains the two-dimensional coordinates indicating where within a point primitive the current fragment is located
  description: "## Name\n\ngl_PointCoord — contains the coordinate of a fragment within a point\n\n## Declaration\n\n`in ``vec2 ``gl_PointCoord ``;`\n\n## Description\n\n`gl_PointCoord` is a fragment language input variable that contains the two-dimensional coordinates indicating where within a point primitive the current fragment is located. If the current primitive is not a point, then values read from `gl_PointCoord` are undefined.\n\n`gl_PointCoord.s` ranges from 0.0 to 1.0 across the point horizontally from left to right. If `GL_POINT_SPRITE_COORD_ORIGIN` is `GL_LOWER_LEFT`, `gl_PointCoord.t` varies from 0.0 to 1.0 vertically from bottom to top. Otherwise, if `GL_POINT_SPRITE_COORD_ORIGIN` is `GL_UPPER_LEFT` then `gl_PointCoord.t` varies from 0.0 to 1.0 vertically from top to bottom. The default value of `GL_POINT_SPRITE_COORD_ORIGIN` is `GL_UPPER_LEFT`.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_PointCoord     |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_FragCoord](gl_fragcoord.xhtml), [gl_FragDepth](gl_fragdepth.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PointCoord.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PointCoord.xhtml)"
- name: gl_PointSize
  id: gl_pointsize.xhtml
  summary: In the vertex, tessellation evaluation and geometry languages, a single global instance of the gl_PerVertex named block is available and its gl_PointSize member is an output that receives the intended size of the point to be rasterized, in pixels
  description: "## Name\n\ngl_PointSize — contains size of rasterized points, in pixels\n\n## Declaration\n\n`gl_PointSize` is a member of the `gl_PerVertex` named block:\n\n``` programlisting\n    out gl_PerVertex {\n        vec4 gl_Position;\n        float gl_PointSize;\n        float gl_ClipDistance[];\n    };\n```\n\n## Description\n\nIn the vertex, tessellation evaluation and geometry languages, a single global instance of the `gl_PerVertex` named block is available and its `gl_PointSize` member is an output that receives the intended size of the point to be rasterized, in pixels. It may be written at any time during shader execution. If `GL_PROGRAM_POINT_SIZE` is enabled, `gl_PointSize` is used to determine the size of rasterized points, otherwise it is ignored by the rasterization stage.\n\nIn the tessellation control language, the `gl_PerVertex` named block is used to construct an array, `gl_out[]`, whose members become available as inputs to the subsequent tessellation evaluation shader.\n\nThe value of `gl_PointSize` (or the `gl_PointSize` member of the `gl_out[]` array, in the case of the tessellation control shader) is undefined after the vertex, tessellation control, and tessellation evaluation shading stages if the corresponding shader executable does not write to gl_PointSize. It is also undefined after the geometry processing stage if the geometry shader executable calls [EmitVertex](emitvertex.xhtml) without having written `gl_PointSize` since the last call to [EmitVertex](emitvertex.xhtml) (or hasn't written it at all).\n\nIn the tessellation control, tessellation evaluation and geometry languages, the `gl_PerVertex` named block is used to construct an array, `gl_in[]` of per-vertex or per-control point inputs whose content represents the corresponding outputs written by the previous stage.\n\n## Version Support\n\n|                                               | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:----------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name**                             |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_PointSize (vertex shader)                  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| gl_PointSize (geometry shader)                |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| gl_PointSize (tessellation evaluation shader) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_Position](gl_position.xhtml), [gl_ClipDistance](gl_clipdistance.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PointSize.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PointSize.xhtml)"
- name: gl_Position
  id: gl_position.xhtml
  summary: In the vertex, tessellation evaluation and geometry languages, a single global instance of the gl_PerVertex named block is available and its gl_Position member is an output that receives the homogeneous vertex position
  description: "## Name\n\ngl_Position — contains the position of the current vertex\n\n## Declaration\n\n`gl_Position` is a member of the `gl_PerVertex` named block:\n\n``` programlisting\n    out gl_PerVertex {\n        vec4 gl_Position;\n        float gl_PointSize;\n        float gl_ClipDistance[];\n    };\n```\n\n## Description\n\nIn the vertex, tessellation evaluation and geometry languages, a single global instance of the `gl_PerVertex` named block is available and its `gl_Position` member is an output that receives the homogeneous vertex position. It may be written at any time during shader execution. The value written to `gl_Position` will be used by primitive assembly, clipping, culling and other fixed functionality operations, if present, that operate on primitives after vertex processing has occurred.\n\nIn the tessellation control language, the `gl_PerVertex` named block is used to construct an array, `gl_out[]`, whose `gl_Position` members hold the homogeneous control point position, which become available as inputs to the subsequent tessellation evaluation shader.\n\nThe value of `gl_Position` (or the `gl_Position` member of the `gl_out[]` array, in the case of the tessellation control shader) is undefined after the vertex, tessellation control, and tessellation evaluation shading stages if the corresponding shader executable does not write to gl_Position. It is also undefined after the geometry processing stage if the geometry shader executable calls [EmitVertex](emitvertex.xhtml) without having written `gl_Position` since the last call to [EmitVertex](emitvertex.xhtml) (or hasn't written it at all).\n\nIn the tessellation control, tessellation evaluation and geometry languages, the `gl_PerVertex` named block is used to construct an array, `gl_in[]` of per-vertex or per-control point inputs whose content represents the corresponding outputs written by the previous stage.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_Position       |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\nVersions 1.10 to 1.40 - vertex shader only.\n\nVersions 1.50 to 3.30 - vertex and geometry shaders only.\n\n## See Also\n\n[gl_PointSize](gl_pointsize.xhtml), [gl_ClipDistance](gl_clipdistance.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_Position.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_Position.xhtml)"
- name: gl_PrimitiveID
  id: gl_primitiveid.xhtml
  summary: gl_PrimitiveID is a tessellation control, tessellation evaluation and fragment language input variable
  description: "## Name\n\ngl_PrimitiveID — contains the index of the current primitive\n\n## Declaration\n\n``` programlisting\n// In tessellation control, tessellation evaluation, and\n// fragment shaders\n```\n\n`in ``int ``gl_PrimitiveID ``;`\n\n``` programlisting\n// In geometry shaders\n```\n\n`out ``int ``gl_PrimitiveID ``;`\n\n## Description\n\n`gl_PrimitiveID` is a tessellation control, tessellation evaluation and fragment language input variable. For the tessellation control and tessellation evaluation languages, it holds the number of primitives processed by the shader since the current set of rendering primitives was started. The first primitive processed by the drawing command is numbered zero and the primitive ID counter is incremented after every individual point, line or triangle primitive is processed. For triangles drawn in point or line mode, the primitive ID counter is incremented only once, even through multiple points or lines may actually be drawn. Restarting a primitive topology using the primitive restart index has no effect on the primitive ID counter.\n\nIn the geometry language, `gl_PrimitiveID` is an output variable that is passed to the corresponding `gl_PrimitiveID` input variable in the fragment shader. If no geomery shader is present then `gl_PrimitiveID` in the fragment language behaves identically as it would in the tessellation control and evaluation languages. If a geometry shader is present but does not write to `gl_PrimitiveID`, the value of `gl_PrimitiveID` in the fragment shader is undefined.\n\n## Version Support\n\n|                                                                  | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-----------------------------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                                                |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| `gl_PrimitiveID` (Fragment and Geometry Languages)               |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| `gl_PrimitiveID` (Tessellation Control and Evaluation Languages) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_InstanceID](gl_instanceid.xhtml), [gl_VertexID](gl_vertexid.xhtml), [gl_PrimitiveIDIn](gl_primitiveidin.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PrimitiveID.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PrimitiveID.xhtml)"
- name: gl_PrimitiveIDIn
  id: gl_primitiveidin.xhtml
  summary: gl_PrimitiveIDIn is a geometry language input variable that holds the number of primitives processed by the shader since the current set of rendering primitives was started
  description: "## Name\n\ngl_PrimitiveIDIn — contains the index of the current primitive\n\n## Declaration\n\n`in ``int ``gl_PrimitiveIDIn ``;`\n\n## Description\n\n`gl_PrimitiveIDIn` is a geometry language input variable that holds the number of primitives processed by the shader since the current set of rendering primitives was started. The first primitive processed by the drawing command is numbered zero and the primitive ID counter is incremented after every individual point, line or triangle primitive is processed. For triangles drawn in point or line mode, the primitive ID counter is incremented only once, even through multiple points or lines may actually be drawn. Restarting a primitive topology using the primitive restart index has no effect on the primitive ID counter.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_PrimitiveIDIn  |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_InstanceID](gl_instanceid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PrimitiveIDIn.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_PrimitiveIDIn.xhtml)"
- name: gl_SampleID
  id: gl_sampleid.xhtml
  summary: gl_SampleID is a fragment language input variable that contains the index of the sample currently being processed
  description: "## Name\n\ngl_SampleID — contains the index of the sample currently being processed\n\n## Declaration\n\n`in ``int ``gl_SampleID ``;`\n\n## Description\n\n`gl_SampleID` is a fragment language input variable that contains the index of the sample currently being processed. This variable is in the range 0 to [gl_NumSamples](gl_numsamples.xhtml) - 1, where [gl_NumSamples](gl_numsamples.xhtml) is the total number of samples in each fragment for the current framebuffer (and thus 1 if rendering to a non-multisample buffer). Any static use of this variable in a fragment shader causes the entire shader to be evaluated per-sample rather than per-fragment.\n\nWhen rendering to a non-multisample buffer, or if multisample rasterization is disabled, `gl_SampleID` will always be zero. [gl_NumSamples](gl_numsamples.xhtml) is the sample count of the framebuffer regardless of whether multisample rasterization is enabled or not.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_SampleID       |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_SamplePosition](gl_sampleposition.xhtml), [gl_NumSamples](gl_numsamples.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_SampleID.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_SampleID.xhtml)"
- name: gl_SampleMask
  id: gl_samplemask.xhtml
  summary: gl_SampleMask is a fragment language output array that may be used to set the sample mask for the fragment being processed
  description: "## Name\n\ngl_SampleMask — specifies the sample coverage mask for the current fragment\n\n## Declaration\n\n`out ``int ``gl_SampleMask[] ``;`\n\n## Description\n\n`gl_SampleMask` is a fragment language output array that may be used to set the sample mask for the fragment being processed. Coverage for the current fragment will become the logical AND of the coverage mask and the output `gl_SampleMask`. That is, setting a bit in `gl_SampleMask` to zero will cause the corresponding sample to be considered uncovered for the purposes of multisample fragment operations. However, setting sample mask bits back to one will never enable samples not covered by the original primitive. Bit *B* of mask `gl_SampleMask[M]` corresponds to sample 32 \\* *M* + *B*. This array must be sized in the fragment shader either implicitly or explicitly to be the same size as the implementation-dependent maximum sample-mask (as an array of 32-bit elements), determined by the maximum number of samples. If the fragment shader statically assigns a value to `gl_SampleMask`, the sample mask will be undefined for any array elements of any fragment shader invocation that fails to assign a value. If a shader does not statically assign a value to `gl_SampleMask`, the sample mask has no effect on the processing of a fragment. If the fragment shader is being evaluated at any frequency other than per-fragment, bits within the sample mask not corresponding to the current fragment shader invocation are ignored.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_SampleMask     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_SampleMaskIn](gl_samplemaskin.xhtml), [gl_SampleID](gl_sampleid.xhtml), [gl_SamplePosition](gl_sampleposition.xhtml), [gl_FragCoord](gl_fragcoord.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_SampleMask.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_SampleMask.xhtml)"
- name: gl_SampleMaskIn
  id: gl_samplemaskin.xhtml
  summary: gl_SampleMaskIn is a fragment language that indicates the set of samples covered by the primitive generating the fragment during multisample rasterization
  description: "## Name\n\ngl_SampleMaskIn — contains the computed sample coverage mask for the current fragment\n\n## Declaration\n\n`in ``int ``gl_SampleMaskIn[] ``;`\n\n## Description\n\n`gl_SampleMaskIn` is a fragment language that indicates the set of samples covered by the primitive generating the fragment during multisample rasterization. It has a sample bit set if and only if the sample is considered covered for this fragment shader invocation. Bit *B* of mask `gl_SampleMask[M]` corresponds to sample 32 \\* *M* + *B*. The array has `ceil`(*s* / 32) elements where *s* is the maximum number of color samples supported by the implementation.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_SampleMaskIn   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_SampleMask](gl_samplemask.xhtml), [gl_SampleID](gl_sampleid.xhtml), [gl_SamplePosition](gl_sampleposition.xhtml), [gl_FragCoord](gl_fragcoord.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_SampleMaskIn.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_SampleMaskIn.xhtml)"
- name: gl_SamplePosition
  id: gl_sampleposition.xhtml
  summary: gl_SamplePosition is a fragment language input variable that contains the location within a fragment of the sample currently being processed
  description: "## Name\n\ngl_SamplePosition — contains the location of the current sample within the current fragment\n\n## Declaration\n\n`in ``vec2 ``gl_SamplePosition ``;`\n\n## Description\n\n`gl_SamplePosition` is a fragment language input variable that contains the location within a fragment of the sample currently being processed. The x and y components of `gl_SamplePosition` contain the sub-pixel coordinate of the current sample and will have values in the range 0.0 to 1.0. The sub-pixel coordinates of the center of the pixel are always (0.5, 0.5). Any static use of `gl_SamplePosition` causes the entire fragment shader to be evaluated per-sample rather than per-fragment. When rendering to a non-multisample buffer, or if multisample rasterization is disabled, `gl_SamplePosition` will be (0.5, 0.5).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_SamplePosition |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_SampleID](gl_sampleid.xhtml), [gl_SampleMask](gl_samplemask.xhtml), [gl_FragCoord](gl_fragcoord.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_SamplePosition.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_SamplePosition.xhtml)"
- name: gl_TessCoord
  id: gl_tesscoord.xhtml
  summary: Available only in the tessellation cevaluation language, gl_TessCoord specifies the three component (u, v, w) vector identifying the position of the vertex being processed by the shader relative to the primitive being tessellated
  description: "## Name\n\ngl_TessCoord — contains the coordinate of the vertex within the current patch\n\n## Declaration\n\n`in ``vec3 ``gl_TessCoord ``;`\n\n## Description\n\nAvailable only in the tessellation cevaluation language, `gl_TessCoord` specifies the three component (u, v, w) vector identifying the position of the vertex being processed by the shader relative to the primitive being tessellated.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_TessCoord      |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_TessLevelOuter](gl_tesslevelouter.xhtml), [gl_TessLevelInner](gl_tesslevelinner.xhtml), [gl_PatchVerticesIn](gl_patchverticesin.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_TessCoord.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_TessCoord.xhtml)"
- name: gl_TessLevelInner
  id: gl_tesslevelinner.xhtml
  summary: Available only in the tessellation control and evaluation languages, gl_TessLevelInner is used to assign values to the corresponding inner tesellation levels of the current patch
  description: "## Name\n\ngl_TessLevelInner — contains the inner tessellation levels for the current patch\n\n## Declaration\n\n``` programlisting\n// In tessellation control shaders\n```\n\n`out ``float ``gl_TessLevelInner[2] ``;`\n\n``` programlisting\n// In tessellation evaluation shaders\n```\n\n`in ``float ``gl_TessLevelInner[2] ``;`\n\n## Description\n\nAvailable only in the tessellation control and evaluation languages, `gl_TessLevelInner` is used to assign values to the corresponding inner tesellation levels of the current patch. The values written into `gl_TessLevelInner` by the tessellation control shader are used by the tessellation primitive generator to control primitive tessellation and may be read by the subsequent tessellation evaluation shader.\n\nAs inputs to the tessellation evaluation shader, `gl_TessLevelInner` contains the values written by the tessellation control shader, if present. If no tessellation control shader is present, it contains the default tessellation level.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_TessLevelInner |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_TessLevelOuter](gl_tesslevelouter.xhtml), [gl_TessCoord](gl_tesscoord.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_TessLevelInner.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_TessLevelInner.xhtml)"
- name: gl_TessLevelOuter
  id: gl_tesslevelouter.xhtml
  summary: Available only in the tessellation control and evaluation languages, gl_TessLevelOuter is used to assign values to the corresponding outer tesellation levels of the current patch
  description: "## Name\n\ngl_TessLevelOuter — contains the outer tessellation levels for the current patch\n\n## Declaration\n\n``` programlisting\n// In tessellation control shaders\n```\n\n`out ``float ``gl_TessLevelOuter[4] ``;`\n\n``` programlisting\n// In tessellation evaluation shaders\n```\n\n`in ``float ``gl_TessLevelOuter[4] ``;`\n\n## Description\n\nAvailable only in the tessellation control and evaluation languages, `gl_TessLevelOuter` is used to assign values to the corresponding outer tesellation levels of the current patch. The values written into `gl_TessLevelOuter` by the tessellation control shader are used by the tessellation primitive generator to control primitive tessellation and may be read by the subsequent tessellation evaluation shader.\n\nAs inputs to the tessellation evaluation shader, `gl_TessLevelOuter` contains the values written by the tessellation control shader, if present. If no tessellation control shader is present, it contains the default tessellation level.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_TessLevelOuter |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_TessLevelInner](gl_tesslevelinner.xhtml), [gl_TessCoord](gl_tesscoord.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_TessLevelOuter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_TessLevelOuter.xhtml)"
- name: gl_VertexID
  id: gl_vertexid.xhtml
  summary: gl_VertexID is a vertex language input variable that holds an integer index for the vertex
  description: "## Name\n\ngl_VertexID — contains the index of the current vertex\n\n## Declaration\n\n`in ``int ``gl_VertexID ``;`\n\n## Description\n\n`gl_VertexID` is a vertex language input variable that holds an integer index for the vertex. The index is implicitly generated by `glDrawArrays` and other commands that do not reference the content of the `GL_ELEMENT_ARRAY_BUFFER`, or explicitly generated from the content of the `GL_ELEMENT_ARRAY_BUFFER` by commands such as `glDrawElements`. For `glDrawElements` forms that take a *`basevertex`*, `gl_VertexID` will have this value added to the index from the buffer.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| `gl_VertexID`     |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_InstanceID](gl_instanceid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_VertexID.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_VertexID.xhtml)"
- name: gl_ViewportIndex
  id: gl_viewportindex.xhtml
  summary: In the geometry language, gl_ViewportIndex is used to specify the index of the viewport to which the next primitive emitted from the shader should be drawn
  description: "## Name\n\ngl_ViewportIndex — contains the index of the viewport to be used in viewport transformation and scissoring\n\n## Declaration\n\n``` programlisting\n// In geometry shaders\n```\n\n`out ``int ``gl_ViewportIndex ``;`\n\n``` programlisting\n// In fragment shaders\n```\n\n`in ``int ``gl_ViewportIndex ``;`\n\n## Description\n\nIn the geometry language, `gl_ViewportIndex` is used to specify the index of the viewport to which the next primitive emitted from the shader should be drawn. Primitives generated by the geometry shader will undergo viewport transformation and scissor testing using the viewport transformation and scissor rectangle selected by the value of `gl_ViewportIndex`. The viewport index used will come from one of the vertices in the primitive being shaded. However, which vertex the viewport index comes from is implementation-defined, and so it is recommended to use the same viewport index for all vertices of a primitive. If a geometry shader does not assign a value to `gl_ViewportIndex`, viewport transform and scissor rectangle zero will be used. If a geometry shader statically assigns a value to `gl_ViewportIndex` and there is a path through the shader that does not assign a value to `gl_ViewportIndex`, the value of `gl_ViewportIndex` is undefined for executions of the shader that take that path.\n\nIn the fragment language, `gl_ViewportIndex` will have the same value that was written to the output variable `gl_ViewportIndex` in the geometry stage. If the geometry stage does not dynamically assign to `gl_ViewportIndex`, the value of `gl_ViewportIndex` in the fragment shader will be undefined. If the geometry stage makes no static assignment to `gl_ViewportIndex`, the fragment stage will read zero. Otherwise, the fragment stage will read the same value written by the geometry stage, even if that value is out of range. If a fragment shader contains a static access to `gl_ViewportIndex`, it will count against the implementation defined limit for the maximum number of inputs to the fragment stage.\n\n## Version Support\n\n|                                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:----------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                 |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_ViewportIndex (geometry stage) |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| gl_ViewportIndex (fragment stage) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_Layer](gl_layer.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_ViewportIndex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_ViewportIndex.xhtml)"
- name: gl_WorkGroupID
  id: gl_workgroupid.xhtml
  summary: In the compute language, gl_WorkGroupID contains the 3-dimensional index of the global work group that the current compute shader invocation is executing within
  description: "## Name\n\ngl_WorkGroupID — contains the index of the workgroup currently being operated on by a compute shader\n\n## Declaration\n\n`in ``uvec3 ``gl_WorkGroupID ``;`\n\n## Description\n\nIn the compute language, `gl_WorkGroupID` contains the 3-dimensional index of the global work group that the current compute shader invocation is executing within. The possible values range across the parameters passed into `glDispatchCompute`, i.e., from (0, 0, 0) to (`gl_NumWorkGroups.x` - 1, `gl_NumWorkGroups.y` - 1, `gl_NumWorkGroups.z` - 1).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_WorkGroupID    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_NumWorkGroups](gl_numworkgroups.xhtml), [gl_WorkGroupID](gl_workgroupid.xhtml), [gl_LocalInvocationID](gl_localinvocationid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_WorkGroupID.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_WorkGroupID.xhtml)"
- name: gl_WorkGroupSize
  id: gl_workgroupsize.xhtml
  summary: In the compute language, gl_WorkGroupSize contains the size of a workgroup declared by a compute shader
  description: "## Name\n\ngl_WorkGroupSize — contains the size of the workgroup operated on by a compute shader\n\n## Declaration\n\n`const ``uvec3 ``gl_WorkGroupSize ``;`\n\n## Description\n\nIn the compute language, `gl_WorkGroupSize` contains the size of a workgroup declared by a compute shader. The size of the work group in the X, Y, and Z dimensions is stored in the x, y, and z components of `gl_WorkGroupSize`. The values stored in `gl_WorkGroupSize` match those specified in the required `local_size_x`, `local_size_y`, and `local_size_z` layout qualifiers for the current shader. This value is constant so that it can be used to size arrays of memory that can be shared within the local work group.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Variable Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| gl_WorkGroupSize  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[gl_NumWorkGroups](gl_numworkgroups.xhtml), [gl_WorkGroupID](gl_workgroupid.xhtml), [gl_LocalInvocationID](gl_localinvocationid.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/gl_WorkGroupSize.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/gl_WorkGroupSize.xhtml)"
- name: glActiveShaderProgram
  id: glactiveshaderprogram.xhtml
  summary: pipeline Specifies the program pipeline object to set the active program object for
  description: "## Name\n\nglActiveShaderProgram — set the active program object for a program pipeline object\n\n## C Specification\n\n`void `**`glActiveShaderProgram`**`(` GLuint `pipeline`, GLuint `program``)`;\n\n## Parameters\n\n *`pipeline`*  \nSpecifies the program pipeline object to set the active program object for.\n\n *`program`*  \nSpecifies the program object to set as the active program pipeline object *`pipeline`*.\n\n## Description\n\n`glActiveShaderProgram` sets the linked program named by *`program`* to be the active program for the program pipeline object *`pipeline`*. The active program in the active program pipeline object is the target of calls to [glUniform](gluniform.xhtml) when no program has been made current through a call to [glUseProgram](gluseprogram.xhtml).\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`pipeline`* is not a name previously returned from a call to [glGenProgramPipelines](glgenprogrampipelines.xhtml) or if such a name has been deleted by a call to [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml).\n\n`GL_INVALID_OPERATION` is generated if *`program`* refers to a program object that has not been successfully linked.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glActiveShaderProgram`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenProgramPipelines](glgenprogrampipelines.xhtml), [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml), [glIsProgramPipeline](glisprogrampipeline.xhtml), [glUseProgram](gluseprogram.xhtml), [glUniform](gluniform.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glActiveShaderProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glActiveShaderProgram.xhtml)"
- name: glActiveTexture
  id: glactivetexture.xhtml
  summary: texture Specifies which texture unit to make active
  description: "## Name\n\nglActiveTexture — select active texture unit\n\n## C Specification\n\n`void `**`glActiveTexture`**`(` GLenum `texture``)`;\n\n## Parameters\n\n *`texture`*  \nSpecifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. *`texture`* must be one of `GL_TEXTURE`*i*, where *i* ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one. The initial value is `GL_TEXTURE0`.\n\n## Description\n\n`glActiveTexture` selects which texture unit subsequent texture state calls will affect. The number of texture units an implementation supports is implementation dependent, but must be at least 80.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`texture`* is not one of `GL_TEXTURE`*i*, where *i* ranges from zero to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS` minus one.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_ACTIVE_TEXTURE`, or `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glActiveTexture`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenTextures](glgentextures.xhtml), [glBindTexture](glbindtexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glDeleteTextures](gldeletetextures.xhtml) [glIsTexture](glistexture.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage2DMultisample](glteximage2dmultisample.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexImage3DMultisample](glteximage3dmultisample.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml),\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glActiveTexture.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glActiveTexture.xhtml)"
- name: glAttachShader
  id: glattachshader.xhtml
  summary: program Specifies the program object to which a shader object will be attached
  description: "## Name\n\nglAttachShader — Attaches a shader object to a program object\n\n## C Specification\n\n`void `**`glAttachShader`**`(` GLuint `program`, GLuint `shader``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to which a shader object will be attached.\n\n *`shader`*  \nSpecifies the shader object that is to be attached.\n\n## Description\n\nIn order to create a complete shader program, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. `glAttachShader` attaches the shader object specified by *`shader`* to the program object specified by *`program`*. This indicates that *`shader`* will be included in link operations that will be performed on *`program`*.\n\nAll operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. It is permissible to attach multiple shader objects of the same type because each may contain a portion of the complete shader. It is also permissible to attach a shader object to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until [glDetachShader](gldetachshader.xhtml) is called to detach it from all program objects to which it is attached.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if either *`program`* or *`shader`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* is not a shader object.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* is already attached to *`program`*.\n\n## Associated Gets\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with the handle of a valid program object\n\n[glGetShaderInfoLog](glgetshaderinfolog.xhtml)\n\n[glGetShaderSource](glgetshadersource.xhtml)\n\n[glIsProgram](glisprogram.xhtml)\n\n[glIsShader](glisshader.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glAttachShader`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCompileShader](glcompileshader.xhtml), [glCreateShader](glcreateshader.xhtml), [glDeleteShader](gldeleteshader.xhtml), [glDetachShader](gldetachshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glShaderSource](glshadersource.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glAttachShader.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glAttachShader.xhtml)"
- name: glBeginConditionalRender
  id: glbeginconditionalrender.xhtml
  summary: id Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded
  description: "## Name\n\nglBeginConditionalRender — start conditional rendering\n\n## C Specification\n\n`void `**`glBeginConditionalRender`**`(` GLuint `id`, GLenum `mode``)`;\n\n`void `**`glEndConditionalRender`**`(` `void``)`;\n\n## Parameters for `glBeginConditionalRender`\n\n *`id`*  \nSpecifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.\n\n *`mode`*  \nSpecifies how `glBeginConditionalRender` interprets the results of the occlusion query.\n\n## Description\n\nConditional rendering is started using `glBeginConditionalRender` and ended using `glEndConditionalRender`. During conditional rendering, all vertex array commands, as well as [glClear](glclear.xhtml) and [glClearBuffer](glclearbuffer.xhtml) have no effect if the (`GL_SAMPLES_PASSED`) result of the query object *`id`* is zero, or if the (`GL_ANY_SAMPLES_PASSED`) result is `GL_FALSE`. The results of commands setting the current vertex state, such as [glVertexAttrib](glvertexattrib.xhtml) are undefined. If the (`GL_SAMPLES_PASSED`) result is non-zero or if the (`GL_ANY_SAMPLES_PASSED`) result is `GL_TRUE`, such commands are not discarded. The *`id`* parameter to `glBeginConditionalRender` must be the name of a query object previously returned from a call to [glGenQueries](glgenqueries.xhtml). *`mode`* specifies how the results of the query object are to be interpreted. If *`mode`* is `GL_QUERY_WAIT`, the GL waits for the results of the query to be available and then uses the results to determine if subsequent rendering commands are discarded. If *`mode`* is `GL_QUERY_NO_WAIT`, the GL may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.\n\nIf *`mode`* is `GL_QUERY_BY_REGION_WAIT`, the GL will also wait for occlusion query results and discard rendering commands if the result of the occlusion query is zero. If the query result is non-zero, subsequent rendering commands are executed, but the GL may discard the results of the commands for any region of the framebuffer that did not contribute to the sample count in the specified occlusion query. Any such discarding is done in an implementation-dependent manner, but the rendering command results may not be discarded for any samples that contributed to the occlusion query sample count. If *`mode`* is `GL_QUERY_BY_REGION_NO_WAIT`, the GL operates as in `GL_QUERY_BY_REGION_WAIT`, but may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.\n\n## Notes\n\n`glBeginConditionalRender` and `glEndConditionalRender` are available only if the GL version is 3.0 or greater.\n\nThe `GL_ANY_SAMPLES_PASSED` query result is available only if the GL version is 3.3 or greater.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`id`* is not the name of an existing query object.\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of the accepted tokens.\n\n`GL_INVALID_OPERATION` is generated if `glBeginConditionalRender` is called while conditional rendering is active, or if `glEndConditionalRender` is called while conditional rendering is inactive.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of a query object with a target other than `GL_SAMPLES_PASSED` or `GL_ANY_SAMPLES_PASSED`.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of a query currently in progress.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBeginConditionalRender`  |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glEndConditionalRender`    |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenQueries](glgenqueries.xhtml), [glDeleteQueries](gldeletequeries.xhtml), [glBeginQuery](glbeginquery.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginConditionalRender.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginConditionalRender.xhtml)"
- name: glBeginQuery
  id: glbeginquery.xhtml
  summary: target Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery
  description: "## Name\n\nglBeginQuery — delimit the boundaries of a query object\n\n## C Specification\n\n`void `**`glBeginQuery`**`(` GLenum `target`, GLuint `id``)`;\n\n`void `**`glEndQuery`**`(` GLenum `target``)`;\n\n## Parameters for `glBeginQuery`\n\n *`target`*  \nSpecifies the target type of query object established between `glBeginQuery` and the subsequent `glEndQuery`. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.\n\n *`id`*  \nSpecifies the name of a query object.\n\n## Parameters for `glEndQuery`\n\n *`target`*  \nSpecifies the target type of query object to be concluded. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.\n\n## Description\n\n`glBeginQuery` and `glEndQuery` delimit the boundaries of a query object. *`query`* must be a name previously returned from a call to [glGenQueries](glgenqueries.xhtml). If a query object with name *`id`* does not yet exist it is created with the type determined by *`target`*. *`target`* must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. The behavior of the query object depends on its type and is as follows.\n\nIf *`target`* is `GL_SAMPLES_PASSED`, *`id`* must be an unused name, or the name of an existing occlusion query object. When `glBeginQuery` is executed, the query object's samples-passed counter is reset to 0. Subsequent rendering will increment the counter for every sample that passes the depth test. If the value of `GL_SAMPLE_BUFFERS` is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of `GL_SAMPLE_BUFFERS` is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of `GL_SAMPLES` if any sample in the fragment is covered. When `glEndQuery` is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nIf *`target`* is `GL_ANY_SAMPLES_PASSED` or `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, *`id`* must be an unused name, or the name of an existing boolean occlusion query object. When `glBeginQuery` is executed, the query object's samples-passed flag is reset to `GL_FALSE`. Subsequent rendering causes the flag to be set to `GL_TRUE` if any sample passes the depth test in the case of `GL_ANY_SAMPLES_PASSED`, or if the implementation determines that any sample might pass the depth test in the case of `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`. The implementation may be able to provide a more efficient test in the case of `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` if some false positives are acceptable to the application. When `glEndQuery` is executed, the samples-passed flag is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nIf *`target`* is `GL_PRIMITIVES_GENERATED`, *`id`* must be an unused name, or the name of an existing primitive query object previously bound to the `GL_PRIMITIVES_GENERATED` query binding. When `glBeginQuery` is executed, the query object's primitives-generated counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader, or from the vertex shader if no geometry shader is present. When `glEndQuery` is executed, the primitives-generated counter is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nIf *`target`* is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, *`id`* must be an unused name, or the name of an existing primitive query object previously bound to the `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN` query binding. When `glBeginQuery` is executed, the query object's primitives-written counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s). If transform feedback mode is not activated between the call to `glBeginQuery` and `glEndQuery`, the counter will not be incremented. When `glEndQuery` is executed, the primitives-written counter is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nIf *`target`* is `GL_TIME_ELAPSED`, *`id`* must be an unused name, or the name of an existing timer query object previously bound to the `GL_TIME_ELAPSED` query binding. When `glBeginQuery` is executed, the query object's time counter is reset to 0. When `glEndQuery` is executed, the elapsed server time that has passed since the call to `glBeginQuery` is written into the query object's time counter. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nQuerying the `GL_QUERY_RESULT` implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. `GL_QUERY_RESULT_AVAILABLE` can be queried to determine if the result is immediately available or if the rendering is not yet complete.\n\n## Notes\n\nIf the query target's count exceeds the maximum value representable in the number of available bits, as reported by [glGetQueryiv](glgetqueryiv.xhtml) with *`target`* set to the appropriate query target and *`pname`* `GL_QUERY_COUNTER_BITS`, the count becomes undefined.\n\nAn implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.\n\nWhen `GL_SAMPLE_BUFFERS` is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test. When `GL_SAMPLE_BUFFERS` is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test.\n\nThe query targets `GL_ANY_SAMPLES_PASSED`, and `GL_TIME_ELAPSED` are availale only if the GL version is 3.3 or higher.\n\nThe query target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only of the GL version is 4.3 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of the accepted tokens.\n\n`GL_INVALID_OPERATION` is generated if `glBeginQuery` is executed while a query object of the same *`target`* is already active.\n\n`GL_INVALID_OPERATION` is generated if `glEndQuery` is executed when a query object of the same *`target`* is not active.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is 0.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of an already active query object.\n\n`GL_INVALID_OPERATION` is generated if *`id`* refers to an existing query object whose type does not does not match *`target`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBeginQuery`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glEndQuery`                |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBeginQueryIndexed](glbeginqueryindexed.xhtml), [glDeleteQueries](gldeletequeries.xhtml), `glEndQuery`, [glGenQueries](glgenqueries.xhtml), [glGetQueryObject](glgetqueryobject.xhtml), [glGetQueryiv](glgetqueryiv.xhtml), [glIsQuery](glisquery.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginQuery.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginQuery.xhtml)"
- name: glBeginQueryIndexed
  id: glbeginqueryindexed.xhtml
  summary: target Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed
  description: "## Name\n\nglBeginQueryIndexed, glEndQueryIndexed — delimit the boundaries of a query object on an indexed target\n\n## C Specification\n\n`void `**`glBeginQueryIndexed`**`(` GLenum `target`, GLuint `index`, GLuint `id``)`;\n\n`void `**`glEndQueryIndexed`**`(` GLenum `target`, GLuint `index``)`;\n\n## Parameters for `glBeginQueryIndexed`\n\n *`target`*  \nSpecifies the target type of query object established between `glBeginQueryIndexed` and the subsequent `glEndQueryIndexed`. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.\n\n *`index`*  \nSpecifies the index of the query target upon which to begin the query.\n\n *`id`*  \nSpecifies the name of a query object.\n\n## Parameters for `glEndQueryIndexed`\n\n *`target`*  \nSpecifies the target type of query object to be concluded. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.\n\n *`index`*  \nSpecifies the index of the query target upon which to end the query.\n\n## Description\n\n`glBeginQueryIndexed` and `glEndQueryIndexed` delimit the boundaries of a query object. *`query`* must be a name previously returned from a call to [glGenQueries](glgenqueries.xhtml). If a query object with name *`id`* does not yet exist it is created with the type determined by *`target`*. *`target`* must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. The behavior of the query object depends on its type and is as follows.\n\n*`index`* specifies the index of the query target and must be between a *`target`*-specific maximum.\n\nIf *`target`* is `GL_SAMPLES_PASSED`, *`id`* must be an unused name, or the name of an existing occlusion query object. When `glBeginQueryIndexed` is executed, the query object's samples-passed counter is reset to 0. Subsequent rendering will increment the counter for every sample that passes the depth test. If the value of `GL_SAMPLE_BUFFERS` is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of `GL_SAMPLE_BUFFERS` is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of `GL_SAMPLES` if any sample in the fragment is covered. When `glEndQueryIndexed` is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_SAMPLES_PASSED`, *`index`* must be zero.\n\nIf *`target`* is `GL_ANY_SAMPLES_PASSED`, *`id`* must be an unused name, or the name of an existing boolean occlusion query object. When `glBeginQueryIndexed` is executed, the query object's samples-passed flag is reset to `GL_FALSE`. Subsequent rendering causes the flag to be set to `GL_TRUE` if any sample passes the depth test. When `glEndQueryIndexed` is executed, the samples-passed flag is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_ANY_SAMPLES_PASSED`, *`index`* must be zero.\n\nIf *`target`* is `GL_PRIMITIVES_GENERATED`, *`id`* must be an unused name, or the name of an existing primitive query object previously bound to the `GL_PRIMITIVES_GENERATED` query binding. When `glBeginQueryIndexed` is executed, the query object's primitives-generated counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader to the stream given by *`index`*, or from the vertex shader if *`index`* is zero and no geometry shader is present. When `glEndQueryIndexed` is executed, the primitives-generated counter for stream *`index`* is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_PRIMITIVES_GENERATED`, *`index`* must be less than the value of `GL_MAX_VERTEX_STREAMS`.\n\nIf *`target`* is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, *`id`* must be an unused name, or the name of an existing primitive query object previously bound to the `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN` query binding. When `glBeginQueryIndexed` is executed, the query object's primitives-written counter for the stream specified by *`index`* is reset to 0. Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s) for stream *`index`*. If transform feedback mode is not activated between the call to `glBeginQueryIndexed` and `glEndQueryIndexed`, the counter will not be incremented. When `glEndQueryIndexed` is executed, the primitives-written counter for stream *`index`* is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, *`index`* must be less than the value of `GL_MAX_VERTEX_STREAMS`.\n\nIf *`target`* is `GL_TIME_ELAPSED`, *`id`* must be an unused name, or the name of an existing timer query object previously bound to the `GL_TIME_ELAPSED` query binding. When `glBeginQueryIndexed` is executed, the query object's time counter is reset to 0. When `glEndQueryIndexed` is executed, the elapsed server time that has passed since the call to `glBeginQueryIndexed` is written into the query object's time counter. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_TIME_ELAPSED`, *`index`* must be zero.\n\nQuerying the `GL_QUERY_RESULT` implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. `GL_QUERY_RESULT_AVAILABLE` can be queried to determine if the result is immediately available or if the rendering is not yet complete.\n\n## Notes\n\nIf the query target's count exceeds the maximum value representable in the number of available bits, as reported by [glGetQueryiv](glgetqueryiv.xhtml) with *`target`* set to the appropriate query target and *`pname`* `GL_QUERY_COUNTER_BITS`, the count becomes undefined.\n\nAn implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.\n\nWhen `GL_SAMPLE_BUFFERS` is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test. When `GL_SAMPLE_BUFFERS` is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test.\n\nCalling [glBeginQuery](glbeginquery.xhtml) or `glEndQuery` is equivalent to calling [glBeginQueryIndexed](glbeginqueryindexed.xhtml) or `glEndQueryIndexed` with *`index`* set to zero, respectively.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of the accepted tokens.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than the query target-specific maximum.\n\n`GL_INVALID_OPERATION` is generated if `glBeginQueryIndexed` is executed while a query object of the same *`target`* is already active.\n\n`GL_INVALID_OPERATION` is generated if `glEndQueryIndexed` is executed when a query object of the same *`target`* is not active.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is 0.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of an already active query object.\n\n`GL_INVALID_OPERATION` is generated if *`id`* refers to an existing query object whose type does not does not match *`target`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBeginQueryIndexed`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glEndQueryIndexed`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBeginQuery](glbeginquery.xhtml), [glDeleteQueries](gldeletequeries.xhtml), `glEndQuery`, [glGenQueries](glgenqueries.xhtml), [glGetQueryObject](glgetqueryobject.xhtml), [glGetQueryiv](glgetqueryiv.xhtml), [glIsQuery](glisquery.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginQueryIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginQueryIndexed.xhtml)"
- name: glBeginTransformFeedback
  id: glbegintransformfeedback.xhtml
  summary: primitiveMode Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback
  description: "## Name\n\nglBeginTransformFeedback — start transform feedback operation\n\n## C Specification\n\n`void `**`glBeginTransformFeedback`**`(` GLenum `primitiveMode``)`;\n\n`void `**`glEndTransformFeedback`**`(` `void``)`;\n\n## Parameters for `glBeginTransformFeedback`\n\n *`primitiveMode`*  \nSpecify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.\n\n## Description\n\nTransform feedback mode captures the values of varying variables written by the vertex shader (or, if active, the geometry shader). Transform feedback is said to be active after a call to `glBeginTransformFeedback` until a subsequent call to `glEndTransformFeedback`. Transform feedback commands must be paired.\n\nIf no geometry shader is present, while transform feedback is active the *`mode`* parameter to [glDrawArrays](gldrawarrays.xhtml) must match those specified in the following table:\n\n|  **Transform Feedback *`primitiveMode`***  |  **Allowed Render Primitive *`modes`***                                                                         |\n|:-------------------------------------------|:----------------------------------------------------------------------------------------------------------------|\n| `GL_POINTS`                                | `GL_POINTS`                                                                                                     |\n| `GL_LINES`                                 | `GL_LINES`, `GL_LINE_LOOP`, `GL_LINE_STRIP`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`                    |\n| `GL_TRIANGLES`                             | `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` |\n\nIf a geometry shader is present, the output primitive type from the geometry shader must match those provided in the following table:\n\n|  **Transform Feedback *`primitiveMode`***  |  **Allowed Geometry Shader Output Primitive Type**  |\n|:-------------------------------------------|:----------------------------------------------------|\n| `GL_POINTS`                                | `points`                                            |\n| `GL_LINES`                                 | `line_strip`                                        |\n| `GL_TRIANGLES`                             | `triangle_strip`                                    |\n\n## Notes\n\nGeometry shaders, and the `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY` and `GL_LINE_STRIP_ADJACENCY` primtive modes are available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if `glBeginTransformFeedback` is executed while transform feedback is active.\n\n`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` is executed while transform feedback is not active.\n\n`GL_INVALID_OPERATION` is generated by [glDrawArrays](gldrawarrays.xhtml) if no geometry shader is present, transform feedback is active and *`mode`* is not one of the allowed modes.\n\n`GL_INVALID_OPERATION` is generated by [glDrawArrays](gldrawarrays.xhtml) if a geometry shader is present, transform feedback is active and the output primitive type of the geometry shader does not match the transform feedback *`primitiveMode`*.\n\n`GL_INVALID_OPERATION` is generated by `glBeginTransformFeedback` if any binding point used in transform feedback mode does not have a buffer object bound.\n\n`GL_INVALID_OPERATION` is generated by `glBeginTransformFeedback` if no binding points would be used, either because no program object is active of because the active program object has specified no varying variables to record.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBeginTransformFeedback`  |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glEndTransformFeedback`    |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginTransformFeedback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginTransformFeedback.xhtml)"
- name: glBindAttribLocation
  id: glbindattriblocation.xhtml
  summary: program Specifies the handle of the program object in which the association is to be made
  description: "## Name\n\nglBindAttribLocation — Associates a generic vertex attribute index with a named attribute variable\n\n## C Specification\n\n`void `**`glBindAttribLocation`**`(` GLuint `program`, GLuint `index`, const GLchar \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the handle of the program object in which the association is to be made.\n\n *`index`*  \nSpecifies the index of the generic vertex attribute to be bound.\n\n *`name`*  \nSpecifies a null terminated string containing the name of the vertex shader attribute variable to which *`index`* is to be bound.\n\n## Description\n\n`glBindAttribLocation` is used to associate a user-defined attribute variable in the program object specified by *`program`* with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in *`name`*. The generic vertex attribute index to be bound to this variable is specified by *`index`*. When *`program`* is made part of current state, values provided via the generic vertex attribute *`index`* will modify the value of the user-defined attribute variable specified by *`name`*.\n\nIf *`name`* refers to a matrix attribute variable, *`index`* refers to the first column of the matrix. Other matrix columns are then automatically bound to locations *`index+1`* for a matrix of type `mat2`; *`index+1`* and *`index+2`* for a matrix of type `mat3`; and *`index+1`*, *`index+2`*, and *`index+3`* for a matrix of type `mat4`.\n\nThis command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from zero to the value of `GL_MAX_VERTEX_ATTRIBS` minus one. The values sent to each generic attribute index are part of current state. If a different program object is made current by calling [glUseProgram](gluseprogram.xhtml), the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to *`index`*.\n\nAttribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling `glBindAttribLocation`. Attribute bindings do not go into effect until [glLinkProgram](gllinkprogram.xhtml) is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs.\n\nAny attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.\n\n## Notes\n\n`glBindAttribLocation` can be called before any vertex shader objects are bound to the specified program object. It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader.\n\nIf *`name`* was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices, but you can bind multiple user-defined attribute variables to the same index.\n\nApplications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index. This is called *aliasing*, and it is allowed only if just one of the aliased attributes is active in the executable program, or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location. The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing.\n\nActive attributes that are not explicitly bound will be bound by the linker when [glLinkProgram](gllinkprogram.xhtml) is called. The locations assigned can be queried by calling [glGetAttribLocation](glgetattriblocation.xhtml).\n\nOpenGL copies the *`name`* string when `glBindAttribLocation` is called, so an application may free its copy of the *`name`* string immediately after the function returns.\n\nGeneric attribute locations may be specified in the shader source text using a `location` layout qualifier. In this case, the location of the attribute specified in the shader's source takes precedence and may be queried by calling [glGetAttribLocation](glgetattriblocation.xhtml).\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_OPERATION` is generated if *`name`* starts with the reserved prefix \"gl\\_\".\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIBS`\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with argument *`program`*\n\n[glGetAttribLocation](glgetattriblocation.xhtml) with arguments *`program`* and *`name`*\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindAttribLocation`      |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n`glDisableVertexAttribArray`, [glEnableVertexAttribArray](glenablevertexattribarray.xhtml), [glUseProgram](gluseprogram.xhtml), [glVertexAttrib](glvertexattrib.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindAttribLocation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindAttribLocation.xhtml)"
- name: glBindBuffer
  id: glbindbuffer.xhtml
  summary: buffer Specifies the name of a buffer object
  description: "## Name\n\nglBindBuffer — bind a named buffer object\n\n## C Specification\n\n`void `**`glBindBuffer`**`(` GLenum `target`, GLuint `buffer``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of a buffer object.\n\n## Description\n\n`glBindBuffer` binds a buffer object to the specified buffer binding point. Calling `glBindBuffer` with *`target`* set to one of the accepted symbolic constants and *`buffer`* set to the name of a buffer object binds that buffer object name to the target. If no buffer object with name *`buffer`* exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that target is automatically broken.\n\nBuffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, *`buffer`* set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.\n\n[glGenBuffers](glgenbuffers.xhtml) must be used to generate a set of unused buffer object names.\n\nThe state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with `GL_READ_WRITE` access and `GL_STATIC_DRAW` usage.\n\nWhile a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an `GL_INVALID_OPERATION` error.\n\nWhen a non-zero buffer object is bound to the `GL_ARRAY_BUFFER` target, the vertex array pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.\n\nWhen a non-zero buffer object is bound to the `GL_DRAW_INDIRECT_BUFFER` target, parameters for draws issued through [glDrawArraysIndirect](gldrawarraysindirect.xhtml) and [glDrawElementsIndirect](gldrawelementsindirect.xhtml) are sourced from the specified offset in that buffer object's data store.\n\nWhen a non-zero buffer object is bound to the `GL_DISPATCH_INDIRECT_BUFFER` target, the parameters for compute dispatches issued through [glDispatchComputeIndirect](gldispatchcomputeindirect.xhtml) are sourced from the specified offset in that buffer object's data store.\n\nWhile a non-zero buffer object is bound to the `GL_ELEMENT_ARRAY_BUFFER` target, the indices parameter of [glDrawElements](gldrawelements.xhtml), [glDrawElementsInstanced](gldrawelementsinstanced.xhtml), [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawRangeElementsBaseVertex](gldrawrangeelementsbasevertex.xhtml), [glMultiDrawElements](glmultidrawelements.xhtml), or [glMultiDrawElementsBaseVertex](glmultidrawelementsbasevertex.xhtml) is interpreted as an offset within the buffer object measured in basic machine units.\n\nWhile a non-zero buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target, the following commands are affected: [glGetCompressedTexImage](glgetcompressedteximage.xhtml), [glGetTexImage](glgetteximage.xhtml), and [glReadPixels](glreadpixels.xhtml). The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.\n\nWhile a non-zero buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target, the following commands are affected: [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), and [glTexSubImage3D](gltexsubimage3d.xhtml). The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units.\n\nThe buffer targets `GL_COPY_READ_BUFFER` and `GL_COPY_WRITE_BUFFER` are provided to allow [glCopyBufferSubData](glcopybuffersubdata.xhtml) to be used without disturbing the state of other bindings. However, [glCopyBufferSubData](glcopybuffersubdata.xhtml) may be used with any pair of buffer binding points.\n\nThe `GL_TRANSFORM_FEEDBACK_BUFFER` buffer binding point may be passed to `glBindBuffer`, but will not directly affect transform feedback state. Instead, the indexed `GL_TRANSFORM_FEEDBACK_BUFFER` bindings must be used through a call to [glBindBufferBase](glbindbufferbase.xhtml) or [glBindBufferRange](glbindbufferrange.xhtml). This will affect the generic `GL_TRANSFORM_FEEDBACK_BUFFER` binding.\n\nLikewise, the `GL_UNIFORM_BUFFER`, `GL_ATOMIC_COUNTER_BUFFER` and `GL_SHADER_STORAGE_BUFFER` buffer binding points may be used, but do not directly affect uniform buffer, atomic counter buffer or shader storage buffer state, respectively. [glBindBufferBase](glbindbufferbase.xhtml) or [glBindBufferRange](glbindbufferrange.xhtml) must be used to bind a buffer to an indexed uniform buffer, atomic counter buffer or shader storage buffer binding point.\n\nThe `GL_QUERY_BUFFER` binding point is used to specify a buffer object that is to receive the results of query objects through calls to the [glGetQueryObject](glgetqueryobject.xhtml) family of commands.\n\nA buffer object binding created with `glBindBuffer` remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with [glDeleteBuffers](gldeletebuffers.xhtml).\n\nOnce created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.\n\n## Notes\n\nThe `GL_COPY_READ_BUFFER`, `GL_UNIFORM_BUFFER` and `GL_TEXTURE_BUFFER` targets are available only if the GL version is 3.1 or greater.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of the allowable values.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is not a name previously returned from a call to [glGenBuffers](glgenbuffers.xhtml).\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_ARRAY_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_ATOMIC_COUNTER_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_COPY_READ_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_COPY_WRITE_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_DRAW_INDIRECT_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_DISPATCH_INDIRECT_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_ELEMENT_ARRAY_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_PACK_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_SHADER_STORAGE_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_UNIFORM_BUFFER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindBuffer`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glGet](glget.xhtml), [glIsBuffer](glisbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBuffer.xhtml)"
- name: glBindBufferBase
  id: glbindbufferbase.xhtml
  summary: target Specify the target of the bind operation
  description: "## Name\n\nglBindBufferBase — bind a buffer object to an indexed buffer target\n\n## C Specification\n\n`void `**`glBindBufferBase`**`(` GLenum `target`, GLuint `index`, GLuint `buffer``)`;\n\n## Parameters\n\n *`target`*  \nSpecify the target of the bind operation. *`target`* must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.\n\n *`index`*  \nSpecify the index of the binding point within the array specified by *`target`*.\n\n *`buffer`*  \nThe name of a buffer object to bind to the specified binding point.\n\n## Description\n\n`glBindBufferBase` binds the buffer object *`buffer`* to the binding point at index *`index`* of the array of targets specified by *`target`*. Each *`target`* represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as [glBindBuffer](glbindbuffer.xhtml) or [glMapBuffer](glmapbuffer.xhtml). In addition to binding *`buffer`* to the indexed buffer binding target, `glBindBufferBase` also binds *`buffer`* to the generic buffer binding point specified by *`target`*.\n\n## Notes\n\nCalling `glBindBufferBase` is equivalent to calling [glBindBufferRange](glbindbufferrange.xhtml) with *`offset`* zero and *`size`* equal to the size of the buffer.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_SHADER_STORAGE_BUFFER` target is available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the number of *`target`*-specific indexed binding points.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* does not have an associated data store, or if the size of that store is zero.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindBufferBase`          |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml),\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBufferBase.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBufferBase.xhtml)"
- name: glBindBufferRange
  id: glbindbufferrange.xhtml
  summary: target Specify the target of the bind operation
  description: "## Name\n\nglBindBufferRange — bind a range within a buffer object to an indexed buffer target\n\n## C Specification\n\n`void `**`glBindBufferRange`**`(` GLenum `target`, GLuint `index`, GLuint `buffer`, GLintptr `offset`, GLsizeiptr `size``)`;\n\n## Parameters\n\n *`target`*  \nSpecify the target of the bind operation. *`target`* must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER`, or `GL_SHADER_STORAGE_BUFFER`.\n\n *`index`*  \nSpecify the index of the binding point within the array specified by *`target`*.\n\n *`buffer`*  \nThe name of a buffer object to bind to the specified binding point.\n\n *`offset`*  \nThe starting offset in basic machine units into the buffer object *`buffer`*.\n\n *`size`*  \nThe amount of data in machine units that can be read from the buffer object while used as an indexed target.\n\n## Description\n\n`glBindBufferRange` binds a range the buffer object *`buffer`* represented by *`offset`* and *`size`* to the binding point at index *`index`* of the array of targets specified by *`target`*. Each *`target`* represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as [glBindBuffer](glbindbuffer.xhtml) or [glMapBuffer](glmapbuffer.xhtml). In addition to binding a range of *`buffer`* to the indexed buffer binding target, `glBindBufferRange` also binds the range to the generic buffer binding point specified by *`target`*.\n\n*`offset`* specifies the offset in basic machine units into the buffer object *`buffer`* and *`size`* specifies the amount of data that can be read from the buffer object while used as an indexed target.\n\n## Notes\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_SHADER_STORAGE_BUFFER` target is available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the number of *`target`*-specific indexed binding points.\n\n`GL_INVALID_VALUE` is generated if *`size`* is less than or equal to zero, or if *`offset`* + *`size`* is greater than the value of `GL_BUFFER_SIZE`.\n\nAdditional errors may be generated if *`offset`* violates any *`target`*-specific alignmemt restrictions.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindBufferRange`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml),\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBufferRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBufferRange.xhtml)"
- name: glBindBuffersBase
  id: glbindbuffersbase.xhtml
  summary: target Specify the target of the bind operation
  description: "## Name\n\nglBindBuffersBase — bind one or more buffer objects to a sequence of indexed buffer targets\n\n## C Specification\n\n`void `**`glBindBuffersBase`**`(` GLenum `target`, GLuint `first`, GLsizei `count`, const GLuint \\*`buffers``)`;\n\n## Parameters\n\n *`target`*  \nSpecify the target of the bind operation. *`target`* must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.\n\n *`first`*  \nSpecify the index of the first binding point within the array specified by *`target`*.\n\n *`count`*  \nSpecify the number of contiguous binding points to which to bind buffers.\n\n *`buffers`*  \nA pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or `NULL`.\n\n## Description\n\n`glBindBuffersBase` binds a set of *`count`* buffer objects whose names are given in the array *`buffers`* to the *`count`* consecutive binding points starting from index *`first`* of the array of targets specified by *`target`*. If *`buffers`* is `NULL` then `glBindBuffersBase` unbinds any buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following pseudo-code, which calls [glBindBufferBase](glbindbufferbase.xhtml), with the exception that the non-indexed *`target`* is not changed by `glBindBuffersBase`:\n\n``` programlisting\n    for (i = 0; i < count; i++) {\n        if (buffers != NULL) {\n            glBindBufferBase(target, first + i, buffers[i]);\n        } else {\n            glBindBufferBase(target, first + i, 0);\n        }\n    }\n```\n\nEach entry in *`buffers`* will be checked individually and if found to be invalid, the state for that buffer binding index will not be changed and an error will be generated. However, the state for other buffer binding indices referenced by the command will still be updated.\n\n## Notes\n\n`glBindBuffersBase` is available only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.\n\n`GL_INVALID_OPERATION` is generated if *`first`* + *`count`* is greater than the number of target-specific indexed binding points.\n\n`GL_INVALID_OPERATION` is generated if any value in *`buffers`* is not zero or the name of an existing buffer object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindBuffersBase`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glBindBuffersRange](glbindbuffersrange.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBuffersBase.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBuffersBase.xhtml)"
- name: glBindBuffersRange
  id: glbindbuffersrange.xhtml
  summary: target Specify the target of the bind operation
  description: "## Name\n\nglBindBuffersRange — bind ranges of one or more buffer objects to a sequence of indexed buffer targets\n\n## C Specification\n\n`void `**`glBindBuffersRange`**`(` GLenum `target`, GLuint `first`, GLsizei `count`, const GLuint \\*`buffers`, const GLintptr \\*`offsets`, const GLintptr \\*`sizes``)`;\n\n## Parameters\n\n *`target`*  \nSpecify the target of the bind operation. *`target`* must be one of `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.\n\n *`first`*  \nSpecify the index of the first binding point within the array specified by *`target`*.\n\n *`count`*  \nSpecify the number of contiguous binding points to which to bind buffers.\n\n *`buffers`*  \nA pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or `NULL`.\n\n *`offsets`*  \nA pointer to an array of offsets into the corresponding buffer in *`buffers`* to bind, or `NULL` if *`buffers`* is `NULL`.\n\n *`sizes`*  \nA pointer to an array of sizes of the corresponding buffer in *`buffers`* to bind, or `NULL` if *`buffers`* is `NULL`.\n\n## Description\n\n`glBindBuffersRange` binds a set of *`count`* ranges from buffer objects whose names are given in the array *`buffers`* to the *`count`* consecutive binding points starting from index *`first`* of the array of targets specified by *`target`*. *`offsets`* specifies the address of an array containing *`count`* starting offsets within the buffers, and *`sizes`* specifies the address of an array of *`count`* sizes of the ranges. If *`buffers`* is `NULL` then *`offsets`* and *`sizes`* are ignored and `glBindBuffersRange` unbinds any buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following pseudo-code, which calls [glBindBufferRange](glbindbufferrange.xhtml), with the exception that the non-indexed *`target`* is not changed by `glBindBuffersRange`:\n\n``` programlisting\n    for (i = 0; i < count; i++) {\n        if (buffers != NULL) {\n            glBindBufferRange(target, first + i, buffers[i], offsets[i], sizes[i]);\n        } else {\n            glBindBufferRange(target, first + i, 0);\n        }\n    }\n```\n\nEach entry in *`buffers`*, *`offsets`*, and *`sizes`* will be checked individually and if found to be invalid, the state for that buffer binding index will not be changed and an error will be generated. However, the state for other buffer binding indices referenced by the command will still be updated.\n\n## Notes\n\n`glBindBuffersBase` is available only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_ATOMIC_COUNTER_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, `GL_UNIFORM_BUFFER` or `GL_SHADER_STORAGE_BUFFER`.\n\n`GL_INVALID_OPERATION` is generated if *`first`* + *`count`* is greater than the number of target-specific indexed binding points.\n\n`GL_INVALID_OPERATION` is generated if any value in *`buffers`* is not zero or the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated by if any value in *`offsets`* is less than zero or if any value in *`sizes`* is less than zero.\n\n`GL_INVALID_VALUE` is generated if any pair of values in *`offsets`* and *`sizes`* does not respectively satisfy the constraints described for those parameters for the specified target.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindBuffersRange`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glBindBuffersRange](glbindbuffersrange.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBuffersRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindBuffersRange.xhtml)"
- name: glBindFragDataLocation
  id: glbindfragdatalocation.xhtml
  summary: glBindFragDataLocation explicitly specifies the binding of the user-defined varying out variable name to fragment shader color number colorNumber for program program
  description: "## Name\n\nglBindFragDataLocation — bind a user-defined varying out variable to a fragment shader color number\n\n## C Specification\n\n`void `**`glBindFragDataLocation`**`(` GLuint `program`, GLuint `colorNumber`, const char \\* `name``)`;\n\n## Parameters\n\n *`program`*  \nThe name of the program containing varying out variable whose binding to modify\n\n *`colorNumber`*  \nThe color number to bind the user-defined varying out variable to\n\n *`name`*  \nThe name of the user-defined varying out variable whose binding to modify\n\n## Description\n\n`glBindFragDataLocation` explicitly specifies the binding of the user-defined varying out variable *`name`* to fragment shader color number *`colorNumber`* for program *`program`*. If *`name`* was bound previously, its assigned binding is replaced with *`colorNumber`*. *`name`* must be a null-terminated string. *`colorNumber`* must be less than `GL_MAX_DRAW_BUFFERS`.\n\nThe bindings specified by `glBindFragDataLocation` have no effect until *`program`* is next linked. Bindings may be specified at any time after *`program`* has been created. Specifically, they may be specified before shader objects are attached to the program. Therefore, any name may be specified in *`name`*, including a name that is never used as a varying out variable in any fragment shader object. Names beginning with `gl_` are reserved by the GL.\n\nIn addition to the errors generated by `glBindFragDataLocation`, the program *`program`* will fail to link if:\n\n- The number of active outputs is greater than the value `GL_MAX_DRAW_BUFFERS`.\n\n- More than one varying out variable is bound to the same color number.\n\n## Notes\n\nVarying out varyings may have indexed locations assigned explicitly in the shader text using a `location` layout qualifier. If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any location assigned with `glBindFragDataLocation` is ignored.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`colorNumber`* is greater than or equal to `GL_MAX_DRAW_BUFFERS`.\n\n`GL_INVALID_OPERATION` is generated if *`name`* starts with the reserved `gl_` prefix.\n\n`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object.\n\n## Associated Gets\n\n[glGetFragDataLocation](glgetfragdatalocation.xhtml) with a valid program object and the name of a user-defined varying out variable\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindFragDataLocation`    |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateProgram](glcreateprogram.xhtml), [glGetFragDataLocation](glgetfragdatalocation.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindFragDataLocation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindFragDataLocation.xhtml)"
- name: glBindFragDataLocationIndexed
  id: glbindfragdatalocationindexed.xhtml
  summary: glBindFragDataLocationIndexed specifies that the varying out variable name in program should be bound to fragment color colorNumber when the program is next linked
  description: "## Name\n\nglBindFragDataLocationIndexed — bind a user-defined varying out variable to a fragment shader color number and index\n\n## C Specification\n\n`void `**`glBindFragDataLocationIndexed`**`(` GLuint `program`, GLuint `colorNumber`, GLuint `index`, const char \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nThe name of the program containing varying out variable whose binding to modify\n\n *`colorNumber`*  \nThe color number to bind the user-defined varying out variable to\n\n *`index`*  \nThe index of the color input to bind the user-defined varying out variable to\n\n *`name`*  \nThe name of the user-defined varying out variable whose binding to modify\n\n## Description\n\n`glBindFragDataLocationIndexed` specifies that the varying out variable *`name`* in *`program`* should be bound to fragment color *`colorNumber`* when the program is next linked. *`index`* may be zero or one to specify that the color be used as either the first or second color input to the blend equation, respectively.\n\nThe bindings specified by `glBindFragDataLocationIndexed` have no effect until *`program`* is next linked. Bindings may be specified at any time after *`program`* has been created. Specifically, they may be specified before shader objects are attached to the program. Therefore, any name may be specified in *`name`*, including a name that is never used as a varying out variable in any fragment shader object. Names beginning with `gl_` are reserved by the GL.\n\nIf *`name`* was bound previously, its assigned binding is replaced with *`colorNumber`* and *`index`*. *`name`* must be a null-terminated string. *`index`* must be less than or equal to one, and *`colorNumber`* must be less than the value of `GL_MAX_DRAW_BUFFERS` if *`index`* is zero, and less than the value of `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` if index is greater than or equal to one.\n\nIn addition to the errors generated by `glBindFragDataLocationIndexed`, the program *`program`* will fail to link if:\n\n- The number of active outputs is greater than the value `GL_MAX_DRAW_BUFFERS`.\n\n- More than one varying out variable is bound to the same color number.\n\n## Notes\n\nVarying out varyings may have locations assigned explicitly in the shader text using a `location` layout qualifier. If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any location assigned with `glBindFragDataLocation` is ignored.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`colorNumber`* is greater than or equal to `GL_MAX_DRAW_BUFFERS`.\n\n`GL_INVALID_VALUE` is generated if *`colorNumber`* is greater than or equal to `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` and *`index`* is greater than or equal to one.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than one.\n\n`GL_INVALID_OPERATION` is generated if *`name`* starts with the reserved `gl_` prefix.\n\n`GL_INVALID_OPERATION` is generated if `program` is not the name of a program object.\n\n## Associated Gets\n\n[glGetFragDataLocation](glgetfragdatalocation.xhtml) with a valid program object and the name of a user-defined varying out variable\n\n[glGetFragDataIndex](glgetfragdataindex.xhtml) with a valid program object and the name of a user-defined varying out variable\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindFragDataLocationIndexed` |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateProgram](glcreateprogram.xhtml), [glLinkProgram](gllinkprogram.xhtml) [glGetFragDataLocation](glgetfragdatalocation.xhtml), [glGetFragDataIndex](glgetfragdataindex.xhtml) [glBindFragDataLocation](glbindfragdatalocation.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindFragDataLocationIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindFragDataLocationIndexed.xhtml)"
- name: glBindFramebuffer
  id: glbindframebuffer.xhtml
  summary: target Specifies the framebuffer target of the binding operation
  description: "## Name\n\nglBindFramebuffer — bind a framebuffer to a framebuffer target\n\n## C Specification\n\n`void `**`glBindFramebuffer`**`(` GLenum `target`, GLuint `framebuffer``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the framebuffer target of the binding operation.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object to bind.\n\n## Description\n\n`glBindFramebuffer` binds the framebuffer object with name *`framebuffer`* to the framebuffer target specified by *`target`*. *`target`* must be either `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. If a framebuffer object is bound to `GL_DRAW_FRAMEBUFFER` or `GL_READ_FRAMEBUFFER`, it becomes the target for rendering or readback operations, respectively, until it is deleted or another framebuffer is bound to the corresponding bind point. Calling `glBindFramebuffer` with *`target`* set to `GL_FRAMEBUFFER` binds *`framebuffer`* to both the read and draw framebuffer targets. *`framebuffer`* is the name of a framebuffer object previously returned from a call to [glGenFramebuffers](glgenframebuffers.xhtml), or zero to break the existing binding of a framebuffer object to *`target`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`.\n\n`GL_INVALID_OPERATION` is generated if *`framebuffer`* is not zero or the name of a framebuffer previously returned from a call to [glGenFramebuffers](glgenframebuffers.xhtml).\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindFramebuffer`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml), `glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`, [glFramebufferTextureLayer](glframebuffertexturelayer.xhtml), [glDeleteFramebuffers](gldeleteframebuffers.xhtml), [glIsFramebuffer](glisframebuffer.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindFramebuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindFramebuffer.xhtml)"
- name: glBindImageTexture
  id: glbindimagetexture.xhtml
  summary: texture Specifies the name of the texture to bind to the image unit
  description: "## Name\n\nglBindImageTexture — bind a level of a texture to an image unit\n\n## C Specification\n\n`void `**`glBindImageTexture`**`(` GLuint `unit`, GLuint `texture`, GLint `level`, GLboolean `layered`, GLint `layer`, GLenum `access`, GLenum `format``)`;\n\n## Parameters\n\n *`unit`*  \nSpecifies the index of the image unit to which to bind the texture\n\n *`texture`*  \nSpecifies the name of the texture to bind to the image unit.\n\n *`level`*  \nSpecifies the level of the texture that is to be bound.\n\n *`layered`*  \nSpecifies whether a layered texture binding is to be established.\n\n *`layer`*  \nIf *`layered`* is `GL_FALSE`, specifies the layer of *`texture`* to be bound to the image unit. Ignored otherwise.\n\n *`access`*  \nSpecifies a token indicating the type of access that will be performed on the image.\n\n *`format`*  \nSpecifies the format that the elements of the image will be treated as for the purposes of formatted stores.\n\n## Description\n\n`glBindImageTexture` binds a single level of a texture to an image unit for the purpose of reading and writing it from shaders. *`unit`* specifies the zero-based index of the image unit to which to bind the texture level. *`texture`* specifies the name of an existing texture object to bind to the image unit. If *`texture`* is zero, then any existing binding to the image unit is broken. *`level`* specifies the level of the texture to bind to the image unit.\n\nIf *`texture`* is the name of a one-, two-, or three-dimensional array texture, a cube map or cube map array texture, or a two-dimensional multisample array texture, then it is possible to bind either the entire array, or only a single layer of the array to the image unit. In such cases, if *`layered`* is `GL_TRUE`, the entire array is attached to the image unit and *`layer`* is ignored. However, if *`layered`* is `GL_FALSE` then *`layer`* specifies the layer of the array to attach to the image unit.\n\n*`access`* specifies the access types to be performed by shaders and may be set to `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE` to indicate read-only, write-only or read-write access, respectively. Violation of the access type specified in *`access`* (for example, if a shader writes to an image bound with *`access`* set to `GL_READ_ONLY`) will lead to undefined results, possibly including program termination.\n\n*`format`* specifies the format that is to be used when performing formatted stores into the image from shaders. *`format`* must be compatible with the texture's internal format and must be one of the formats listed in the following table.\n\nTable 1. Internal Image Formats\n\n|  **Image Unit Format**  |  **Format Qualifier**  |\n|:------------------------|:-----------------------|\n| `GL_RGBA32F`            | `rgba32f`              |\n| `GL_RGBA16F`            | `rgba16f`              |\n| `GL_RG32F`              | `rg32f`                |\n| `GL_RG16F`              | `rg16f`                |\n| `GL_R11F_G11F_B10F`     | `r11f_g11f_b10f`       |\n| `GL_R32F`               | `r32f`                 |\n| `GL_R16F`               | `r16f`                 |\n| `GL_RGBA32UI`           | `rgba32ui`             |\n| `GL_RGBA16UI`           | `rgba16ui`             |\n| `GL_RGB10_A2UI`         | `rgb10_a2ui`           |\n| `GL_RGBA8UI`            | `rgba8ui`              |\n| `GL_RG32UI`             | `rg32ui`               |\n| `GL_RG16UI`             | `rg16ui`               |\n| `GL_RG8UI`              | `rg8ui`                |\n| `GL_R32UI`              | `r32ui`                |\n| `GL_R16UI`              | `r16ui`                |\n| `GL_R8UI`               | `r8ui`                 |\n| `GL_RGBA32I`            | `rgba32i`              |\n| `GL_RGBA16I`            | `rgba16i`              |\n| `GL_RGBA8I`             | `rgba8i`               |\n| `GL_RG32I`              | `rg32i`                |\n| `GL_RG16I`              | `rg16i`                |\n| `GL_RG8I`               | `rg8i`                 |\n| `GL_R32I`               | `r32i`                 |\n| `GL_R16I`               | `r16i`                 |\n| `GL_R8I`                | `r8i`                  |\n| `GL_RGBA16`             | `rgba16`               |\n| `GL_RGB10_A2`           | `rgb10_a2`             |\n| `GL_RGBA8`              | `rgba8`                |\n| `GL_RG16`               | `rg16`                 |\n| `GL_RG8`                | `rg8`                  |\n| `GL_R16`                | `r16`                  |\n| `GL_R8`                 | `r8`                   |\n| `GL_RGBA16_SNORM`       | `rgba16_snorm`         |\n| `GL_RGBA8_SNORM`        | `rgba8_snorm`          |\n| `GL_RG16_SNORM`         | `rg16_snorm`           |\n| `GL_RG8_SNORM`          | `rg8_snorm`            |\n| `GL_R16_SNORM`          | `r16_snorm`            |\n| `GL_R8_SNORM`           | `r8_snorm`             |\n\n  \n\nWhen a texture is bound to an image unit, the *`format`* parameter for the image unit need not exactly match the texture internal format as long as the formats are considered compatible as defined in the OpenGL Specification. The matching criterion used for a given texture may be determined by calling [glGetTexParameter](glgettexparameter.xhtml) with *`value`* set to `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, with return values of `GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE` and `GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS`, specifying matches by size and class, respectively.\n\n## Notes\n\nThe `glBindImageTexture` is available only if the GL version is 4.2 or greater.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`unit`* greater than or equal to the value of `GL_MAX_IMAGE_UNITS`.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`level`* or *`layer`* is less than zero.\n\n`GL_INVALID_ENUM` is generated if *`access`* or *`format`* is not one of the supported tokens.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_IMAGE_BINDING_NAME`.\n\n[glGet](glget.xhtml) with argument `GL_IMAGE_BINDING_LEVEL`.\n\n[glGet](glget.xhtml) with argument `GL_IMAGE_BINDING_LAYERED`.\n\n[glGet](glget.xhtml) with argument `GL_IMAGE_BINDING_LAYER`.\n\n[glGet](glget.xhtml) with argument `GL_IMAGE_BINDING_ACCESS`.\n\n[glGet](glget.xhtml) with argument `GL_IMAGE_BINDING_FORMAT`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindImageTexture`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenTextures](glgentextures.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml), [glBindTexture](glbindtexture.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindImageTexture.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindImageTexture.xhtml)"
- name: glBindImageTextures
  id: glbindimagetextures.xhtml
  summary: first Specifies the first image unit to which a texture is to be bound
  description: "## Name\n\nglBindImageTextures — bind one or more named texture images to a sequence of consecutive image units\n\n## C Specification\n\n`void `**`glBindImageTextures`**`(` GLuint `first`, GLsizei `count`, const GLuint \\*`textures``)`;\n\n## Parameters\n\n *`first`*  \nSpecifies the first image unit to which a texture is to be bound.\n\n *`count`*  \nSpecifies the number of textures to bind.\n\n *`textures`*  \nSpecifies the address of an array of names of existing texture objects.\n\n## Description\n\n`glBindImageTextures` binds images from an array of existing texture objects to a specified number of consecutive image units. *`count`* specifies the number of texture objects whose names are stored in the array *`textures`*. That number of texture names are read from the array and bound to the *`count`* consecutive texture units starting from *`first`*. If the name zero appears in the *`textures`* array, any existing binding to the image unit is reset. Any non-zero entry in *`textures`* must be the name of an existing texture object. When a non-zero entry in *`textures`* is present, the image at level zero is bound, the binding is considered layered, with the first layer set to zero, and the image is bound for read-write access. The image unit format parameter is taken from the internal format of the image at level zero of the texture object. For cube map textures, the internal format of the positive X image of level zero is used. If *`textures`* is `NULL` then it is as if an appropriately sized array containing only zeros had been specified.\n\n`glBindImageTextures` is equivalent to the following pseudo code:\n\n``` programlisting\n    for (i = 0; i < count; i++) {\n        if (textures == NULL || textures[i] = 0) {\n            glBindImageTexture(first + i, 0, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R8);\n        } else {\n            glBindImageTexture(first + i, textures[i], 0, GL_TRUE, 0, GL_READ_WRITE, lookupInternalFormat(textures[i]));\n        }\n    }\n```\n\nEach entry in *`textures`* will be checked individually and if found to be invalid, the state for that image unit will not be changed and an error will be generated. However, the state for other texture image units referenced by the command will still be updated.\n\n## Notes\n\n`glBindImageTextures` is available only if the GL version is 4.4 or higher.\n\nNote that because `glBindImageTextures` cannot create new textures (even if a name passed has been previously generated by call to [glGenTextures](glgentextures.xhtml)), names passed to `glBindImageTextures` must have been bound at least once previously via a call to [glBindTexture](glbindtexture.xhtml).\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`first`* + *`count`* is greater than the number of image units supported by the implementation.\n\n`GL_INVALID_OPERATION` is generated if any value in *`textures`* is not zero or the name of an existing texture object.\n\n`GL_INVALID_OPERATION` error is generated if the internal format of the level zero texture image of any texture in textures is not supported.\n\n`GL_INVALID_OPERATION` error is generated if the width, height, or depth of the level zero texture image of any texture in textures is zero.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_BINDING_2D`, `GL_TEXTURE_BINDING_3D`, `GL_TEXTURE_BINDING_1D_ARRAY`, `GL_TEXTURE_BINDING_2D_ARRAY`, `GL_TEXTURE_BINDING_RECTANGLE`, `GL_TEXTURE_BINDING_BUFFER`, `GL_TEXTURE_BINDING_CUBE_MAP`, `GL_TEXTURE_BINDING_CUBE_MAP`, `GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`, `GL_TEXTURE_BINDING_2D_MULTISAMPLE`, or `GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindImageTextures`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindTexture](glbindtexture.xhtml), [glBindTextures](glbindtextures.xhtml), [glDeleteTextures](gldeletetextures.xhtml), [glGenTextures](glgentextures.xhtml), [glGet](glget.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glIsTexture](glistexture.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml), [glTexStorage2DMultisample](gltexstorage2dmultisample.xhtml), [glTexStorage3D](gltexstorage3d.xhtml), [glTexStorage3DMultisample](gltexstorage3dmultisample.xhtml), [glTexBuffer](gltexbuffer.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindImageTextures.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindImageTextures.xhtml)"
- name: glBindProgramPipeline
  id: glbindprogrampipeline.xhtml
  summary: pipeline Specifies the name of the pipeline object to bind to the context
  description: "## Name\n\nglBindProgramPipeline — bind a program pipeline to the current context\n\n## C Specification\n\n`void `**`glBindProgramPipeline`**`(` GLuint `pipeline``)`;\n\n## Parameters\n\n *`pipeline`*  \nSpecifies the name of the pipeline object to bind to the context.\n\n## Description\n\n`glBindProgramPipeline` binds a program pipeline object to the current context. *`pipeline`* must be a name previously returned from a call to [glGenProgramPipelines](glgenprogrampipelines.xhtml). If no program pipeline exists with name *`pipeline`* then a new pipeline object is created with that name and initialized to the default state vector.\n\nWhen a program pipeline object is bound using `glBindProgramPipeline`, any previous binding is broken and is replaced with a binding to the specified pipeline object. If *`pipeline`* is zero, the previous binding is broken and is not replaced, leaving no pipeline object bound. If no current program object has been established by [glUseProgram](gluseprogram.xhtml), the program objects used for each stage and for uniform updates are taken from the bound program pipeline object, if any. If there is a current program object established by [glUseProgram](gluseprogram.xhtml), the bound program pipeline object has no effect on rendering or uniform updates. When a bound program pipeline object is used for rendering, individual shader executables are taken from its program objects.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`pipeline`* is not zero or a name previously returned from a call to [glGenProgramPipelines](glgenprogrampipelines.xhtml) or if such a name has been deleted by a call to [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml).\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindProgramPipeline`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateShader](glcreateshader.xhtml), [glCreateProgram](glcreateprogram.xhtml), [glCompileShader](glcompileshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glGenProgramPipelines](glgenprogrampipelines.xhtml), [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml), [glIsProgramPipeline](glisprogrampipeline.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindProgramPipeline.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindProgramPipeline.xhtml)"
- name: glBindRenderbuffer
  id: glbindrenderbuffer.xhtml
  summary: target Specifies the renderbuffer target of the binding operation
  description: "## Name\n\nglBindRenderbuffer — bind a renderbuffer to a renderbuffer target\n\n## C Specification\n\n`void `**`glBindRenderbuffer`**`(` GLenum `target`, GLuint `renderbuffer``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the renderbuffer target of the binding operation. *`target`* must be `GL_RENDERBUFFER`.\n\n *`renderbuffer`*  \nSpecifies the name of the renderbuffer object to bind.\n\n## Description\n\n`glBindRenderbuffer` binds the renderbuffer object with name *`renderbuffer`* to the renderbuffer target specified by *`target`*. *`target`* must be `GL_RENDERBUFFER`. *`renderbuffer`* is the name of a renderbuffer object previously returned from a call to [glGenRenderbuffers](glgenrenderbuffers.xhtml), or zero to break the existing binding of a renderbuffer object to *`target`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_RENDERBUFFER`.\n\n`GL_INVALID_OPERATION` is generated if *`renderbuffer`* is not zero or the name of a renderbuffer previously returned from a call to [glGenRenderbuffers](glgenrenderbuffers.xhtml).\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindRenderbuffer`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDeleteRenderbuffers](gldeleterenderbuffers.xhtml), [glGenRenderbuffers](glgenrenderbuffers.xhtml), [glIsRenderbuffer](glisrenderbuffer.xhtml), [glRenderbufferStorage](glrenderbufferstorage.xhtml), [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindRenderbuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindRenderbuffer.xhtml)"
- name: glBindSampler
  id: glbindsampler.xhtml
  summary: unit Specifies the index of the texture unit to which the sampler is bound
  description: "## Name\n\nglBindSampler — bind a named sampler to a texturing target\n\n## C Specification\n\n`void `**`glBindSampler`**`(` GLuint `unit`, GLuint `sampler``)`;\n\n## Parameters\n\n *`unit`*  \nSpecifies the index of the texture unit to which the sampler is bound.\n\n *`sampler`*  \nSpecifies the name of a sampler.\n\n## Description\n\n`glBindSampler` binds *`sampler`* to the texture unit at index *`unit`*. *`sampler`* must be zero or the name of a sampler object previously returned from a call to [glGenSamplers](glgensamplers.xhtml). *`unit`* must be less than the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`.\n\nWhen a sampler object is bound to a texture unit, its state supersedes that of the texture object bound to that texture unit. If the sampler name zero is bound to a texture unit, the currently bound texture's sampler state becomes active. A single sampler object may be bound to multiple texture units simultaneously.\n\n## Notes\n\n`glBindSampler` is available only if the GL version is 3.3 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`unit`* is greater than or equal to the value of `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`.\n\n`GL_INVALID_OPERATION` is generated if *`sampler`* is not zero or a name previously returned from a call to [glGenSamplers](glgensamplers.xhtml), or if such a name has been deleted by a call to [glDeleteSamplers](gldeletesamplers.xhtml).\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_SAMPLER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindSampler`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenSamplers](glgensamplers.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml), [glGet](glget.xhtml), [glSamplerParameter](glsamplerparameter.xhtml), [glGetSamplerParameter](glgetsamplerparameter.xhtml), [glGenTextures](glgentextures.xhtml), [glBindTexture](glbindtexture.xhtml), [glDeleteTextures](gldeletetextures.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindSampler.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindSampler.xhtml)"
- name: glBindSamplers
  id: glbindsamplers.xhtml
  summary: first Specifies the first sampler unit to which a sampler object is to be bound
  description: "## Name\n\nglBindSamplers — bind one or more named sampler objects to a sequence of consecutive sampler units\n\n## C Specification\n\n`void `**`glBindSamplers`**`(` GLuint `first`, GLsizei `count`, const GLuint \\*`samplers``)`;\n\n## Parameters\n\n *`first`*  \nSpecifies the first sampler unit to which a sampler object is to be bound.\n\n *`count`*  \nSpecifies the number of samplers to bind.\n\n *`samplers`*  \nSpecifies the address of an array of names of existing sampler objects.\n\n## Description\n\n`glBindSamplers` binds samplers from an array of existing sampler objects to a specified number of consecutive sampler units. *`count`* specifies the number of sampler objects whose names are stored in the array *`samplers`*. That number of sampler names is read from the array and bound to the *`count`* consecutive sampler units starting from *`first`*.\n\nIf the name zero appears in the *`samplers`* array, any existing binding to the sampler unit is reset. Any non-zero entry in *`samplers`* must be the name of an existing sampler object. When a non-zero entry in *`samplers`* is present, that sampler object is bound to the corresponding sampler unit. If *`samplers`* is `NULL` then it is as if an appropriately sized array containing only zeros had been specified.\n\n`glBindSamplers` is equivalent to the following pseudo code:\n\n``` programlisting\n    for (i = 0; i < count; i++) {\n        if (samplers == NULL) {\n            glBindSampler(first + i, 0);\n        } else {\n            glBindSampler(first + i, samplers[i]);\n        }\n    }\n```\n\nEach entry in *`samplers`* will be checked individually and if found to be invalid, the state for that sampler unit will not be changed and an error will be generated. However, the state for other sampler units referenced by the command will still be updated.\n\n## Notes\n\n`glBindSamplers` is available only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`first`* + *`count`* is greater than the number of sampler units supported by the implementation.\n\n`GL_INVALID_OPERATION` is generated if any value in *`samplers`* is not zero or the name of an existing sampler object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_SAMPLER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindSamplers`            |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenSamplers](glgensamplers.xhtml), [glBindSampler](glbindsampler.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml), [glGet](glget.xhtml), [glSamplerParameter](glsamplerparameter.xhtml), [glGetSamplerParameter](glgetsamplerparameter.xhtml), [glGenTextures](glgentextures.xhtml), [glBindTexture](glbindtexture.xhtml), [glDeleteTextures](gldeletetextures.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindSamplers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindSamplers.xhtml)"
- name: glBindTexture
  id: glbindtexture.xhtml
  summary: target Specifies the target to which the texture is bound
  description: "## Name\n\nglBindTexture — bind a named texture to a texturing target\n\n## C Specification\n\n`void `**`glBindTexture`**`(` GLenum `target`, GLuint `texture``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound. Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n *`texture`*  \nSpecifies the name of a texture.\n\n## Description\n\n`glBindTexture` lets you create or use a named texture. Calling `glBindTexture` with *`target`* set to `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` and *`texture`* set to the name of the new texture binds the texture name to the target. When a texture is bound to a target, the previous binding for that target is automatically broken.\n\nTexture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.\n\nYou must use [glGenTextures](glgentextures.xhtml) to generate a set of new texture names.\n\nWhen a texture is first bound, it assumes the specified target: A texture first bound to `GL_TEXTURE_1D` becomes one-dimensional texture, a texture first bound to `GL_TEXTURE_2D` becomes two-dimensional texture, a texture first bound to `GL_TEXTURE_3D` becomes three-dimensional texture, a texture first bound to `GL_TEXTURE_1D_ARRAY` becomes one-dimensional array texture, a texture first bound to `GL_TEXTURE_2D_ARRAY` becomes two-dimensional array texture, a texture first bound to `GL_TEXTURE_RECTANGLE` becomes rectangle texture, a texture first bound to `GL_TEXTURE_CUBE_MAP` becomes a cube-mapped texture, a texture first bound to `GL_TEXTURE_CUBE_MAP_ARRAY` becomes a cube-mapped array texture, a texture first bound to `GL_TEXTURE_BUFFER` becomes a buffer texture, a texture first bound to `GL_TEXTURE_2D_MULTISAMPLE` becomes a two-dimensional multisampled texture, and a texture first bound to `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` becomes a two-dimensional multisampled array texture. The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the default `GL_TEXTURE_1D` at GL initialization, and similarly for the other texture types.\n\nWhile a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.\n\nA texture binding created with `glBindTexture` remains active until a different texture is bound to the same target, or until the bound texture is deleted with [glDeleteTextures](gldeletetextures.xhtml).\n\nOnce created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use `glBindTexture` to bind an existing named texture to one of the texture targets than it is to reload the texture image using [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml) or another similar function.\n\n## Notes\n\nThe `GL_TEXTURE_2D_MULTISAMPLE` and `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` targets are available only if the GL version is 3.2 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of the allowable values.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not a name returned from a previous call to [glGenTextures](glgentextures.xhtml).\n\n`GL_INVALID_OPERATION` is generated if *`texture`* was previously created with a target that doesn't match that of *`target`*.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_BINDING_2D`, `GL_TEXTURE_BINDING_3D`, `GL_TEXTURE_BINDING_1D_ARRAY`, `GL_TEXTURE_BINDING_2D_ARRAY`, `GL_TEXTURE_BINDING_RECTANGLE`, `GL_TEXTURE_BINDING_BUFFER`, `GL_TEXTURE_BINDING_CUBE_MAP`, `GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`, `GL_TEXTURE_BINDING_2D_MULTISAMPLE`, or `GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindTexture`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDeleteTextures](gldeletetextures.xhtml), [glGenTextures](glgentextures.xhtml), [glGet](glget.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glIsTexture](glistexture.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage2DMultisample](glteximage2dmultisample.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexImage3DMultisample](glteximage3dmultisample.xhtml), [glTexBuffer](gltexbuffer.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindTexture.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindTexture.xhtml)"
- name: glBindTextures
  id: glbindtextures.xhtml
  summary: first Specifies the first texture unit to which a texture is to be bound
  description: "## Name\n\nglBindTextures — bind one or more named textures to a sequence of consecutive texture units\n\n## C Specification\n\n`void `**`glBindTextures`**`(` GLuint `first`, GLsizei `count`, const GLuint \\*`textures``)`;\n\n## Parameters\n\n *`first`*  \nSpecifies the first texture unit to which a texture is to be bound.\n\n *`count`*  \nSpecifies the number of textures to bind.\n\n *`textures`*  \nSpecifies the address of an array of names of existing texture objects.\n\n## Description\n\n`glBindTextures` binds an array of existing texture objects to a specified number of consecutive texture units. *`count`* specifies the number of texture objects whose names are stored in the array *`textures`*. That number of texture names are read from the array and bound to the *`count`* consecutive texture units starting from *`first`*. The target, or type of texture is deduced from the texture object and each texture is bound to the corresponding target of the texture unit. If the name zero appears in the *`textures`* array, any existing binding to any target of the texture unit is reset and the default texture for that target is bound in its place. Any non-zero entry in *`textures`* must be the name of an existing texture object. If *`textures`* is `NULL` then it is as if an appropriately sized array containing only zeros had been specified.\n\nWith the exception that the active texture selector maintains its current value, `glBindTextures` is equivalent to the following pseudo code:\n\n``` programlisting\n    for (i = 0; i < count; i++) {\n        GLuint texture;\n        if (textures == NULL) {\n            texture = 0;\n        } else {\n            texture = textures[i];\n        }\n        glActiveTexture(GL_TEXTURE0 + first + i);\n        if (texture != 0) {\n            GLenum target = /* target of textures[i] */;\n            glBindTexture(target, textures[i]);\n        } else {\n            for (target in all supported targets) {\n                glBindTexture(target, 0);\n            }\n        }\n    }\n```\n\nEach entry in *`textures`* will be checked individually and if found to be invalid, the state for that texture unit will not be changed and an error will be generated. However, the state for other texture units referenced by the command will still be updated.\n\n## Notes\n\n`glBindTextures` is available only if the GL version is 4.4 or higher.\n\nNote that because `glBindTextures` cannot create new textures (even if a name passed has been previously generated by call to [glGenTextures](glgentextures.xhtml)), names passed to `glBindTextures` must have been bound at least once previously via a call to [glBindTexture](glbindtexture.xhtml).\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`first`* + *`count`* is greater than the number of texture image units supported by the implementation.\n\n`GL_INVALID_OPERATION` is generated if any value in textures is not zero or the name of an existing texture object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_BINDING_2D`, `GL_TEXTURE_BINDING_3D`, `GL_TEXTURE_BINDING_1D_ARRAY`, `GL_TEXTURE_BINDING_2D_ARRAY`, `GL_TEXTURE_BINDING_RECTANGLE`, `GL_TEXTURE_BINDING_BUFFER`, `GL_TEXTURE_BINDING_CUBE_MAP`, `GL_TEXTURE_BINDING_CUBE_MAP`, `GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`, `GL_TEXTURE_BINDING_2D_MULTISAMPLE`, or `GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindTextures`            |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindTexture](glbindtexture.xhtml), [glDeleteTextures](gldeletetextures.xhtml), [glGenTextures](glgentextures.xhtml), [glGet](glget.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glIsTexture](glistexture.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage2DMultisample](glteximage2dmultisample.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexImage3DMultisample](glteximage3dmultisample.xhtml), [glTexBuffer](gltexbuffer.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindTextures.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindTextures.xhtml)"
- name: glBindTextureUnit
  id: glbindtextureunit.xhtml
  summary: unit Specifies the texture unit, to which the texture object should be bound to
  description: "## Name\n\nglBindTextureUnit — bind an existing texture object to the specified texture unit\n\n## C Specification\n\n`void `**`glBindTextureUnit`**`(` GLuint `unit`, GLuint `texture``)`;\n\n## Parameters\n\n *`unit`*  \nSpecifies the texture unit, to which the texture object should be bound to.\n\n *`texture`*  \nSpecifies the name of a texture.\n\n## Description\n\n`glBindTextureUnit` binds an existing texture object to the texture unit numbered *`unit`*.\n\n*`texture`* must be zero or the name of an existing texture object. When *`texture`* is the name of an existing texture object, that object is bound to the target, in the corresponding texture unit, that was specified when the object was created. When *`texture`* is zero, each of the targets enumerated at the beginning of this section is reset to its default texture for the corresponding texture image unit.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_BINDING_2D`, `GL_TEXTURE_BINDING_3D`, `GL_TEXTURE_BINDING_1D_ARRAY`, `GL_TEXTURE_BINDING_2D_ARRAY`, `GL_TEXTURE_BINDING_RECTANGLE`, `GL_TEXTURE_BINDING_BUFFER`, `GL_TEXTURE_BINDING_CUBE_MAP`, `GL_TEXTURE_BINDING_CUBE_MAP_ARRAY`, `GL_TEXTURE_BINDING_2D_MULTISAMPLE` or `GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated if *`texture`* is not zero or the name of an existing texture object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindTextureUnit`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glDeleteTextures](gldeletetextures.xhtml), [glGenTextures](glgentextures.xhtml), [glGet](glget.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glIsTexture](glistexture.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage2DMultisample](glteximage2dmultisample.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexImage3DMultisample](glteximage3dmultisample.xhtml), [glTexBuffer](gltexbuffer.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindTextureUnit.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindTextureUnit.xhtml)"
- name: glBindTransformFeedback
  id: glbindtransformfeedback.xhtml
  summary: target Specifies the target to which to bind the transform feedback object id
  description: "## Name\n\nglBindTransformFeedback — bind a transform feedback object\n\n## C Specification\n\n`void `**`glBindTransformFeedback`**`(` GLenum `target`, GLuint `id``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which to bind the transform feedback object *`id`*. *`target`* must be `GL_TRANSFORM_FEEDBACK`.\n\n *`id`*  \nSpecifies the name of a transform feedback object reserved by [glGenTransformFeedbacks](glgentransformfeedbacks.xhtml).\n\n## Description\n\n`glBindTransformFeedback` binds the transform feedback object with name *`id`* to the current GL state. *`id`* must be a name previously returned from a call to [glGenTransformFeedbacks](glgentransformfeedbacks.xhtml). If *`id`* has not previously been bound, a new transform feedback object with name *`id`* and initialized with the default transform state vector is created.\n\nIn the initial state, a default transform feedback object is bound and treated as a transform feedback object with a name of zero. If the name zero is subsequently bound, the default transform feedback object is again bound to the GL state.\n\nWhile a transform feedback buffer object is bound, GL operations on the target to which it is bound affect the bound transform feedback object, and queries of the target to which a transform feedback object is bound return state from the bound object. When buffer objects are bound for transform feedback, they are attached to the currently bound transform feedback object. Buffer objects are used for trans- form feedback only if they are attached to the currently bound transform feedback object.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_TRANSFORM_FEEDBACK`.\n\n`GL_INVALID_OPERATION` is generated if the transform feedback operation is active on the currently bound transform feedback object, and that operation is not paused.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is not zero or the name of a transform feedback object returned from a previous call to [glGenTransformFeedbacks](glgentransformfeedbacks.xhtml), or if such a name has been deleted by [glDeleteTransformFeedbacks](gldeletetransformfeedbacks.xhtml).\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_TRANSFORM_FEEDBACK_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindTransformFeedback`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenTransformFeedbacks](glgentransformfeedbacks.xhtml), [glDeleteTransformFeedbacks](gldeletetransformfeedbacks.xhtml), [glIsTransformFeedback](glistransformfeedback.xhtml), [glBeginTransformFeedback](glbegintransformfeedback.xhtml), [glPauseTransformFeedback](glpausetransformfeedback.xhtml), [glResumeTransformFeedback](glresumetransformfeedback.xhtml), `glEndTransformFeedback`\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindTransformFeedback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindTransformFeedback.xhtml)"
- name: glBindVertexArray
  id: glbindvertexarray.xhtml
  summary: array Specifies the name of the vertex array to bind
  description: "## Name\n\nglBindVertexArray — bind a vertex array object\n\n## C Specification\n\n`void `**`glBindVertexArray`**`(` GLuint `array``)`;\n\n## Parameters\n\n *`array`*  \nSpecifies the name of the vertex array to bind.\n\n## Description\n\n`glBindVertexArray` binds the vertex array object with name *`array`*. *`array`* is the name of a vertex array object previously returned from a call to [glGenVertexArrays](glgenvertexarrays.xhtml), or zero to break the existing vertex array object binding.\n\nIf no vertex array object with name *`array`* exists, one is created when *`array`* is first bound. If the bind is successful no change is made to the state of the vertex array object, and any previous vertex array object binding is broken.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`array`* is not zero or the name of a vertex array object previously returned from a call to [glGenVertexArrays](glgenvertexarrays.xhtml).\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindVertexArray`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDeleteVertexArrays](gldeletevertexarrays.xhtml), [glEnableVertexAttribArray](glenablevertexattribarray.xhtml), [glGenVertexArrays](glgenvertexarrays.xhtml), [glIsVertexArray](glisvertexarray.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexArray.xhtml)"
- name: glBindVertexBuffer
  id: glbindvertexbuffer.xhtml
  summary: vaobj Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function
  description: "## Name\n\nglBindVertexBuffer, glVertexArrayVertexBuffer — bind a buffer to a vertex buffer bind point\n\n## C Specification\n\n`void `**`glBindVertexBuffer`**`(` GLuint `bindingindex`, GLuint `buffer`, GLintptr `offset`, GLsizei `stride``)`;\n\n`void `**`glVertexArrayVertexBuffer`**`(` GLuint `vaobj`, GLuint `bindingindex`, GLuint `buffer`, GLintptr `offset`, GLsizei `stride``)`;\n\n## Parameters\n\n *`vaobj`*  \nSpecifies the name of the vertex array object to be used by `glVertexArrayVertexBuffer` function.\n\n *`bindingindex`*  \nThe index of the vertex buffer binding point to which to bind the buffer.\n\n *`buffer`*  \nThe name of a buffer to bind to the vertex buffer binding point.\n\n *`offset`*  \nThe offset of the first element of the buffer.\n\n *`stride`*  \nThe distance between elements within the buffer.\n\n## Description\n\n`glBindVertexBuffer` and `glVertexArrayVertexBuffer` bind the buffer named *`buffer`* to the vertex buffer binding point whose index is given by *`bindingindex`*. `glBindVertexBuffer` modifies the binding of the currently bound vertex array object, whereas `glVertexArrayVertexBuffer` allows the caller to specify ID of the vertex array object with an argument named *`vaobj`*, for which the binding should be modified. *`offset`* and *`stride`* specify the offset of the first element within the buffer and the distance between elements within the buffer, respectively, and are both measured in basic machine units. *`bindingindex`* must be less than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`. *`offset`* and *`stride`* must be greater than or equal to zero. If *`buffer`* is zero, then any buffer currently bound to the specified binding point is unbound.\n\nIf *`buffer`* is not the name of an existing buffer object, the GL first creates a new state vector, initialized with a zero-sized memory buffer and comprising all the state and with the same initial values as in case of `glBindBuffer`. *`buffer`* is then attached to the specified *`bindingindex`* of the vertex array object.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glBindVertexBuffer` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayVertexBuffer` if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_VALUE` is generated if *`bindingindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`stride`* is less than zero, or if stride is greater than the value of `GL_MAX_VERTEX_ATTRIB_STRIDE`.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is not zero or the name of an existing buffer object (as returned by `glGenBuffers` or `glCreateBuffers`).\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindVertexBuffer`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glVertexArrayVertexBuffer` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glVertexAttribBinding](glvertexattribbinding.xhtml), [glVertexAttribFormat](glvertexattribformat.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml), [glVertexBindingDivisor](glvertexbindingdivisor.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexBuffer.xhtml)"
- name: glBindVertexBuffers
  id: glbindvertexbuffers.xhtml
  summary: vaobj Specifies the name of the vertex array object for glVertexArrayVertexBuffers
  description: "## Name\n\nglBindVertexBuffers, glVertexArrayVertexBuffers — attach multiple buffer objects to a vertex array object\n\n## C Specification\n\n`void `**`glBindVertexBuffers`**`(` GLuint `first`, GLsizei `count`, const GLuint \\*`buffers`, const GLintptr \\*`offsets`, const GLsizei \\*`strides``)`;\n\n`void `**`glVertexArrayVertexBuffers`**`(` GLuint `vaobj`, GLuint `first`, GLsizei `count`, const GLuint \\*`buffers`, const GLintptr \\*`offsets`, const GLsizei \\*`strides``)`;\n\n## Parameters\n\n *`vaobj`*  \nSpecifies the name of the vertex array object for `glVertexArrayVertexBuffers`.\n\n *`first`*  \nSpecifies the first vertex buffer binding point to which a buffer object is to be bound.\n\n *`count`*  \nSpecifies the number of buffers to bind.\n\n *`buffers`*  \nSpecifies the address of an array of names of existing buffer objects.\n\n *`offsets`*  \nSpecifies the address of an array of offsets to associate with the binding points.\n\n *`strides`*  \nSpecifies the address of an array of strides to associate with the binding points.\n\n## Description\n\n`glBindVertexBuffers` and `glVertexArrayVertexBuffers` bind storage from an array of existing buffer objects to a specified number of consecutive vertex buffer binding points units in a vertex array object. For `glBindVertexBuffers`, the vertex array object is the currently bound vertex array object. For `glVertexArrayVertexBuffers`, *`vaobj`* is the name of the vertex array object.\n\n*`count`* existing buffer objects are bound to vertex buffer binding points numbered $first$ through $first + count - 1$. If *`buffers`* is not NULL, it specifies an array of *`count`* values, each of which must be zero or the name of an existing buffer object. *`offsets`* and *`strides`* specify arrays of *`count`* values indicating the offset of the first element and stride between elements in each buffer, respectively. If *`buffers`* is NULL, each affected vertex buffer binding point from $first$ through $first + count - 1$ will be reset to have no bound buffer object. In this case, the offsets and strides associated with the binding points are set to default values, ignoring *`offsets`* and *`strides`*.\n\n`glBindVertexBuffers` is equivalent (assuming no errors are generated) to:\n\n``` programlisting\n    for (i = 0; i < count; i++) {\n        if (buffers == NULL) {\n            glBindVertexBuffer(first + i, 0, 0, 16);\n        } else {\n            glBindVertexBuffer(first + i, buffers[i], offsets[i], strides[i]);\n        }\n    }\n```\n\nexcept that buffers will not be created if they do not exist.\n\n`glVertexArrayVertexBuffers` is equivalent to the pseudocode above, but replacing `glBindVertexBuffers`(args) with `glVertexArrayVertexBuffers`(vaobj, args).\n\nThe values specified in *`buffers`*, *`offsets`*, and *`strides`* will be checked separately for each vertex buffer binding point. When a value for a specific vertex buffer binding point is invalid, the state for that binding point will be unchanged and an error will be generated. However, state for other vertex buffer binding points will still be changed if their corresponding values are valid.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glBindVertexBuffers` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayVertexBuffers` if *`vaobj`* is not the name of the vertex array object.\n\n`GL_INVALID_OPERATION` is generated if $first + count$ is greater than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n`GL_INVALID_OPERATION` is generated if any value in `buffers` is not zero or the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if any value in *`offsets`* or *`strides`* is negative, or if a value is *`stride`* is greater than the value of `GL_MAX_VERTEX_ATTRIB_STRIDE`.\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBindVertexBuffers`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |\n| `glVertexArrayVertexBuffers` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml) [glDeleteTextures](gldeletetextures.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexBuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexBuffers.xhtml)"
- name: glBlendColor
  id: glblendcolor.xhtml
  summary: The GL_BLEND_COLOR may be used to calculate the source and destination blending factors
  description: "## Name\n\nglBlendColor — set the blend color\n\n## C Specification\n\n`void `**`glBlendColor`**`(` GLfloat `red`, GLfloat `green`, GLfloat `blue`, GLfloat `alpha``)`;\n\n## Parameters\n\n*`red`*,  *`green`*,  *`blue`*,   *`alpha`*  \nspecify the components of `GL_BLEND_COLOR`\n\n## Description\n\nThe `GL_BLEND_COLOR` may be used to calculate the source and destination blending factors. The color components are clamped to the range \\[0, 1\\] before being stored. See [glBlendFunc](glblendfunc.xhtml) for a complete description of the blending operations. Initially the `GL_BLEND_COLOR` is set to (0, 0, 0, 0).\n\n## Notes\n\nThe type of the *`red`*, *`green`*, *`blue`*, and *`alpha`* parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with an argument of `GL_BLEND_COLOR`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBlendColor`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBlendEquation](glblendequation.xhtml), [glBlendFunc](glblendfunc.xhtml), [glGetString](glgetstring.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendColor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendColor.xhtml)"
- name: glBlendEquation
  id: glblendequation.xhtml
  summary: buf for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation
  description: "## Name\n\nglBlendEquation — specify the equation used for both the RGB blend equation and the Alpha blend equation\n\n## C Specification\n\n`void `**`glBlendEquation`**`(` GLenum `mode``)`;\n\n`void `**`glBlendEquationi`**`(` GLuint `buf`, GLenum `mode``)`;\n\n## Parameters\n\n *`buf`*  \nfor `glBlendEquationi`, specifies the index of the draw buffer for which to set the blend equation.\n\n *`mode`*  \nspecifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.\n\n## Description\n\nThe blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function sets both the RGB blend equation and the alpha blend equation to a single equation. `glBlendEquationi` specifies the blend equation for a single draw buffer whereas `glBlendEquation` sets the blend equation for all draw buffers.\n\nThese equations use the source and destination blend factors specified by either [glBlendFunc](glblendfunc.xhtml) or [glBlendFuncSeparate](glblendfuncseparate.xhtml). See [glBlendFunc](glblendfunc.xhtml) or [glBlendFuncSeparate](glblendfuncseparate.xhtml) for a description of the various blend factors.\n\nIn the equations that follow, source and destination color components are referred to as (*R*_(*s*), *G*_(*s*), *B*_(*s*), *A*_(*s*)) and (*R*_(*d*), *G*_(*d*), *B*_(*d*), *A*_(*d*)), respectively. The result color is referred to as (*R*_(*r*), *G*_(*r*), *B*_(*r*), *A*_(*r*)). The source and destination blend factors are denoted (*s*_(*R*), *s*_(*G*), *s*_(*B*), *s*_(*A*)) and (*d*_(*R*), *d*_(*G*), *d*_(*B*), *d*_(*A*)), respectively. For these equations all color components are understood to have values in the range \\[0, 1\\].\n\n|  **Mode**                  |  **RGB Components**                                                                                                                                |  **Alpha Component**                             |\n|:---------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------|\n| `GL_FUNC_ADD`              | *R**r* = *R*_(*s*)*s*_(*R*) + *R*_(*d*)*d*_(*R*) *G**r* = *G*_(*s*)*s*_(*G*) + *G*_(*d*)*d*_(*G*) *B**r* = *B*_(*s*)*s*_(*B*) + *B*_(*d*)*d*_(*B*) | *A**r* = *A*_(*s*)*s*_(*A*) + *A*_(*d*)*d*_(*A*) |\n| `GL_FUNC_SUBTRACT`         | *R**r* = *R*_(*s*)*s*_(*R*) − *R*_(*d*)*d*_(*R*) *G**r* = *G*_(*s*)*s*_(*G*) − *G*_(*d*)*d*_(*G*) *B**r* = *B*_(*s*)*s*_(*B*) − *B*_(*d*)*d*_(*B*) | *A**r* = *A*_(*s*)*s*_(*A*) − *A*_(*d*)*d*_(*A*) |\n| `GL_FUNC_REVERSE_SUBTRACT` | *R**r* = *R*_(*d*)*d*_(*R*) − *R*_(*s*)*s*_(*R*) *G**r* = *G*_(*d*)*d*_(*G*) − *G*_(*s*)*s*_(*G*) *B**r* = *B*_(*d*)*d*_(*B*) − *B*_(*s*)*s*_(*B*) | *A**r* = *A*_(*d*)*d*_(*A*) − *A*_(*s*)*s*_(*A*) |\n| `GL_MIN`                   | *R**r* = *min* (*R*_(*s*), *R*_(*d*)) *G**r* = *min* (*G*_(*s*), *G*_(*d*)) *B**r* = *min* (*B*_(*s*), *B*_(*d*))                                  | *A**r* = *min* (*A*_(*s*), *A*_(*d*))            |\n| `GL_MAX`                   | *R**r* = *max* (*R*_(*s*), *R*_(*d*)) *G**r* = *max* (*G*_(*s*), *G*_(*d*)) *B**r* = *max* (*B*_(*s*), *B*_(*d*))                                  | *A**r* = *max* (*A*_(*s*), *A*_(*d*))            |\n\nThe results of these equations are clamped to the range \\[0, 1\\].\n\nThe `GL_MIN` and `GL_MAX` equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The `GL_FUNC_ADD` equation is useful for antialiasing and transparency, among other things.\n\nInitially, both the RGB blend equation and the alpha blend equation are set to `GL_FUNC_ADD`.\n\n## Notes\n\nThe `GL_MIN`, and `GL_MAX` equations do not use the source or destination factors, only the source and destination colors.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MAX`, or `GL_MIN`.\n\n`GL_INVALID_VALUE` is generated by `glBlendEquationi` if *`buf`* is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with an argument of `GL_BLEND_EQUATION_RGB`\n\n[glGet](glget.xhtml) with an argument of `GL_BLEND_EQUATION_ALPHA`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBlendEquation`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glBlendEquationi`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBlendColor](glblendcolor.xhtml), [glBlendFunc](glblendfunc.xhtml) [glBlendFuncSeparate](glblendfuncseparate.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendEquation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendEquation.xhtml)"
- name: glBlendEquationi
  id: glblendequation.xhtml#glBlendEquationi
  summary: for glBlendEquationi, specifies the index of the draw buffer for which to set the blend equation
  belongs_to: glBlendEquation
  description: "`void `**`glBlendEquationi`**`(` GLuint `buf`, GLenum `mode``)`;\n\n## Parameters\n\n*`buf`*\n\nfor `glBlendEquationi`, specifies the index of the draw buffer for which to set the blend equation.\n\n*`mode`*\n\nspecifies how source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.\n\n## Description\n\nThe blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). This function sets both the RGB blend equation and the alpha blend equation to a single equation. `glBlendEquationi` specifies the blend equation for a single draw buffer whereas `glBlendEquation` sets the blend equation for all draw buffers.\n\nThese equations use the source and destination blend factors specified by either [glBlendFunc](glblendfunc.xhtml) or [glBlendFuncSeparate](glblendfuncseparate.xhtml). See [glBlendFunc](glblendfunc.xhtml) or [glBlendFuncSeparate](glblendfuncseparate.xhtml) for a description of the various blend factors.\n\nIn the equations that follow, source and destination color components are referred to as (*R*_(*s*), *G*_(*s*), *B*_(*s*), *A*_(*s*)) and (*R*_(*d*), *G*_(*d*), *B*_(*d*), *A*_(*d*)), respectively. The result color is referred to as (*R*_(*r*), *G*_(*r*), *B*_(*r*), *A*_(*r*)). The source and destination blend factors are denoted (*s*_(*R*), *s*_(*G*), *s*_(*B*), *s*_(*A*)) and (*d*_(*R*), *d*_(*G*), *d*_(*B*), *d*_(*A*)), respectively. For these equations all color components are understood to have values in the range \\[0, 1\\].\n\n|  **Mode**                  |  **RGB Components**                                                                                                                                |  **Alpha Component**                             |\n|:---------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------|\n| `GL_FUNC_ADD`              | *R**r* = *R*_(*s*)*s*_(*R*) + *R*_(*d*)*d*_(*R*) *G**r* = *G*_(*s*)*s*_(*G*) + *G*_(*d*)*d*_(*G*) *B**r* = *B*_(*s*)*s*_(*B*) + *B*_(*d*)*d*_(*B*) | *A**r* = *A*_(*s*)*s*_(*A*) + *A*_(*d*)*d*_(*A*) |\n| `GL_FUNC_SUBTRACT`         | *R**r* = *R*_(*s*)*s*_(*R*) − *R*_(*d*)*d*_(*R*) *G**r* = *G*_(*s*)*s*_(*G*) − *G*_(*d*)*d*_(*G*) *B**r* = *B*_(*s*)*s*_(*B*) − *B*_(*d*)*d*_(*B*) | *A**r* = *A*_(*s*)*s*_(*A*) − *A*_(*d*)*d*_(*A*) |\n| `GL_FUNC_REVERSE_SUBTRACT` | *R**r* = *R*_(*d*)*d*_(*R*) − *R*_(*s*)*s*_(*R*) *G**r* = *G*_(*d*)*d*_(*G*) − *G*_(*s*)*s*_(*G*) *B**r* = *B*_(*d*)*d*_(*B*) − *B*_(*s*)*s*_(*B*) | *A**r* = *A*_(*d*)*d*_(*A*) − *A*_(*s*)*s*_(*A*) |\n| `GL_MIN`                   | *R**r* = *min* (*R*_(*s*), *R*_(*d*)) *G**r* = *min* (*G*_(*s*), *G*_(*d*)) *B**r* = *min* (*B*_(*s*), *B*_(*d*))                                  | *A**r* = *min* (*A*_(*s*), *A*_(*d*))            |\n| `GL_MAX`                   | *R**r* = *max* (*R*_(*s*), *R*_(*d*)) *G**r* = *max* (*G*_(*s*), *G*_(*d*)) *B**r* = *max* (*B*_(*s*), *B*_(*d*))                                  | *A**r* = *max* (*A*_(*s*), *A*_(*d*))            |\n\nThe results of these equations are clamped to the range \\[0, 1\\].\n\nThe `GL_MIN` and `GL_MAX` equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The `GL_FUNC_ADD` equation is useful for antialiasing and transparency, among other things.\n\nInitially, both the RGB blend equation and the alpha blend equation are set to `GL_FUNC_ADD`.\n\n## Notes\n\nThe `GL_MIN`, and `GL_MAX` equations do not use the source or destination factors, only the source and destination colors.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MAX`, or `GL_MIN`.\n\n`GL_INVALID_VALUE` is generated by `glBlendEquationi` if *`buf`* is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with an argument of `GL_BLEND_EQUATION_RGB`\n\n[glGet](glget.xhtml) with an argument of `GL_BLEND_EQUATION_ALPHA`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBlendEquation`             |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glBlendEquationi`            |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBlendColor](glblendcolor.xhtml), [glBlendFunc](glblendfunc.xhtml)[glBlendFuncSeparate](glblendfuncseparate.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendEquation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendEquation.xhtml)"
- name: glBlendEquationSeparate
  id: glblendequationseparate.xhtml
  summary: buf for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations
  description: "## Name\n\nglBlendEquationSeparate — set the RGB blend equation and the alpha blend equation separately\n\n## C Specification\n\n`void `**`glBlendEquationSeparate`**`(` GLenum `modeRGB`, GLenum `modeAlpha``)`;\n\n`void `**`glBlendEquationSeparatei`**`(` GLuint `buf`, GLenum `modeRGB`, GLenum `modeAlpha``)`;\n\n## Parameters\n\n *`buf`*  \nfor `glBlendEquationSeparatei`, specifies the index of the draw buffer for which to set the blend equations.\n\n *`modeRGB`*  \nspecifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.\n\n *`modeAlpha`*  \nspecifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.\n\n## Description\n\nThe blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). These functions specify one blend equation for the RGB-color components and one blend equation for the alpha component. `glBlendEquationSeparatei` specifies the blend equations for a single draw buffer whereas `glBlendEquationSeparate` sets the blend equations for all draw buffers.\n\nThe blend equations use the source and destination blend factors specified by either [glBlendFunc](glblendfunc.xhtml) or [glBlendFuncSeparate](glblendfuncseparate.xhtml). See [glBlendFunc](glblendfunc.xhtml) or [glBlendFuncSeparate](glblendfuncseparate.xhtml) for a description of the various blend factors.\n\nIn the equations that follow, source and destination color components are referred to as (*R*_(*s*), *G*_(*s*), *B*_(*s*), *A*_(*s*)) and (*R*_(*d*), *G*_(*d*), *B*_(*d*), *A*_(*d*)), respectively. The result color is referred to as (*R*_(*r*), *G*_(*r*), *B*_(*r*), *A*_(*r*)). The source and destination blend factors are denoted (*s*_(*R*), *s*_(*G*), *s*_(*B*), *s*_(*A*)) and (*d*_(*R*), *d*_(*G*), *d*_(*B*), *d*_(*A*)), respectively. For these equations all color components are understood to have values in the range \\[0, 1\\].\n\n|  **Mode**                  |  **RGB Components**                                                                                                                                |  **Alpha Component**                             |\n|:---------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------|\n| `GL_FUNC_ADD`              | *R**r* = *R*_(*s*)*s*_(*R*) + *R*_(*d*)*d*_(*R*) *G**r* = *G*_(*s*)*s*_(*G*) + *G*_(*d*)*d*_(*G*) *B**r* = *B*_(*s*)*s*_(*B*) + *B*_(*d*)*d*_(*B*) | *A**r* = *A*_(*s*)*s*_(*A*) + *A*_(*d*)*d*_(*A*) |\n| `GL_FUNC_SUBTRACT`         | *R**r* = *R*_(*s*)*s*_(*R*) − *R*_(*d*)*d*_(*R*) *G**r* = *G*_(*s*)*s*_(*G*) − *G*_(*d*)*d*_(*G*) *B**r* = *B*_(*s*)*s*_(*B*) − *B*_(*d*)*d*_(*B*) | *A**r* = *A*_(*s*)*s*_(*A*) − *A*_(*d*)*d*_(*A*) |\n| `GL_FUNC_REVERSE_SUBTRACT` | *R**r* = *R*_(*d*)*d*_(*R*) − *R*_(*s*)*s*_(*R*) *G**r* = *G*_(*d*)*d*_(*G*) − *G*_(*s*)*s*_(*G*) *B**r* = *B*_(*d*)*d*_(*B*) − *B*_(*s*)*s*_(*B*) | *A**r* = *A*_(*d*)*d*_(*A*) − *A*_(*s*)*s*_(*A*) |\n| `GL_MIN`                   | *R**r* = *min* (*R*_(*s*), *R*_(*d*)) *G**r* = *min* (*G*_(*s*), *G*_(*d*)) *B**r* = *min* (*B*_(*s*), *B*_(*d*))                                  | *A**r* = *min* (*A*_(*s*), *A*_(*d*))            |\n| `GL_MAX`                   | *R**r* = *max* (*R*_(*s*), *R*_(*d*)) *G**r* = *max* (*G*_(*s*), *G*_(*d*)) *B**r* = *max* (*B*_(*s*), *B*_(*d*))                                  | *A**r* = *max* (*A*_(*s*), *A*_(*d*))            |\n\nThe results of these equations are clamped to the range \\[0, 1\\].\n\nThe `GL_MIN` and `GL_MAX` equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The `GL_FUNC_ADD` equation is useful for antialiasing and transparency, among other things.\n\nInitially, both the RGB blend equation and the alpha blend equation are set to `GL_FUNC_ADD`.\n\n## Notes\n\nThe `GL_MIN`, and `GL_MAX` equations do not use the source or destination factors, only the source and destination colors.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if either *`modeRGB`* or *`modeAlpha`* is not one of `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MAX`, or `GL_MIN`.\n\n`GL_INVALID_VALUE` is generated by `glBlendEquationSeparatei` if *`buf`* is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with an argument of `GL_BLEND_EQUATION_RGB`\n\n[glGet](glget.xhtml) with an argument of `GL_BLEND_EQUATION_ALPHA`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBlendEquationSeparate`   |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glBlendEquationSeparatei`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetString](glgetstring.xhtml), [glBlendColor](glblendcolor.xhtml), [glBlendFunc](glblendfunc.xhtml), [glBlendFuncSeparate](glblendfuncseparate.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendEquationSeparate.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendEquationSeparate.xhtml)"
- name: glBlendEquationSeparatei
  id: glblendequationseparate.xhtml#glBlendEquationSeparatei
  summary: for glBlendEquationSeparatei, specifies the index of the draw buffer for which to set the blend equations
  belongs_to: glBlendEquationSeparate
  description: "`void `**`glBlendEquationSeparatei`**`(` GLuint `buf`, GLenum `modeRGB`, GLenum `modeAlpha``)`;\n\n## Parameters\n\n*`buf`*\n\nfor `glBlendEquationSeparatei`, specifies the index of the draw buffer for which to set the blend equations.\n\n*`modeRGB`*\n\nspecifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.\n\n*`modeAlpha`*\n\nspecifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN`, `GL_MAX`.\n\n## Description\n\nThe blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color). These functions specify one blend equation for the RGB-color components and one blend equation for the alpha component. `glBlendEquationSeparatei` specifies the blend equations for a single draw buffer whereas `glBlendEquationSeparate` sets the blend equations for all draw buffers.\n\nThe blend equations use the source and destination blend factors specified by either [glBlendFunc](glblendfunc.xhtml) or [glBlendFuncSeparate](glblendfuncseparate.xhtml). See [glBlendFunc](glblendfunc.xhtml) or [glBlendFuncSeparate](glblendfuncseparate.xhtml) for a description of the various blend factors.\n\nIn the equations that follow, source and destination color components are referred to as (*R*_(*s*), *G*_(*s*), *B*_(*s*), *A*_(*s*)) and (*R*_(*d*), *G*_(*d*), *B*_(*d*), *A*_(*d*)), respectively. The result color is referred to as (*R*_(*r*), *G*_(*r*), *B*_(*r*), *A*_(*r*)). The source and destination blend factors are denoted (*s*_(*R*), *s*_(*G*), *s*_(*B*), *s*_(*A*)) and (*d*_(*R*), *d*_(*G*), *d*_(*B*), *d*_(*A*)), respectively. For these equations all color components are understood to have values in the range \\[0, 1\\].\n\n|  **Mode**                  |  **RGB Components**                                                                                                                                |  **Alpha Component**                             |\n|:---------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------|\n| `GL_FUNC_ADD`              | *R**r* = *R*_(*s*)*s*_(*R*) + *R*_(*d*)*d*_(*R*) *G**r* = *G*_(*s*)*s*_(*G*) + *G*_(*d*)*d*_(*G*) *B**r* = *B*_(*s*)*s*_(*B*) + *B*_(*d*)*d*_(*B*) | *A**r* = *A*_(*s*)*s*_(*A*) + *A*_(*d*)*d*_(*A*) |\n| `GL_FUNC_SUBTRACT`         | *R**r* = *R*_(*s*)*s*_(*R*) − *R*_(*d*)*d*_(*R*) *G**r* = *G*_(*s*)*s*_(*G*) − *G*_(*d*)*d*_(*G*) *B**r* = *B*_(*s*)*s*_(*B*) − *B*_(*d*)*d*_(*B*) | *A**r* = *A*_(*s*)*s*_(*A*) − *A*_(*d*)*d*_(*A*) |\n| `GL_FUNC_REVERSE_SUBTRACT` | *R**r* = *R*_(*d*)*d*_(*R*) − *R*_(*s*)*s*_(*R*) *G**r* = *G*_(*d*)*d*_(*G*) − *G*_(*s*)*s*_(*G*) *B**r* = *B*_(*d*)*d*_(*B*) − *B*_(*s*)*s*_(*B*) | *A**r* = *A*_(*d*)*d*_(*A*) − *A*_(*s*)*s*_(*A*) |\n| `GL_MIN`                   | *R**r* = *min* (*R*_(*s*), *R*_(*d*)) *G**r* = *min* (*G*_(*s*), *G*_(*d*)) *B**r* = *min* (*B*_(*s*), *B*_(*d*))                                  | *A**r* = *min* (*A*_(*s*), *A*_(*d*))            |\n| `GL_MAX`                   | *R**r* = *max* (*R*_(*s*), *R*_(*d*)) *G**r* = *max* (*G*_(*s*), *G*_(*d*)) *B**r* = *max* (*B*_(*s*), *B*_(*d*))                                  | *A**r* = *max* (*A*_(*s*), *A*_(*d*))            |\n\nThe results of these equations are clamped to the range \\[0, 1\\].\n\nThe `GL_MIN` and `GL_MAX` equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The `GL_FUNC_ADD` equation is useful for antialiasing and transparency, among other things.\n\nInitially, both the RGB blend equation and the alpha blend equation are set to `GL_FUNC_ADD`.\n\n## Notes\n\nThe `GL_MIN`, and `GL_MAX` equations do not use the source or destination factors, only the source and destination colors.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if either *`modeRGB`* or *`modeAlpha`* is not one of `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MAX`, or `GL_MIN`.\n\n`GL_INVALID_VALUE` is generated by `glBlendEquationSeparatei` if *`buf`* is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with an argument of `GL_BLEND_EQUATION_RGB`\n\n[glGet](glget.xhtml) with an argument of `GL_BLEND_EQUATION_ALPHA`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBlendEquationSeparate`     |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glBlendEquationSeparatei`    |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGetString](glgetstring.xhtml), [glBlendColor](glblendcolor.xhtml), [glBlendFunc](glblendfunc.xhtml), [glBlendFuncSeparate](glblendfuncseparate.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendEquationSeparate.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendEquationSeparate.xhtml)"
- name: glBlendFunc
  id: glblendfunc.xhtml
  summary: buf For glBlendFunci, specifies the index of the draw buffer for which to set the blend function
  description: "## Name\n\nglBlendFunc — specify pixel arithmetic\n\n## C Specification\n\n`void `**`glBlendFunc`**`(` GLenum `sfactor`, GLenum `dfactor``)`;\n\n`void `**`glBlendFunci`**`(` GLuint `buf`, GLenum `sfactor`, GLenum `dfactor``)`;\n\n## Parameters\n\n *`buf`*  \nFor `glBlendFunci`, specifies the index of the draw buffer for which to set the blend function.\n\n *`sfactor`*  \nSpecifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`.\n\n *`dfactor`*  \nSpecifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`.\n\n## Description\n\nPixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use [glEnable](glenable.xhtml) and `glDisable` with argument `GL_BLEND` to enable and disable blending.\n\n`glBlendFunc` defines the operation of blending for all draw buffers when it is enabled. `glBlendFunci` defines the operation of blending for a single draw buffer specified by *`buf`* when enabled for that draw buffer. *`sfactor`* specifies which method is used to scale the source color components. *`dfactor`* specifies which method is used to scale the destination color components. Both parameters must be one of the following symbolic constants: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`, `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, `GL_ONE_MINUS_CONSTANT_ALPHA`, `GL_SRC_ALPHA_SATURATE`, `GL_SRC1_COLOR`, `GL_ONE_MINUS_SRC1_COLOR`, `GL_SRC1_ALPHA`, and `GL_ONE_MINUS_SRC1_ALPHA`. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, first source, second source and destination color components are referred to as (*R*_(*s**0*), *G*_(*s**0*), *B*_(*s**0*), *A*_(*s**0*)), (*R*_(*s**1*), *G*_(*s**1*), *B*_(*s**1*), *A*_(*s**1*)) and (*R*_(*d*), *G*_(*d*), *B*_(*d*), *A*_(*d*)), respectively. The color specified by [glBlendColor](glblendcolor.xhtml) is referred to as (*R*_(*c*), *G*_(*c*), *B*_(*c*), *A*_(*c*)). They are understood to have integer values between 0 and (*k*_(*R*), *k*_(*G*), *k*_(*B*), *k*_(*A*)), where\n\n*k*_(*c*) = 2^(*m*_(*c*)) − 1\n\nand (*m*_(*R*), *m*_(*G*), *m*_(*B*), *m*_(*A*)) is the number of red, green, blue, and alpha bitplanes.\n\nSource and destination scale factors are referred to as (*s*_(*R*), *s*_(*G*), *s*_(*B*), *s*_(*A*)) and (*d*_(*R*), *d*_(*G*), *d*_(*B*), *d*_(*A*)). The scale factors described in the table, denoted (*f*_(*R*), *f*_(*G*), *f*_(*B*), *f*_(*A*)), represent either source or destination factors. All scale factors have range \\[0, 1\\].\n\n|  **Parameter**                | (*f*_(*R*), *f*_(*G*), *f*_(*B*), *f*_(*A*))                                                                                                                                                                                                                                              |\n|:------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `GL_ZERO`                     | (0, 0, 0, 0)                                                                                                                                                                                                                                                                              |\n| `GL_ONE`                      | (1, 1, 1, 1)                                                                                                                                                                                                                                                                              |\n| `GL_SRC_COLOR`                | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            |\n| `GL_ONE_MINUS_SRC_COLOR`      | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$ |\n| `GL_DST_COLOR`                | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                                |\n| `GL_ONE_MINUS_DST_COLOR`      | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$     |\n| `GL_SRC_ALPHA`                | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            |\n| `GL_ONE_MINUS_SRC_ALPHA`      | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$ |\n| `GL_DST_ALPHA`                | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                                |\n| `GL_ONE_MINUS_DST_ALPHA`      | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$     |\n| `GL_CONSTANT_COLOR`           | (*R*_(*c*), *G*_(*c*), *B*_(*c*), *A*_(*c*))                                                                                                                                                                                                                                              |\n| `GL_ONE_MINUS_CONSTANT_COLOR` | (1, 1, 1, 1) − (*R*_(*c*), *G*_(*c*), *B*_(*c*), *A*_(*c*))                                                                                                                                                                                                                               |\n| `GL_CONSTANT_ALPHA`           | (*A*_(*c*), *A*_(*c*), *A*_(*c*), *A*_(*c*))                                                                                                                                                                                                                                              |\n| `GL_ONE_MINUS_CONSTANT_ALPHA` | (1, 1, 1, 1) − (*A*_(*c*), *A*_(*c*), *A*_(*c*), *A*_(*c*))                                                                                                                                                                                                                               |\n| `GL_SRC_ALPHA_SATURATE`       | (*i*, *i*, *i*, 1)                                                                                                                                                                                                                                                                        |\n| `GL_SRC1_COLOR`               | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            |\n| `GL_ONE_MINUS_SRC1_COLOR`     | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$ |\n| `GL_SRC1_ALPHA`               | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            |\n| `GL_ONE_MINUS_SRC1_ALPHA`     | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$ |\n\nIn the table,\n\n$\\mathit{i} = \\frac{\\mathit{\\min}\\left( {\\mathit{A}\\_{\\mathit{s}},{\\mathit{k}\\_{\\mathit{A}} - \\mathit{A}\\_{\\mathit{d}}}} \\right)}{\\mathit{k}\\_{\\mathit{A}}}$\n\nTo determine the blended RGBA values of a pixel, the system uses the following equations:\n\n*R*_(*d*) = *min* (*k*_(*R*), *R*_(*s*)*s*_(*R*) + *R*_(*d*)*d*_(*R*)) *G*_(*d*) = *min* (*k*_(*G*), *G*_(*s*)*s*_(*G*) + *G*_(*d*)*d*_(*G*)) *B*_(*d*) = *min* (*k*_(*B*), *B*_(*s*)*s*_(*B*) + *B*_(*d*)*d*_(*B*)) *A*_(*d*) = *min* (*k*_(*A*), *A*_(*s*)*s*_(*A*) + *A*_(*d*)*d*_(*A*))\n\nDespite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when *`sfactor`* is `GL_SRC_ALPHA`, *`dfactor`* is `GL_ONE_MINUS_SRC_ALPHA`, and *A*_(*s*) is equal to *k*_(*A*), the equations reduce to simple replacement:\n\n*R*_(*d*) = *R*_(*s*) *G*_(*d*) = *G*_(*s*) *B*_(*d*) = *B*_(*s*) *A*_(*d*) = *A*_(*s*)\n\n## Examples\n\nTransparency is best implemented using blend function (`GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`) with primitives sorted from farthest to nearest. Note that this transparency calculation does not require the presence of alpha bitplanes in the frame buffer.\n\nBlend function (`GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`) is also useful for rendering antialiased points and lines in arbitrary order.\n\nPolygon antialiasing is optimized using blend function (`GL_SRC_ALPHA_SATURATE`, `GL_ONE`) with polygons sorted from nearest to farthest. (See the [glEnable](glenable.xhtml), `glDisable` reference page and the `GL_POLYGON_SMOOTH` argument for information on polygon antialiasing.) Destination alpha bitplanes, which must be present for this blend function to operate correctly, store the accumulated coverage.\n\n## Notes\n\nIncoming (source) alpha would typically be used as a material opacity, ranging from 1.0 (*K*_(*A*)), representing complete opacity, to 0.0 (0), representing complete transparency.\n\nWhen more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See [glDrawBuffer](gldrawbuffer.xhtml).)\n\nWhen dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`, which may be lower than `GL_MAX_DRAW_BUFFERS`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if either *`sfactor`* or *`dfactor`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated by `glBlendFunci` if *`buf`* is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_BLEND_SRC_RGB`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_SRC_ALPHA`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_DST_RGB`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_DST_ALPHA`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_BLEND`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBlendFunc`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glBlendFunci`              |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBlendColor](glblendcolor.xhtml), [glBlendEquation](glblendequation.xhtml), [glBlendFuncSeparate](glblendfuncseparate.xhtml), [glClear](glclear.xhtml), [glDrawBuffer](gldrawbuffer.xhtml), [glEnable](glenable.xhtml), [glLogicOp](gllogicop.xhtml), [glStencilFunc](glstencilfunc.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendFunc.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendFunc.xhtml)"
- name: glBlendFunci
  id: glblendfunc.xhtml#glBlendFunci
  summary: For glBlendFunci, specifies the index of the draw buffer for which to set the blend function
  belongs_to: glBlendFunc
  description: "`void `**`glBlendFunci`**`(` GLuint `buf`, GLenum `sfactor`, GLenum `dfactor``)`;\n\n## Parameters\n\n*`buf`*\n\nFor `glBlendFunci`, specifies the index of the draw buffer for which to set the blend function.\n\n*`sfactor`*\n\nSpecifies how the red, green, blue, and alpha source blending factors are computed. The initial value is `GL_ONE`.\n\n*`dfactor`*\n\nSpecifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`. `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, and `GL_ONE_MINUS_CONSTANT_ALPHA`. The initial value is `GL_ZERO`.\n\n## Description\n\nPixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use [glEnable](glenable.xhtml) and `glDisable` with argument `GL_BLEND` to enable and disable blending.\n\n`glBlendFunc` defines the operation of blending for all draw buffers when it is enabled. `glBlendFunci` defines the operation of blending for a single draw buffer specified by *`buf`* when enabled for that draw buffer. *`sfactor`* specifies which method is used to scale the source color components. *`dfactor`* specifies which method is used to scale the destination color components. Both parameters must be one of the following symbolic constants: `GL_ZERO`, `GL_ONE`, `GL_SRC_COLOR`, `GL_ONE_MINUS_SRC_COLOR`, `GL_DST_COLOR`, `GL_ONE_MINUS_DST_COLOR`, `GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`, `GL_DST_ALPHA`, `GL_ONE_MINUS_DST_ALPHA`, `GL_CONSTANT_COLOR`, `GL_ONE_MINUS_CONSTANT_COLOR`, `GL_CONSTANT_ALPHA`, `GL_ONE_MINUS_CONSTANT_ALPHA`, `GL_SRC_ALPHA_SATURATE`, `GL_SRC1_COLOR`, `GL_ONE_MINUS_SRC1_COLOR`, `GL_SRC1_ALPHA`, and `GL_ONE_MINUS_SRC1_ALPHA`. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, first source, second source and destination color components are referred to as (*R*_(*s**0*), *G*_(*s**0*), *B*_(*s**0*), *A*_(*s**0*)), (*R*_(*s**1*), *G*_(*s**1*), *B*_(*s**1*), *A*_(*s**1*)) and (*R*_(*d*), *G*_(*d*), *B*_(*d*), *A*_(*d*)), respectively. The color specified by [glBlendColor](glblendcolor.xhtml) is referred to as (*R*_(*c*), *G*_(*c*), *B*_(*c*), *A*_(*c*)). They are understood to have integer values between 0 and (*k*_(*R*), *k*_(*G*), *k*_(*B*), *k*_(*A*)), where\n\n*k*_(*c*) = 2^(*m*_(*c*)) − 1\n\nand (*m*_(*R*), *m*_(*G*), *m*_(*B*), *m*_(*A*)) is the number of red, green, blue, and alpha bitplanes.\n\nSource and destination scale factors are referred to as (*s*_(*R*), *s*_(*G*), *s*_(*B*), *s*_(*A*)) and (*d*_(*R*), *d*_(*G*), *d*_(*B*), *d*_(*A*)). The scale factors described in the table, denoted (*f*_(*R*), *f*_(*G*), *f*_(*B*), *f*_(*A*)), represent either source or destination factors. All scale factors have range \\[0, 1\\].\n\n|  **Parameter**                | (*f*_(*R*), *f*_(*G*), *f*_(*B*), *f*_(*A*))                                                                                                                                                                                                                                              |\n|:------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `GL_ZERO`                     | (0, 0, 0, 0)                                                                                                                                                                                                                                                                              |\n| `GL_ONE`                      | (1, 1, 1, 1)                                                                                                                                                                                                                                                                              |\n| `GL_SRC_COLOR`                | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            |\n| `GL_ONE_MINUS_SRC_COLOR`      | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$ |\n| `GL_DST_COLOR`                | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                                |\n| `GL_ONE_MINUS_DST_COLOR`      | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$     |\n| `GL_SRC_ALPHA`                | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            |\n| `GL_ONE_MINUS_SRC_ALPHA`      | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$ |\n| `GL_DST_ALPHA`                | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                                |\n| `GL_ONE_MINUS_DST_ALPHA`      | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$     |\n| `GL_CONSTANT_COLOR`           | (*R*_(*c*), *G*_(*c*), *B*_(*c*), *A*_(*c*))                                                                                                                                                                                                                                              |\n| `GL_ONE_MINUS_CONSTANT_COLOR` | (1, 1, 1, 1) − (*R*_(*c*), *G*_(*c*), *B*_(*c*), *A*_(*c*))                                                                                                                                                                                                                               |\n| `GL_CONSTANT_ALPHA`           | (*A*_(*c*), *A*_(*c*), *A*_(*c*), *A*_(*c*))                                                                                                                                                                                                                                              |\n| `GL_ONE_MINUS_CONSTANT_ALPHA` | (1, 1, 1, 1) − (*A*_(*c*), *A*_(*c*), *A*_(*c*), *A*_(*c*))                                                                                                                                                                                                                               |\n| `GL_SRC_ALPHA_SATURATE`       | (*i*, *i*, *i*, 1)                                                                                                                                                                                                                                                                        |\n| `GL_SRC1_COLOR`               | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            |\n| `GL_ONE_MINUS_SRC1_COLOR`     | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{B}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$ |\n| `GL_SRC1_ALPHA`               | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            |\n| `GL_ONE_MINUS_SRC1_ALPHA`     | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$ |\n\nIn the table,\n\n$\\mathit{i} = \\frac{\\mathit{\\min}\\left( {\\mathit{A}\\_{\\mathit{s}},{\\mathit{k}\\_{\\mathit{A}} - \\mathit{A}\\_{\\mathit{d}}}} \\right)}{\\mathit{k}\\_{\\mathit{A}}}$\n\nTo determine the blended RGBA values of a pixel, the system uses the following equations:\n\n*R*_(*d*) = *min* (*k*_(*R*), *R*_(*s*)*s*_(*R*) + *R*_(*d*)*d*_(*R*)) *G*_(*d*) = *min* (*k*_(*G*), *G*_(*s*)*s*_(*G*) + *G*_(*d*)*d*_(*G*)) *B*_(*d*) = *min* (*k*_(*B*), *B*_(*s*)*s*_(*B*) + *B*_(*d*)*d*_(*B*)) *A*_(*d*) = *min* (*k*_(*A*), *A*_(*s*)*s*_(*A*) + *A*_(*d*)*d*_(*A*))\n\nDespite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when *`sfactor`* is `GL_SRC_ALPHA`, *`dfactor`* is `GL_ONE_MINUS_SRC_ALPHA`, and *A*_(*s*) is equal to *k*_(*A*), the equations reduce to simple replacement:\n\n*R*_(*d*) = *R*_(*s*) *G*_(*d*) = *G*_(*s*) *B*_(*d*) = *B*_(*s*) *A*_(*d*) = *A*_(*s*)\n\n## Examples\n\nTransparency is best implemented using blend function (`GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`) with primitives sorted from farthest to nearest. Note that this transparency calculation does not require the presence of alpha bitplanes in the frame buffer.\n\nBlend function (`GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`) is also useful for rendering antialiased points and lines in arbitrary order.\n\nPolygon antialiasing is optimized using blend function (`GL_SRC_ALPHA_SATURATE`, `GL_ONE`) with polygons sorted from nearest to farthest. (See the [glEnable](glenable.xhtml), `glDisable` reference page and the `GL_POLYGON_SMOOTH` argument for information on polygon antialiasing.) Destination alpha bitplanes, which must be present for this blend function to operate correctly, store the accumulated coverage.\n\n## Notes\n\nIncoming (source) alpha would typically be used as a material opacity, ranging from 1.0 (*K*_(*A*)), representing complete opacity, to 0.0 (0), representing complete transparency.\n\nWhen more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See [glDrawBuffer](gldrawbuffer.xhtml).)\n\nWhen dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`, which may be lower than `GL_MAX_DRAW_BUFFERS`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if either *`sfactor`* or *`dfactor`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated by `glBlendFunci` if *`buf`* is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_BLEND_SRC_RGB`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_SRC_ALPHA`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_DST_RGB`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_DST_ALPHA`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_BLEND`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBlendFunc`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glBlendFunci`                |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBlendColor](glblendcolor.xhtml), [glBlendEquation](glblendequation.xhtml), [glBlendFuncSeparate](glblendfuncseparate.xhtml), [glClear](glclear.xhtml), [glDrawBuffer](gldrawbuffer.xhtml), [glEnable](glenable.xhtml), [glLogicOp](gllogicop.xhtml), [glStencilFunc](glstencilfunc.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendFunc.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendFunc.xhtml)"
- name: glBlendFuncSeparate
  id: glblendfuncseparate.xhtml
  summary: buf For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions
  description: "## Name\n\nglBlendFuncSeparate — specify pixel arithmetic for RGB and alpha components separately\n\n## C Specification\n\n`void `**`glBlendFuncSeparate`**`(` GLenum `srcRGB`, GLenum `dstRGB`, GLenum `srcAlpha`, GLenum `dstAlpha``)`;\n\n`void `**`glBlendFuncSeparatei`**`(` GLuint `buf`, GLenum `srcRGB`, GLenum `dstRGB`, GLenum `srcAlpha`, GLenum `dstAlpha``)`;\n\n## Parameters\n\n *`buf`*  \nFor `glBlendFuncSeparatei`, specifies the index of the draw buffer for which to set the blend functions.\n\n *`srcRGB`*  \nSpecifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`.\n\n *`dstRGB`*  \nSpecifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`.\n\n *`srcAlpha`*  \nSpecified how the alpha source blending factor is computed. The initial value is `GL_ONE`.\n\n *`dstAlpha`*  \nSpecified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`.\n\n## Description\n\nPixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use [glEnable](glenable.xhtml) and `glDisable` with argument `GL_BLEND` to enable and disable blending.\n\n`glBlendFuncSeparate` defines the operation of blending for all draw buffers when it is enabled. `glBlendFuncSeparatei` defines the operation of blending for a single draw buffer specified by *`buf`* when enabled for that draw buffer. *`srcRGB`* specifies which method is used to scale the source RGB-color components. *`dstRGB`* specifies which method is used to scale the destination RGB-color components. Likewise, *`srcAlpha`* specifies which method is used to scale the source alpha color component, and *`dstAlpha`* specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha.\n\nIn the table and in subsequent equations, first source, second source and destination color components are referred to as (*R*_(*s**0*), *G*_(*s**0*), *B*_(*s**0*), *A*_(*s**0*)), (*R*_(*s**1*), *G*_(*s**1*), *B*_(*s**1*), *A*_(*s**1*)), and (*R*_(*d*), *G*_(*d*), *B*_(*d*), *A*_(*d*)), respectively. The color specified by [glBlendColor](glblendcolor.xhtml) is referred to as (*R*_(*c*), *G*_(*c*), *B*_(*c*), *A*_(*c*)). They are understood to have integer values between 0 and (*k*_(*R*), *k*_(*G*), *k*_(*B*), *k*_(*A*)), where\n\n*k*_(*c*) = 2^(*m*_(*c*)) − 1\n\nand (*m*_(*R*), *m*_(*G*), *m*_(*B*), *m*_(*A*)) is the number of red, green, blue, and alpha bitplanes.\n\nSource and destination scale factors are referred to as (*s*_(*R*), *s*_(*G*), *s*_(*B*), *s*_(*A*)) and (*d*_(*R*), *d*_(*G*), *d*_(*B*), *d*_(*A*)). All scale factors have range \\[0, 1\\].\n\n|  **Parameter**                |  **RGB Factor**                                                                                                                                                                                                                |  **Alpha Factor**                                                |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------|\n| `GL_ZERO`                     | (0, 0, 0)                                                                                                                                                                                                                      | 0                                                                |\n| `GL_ONE`                      | (1, 1, 1)                                                                                                                                                                                                                      | 1                                                                |\n| `GL_SRC_COLOR`                | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$                            | $\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}$     |\n| `GL_ONE_MINUS_SRC_COLOR`      | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$   | $1 - \\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}$ |\n| `GL_DST_COLOR`                | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$                               | $\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}$      |\n| `GL_ONE_MINUS_DST_COLOR`      | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$      | $1 - \\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}$  |\n| `GL_SRC_ALPHA`                | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            | $\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}$     |\n| `GL_ONE_MINUS_SRC_ALPHA`      | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$   | $1 - \\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}$ |\n| `GL_DST_ALPHA`                | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                               | $\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}$      |\n| `GL_ONE_MINUS_DST_ALPHA`      | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$      | $1 - \\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}$  |\n| `GL_CONSTANT_COLOR`           | (*R*_(*c*), *G*_(*c*), *B*_(*c*))                                                                                                                                                                                              | *A*_(*c*)                                                        |\n| `GL_ONE_MINUS_CONSTANT_COLOR` | (1, 1, 1) − (*R*_(*c*), *G*_(*c*), *B*_(*c*))                                                                                                                                                                                  | 1 − *A*_(*c*)                                                    |\n| `GL_CONSTANT_ALPHA`           | (*A*_(*c*), *A*_(*c*), *A*_(*c*))                                                                                                                                                                                              | *A*_(*c*)                                                        |\n| `GL_ONE_MINUS_CONSTANT_ALPHA` | (1, 1, 1) − (*A*_(*c*), *A*_(*c*), *A*_(*c*))                                                                                                                                                                                  | 1 − *A*_(*c*)                                                    |\n| `GL_SRC_ALPHA_SATURATE`       | (*i*, *i*, *i*)                                                                                                                                                                                                                | 1                                                                |\n| `GL_SRC1_COLOR`               | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$                            | $\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}$     |\n| `GL_ONE_MINUS_SRC1_COLOR`     | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$ | $1 - \\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}$ |\n| `GL_SRC1_ALPHA`               | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            | $\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}$     |\n| `GL_ONE_MINUS_SRC1_ALPHA`     | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$   | $1 - \\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}$ |\n\nIn the table,\n\n*i* = *min* (*A*_(*s*), 1 − *A*_(*d*))\n\nTo determine the blended RGBA values of a pixel, the system uses the following equations:\n\n*R*_(*d*) = *min* (*k*_(*R*), *R*_(*s*)*s*_(*R*) + *R*_(*d*)*d*_(*R*)) *G*_(*d*) = *min* (*k*_(*G*), *G*_(*s*)*s*_(*G*) + *G*_(*d*)*d*_(*G*)) *B*_(*d*) = *min* (*k*_(*B*), *B*_(*s*)*s*_(*B*) + *B*_(*d*)*d*_(*B*)) *A*_(*d*) = *min* (*k*_(*A*), *A*_(*s*)*s*_(*A*) + *A*_(*d*)*d*_(*A*))\n\nDespite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when *`srcRGB`* is `GL_SRC_ALPHA`, *`dstRGB`* is `GL_ONE_MINUS_SRC_ALPHA`, and *A*_(*s*) is equal to *k*_(*A*), the equations reduce to simple replacement:\n\n*R*_(*d*) = *R*_(*s*) *G*_(*d*) = *G*_(*s*) *B*_(*d*) = *B*_(*s*) *A*_(*d*) = *A*_(*s*)\n\n## Notes\n\nIncoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (*K*_(*A*)), representing complete opacity, to 0.0 (0), representing complete transparency.\n\nWhen more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See [glDrawBuffer](gldrawbuffer.xhtml).)\n\nWhen dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`, which may be lower than `GL_MAX_DRAW_BUFFERS`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if either *`srcRGB`* or *`dstRGB`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated by `glBlendFuncSeparatei` if *`buf`* is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_BLEND_SRC_RGB`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_SRC_ALPHA`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_DST_RGB`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_DST_ALPHA`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_BLEND`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBlendFuncSeparate`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glBlendFuncSeparatei`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBlendColor](glblendcolor.xhtml), [glBlendFunc](glblendfunc.xhtml), [glBlendEquation](glblendequation.xhtml), [glClear](glclear.xhtml), [glDrawBuffer](gldrawbuffer.xhtml), [glEnable](glenable.xhtml), [glLogicOp](gllogicop.xhtml), [glStencilFunc](glstencilfunc.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2018 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2018 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendFuncSeparate.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendFuncSeparate.xhtml)"
- name: glBlendFuncSeparatei
  id: glblendfuncseparate.xhtml#glBlendFuncSeparatei
  summary: For glBlendFuncSeparatei, specifies the index of the draw buffer for which to set the blend functions
  belongs_to: glBlendFuncSeparate
  description: "`void `**`glBlendFuncSeparatei`**`(` GLuint `buf`, GLenum `srcRGB`, GLenum `dstRGB`, GLenum `srcAlpha`, GLenum `dstAlpha``)`;\n\n## Parameters\n\n*`buf`*\n\nFor `glBlendFuncSeparatei`, specifies the index of the draw buffer for which to set the blend functions.\n\n*`srcRGB`*\n\nSpecifies how the red, green, and blue blending factors are computed. The initial value is `GL_ONE`.\n\n*`dstRGB`*\n\nSpecifies how the red, green, and blue destination blending factors are computed. The initial value is `GL_ZERO`.\n\n*`srcAlpha`*\n\nSpecified how the alpha source blending factor is computed. The initial value is `GL_ONE`.\n\n*`dstAlpha`*\n\nSpecified how the alpha destination blending factor is computed. The initial value is `GL_ZERO`.\n\n## Description\n\nPixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use [glEnable](glenable.xhtml) and `glDisable` with argument `GL_BLEND` to enable and disable blending.\n\n`glBlendFuncSeparate` defines the operation of blending for all draw buffers when it is enabled. `glBlendFuncSeparatei` defines the operation of blending for a single draw buffer specified by *`buf`* when enabled for that draw buffer. *`srcRGB`* specifies which method is used to scale the source RGB-color components. *`dstRGB`* specifies which method is used to scale the destination RGB-color components. Likewise, *`srcAlpha`* specifies which method is used to scale the source alpha color component, and *`dstAlpha`* specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha.\n\nIn the table and in subsequent equations, first source, second source and destination color components are referred to as (*R*_(*s**0*), *G*_(*s**0*), *B*_(*s**0*), *A*_(*s**0*)), (*R*_(*s**1*), *G*_(*s**1*), *B*_(*s**1*), *A*_(*s**1*)), and (*R*_(*d*), *G*_(*d*), *B*_(*d*), *A*_(*d*)), respectively. The color specified by [glBlendColor](glblendcolor.xhtml) is referred to as (*R*_(*c*), *G*_(*c*), *B*_(*c*), *A*_(*c*)). They are understood to have integer values between 0 and (*k*_(*R*), *k*_(*G*), *k*_(*B*), *k*_(*A*)), where\n\n*k*_(*c*) = 2^(*m*_(*c*)) − 1\n\nand (*m*_(*R*), *m*_(*G*), *m*_(*B*), *m*_(*A*)) is the number of red, green, blue, and alpha bitplanes.\n\nSource and destination scale factors are referred to as (*s*_(*R*), *s*_(*G*), *s*_(*B*), *s*_(*A*)) and (*d*_(*R*), *d*_(*G*), *d*_(*B*), *d*_(*A*)). All scale factors have range \\[0, 1\\].\n\n|  **Parameter**                |  **RGB Factor**                                                                                                                                                                                                                |  **Alpha Factor**                                                |\n|:------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------|\n| `GL_ZERO`                     | (0, 0, 0)                                                                                                                                                                                                                      | 0                                                                |\n| `GL_ONE`                      | (1, 1, 1)                                                                                                                                                                                                                      | 1                                                                |\n| `GL_SRC_COLOR`                | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$                            | $\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}$     |\n| `GL_ONE_MINUS_SRC_COLOR`      | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$   | $1 - \\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}$ |\n| `GL_DST_COLOR`                | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$                               | $\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}$      |\n| `GL_ONE_MINUS_DST_COLOR`      | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$      | $1 - \\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}$  |\n| `GL_SRC_ALPHA`                | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            | $\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}$     |\n| `GL_ONE_MINUS_SRC_ALPHA`      | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$   | $1 - \\frac{\\mathit{A}\\_{\\mathit{s0}}}{\\mathit{k}\\_{\\mathit{A}}}$ |\n| `GL_DST_ALPHA`                | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                               | $\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}$      |\n| `GL_ONE_MINUS_DST_ALPHA`      | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$      | $1 - \\frac{\\mathit{A}\\_{\\mathit{d}}}{\\mathit{k}\\_{\\mathit{A}}}$  |\n| `GL_CONSTANT_COLOR`           | (*R*_(*c*), *G*_(*c*), *B*_(*c*))                                                                                                                                                                                              | *A*_(*c*)                                                        |\n| `GL_ONE_MINUS_CONSTANT_COLOR` | (1, 1, 1) − (*R*_(*c*), *G*_(*c*), *B*_(*c*))                                                                                                                                                                                  | 1 − *A*_(*c*)                                                    |\n| `GL_CONSTANT_ALPHA`           | (*A*_(*c*), *A*_(*c*), *A*_(*c*))                                                                                                                                                                                              | *A*_(*c*)                                                        |\n| `GL_ONE_MINUS_CONSTANT_ALPHA` | (1, 1, 1) − (*A*_(*c*), *A*_(*c*), *A*_(*c*))                                                                                                                                                                                  | 1 − *A*_(*c*)                                                    |\n| `GL_SRC_ALPHA_SATURATE`       | (*i*, *i*, *i*)                                                                                                                                                                                                                | 1                                                                |\n| `GL_SRC1_COLOR`               | $\\left( {\\frac{\\mathit{R}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$                            | $\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}$     |\n| `GL_ONE_MINUS_SRC1_COLOR`     | $\\left( {1,1,1,1} \\right) - \\left( {\\frac{\\mathit{R}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{R}}},\\frac{\\mathit{G}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{G}}},\\frac{\\mathit{B}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{B}}}} \\right)$ | $1 - \\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}$ |\n| `GL_SRC1_ALPHA`               | $\\left( {\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$                            | $\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}$     |\n| `GL_ONE_MINUS_SRC1_ALPHA`     | $\\left( {1,1,1} \\right) - \\left( {\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}},\\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}} \\right)$   | $1 - \\frac{\\mathit{A}\\_{\\mathit{s1}}}{\\mathit{k}\\_{\\mathit{A}}}$ |\n\nIn the table,\n\n*i* = *min* (*A*_(*s*), 1 − *A*_(*d*))\n\nTo determine the blended RGBA values of a pixel, the system uses the following equations:\n\n*R*_(*d*) = *min* (*k*_(*R*), *R*_(*s*)*s*_(*R*) + *R*_(*d*)*d*_(*R*)) *G*_(*d*) = *min* (*k*_(*G*), *G*_(*s*)*s*_(*G*) + *G*_(*d*)*d*_(*G*)) *B*_(*d*) = *min* (*k*_(*B*), *B*_(*s*)*s*_(*B*) + *B*_(*d*)*d*_(*B*)) *A*_(*d*) = *min* (*k*_(*A*), *A*_(*s*)*s*_(*A*) + *A*_(*d*)*d*_(*A*))\n\nDespite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when *`srcRGB`* is `GL_SRC_ALPHA`, *`dstRGB`* is `GL_ONE_MINUS_SRC_ALPHA`, and *A*_(*s*) is equal to *k*_(*A*), the equations reduce to simple replacement:\n\n*R*_(*d*) = *R*_(*s*) *G*_(*d*) = *G*_(*s*) *B*_(*d*) = *B*_(*s*) *A*_(*d*) = *A*_(*s*)\n\n## Notes\n\nIncoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (*K*_(*A*)), representing complete opacity, to 0.0 (0), representing complete transparency.\n\nWhen more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See [glDrawBuffer](gldrawbuffer.xhtml).)\n\nWhen dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`, which may be lower than `GL_MAX_DRAW_BUFFERS`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if either *`srcRGB`* or *`dstRGB`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated by `glBlendFuncSeparatei` if *`buf`* is greater than or equal to the value of `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_BLEND_SRC_RGB`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_SRC_ALPHA`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_DST_RGB`\n\n[glGet](glget.xhtml) with argument `GL_BLEND_DST_ALPHA`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_BLEND`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBlendFuncSeparate`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glBlendFuncSeparatei`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBlendColor](glblendcolor.xhtml), [glBlendFunc](glblendfunc.xhtml), [glBlendEquation](glblendequation.xhtml), [glClear](glclear.xhtml), [glDrawBuffer](gldrawbuffer.xhtml), [glEnable](glenable.xhtml), [glLogicOp](gllogicop.xhtml), [glStencilFunc](glstencilfunc.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2018 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2018 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendFuncSeparate.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlendFuncSeparate.xhtml)"
- name: glBlitFramebuffer
  id: glblitframebuffer.xhtml
  summary: readFramebuffer Specifies the name of the source framebuffer object for glBlitNamedFramebuffer
  description: "## Name\n\nglBlitFramebuffer, glBlitNamedFramebuffer — copy a block of pixels from one framebuffer object to another\n\n## C Specification\n\n`void `**`glBlitFramebuffer`**`(` GLint `srcX0`, GLint `srcY0`, GLint `srcX1`, GLint `srcY1`, GLint `dstX0`, GLint `dstY0`, GLint `dstX1`, GLint `dstY1`, GLbitfield `mask`, GLenum `filter``)`;\n\n`void `**`glBlitNamedFramebuffer`**`(` GLuint `readFramebuffer`, GLuint `drawFramebuffer`, GLint `srcX0`, GLint `srcY0`, GLint `srcX1`, GLint `srcY1`, GLint `dstX0`, GLint `dstY0`, GLint `dstX1`, GLint `dstY1`, GLbitfield `mask`, GLenum `filter``)`;\n\n## Parameters\n\n *`readFramebuffer`*  \nSpecifies the name of the source framebuffer object for `glBlitNamedFramebuffer`.\n\n *`drawFramebuffer`*  \nSpecifies the name of the destination framebuffer object for `glBlitNamedFramebuffer`.\n\n*`srcX0`*,  *`srcY0`*,  *`srcX1`*,   *`srcY1`*  \nSpecify the bounds of the source rectangle within the read buffer of the read framebuffer.\n\n*`dstX0`*,  *`dstY0`*,  *`dstX1`*,   *`dstY1`*  \nSpecify the bounds of the destination rectangle within the write buffer of the write framebuffer.\n\n *`mask`*  \nThe bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`.\n\n *`filter`*  \nSpecifies the interpolation to be applied if the image is stretched. Must be `GL_NEAREST` or `GL_LINEAR`.\n\n## Description\n\n`glBlitFramebuffer` and `glBlitNamedFramebuffer` transfer a rectangle of pixel values from one region of a read framebuffer to another region of a draw framebuffer.\n\nFor `glBlitFramebuffer`, the read and draw framebuffers are those bound to the `GL_READ_FRAMEBUFFER` and `GL_DRAW_FRAMEBUFFER` targets respectively.\n\nFor `glBlitNamedFramebuffer`, *`readFramebuffer`* and *`drawFramebuffer`* are the names of the read and draw framebuffer objects respectively. If *`readFramebuffer`* or *`drawFramebuffer`* is zero, then the default read or draw framebuffer respectively is used.\n\n*`mask`* is the bitwise OR of a number of values indicating which buffers are to be copied. The values are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. The pixels corresponding to these buffers are copied from the source rectangle bounded by the locations (*`srcX0`*, *`srcY0`*) and (*`srcX1`*, *`srcY1`*) to the destination rectangle bounded by the locations (*`dstX0`*, *`dstY0`*) and (*`dstX1`*, *`dstY1`*). The lower bounds of the rectangle are inclusive, while the upper bounds are exclusive.\n\nThe actual region taken from the read framebuffer is limited to the intersection of the source buffers being transferred, which may include the color buffer selected by the read buffer, the depth buffer, and/or the stencil buffer depending on mask. The actual region written to the draw framebuffer is limited to the intersection of the destination buffers being written, which may include multiple draw buffers, the depth buffer, and/or the stencil buffer depending on mask. Whether or not the source or destination regions are altered due to these limits, the scaling and offset applied to pixels being transferred is performed as though no such limits were present.\n\nIf the sizes of the source and destination rectangles are not equal, *`filter`* specifies the interpolation method that will be applied to resize the source image , and must be `GL_NEAREST` or `GL_LINEAR`. `GL_LINEAR` is only a valid interpolation method for the color buffer. If *`filter`* is not `GL_NEAREST` and *`mask`* includes `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT`, no data is transferred and a `GL_INVALID_OPERATION` error is generated.\n\nIf *`filter`* is `GL_LINEAR` and the source rectangle would require sampling outside the bounds of the source framebuffer, values are read as if the `GL_CLAMP_TO_EDGE` texture wrapping mode were applied.\n\nWhen the color buffer is transferred, values are taken from the read buffer of the specified read framebuffer and written to each of the draw buffers of the specified draw framebuffer.\n\nIf the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result of the operation is undefined.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `BlitNamedFramebuffer` if *`readFramebuffer`* or *`drawFramebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_OPERATION` is generated if *`mask`* contains any of the `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT` and *`filter`* is not `GL_NEAREST`.\n\n`GL_INVALID_OPERATION` is generated if *`mask`* contains `GL_COLOR_BUFFER_BIT` and any of the following conditions hold:\n\n- The read buffer contains fixed-point or floating-point values and any draw buffer contains neither fixed-point nor floating-point values.\n\n- The read buffer contains unsigned integer values and any draw buffer does not contain unsigned integer values.\n\n- The read buffer contains signed integer values and any draw buffer does not contain signed integer values.\n\n`GL_INVALID_OPERATION` is generated if *`mask`* contains `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT` and the source and destination depth and stencil formats do not match.\n\n`GL_INVALID_OPERATION` is generated if *`filter`* is `GL_LINEAR` and the read buffer contains integer data.\n\n`GL_INVALID_OPERATION` is generated if both the read and draw framebuffers are multisampled, and their effective values of `GL_SAMPLES` are not identical.\n\n`GL_INVALID_OPERATION` is generated if the value of `GL_SAMPLE_BUFFERS` for either read or draw buffers is greater than zero and the dimensions of the source and destination rectangles is not identical.\n\n`GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the specified read and draw framebuffers are not framebuffer complete.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBlitFramebuffer`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glBlitNamedFramebuffer`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glReadPixels](glreadpixels.xhtml) [glCheckFramebufferStatus](glcheckframebufferstatus.xhtml), [glGenFramebuffers](glgenframebuffers.xhtml) [glBindFramebuffer](glbindframebuffer.xhtml) [glDeleteFramebuffers](gldeleteframebuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlitFramebuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlitFramebuffer.xhtml)"
- name: glBlitNamedFramebuffer
  id: glblitframebuffer.xhtml#glBlitNamedFramebuffer
  summary: Specifies the name of the source framebuffer object for glBlitNamedFramebuffer
  belongs_to: glBlitFramebuffer
  description: "`void `**`glBlitNamedFramebuffer`**`(` GLuint `readFramebuffer`, GLuint `drawFramebuffer`, GLint `srcX0`, GLint `srcY0`, GLint `srcX1`, GLint `srcY1`, GLint `dstX0`, GLint `dstY0`, GLint `dstX1`, GLint `dstY1`, GLbitfield `mask`, GLenum `filter``)`;\n\n## Parameters\n\n*`readFramebuffer`*\n\nSpecifies the name of the source framebuffer object for `glBlitNamedFramebuffer`.\n\n*`drawFramebuffer`*\n\nSpecifies the name of the destination framebuffer object for `glBlitNamedFramebuffer`.\n\n*`srcX0`*, *`srcY0`*, *`srcX1`*, *`srcY1`*\n\nSpecify the bounds of the source rectangle within the read buffer of the read framebuffer.\n\n*`dstX0`*, *`dstY0`*, *`dstX1`*, *`dstY1`*\n\nSpecify the bounds of the destination rectangle within the write buffer of the write framebuffer.\n\n*`mask`*\n\nThe bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT` and `GL_STENCIL_BUFFER_BIT`.\n\n*`filter`*\n\nSpecifies the interpolation to be applied if the image is stretched. Must be `GL_NEAREST` or `GL_LINEAR`.\n\n## Description\n\n`glBlitFramebuffer` and `glBlitNamedFramebuffer` transfer a rectangle of pixel values from one region of a read framebuffer to another region of a draw framebuffer.\n\nFor `glBlitFramebuffer`, the read and draw framebuffers are those bound to the `GL_READ_FRAMEBUFFER` and `GL_DRAW_FRAMEBUFFER` targets respectively.\n\nFor `glBlitNamedFramebuffer`, *`readFramebuffer`* and *`drawFramebuffer`* are the names of the read and draw framebuffer objects respectively. If *`readFramebuffer`* or *`drawFramebuffer`* is zero, then the default read or draw framebuffer respectively is used.\n\n*`mask`* is the bitwise OR of a number of values indicating which buffers are to be copied. The values are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`. The pixels corresponding to these buffers are copied from the source rectangle bounded by the locations (*`srcX0`*, *`srcY0`*) and (*`srcX1`*, *`srcY1`*) to the destination rectangle bounded by the locations (*`dstX0`*, *`dstY0`*) and (*`dstX1`*, *`dstY1`*). The lower bounds of the rectangle are inclusive, while the upper bounds are exclusive.\n\nThe actual region taken from the read framebuffer is limited to the intersection of the source buffers being transferred, which may include the color buffer selected by the read buffer, the depth buffer, and/or the stencil buffer depending on mask. The actual region written to the draw framebuffer is limited to the intersection of the destination buffers being written, which may include multiple draw buffers, the depth buffer, and/or the stencil buffer depending on mask. Whether or not the source or destination regions are altered due to these limits, the scaling and offset applied to pixels being transferred is performed as though no such limits were present.\n\nIf the sizes of the source and destination rectangles are not equal, *`filter`* specifies the interpolation method that will be applied to resize the source image , and must be `GL_NEAREST` or `GL_LINEAR`. `GL_LINEAR` is only a valid interpolation method for the color buffer. If *`filter`* is not `GL_NEAREST` and *`mask`* includes `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT`, no data is transferred and a `GL_INVALID_OPERATION` error is generated.\n\nIf *`filter`* is `GL_LINEAR` and the source rectangle would require sampling outside the bounds of the source framebuffer, values are read as if the `GL_CLAMP_TO_EDGE` texture wrapping mode were applied.\n\nWhen the color buffer is transferred, values are taken from the read buffer of the specified read framebuffer and written to each of the draw buffers of the specified draw framebuffer.\n\nIf the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result of the operation is undefined.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `BlitNamedFramebuffer` if *`readFramebuffer`* or *`drawFramebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_OPERATION` is generated if *`mask`* contains any of the `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT` and *`filter`* is not `GL_NEAREST`.\n\n`GL_INVALID_OPERATION` is generated if *`mask`* contains `GL_COLOR_BUFFER_BIT` and any of the following conditions hold:\n\n- The read buffer contains fixed-point or floating-point values and any draw buffer contains neither fixed-point nor floating-point values.\n\n- The read buffer contains unsigned integer values and any draw buffer does not contain unsigned integer values.\n\n- The read buffer contains signed integer values and any draw buffer does not contain signed integer values.\n\n`GL_INVALID_OPERATION` is generated if *`mask`* contains `GL_DEPTH_BUFFER_BIT` or `GL_STENCIL_BUFFER_BIT` and the source and destination depth and stencil formats do not match.\n\n`GL_INVALID_OPERATION` is generated if *`filter`* is `GL_LINEAR` and the read buffer contains integer data.\n\n`GL_INVALID_OPERATION` is generated if both the read and draw framebuffers are multisampled, and their effective values of `GL_SAMPLES` are not identical.\n\n`GL_INVALID_OPERATION` is generated if the value of `GL_SAMPLE_BUFFERS` for either read or draw buffers is greater than zero and the dimensions of the source and destination rectangles is not identical.\n\n`GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the specified read and draw framebuffers are not framebuffer complete.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBlitFramebuffer`           |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glBlitNamedFramebuffer`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glReadPixels](glreadpixels.xhtml)[glCheckFramebufferStatus](glcheckframebufferstatus.xhtml), [glGenFramebuffers](glgenframebuffers.xhtml)[glBindFramebuffer](glbindframebuffer.xhtml)[glDeleteFramebuffers](gldeleteframebuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBlitFramebuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBlitFramebuffer.xhtml)"
- name: glBufferData
  id: glbufferdata.xhtml
  summary: buffer Specifies the name of the buffer object for glNamedBufferData function
  description: "## Name\n\nglBufferData, glNamedBufferData — creates and initializes a buffer object's data store\n\n## C Specification\n\n`void `**`glBufferData`**`(` GLenum `target`, GLsizeiptr `size`, const void \\* `data`, GLenum `usage``)`;\n\n`void `**`glNamedBufferData`**`(` GLuint `buffer`, GLsizeiptr `size`, const void \\*`data`, GLenum `usage``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glBufferData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glNamedBufferData` function.\n\n *`size`*  \nSpecifies the size in bytes of the buffer object's new data store.\n\n *`data`*  \nSpecifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.\n\n *`usage`*  \nSpecifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.\n\n## Description\n\n`glBufferData` and `glNamedBufferData` create a new data store for a buffer object. In case of `glBufferData`, the buffer object currently bound to *`target`* is used. For `glNamedBufferData`, a buffer object associated with ID specified by the caller in *`buffer`* will be used instead.\n\nWhile creating the new storage, any pre-existing data store is deleted. The new data store is created with the specified *`size`* in bytes and *`usage`*. If *`data`* is not `NULL`, the data store is initialized with data from this pointer. In its initial state, the new data store is not mapped, it has a `NULL` mapped pointer, and its mapped access is `GL_READ_WRITE`.\n\n*`usage`* is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. *`usage`* can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these:\n\nSTREAM  \nThe data store contents will be modified once and used at most a few times.\n\nSTATIC  \nThe data store contents will be modified once and used many times.\n\nDYNAMIC  \nThe data store contents will be modified repeatedly and used many times.\n\nThe nature of access may be one of these:\n\nDRAW  \nThe data store contents are modified by the application, and used as the source for GL drawing and image specification commands.\n\nREAD  \nThe data store contents are modified by reading data from the GL, and used to return that data when queried by the application.\n\nCOPY  \nThe data store contents are modified by reading data from the GL, and used as the source for GL drawing and image specification commands.\n\n## Notes\n\nIf *`data`* is `NULL`, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.\n\nClients must align data elements consistently with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising *N* bytes be a multiple of *N*.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glBufferData` if *`target`* is not one of the accepted buffer targets.\n\n`GL_INVALID_ENUM` is generated if *`usage`* is not `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.\n\n`GL_INVALID_VALUE` is generated if *`size`* is negative.\n\n`GL_INVALID_OPERATION` is generated by `glBufferData` if the reserved buffer object name 0 is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedBufferData` if buffer is not the name of an existing buffer object.\n\n`GL_INVALID_OPERATION` is generated if the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer object is `GL_TRUE`.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the specified *`size`*.\n\n## Associated Gets\n\n[glGetBufferSubData](glgetbuffersubdata.xhtml)\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_SIZE` or `GL_BUFFER_USAGE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBufferData`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glNamedBufferData`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferData.xhtml)"
- name: glBufferStorage
  id: glbufferstorage.xhtml
  summary: buffer Specifies the name of the buffer object for glNamedBufferStorage function
  description: "## Name\n\nglBufferStorage, glNamedBufferStorage — creates and initializes a buffer object's immutable data store\n\n## C Specification\n\n`void `**`glBufferStorage`**`(` GLenum `target`, GLsizeiptr `size`, const void \\* `data`, GLbitfield `flags``)`;\n\n`void `**`glNamedBufferStorage`**`(` GLuint `buffer`, GLsizeiptr `size`, const void \\*`data`, GLbitfield `flags``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glBufferStorage`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glNamedBufferStorage` function.\n\n *`size`*  \nSpecifies the size in bytes of the buffer object's new data store.\n\n *`data`*  \nSpecifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.\n\n *`flags`*  \nSpecifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. `GL_DYNAMIC_STORAGE_BIT`, `GL_MAP_READ_BIT` `GL_MAP_WRITE_BIT`, `GL_MAP_PERSISTENT_BIT`, `GL_MAP_COHERENT_BIT`, and `GL_CLIENT_STORAGE_BIT`.\n\n## Description\n\n`glBufferStorage` and `glNamedBufferStorage` create a new immutable data store. For `glBufferStorage`, the buffer object currently bound to *`target`* will be initialized. For `glNamedBufferStorage`, *`buffer`* is the name of the buffer object that will be configured. The size of the data store is specified by *`size`*. If an initial data is available, its address may be supplied in *`data`*. Otherwise, to create an uninitialized data store, *`data`* should be `NULL`.\n\nThe *`flags`* parameters specifies the intended usage of the buffer's data store. It must be a bitwise combination of a subset of the following flags:\n\n `GL_DYNAMIC_STORAGE_BIT`  \nThe contents of the data store may be updated after creation through calls to [glBufferSubData](glbuffersubdata.xhtml). If this bit is not set, the buffer content may not be directly updated by the client. The data argument may be used to specify the initial content of the buffer's data store regardless of the presence of the `GL_DYNAMIC_STORAGE_BIT`. Regardless of the presence of this bit, buffers may always be updated with server-side calls such as [glCopyBufferSubData](glcopybuffersubdata.xhtml) and [glClearBufferSubData](glclearbuffersubdata.xhtml).\n\n `GL_MAP_READ_BIT`  \nThe data store may be mapped by the client for read access and a pointer in the client's address space obtained that may be read from.\n\n `GL_MAP_WRITE_BIT`  \nThe data store may be mapped by the client for write access and a pointer in the client's address space obtained that may be written through.\n\n `GL_MAP_PERSISTENT_BIT`  \nThe client may request that the server read from or write to the buffer while it is mapped. The client's pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.\n\n `GL_MAP_COHERENT_BIT`  \nShared access to buffers that are simultaneously mapped for client access and are used by the server will be coherent, so long as that mapping is performed using [glMapBufferRange](glmapbufferrange.xhtml). That is, data written to the store by either the client or server will be immediately visible to the other with no further action taken by the application. In particular,\n\n- If `GL_MAP_COHERENT_BIT` is not set and the client performs a write followed by a call to the [glMemoryBarrier](glmemorybarrier.xhtml) command with the `GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT` set, then in subsequent commands the server will see the writes.\n\n- If `GL_MAP_COHERENT_BIT` is set and the client performs a write, then in subsequent commands the server will see the writes.\n\n- If `GL_MAP_COHERENT_BIT` is not set and the server performs a write, the application must call [glMemoryBarrier](glmemorybarrier.xhtml) with the `GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT` set and then call [glFenceSync](glfencesync.xhtml) with `GL_SYNC_GPU_COMMANDS_COMPLETE` (or `glFinish`). Then the CPU will see the writes after the sync is complete.\n\n- If `GL_MAP_COHERENT_BIT` is set and the server does a write, the app must call `glFenceSync` with `GL_SYNC_GPU_COMMANDS_COMPLETE` (or [glFinish](glfinish.xhtml)). Then the CPU will see the writes after the sync is complete.\n\n `GL_CLIENT_STORAGE_BIT`  \nWhen all other criteria for the buffer storage allocation are met, this bit may be used by an implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.\n\nThe allowed combinations of flags are subject to certain restrictions. They are as follows:\n\n- If *`flags`* contains `GL_MAP_PERSISTENT_BIT`, it must also contain at least one of `GL_MAP_READ_BIT` or `GL_MAP_WRITE_BIT`.\n\n- If *`flags`* contains `GL_MAP_COHERENT_BIT`, it must also contain `GL_MAP_PERSISTENT_BIT`.\n\n## Notes\n\n`glBufferStorage` is available only if the GL version is 4.4 or greater.\n\n`glNamedBufferStorage` is available only if the GL version is 4.5 or greater.\n\nIf *`data`* is `NULL`, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glBufferStorage` if *`target`* is not one of the accepted buffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glNamedBufferStorage` if buffer is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`size`* is less than or equal to zero.\n\n`GL_INVALID_OPERATION` is generated by `glBufferStorage` if the reserved buffer object name 0 is bound to *`target`*.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the properties requested in *`flags`*.\n\n`GL_INVALID_VALUE` is generated if *`flags`* has any bits set other than those defined above.\n\n`GL_INVALID_VALUE` error is generated if *`flags`* contains `GL_MAP_PERSISTENT_BIT` but does not contain at least one of `GL_MAP_READ_BIT` or `GL_MAP_WRITE_BIT`.\n\n`GL_INVALID_VALUE` is generated if *`flags`* contains `GL_MAP_COHERENT_BIT`, but does not also contain `GL_MAP_PERSISTENT_BIT`.\n\n`GL_INVALID_OPERATION` is generated by `glBufferStorage` if the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer bound to *`target`* is `GL_TRUE`.\n\n## Associated Gets\n\n[glGetBufferSubData](glgetbuffersubdata.xhtml)\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_SIZE` or `GL_BUFFER_USAGE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBufferStorage`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |\n| `glNamedBufferStorage`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferStorage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferStorage.xhtml)"
- name: glBufferSubData
  id: glbuffersubdata.xhtml
  summary: buffer Specifies the name of the buffer object for glNamedBufferSubData
  description: "## Name\n\nglBufferSubData, glNamedBufferSubData — updates a subset of a buffer object's data store\n\n## C Specification\n\n`void `**`glBufferSubData`**`(` GLenum `target`, GLintptr `offset`, GLsizeiptr `size`, const void \\* `data``)`;\n\n`void `**`glNamedBufferSubData`**`(` GLuint `buffer`, GLintptr `offset`, GLsizeiptr `size`, const void \\*`data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glBufferSubData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glNamedBufferSubData`.\n\n *`offset`*  \nSpecifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.\n\n *`size`*  \nSpecifies the size in bytes of the data store region being replaced.\n\n *`data`*  \nSpecifies a pointer to the new data that will be copied into the data store.\n\n## Description\n\n`glBufferSubData` and `glNamedBufferSubData` redefine some or all of the data store for the specified buffer object. Data starting at byte offset *`offset`* and extending for *`size`* bytes is copied to the data store from the memory pointed to by *`data`*. *`offset`* and *`size`* must define a range lying entirely within the buffer object's data store.\n\n## Notes\n\nWhen replacing the entire data store, consider using `glBufferSubData` rather than completely recreating the data store with `glBufferData`. This avoids the cost of reallocating the data store.\n\nConsider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering in the pipeline makes reference to data in the buffer object being updated by `glBufferSubData`, especially from the specific region being updated, that rendering must drain from the pipeline before the data store can be updated.\n\nClients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising $N$ bytes be a multiple of $N$.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glBufferSubData` if *`target`* is not one of the accepted buffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glBufferSubData` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedBufferSubData` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`size`* is negative, or if $offset + size$ is greater than the value of `GL_BUFFER_SIZE` for the specified buffer object.\n\n`GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *`access`* flags.\n\n`GL_INVALID_OPERATION` is generated if the value of the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer object is `GL_TRUE` and the value of `GL_BUFFER_STORAGE_FLAGS` for the buffer object does not have the `GL_DYNAMIC_STORAGE_BIT` bit set.\n\n## Associated Gets\n\n[glGetBufferSubData](glgetbuffersubdata.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glBufferSubData`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glNamedBufferSubData`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glMapBufferRange](glmapbufferrange.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferSubData.xhtml)"
- name: glCheckFramebufferStatus
  id: glcheckframebufferstatus.xhtml
  summary: target Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus
  description: "## Name\n\nglCheckFramebufferStatus, glCheckNamedFramebufferStatus — check the completeness status of a framebuffer\n\n## C Specification\n\n`GLenum `**`glCheckFramebufferStatus`**`(` GLenum `target``)`;\n\n`GLenum `**`glCheckNamedFramebufferStatus`**`(` GLuint `framebuffer`, GLenum `target``)`;\n\n## Parameters\n\n *`target`*  \nSpecify the target to which the framebuffer is bound for `glCheckFramebufferStatus`, and the target against which framebuffer completeness of *`framebuffer`* is checked for `glCheckNamedFramebufferStatus`.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glCheckNamedFramebufferStatus`\n\n## Description\n\n`glCheckFramebufferStatus` and `glCheckNamedFramebufferStatus` return the completeness status of a framebuffer object when treated as a read or draw framebuffer, depending on the value of *`target`*.\n\nFor `glCheckFramebufferStatus`, the framebuffer checked is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glCheckNamedFramebufferStatus`, *`framebuffer`* is zero or the name of the framebuffer object to check. If *`framebuffer`* is zero, then the status of the default read or draw framebuffer, as determined by *`target`*, is returned.\n\nThe return value is `GL_FRAMEBUFFER_COMPLETE` if the specified framebuffer is complete. Otherwise, the return value is determined as follows:\n\n- `GL_FRAMEBUFFER_UNDEFINED` is returned if the specified framebuffer is the default read or draw framebuffer, but the default framebuffer does not exist.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT` is returned if any of the framebuffer attachment points are framebuffer incomplete.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT` is returned if the framebuffer does not have at least one image attached to it.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER` is returned if the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` for any color attachment point(s) named by `GL_DRAW_BUFFERi`.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER` is returned if `GL_READ_BUFFER` is not `GL_NONE` and the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` for the color attachment point named by `GL_READ_BUFFER`.\n\n- `GL_FRAMEBUFFER_UNSUPPORTED` is returned if the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE` is returned if the value of `GL_RENDERBUFFER_SAMPLES` is not the same for all attached renderbuffers; if the value of `GL_TEXTURE_SAMPLES` is the not same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of `GL_RENDERBUFFER_SAMPLES` does not match the value of `GL_TEXTURE_SAMPLES`.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE` is also returned if the value of `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS` is not the same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS` is not `GL_TRUE` for all attached textures.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS` is returned if any framebuffer attachment is layered, and any populated attachment is not layered, or if all populated color attachments are not from textures of the same target.\n\nAdditionally, if an error occurs, zero is returned.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glCheckNamedFramebufferStatus` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCheckFramebufferStatus`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glCheckNamedFramebufferStatus` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glDeleteFramebuffers](gldeleteframebuffers.xhtml) [glBindFramebuffer](glbindframebuffer.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCheckFramebufferStatus.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCheckFramebufferStatus.xhtml)"
- name: glCheckNamedFramebufferStatus
  id: glcheckframebufferstatus.xhtml#glCheckNamedFramebufferStatus
  summary: Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus
  belongs_to: glCheckFramebufferStatus
  description: "`GLenum `**`glCheckNamedFramebufferStatus`**`(` GLuint `framebuffer`, GLenum `target``)`;\n\n## Parameters\n\n*`target`*\n\nSpecify the target to which the framebuffer is bound for `glCheckFramebufferStatus`, and the target against which framebuffer completeness of *`framebuffer`* is checked for `glCheckNamedFramebufferStatus`.\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glCheckNamedFramebufferStatus`\n\n## Description\n\n`glCheckFramebufferStatus` and `glCheckNamedFramebufferStatus` return the completeness status of a framebuffer object when treated as a read or draw framebuffer, depending on the value of *`target`*.\n\nFor `glCheckFramebufferStatus`, the framebuffer checked is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glCheckNamedFramebufferStatus`, *`framebuffer`* is zero or the name of the framebuffer object to check. If *`framebuffer`* is zero, then the status of the default read or draw framebuffer, as determined by *`target`*, is returned.\n\nThe return value is `GL_FRAMEBUFFER_COMPLETE` if the specified framebuffer is complete. Otherwise, the return value is determined as follows:\n\n- `GL_FRAMEBUFFER_UNDEFINED` is returned if the specified framebuffer is the default read or draw framebuffer, but the default framebuffer does not exist.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT` is returned if any of the framebuffer attachment points are framebuffer incomplete.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT` is returned if the framebuffer does not have at least one image attached to it.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER` is returned if the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` for any color attachment point(s) named by `GL_DRAW_BUFFERi`.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER` is returned if `GL_READ_BUFFER` is not `GL_NONE` and the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` for the color attachment point named by `GL_READ_BUFFER`.\n\n- `GL_FRAMEBUFFER_UNSUPPORTED` is returned if the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE` is returned if the value of `GL_RENDERBUFFER_SAMPLES` is not the same for all attached renderbuffers; if the value of `GL_TEXTURE_SAMPLES` is the not same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of `GL_RENDERBUFFER_SAMPLES` does not match the value of `GL_TEXTURE_SAMPLES`.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE` is also returned if the value of `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS` is not the same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of `GL_TEXTURE_FIXED_SAMPLE_LOCATIONS` is not `GL_TRUE` for all attached textures.\n\n- `GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS` is returned if any framebuffer attachment is layered, and any populated attachment is not layered, or if all populated color attachments are not from textures of the same target.\n\nAdditionally, if an error occurs, zero is returned.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glCheckNamedFramebufferStatus` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n## Version Support\n\n|                                 |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**    |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glCheckFramebufferStatus`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glCheckNamedFramebufferStatus` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glDeleteFramebuffers](gldeleteframebuffers.xhtml)[glBindFramebuffer](glbindframebuffer.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCheckFramebufferStatus.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCheckFramebufferStatus.xhtml)"
- name: glClampColor
  id: glclampcolor.xhtml
  summary: target Target for color clamping
  description: "## Name\n\nglClampColor — specify whether data read via [glReadPixels](glreadpixels.xhtml) should be clamped\n\n## C Specification\n\n`void `**`glClampColor`**`(` GLenum `target`, GLenum `clamp``)`;\n\n## Parameters\n\n *`target`*  \nTarget for color clamping. *`target`* must be `GL_CLAMP_READ_COLOR`.\n\n *`clamp`*  \nSpecifies whether to apply color clamping. *`clamp`* must be `GL_TRUE` or `GL_FALSE`.\n\n## Description\n\n`glClampColor` controls color clamping that is performed during [glReadPixels](glreadpixels.xhtml). *`target`* must be `GL_CLAMP_READ_COLOR`. If *`clamp`* is `GL_TRUE`, read color clamping is enabled; if *`clamp`* is `GL_FALSE`, read color clamping is disabled. If *`clamp`* is `GL_FIXED_ONLY`, read color clamping is enabled only if the selected read buffer has fixed point components and disabled otherwise.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_CLAMP_READ_COLOR`.\n\n`GL_INVALID_ENUM` is generated if *`clamp`* is not `GL_TRUE` or `GL_FALSE`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_CLAMP_READ_COLOR`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClampColor`              |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClampColor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClampColor.xhtml)"
- name: glClear
  id: glclear.xhtml
  summary: mask Bitwise OR of masks that indicate the buffers to be cleared
  description: "## Name\n\nglClear — clear buffers to preset values\n\n## C Specification\n\n`void `**`glClear`**`(` GLbitfield `mask``)`;\n\n## Parameters\n\n *`mask`*  \nBitwise OR of masks that indicate the buffers to be cleared. The three masks are `GL_COLOR_BUFFER_BIT`, `GL_DEPTH_BUFFER_BIT`, and `GL_STENCIL_BUFFER_BIT`.\n\n## Description\n\n`glClear` sets the bitplane area of the window to values previously selected by `glClearColor`, `glClearDepth`, and `glClearStencil`. Multiple color buffers can be cleared simultaneously by selecting more than one buffer at a time using [glDrawBuffer](gldrawbuffer.xhtml).\n\nThe pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of `glClear`. The scissor box bounds the cleared region. Alpha function, blend function, logical operation, stenciling, texture mapping, and depth-buffering are ignored by `glClear`.\n\n`glClear` takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared.\n\nThe values are as follows:\n\n `GL_COLOR_BUFFER_BIT`  \nIndicates the buffers currently enabled for color writing.\n\n `GL_DEPTH_BUFFER_BIT`  \nIndicates the depth buffer.\n\n `GL_STENCIL_BUFFER_BIT`  \nIndicates the stencil buffer.\n\nThe value to which each buffer is cleared depends on the setting of the clear value for that buffer.\n\n## Notes\n\nIf a buffer is not present, then a `glClear` directed at that buffer has no effect.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if any bit other than the three defined bits is set in *`mask`*.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_CLEAR_VALUE`\n\n[glGet](glget.xhtml) with argument `GL_COLOR_CLEAR_VALUE`\n\n[glGet](glget.xhtml) with argument `GL_STENCIL_CLEAR_VALUE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClear`                   |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n`glClearColor`, `glClearDepth`, `glClearStencil`, [glColorMask](glcolormask.xhtml), [glDepthMask](gldepthmask.xhtml), [glDrawBuffer](gldrawbuffer.xhtml), [glScissor](glscissor.xhtml), [glStencilMask](glstencilmask.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClear.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClear.xhtml)"
- name: glClearBuffer
  id: glclearbuffer.xhtml
  summary: buffer Specify the buffer to clear
  description: "## Name\n\nglClearBuffer — clear individual buffers of a framebuffer\n\n## C Specification\n\n`void `**`glClearBufferiv`**`(` GLenum `buffer`, GLint `drawbuffer`, const GLint \\* `value``)`;\n\n`void `**`glClearBufferuiv`**`(` GLenum `buffer`, GLint `drawbuffer`, const GLuint \\* `value``)`;\n\n`void `**`glClearBufferfv`**`(` GLenum `buffer`, GLint `drawbuffer`, const GLfloat \\* `value``)`;\n\n`void `**`glClearBufferfi`**`(` GLenum `buffer`, GLint `drawbuffer`, GLfloat `depth`, GLint `stencil``)`;\n\n`void `**`glClearNamedFramebufferiv`**`(` GLuint `framebuffer`, GLenum `buffer`, GLint `drawbuffer`, const GLint \\*`value``)`;\n\n`void `**`glClearNamedFramebufferuiv`**`(` GLuint `framebuffer`, GLenum `buffer`, GLint `drawbuffer`, const GLuint \\*`value``)`;\n\n`void `**`glClearNamedFramebufferfv`**`(` GLuint `framebuffer`, GLenum `buffer`, GLint `drawbuffer`, const GLfloat \\*`value``)`;\n\n`void `**`glClearNamedFramebufferfi`**`(` GLuint `framebuffer`, GLenum `buffer`, GLint `drawbuffer`, GLfloat `depth`, GLint `stencil``)`;\n\n## Parameters\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glClearNamedFramebuffer*`.\n\n *`buffer`*  \nSpecify the buffer to clear.\n\n *`drawbuffer`*  \nSpecify a particular draw buffer to clear.\n\n *`value`*  \nA pointer to the value or values to clear the buffer to.\n\n *`depth`*  \nThe value to clear the depth buffer to.\n\n *`stencil`*  \nThe value to clear the stencil buffer to.\n\n## Description\n\nThese commands clear a specified buffer of a framebuffer to specified value(s). For `glClearBuffer*`, the framebuffer is the currently bound draw framebuffer object. For `glClearNamedFramebuffer*`, *`framebuffer`* is zero, indicating the default draw framebuffer, or the name of a framebuffer object.\n\n*`buffer`* and *`drawbuffer`* identify the buffer to clear.\n\nIf *`buffer`* is `GL_COLOR`, a particular draw buffer `GL_DRAW_BUFFER`*`i`* is specified by passing *`i`* as *`drawbuffer`*, and *`value`* points to a four-element vector specifying the R, G, B and A color to clear that draw buffer to. If the value of `GL_DRAW_BUFFER`*`i`* is `GL_NONE`, the command has no effect. Otherwise, the value of `GL_DRAW_BUFFER`*`i`* identifies one or more color buffers, each of which is cleared to the same value. Clamping and type conversion for fixed-point color buffers are performed in the same fashion as for [glClearColor](glclearcolor.xhtml). The `*fv`, `*iv` and `*uiv` forms of these commands should be used to clear fixed- and floating-point, signed integer, and unsigned integer color buffers respectively.\n\nIf *`buffer`* is `GL_DEPTH`, *`drawbuffer`* must be zero, and *`value`* points to a single value to clear the depth buffer to. Clamping and type conversion for fixed-point depth buffers are performed in the same fashion as for [glClearDepth](glcleardepth.xhtml). Only the `*fv` forms of these commands should be used to clear depth buffers; other forms do not accept a *`buffer`* of `GL_DEPTH`.\n\nIf *`buffer`* is `GL_STENCIL`, *`drawbuffer`* must be zero, and *`value`* points to a single value to clear the stencil buffer to. Masking is performed in the same fashion as for [glClearStencil](glclearstencil.xhtml). Only the `*iv` forms of these commands should be used to clear stencil buffers; be used to clear stencil buffers; other forms do not accept a *`buffer`* of `GL_STENCIL`.\n\n`glClearBufferfi` and `glClearNamedFramebufferfi` are used to clear the depth and stencil buffers simultaneously. *`buffer`* must be `GL_DEPTH_STENCIL` and *`drawbuffer`* must be zero. *`depth`* and *`stencil`* are the values to clear the depth and stencil buffers to, respectively. Clamping and type conversion of *`depth`* for fixed-point depth buffers are performed in the same fashion as for [glClearDepth](glcleardepth.xhtml). Masking of *`stencil`* for stencil buffers is performed in the same fashion as for [glClearStencil](glclearstencil.xhtml). These commands are equivalent to clearing the depth and stencil buffers separately, but may be faster when a buffer of internal format `GL_DEPTH_STENCIL` is being cleared. The same per-fragment and masking operations defined for `glClear` are applied.\n\nThe result of these commands is undefined if no conversion between the type of the specified *`value`* and the type of the buffer being cleared is defined (for example, if `glClearBufferiv` is called for a fixed- or floating-point buffer, or if `glClearBufferfv` is called for a signed or unsigned integer buffer). This is not an error.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glClearNamedFramebuffer*` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated by `glClearBufferiv` and `glClearNamedFramebufferiv` *`buffer`* is not `GL_COLOR` or `GL_STENCIL`.\n\n`GL_INVALID_ENUM` is generated by `glClearBufferuiv` and `glClearNamedFramebufferuiv` *`buffer`* is not `GL_COLOR`.\n\n`GL_INVALID_ENUM` is generated by `glClearBufferfv` and `glClearNamedFramebufferfv` *`buffer`* is not `GL_COLOR` or `GL_DEPTH`.\n\n`GL_INVALID_ENUM` is generated by `glClearBufferfi` and `glClearNamedFramebufferfi` *`buffer`* is not `GL_DEPTH_STENCIL`.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is `GL_COLOR` *`drawbuffer`* is negative, or greater than the value of `GL_MAX_DRAW_BUFFERS` minus one.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is `GL_DEPTH`, `GL_STENCIL` or `GL_DEPTH_STENCIL` and *`drawbuffer`* is not zero.\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClearBufferfi`            |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glClearBufferfv`            |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glClearBufferiv`            |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glClearBufferuiv`           |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glClearNamedFramebufferfi`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glClearNamedFramebufferfv`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glClearNamedFramebufferiv`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glClearNamedFramebufferuiv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glClearColor](glclearcolor.xhtml), [glClearDepth](glcleardepth.xhtml), [glClearStencil](glclearstencil.xhtml), [glClear](glclear.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBuffer.xhtml)"
- name: glClearBufferData
  id: glclearbufferdata.xhtml
  summary: buffer Specifies the name of the buffer object for glClearNamedBufferData
  description: "## Name\n\nglClearBufferData, glClearNamedBufferData — fill a buffer object's data store with a fixed value\n\n## C Specification\n\n`void `**`glClearBufferData`**`(` GLenum `target`, GLenum `internalformat`, GLenum `format`, GLenum `type`, const void \\* `data``)`;\n\n`void `**`glClearNamedBufferData`**`(` GLuint `buffer`, GLenum `internalformat`, GLenum `format`, GLenum `type`, const void \\*`data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glClearBufferData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glClearNamedBufferData`.\n\n *`internalformat`*  \nThe internal format with which the data will be stored in the buffer object.\n\n *`format`*  \nThe format of the data in memory addressed by *`data`*.\n\n *`type`*  \nThe type of the data in memory addressed by *`data`*.\n\n *`data`*  \nThe address of a memory location storing the data to be replicated into the buffer's data store.\n\n## Description\n\n`glClearBufferData` and `glClearNamedBufferData` fill the entirety of a buffer object's data store with data from client memory.\n\nData, initially supplied in a format specified by *`format`* in data type *`type`* is read from the memory address given by *`data`* and converted into the internal representation given by *`internalformat`*, which must be one of the following sized internal formats:\n\n|                             |                 |                  |            |  **Component**  |     |     |     |\n|:----------------------------|:----------------|:-----------------|:-----------|:---------------:|:---:|:---:|:---:|\n|  **Sized Internal Format**  |  **Base Type**  |  **Components**  |  **Norm**  |        0        |  1  |  2  |  3  |\n| `GL_R8`                     | ubyte           | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16`                    | ushort          | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16F`                   | half            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32F`                   | float           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8I`                    | byte            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16I`                   | short           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32I`                   | int             | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8UI`                   | ubyte           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16UI`                  | ushort          | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32UI`                  | uint            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_RG8`                    | ubyte           | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16`                   | ushort          | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16F`                  | half            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32F`                  | float           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8I`                   | byte            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16I`                  | short           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32I`                  | int             | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8UI`                  | ubyte           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16UI`                 | ushort          | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32UI`                 | uint            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RGB32F`                 | float           | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32I`                 | int             | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32UI`                | uint            | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGBA8`                  | uint            | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16`                 | short           | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16F`                | half            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32F`                | float           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8I`                 | byte            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16I`                | short           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32I`                | int             | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8UI`                | ubyte           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16UI`               | ushort          | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32UI`               | uint            | 4                | NO         |        R        |  G  |  B  |  A  |\n\nThis converted data is then replicated throughout the buffer object's data store. If *`data`* is NULL, then the buffer's data store is filled with zeros.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glClearBufferData` if *`target`* is not one of the generic buffer binding targets.\n\n`GL_INVALID_VALUE` is generated by `glClearBufferData` if no buffer is bound *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glClearNamedBufferData` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the valid sized internal formats listed in the table above.\n\n`GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *`access`* flags.\n\n`GL_INVALID_VALUE` is generated if *`format`* is not a valid format, or *`type`* is not a valid type.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClearBufferData`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glClearNamedBufferData`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glClearBufferSubData](glclearbuffersubdata.xhtml).\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBufferData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBufferData.xhtml)"
- name: glClearBufferfi
  id: glclearbuffer.xhtml#glClearBufferfi
  summary: null
  belongs_to: glClearBuffer
  description: '`void `**`glClearBufferfi`**`(` GLenum `buffer`, GLint `drawbuffer`, GLfloat `depth`, GLint `stencil``)`;'
- name: glClearBufferfv
  id: glclearbuffer.xhtml#glClearBufferfv
  summary: null
  belongs_to: glClearBuffer
  description: '`void `**`glClearBufferfv`**`(` GLenum `buffer`, GLint `drawbuffer`, const GLfloat \* `value``)`;'
- name: glClearBufferiv
  id: glclearbuffer.xhtml#glClearBufferiv
  summary: null
  belongs_to: glClearBuffer
  description: '`void `**`glClearBufferiv`**`(` GLenum `buffer`, GLint `drawbuffer`, const GLint \* `value``)`;'
- name: glClearBufferSubData
  id: glclearbuffersubdata.xhtml
  summary: buffer Specifies the name of the buffer object for glClearNamedBufferSubData
  description: "## Name\n\nglClearBufferSubData, glClearNamedBufferSubData — fill all or part of buffer object's data store with a fixed value\n\n## C Specification\n\n`void `**`glClearBufferSubData`**`(` GLenum `target`, GLenum `internalformat`, GLintptr `offset`, GLsizeiptr `size`, GLenum `format`, GLenum `type`, const void \\* `data``)`;\n\n`void `**`glClearNamedBufferSubData`**`(` GLuint `buffer`, GLenum `internalformat`, GLintptr `offset`, GLsizeiptr `size`, GLenum `format`, GLenum `type`, const void \\*`data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glClearBufferSubData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glClearNamedBufferSubData`.\n\n *`internalformat`*  \nThe internal format with which the data will be stored in the buffer object.\n\n *`offset`*  \nThe offset in basic machine units into the buffer object's data store at which to start filling.\n\n *`size`*  \nThe size in basic machine units of the range of the data store to fill.\n\n *`format`*  \nThe format of the data in memory addressed by *`data`*.\n\n *`type`*  \nThe type of the data in memory addressed by *`data`*.\n\n *`data`*  \nThe address of a memory location storing the data to be replicated into the buffer's data store.\n\n## Description\n\n`glClearBufferSubData` and `glClearNamedBufferSubData` fill a specified region of a buffer object's data store with data from client memory.\n\n*`offset`* and *`size`* specify the extent of the region within the data store of the buffer object to fill with data. Data, initially supplied in a format specified by *`format`* in data type *`type`* is read from the memory address given by *`data`* and converted into the internal representation given by *`internalformat`*, which must be one of the following sized internal formats:\n\n|                             |                 |                  |            |  **Component**  |     |     |     |\n|:----------------------------|:----------------|:-----------------|:-----------|:---------------:|:---:|:---:|:---:|\n|  **Sized Internal Format**  |  **Base Type**  |  **Components**  |  **Norm**  |        0        |  1  |  2  |  3  |\n| `GL_R8`                     | ubyte           | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16`                    | ushort          | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16F`                   | half            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32F`                   | float           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8I`                    | byte            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16I`                   | short           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32I`                   | int             | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8UI`                   | ubyte           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16UI`                  | ushort          | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32UI`                  | uint            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_RG8`                    | ubyte           | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16`                   | ushort          | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16F`                  | half            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32F`                  | float           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8I`                   | byte            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16I`                  | short           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32I`                  | int             | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8UI`                  | ubyte           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16UI`                 | ushort          | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32UI`                 | uint            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RGB32F`                 | float           | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32I`                 | int             | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32UI`                | uint            | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGBA8`                  | uint            | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16`                 | short           | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16F`                | half            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32F`                | float           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8I`                 | byte            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16I`                | short           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32I`                | int             | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8UI`                | ubyte           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16UI`               | ushort          | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32UI`               | uint            | 4                | NO         |        R        |  G  |  B  |  A  |\n\nThis converted data is then replicated throughout the specified region of the buffer object's data store. If *`data`* is NULL, then the subrange of the buffer's data store is filled with zeros.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glClearBufferSubData` if *`target`* is not one of the generic buffer binding targets.\n\n`GL_INVALID_VALUE` is generated by `glClearBufferSubData` if no buffer is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glClearNamedBufferSubData` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the valid sized internal formats listed in the table above.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`range`* are not multiples of the number of basic machine units per-element for the internal format specified by *`internalformat`*. This value may be computed by multiplying the number of components for *`internalformat`* from the table by the size of the base type from the table.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`size`* is negative, or if $offset + size$ is greater than the value of `GL_BUFFER_SIZE` for the buffer object.\n\n`GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *`access`* flags.\n\n`GL_INVALID_VALUE` is generated if *`format`* is not a valid format, or *`type`* is not a valid type.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClearBufferSubData`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glClearNamedBufferSubData` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glClearBufferData](glclearbufferdata.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBufferSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBufferSubData.xhtml)"
- name: glClearBufferuiv
  id: glclearbuffer.xhtml#glClearBufferuiv
  summary: null
  belongs_to: glClearBuffer
  description: '`void `**`glClearBufferuiv`**`(` GLenum `buffer`, GLint `drawbuffer`, const GLuint \* `value``)`;'
- name: glClearColor
  id: glclearcolor.xhtml
  summary: red, green, blue, alpha Specify the red, green, blue, and alpha values used when the color buffers are cleared
  description: "## Name\n\nglClearColor — specify clear values for the color buffers\n\n## C Specification\n\n`void `**`glClearColor`**`(` GLfloat `red`, GLfloat `green`, GLfloat `blue`, GLfloat `alpha``)`;\n\n## Parameters\n\n*`red`*,  *`green`*,  *`blue`*,   *`alpha`*  \nSpecify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.\n\n## Description\n\n`glClearColor` specifies the red, green, blue, and alpha values used by [glClear](glclear.xhtml) to clear the color buffers. Values specified by `glClearColor` are clamped to the range \\[0, 1\\].\n\n## Notes\n\nThe type of the *`red`*, *`green`*, *`blue`*, and *`alpha`* parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_COLOR_CLEAR_VALUE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClearColor`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glClear](glclear.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearColor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearColor.xhtml)"
- name: glClearDepth
  id: glcleardepth.xhtml
  summary: depth Specifies the depth value used when the depth buffer is cleared
  description: "## Name\n\nglClearDepth — specify the clear value for the depth buffer\n\n## C Specification\n\n`void `**`glClearDepth`**`(` GLdouble `depth``)`;\n\n`void `**`glClearDepthf`**`(` GLfloat `depth``)`;\n\n## Parameters\n\n *`depth`*  \nSpecifies the depth value used when the depth buffer is cleared. The initial value is 1.\n\n## Description\n\n`glClearDepth` specifies the depth value used by [glClear](glclear.xhtml) to clear the depth buffer. Values specified by `glClearDepth` are clamped to the range \\[0, 1\\].\n\n## Notes\n\nThe type of the *`depth`* parameter was changed from GLclampf to GLfloat for `glClearDepthf` and from GLclampd to GLdouble for `glClearDepth`. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_CLEAR_VALUE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClearDepth`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glClearDepthf`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glClear](glclear.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearDepth.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearDepth.xhtml)"
- name: glClearDepthf
  id: glcleardepth.xhtml#glClearDepthf
  summary: Specifies the depth value used when the depth buffer is cleared
  belongs_to: glClearDepth
  description: "`void `**`glClearDepthf`**`(` GLfloat `depth``)`;\n\n## Parameters\n\n*`depth`*\n\nSpecifies the depth value used when the depth buffer is cleared. The initial value is 1.\n\n## Description\n\n`glClearDepth` specifies the depth value used by [glClear](glclear.xhtml) to clear the depth buffer. Values specified by `glClearDepth` are clamped to the range \\[0, 1\\].\n\n## Notes\n\nThe type of the *`depth`* parameter was changed from GLclampf to GLfloat for `glClearDepthf` and from GLclampd to GLdouble for `glClearDepth`. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_CLEAR_VALUE`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glClearDepth`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glClearDepthf`               |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glClear](glclear.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearDepth.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearDepth.xhtml)"
- name: glClearNamedBufferData
  id: glclearbufferdata.xhtml#glClearNamedBufferData
  summary: Specifies the name of the buffer object for glClearNamedBufferData
  belongs_to: glClearBufferData
  description: "`void `**`glClearNamedBufferData`**`(` GLuint `buffer`, GLenum `internalformat`, GLenum `format`, GLenum `type`, const void \\*`data``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glClearBufferData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glClearNamedBufferData`.\n\n*`internalformat`*\n\nThe internal format with which the data will be stored in the buffer object.\n\n*`format`*\n\nThe format of the data in memory addressed by *`data`*.\n\n*`type`*\n\nThe type of the data in memory addressed by *`data`*.\n\n*`data`*\n\nThe address of a memory location storing the data to be replicated into the buffer's data store.\n\n## Description\n\n`glClearBufferData` and `glClearNamedBufferData` fill the entirety of a buffer object's data store with data from client memory.\n\nData, initially supplied in a format specified by *`format`* in data type *`type`* is read from the memory address given by *`data`* and converted into the internal representation given by *`internalformat`*, which must be one of the following sized internal formats:\n\n|                             |                 |                  |            |  **Component**  |     |     |     |\n|:----------------------------|:----------------|:-----------------|:-----------|:---------------:|:---:|:---:|:---:|\n|  **Sized Internal Format**  |  **Base Type**  |  **Components**  |  **Norm**  |        0        |  1  |  2  |  3  |\n| `GL_R8`                     | ubyte           | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16`                    | ushort          | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16F`                   | half            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32F`                   | float           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8I`                    | byte            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16I`                   | short           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32I`                   | int             | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8UI`                   | ubyte           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16UI`                  | ushort          | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32UI`                  | uint            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_RG8`                    | ubyte           | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16`                   | ushort          | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16F`                  | half            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32F`                  | float           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8I`                   | byte            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16I`                  | short           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32I`                  | int             | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8UI`                  | ubyte           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16UI`                 | ushort          | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32UI`                 | uint            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RGB32F`                 | float           | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32I`                 | int             | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32UI`                | uint            | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGBA8`                  | uint            | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16`                 | short           | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16F`                | half            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32F`                | float           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8I`                 | byte            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16I`                | short           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32I`                | int             | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8UI`                | ubyte           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16UI`               | ushort          | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32UI`               | uint            | 4                | NO         |        R        |  G  |  B  |  A  |\n\nThis converted data is then replicated throughout the buffer object's data store. If *`data`* is NULL, then the buffer's data store is filled with zeros.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glClearBufferData` if *`target`* is not one of the generic buffer binding targets.\n\n`GL_INVALID_VALUE` is generated by `glClearBufferData` if no buffer is bound *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glClearNamedBufferData` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the valid sized internal formats listed in the table above.\n\n`GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *`access`* flags.\n\n`GL_INVALID_VALUE` is generated if *`format`* is not a valid format, or *`type`* is not a valid type.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glClearBufferData`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glClearNamedBufferData`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glClearBufferSubData](glclearbuffersubdata.xhtml).\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBufferData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBufferData.xhtml)"
- name: glClearNamedBufferSubData
  id: glclearbuffersubdata.xhtml#glClearNamedBufferSubData
  summary: Specifies the name of the buffer object for glClearNamedBufferSubData
  belongs_to: glClearBufferSubData
  description: "`void `**`glClearNamedBufferSubData`**`(` GLuint `buffer`, GLenum `internalformat`, GLintptr `offset`, GLsizeiptr `size`, GLenum `format`, GLenum `type`, const void \\*`data``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glClearBufferSubData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glClearNamedBufferSubData`.\n\n*`internalformat`*\n\nThe internal format with which the data will be stored in the buffer object.\n\n*`offset`*\n\nThe offset in basic machine units into the buffer object's data store at which to start filling.\n\n*`size`*\n\nThe size in basic machine units of the range of the data store to fill.\n\n*`format`*\n\nThe format of the data in memory addressed by *`data`*.\n\n*`type`*\n\nThe type of the data in memory addressed by *`data`*.\n\n*`data`*\n\nThe address of a memory location storing the data to be replicated into the buffer's data store.\n\n## Description\n\n`glClearBufferSubData` and `glClearNamedBufferSubData` fill a specified region of a buffer object's data store with data from client memory.\n\n*`offset`* and *`size`* specify the extent of the region within the data store of the buffer object to fill with data. Data, initially supplied in a format specified by *`format`* in data type *`type`* is read from the memory address given by *`data`* and converted into the internal representation given by *`internalformat`*, which must be one of the following sized internal formats:\n\n|                             |                 |                  |            |  **Component**  |     |     |     |\n|:----------------------------|:----------------|:-----------------|:-----------|:---------------:|:---:|:---:|:---:|\n|  **Sized Internal Format**  |  **Base Type**  |  **Components**  |  **Norm**  |        0        |  1  |  2  |  3  |\n| `GL_R8`                     | ubyte           | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16`                    | ushort          | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16F`                   | half            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32F`                   | float           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8I`                    | byte            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16I`                   | short           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32I`                   | int             | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8UI`                   | ubyte           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16UI`                  | ushort          | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32UI`                  | uint            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_RG8`                    | ubyte           | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16`                   | ushort          | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16F`                  | half            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32F`                  | float           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8I`                   | byte            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16I`                  | short           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32I`                  | int             | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8UI`                  | ubyte           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16UI`                 | ushort          | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32UI`                 | uint            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RGB32F`                 | float           | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32I`                 | int             | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32UI`                | uint            | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGBA8`                  | uint            | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16`                 | short           | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16F`                | half            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32F`                | float           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8I`                 | byte            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16I`                | short           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32I`                | int             | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8UI`                | ubyte           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16UI`               | ushort          | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32UI`               | uint            | 4                | NO         |        R        |  G  |  B  |  A  |\n\nThis converted data is then replicated throughout the specified region of the buffer object's data store. If *`data`* is NULL, then the subrange of the buffer's data store is filled with zeros.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glClearBufferSubData` if *`target`* is not one of the generic buffer binding targets.\n\n`GL_INVALID_VALUE` is generated by `glClearBufferSubData` if no buffer is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glClearNamedBufferSubData` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the valid sized internal formats listed in the table above.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`range`* are not multiples of the number of basic machine units per-element for the internal format specified by *`internalformat`*. This value may be computed by multiplying the number of components for *`internalformat`* from the table by the size of the base type from the table.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`size`* is negative, or if $offset + size$ is greater than the value of `GL_BUFFER_SIZE` for the buffer object.\n\n`GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *`access`* flags.\n\n`GL_INVALID_VALUE` is generated if *`format`* is not a valid format, or *`type`* is not a valid type.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glClearBufferSubData`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glClearNamedBufferSubData`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glClearBufferData](glclearbufferdata.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBufferSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBufferSubData.xhtml)"
- name: glClearNamedFramebufferfi
  id: glclearbuffer.xhtml#glClearNamedFramebufferfi
  summary: Specify the buffer to clear
  belongs_to: glClearBuffer
  description: "`void `**`glClearNamedFramebufferfi`**`(` GLuint `framebuffer`, GLenum `buffer`, GLint `drawbuffer`, GLfloat `depth`, GLint `stencil``)`;\n\n## Parameters\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glClearNamedFramebuffer*`.\n\n*`buffer`*\n\nSpecify the buffer to clear.\n\n*`drawbuffer`*\n\nSpecify a particular draw buffer to clear.\n\n*`value`*\n\nA pointer to the value or values to clear the buffer to.\n\n*`depth`*\n\nThe value to clear the depth buffer to.\n\n*`stencil`*\n\nThe value to clear the stencil buffer to.\n\n## Description\n\nThese commands clear a specified buffer of a framebuffer to specified value(s). For `glClearBuffer*`, the framebuffer is the currently bound draw framebuffer object. For `glClearNamedFramebuffer*`, *`framebuffer`* is zero, indicating the default draw framebuffer, or the name of a framebuffer object.\n\n*`buffer`* and *`drawbuffer`* identify the buffer to clear.\n\nIf *`buffer`* is `GL_COLOR`, a particular draw buffer `GL_DRAW_BUFFER`*`i`* is specified by passing *`i`* as *`drawbuffer`*, and *`value`* points to a four-element vector specifying the R, G, B and A color to clear that draw buffer to. If the value of `GL_DRAW_BUFFER`*`i`* is `GL_NONE`, the command has no effect. Otherwise, the value of `GL_DRAW_BUFFER`*`i`* identifies one or more color buffers, each of which is cleared to the same value. Clamping and type conversion for fixed-point color buffers are performed in the same fashion as for [glClearColor](glclearcolor.xhtml). The `*fv`, `*iv` and `*uiv` forms of these commands should be used to clear fixed- and floating-point, signed integer, and unsigned integer color buffers respectively.\n\nIf *`buffer`* is `GL_DEPTH`, *`drawbuffer`* must be zero, and *`value`* points to a single value to clear the depth buffer to. Clamping and type conversion for fixed-point depth buffers are performed in the same fashion as for [glClearDepth](glcleardepth.xhtml). Only the `*fv` forms of these commands should be used to clear depth buffers; other forms do not accept a *`buffer`* of `GL_DEPTH`.\n\nIf *`buffer`* is `GL_STENCIL`, *`drawbuffer`* must be zero, and *`value`* points to a single value to clear the stencil buffer to. Masking is performed in the same fashion as for [glClearStencil](glclearstencil.xhtml). Only the `*iv` forms of these commands should be used to clear stencil buffers; be used to clear stencil buffers; other forms do not accept a *`buffer`* of `GL_STENCIL`.\n\n`glClearBufferfi` and `glClearNamedFramebufferfi` are used to clear the depth and stencil buffers simultaneously. *`buffer`* must be `GL_DEPTH_STENCIL` and *`drawbuffer`* must be zero. *`depth`* and *`stencil`* are the values to clear the depth and stencil buffers to, respectively. Clamping and type conversion of *`depth`* for fixed-point depth buffers are performed in the same fashion as for [glClearDepth](glcleardepth.xhtml). Masking of *`stencil`* for stencil buffers is performed in the same fashion as for [glClearStencil](glclearstencil.xhtml). These commands are equivalent to clearing the depth and stencil buffers separately, but may be faster when a buffer of internal format `GL_DEPTH_STENCIL` is being cleared. The same per-fragment and masking operations defined for `glClear` are applied.\n\nThe result of these commands is undefined if no conversion between the type of the specified *`value`* and the type of the buffer being cleared is defined (for example, if `glClearBufferiv` is called for a fixed- or floating-point buffer, or if `glClearBufferfv` is called for a signed or unsigned integer buffer). This is not an error.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glClearNamedFramebuffer*` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated by `glClearBufferiv` and `glClearNamedFramebufferiv` *`buffer`* is not `GL_COLOR` or `GL_STENCIL`.\n\n`GL_INVALID_ENUM` is generated by `glClearBufferuiv` and `glClearNamedFramebufferuiv` *`buffer`* is not `GL_COLOR`.\n\n`GL_INVALID_ENUM` is generated by `glClearBufferfv` and `glClearNamedFramebufferfv` *`buffer`* is not `GL_COLOR` or `GL_DEPTH`.\n\n`GL_INVALID_ENUM` is generated by `glClearBufferfi` and `glClearNamedFramebufferfi` *`buffer`* is not `GL_DEPTH_STENCIL`.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is `GL_COLOR` *`drawbuffer`* is negative, or greater than the value of `GL_MAX_DRAW_BUFFERS` minus one.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is `GL_DEPTH`, `GL_STENCIL` or `GL_DEPTH_STENCIL` and *`drawbuffer`* is not zero.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glClearBufferfi`             |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glClearBufferfv`             |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glClearBufferiv`             |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glClearBufferuiv`            |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glClearNamedFramebufferfi`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glClearNamedFramebufferfv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glClearNamedFramebufferiv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glClearNamedFramebufferuiv`  |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glClearColor](glclearcolor.xhtml), [glClearDepth](glcleardepth.xhtml), [glClearStencil](glclearstencil.xhtml), [glClear](glclear.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearBuffer.xhtml)"
- name: glClearNamedFramebufferfv
  id: glclearbuffer.xhtml#glClearNamedFramebufferfv
  summary: null
  belongs_to: glClearBuffer
  description: '`void `**`glClearNamedFramebufferfv`**`(` GLuint `framebuffer`, GLenum `buffer`, GLint `drawbuffer`, const GLfloat \*`value``)`;'
- name: glClearNamedFramebufferiv
  id: glclearbuffer.xhtml#glClearNamedFramebufferiv
  summary: null
  belongs_to: glClearBuffer
  description: '`void `**`glClearNamedFramebufferiv`**`(` GLuint `framebuffer`, GLenum `buffer`, GLint `drawbuffer`, const GLint \*`value``)`;'
- name: glClearNamedFramebufferuiv
  id: glclearbuffer.xhtml#glClearNamedFramebufferuiv
  summary: null
  belongs_to: glClearBuffer
  description: '`void `**`glClearNamedFramebufferuiv`**`(` GLuint `framebuffer`, GLenum `buffer`, GLint `drawbuffer`, const GLuint \*`value``)`;'
- name: glClearStencil
  id: glclearstencil.xhtml
  summary: s Specifies the index used when the stencil buffer is cleared
  description: "## Name\n\nglClearStencil — specify the clear value for the stencil buffer\n\n## C Specification\n\n`void `**`glClearStencil`**`(` GLint `s``)`;\n\n## Parameters\n\n *`s`*  \nSpecifies the index used when the stencil buffer is cleared. The initial value is 0.\n\n## Description\n\n`glClearStencil` specifies the index used by [glClear](glclear.xhtml) to clear the stencil buffer. *`s`* is masked with 2^(*m*) − 1, where *m* is the number of bits in the stencil buffer.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_STENCIL_CLEAR_VALUE`\n\n[glGet](glget.xhtml) with argument `GL_STENCIL_BITS`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClearStencil`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glClear](glclear.xhtml), [glStencilFunc](glstencilfunc.xhtml), [glStencilFuncSeparate](glstencilfuncseparate.xhtml), [glStencilMask](glstencilmask.xhtml), [glStencilMaskSeparate](glstencilmaskseparate.xhtml), [glStencilOp](glstencilop.xhtml), [glStencilOpSeparate](glstencilopseparate.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearStencil.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearStencil.xhtml)"
- name: glClearTexImage
  id: glclearteximage.xhtml
  summary: texture The name of an existing texture object containing the image to be cleared
  description: "## Name\n\nglClearTexImage — fills all a texture image with a constant value\n\n## C Specification\n\n`void `**`glClearTexImage`**`(` GLuint `texture`, GLint `level`, GLenum `format`, GLenum `type`, const void \\* `data``)`;\n\n## Parameters\n\n *`texture`*  \nThe name of an existing texture object containing the image to be cleared.\n\n *`level`*  \nThe level of *`texture`* containing the region to be cleared.\n\n *`format`*  \nThe format of the data whose address in memory is given by *`data`*.\n\n *`type`*  \nThe type of the data whose address in memory is given by *`data`*.\n\n *`data`*  \nThe address in memory of the data to be used to clear the specified region.\n\n## Description\n\n`glClearTexImage` fills all an image contained in a texture with an application supplied value. *`texture`* must be the name of an existing texture. Further, *`texture`* may not be the name of a buffer texture, nor may its internal format be compressed.\n\n*`format`* and *`type`* specify the format and type of the source data and are interpreted as they are for [glTexImage3D](glteximage3d.xhtml). Textures with a base internal format of `GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL` require depth component, stencil, or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures with integer internal formats require integer data.\n\n*`data`* is a pointer to an array of between one and four components of texel data that will be used as the source for the constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was specified when the level was defined by any of the `glTexImage*`, `glTexStorage*` or `glCopyTexImage*` commands), and then used to fill the specified range of the destination texture level. If *`data`* is `NULL`, then the pointer is ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are cleared to the value specified by data.\n\n## Notes\n\n`glClearTexImage` is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`texture`* is zero or not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated if *`texture`* is a buffer texture.\n\n`GL_INVALID_OPERATION` is generated if *`texture`* has a compressed internal format.\n\n`GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_COMPONENT` and *`format`* is not `GL_DEPTH_COMPONENT`.\n\n`GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_STENCIL` and *`format`* is not `GL_DEPTH_STENCIL`.\n\n`GL_INVALID_OPERATION` is generated if the base internal format is `GL_STENCIL_INDEX` and *`format`* is not `GL_STENCIL_INDEX`.\n\n`GL_INVALID_OPERATION` is generated if the base internal format is `GL_RGBA` and *`format`* is `GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL`.\n\n`GL_INVALID_OPERATION` is generated if the internal format is integer and *`format`* does not specify integer data.\n\n`GL_INVALID_OPERATION` is generated if the internal format is not integer and *`format`* specifies integer data.\n\n`GL_INVALID_OPERATION` is generated if the image array identified by *`level`* has not previously been defined by a call to `glTexImage*` or `glTexStorage*`.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml), [glGetInternalformat](glgetinternalformat.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClearTexImage`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |\n\n## See Also\n\n[glClearTexSubImage](glcleartexsubimage.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearTexImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearTexImage.xhtml)"
- name: glClearTexSubImage
  id: glcleartexsubimage.xhtml
  summary: texture The name of an existing texture object containing the image to be cleared
  description: "## Name\n\nglClearTexSubImage — fills all or part of a texture image with a constant value\n\n## C Specification\n\n`void `**`glClearTexSubImage`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLenum `format`, GLenum `type`, const void \\* `data``)`;\n\n## Parameters\n\n *`texture`*  \nThe name of an existing texture object containing the image to be cleared.\n\n *`level`*  \nThe level of *`texture`* containing the region to be cleared.\n\n *`xoffset`*  \nThe coordinate of the left edge of the region to be cleared.\n\n *`yoffset`*  \nThe coordinate of the lower edge of the region to be cleared.\n\n *`zoffset`*  \nThe coordinate of the front of the region to be cleared.\n\n *`width`*  \nThe width of the region to be cleared.\n\n *`height`*  \nThe height of the region to be cleared.\n\n *`depth`*  \nThe depth of the region to be cleared.\n\n *`format`*  \nThe format of the data whose address in memory is given by *`data`*.\n\n *`type`*  \nThe type of the data whose address in memory is given by *`data`*.\n\n *`data`*  \nThe address in memory of the data to be used to clear the specified region.\n\n## Description\n\n`glClearTexSubImage` fills all or part of an image contained in a texture with an application supplied value. *`texture`* must be the name of an existing texture. Further, *`texture`* may not be the name of a buffer texture, nor may its internal format be compressed.\n\nArguments *`xoffset`*, *`yoffset`*, and *`zoffset`* specify the lower left texel coordinates of a width-wide by height-high by depth-deep rectangular subregion of the texel array.\n\nFor one-dimensional array textures, *`yoffset`* is interpreted as the first layer to be cleared and *`height`* is the number of layers to clear. For two-dimensional array textures, *`zoffset`* is interpreted as the first layer to be cleared and *`depth`* is the number of layers to clear. Cube map textures are treated as an array of six slices in the z-dimension, where the value of *`zoffset`* is interpreted as specifying the cube map face for the corresponding layer and *`depth`* is the number of faces to clear. For cube map array textures, *`zoffset`* is the first layer-face to clear, and *`depth`* is the number of layer-faces to clear. Each layer-face is translated into an array layer and a cube map face as described in the OpenGL Specification.\n\nNegative values of *`xoffset`*, *`yoffset`*, and *`zoffset`* correspond to the coordinates of border texels. Taking *w**s*, *h**s*, *d**s*, *w**b*, *h**b*, and *d**b* to be the specified *`width`*, *`height`*, *`depth`*, and the border width, border height, and border depth of the texel array and taking *x*, *y*, *z*, *w*, *h*, and *d* to be the *`xoffset`*, *`yoffset`*, *`zoffset`*, *`width`*, *`height`*, and *`depth`* argument values, any of the following relationships generates a `GL_INVALID_OPERATION` error:\n\n- x \\< w_(b)\n\n- *x* + *w* \\> *w*_(*s*) − *w*_(*b*)\n\n- *y* \\< −*h*_(*b*)\n\n- *y* + *h* \\> *h*_(*s*) − *h*_(*b*)\n\n- *z* \\< −*d*_(*b*)\n\n- *z* + *d* \\> *d*_(*s*) − *d*_(*b*)\n\nFor texture types that do not have certain dimensions, this command treats those dimensions as having a size of 1. For example, to clear a portion of a two-dimensional texture, use *`zoffset`* equal to zero and *`depth`* equal to one.\n\n*`format`* and *`type`* specify the format and type of the source data and are interpreted as they are for [glTexImage3D](glteximage3d.xhtml). Textures with a base internal format of `GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL` require depth component, stencil, or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures with integer internal formats require integer data.\n\n*`data`* is a pointer to an array of between one and four components of texel data that will be used as the source for the constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was specified when the level was defined by any of the `glTexImage*`, `glTexStorage*` or `glCopyTexImage*` commands), and then used to fill the specified range of the destination texture level. If *`data`* is `NULL`, then the pointer is ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are cleared to the value specified by data.\n\n## Notes\n\n`glClearTexSubImage` is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`texture`* is zero or not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated if *`texture`* is a buffer texture.\n\n`GL_INVALID_OPERATION` is generated if *`texture`* has a compressed internal format.\n\n`GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_COMPONENT` and *`format`* is not `GL_DEPTH_COMPONENT`.\n\n`GL_INVALID_OPERATION` is generated if the base internal format is `GL_DEPTH_STENCIL` and *`format`* is not `GL_DEPTH_STENCIL`.\n\n`GL_INVALID_OPERATION` is generated if the base internal format is `GL_STENCIL_INDEX` and *`format`* is not `GL_STENCIL_INDEX`.\n\n`GL_INVALID_OPERATION` is generated if the base internal format is `GL_RGBA` and *`format`* is `GL_DEPTH_COMPONENT`, `GL_STENCIL_INDEX`, or `GL_DEPTH_STENCIL`.\n\n`GL_INVALID_OPERATION` is generated if the internal format is integer and *`format`* does not specify integer data.\n\n`GL_INVALID_OPERATION` is generated if the internal format is not integer and *`format`* specifies integer data.\n\n`GL_INVALID_OPERATION` error is generated if the *`xoffset`*, *`yoffset`*, *`zoffset`*, *`width`*, *`height`*, and *`depth`* parameters (or combinations thereof) specify a region that falls outside the defined texture image array (including border, if any).\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml), [glGetInternalformat](glgetinternalformat.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClearTexSubImage`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |\n\n## See Also\n\n[glClearTexImage](glclearteximage.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClearTexSubImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClearTexSubImage.xhtml)"
- name: glClientWaitSync
  id: glclientwaitsync.xhtml
  summary: sync The sync object whose status to wait on
  description: "## Name\n\nglClientWaitSync — block and wait for a sync object to become signaled\n\n## C Specification\n\n`GLenum `**`glClientWaitSync`**`(` GLsync `sync`, GLbitfield `flags`, GLuint64 `timeout``)`;\n\n## Parameters\n\n *`sync`*  \nThe sync object whose status to wait on.\n\n *`flags`*  \nA bitfield controlling the command flushing behavior. *`flags`* may be `GL_SYNC_FLUSH_COMMANDS_BIT`.\n\n *`timeout`*  \nThe timeout, specified in nanoseconds, for which the implementation should wait for *`sync`* to become signaled.\n\n## Description\n\n`glClientWaitSync` causes the client to block and wait for the sync object specified by *`sync`* to become signaled. If *`sync`* is signaled when `glClientWaitSync` is called, `glClientWaitSync` returns immediately, otherwise it will block and wait for up to *`timeout`* nanoseconds for *`sync`* to become signaled.\n\nThe return value is one of four status values:\n\n- `GL_ALREADY_SIGNALED` indicates that *`sync`* was signaled at the time that `glClientWaitSync` was called.\n\n- `GL_TIMEOUT_EXPIRED` indicates that at least *`timeout`* nanoseconds passed and *`sync`* did not become signaled.\n\n- `GL_CONDITION_SATISFIED` indicates that *`sync`* was signaled before the timeout expired.\n\n- `GL_WAIT_FAILED` indicates that an error occurred. Additionally, an OpenGL error will be generated.\n\n## Notes\n\n`glClientWaitSync` is available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`sync`* is not the name of an existing sync object.\n\n`GL_INVALID_VALUE` is generated if *`flags`* contains any unsupported flag.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClientWaitSync`          |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glFenceSync](glfencesync.xhtml), [glIsSync](glissync.xhtml) [glWaitSync](glwaitsync.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClientWaitSync.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClientWaitSync.xhtml)"
- name: glClipControl
  id: glclipcontrol.xhtml
  summary: origin Specifies the clip control origin
  description: "## Name\n\nglClipControl — control clip coordinate to window coordinate behavior\n\n## C Specification\n\n`void `**`glClipControl`**`(` GLenum `origin`, GLenum `depth``)`;\n\n## Parameters\n\n *`origin`*  \nSpecifies the clip control origin. Must be one of `GL_LOWER_LEFT` or `GL_UPPER_LEFT`.\n\n *`depth`*  \nSpecifies the clip control depth mode. Must be one of `GL_NEGATIVE_ONE_TO_ONE` or `GL_ZERO_TO_ONE`.\n\n## Description\n\n`glClipControl` controls the clipping volume behavior and the clip coordinate to window coordinate transformation behavior.\n\nThe view volume is defined by $$z\\_{min} \\leq z_c \\leq w_c$$ where $z\\_{min} = -w_c$ when *`depth`* is `GL_NEGATIVE_ONE_TO_ONE`, and $z\\_{min} = 0$ when *`depth`* is `GL_ZERO_TO_ONE`.\n\nThe normalized device coordinate $y_d$ is given by $$y_d = { { f \\times y_c } \\over w_c }$$ where $f = 1$ when *`origin`* is `GL_LOWER_LEFT`, and $f = -1$ when *`origin`* is `GL_UPPER_LEFT`.\n\nThe window coordinate $z_w$ is given by $$z_w = s \\times z_d + b$$ where $s = { { f - n } \\over 2 }$ and $b = { {n + f} \\over 2 }$ when *`depth`* is `GL_NEGATIVE_ONE_TO_ONE`, and $s = f - n$ and $b = n$ when *`depth`* is `GL_ZERO_TO_ONE`. $n$ and $f$ are the near and far depth range values set with [glDepthRange](gldepthrange.xhtml).\n\nFinally, the polygon area computation defined by [gl_FrontFacing](gl_frontfacing.xhtml) to determine if a polygon is front- or back-facing has its sign negated when *`origin`* is `GL_UPPER_LEFT`.\n\n## Notes\n\nThe default GL clip volume definition is for a *`origin`* of `GL_LOWER_LEFT` and a *`depth`* of `GL_NEGATIVE_ONE_TO_ONE`.\n\nAn *`origin`* of `GL_UPPER_LEFT` and a *`depth`* of `GL_ZERO_TO_ONE` corresponds to Direct3D's clip volume definition.\n\nAn *`origin`* of `GL_UPPER_LEFT` and a *`depth`* of `GL_NEGATIVE_ONE_TO_ONE` corresponds to the upper-left origin of the window coordinate system of Microsoft Windows and the X Window System.\n\nThere is extensive discussion of the uses and further consequences of the different clip volume settings in the `GL_ARB_clip_control` extension specification in the OpenGL Registry at URL [http://www.opengl.org/registry/](http://www.opengl.org/registry/).\n\n## Errors\n\nAn `GL_INVALID_ENUM` error is generated if *`origin`* is not `GL_LOWER_LEFT` or `GL_UPPER_LEFT`.\n\nAn `GL_INVALID_ENUM` error is generated if *`depth`* is not `GL_NEGATIVE_ONE_TO_ONE` or `GL_ZERO_TO_ONE`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glClipControl`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[gl_ClipDistance](gl_clipdistance.xhtml), [gl_CullDistance](gl_culldistance.xhtml), [gl_FrontFacing](gl_frontfacing.xhtml), [glDepthRange](gldepthrange.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glClipControl.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glClipControl.xhtml)"
- name: glColorMask
  id: glcolormask.xhtml
  summary: buf For glColorMaski, specifies the index of the draw buffer whose color mask to set
  description: "## Name\n\nglColorMask, glColorMaski — enable and disable writing of frame buffer color components\n\n## C Specification\n\n`void `**`glColorMask`**`(` GLboolean `red`, GLboolean `green`, GLboolean `blue`, GLboolean `alpha``)`;\n\n`void `**`glColorMaski`**`(` GLuint `buf`, GLboolean `red`, GLboolean `green`, GLboolean `blue`, GLboolean `alpha``)`;\n\n## Parameters\n\n *`buf`*  \nFor `glColorMaski`, specifies the index of the draw buffer whose color mask to set.\n\n*`red`*,  *`green`*,  *`blue`*,   *`alpha`*  \nSpecify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written.\n\n## Description\n\n`glColorMask` and `glColorMaski` specify whether the individual color components in the frame buffer can or cannot be written. `glColorMaski` sets the mask for a specific draw buffer, whereas `glColorMask` sets the mask for all draw buffers. If *`red`* is `GL_FALSE`, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.\n\nChanges to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_COLOR_WRITEMASK`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glColorMask`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glColorMaski`              |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glClear](glclear.xhtml), [glDepthMask](gldepthmask.xhtml), [glStencilMask](glstencilmask.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glColorMask.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glColorMask.xhtml)"
- name: glColorMaski
  id: glcolormask.xhtml#glColorMaski
  summary: For glColorMaski, specifies the index of the draw buffer whose color mask to set
  belongs_to: glColorMask
  description: "`void `**`glColorMaski`**`(` GLuint `buf`, GLboolean `red`, GLboolean `green`, GLboolean `blue`, GLboolean `alpha``)`;\n\n## Parameters\n\n*`buf`*\n\nFor `glColorMaski`, specifies the index of the draw buffer whose color mask to set.\n\n*`red`*, *`green`*, *`blue`*, *`alpha`*\n\nSpecify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all `GL_TRUE`, indicating that the color components are written.\n\n## Description\n\n`glColorMask` and `glColorMaski` specify whether the individual color components in the frame buffer can or cannot be written. `glColorMaski` sets the mask for a specific draw buffer, whereas `glColorMask` sets the mask for all draw buffers. If *`red`* is `GL_FALSE`, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.\n\nChanges to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_COLOR_WRITEMASK`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glColorMask`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glColorMaski`                |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glClear](glclear.xhtml), [glDepthMask](gldepthmask.xhtml), [glStencilMask](glstencilmask.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glColorMask.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glColorMask.xhtml)"
- name: glCompileShader
  id: glcompileshader.xhtml
  summary: shader Specifies the shader object to be compiled
  description: "## Name\n\nglCompileShader — Compiles a shader object\n\n## C Specification\n\n`void `**`glCompileShader`**`(` GLuint `shader``)`;\n\n## Parameters\n\n *`shader`*  \nSpecifies the shader object to be compiled.\n\n## Description\n\n`glCompileShader` compiles the source code strings that have been stored in the shader object specified by *`shader`*.\n\nThe compilation status will be stored as part of the shader object's state. This value will be set to `GL_TRUE` if the shader was compiled without errors and is ready for use, and `GL_FALSE` otherwise. It can be queried by calling [glGetShader](glgetshader.xhtml) with arguments *`shader`* and `GL_COMPILE_STATUS`.\n\nCompilation of a shader can fail for a number of reasons as specified by the OpenGL Shading Language Specification. Whether or not the compilation was successful, information about the compilation can be obtained from the shader object's information log by calling [glGetShaderInfoLog](glgetshaderinfolog.xhtml).\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`shader`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* is not a shader object.\n\n## Associated Gets\n\n[glGetShaderInfoLog](glgetshaderinfolog.xhtml) with argument *`shader`*\n\n[glGetShader](glgetshader.xhtml) with arguments *`shader`* and `GL_COMPILE_STATUS`\n\n[ glIsShader ](glisshader.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCompileShader`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateShader](glcreateshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glShaderSource](glshadersource.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompileShader.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompileShader.xhtml)"
- name: glCompressedTexImage1D
  id: glcompressedteximage1d.xhtml
  summary: target Specifies the target texture
  description: "## Name\n\nglCompressedTexImage1D — specify a one-dimensional texture image in a compressed format\n\n## C Specification\n\n`void `**`glCompressedTexImage1D`**`(` GLenum `target`, GLint `level`, GLenum `internalformat`, GLsizei `width`, GLint `border`, GLsizei `imageSize`, const void \\* `data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`internalformat`*  \nSpecifies the format of the compressed image data stored at address *`data`*.\n\n *`width`*  \nSpecifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.\n\n *`border`*  \nThis value must be 0.\n\n *`imageSize`*  \nSpecifies the number of unsigned bytes of image data starting at the address specified by *`data`*.\n\n *`data`*  \nSpecifies a pointer to the compressed image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\n`glCompressedTexImage1D` loads a previously defined, and retrieved, compressed one-dimensional texture image if *`target`* is `GL_TEXTURE_1D` (see [glTexImage1D](glteximage1d.xhtml)).\n\nIf *`target`* is `GL_PROXY_TEXTURE_1D`, no data is read from *`data`*, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see [glGetError](glgeterror.xhtml)). To query for an entire mipmap array, use an image array level greater than or equal to 1.\n\n*`internalformat`* must be an extension-specified compressed-texture format. When a texture is loaded with [glTexImage1D](glteximage1d.xhtml) using a generic compressed texture format (e.g., `GL_COMPRESSED_RGB`) the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using `glCompressedTexImage1D`, query the compressed texture image's size and format using [glGetTexLevelParameter](glgettexlevelparameter.xhtml).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\nIf the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for [glTexImage1D](glteximage1d.xhtml). In the following description, denote by *b*_(*s*), *b*_(*w*), *b*_(*h*), and *b*_(*d*) the values of pixel storage modes `GL_UNPACK_COMPRESSED_BLOCK_SIZE`, `GL_UNPACK_COMPRESSED_BLOCK_WIDTH`, `GL_UNPACK_COMPRESSED_BLOCK_HEIGHT`, and `GL_UNPACK_COMPRESSED_BLOCK_DEPTH`, respectively. *b*_(*s*) is the compressed block size in bytes; *b*_(*w*), *b*_(*h*), and *b*_(*d*) are the compressed block width, height, and depth in pixels.\n\nBy default the pixel storage modes `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_IMAGE_HEIGHT` and `GL_UNPACK_SKIP_IMAGES` are ignored for compressed images. To enable `GL_UNPACK_SKIP_PIXELS` and `GL_UNPACK_ROW_LENGTH`, *b*_(*s*) and *b*_(*w*) must both be non-zero. To also enable `GL_UNPACK_SKIP_ROWS` and `GL_UNPACK_IMAGE_HEIGHT`, *b*_(*h*) must be non-zero. To also enable `GL_UNPACK_SKIP_IMAGES`, *b*_(*d*) must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.\n\nWhen selecting a sub-rectangle from a compressed image,\n\n- the value of `GL_UNPACK_SKIP_PIXELS` must be a multiple of *b*_(*w*)\n\n*`imageSize`* must be equal to:\n\n$$b\\_{s} \\times \\left\\lceil \\frac{width}{b\\_{w}} \\right\\rceil$$\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a supported specific compressed internal formats, or is one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.\n\n`GL_INVALID_VALUE` is generated if *`imageSize`* is not consistent with the format, dimensions, and contents of the specified compressed image data.\n\n`GL_INVALID_VALUE` is generated if *`border`* is not 0.\n\n`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\nUndefined results, including abnormal program termination, are generated if *`data`* is not encoded in a manner consistent with the extension specification defining the internal compression format.\n\n## Associated Gets\n\n[glGetCompressedTexImage](glgetcompressedteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGet](glget.xhtml) with argument `GL_NUM_COMPRESSED_TEXTURE_FORMATS`\n\n[glGet](glget.xhtml) with argument `GL_COMPRESSED_TEXTURE_FORMATS`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_INTERNAL_FORMAT` and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCompressedTexImage1D`    |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexImage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexImage1D.xhtml)"
- name: glCompressedTexImage2D
  id: glcompressedteximage2d.xhtml
  summary: target Specifies the target texture
  description: "## Name\n\nglCompressedTexImage2D — specify a two-dimensional texture image in a compressed format\n\n## C Specification\n\n`void `**`glCompressedTexImage2D`**`(` GLenum `target`, GLint `level`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLint `border`, GLsizei `imageSize`, const void \\* `data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`internalformat`*  \nSpecifies the format of the compressed image data stored at address *`data`*.\n\n *`width`*  \nSpecifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.\n\n *`height`*  \nSpecifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.\n\n *`border`*  \nThis value must be 0.\n\n *`imageSize`*  \nSpecifies the number of unsigned bytes of image data starting at the address specified by *`data`*.\n\n *`data`*  \nSpecifies a pointer to the compressed image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\n`glCompressedTexImage2D` loads a previously defined, and retrieved, compressed two-dimensional texture image if *`target`* is `GL_TEXTURE_2D`, or one of the cube map faces such as `GL_TEXTURE_CUBE_MAP_POSITIVE_X`. (see [glTexImage2D](glteximage2d.xhtml)).\n\nIf *`target`* is `GL_TEXTURE_1D_ARRAY`, *`data`* is treated as an array of compressed 1D textures.\n\nIf *`target`* is `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_CUBE_MAP`, no data is read from *`data`*, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see [glGetError](glgeterror.xhtml)). To query for an entire mipmap array, use an image array level greater than or equal to 1.\n\n*`internalformat`* must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. When a texture is loaded with [glTexImage2D](glteximage2d.xhtml) using a generic compressed texture format (e.g., `GL_COMPRESSED_RGB`), the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using `glCompressedTexImage2D`, query the compressed texture image's size and format using [glGetTexLevelParameter](glgettexlevelparameter.xhtml).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\nIf the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for [glTexImage2D](glteximage2d.xhtml). In the following description, denote by *b*_(*s*), *b*_(*w*), *b*_(*h*), and *b*_(*d*), the values of pixel storage modes `GL_UNPACK_COMPRESSED_BLOCK_SIZE`, `GL_UNPACK_COMPRESSED_BLOCK_WIDTH`, `GL_UNPACK_COMPRESSED_BLOCK_HEIGHT`, and `GL_UNPACK_COMPRESSED_BLOCK_DEPTH`, respectively. *b*_(*s*) is the compressed block size in bytes; *b*_(*w*), *b*_(*h*), and *b*_(*d*) are the compressed block width, height, and depth in pixels.\n\nBy default the pixel storage modes `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_IMAGE_HEIGHT` and `GL_UNPACK_SKIP_IMAGES` are ignored for compressed images. To enable `GL_UNPACK_SKIP_PIXELS` and `GL_UNPACK_ROW_LENGTH`, *b*_(*s*) and *b*_(*w*) must both be non-zero. To also enable `GL_UNPACK_SKIP_ROWS` and `GL_UNPACK_IMAGE_HEIGHT`, *b*_(*h*) must be non-zero. To also enable `GL_UNPACK_SKIP_IMAGES`, *b*_(*d*) must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.\n\nWhen selecting a sub-rectangle from a compressed image:\n\n- The value of `GL_UNPACK_SKIP_PIXELS` must be a multiple of *b*_(*w*);\n\n- the value of `GL_UNPACK_SKIP_ROWS` must be a multiple of *b*_(*w*).\n\n*`imageSize`* must be equal to:\n\n$$b\\_{s} \\times \\left\\lceil \\frac{width}{b\\_{w}} \\right\\rceil \\times \\left\\lceil \\frac{height}{b\\_{h}} \\right\\rceil$$\n\n## Notes\n\nThe specific compressed internal formats `GL_COMPRESSED_RGB8_ETC2`, `GL_COMPRESSED_SRGB8_ETC2`, `GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2`, `GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2`, `GL_COMPRESSED_RGBA8_ETC2_EAC`, `GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC`, `GL_COMPRESSED_R11_EAC`, `GL_COMPRESSED_SIGNED_R11_EAC`, `GL_COMPRESSED_RG11_EAC`, and `GL_COMPRESSED_SIGNED_RG11_EAC` are available only if the GL version is 4.3 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the specific compressed internal formats: `GL_COMPRESSED_RED_RGTC1`, `GL_COMPRESSED_SIGNED_RED_RGTC1`, `GL_COMPRESSED_RG_RGTC2`, `GL_COMPRESSED_SIGNED_RG_RGTC2`. `GL_COMPRESSED_RGBA_BPTC_UNORM`, `GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`, `GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`, `GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT`, `GL_COMPRESSED_RGB8_ETC2`, `GL_COMPRESSED_SRGB8_ETC2`, `GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2`, `GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2`, `GL_COMPRESSED_RGBA8_ETC2_EAC`, `GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC`, `GL_COMPRESSED_R11_EAC`, `GL_COMPRESSED_SIGNED_R11_EAC`, `GL_COMPRESSED_RG11_EAC`, or `GL_COMPRESSED_SIGNED_RG11_EAC`.\n\n`GL_INVALID_VALUE` is generated if *`imageSize`* is not consistent with the format, dimensions, and contents of the specified compressed image data.\n\n`GL_INVALID_VALUE` is generated if *`border`* is not 0.\n\n`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\nUndefined results, including abnormal program termination, are generated if *`data`* is not encoded in a manner consistent with the extension specification defining the internal compression format.\n\n## Associated Gets\n\n[glGetCompressedTexImage](glgetcompressedteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_INTERNAL_FORMAT` and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCompressedTexImage2D`    |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexImage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexImage2D.xhtml)"
- name: glCompressedTexImage3D
  id: glcompressedteximage3d.xhtml
  summary: target Specifies the target texture
  description: "## Name\n\nglCompressedTexImage3D — specify a three-dimensional texture image in a compressed format\n\n## C Specification\n\n`void `**`glCompressedTexImage3D`**`(` GLenum `target`, GLint `level`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLint `border`, GLsizei `imageSize`, const void \\* `data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target texture. Must be `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_2D_ARRAY`.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`internalformat`*  \nSpecifies the format of the compressed image data stored at address *`data`*.\n\n *`width`*  \nSpecifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.\n\n *`height`*  \nSpecifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.\n\n *`depth`*  \nSpecifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.\n\n *`border`*  \nThis value must be 0.\n\n *`imageSize`*  \nSpecifies the number of unsigned bytes of image data starting at the address specified by *`data`*.\n\n *`data`*  \nSpecifies a pointer to the compressed image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\n`glCompressedTexImage3D` loads a previously defined, and retrieved, compressed three-dimensional texture image if *`target`* is `GL_TEXTURE_3D` (see [glTexImage3D](glteximage3d.xhtml)).\n\nIf *`target`* is `GL_TEXTURE_2D_ARRAY`, *`data`* is treated as an array of compressed 2D textures.\n\nIf *`target`* is `GL_PROXY_TEXTURE_3D` or `GL_PROXY_TEXTURE_2D_ARRAY`, no data is read from *`data`*, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see [glGetError](glgeterror.xhtml)). To query for an entire mipmap array, use an image array level greater than or equal to 1.\n\n*`internalformat`* must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. When a texture is loaded with [glTexImage2D](glteximage2d.xhtml) using a generic compressed texture format (e.g., `GL_COMPRESSED_RGB`), the GL selects from one of its extensions supporting compressed textures. In order to load the compressed texture image using `glCompressedTexImage3D`, query the compressed texture image's size and format using [glGetTexLevelParameter](glgettexlevelparameter.xhtml).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\nIf the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for [glTexImage1D](glteximage1d.xhtml). In the following description, denote by *b*_(*s*), *b*_(*w*), *b*_(*h*), and *b*_(*d*) the values of pixel storage modes `GL_UNPACK_COMPRESSED_BLOCK_SIZE`, `GL_UNPACK_COMPRESSED_BLOCK_WIDTH`, `GL_UNPACK_COMPRESSED_BLOCK_HEIGHT`, and `GL_UNPACK_COMPRESSED_BLOCK_DEPTH`, respectively. *b*_(*s*) is the compressed block size in bytes; *b*_(*w*), *b*_(*h*), and *b*_(*d*) are the compressed block width, height, and depth in pixels.\n\nBy default the pixel storage modes `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_IMAGE_HEIGHT` and `GL_UNPACK_SKIP_IMAGES` are ignored for compressed images. To enable `GL_UNPACK_SKIP_PIXELS` and `GL_UNPACK_ROW_LENGTH`, *b*_(*s*) and *b*_(*w*) must both be non-zero. To also enable `GL_UNPACK_SKIP_ROWS` and `GL_UNPACK_IMAGE_HEIGHT`, *b*_(*h*) must be non-zero. To also enable `GL_UNPACK_SKIP_IMAGES`, *b*_(*d*) must be non-zero. All parameters must be consistent with the compressed format to produce the desired results.\n\nWhen selecting a sub-rectangle from a compressed image:\n\n- the value of `GL_UNPACK_SKIP_PIXELS` must be a multiple of *b*_(*w*);\n\n- the value of `GL_UNPACK_SKIP_ROWS` must be a multiple of *b*_(*w*);\n\n- the value of `GL_UNPACK_SKIP_IMAGES` must be a multiple of *b*_(*w*).\n\n*`imageSize`* must be equal to:\n\n$$b\\_{s} \\times \\left\\lceil \\frac{width}{b\\_{w}} \\right\\rceil \\times \\left\\lceil \\frac{height}{b\\_{h}} \\right\\rceil \\times \\left\\lceil \\frac{depth}{b\\_{d}} \\right\\rceil$$\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.\n\n`GL_INVALID_VALUE` is generated if *`imageSize`* is not consistent with the format, dimensions, and contents of the specified compressed image data.\n\n`GL_INVALID_VALUE` is generated if *`border`* is not 0.\n\n`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\nUndefined results, including abnormal program termination, are generated if *`data`* is not encoded in a manner consistent with the extension specification defining the internal compression format.\n\n## Associated Gets\n\n[glGetCompressedTexImage](glgetcompressedteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_INTERNAL_FORMAT` and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCompressedTexImage3D`    |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexImage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexImage3D.xhtml)"
- name: glCompressedTexSubImage1D
  id: glcompressedtexsubimage1d.xhtml
  summary: target Specifies the target, to which the texture is bound, for glCompressedTexSubImage1D function
  description: "## Name\n\nglCompressedTexSubImage1D, glCompressedTextureSubImage1D — specify a one-dimensional texture subimage in a compressed format\n\n## C Specification\n\n`void `**`glCompressedTexSubImage1D`**`(` GLenum `target`, GLint `level`, GLint `xoffset`, GLsizei `width`, GLenum `format`, GLsizei `imageSize`, const void \\* `data``)`;\n\n`void `**`glCompressedTextureSubImage1D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLsizei `width`, GLenum `format`, GLsizei `imageSize`, const void \\*`data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target, to which the texture is bound, for `glCompressedTexSubImage1D` function. Must be `GL_TEXTURE_1D`.\n\n *`texture`*  \nSpecifies the texture object name for `glCompressedTextureSubImage1D` function.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n *`format`*  \nSpecifies the format of the compressed image data stored at address *`data`*.\n\n *`imageSize`*  \nSpecifies the number of unsigned bytes of image data starting at the address specified by *`data`*.\n\n *`data`*  \nSpecifies a pointer to the compressed image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\n`glCompressedTexSubImage1D` and `glCompressedTextureSubImage1D` redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by *`data`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.\n\n*`internalformat`* must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. The *`format`* of the compressed texture image is selected by the GL implementation that compressed it (see [glTexImage1D](glteximage1d.xhtml)), and should be queried at the time the texture was compressed with [glGetTexLevelParameter](glgettexlevelparameter.xhtml).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.\n\n`GL_INVALID_VALUE` is generated if *`imageSize`* is not consistent with the format, dimensions, and contents of the specified compressed image data.\n\n`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\nGL_INVALID_OPERATION is generated by `glCompressedTextureSubImage1D` function if texture is not the name of an existing texture object.\n\nUndefined results, including abnormal program termination, are generated if *`data`* is not encoded in a manner consistent with the extension specification defining the internal compression format.\n\n## Associated Gets\n\n[glGetCompressedTexImage](glgetcompressedteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_INTERNAL_FORMAT` and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCompressedTexSubImage1D`     |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glCompressedTextureSubImage1D` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage1D.xhtml)"
- name: glCompressedTexSubImage2D
  id: glcompressedtexsubimage2d.xhtml
  summary: target Specifies the target to which the texture is bound for glCompressedTexSubImage2D function
  description: "## Name\n\nglCompressedTexSubImage2D, glCompressedTextureSubImage2D — specify a two-dimensional texture subimage in a compressed format\n\n## C Specification\n\n`void `**`glCompressedTexSubImage2D`**`(` GLenum `target`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLsizei `width`, GLsizei `height`, GLenum `format`, GLsizei `imageSize`, const void \\* `data``)`;\n\n`void `**`glCompressedTextureSubImage2D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLsizei `width`, GLsizei `height`, GLenum `format`, GLsizei `imageSize`, const void \\*`data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glCompressedTexSubImage2D` function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.\n\n *`texture`*  \nSpecifies the texture object name for `glCompressedTextureSubImage2D` function.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`yoffset`*  \nSpecifies a texel offset in the y direction within the texture array.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n *`height`*  \nSpecifies the height of the texture subimage.\n\n *`format`*  \nSpecifies the format of the compressed image data stored at address *`data`*.\n\n *`imageSize`*  \nSpecifies the number of unsigned bytes of image data starting at the address specified by *`data`*.\n\n *`data`*  \nSpecifies a pointer to the compressed image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\n`glCompressedTexSubImage2D` and `glCompressedTextureSubImage2D` redefine a contiguous subregion of an existing two-dimensional texture image. The texels referenced by *`data`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, and the y indices *`yoffset`* and *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.\n\n*`internalformat`* must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. The *`format`* of the compressed texture image is selected by the GL implementation that compressed it (see [glTexImage2D](glteximage2d.xhtml)) and should be queried at the time the texture was compressed with [glGetTexLevelParameter](glgettexlevelparameter.xhtml).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.\n\n`GL_INVALID_ENUM` is generated by `glCompressedTexSubImage2D` if *`target`* is `GL_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_RECTANGLE`.\n\n`GL_INVALID_VALUE` is generated if *`imageSize`* is not consistent with the format, dimensions, and contents of the specified compressed image data.\n\n`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated by `glCompressedTextureSubImage2D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated by `glCompressedTextureSubImage2D` if the effective target is `GL_TEXTURE_RECTANGLE`.\n\nUndefined results, including abnormal program termination, are generated if *`data`* is not encoded in a manner consistent with the extension specification defining the internal compression format.\n\n## Associated Gets\n\n[glGetCompressedTexImage](glgetcompressedteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_INTERNAL_FORMAT` and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCompressedTexSubImage2D`     |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glCompressedTextureSubImage2D` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage2D.xhtml)"
- name: glCompressedTexSubImage3D
  id: glcompressedtexsubimage3d.xhtml
  summary: target Specifies the target to which the texture is bound for glCompressedTexSubImage3D function
  description: "## Name\n\nglCompressedTexSubImage3D, glCompressedTextureSubImage3D — specify a three-dimensional texture subimage in a compressed format\n\n## C Specification\n\n`void `**`glCompressedTexSubImage3D`**`(` GLenum `target`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLenum `format`, GLsizei `imageSize`, const void \\* `data``)`;\n\n`void `**`glCompressedTextureSubImage3D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLenum `format`, GLsizei `imageSize`, const void \\*`data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glCompressedTexSubImage3D` function. Must be `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n *`texture`*  \nSpecifies the texture object name for `glCompressedTextureSubImage3D` function.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`yoffset`*  \nSpecifies a texel offset in the y direction within the texture array.\n\n *`zoffset`*  \nSpecifies a texel offset in the z direction within the texture array.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n *`height`*  \nSpecifies the height of the texture subimage.\n\n *`depth`*  \nSpecifies the depth of the texture subimage.\n\n *`format`*  \nSpecifies the format of the compressed image data stored at address *`data`*.\n\n *`imageSize`*  \nSpecifies the number of unsigned bytes of image data starting at the address specified by *`data`*.\n\n *`data`*  \nSpecifies a pointer to the compressed image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\n`glCompressedTexSubImage3D` and `glCompressedTextureSubImage3D` redefine a contiguous subregion of an existing three-dimensional texture image. The texels referenced by *`data`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, and the y indices *`yoffset`* and *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, and the z indices *`zoffset`* and *z**o**f**f**s**e**t* + *d**e**p**t**h* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.\n\n*`internalformat`* must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. The *`format`* of the compressed texture image is selected by the GL implementation that compressed it (see [glTexImage3D](glteximage3d.xhtml)) and should be queried at the time the texture was compressed with [glGetTexLevelParameter](glgettexlevelparameter.xhtml).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.\n\n`GL_INVALID_ENUM` is generated by `glCompressedTexSubImage3D` if *`target`* is not `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n`GL_INVALID_OPERATION` is generated by `glCompressedTextureSubImage3D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`imageSize`* is not consistent with the format, dimensions, and contents of the specified compressed image data.\n\n`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\nUndefined results, including abnormal program termination, are generated if *`data`* is not encoded in a manner consistent with the extension specification defining the internal compression format.\n\n## Associated Gets\n\n[glGetCompressedTexImage](glgetcompressedteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_INTERNAL_FORMAT` and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCompressedTexSubImage3D`     |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glCompressedTextureSubImage3D` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage3D.xhtml)"
- name: glCompressedTextureSubImage1D
  id: glcompressedtexsubimage1d.xhtml#glCompressedTextureSubImage1D
  summary: Specifies the target, to which the texture is bound, for glCompressedTexSubImage1D function
  belongs_to: glCompressedTexSubImage1D
  description: "`void `**`glCompressedTextureSubImage1D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLsizei `width`, GLenum `format`, GLsizei `imageSize`, const void \\*`data``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target, to which the texture is bound, for `glCompressedTexSubImage1D` function. Must be `GL_TEXTURE_1D`.\n\n*`texture`*\n\nSpecifies the texture object name for `glCompressedTextureSubImage1D` function.\n\n*`level`*\n\nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`xoffset`*\n\nSpecifies a texel offset in the x direction within the texture array.\n\n*`width`*\n\nSpecifies the width of the texture subimage.\n\n*`format`*\n\nSpecifies the format of the compressed image data stored at address *`data`*.\n\n*`imageSize`*\n\nSpecifies the number of unsigned bytes of image data starting at the address specified by *`data`*.\n\n*`data`*\n\nSpecifies a pointer to the compressed image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\n`glCompressedTexSubImage1D` and `glCompressedTextureSubImage1D` redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by *`data`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.\n\n*`internalformat`* must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. The *`format`* of the compressed texture image is selected by the GL implementation that compressed it (see [glTexImage1D](glteximage1d.xhtml)), and should be queried at the time the texture was compressed with [glGetTexLevelParameter](glgettexlevelparameter.xhtml).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.\n\n`GL_INVALID_VALUE` is generated if *`imageSize`* is not consistent with the format, dimensions, and contents of the specified compressed image data.\n\n`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\nGL_INVALID_OPERATION is generated by `glCompressedTextureSubImage1D` function if texture is not the name of an existing texture object.\n\nUndefined results, including abnormal program termination, are generated if *`data`* is not encoded in a manner consistent with the extension specification defining the internal compression format.\n\n## Associated Gets\n\n[ glGetCompressedTexImage ](glgetcompressedteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_INTERNAL_FORMAT` and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n## Version Support\n\n|                                 |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**    |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glCompressedTexSubImage1D`     |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glCompressedTextureSubImage1D` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage1D.xhtml)"
- name: glCompressedTextureSubImage2D
  id: glcompressedtexsubimage2d.xhtml#glCompressedTextureSubImage2D
  summary: Specifies the target to which the texture is bound for glCompressedTexSubImage2D function
  belongs_to: glCompressedTexSubImage2D
  description: "`void `**`glCompressedTextureSubImage2D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLsizei `width`, GLsizei `height`, GLenum `format`, GLsizei `imageSize`, const void \\*`data``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glCompressedTexSubImage2D` function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.\n\n*`texture`*\n\nSpecifies the texture object name for `glCompressedTextureSubImage2D` function.\n\n*`level`*\n\nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`xoffset`*\n\nSpecifies a texel offset in the x direction within the texture array.\n\n*`yoffset`*\n\nSpecifies a texel offset in the y direction within the texture array.\n\n*`width`*\n\nSpecifies the width of the texture subimage.\n\n*`height`*\n\nSpecifies the height of the texture subimage.\n\n*`format`*\n\nSpecifies the format of the compressed image data stored at address *`data`*.\n\n*`imageSize`*\n\nSpecifies the number of unsigned bytes of image data starting at the address specified by *`data`*.\n\n*`data`*\n\nSpecifies a pointer to the compressed image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\n`glCompressedTexSubImage2D` and `glCompressedTextureSubImage2D` redefine a contiguous subregion of an existing two-dimensional texture image. The texels referenced by *`data`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, and the y indices *`yoffset`* and *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.\n\n*`internalformat`* must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. The *`format`* of the compressed texture image is selected by the GL implementation that compressed it (see [glTexImage2D](glteximage2d.xhtml)) and should be queried at the time the texture was compressed with [glGetTexLevelParameter](glgettexlevelparameter.xhtml).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.\n\n`GL_INVALID_ENUM` is generated by `glCompressedTexSubImage2D` if *`target`* is `GL_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_RECTANGLE`.\n\n`GL_INVALID_VALUE` is generated if *`imageSize`* is not consistent with the format, dimensions, and contents of the specified compressed image data.\n\n`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated by `glCompressedTextureSubImage2D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated by `glCompressedTextureSubImage2D` if the effective target is `GL_TEXTURE_RECTANGLE`.\n\nUndefined results, including abnormal program termination, are generated if *`data`* is not encoded in a manner consistent with the extension specification defining the internal compression format.\n\n## Associated Gets\n\n[ glGetCompressedTexImage ](glgetcompressedteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_INTERNAL_FORMAT` and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n## Version Support\n\n|                                 |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**    |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glCompressedTexSubImage2D`     |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glCompressedTextureSubImage2D` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage2D.xhtml)"
- name: glCompressedTextureSubImage3D
  id: glcompressedtexsubimage3d.xhtml#glCompressedTextureSubImage3D
  summary: Specifies the target to which the texture is bound for glCompressedTexSubImage3D function
  belongs_to: glCompressedTexSubImage3D
  description: "`void `**`glCompressedTextureSubImage3D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLenum `format`, GLsizei `imageSize`, const void \\*`data``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glCompressedTexSubImage3D` function. Must be `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n*`texture`*\n\nSpecifies the texture object name for `glCompressedTextureSubImage3D` function.\n\n*`level`*\n\nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`xoffset`*\n\nSpecifies a texel offset in the x direction within the texture array.\n\n*`yoffset`*\n\nSpecifies a texel offset in the y direction within the texture array.\n\n*`zoffset`*\n\nSpecifies a texel offset in the z direction within the texture array.\n\n*`width`*\n\nSpecifies the width of the texture subimage.\n\n*`height`*\n\nSpecifies the height of the texture subimage.\n\n*`depth`*\n\nSpecifies the depth of the texture subimage.\n\n*`format`*\n\nSpecifies the format of the compressed image data stored at address *`data`*.\n\n*`imageSize`*\n\nSpecifies the number of unsigned bytes of image data starting at the address specified by *`data`*.\n\n*`data`*\n\nSpecifies a pointer to the compressed image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\n`glCompressedTexSubImage3D` and `glCompressedTextureSubImage3D` redefine a contiguous subregion of an existing three-dimensional texture image. The texels referenced by *`data`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, and the y indices *`yoffset`* and *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, and the z indices *`zoffset`* and *z**o**f**f**s**e**t* + *d**e**p**t**h* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.\n\n*`internalformat`* must be a known compressed image format (such as `GL_RGTC`) or an extension-specified compressed-texture format. The *`format`* of the compressed texture image is selected by the GL implementation that compressed it (see [glTexImage3D](glteximage3d.xhtml)) and should be queried at the time the texture was compressed with [glGetTexLevelParameter](glgettexlevelparameter.xhtml).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is one of the generic compressed internal formats: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, or `GL_COMPRESSED_SRGB_ALPHA`.\n\n`GL_INVALID_ENUM` is generated by `glCompressedTexSubImage3D` if *`target`* is not `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n`GL_INVALID_OPERATION` is generated by `glCompressedTextureSubImage3D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`imageSize`* is not consistent with the format, dimensions, and contents of the specified compressed image data.\n\n`GL_INVALID_OPERATION` is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\nUndefined results, including abnormal program termination, are generated if *`data`* is not encoded in a manner consistent with the extension specification defining the internal compression format.\n\n## Associated Gets\n\n[ glGetCompressedTexImage ](glgetcompressedteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_INTERNAL_FORMAT` and `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n## Version Support\n\n|                                 |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**    |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glCompressedTexSubImage3D`     |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glCompressedTextureSubImage3D` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCompressedTexSubImage3D.xhtml)"
- name: glCopyBufferSubData
  id: glcopybuffersubdata.xhtml
  summary: writeTarget Specifies the target to which the destination buffer object is bound for glCopyBufferSubData
  description: "## Name\n\nglCopyBufferSubData, glCopyNamedBufferSubData — copy all or part of the data store of a buffer object to the data store of another buffer object\n\n## C Specification\n\n`void `**`glCopyBufferSubData`**`(` GLenum `readTarget`, GLenum `writeTarget`, GLintptr `readOffset`, GLintptr `writeOffset`, GLsizeiptr `size``)`;\n\n`void `**`glCopyNamedBufferSubData`**`(` GLuint `readBuffer`, GLuint `writeBuffer`, GLintptr `readOffset`, GLintptr `writeOffset`, GLsizeiptr `size``)`;\n\n## Parameters\n\n *`readTarget`*  \nSpecifies the target to which the source buffer object is bound for `glCopyBufferSubData`\n\n *`writeTarget`*  \nSpecifies the target to which the destination buffer object is bound for `glCopyBufferSubData`.\n\n *`readBuffer`*  \nSpecifies the name of the source buffer object for `glCopyNamedBufferSubData`.\n\n *`writeBuffer`*  \nSpecifies the name of the destination buffer object for `glCopyNamedBufferSubData`.\n\n *`readOffset`*  \nSpecifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.\n\n *`writeOffset`*  \nSpecifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written.\n\n *`size`*  \nSpecifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object.\n\n## Description\n\n`glCopyBufferSubData` and `glCopyNamedBufferSubData` copy part of the data store attached to a source buffer object to the data store attached to a destination buffer object. The number of basic machine units indicated by *`size`* is copied from the source at offset *`readOffset`* to the destination at *`writeOffset`*. *`readOffset`*, *`writeOffset`* and *`size`* are in terms of basic machine units.\n\nFor `glCopyBufferSubData`, *`readTarget`* and *`writeTarget`* specify the targets to which the source and destination buffer objects are bound, and must each be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\nAny of these targets may be used, but the targets `GL_COPY_READ_BUFFER` and `GL_COPY_WRITE_BUFFER` are provided specifically to allow copies between buffers without disturbing other GL state.\n\n*`readOffset`*, *`writeOffset`* and *`size`* must all be greater than or equal to zero. Furthermore, $readOffset+size$ must not exceeed the size of the source buffer object, and $writeOffset+size$ must not exceeed the size of the buffer bound to *`writeTarget`*. If the source and destination are the same buffer object, then the source and destination ranges must not overlap.\n\n## Notes\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glCopyBufferSubData` if *`readTarget`* or *`writeTarget`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glCopyBufferSubData` if zero is bound to *`readTarget`* or *`writeTarget`*.\n\n`GL_INVALID_OPERATION` is generated by `glCopyNamedBufferSubData` if *`readBuffer`* or *`writeBuffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if any of *`readOffset`*, *`writeOffset`* or *`size`* is negative, if $readOffset + size$ is greater than the size of the source buffer object (its value of `GL_BUFFER_SIZE`), or if $writeOffset + size$ is greater than the size of the destination buffer object.\n\n`GL_INVALID_VALUE` is generated if the source and destination are the same buffer object, and the ranges $\\[readOffset,readOffset+size)$ and $\\[writeOffset,writeOffset+size)$ overlap.\n\n`GL_INVALID_OPERATION` is generated if either the source or destination buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless they were mapped with the `GL_MAP_PERSISTENT` bit set in the `glMapBufferRange` *`access`* flags.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCopyBufferSubData`       |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glCopyNamedBufferSubData`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glGetBufferSubData](glgetbuffersubdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glMapBufferRange](glmapbufferrange.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyBufferSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyBufferSubData.xhtml)"
- name: glCopyImageSubData
  id: glcopyimagesubdata.xhtml
  summary: srcName The name of a texture or renderbuffer object from which to copy
  description: "## Name\n\nglCopyImageSubData — perform a raw data copy between two images\n\n## C Specification\n\n`void `**`glCopyImageSubData`**`(` GLuint `srcName`, GLenum `srcTarget`, GLint `srcLevel`, GLint `srcX`, GLint `srcY`, GLint `srcZ`, GLuint `dstName`, GLenum `dstTarget`, GLint `dstLevel`, GLint `dstX`, GLint `dstY`, GLint `dstZ`, GLsizei `srcWidth`, GLsizei `srcHeight`, GLsizei `srcDepth``)`;\n\n## Parameters\n\n *`srcName`*  \nThe name of a texture or renderbuffer object from which to copy.\n\n *`srcTarget`*  \nThe target representing the namespace of the source name *`srcName`*.\n\n *`srcLevel`*  \nThe mipmap level to read from the source.\n\n *`srcX`*  \nThe X coordinate of the left edge of the souce region to copy.\n\n *`srcY`*  \nThe Y coordinate of the top edge of the souce region to copy.\n\n *`srcZ`*  \nThe Z coordinate of the near edge of the souce region to copy.\n\n *`dstName`*  \nThe name of a texture or renderbuffer object to which to copy.\n\n *`dstTarget`*  \nThe target representing the namespace of the destination name *`dstName`*.\n\n *`dstX`*  \nThe X coordinate of the left edge of the destination region.\n\n *`dstY`*  \nThe Y coordinate of the top edge of the destination region.\n\n *`dstZ`*  \nThe Z coordinate of the near edge of the destination region.\n\n *`srcWidth`*  \nThe width of the region to be copied.\n\n *`srcHeight`*  \nThe height of the region to be copied.\n\n *`srcDepth`*  \nThe depth of the region to be copied.\n\n## Description\n\n`glCopyImageSubData` may be used to copy data from one image (i.e. texture or renderbuffer) to another. `glCopyImageSubData` does not perform general-purpose conversions such as scaling, resizing, blending, color-space, or format conversions. It should be considered to operate in a manner similar to a CPU memcpy. CopyImageSubData can copy between images with different internal formats, provided the formats are compatible.\n\n`glCopyImageSubData` also allows copying between certain types of compressed and uncompressed internal formats. This copy does not perform on-the-fly compression or decompression. When copying from an uncompressed internal format to a compressed internal format, each texel of uncompressed data becomes a single block of compressed data. When copying from a compressed internal format to an uncompressed internal format, a block of compressed data becomes a single texel of uncompressed data. The texel size of the uncompressed format must be the same size the block size of the compressed formats. Thus it is permitted to copy between a 128-bit uncompressed format and a compressed format which uses 8-bit 4x4 blocks, or between a 64-bit uncompressed format and a compressed format which uses 4-bit 4x4 blocks.\n\nThe source object is identified by *`srcName`* and *`srcTarget`* and the destination object is identified by *`dstName`* and *`dstTarget`*. The interpretation of the name depends on the value of the corresponding *`target`* parameter. If *`target`* is `GL_RENDERBUFFER`, the name is interpreted as the name of a renderbuffer object. If the target parameter is a texture target, the name is interpreted as a texture object. All non-proxy texture targets are accepted, with the exception of `GL_TEXTURE_BUFFER` and the cubemap face selectors.\n\n*`srcLevel`* and *`dstLevel`* identify the source and destination level of detail. For textures, this must be a valid level of detail in the texture object. For renderbuffers, this value must be zero.\n\n*`srcX`*, *`srcY`*, and *`srcZ`* specify the lower left texel coordinates of a *`srcWidth`*-wide by *`srcHeight`*-high by *`srcDepth`*-deep rectangular subregion of the source texel array. Similarly, *`dstX`*, *`dstY`* and *`dstZ`* specify the coordinates of a subregion of the destination texel array. The source and destination subregions must be contained entirely within the specified level of the corresponding image objects.\n\nThe dimensions are always specified in texels, even for compressed texture formats. However, it should be noted that if only one of the source and destination textures is compressed then the number of texels touched in the compressed image will be a factor of the block size larger than in the uncompressed image.\n\nSlices of a `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY` `GL_TEXTURE_3D` and faces of `GL_TEXTURE_CUBE_MAP` are all compatible provided they share a compatible internal format, and multiple slices or faces may be copied between these objects with a single call by specifying the starting slice with *`srcZ`* and *`dstZ`*, and the number of slices to be copied with *`srcDepth`*. Cubemap textures always have six faces which are selected by a zero-based face index.\n\nFor the purposes of CopyImageSubData, two internal formats are considered compatible if any of the following conditions are met:\n\n- the formats are the same,\n\n- the formats are considered compatible according to the compatibility rules used for texture views as defined in section 3.9.X. In particular, if both internal formats are listed in the same entry of Table 3.X.2, they are considered compatible, or\n\n- one format is compressed and the other is uncompressed and Table 4.X.1 lists the two formats in the same row.\n\nIf the formats are not compatible, an INVALID_OPERATION error is generated.\n\nTable 1. Sized Internal Formats\n\n|  **Texel / Block Size**  |  **Uncompressed Internal Format**                                                                              |  **Compressed Internal Format(s)**                                                                                                                                                                                                                                                                                                                                            |\n|:-------------------------|:---------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 64-bit                   | `GL_RGBA32UI`, `GL_RGBA32I`, `GL_RGBA32F`                                                                      | `GL_COMPRESSED_RGBA_S3TC_DXT3_EXT`, `GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT`, `GL_COMPRESSED_RGBA_S3TC_DXT5_EXT`, `GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT`, `GL_COMPRESSED_RG_RGTC2`, `GL_COMPRESSED_SIGNED_RG_RGTC2`, `GL_COMPRESSED_RGBA_BPTC_UNORM`, `GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`, `GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`, `GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT` |\n| 128-bit                  | `GL_RGBA16UI`, `GL_RGBA16I`, `GL_RGBA16F`, `GL_RG32F`, `GL_RG32UI`, `GL_RG32I`, `GL_RGBA16`, `GL_RGBA16_SNORM` | `GL_COMPRESSED_RGB_S3TC_DXT1_EXT`, `GL_COMPRESSED_SRGB_S3TC_DXT1_EXT`, `GL_COMPRESSED_RGBA_S3TC_DXT1_EXT`, `GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT`, `GL_COMPRESSED_RED_RGTC1`, `GL_COMPRESSED_SIGNED_RED_RGTC1`                                                                                                                                                              |\n\n  \n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if the texel size of the uncompressed image is not equal to the block size of the compressed image.\n\n`GL_INVALID_ENUM` is generated if either target parameter is not `GL_RENDERBUFFER`, a valid non-proxy texture target other than `GL_TEXTURE_BUFFER`, or is one of the cubemap face selectors.\n\n`GL_INVALID_ENUM` is generated if *`target`* does not match the type of the object.\n\n`GL_INVALID_OPERATION` is generated if either object is a texture and the texture is not complete.\n\n`GL_INVALID_OPERATION` is generated if the source and destination internal formats are not compatible, or if the number of samples do not match.\n\n`GL_INVALID_VALUE` is generated if either name does not correspond to a valid renderbuffer or texture object according to the corresponding target parameter.\n\n`GL_INVALID_VALUE` is generated if the specified level of either the source or destination is not a valid level for the corresponding image.\n\n`GL_INVALID_VALUE` is generated if the dimensions of the either subregion exceeds the boundaries of the corresponding image object, or if the image format is compressed and the dimensions of the subregion fail to meet the alignment constraints of the format.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_COMPUTE_WORK_GROUP_COUNT`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCopyImageSubData`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDispatchComputeIndirect](gldispatchcomputeindirect.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyImageSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyImageSubData.xhtml)"
- name: glCopyNamedBufferSubData
  id: glcopybuffersubdata.xhtml#glCopyNamedBufferSubData
  summary: Specifies the target to which the destination buffer object is bound for glCopyBufferSubData
  belongs_to: glCopyBufferSubData
  description: "`void `**`glCopyNamedBufferSubData`**`(` GLuint `readBuffer`, GLuint `writeBuffer`, GLintptr `readOffset`, GLintptr `writeOffset`, GLsizeiptr `size``)`;\n\n## Parameters\n\n*`readTarget`*\n\nSpecifies the target to which the source buffer object is bound for `glCopyBufferSubData`\n\n*`writeTarget`*\n\nSpecifies the target to which the destination buffer object is bound for `glCopyBufferSubData`.\n\n*`readBuffer`*\n\nSpecifies the name of the source buffer object for `glCopyNamedBufferSubData`.\n\n*`writeBuffer`*\n\nSpecifies the name of the destination buffer object for `glCopyNamedBufferSubData`.\n\n*`readOffset`*\n\nSpecifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.\n\n*`writeOffset`*\n\nSpecifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written.\n\n*`size`*\n\nSpecifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object.\n\n## Description\n\n`glCopyBufferSubData` and `glCopyNamedBufferSubData` copy part of the data store attached to a source buffer object to the data store attached to a destination buffer object. The number of basic machine units indicated by *`size`* is copied from the source at offset *`readOffset`* to the destination at *`writeOffset`*. *`readOffset`*, *`writeOffset`* and *`size`* are in terms of basic machine units.\n\nFor `glCopyBufferSubData`, *`readTarget`* and *`writeTarget`* specify the targets to which the source and destination buffer objects are bound, and must each be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\nAny of these targets may be used, but the targets `GL_COPY_READ_BUFFER` and `GL_COPY_WRITE_BUFFER` are provided specifically to allow copies between buffers without disturbing other GL state.\n\n*`readOffset`*, *`writeOffset`* and *`size`* must all be greater than or equal to zero. Furthermore, $readOffset+size$ must not exceeed the size of the source buffer object, and $writeOffset+size$ must not exceeed the size of the buffer bound to *`writeTarget`*. If the source and destination are the same buffer object, then the source and destination ranges must not overlap.\n\n## Notes\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glCopyBufferSubData` if *`readTarget`* or *`writeTarget`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glCopyBufferSubData` if zero is bound to *`readTarget`* or *`writeTarget`*.\n\n`GL_INVALID_OPERATION` is generated by `glCopyNamedBufferSubData` if *`readBuffer`* or *`writeBuffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if any of *`readOffset`*, *`writeOffset`* or *`size`* is negative, if $readOffset + size$ is greater than the size of the source buffer object (its value of `GL_BUFFER_SIZE`), or if $writeOffset + size$ is greater than the size of the destination buffer object.\n\n`GL_INVALID_VALUE` is generated if the source and destination are the same buffer object, and the ranges $\\[readOffset,readOffset+size)$ and $\\[writeOffset,writeOffset+size)$ overlap.\n\n`GL_INVALID_OPERATION` is generated if either the source or destination buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless they were mapped with the `GL_MAP_PERSISTENT` bit set in the `glMapBufferRange` *`access`* flags.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glCopyBufferSubData`         |          \\-          |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glCopyNamedBufferSubData`    |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glGetBufferSubData](glgetbuffersubdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glMapBufferRange](glmapbufferrange.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyBufferSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyBufferSubData.xhtml)"
- name: glCopyTexImage1D
  id: glcopyteximage1d.xhtml
  summary: target Specifies the target texture
  description: "## Name\n\nglCopyTexImage1D — copy pixels into a 1D texture image\n\n## C Specification\n\n`void `**`glCopyTexImage1D`**`(` GLenum `target`, GLint `level`, GLenum `internalformat`, GLint `x`, GLint `y`, GLsizei `width`, GLint `border``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target texture. Must be `GL_TEXTURE_1D`.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`internalformat`*  \nSpecifies the internal format of the texture. Must be one of the following symbolic constants: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, `GL_COMPRESSED_SRGB_ALPHA`. `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_STENCIL_INDEX8`, `GL_RED`, `GL_RG`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`.\n\n*`x`*,   *`y`*  \nSpecify the window coordinates of the left corner of the row of pixels to be copied.\n\n *`width`*  \nSpecifies the width of the texture image. The height of the texture image is 1.\n\n *`border`*  \nMust be 0.\n\n## Description\n\n`glCopyTexImage1D` defines a one-dimensional texture image with pixels from the current `GL_READ_BUFFER`.\n\nThe screen-aligned pixel row with left corner at (*x*, *y*) and with a length of *w**i**d**t**h* defines the texture array at the mipmap level specified by *`level`*. *`internalformat`* specifies the internal format of the texture array.\n\nThe pixels in the row are processed exactly as if [glReadPixels](glreadpixels.xhtml) had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range \\[0, 1\\] and then converted to the texture's internal format for storage in the texel array.\n\nPixel ordering is such that lower *x* screen coordinates correspond to lower texture coordinates.\n\nIf any of the pixels within the specified row of the current `GL_READ_BUFFER` are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined.\n\n`glCopyTexImage1D` defines a one-dimensional texture image with pixels from the current `GL_READ_BUFFER`.\n\nWhen *`internalformat`* is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the `glPixelMap` function can be used to accomplish the conversion.\n\n## Notes\n\n1, 2, 3, and 4 are not accepted values for *`internalformat`*.\n\nAn image with 0 width indicates a NULL texture.\n\n`GL_STENCIL_INDEX8` is accepted for *`internalformat`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of the allowable values.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂*max* , where *max*  is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`internalformat`* is not an allowable value.\n\n`GL_INVALID_VALUE` is generated if *`width`* is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`border`* is not 0.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32` and there is no depth buffer.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCopyTexImage1D`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexImage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexImage1D.xhtml)"
- name: glCopyTexImage2D
  id: glcopyteximage2d.xhtml
  summary: target Specifies the target texture
  description: "## Name\n\nglCopyTexImage2D — copy pixels into a 2D texture image\n\n## C Specification\n\n`void `**`glCopyTexImage2D`**`(` GLenum `target`, GLint `level`, GLenum `internalformat`, GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height`, GLint `border``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target texture. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`internalformat`*  \nSpecifies the internal format of the texture. Must be one of the following symbolic constants: `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, `GL_COMPRESSED_RGBA`. `GL_COMPRESSED_SRGB`, `GL_COMPRESSED_SRGB_ALPHA`. `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, `GL_DEPTH_COMPONENT32`, `GL_STENCIL_INDEX8`, `GL_RED`, `GL_RG`, `GL_RGB`, `GL_R3_G3_B2`, `GL_RGB4`, `GL_RGB5`, `GL_RGB8`, `GL_RGB10`, `GL_RGB12`, `GL_RGB16`, `GL_RGBA`, `GL_RGBA2`, `GL_RGBA4`, `GL_RGB5_A1`, `GL_RGBA8`, `GL_RGB10_A2`, `GL_RGBA12`, `GL_RGBA16`, `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`.\n\n*`x`*,   *`y`*  \nSpecify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.\n\n *`width`*  \nSpecifies the width of the texture image.\n\n *`height`*  \nSpecifies the height of the texture image.\n\n *`border`*  \nMust be 0.\n\n## Description\n\n`glCopyTexImage2D` defines a two-dimensional texture image, or cube-map texture image with pixels from the current `GL_READ_BUFFER`.\n\nThe screen-aligned pixel rectangle with lower left corner at (*`x`*, *`y`*) and with a width of *w**i**d**t**h* and a height of *h**e**i**g**h**t* defines the texture array at the mipmap level specified by *`level`*. *`internalformat`* specifies the internal format of the texture array.\n\nThe pixels in the rectangle are processed exactly as if [glReadPixels](glreadpixels.xhtml) had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range \\[0, 1\\] and then converted to the texture's internal format for storage in the texel array.\n\nPixel ordering is such that lower *x* and *y* screen coordinates correspond to lower *s* and *t* texture coordinates.\n\nIf any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined.\n\nWhen *`internalformat`* is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the `glPixelMap` function can be used to accomplish the conversion.\n\n## Notes\n\n1, 2, 3, and 4 are not accepted values for *`internalformat`*.\n\nAn image with height or width of 0 indicates a NULL texture.\n\n`GL_STENCIL_INDEX8` is accepted for *`internalformat`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂*max* , where *max*  is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`width`* is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`border`* is not 0.\n\n`GL_INVALID_VALUE` is generated if *`internalformat`* is not an accepted format.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32` and there is no depth buffer.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCopyTexImage2D`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexImage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexImage2D.xhtml)"
- name: glCopyTexSubImage1D
  id: glcopytexsubimage1d.xhtml
  summary: target Specifies the target to which the texture object is bound for glCopyTexSubImage1D function
  description: "## Name\n\nglCopyTexSubImage1D, glCopyTextureSubImage1D — copy a one-dimensional texture subimage\n\n## C Specification\n\n`void `**`glCopyTexSubImage1D`**`(` GLenum `target`, GLint `level`, GLint `xoffset`, GLint `x`, GLint `y`, GLsizei `width``)`;\n\n`void `**`glCopyTextureSubImage1D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `x`, GLint `y`, GLsizei `width``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glCopyTexSubImage1D` function. Must be `GL_TEXTURE_1D`.\n\n *`texture`*  \nSpecifies the texture object name for `glCopyTextureSubImage1D` function.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies the texel offset within the texture array.\n\n*`x`*,   *`y`*  \nSpecify the window coordinates of the left corner of the row of pixels to be copied.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n## Description\n\n`glCopyTexSubImage1D` and `glCopyTextureSubImage1D` replace a portion of a one-dimensional texture image with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is the case for [glTexSubImage1D](gltexsubimage1d.xhtml)). For `glCopyTexSubImage1D`, the texture object that is bound to *`target`* will be used for the process. For `glCopyTextureSubImage1D`, *`texture`* tells which texture object should be used for the purpose of the call.\n\nThe screen-aligned pixel row with left corner at (*`x`*,\\\\ *`y`*), and with length *`width`* replaces the portion of the texture array with x indices *`xoffset`* through *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive. The destination in the texture array may not include any texels outside the texture array as it was originally specified.\n\nThe pixels in the row are processed exactly as if [glReadPixels](glreadpixels.xhtml) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range \\[0, 1\\] and then converted to the texture's internal format for storage in the texel array.\n\nIt is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels within the specified row of the current `GL_READ_BUFFER` are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.\n\nNo change is made to the *internalformat* or *width* parameters of the specified texture array or to texel values outside the specified subregion.\n\n## Notes\n\nThe [glPixelStore](glpixelstore.xhtml) mode affects texture images.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glCopyTexSubImage1D` if *`target`* is not `GL_TEXTURE_1D`.\n\n`GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the object bound to `GL_READ_FRAMEBUFFER_BINDING` is not framebuffer complete.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage1D` if *`texture`* is not the name of an existing texture object, or if the effective target of *`texture`* is not `GL_TEXTURE_1D`.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage1D](glteximage1d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), or [glTexStorage1D](gltexstorage1d.xhtml) operation.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *l**e**v**e**l* \\> *log* ₂(*max* ), where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< 0, or (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> *w*, where *w* is the `GL_TEXTURE_WIDTH` of the texture image being modified.\n\n`GL_INVALID_OPERATION` is generated if:\n\n- the read buffer is `GL_NONE`, or\n\n- the value of `GL_READ_FRAMEBUFFER_BINDING` is non-zero, and:\n\n  - the read buffer selects an attachment that has no image attached, or\n\n  - the effective value of `GL_SAMPLE_BUFFERS` for the read framebuffer is one.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCopyTexSubImage1D`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glCopyTextureSubImage1D`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glReadBuffer](glreadbuffer.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage1D.xhtml)"
- name: glCopyTexSubImage2D
  id: glcopytexsubimage2d.xhtml
  summary: target Specifies the target to which the texture object is bound for glCopyTexSubImage2D function
  description: "## Name\n\nglCopyTexSubImage2D, glCopyTextureSubImage2D — copy a two-dimensional texture subimage\n\n## C Specification\n\n`void `**`glCopyTexSubImage2D`**`(` GLenum `target`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n`void `**`glCopyTextureSubImage2D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glCopyTexSubImage2D` function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_RECTANGLE`.\n\n *`texture`*  \nSpecifies the texture object name for `glCopyTextureSubImage2D` function.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`yoffset`*  \nSpecifies a texel offset in the y direction within the texture array.\n\n*`x`*,   *`y`*  \nSpecify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n *`height`*  \nSpecifies the height of the texture subimage.\n\n## Description\n\n`glCopyTexSubImage2D` and `glCopyTextureSubImage2D` replace a rectangular portion of a two-dimensional texture image, cube-map texture image, rectangular image, or a linear portion of a number of slices of a one-dimensional array texture with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is the case for [glTexSubImage2D](gltexsubimage2d.xhtml)).\n\nThe screen-aligned pixel rectangle with lower left corner at (*x*, *y*) and with width *`width`* and height *`height`* replaces the portion of the texture array with x indices *`xoffset`* through *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive, and y indices *`yoffset`* through *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive, at the mipmap level specified by *`level`*.\n\nThe pixels in the rectangle are processed exactly as if [glReadPixels](glreadpixels.xhtml) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range $\\[0,1\\]$ and then converted to the texture's internal format for storage in the texel array.\n\nThe destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.\n\nWhen *`target`* is `GL_TEXTURE_1D_ARRAY` then the y coordinate and height are treated as the start slice and number of slices to modify, respectively.\n\nIf any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.\n\nNo change is made to the *internalformat*, *width* or *height* parameters of the specified texture array, or to texel values outside the specified subregion.\n\n## Notes\n\n[glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_TEXTURE_1D_ARRAY` or `GL_RECTANGLE`.\n\n`GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the object bound to `GL_READ_FRAMEBUFFER_BINDING` is not framebuffer complete.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage2D](glteximage2d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml) or [glCopyTexImage2D](glcopyteximage2d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage2D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage2D` if the effective target of texture does not correspond to one of the texture targets supported by the function.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` is generated if the effective target is `GL_TEXTURE_RECTANGLE` and *`level`* is not zero.\n\n`GL_INVALID_VALUE` may be generated if *l**e**v**e**l* \\> *log* ₂(*max* ), where *max*  is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< 0, (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> *w*, *y**o**f**f**s**e**t* \\< 0, or (*y**o**f**f**s**e**t* + *h**e**i**g**h**t*) \\> *h*, where *w* is the `GL_TEXTURE_WIDTH` and *h* is the `GL_TEXTURE_HEIGHT` of the texture image being modified.\n\n`GL_INVALID_OPERATION` is generated if:\n\n- the read buffer is `GL_NONE`, or\n\n- the value of `GL_READ_FRAMEBUFFER_BINDING` is non-zero, and:\n\n  - the read buffer selects an attachment that has no image attached, or\n\n  - the effective value of `GL_SAMPLE_BUFFERS` for the read framebuffer is one.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCopyTexSubImage2D`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glCopyTextureSubImage2D`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glReadBuffer](glreadbuffer.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage2D.xhtml)"
- name: glCopyTexSubImage3D
  id: glcopytexsubimage3d.xhtml
  summary: target Specifies the target to which the texture object is bound for glCopyTexSubImage3D function
  description: "## Name\n\nglCopyTexSubImage3D, glCopyTextureSubImage3D — copy a three-dimensional texture subimage\n\n## C Specification\n\n`void `**`glCopyTexSubImage3D`**`(` GLenum `target`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n`void `**`glCopyTextureSubImage3D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glCopyTexSubImage3D` function. Must be `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n *`texture`*  \nSpecifies the texture object name for `glCopyTextureSubImage3D` function.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`yoffset`*  \nSpecifies a texel offset in the y direction within the texture array.\n\n *`zoffset`*  \nSpecifies a texel offset in the z direction within the texture array.\n\n*`x`*,   *`y`*  \nSpecify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n *`height`*  \nSpecifies the height of the texture subimage.\n\n## Description\n\n`glCopyTexSubImage3D` and `glCopyTextureSubImage3D` functions replace a rectangular portion of a three-dimensional or two-dimensional array texture image with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is the case for [glTexSubImage3D](gltexsubimage3d.xhtml)).\n\nThe screen-aligned pixel rectangle with lower left corner at (*`x`*, *`y`*) and with width *`width`* and height *`height`* replaces the portion of the texture array with x indices *`xoffset`* through *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive, and y indices *`yoffset`* through *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive, at z index *`zoffset`* and at the mipmap level specified by *`level`*.\n\nThe pixels in the rectangle are processed exactly as if [glReadPixels](glreadpixels.xhtml) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range \\[0, 1\\] and then converted to the texture's internal format for storage in the texel array.\n\nThe destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.\n\nIf any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.\n\nNo change is made to the *internalformat*, *width*, *height*, *depth*, or *border* parameters of the specified texture array or to texel values outside the specified subregion.\n\n## Notes\n\n[glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glCopyTexSubImage3D` if *`target`* is not `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage3D` if the effective target is not `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_CUBE_MAP`.\n\n`GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the object bound to `GL_READ_FRAMEBUFFER_BINDING` is not framebuffer complete.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage3D](glteximage3d.xhtml) or [glTexStorage3D](gltexstorage3d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage3D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *l**e**v**e**l* \\> *log* ₂(*max* ), where *max*  is the returned value of `GL_MAX_3D_TEXTURE_SIZE` if *`target`* is `GL_TEXTURE_3D` or the returned value of `GL_MAX_ARRAY_TEXTURE_LAYERS` if *`target`* is `GL_TEXTURE_2D_ARRAY`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< 0, (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> *w*, *y**o**f**f**s**e**t* \\< 0, (*y**o**f**f**s**e**t* + *h**e**i**g**h**t*) \\> *h*, *z**o**f**f**s**e**t* \\< 0, or (*z**o**f**f**s**e**t* + 1) \\> *d*, where *w* is the `GL_TEXTURE_WIDTH`, *h* is the `GL_TEXTURE_HEIGHT`, *d* is the `GL_TEXTURE_DEPTH` and of the texture image being modified. Note that *w*, *h*, and *d* include twice the border width.\n\n`GL_INVALID_OPERATION` is generated if:\n\n- the read buffer is `GL_NONE`, or\n\n- the value of `GL_READ_FRAMEBUFFER_BINDING` is non-zero, and:\n\n  - the read buffer selects an attachment that has no image attached, or\n\n  - the effective value of `GL_SAMPLE_BUFFERS` for the read framebuffer is one.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCopyTexSubImage3D`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glCopyTextureSubImage3D`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glPixelStore](glpixelstore.xhtml), [glReadBuffer](glreadbuffer.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage3D.xhtml)"
- name: glCopyTextureSubImage1D
  id: glcopytexsubimage1d.xhtml#glCopyTextureSubImage1D
  summary: Specifies the target to which the texture object is bound for glCopyTexSubImage1D function
  belongs_to: glCopyTexSubImage1D
  description: "`void `**`glCopyTextureSubImage1D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `x`, GLint `y`, GLsizei `width``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glCopyTexSubImage1D` function. Must be `GL_TEXTURE_1D`.\n\n*`texture`*\n\nSpecifies the texture object name for `glCopyTextureSubImage1D` function.\n\n*`level`*\n\nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`xoffset`*\n\nSpecifies the texel offset within the texture array.\n\n*`x`*, *`y`*\n\nSpecify the window coordinates of the left corner of the row of pixels to be copied.\n\n*`width`*\n\nSpecifies the width of the texture subimage.\n\n## Description\n\n`glCopyTexSubImage1D` and `glCopyTextureSubImage1D` replace a portion of a one-dimensional texture image with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is the case for [glTexSubImage1D](gltexsubimage1d.xhtml)). For `glCopyTexSubImage1D`, the texture object that is bound to *`target`* will be used for the process. For `glCopyTextureSubImage1D`, *`texture`* tells which texture object should be used for the purpose of the call.\n\nThe screen-aligned pixel row with left corner at (*`x`*,\\\\ *`y`*), and with length *`width`* replaces the portion of the texture array with x indices *`xoffset`* through *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive. The destination in the texture array may not include any texels outside the texture array as it was originally specified.\n\nThe pixels in the row are processed exactly as if [glReadPixels](glreadpixels.xhtml) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range \\[0, 1\\] and then converted to the texture's internal format for storage in the texel array.\n\nIt is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels within the specified row of the current `GL_READ_BUFFER` are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.\n\nNo change is made to the *internalformat* or *width* parameters of the specified texture array or to texel values outside the specified subregion.\n\n## Notes\n\nThe [glPixelStore](glpixelstore.xhtml) mode affects texture images.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glCopyTexSubImage1D` if *`target`* is not `GL_TEXTURE_1D`.\n\n`GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the object bound to `GL_READ_FRAMEBUFFER_BINDING` is not framebuffer complete.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage1D` if *`texture`* is not the name of an existing texture object, or if the effective target of *`texture`* is not `GL_TEXTURE_1D`.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage1D](glteximage1d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), or [glTexStorage1D](gltexstorage1d.xhtml) operation.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *l**e**v**e**l* \\> *log* ₂(*max* ), where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< 0, or (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> *w*, where *w* is the `GL_TEXTURE_WIDTH` of the texture image being modified.\n\n`GL_INVALID_OPERATION` is generated if:\n\n- the read buffer is `GL_NONE`, or\n\n- the value of `GL_READ_FRAMEBUFFER_BINDING` is non-zero, and:\n\n  - the read buffer selects an attachment that has no image attached, or\n\n  - the effective value of `GL_SAMPLE_BUFFERS` for the read framebuffer is one.\n\n## Associated Gets\n\n[ glGetTexImage ](glgetteximage.xhtml)\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glCopyTexSubImage1D`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glCopyTextureSubImage1D`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glReadBuffer](glreadbuffer.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage1D.xhtml)"
- name: glCopyTextureSubImage2D
  id: glcopytexsubimage2d.xhtml#glCopyTextureSubImage2D
  summary: Specifies the target to which the texture object is bound for glCopyTexSubImage2D function
  belongs_to: glCopyTexSubImage2D
  description: "`void `**`glCopyTextureSubImage2D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glCopyTexSubImage2D` function. Must be `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_RECTANGLE`.\n\n*`texture`*\n\nSpecifies the texture object name for `glCopyTextureSubImage2D` function.\n\n*`level`*\n\nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`xoffset`*\n\nSpecifies a texel offset in the x direction within the texture array.\n\n*`yoffset`*\n\nSpecifies a texel offset in the y direction within the texture array.\n\n*`x`*, *`y`*\n\nSpecify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.\n\n*`width`*\n\nSpecifies the width of the texture subimage.\n\n*`height`*\n\nSpecifies the height of the texture subimage.\n\n## Description\n\n`glCopyTexSubImage2D` and `glCopyTextureSubImage2D` replace a rectangular portion of a two-dimensional texture image, cube-map texture image, rectangular image, or a linear portion of a number of slices of a one-dimensional array texture with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is the case for [glTexSubImage2D](gltexsubimage2d.xhtml)).\n\nThe screen-aligned pixel rectangle with lower left corner at (*x*, *y*) and with width *`width`* and height *`height`* replaces the portion of the texture array with x indices *`xoffset`* through *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive, and y indices *`yoffset`* through *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive, at the mipmap level specified by *`level`*.\n\nThe pixels in the rectangle are processed exactly as if [glReadPixels](glreadpixels.xhtml) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range $\\[0,1\\]$ and then converted to the texture's internal format for storage in the texel array.\n\nThe destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.\n\nWhen *`target`* is `GL_TEXTURE_1D_ARRAY` then the y coordinate and height are treated as the start slice and number of slices to modify, respectively.\n\nIf any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.\n\nNo change is made to the *internalformat*, *width* or *height* parameters of the specified texture array, or to texel values outside the specified subregion.\n\n## Notes\n\n[glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_TEXTURE_1D_ARRAY` or `GL_RECTANGLE`.\n\n`GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the object bound to `GL_READ_FRAMEBUFFER_BINDING` is not framebuffer complete.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage2D](glteximage2d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml) or [glCopyTexImage2D](glcopyteximage2d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage2D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage2D` if the effective target of texture does not correspond to one of the texture targets supported by the function.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` is generated if the effective target is `GL_TEXTURE_RECTANGLE` and *`level`* is not zero.\n\n`GL_INVALID_VALUE` may be generated if *l**e**v**e**l* \\> *log* ₂(*max* ), where *max*  is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< 0, (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> *w*, *y**o**f**f**s**e**t* \\< 0, or (*y**o**f**f**s**e**t* + *h**e**i**g**h**t*) \\> *h*, where *w* is the `GL_TEXTURE_WIDTH` and *h* is the `GL_TEXTURE_HEIGHT` of the texture image being modified.\n\n`GL_INVALID_OPERATION` is generated if:\n\n- the read buffer is `GL_NONE`, or\n\n- the value of `GL_READ_FRAMEBUFFER_BINDING` is non-zero, and:\n\n  - the read buffer selects an attachment that has no image attached, or\n\n  - the effective value of `GL_SAMPLE_BUFFERS` for the read framebuffer is one.\n\n## Associated Gets\n\n[ glGetTexImage ](glgetteximage.xhtml)\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glCopyTexSubImage2D`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glCopyTextureSubImage2D`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glReadBuffer](glreadbuffer.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage2D.xhtml)"
- name: glCopyTextureSubImage3D
  id: glcopytexsubimage3d.xhtml#glCopyTextureSubImage3D
  summary: Specifies the target to which the texture object is bound for glCopyTexSubImage3D function
  belongs_to: glCopyTexSubImage3D
  description: "`void `**`glCopyTextureSubImage3D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glCopyTexSubImage3D` function. Must be `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n*`texture`*\n\nSpecifies the texture object name for `glCopyTextureSubImage3D` function.\n\n*`level`*\n\nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`xoffset`*\n\nSpecifies a texel offset in the x direction within the texture array.\n\n*`yoffset`*\n\nSpecifies a texel offset in the y direction within the texture array.\n\n*`zoffset`*\n\nSpecifies a texel offset in the z direction within the texture array.\n\n*`x`*, *`y`*\n\nSpecify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.\n\n*`width`*\n\nSpecifies the width of the texture subimage.\n\n*`height`*\n\nSpecifies the height of the texture subimage.\n\n## Description\n\n`glCopyTexSubImage3D` and `glCopyTextureSubImage3D` functions replace a rectangular portion of a three-dimensional or two-dimensional array texture image with pixels from the current `GL_READ_BUFFER` (rather than from main memory, as is the case for [glTexSubImage3D](gltexsubimage3d.xhtml)).\n\nThe screen-aligned pixel rectangle with lower left corner at (*`x`*, *`y`*) and with width *`width`* and height *`height`* replaces the portion of the texture array with x indices *`xoffset`* through *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive, and y indices *`yoffset`* through *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive, at z index *`zoffset`* and at the mipmap level specified by *`level`*.\n\nThe pixels in the rectangle are processed exactly as if [glReadPixels](glreadpixels.xhtml) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range \\[0, 1\\] and then converted to the texture's internal format for storage in the texel array.\n\nThe destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.\n\nIf any of the pixels within the specified rectangle of the current `GL_READ_BUFFER` are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.\n\nNo change is made to the *internalformat*, *width*, *height*, *depth*, or *border* parameters of the specified texture array or to texel values outside the specified subregion.\n\n## Notes\n\n[glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glCopyTexSubImage3D` if *`target`* is not `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage3D` if the effective target is not `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_CUBE_MAP`.\n\n`GL_INVALID_FRAMEBUFFER_OPERATION` is generated if the object bound to `GL_READ_FRAMEBUFFER_BINDING` is not framebuffer complete.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage3D](glteximage3d.xhtml) or [glTexStorage3D](gltexstorage3d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated by `glCopyTextureSubImage3D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *l**e**v**e**l* \\> *log* ₂(*max* ), where *max*  is the returned value of `GL_MAX_3D_TEXTURE_SIZE` if *`target`* is `GL_TEXTURE_3D` or the returned value of `GL_MAX_ARRAY_TEXTURE_LAYERS` if *`target`* is `GL_TEXTURE_2D_ARRAY`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< 0, (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> *w*, *y**o**f**f**s**e**t* \\< 0, (*y**o**f**f**s**e**t* + *h**e**i**g**h**t*) \\> *h*, *z**o**f**f**s**e**t* \\< 0, or (*z**o**f**f**s**e**t* + 1) \\> *d*, where *w* is the `GL_TEXTURE_WIDTH`, *h* is the `GL_TEXTURE_HEIGHT`, *d* is the `GL_TEXTURE_DEPTH` and of the texture image being modified. Note that *w*, *h*, and *d* include twice the border width.\n\n`GL_INVALID_OPERATION` is generated if:\n\n- the read buffer is `GL_NONE`, or\n\n- the value of `GL_READ_FRAMEBUFFER_BINDING` is non-zero, and:\n\n  - the read buffer selects an attachment that has no image attached, or\n\n  - the effective value of `GL_SAMPLE_BUFFERS` for the read framebuffer is one.\n\n## Associated Gets\n\n[ glGetTexImage ](glgetteximage.xhtml)\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glCopyTexSubImage3D`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glCopyTextureSubImage3D`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glPixelStore](glpixelstore.xhtml), [glReadBuffer](glreadbuffer.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCopyTexSubImage3D.xhtml)"
- name: glCreateBuffers
  id: glcreatebuffers.xhtml
  summary: n Specifies the number of buffer objects to create
  description: "## Name\n\nglCreateBuffers — create buffer objects\n\n## C Specification\n\n`void `**`glCreateBuffers`**`(` GLsizei `n`, GLuint \\*`buffers``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of buffer objects to create.\n\n *`buffers`*  \nSpecifies an array in which names of the new buffer objects are stored.\n\n## Description\n\n`glCreateBuffers` returns *`n`* previously unused buffer names in *`buffers`*, each representing a new buffer object initialized as if it had been bound to an unspecified target.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateBuffers`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glGet](glget.xhtml), [glIsBuffer](glisbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateBuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateBuffers.xhtml)"
- name: glCreateFramebuffers
  id: glcreateframebuffers.xhtml
  summary: n Number of framebuffer objects to create
  description: "## Name\n\nglCreateFramebuffers — create framebuffer objects\n\n## C Specification\n\n`void `**`glCreateFramebuffers`**`(` GLsizei `n`, GLuint \\*`framebuffers``)`;\n\n## Parameters\n\n *`n`*  \nNumber of framebuffer objects to create.\n\n *`framebuffers`*  \nSpecifies an array in which names of the new framebuffer objects are stored.\n\n## Description\n\n`glCreateFramebuffers` returns *`n`* previously unused framebuffer names in *`framebuffers`*, each representing a new framebuffer object initialized to the default state.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateFramebuffers`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml), `glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`, [glFramebufferTextureLayer](glframebuffertexturelayer.xhtml), [glDeleteFramebuffers](gldeleteframebuffers.xhtml), [glIsFramebuffer](glisframebuffer.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateFramebuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateFramebuffers.xhtml)"
- name: glCreateProgram
  id: glcreateprogram.xhtml
  summary: glCreateProgram creates an empty program object and returns a non-zero value by which it can be referenced
  description: "## Name\n\nglCreateProgram — Creates a program object\n\n## C Specification\n\n`GLuint `**`glCreateProgram`**`(` `void``)`;\n\n## Description\n\n`glCreateProgram` creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program. It also provides a means for checking the compatibility of the shaders that will be used to create a program (for instance, checking the compatibility between a vertex shader and a fragment shader). When no longer needed as part of a program object, shader objects can be detached.\n\nOne or more executables are created in a program object by successfully attaching shader objects to it with [glAttachShader](glattachshader.xhtml), successfully compiling the shader objects with [glCompileShader](glcompileshader.xhtml), and successfully linking the program object with [glLinkProgram](gllinkprogram.xhtml). These executables are made part of current state when [glUseProgram](gluseprogram.xhtml) is called. Program objects can be deleted by calling [glDeleteProgram](gldeleteprogram.xhtml). The memory associated with the program object will be deleted when it is no longer part of current rendering state for any context.\n\n## Notes\n\nLike buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.\n\nApplications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.\n\n## Errors\n\nThis function returns 0 if an error occurs creating the program object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with the argument `GL_CURRENT_PROGRAM`\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with a valid program object and the index of an active attribute variable\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with a valid program object and the index of an active uniform variable\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with a valid program object\n\n[glGetAttribLocation](glgetattriblocation.xhtml) with a valid program object and the name of an attribute variable\n\n[glGetProgram](glgetprogram.xhtml) with a valid program object and the parameter to be queried\n\n[glGetProgramInfoLog](glgetprograminfolog.xhtml) with a valid program object\n\n[glGetUniform](glgetuniform.xhtml) with a valid program object and the location of a uniform variable\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with a valid program object and the name of a uniform variable\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateProgram`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glAttachShader](glattachshader.xhtml), [glBindAttribLocation](glbindattriblocation.xhtml), [glCreateShader](glcreateshader.xhtml), [glDeleteProgram](gldeleteprogram.xhtml), [glDetachShader](gldetachshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glUniform](gluniform.xhtml), [glUseProgram](gluseprogram.xhtml), [glValidateProgram](glvalidateprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateProgram.xhtml)"
- name: glCreateProgramPipelines
  id: glcreateprogrampipelines.xhtml
  summary: n Number of program pipeline objects to create
  description: "## Name\n\nglCreateProgramPipelines — create program pipeline objects\n\n## C Specification\n\n`void `**`glCreateProgramPipelines`**`(` GLsizei `n`, GLuint \\*`pipelines``)`;\n\n## Parameters\n\n *`n`*  \nNumber of program pipeline objects to create.\n\n *`pipelines`*  \nSpecifies an array in which names of the new program pipeline objects are stored.\n\n## Description\n\n`glCreateProgramPipelines` returns *`n`* previously unused program pipeline names in *`pipelines`*, each representing a new program pipeline object initialized to the default state.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateProgramPipelines`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindProgramPipeline](glbindprogrampipeline.xhtml), [glCreateShader](glcreateshader.xhtml), [glCreateProgram](glcreateprogram.xhtml), [glCompileShader](glcompileshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glGenProgramPipelines](glgenprogrampipelines.xhtml), [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml), [glIsProgramPipeline](glisprogrampipeline.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateProgramPipelines.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateProgramPipelines.xhtml)"
- name: glCreateQueries
  id: glcreatequeries.xhtml
  summary: target Specifies the target of each created query object
  description: "## Name\n\nglCreateQueries — create query objects\n\n## C Specification\n\n`void `**`glCreateQueries`**`(` GLenum `target`, GLsizei `n`, GLuint \\*`ids``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target of each created query object.\n\n *`n`*  \nNumber of query objects to create.\n\n *`ids`*  \nSpecifies an array in which names of the new query objects are stored.\n\n## Description\n\n`glCreateQueries` returns *`n`* previously unused query object names in *`ids`*, each representing a new query object with the specified *`target`*.\n\n*`target`* may be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_TIME_ELAPSED`, `GL_TIMESTAMP`, `GL_PRIMITIVES_GENERATED` or `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateQueries`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBeginQuery](glbeginquery.xhtml), [glBeginQueryIndexed](glbeginqueryindexed.xhtml), [glDeleteQueries](gldeletequeries.xhtml), `glEndQuery`, [glGenQueries](glgenqueries.xhtml), [glGetQueryObject](glgetqueryobject.xhtml), [glGetQueryiv](glgetqueryiv.xhtml), [glIsQuery](glisquery.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateQueries.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateQueries.xhtml)"
- name: glCreateRenderbuffers
  id: glcreaterenderbuffers.xhtml
  summary: n Number of renderbuffer objects to create
  description: "## Name\n\nglCreateRenderbuffers — create renderbuffer objects\n\n## C Specification\n\n`void `**`glCreateRenderbuffers`**`(` GLsizei `n`, GLuint \\*`renderbuffers``)`;\n\n## Parameters\n\n *`n`*  \nNumber of renderbuffer objects to create.\n\n *`renderbuffers`*  \nSpecifies an array in which names of the new renderbuffer objects are stored.\n\n## Description\n\n`glCreateRenderbuffers` returns *`n`* previously unused renderbuffer object names in *`renderbuffers`*, each representing a new renderbuffer object initialized to the default state.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateRenderbuffers`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindRenderbuffer](glbindrenderbuffer.xhtml), [glDeleteRenderbuffers](gldeleterenderbuffers.xhtml), [glGenRenderbuffers](glgenrenderbuffers.xhtml), [glIsRenderbuffer](glisrenderbuffer.xhtml), [glRenderbufferStorage](glrenderbufferstorage.xhtml), [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateRenderbuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateRenderbuffers.xhtml)"
- name: glCreateSamplers
  id: glcreatesamplers.xhtml
  summary: n Number of sampler objects to create
  description: "## Name\n\nglCreateSamplers — create sampler objects\n\n## C Specification\n\n`void `**`glCreateSamplers`**`(` GLsizei `n`, GLuint \\*`samplers``)`;\n\n## Parameters\n\n *`n`*  \nNumber of sampler objects to create.\n\n *`samplers`*  \nSpecifies an array in which names of the new sampler objects are stored.\n\n## Description\n\n`glCreateSamplers` returns *`n`* previously unused sampler names in *`samplers`*, each representing a new sampler object initialized to the default state.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateSamplers`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindSampler](glbindsampler.xhtml), [glBindTexture](glbindtexture.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml), [glDeleteTextures](gldeletetextures.xhtml), [glGenSamplers](glgensamplers.xhtml), [glGenTextures](glgentextures.xhtml), [glGet](glget.xhtml), [glGetSamplerParameter](glgetsamplerparameter.xhtml), [glSamplerParameter](glsamplerparameter.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateSamplers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateSamplers.xhtml)"
- name: glCreateShader
  id: glcreateshader.xhtml
  summary: shaderType Specifies the type of shader to be created
  description: "## Name\n\nglCreateShader — Creates a shader object\n\n## C Specification\n\n`GLuint `**`glCreateShader`**`(` GLenum `shaderType``)`;\n\n## Parameters\n\n *`shaderType`*  \nSpecifies the type of shader to be created. Must be one of `GL_COMPUTE_SHADER`, `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER`, or `GL_FRAGMENT_SHADER`.\n\n## Description\n\n`glCreateShader` creates an empty shader object and returns a non-zero value by which it can be referenced. A shader object is used to maintain the source code strings that define a shader. *`shaderType`* indicates the type of shader to be created. Five types of shader are supported. A shader of type `GL_COMPUTE_SHADER` is a shader that is intended to run on the programmable compute processor. A shader of type `GL_VERTEX_SHADER` is a shader that is intended to run on the programmable vertex processor. A shader of type `GL_TESS_CONTROL_SHADER` is a shader that is intended to run on the programmable tessellation processor in the control stage. A shader of type `GL_TESS_EVALUATION_SHADER` is a shader that is intended to run on the programmable tessellation processor in the evaluation stage. A shader of type `GL_GEOMETRY_SHADER` is a shader that is intended to run on the programmable geometry processor. A shader of type `GL_FRAGMENT_SHADER` is a shader that is intended to run on the programmable fragment processor.\n\nWhen created, a shader object's `GL_SHADER_TYPE` parameter is set to either `GL_COMPUTE_SHADER`, `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`, depending on the value of *`shaderType`*.\n\n## Notes\n\nLike buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.\n\nApplications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.\n\n`GL_COMPUTE_SHADER` is available only if the GL version is 4.3 or higher.\n\n## Errors\n\nThis function returns 0 if an error occurs creating the shader object.\n\n`GL_INVALID_ENUM` is generated if *`shaderType`* is not an accepted value.\n\n## Associated Gets\n\n[glGetShader](glgetshader.xhtml) with a valid shader object and the parameter to be queried\n\n[glGetShaderInfoLog](glgetshaderinfolog.xhtml) with a valid shader object\n\n[glGetShaderSource](glgetshadersource.xhtml) with a valid shader object\n\n[ glIsShader ](glisshader.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateShader`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glAttachShader](glattachshader.xhtml), [glCompileShader](glcompileshader.xhtml), [glDeleteShader](gldeleteshader.xhtml), [glDetachShader](gldetachshader.xhtml), [glShaderSource](glshadersource.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateShader.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateShader.xhtml)"
- name: glCreateShaderProgram
  id: glcreateshaderprogram.xhtml
  summary: type Specifies the type of shader to create
  description: "## Name\n\nglCreateShaderProgramv — create a stand-alone program from an array of null-terminated source code strings\n\n## C Specification\n\n`GLuint `**`glCreateShaderProgramv`**`(` GLenum `type`, GLsizei `count`, const char \\*\\*`strings``)`;\n\n## Parameters\n\n *`type`*  \nSpecifies the type of shader to create.\n\n *`count`*  \nSpecifies the number of source code strings in the array *`strings`*.\n\n *`strings`*  \nSpecifies the address of an array of pointers to source code strings from which to create the program object.\n\n## Description\n\n`glCreateShaderProgram` creates a program object containing compiled and linked shaders for a single stage specified by *`type`*. *`strings`* refers to an array of *`count`* strings from which to create the shader executables.\n\n`glCreateShaderProgram` is equivalent (assuming no errors are generated) to:\n\n``` programlisting\n    const GLuint shader = glCreateShader(type);\n    if (shader) {\n        glShaderSource(shader, count, strings, NULL);\n        glCompileShader(shader);\n        const GLuint program = glCreateProgram();\n        if (program) {\n            GLint compiled = GL_FALSE;\n            glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n            glProgramParameteri(program, GL_PROGRAM_SEPARABLE, GL_TRUE);\n            if (compiled) {\n                glAttachShader(program, shader);\n                glLinkProgram(program);\n                glDetachShader(program, shader);\n            }\n            /* append-shader-info-log-to-program-info-log */\n        }\n        glDeleteShader(shader);\n        return program;\n    } else {\n        return 0;\n    }\n```\n\nThe program object created by `glCreateShaderProgram` has its `GL_PROGRAM_SEPARABLE` status set to `GL_TRUE`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`type`* is not an accepted shader type.\n\n`GL_INVALID_VALUE` is generated if *`count`* is negative.\n\nOther errors are generated if the supplied shader code fails to compile and link, as described for the commands in the pseudocode sequence above, but all such errors are generated without any side effects of executing those commands.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateShaderProgramv`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateShader](glcreateshader.xhtml), [glCreateProgram](glcreateprogram.xhtml), [glCompileShader](glcompileshader.xhtml), [glLinkProgram](gllinkprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateShaderProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateShaderProgram.xhtml)"
- name: glCreateShaderProgramv
  id: glcreateshaderprogram.xhtml#glCreateShaderProgramv
  summary: Specifies the type of shader to create
  belongs_to: glCreateShaderProgram
  description: "`GLuint `**`glCreateShaderProgramv`**`(` GLenum `type`, GLsizei `count`, const char \\*\\*`strings``)`;\n\n## Parameters\n\n*`type`*\n\nSpecifies the type of shader to create.\n\n*`count`*\n\nSpecifies the number of source code strings in the array *`strings`*.\n\n*`strings`*\n\nSpecifies the address of an array of pointers to source code strings from which to create the program object.\n\n## Description\n\n`glCreateShaderProgram` creates a program object containing compiled and linked shaders for a single stage specified by *`type`*. *`strings`* refers to an array of *`count`* strings from which to create the shader executables.\n\n`glCreateShaderProgram` is equivalent (assuming no errors are generated) to:\n\n``` programlisting\n    const GLuint shader = glCreateShader(type);\n    if (shader) {\n        glShaderSource(shader, count, strings, NULL);\n        glCompileShader(shader);\n        const GLuint program = glCreateProgram();\n        if (program) {\n            GLint compiled = GL_FALSE;\n            glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n            glProgramParameteri(program, GL_PROGRAM_SEPARABLE, GL_TRUE);\n            if (compiled) {\n                glAttachShader(program, shader);\n                glLinkProgram(program);\n                glDetachShader(program, shader);\n            }\n            /* append-shader-info-log-to-program-info-log */\n        }\n        glDeleteShader(shader);\n        return program;\n    } else {\n        return 0;\n    }\n```\n\nThe program object created by `glCreateShaderProgram` has its `GL_PROGRAM_SEPARABLE` status set to `GL_TRUE`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`type`* is not an accepted shader type.\n\n`GL_INVALID_VALUE` is generated if *`count`* is negative.\n\nOther errors are generated if the supplied shader code fails to compile and link, as described for the commands in the pseudocode sequence above, but all such errors are generated without any side effects of executing those commands.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glCreateShaderProgramv`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glCreateShader](glcreateshader.xhtml), [glCreateProgram](glcreateprogram.xhtml), [glCompileShader](glcompileshader.xhtml), [glLinkProgram](gllinkprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateShaderProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateShaderProgram.xhtml)"
- name: glCreateTextures
  id: glcreatetextures.xhtml
  summary: target Specifies the effective texture target of each created texture
  description: "## Name\n\nglCreateTextures — create texture objects\n\n## C Specification\n\n`void `**`glCreateTextures`**`(` GLenum `target`, GLsizei `n`, GLuint \\*`textures``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the effective texture target of each created texture.\n\n *`n`*  \nNumber of texture objects to create.\n\n *`textures`*  \nSpecifies an array in which names of the new texture objects are stored.\n\n## Description\n\n`glCreateTextures` returns *`n`* previously unused texture names in *`textures`*, each representing a new texture object of the dimensionality and type specified by *`target`* and initialized to the default values for that texture type.\n\n*`target`* must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of the allowable values.\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateTextures`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindTexture](glbindtexture.xhtml), [glDeleteTextures](gldeletetextures.xhtml), [glGenTextures](glgentextures.xhtml), [glGet](glget.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glIsTexture](glistexture.xhtml), [glTexBuffer](gltexbuffer.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage2DMultisample](glteximage2dmultisample.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexImage3DMultisample](glteximage3dmultisample.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateTextures.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateTextures.xhtml)"
- name: glCreateTransformFeedbacks
  id: glcreatetransformfeedbacks.xhtml
  summary: n Number of transform feedback objects to create
  description: "## Name\n\nglCreateTransformFeedbacks — create transform feedback objects\n\n## C Specification\n\n`void `**`glCreateTransformFeedbacks`**`(` GLsizei `n`, GLuint \\*`ids``)`;\n\n## Parameters\n\n *`n`*  \nNumber of transform feedback objects to create.\n\n *`ids`*  \nSpecifies an array in which names of the new transform feedback objects are stored.\n\n## Description\n\n`glCreateTransformFeedbacks` returns *`n`* previously unused transform feedback object names in *`ids`*, each representing a new transform feedback object initialized to the default state.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateTransformFeedbacks` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBeginTransformFeedback](glbegintransformfeedback.xhtml), [glBindTransformFeedback](glbindtransformfeedback.xhtml), [glDeleteTransformFeedbacks](gldeletetransformfeedbacks.xhtml), `glEndTransformFeedback`, [glGenTransformFeedbacks](glgentransformfeedbacks.xhtml), [glIsTransformFeedback](glistransformfeedback.xhtml), [glPauseTransformFeedback](glpausetransformfeedback.xhtml), [glResumeTransformFeedback](glresumetransformfeedback.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateTransformFeedbacks.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateTransformFeedbacks.xhtml)"
- name: glCreateVertexArrays
  id: glcreatevertexarrays.xhtml
  summary: n Number of vertex array objects to create
  description: "## Name\n\nglCreateVertexArrays — create vertex array objects\n\n## C Specification\n\n`void `**`glCreateVertexArrays`**`(` GLsizei `n`, GLuint \\*`arrays``)`;\n\n## Parameters\n\n *`n`*  \nNumber of vertex array objects to create.\n\n *`arrays`*  \nSpecifies an array in which names of the new vertex array objects are stored.\n\n## Description\n\n`glCreateVertexArrays` returns *`n`* previously unused vertex array object names in *`arrays`*, each representing a new vertex array object initialized to the default state.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCreateVertexArrays`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindVertexArray](glbindvertexarray.xhtml), [glDeleteVertexArrays](gldeletevertexarrays.xhtml) [glEnableVertexAttribArray](glenablevertexattribarray.xhtml) [glGenVertexArrays](glgenvertexarrays.xhtml), [glIsVertexArray](glisvertexarray.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateVertexArrays.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCreateVertexArrays.xhtml)"
- name: glCullFace
  id: glcullface.xhtml
  summary: mode Specifies whether front- or back-facing facets are candidates for culling
  description: "## Name\n\nglCullFace — specify whether front- or back-facing facets can be culled\n\n## C Specification\n\n`void `**`glCullFace`**`(` GLenum `mode``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies whether front- or back-facing facets are candidates for culling. Symbolic constants `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_BACK`.\n\n## Description\n\n`glCullFace` specifies whether front- or back-facing facets are culled (as specified by *mode*) when facet culling is enabled. Facet culling is initially disabled. To enable and disable facet culling, call the [glEnable](glenable.xhtml) and `glDisable` commands with the argument `GL_CULL_FACE`. Facets include triangles, quadrilaterals, polygons, and rectangles.\n\n[glFrontFace](glfrontface.xhtml) specifies which of the clockwise and counterclockwise facets are front-facing and back-facing. See [glFrontFace](glfrontface.xhtml).\n\n## Notes\n\nIf *`mode`* is `GL_FRONT_AND_BACK`, no facets are drawn, but other primitives such as points and lines are drawn.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n## Associated Gets\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_CULL_FACE`\n\n[glGet](glget.xhtml) with argument `GL_CULL_FACE_MODE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glCullFace`                |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glEnable](glenable.xhtml), [glFrontFace](glfrontface.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glCullFace.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glCullFace.xhtml)"
- name: glDebugMessageCallback
  id: gldebugmessagecallback.xhtml
  summary: callback The address of a callback function that will be called when a debug message is generated
  description: "## Name\n\nglDebugMessageCallback — specify a callback to receive debugging messages from the GL\n\n## C Specification\n\n`void `**`glDebugMessageCallback`**`(` DEBUGPROC `callback`, const void \\* `userParam``)`;\n\n## Parameters\n\n *`callback`*  \nThe address of a callback function that will be called when a debug message is generated.\n\n *`userParam`*  \nA user supplied pointer that will be passed on each invocation of *`callback`*.\n\n## Description\n\n`glDebugMessageCallback` sets the current debug output callback function to the function whose address is given in *`callback`*. The callback function should have the following prototype (in C), or be otherwise compatible with such a prototype:\n\n``` programlisting\n        typedef void (APIENTRY *DEBUGPROC)(GLenum source,\n            GLenum type,\n            GLuint id,\n            GLenum severity,\n            GLsizei length,\n            const GLchar *message,\n            const void *userParam);\n```\n\nThis function is defined to have the same calling convention as the GL API functions. In most cases this is defined as `APIENTRY`, although it will vary depending on platform, language and compiler.\n\nEach time a debug message is generated the debug callback function will be invoked with *`source`*, *`type`*, *`id`*, and *`severity`* associated with the message, and *`length`* set to the length of debug message whose character string is in the array pointed to by *`message`*. *`userParam`* will be set to the value passed in the *`userParam`* parameter to the most recent call to `glDebugMessageCallback`.\n\n## Notes\n\nWhen the GL is in use remotely, the server may not be able to call functions in the client's address space. In such cases, the callback function may not be invoked and the user should retrieve debug messages from the context's debug message log by calling [glGetDebugMessageLog](glgetdebugmessagelog.xhtml).\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDebugMessageCallback`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDebugMessageControl](gldebugmessagecontrol.xhtml), [glDebugMessageInsert](gldebugmessageinsert.xhtml), [glGetDebugMessageLog](glgetdebugmessagelog.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDebugMessageCallback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDebugMessageCallback.xhtml)"
- name: glDebugMessageControl
  id: gldebugmessagecontrol.xhtml
  summary: source The source of debug messages to enable or disable
  description: "## Name\n\nglDebugMessageControl — control the reporting of debug messages in a debug context\n\n## C Specification\n\n`void `**`glDebugMessageControl`**`(` GLenum `source`, GLenum `type`, GLenum `severity`, GLsizei `count`, const GLuint \\*`ids`, GLboolean `enabled``)`;\n\n## Parameters\n\n *`source`*  \nThe source of debug messages to enable or disable.\n\n *`type`*  \nThe type of debug messages to enable or disable.\n\n *`severity`*  \nThe severity of debug messages to enable or disable.\n\n *`count`*  \nThe length of the array *`ids`*.\n\n *`ids`*  \nThe address of an array of unsigned integers contianing the ids of the messages to enable or disable.\n\n *`enabled`*  \nA Boolean flag determining whether the selected messages should be enabled or disabled.\n\n## Description\n\n`glDebugMessageControl` controls the reporting of debug messages generated by a debug context. The parameters *`source`*, *`type`* and *`severity`* form a filter to select messages from the pool of potential messages generated by the GL.\n\n*`source`* may be `GL_DEBUG_SOURCE_API`, `GL_DEBUG_SOURCE_WINDOW_SYSTEM_`, `GL_DEBUG_SOURCE_SHADER_COMPILER`, `GL_DEBUG_SOURCE_THIRD_PARTY`, `GL_DEBUG_SOURCE_APPLICATION`, `GL_DEBUG_SOURCE_OTHER` to select messages generated by usage of the GL API, the window system, the shader compiler, third party tools or libraries, explicitly by the application or by some other source, respectively. It may also take the value `GL_DONT_CARE`. If *`source`* is not `GL_DONT_CARE` then only messages whose source matches *`source`* will be referenced.\n\n*`type`* may be one of `GL_DEBUG_TYPE_ERROR`, `GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR`, `GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR`, `GL_DEBUG_TYPE_PORTABILITY`, `GL_DEBUG_TYPE_PERFORMANCE`, `GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, or `GL_DEBUG_TYPE_OTHER` to indicate the type of messages describing GL errors, attempted use of deprecated features, triggering of undefined behavior, portability issues, performance notifications, markers, group push and pop events, and other types of messages, respectively. It may also take the value `GL_DONT_CARE`. If *`type`* is not `GL_DONT_CARE` then only messages whose type matches *`type`* will be referenced.\n\n*`severity`* may be one of `GL_DEBUG_SEVERITY_LOW`, `GL_DEBUG_SEVERITY_MEDIUM`, or `GL_DEBUG_SEVERITY_HIGH` to select messages of low, medium or high severity messages or to `GL_DEBUG_SEVERITY_NOTIFICATION` for notifications. It may also take the value `GL_DONT_CARE`. If *`severity`* is not `GL_DONT_CARE` then only messages whose severity matches *`severity`* will be referenced.\n\n*`ids`* contains a list of *`count`* message identifiers to select specific messages from the pool of available messages. If *`count`* is zero then the value of *`ids`* is ignored. Otherwise, only messages appearing in this list are selected. In this case, *`source`* and *`type`* may not be `GL_DONT_CARE` and *`severity`* must be `GL_DONT_CARE`.\n\nIf *`enabled`* is `GL_TRUE` then messages that match the filter formed by *`source`*, *`type`*, *`severity`* and *`ids`* are enabled. Otherwise, those messages are disabled.\n\n## Notes\n\nAlthough debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug context may produce no messages at all.\n\n`GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, and `GL_DEBUG_SEVERITY_NOTIFICATION` are available only if the GL version is 4.3 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`count`* is negative.\n\n`GL_INVALID_ENUM` is generated if any of *`source`*, *`type`* or *`severity`* is not one of the accepted interface types.\n\n`GL_INVALID_OPERATION` is generated if *`count`* is non-zero and either *`source`* or *`type`* is `GL_DONT_CARE` or if *`severity`* is not `GL_DONT_CARE`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDebugMessageControl`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDebugMessageInsert](gldebugmessageinsert.xhtml), [glDebugMessageCallback](gldebugmessagecallback.xhtml), [glGetDebugMessageLog](glgetdebugmessagelog.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDebugMessageControl.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDebugMessageControl.xhtml)"
- name: glDebugMessageInsert
  id: gldebugmessageinsert.xhtml
  summary: source The source of the debug message to insert
  description: "## Name\n\nglDebugMessageInsert — inject an application-supplied message into the debug message queue\n\n## C Specification\n\n`void `**`glDebugMessageInsert`**`(` GLenum `source`, GLenum `type`, GLuint `id`, GLenum `severity`, GLsizei `length`, const char \\*`message``)`;\n\n## Parameters\n\n *`source`*  \nThe source of the debug message to insert.\n\n *`type`*  \nThe type of the debug message insert.\n\n *`id`*  \nThe user-supplied identifier of the message to insert.\n\n *`severity`*  \nThe severity of the debug messages to insert.\n\n *`length`*  \nThe length string contained in the character array whose address is given by *`message`*.\n\n *`message`*  \nThe address of a character array containing the message to insert.\n\n## Description\n\n`glDebugMessageInsert` inserts a user-supplied message into the debug output queue. *`source`* specifies the source that will be used to classify the message and must be `GL_DEBUG_SOURCE_APPLICATION` or `GL_DEBUG_SOURCE_THIRD_PARTY`. All other sources are reserved for use by the GL implementation. *`type`* indicates the type of the message to be inserted and may be one of `GL_DEBUG_TYPE_ERROR`, `GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR`, `GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR`, `GL_DEBUG_TYPE_PORTABILITY`, `GL_DEBUG_TYPE_PERFORMANCE`, `GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, or `GL_DEBUG_TYPE_OTHER`. *`severity`* indicates the severity of the message and may be `GL_DEBUG_SEVERITY_LOW`, `GL_DEBUG_SEVERITY_MEDIUM`, `GL_DEBUG_SEVERITY_HIGH` or `GL_DEBUG_SEVERITY_NOTIFICATION`. *`id`* is available for application defined use and may be any value. This value will be recorded and used to identify the message.\n\n*`length`* contains a count of the characters in the character array whose address is given in *`message`*. If *`length`* is negative then *`message`* is treated as a null-terminated string. The length of the message, whether specified explicitly or implicitly, must be less than or equal to the implementation defined constant `GL_MAX_DEBUG_MESSAGE_LENGTH`.\n\n## Notes\n\n`GL_DEBUG_TYPE_MARKER`, `GL_DEBUG_TYPE_PUSH_GROUP`, `GL_DEBUG_TYPE_POP_GROUP`, and `GL_DEBUG_SEVERITY_NOTIFICATION` are available only if the GL version is 4.3 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if any of *`source`*, *`type`* or *`severity`* is not one of the accepted interface types.\n\n`GL_INVALID_VALUE` is generated if the length of the message is greater than the value of `GL_MAX_DEBUG_MESSAGE_LENGTH`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDebugMessageInsert`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDebugMessageControl](gldebugmessagecontrol.xhtml), [glDebugMessageCallback](gldebugmessagecallback.xhtml), [glGetDebugMessageLog](glgetdebugmessagelog.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDebugMessageInsert.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDebugMessageInsert.xhtml)"
- name: glDeleteBuffers
  id: gldeletebuffers.xhtml
  summary: n Specifies the number of buffer objects to be deleted
  description: "## Name\n\nglDeleteBuffers — delete named buffer objects\n\n## C Specification\n\n`void `**`glDeleteBuffers`**`(` GLsizei `n`, const GLuint \\* `buffers``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of buffer objects to be deleted.\n\n *`buffers`*  \nSpecifies an array of buffer objects to be deleted.\n\n## Description\n\n`glDeleteBuffers` deletes *`n`* buffer objects named by the elements of the array *`buffers`*. After a buffer object is deleted, it has no contents, and its name is free for reuse (for example by [glGenBuffers](glgenbuffers.xhtml)). If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any buffer object).\n\n`glDeleteBuffers` silently ignores 0's and names that do not correspond to existing buffer objects.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Associated Gets\n\n[glIsBuffer](glisbuffer.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteBuffers`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glGenBuffers](glgenbuffers.xhtml), [glGet](glget.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteBuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteBuffers.xhtml)"
- name: glDeleteFramebuffers
  id: gldeleteframebuffers.xhtml
  summary: n Specifies the number of framebuffer objects to be deleted
  description: "## Name\n\nglDeleteFramebuffers — delete framebuffer objects\n\n## C Specification\n\n`void `**`glDeleteFramebuffers`**`(` GLsizei `n`, GLuint \\*`framebuffers``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of framebuffer objects to be deleted.\n\n *`framebuffers`*  \nA pointer to an array containing *`n`* framebuffer objects to be deleted.\n\n## Description\n\n`glDeleteFramebuffers` deletes the *`n`* framebuffer objects whose names are stored in the array addressed by *`framebuffers`*. The name zero is reserved by the GL and is silently ignored, should it occur in *`framebuffers`*, as are other unused names. Once a framebuffer object is deleted, its name is again unused and it has no attachments. If a framebuffer that is currently bound to one or more of the targets `GL_DRAW_FRAMEBUFFER` or `GL_READ_FRAMEBUFFER` is deleted, it is as though [glBindFramebuffer](glbindframebuffer.xhtml) had been executed with the corresponding *`target`* and *`framebuffer`* zero.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteFramebuffers`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml), [glCheckFramebufferStatus](glcheckframebufferstatus.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteFramebuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteFramebuffers.xhtml)"
- name: glDeleteProgram
  id: gldeleteprogram.xhtml
  summary: program Specifies the program object to be deleted
  description: "## Name\n\nglDeleteProgram — Deletes a program object\n\n## C Specification\n\n`void `**`glDeleteProgram`**`(` GLuint `program``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to be deleted.\n\n## Description\n\n`glDeleteProgram` frees the memory and invalidates the name associated with the program object specified by *`program.`* This command effectively undoes the effects of a call to [glCreateProgram](glcreateprogram.xhtml).\n\nIf a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted until it is no longer part of current state for any rendering context. If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached but not deleted unless they have already been flagged for deletion by a previous call to [glDeleteShader](gldeleteshader.xhtml). A value of 0 for *`program`* will be silently ignored.\n\nTo determine whether a program object has been flagged for deletion, call [glGetProgram](glgetprogram.xhtml) with arguments *`program`* and `GL_DELETE_STATUS`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_CURRENT_PROGRAM`\n\n[glGetProgram](glgetprogram.xhtml) with arguments *`program`* and `GL_DELETE_STATUS`\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteProgram`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateShader](glcreateshader.xhtml), [glDetachShader](gldetachshader.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteProgram.xhtml)"
- name: glDeleteProgramPipelines
  id: gldeleteprogrampipelines.xhtml
  summary: n Specifies the number of program pipeline objects to delete
  description: "## Name\n\nglDeleteProgramPipelines — delete program pipeline objects\n\n## C Specification\n\n`void `**`glDeleteProgramPipelines`**`(` GLsizei `n`, const GLuint \\*`pipelines``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of program pipeline objects to delete.\n\n *`pipelines`*  \nSpecifies an array of names of program pipeline objects to delete.\n\n## Description\n\n`glDeleteProgramPipelines` deletes the *`n`* program pipeline objects whose names are stored in the array *`pipelines`*. Unused names in *`pipelines`* are ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused and it has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts to zero and no program pipeline object becomes current.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_PROGRAM_PIPELINE_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteProgramPipelines`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenProgramPipelines](glgenprogrampipelines.xhtml), [glBindProgramPipeline](glbindprogrampipeline.xhtml), [glIsProgramPipeline](glisprogrampipeline.xhtml), [glUseProgramStages](gluseprogramstages.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteProgramPipelines.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteProgramPipelines.xhtml)"
- name: glDeleteQueries
  id: gldeletequeries.xhtml
  summary: n Specifies the number of query objects to be deleted
  description: "## Name\n\nglDeleteQueries — delete named query objects\n\n## C Specification\n\n`void `**`glDeleteQueries`**`(` GLsizei `n`, const GLuint \\* `ids``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of query objects to be deleted.\n\n *`ids`*  \nSpecifies an array of query objects to be deleted.\n\n## Description\n\n`glDeleteQueries` deletes *`n`* query objects named by the elements of the array *`ids`*. After a query object is deleted, it has no contents, and its name is free for reuse (for example by [glGenQueries](glgenqueries.xhtml)).\n\n`glDeleteQueries` silently ignores 0's and names that do not correspond to existing query objects.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Associated Gets\n\n[glIsQuery](glisquery.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteQueries`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBeginQuery](glbeginquery.xhtml), `glEndQuery`, [glGenQueries](glgenqueries.xhtml), [glGetQueryiv](glgetqueryiv.xhtml), [glGetQueryObject](glgetqueryobject.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteQueries.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteQueries.xhtml)"
- name: glDeleteRenderbuffers
  id: gldeleterenderbuffers.xhtml
  summary: n Specifies the number of renderbuffer objects to be deleted
  description: "## Name\n\nglDeleteRenderbuffers — delete renderbuffer objects\n\n## C Specification\n\n`void `**`glDeleteRenderbuffers`**`(` GLsizei `n`, GLuint \\*`renderbuffers``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of renderbuffer objects to be deleted.\n\n *`renderbuffers`*  \nA pointer to an array containing *`n`* renderbuffer objects to be deleted.\n\n## Description\n\n`glDeleteRenderbuffers` deletes the *`n`* renderbuffer objects whose names are stored in the array addressed by *`renderbuffers`*. The name zero is reserved by the GL and is silently ignored, should it occur in *`renderbuffers`*, as are other unused names. Once a renderbuffer object is deleted, its name is again unused and it has no contents. If a renderbuffer that is currently bound to the target `GL_RENDERBUFFER` is deleted, it is as though [glBindRenderbuffer](glbindrenderbuffer.xhtml) had been executed with a *`target`* of `GL_RENDERBUFFER` and a *`name`* of zero.\n\nIf a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml) had been called, with a *`renderbuffer`* of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words, this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. Note that the renderbuffer image is specifically *not* detached from any non-bound framebuffers.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteRenderbuffers`     |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenRenderbuffers](glgenrenderbuffers.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glRenderbufferStorage](glrenderbufferstorage.xhtml), [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteRenderbuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteRenderbuffers.xhtml)"
- name: glDeleteSamplers
  id: gldeletesamplers.xhtml
  summary: n Specifies the number of sampler objects to be deleted
  description: "## Name\n\nglDeleteSamplers — delete named sampler objects\n\n## C Specification\n\n`void `**`glDeleteSamplers`**`(` GLsizei `n`, const GLuint \\* `samplers``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of sampler objects to be deleted.\n\n *`samplers`*  \nSpecifies an array of sampler objects to be deleted.\n\n## Description\n\n`glDeleteSamplers` deletes *`n`* sampler objects named by the elements of the array *`samplers`*. After a sampler object is deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as though [glBindSampler](glbindsampler.xhtml) is called with unit set to the unit the sampler is bound to and sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.\n\n## Notes\n\n`glDeleteSamplers` is available only if the GL version is 3.3 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Associated Gets\n\n[glIsSampler](glissampler.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteSamplers`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenSamplers](glgensamplers.xhtml), [glBindSampler](glbindsampler.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml), [glIsSampler](glissampler.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteSamplers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteSamplers.xhtml)"
- name: glDeleteShader
  id: gldeleteshader.xhtml
  summary: shader Specifies the shader object to be deleted
  description: "## Name\n\nglDeleteShader — Deletes a shader object\n\n## C Specification\n\n`void `**`glDeleteShader`**`(` GLuint `shader``)`;\n\n## Parameters\n\n *`shader`*  \nSpecifies the shader object to be deleted.\n\n## Description\n\n`glDeleteShader` frees the memory and invalidates the name associated with the shader object specified by *`shader`*. This command effectively undoes the effects of a call to [glCreateShader](glcreateshader.xhtml).\n\nIf a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted). A value of 0 for *`shader`* will be silently ignored.\n\nTo determine whether an object has been flagged for deletion, call [glGetShader](glgetshader.xhtml) with arguments *`shader`* and `GL_DELETE_STATUS`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`shader`* is not a value generated by OpenGL.\n\n## Associated Gets\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with the program object to be queried\n\n[glGetShader](glgetshader.xhtml) with arguments *`shader`* and `GL_DELETE_STATUS`\n\n[ glIsShader ](glisshader.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteShader`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateProgram](glcreateprogram.xhtml), [glCreateShader](glcreateshader.xhtml), [glDetachShader](gldetachshader.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteShader.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteShader.xhtml)"
- name: glDeleteSync
  id: gldeletesync.xhtml
  summary: sync The sync object to be deleted
  description: "## Name\n\nglDeleteSync — delete a sync object\n\n## C Specification\n\n`void `**`glDeleteSync`**`(` GLsync `sync``)`;\n\n## Parameters\n\n *`sync`*  \nThe sync object to be deleted.\n\n## Description\n\n`glDeleteSync` deletes the sync object specified by *`sync`*. If the fence command corresponding to the specified sync object has completed, or if no [glWaitSync](glwaitsync.xhtml) or [glClientWaitSync](glclientwaitsync.xhtml) commands are blocking on *`sync`*, the object is deleted immediately. Otherwise, *`sync`* is flagged for deletion and will be deleted when it is no longer associated with any fence command and is no longer blocking any [glWaitSync](glwaitsync.xhtml) or [glClientWaitSync](glclientwaitsync.xhtml) command. In either case, after `glDeleteSync` returns, the name *`sync`* is invalid and can no longer be used to refer to the sync object.\n\n`glDeleteSync` will silently ignore a *`sync`* value of zero.\n\n## Notes\n\n`glSync` is only supported if the GL version is 3.2 or greater, or if the `ARB_sync` extension is supported.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`sync`* is neither zero or the name of a sync object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteSync`              |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glFenceSync](glfencesync.xhtml), [glWaitSync](glwaitsync.xhtml), [glClientWaitSync](glclientwaitsync.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteSync.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteSync.xhtml)"
- name: glDeleteTextures
  id: gldeletetextures.xhtml
  summary: n Specifies the number of textures to be deleted
  description: "## Name\n\nglDeleteTextures — delete named textures\n\n## C Specification\n\n`void `**`glDeleteTextures`**`(` GLsizei `n`, const GLuint \\* `textures``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of textures to be deleted.\n\n *`textures`*  \nSpecifies an array of textures to be deleted.\n\n## Description\n\n`glDeleteTextures` deletes *`n`* textures named by the elements of the array *`textures`*. After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by [glGenTextures](glgentextures.xhtml)). If a texture that is currently bound is deleted, the binding reverts to 0 (the default texture).\n\n`glDeleteTextures` silently ignores 0's and names that do not correspond to existing textures.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Associated Gets\n\n[glIsTexture](glistexture.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteTextures`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindTexture](glbindtexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glGenTextures](glgentextures.xhtml), [glGet](glget.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteTextures.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteTextures.xhtml)"
- name: glDeleteTransformFeedbacks
  id: gldeletetransformfeedbacks.xhtml
  summary: n Specifies the number of transform feedback objects to delete
  description: "## Name\n\nglDeleteTransformFeedbacks — delete transform feedback objects\n\n## C Specification\n\n`void `**`glDeleteTransformFeedbacks`**`(` GLsizei `n`, const GLuint \\*`ids``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of transform feedback objects to delete.\n\n *`ids`*  \nSpecifies an array of names of transform feedback objects to delete.\n\n## Description\n\n`glDeleteTransformFeedbacks` deletes the *`n`* transform feedback objects whose names are stored in the array *`ids`*. Unused names in *`ids`* are ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but the underlying object is not deleted until it is no longer active.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_TRANSFORM_FEEDBACK_BINDING`\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteTransformFeedbacks` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenTransformFeedbacks](glgentransformfeedbacks.xhtml), [glBindTransformFeedback](glbindtransformfeedback.xhtml), [glIsTransformFeedback](glistransformfeedback.xhtml), [glBeginTransformFeedback](glbegintransformfeedback.xhtml), [glPauseTransformFeedback](glpausetransformfeedback.xhtml), [glResumeTransformFeedback](glresumetransformfeedback.xhtml), `glEndTransformFeedback`\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteTransformFeedbacks.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteTransformFeedbacks.xhtml)"
- name: glDeleteVertexArrays
  id: gldeletevertexarrays.xhtml
  summary: n Specifies the number of vertex array objects to be deleted
  description: "## Name\n\nglDeleteVertexArrays — delete vertex array objects\n\n## C Specification\n\n`void `**`glDeleteVertexArrays`**`(` GLsizei `n`, const GLuint \\*`arrays``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of vertex array objects to be deleted.\n\n *`arrays`*  \nSpecifies the address of an array containing the *`n`* names of the objects to be deleted.\n\n## Description\n\n`glDeleteVertexArrays` deletes *`n`* vertex array objects whose names are stored in the array addressed by *`arrays`*. Once a vertex array object is deleted it has no contents and its name is again unused. If a vertex array object that is currently bound is deleted, the binding for that object reverts to zero and the default vertex array becomes current. Unused names in *`arrays`* are silently ignored, as is the value zero.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDeleteVertexArrays`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenVertexArrays](glgenvertexarrays.xhtml), [glIsVertexArray](glisvertexarray.xhtml), [glBindVertexArray](glbindvertexarray.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteVertexArrays.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDeleteVertexArrays.xhtml)"
- name: glDepthFunc
  id: gldepthfunc.xhtml
  summary: func Specifies the depth comparison function
  description: "## Name\n\nglDepthFunc — specify the value used for depth buffer comparisons\n\n## C Specification\n\n`void `**`glDepthFunc`**`(` GLenum `func``)`;\n\n## Parameters\n\n *`func`*  \nSpecifies the depth comparison function. Symbolic constants `GL_NEVER`, `GL_LESS`, `GL_EQUAL`, `GL_LEQUAL`, `GL_GREATER`, `GL_NOTEQUAL`, `GL_GEQUAL`, and `GL_ALWAYS` are accepted. The initial value is `GL_LESS`.\n\n## Description\n\n`glDepthFunc` specifies the function used to compare each incoming pixel depth value with the depth value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See [glEnable](glenable.xhtml) and `glDisable` of `GL_DEPTH_TEST`.)\n\n*`func`* specifies the conditions under which the pixel will be drawn. The comparison functions are as follows:\n\n `GL_NEVER`  \nNever passes.\n\n `GL_LESS`  \nPasses if the incoming depth value is less than the stored depth value.\n\n `GL_EQUAL`  \nPasses if the incoming depth value is equal to the stored depth value.\n\n `GL_LEQUAL`  \nPasses if the incoming depth value is less than or equal to the stored depth value.\n\n `GL_GREATER`  \nPasses if the incoming depth value is greater than the stored depth value.\n\n `GL_NOTEQUAL`  \nPasses if the incoming depth value is not equal to the stored depth value.\n\n `GL_GEQUAL`  \nPasses if the incoming depth value is greater than or equal to the stored depth value.\n\n `GL_ALWAYS`  \nAlways passes.\n\nThe initial value of *`func`* is `GL_LESS`. Initially, depth testing is disabled. If depth testing is disabled or if no depth buffer exists, it is as if the depth test always passes.\n\n## Notes\n\nEven if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to `GL_ALWAYS`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`func`* is not an accepted value.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_FUNC`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_DEPTH_TEST`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDepthFunc`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDepthRange](gldepthrange.xhtml), [glEnable](glenable.xhtml), [glPolygonOffset](glpolygonoffset.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthFunc.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthFunc.xhtml)"
- name: glDepthMask
  id: gldepthmask.xhtml
  summary: flag Specifies whether the depth buffer is enabled for writing
  description: "## Name\n\nglDepthMask — enable or disable writing into the depth buffer\n\n## C Specification\n\n`void `**`glDepthMask`**`(` GLboolean `flag``)`;\n\n## Parameters\n\n *`flag`*  \nSpecifies whether the depth buffer is enabled for writing. If *`flag`* is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.\n\n## Description\n\n`glDepthMask` specifies whether the depth buffer is enabled for writing. If *`flag`* is `GL_FALSE`, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_WRITEMASK`\n\n## Notes\n\nEven if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to `GL_ALWAYS` (see [glDepthFunc](gldepthfunc.xhtml)).\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDepthMask`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glColorMask](glcolormask.xhtml), [glDepthFunc](gldepthfunc.xhtml), [glDepthRange](gldepthrange.xhtml), [glStencilMask](glstencilmask.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthMask.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthMask.xhtml)"
- name: glDepthRange
  id: gldepthrange.xhtml
  summary: nearVal Specifies the mapping of the near clipping plane to window coordinates
  description: "## Name\n\nglDepthRange — specify mapping of depth values from normalized device coordinates to window coordinates\n\n## C Specification\n\n`void `**`glDepthRange`**`(` GLdouble `nearVal`, GLdouble `farVal``)`;\n\n`void `**`glDepthRangef`**`(` GLfloat `nearVal`, GLfloat `farVal``)`;\n\n## Parameters\n\n *`nearVal`*  \nSpecifies the mapping of the near clipping plane to window coordinates. The initial value is 0.\n\n *`farVal`*  \nSpecifies the mapping of the far clipping plane to window coordinates. The initial value is 1.\n\n## Description\n\nAfter clipping and division by *w*, depth coordinates range from −1 to 1, corresponding to the near and far clipping planes. `glDepthRange` specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by `glDepthRange` are both clamped to this range before they are accepted.\n\nThe setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.\n\n## Notes\n\nIt is not necessary that *`nearVal`* be less than *`farVal`*. Reverse mappings such as *n**e**a**r**V**a**l* = 1, and *f**a**r**V**a**l* = 0 are acceptable.\n\nThe type of the *`nearVal`* and *`farVal`* parameters was changed from GLclampf to GLfloat for `glDepthRangef` and from GLclampd to GLdouble for `glDepthRange`. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_RANGE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDepthRange`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glDepthRangef`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDepthFunc](gldepthfunc.xhtml), [glPolygonOffset](glpolygonoffset.xhtml), [glViewport](glviewport.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRange.xhtml)"
- name: glDepthRangeArray
  id: gldepthrangearray.xhtml
  summary: first Specifies the index of the first viewport whose depth range to update
  description: "## Name\n\nglDepthRangeArray — specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports\n\n## C Specification\n\n`void `**`glDepthRangeArrayv`**`(` GLuint `first`, GLsizei `count`, const GLdouble \\*`v``)`;\n\n## Parameters\n\n *`first`*  \nSpecifies the index of the first viewport whose depth range to update.\n\n *`count`*  \nSpecifies the number of viewports whose depth range to update.\n\n *`v`*  \nSpecifies the address of an array containing the near and far values for the depth range of each modified viewport.\n\n## Description\n\nAfter clipping and division by *w*, depth coordinates range from −1 to 1, corresponding to the near and far clipping planes. Each viewport has an independent depth range specified as a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). `glDepthRangeArray` specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates for each viewport in the range \\[*`first`*, *`first`* + *`count`*). Thus, the values accepted by `glDepthRangeArray` are both clamped to this range before they are accepted.\n\nThe *`first`* parameter specifies the index of the first viewport whose depth range to modify and must be less than the value of `GL_MAX_VIEWPORTS`. *`count`* specifies the number of viewports whose depth range to modify. *`first`* + *`count`* must be less than or equal to the value of `GL_MAX_VIEWPORTS`. *`v`* specifies the address of an array of pairs of double precision floating point values representing the near and far values of the depth range for each viewport, in that order.\n\nThe setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.\n\n## Notes\n\nIt is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as *n**e**a**r* = 1, and *f**a**r* = 0 are acceptable.\n\nThe type of the *`v`* parameter was changed from GLclampd to GLdouble. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`first`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if *`first`* + *`count`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_RANGE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDepthRangeArrayv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDepthFunc](gldepthfunc.xhtml), [glDepthRange](gldepthrange.xhtml), [glDepthRangeIndexed](gldepthrangeindexed.xhtml), [glPolygonOffset](glpolygonoffset.xhtml), [glViewportArray](glviewportarray.xhtml), [glViewport](glviewport.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRangeArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRangeArray.xhtml)"
- name: glDepthRangeArrayv
  id: gldepthrangearray.xhtml#glDepthRangeArrayv
  summary: Specifies the index of the first viewport whose depth range to update
  belongs_to: glDepthRangeArray
  description: "`void `**`glDepthRangeArrayv`**`(` GLuint `first`, GLsizei `count`, const GLdouble \\*`v``)`;\n\n## Parameters\n\n*`first`*\n\nSpecifies the index of the first viewport whose depth range to update.\n\n*`count`*\n\nSpecifies the number of viewports whose depth range to update.\n\n*`v`*\n\nSpecifies the address of an array containing the near and far values for the depth range of each modified viewport.\n\n## Description\n\nAfter clipping and division by *w*, depth coordinates range from −1 to 1, corresponding to the near and far clipping planes. Each viewport has an independent depth range specified as a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). `glDepthRangeArray` specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates for each viewport in the range \\[*`first`*, *`first`* + *`count`*). Thus, the values accepted by `glDepthRangeArray` are both clamped to this range before they are accepted.\n\nThe *`first`* parameter specifies the index of the first viewport whose depth range to modify and must be less than the value of `GL_MAX_VIEWPORTS`. *`count`* specifies the number of viewports whose depth range to modify. *`first`* + *`count`* must be less than or equal to the value of `GL_MAX_VIEWPORTS`. *`v`* specifies the address of an array of pairs of double precision floating point values representing the near and far values of the depth range for each viewport, in that order.\n\nThe setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.\n\n## Notes\n\nIt is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as *n**e**a**r* = 1, and *f**a**r* = 0 are acceptable.\n\nThe type of the *`v`* parameter was changed from GLclampd to GLdouble. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`first`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if *`first`* + *`count`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_RANGE`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glDepthRangeArrayv`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glDepthFunc](gldepthfunc.xhtml), [glDepthRange](gldepthrange.xhtml), [glDepthRangeIndexed](gldepthrangeindexed.xhtml), [glPolygonOffset](glpolygonoffset.xhtml), [glViewportArray](glviewportarray.xhtml), [glViewport](glviewport.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRangeArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRangeArray.xhtml)"
- name: glDepthRangef
  id: gldepthrange.xhtml#glDepthRangef
  summary: Specifies the mapping of the near clipping plane to window coordinates
  belongs_to: glDepthRange
  description: "`void `**`glDepthRangef`**`(` GLfloat `nearVal`, GLfloat `farVal``)`;\n\n## Parameters\n\n*`nearVal`*\n\nSpecifies the mapping of the near clipping plane to window coordinates. The initial value is 0.\n\n*`farVal`*\n\nSpecifies the mapping of the far clipping plane to window coordinates. The initial value is 1.\n\n## Description\n\nAfter clipping and division by *w*, depth coordinates range from −1 to 1, corresponding to the near and far clipping planes. `glDepthRange` specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by `glDepthRange` are both clamped to this range before they are accepted.\n\nThe setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.\n\n## Notes\n\nIt is not necessary that *`nearVal`* be less than *`farVal`*. Reverse mappings such as *n**e**a**r**V**a**l* = 1, and *f**a**r**V**a**l* = 0 are acceptable.\n\nThe type of the *`nearVal`* and *`farVal`* parameters was changed from GLclampf to GLfloat for `glDepthRangef` and from GLclampd to GLdouble for `glDepthRange`. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_RANGE`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glDepthRange`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glDepthRangef`               |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glDepthFunc](gldepthfunc.xhtml), [glPolygonOffset](glpolygonoffset.xhtml), [glViewport](glviewport.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRange.xhtml)"
- name: glDepthRangeIndexed
  id: gldepthrangeindexed.xhtml
  summary: index Specifies the index of the viewport whose depth range to update
  description: "## Name\n\nglDepthRangeIndexed — specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport\n\n## C Specification\n\n`void `**`glDepthRangeIndexed`**`(` GLuint `index`, GLdouble `nearVal`, GLdouble `farVal``)`;\n\n## Parameters\n\n *`index`*  \nSpecifies the index of the viewport whose depth range to update.\n\n *`nearVal`*  \nSpecifies the mapping of the near clipping plane to window coordinates. The initial value is 0.\n\n *`farVal`*  \nSpecifies the mapping of the far clipping plane to window coordinates. The initial value is 1.\n\n## Description\n\nAfter clipping and division by *w*, depth coordinates range from −1 to 1, corresponding to the near and far clipping planes. Each viewport has an independent depth range specified as a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). `glDepthRangeIndexed` specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates for a specified viewport. Thus, the values accepted by `glDepthRangeIndexed` are both clamped to this range before they are accepted.\n\nThe *`index`* parameter specifies the index of first viewport whose depth range to modify and must be less than the value of `GL_MAX_VIEWPORTS`. *`nearVal`* and *`farVal`* specify near and far values of the depth range for the specified viewport, respectively.\n\nThe setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.\n\n## Notes\n\nIt is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as *n**e**a**r**V**a**l* = 1, and *f**a**r**V**a**l* = 0 are acceptable.\n\nThe type of the *`nearVal`* and *`farVal`* parameters was changed from GLclampd to GLdouble. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEPTH_RANGE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDepthRangeIndexed`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDepthFunc](gldepthfunc.xhtml), [glDepthRange](gldepthrange.xhtml), [glDepthRangeArray](gldepthrangearray.xhtml), [glPolygonOffset](glpolygonoffset.xhtml), [glViewportArray](glviewportarray.xhtml), [glViewport](glviewport.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRangeIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDepthRangeIndexed.xhtml)"
- name: glDetachShader
  id: gldetachshader.xhtml
  summary: program Specifies the program object from which to detach the shader object
  description: "## Name\n\nglDetachShader — Detaches a shader object from a program object to which it is attached\n\n## C Specification\n\n`void `**`glDetachShader`**`(` GLuint `program`, GLuint `shader``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object from which to detach the shader object.\n\n *`shader`*  \nSpecifies the shader object to be detached.\n\n## Description\n\n`glDetachShader` detaches the shader object specified by *`shader`* from the program object specified by *`program`*. This command can be used to undo the effect of the command [glAttachShader](glattachshader.xhtml).\n\nIf *`shader`* has already been flagged for deletion by a call to [glDeleteShader](gldeleteshader.xhtml) and it is not attached to any other program object, it will be deleted after it has been detached.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if either *`program`* or *`shader`* is a value that was not generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* is not a shader object.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* is not attached to *`program`*.\n\n## Associated Gets\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with the handle of a valid program object\n\n[glGetShader](glgetshader.xhtml) with arguments *`shader`* and `GL_DELETE_STATUS`\n\n[ glIsProgram ](glisprogram.xhtml)\n\n[ glIsShader ](glisshader.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDetachShader`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[ glAttachShader ](glattachshader.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDetachShader.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDetachShader.xhtml)"
- name: glDisable
  id: glenable.xhtml#glDisable
  summary: null
  belongs_to: glEnable
  description: '`void `**`glDisable`**`(` GLenum `cap``)`;'
- name: glDisablei
  id: glenable.xhtml#glDisablei
  summary: Specifies a symbolic constant indicating a GL capability
  belongs_to: glEnable
  description: "`void `**`glDisablei`**`(` GLenum `cap`, GLuint `index``)`;\n\n## Parameters\n\n*`cap`*\n\nSpecifies a symbolic constant indicating a GL capability.\n\n*`index`*\n\nSpecifies the index of the switch to disable (for `glEnablei` and `glDisablei` only).\n\n## Description\n\n`glEnable` and `glDisable` enable and disable various capabilities. Use [glIsEnabled](glisenabled.xhtml) or [glGet](glget.xhtml) to determine the current setting of any capability. The initial value for each capability with the exception of `GL_DITHER` and `GL_MULTISAMPLE` is `GL_FALSE`. The initial value for `GL_DITHER` and `GL_MULTISAMPLE` is `GL_TRUE`.\n\nBoth `glEnable` and `glDisable` take a single argument, *`cap`*, which can assume one of the following values:\n\nSome of the GL's capabilities are indexed. `glEnablei` and `glDisablei` enable and disable indexed capabilities.\n\n`GL_BLEND`\n\nIf enabled, blend the computed fragment color values with the values in the color buffers. See [glBlendFunc](glblendfunc.xhtml).\n\n`GL_CLIP_DISTANCE` *i*\n\nIf enabled, clip geometry against user-defined half space *i*.\n\n`GL_COLOR_LOGIC_OP`\n\nIf enabled, apply the currently selected logical operation to the computed fragment color and color buffer values. See [glLogicOp](gllogicop.xhtml).\n\n`GL_CULL_FACE`\n\nIf enabled, cull polygons based on their winding in window coordinates. See [glCullFace](glcullface.xhtml).\n\n`GL_DEBUG_OUTPUT`\n\nIf enabled, debug messages are produced by a debug context. When disabled, the debug message log is silenced. Note that in a non-debug context, very few, if any messages might be produced, even when `GL_DEBUG_OUTPUT` is enabled.\n\n`GL_DEBUG_OUTPUT_SYNCHRONOUS`\n\nIf enabled, debug messages are produced synchronously by a debug context. If disabled, debug messages may be produced asynchronously. In particular, they may be delayed relative to the execution of GL commands, and the debug callback function may be called from a thread other than that in which the commands are executed. See [glDebugMessageCallback](gldebugmessagecallback.xhtml).\n\n`GL_DEPTH_CLAMP`\n\nIf enabled, the −*w*_(*c*) ≤ *z*_(*c*) ≤ *w*_(*c*) plane equation is ignored by view volume clipping (effectively, there is no near or far plane clipping). See [glDepthRange](gldepthrange.xhtml).\n\n`GL_DEPTH_TEST`\n\nIf enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See [glDepthFunc](gldepthfunc.xhtml) and [glDepthRange](gldepthrange.xhtml).\n\n`GL_DITHER`\n\nIf enabled, dither color components or indices before they are written to the color buffer.\n\n`GL_FRAMEBUFFER_SRGB`\n\nIf enabled and the value of `GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING` for the framebuffer attachment corresponding to the destination buffer is `GL_SRGB`, the R, G, and B destination color values (after conversion from fixed-point to floating-point) are considered to be encoded for the sRGB color space and hence are linearized prior to their use in blending.\n\n`GL_LINE_SMOOTH`\n\nIf enabled, draw lines with correct filtering. Otherwise, draw aliased lines. See [glLineWidth](gllinewidth.xhtml).\n\n`GL_MULTISAMPLE`\n\nIf enabled, use multiple fragment samples in computing the final color of a pixel. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n`GL_POLYGON_OFFSET_FILL`\n\nIf enabled, and if the polygon is rendered in `GL_FILL` mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n`GL_POLYGON_OFFSET_LINE`\n\nIf enabled, and if the polygon is rendered in `GL_LINE` mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n`GL_POLYGON_OFFSET_POINT`\n\nIf enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the polygon is rendered in `GL_POINT` mode. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n`GL_POLYGON_SMOOTH`\n\nIf enabled, draw polygons with proper filtering. Otherwise, draw aliased polygons. For correct antialiased polygons, an alpha buffer is needed and the polygons must be sorted front to back.\n\n`GL_PRIMITIVE_RESTART`\n\nEnables primitive restarting. If enabled, any one of the draw commands which transfers a set of generic attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the primitive restart index. See [glPrimitiveRestartIndex](glprimitiverestartindex.xhtml).\n\n`GL_PRIMITIVE_RESTART_FIXED_INDEX`\n\nEnables primitive restarting with a fixed index. If enabled, any one of the draw commands which transfers a set of generic attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the fixed primitive index for the specified index type. The fixed index is equal to 2^(*n*) − 1 where *n* is equal to 8 for `GL_UNSIGNED_BYTE`, 16 for `GL_UNSIGNED_SHORT` and 32 for `GL_UNSIGNED_INT`.\n\n`GL_RASTERIZER_DISCARD`\n\nIf enabled, primitives are discarded after the optional transform feedback stage, but before rasterization. Furthermore, when enabled, [glClear](glclear.xhtml), [glClearBufferData](glclearbufferdata.xhtml), [glClearBufferSubData](glclearbuffersubdata.xhtml), [glClearTexImage](glclearteximage.xhtml), and [glClearTexSubImage](glcleartexsubimage.xhtml) are ignored.\n\n`GL_SAMPLE_ALPHA_TO_COVERAGE`\n\nIf enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location. The temporary coverage value is then ANDed with the fragment coverage value.\n\n`GL_SAMPLE_ALPHA_TO_ONE`\n\nIf enabled, each sample alpha value is replaced by the maximum representable alpha value.\n\n`GL_SAMPLE_COVERAGE`\n\nIf enabled, the fragment's coverage is ANDed with the temporary coverage value. If `GL_SAMPLE_COVERAGE_INVERT` is set to `GL_TRUE`, invert the coverage value. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n`GL_SAMPLE_SHADING`\n\nIf enabled, the active fragment shader is run once for each covered sample, or at fraction of this rate as determined by the current value of `GL_MIN_SAMPLE_SHADING_VALUE`. See [glMinSampleShading](glminsampleshading.xhtml).\n\n`GL_SAMPLE_MASK`\n\nIf enabled, the sample coverage mask generated for a fragment during rasterization will be ANDed with the value of `GL_SAMPLE_MASK_VALUE` before shading occurs. See [glSampleMaski](glsamplemaski.xhtml).\n\n`GL_SCISSOR_TEST`\n\nIf enabled, discard fragments that are outside the scissor rectangle. See [glScissor](glscissor.xhtml).\n\n`GL_STENCIL_TEST`\n\nIf enabled, do stencil testing and update the stencil buffer. See [glStencilFunc](glstencilfunc.xhtml) and [glStencilOp](glstencilop.xhtml).\n\n`GL_TEXTURE_CUBE_MAP_SEAMLESS`\n\nIf enabled, cubemap textures are sampled such that when linearly sampling from the border between two adjacent faces, texels from both faces are used to generate the final sample value. When disabled, texels from only a single face are used to construct the final sample value.\n\n`GL_PROGRAM_POINT_SIZE`\n\nIf enabled and a vertex or geometry shader is active, then the derived point size is taken from the (potentially clipped) shader builtin `gl_PointSize` and clamped to the implementation-dependent point size range.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`cap`* is not one of the values listed previously.\n\n`GL_INVALID_VALUE` is generated by `glEnablei` and `glDisablei` if *`index`* is greater than or equal to the number of indexed capabilities for *`cap`*.\n\n## Notes\n\n`GL_PRIMITIVE_RESTART` is available only if the GL version is 3.1 or greater.\n\n`GL_TEXTURE_CUBE_MAP_SEAMLESS` is available only if the GL version is 3.2 or greater.\n\n`GL_PRIMITIVE_RESTART_FIXED_INDEX` is available only if the GL version is 4.3 or greater.\n\n`GL_DEBUG_OUTPUT` and `GL_DEBUG_OUTPUT_SYNCHRONOUS` are available only if the GL version is 4.3 or greater.\n\nAny token accepted by `glEnable` or `glDisable` is also accepted by `glEnablei` and `glDisablei`, but if the capability is not indexed, the maximum value that *`index`* may take is zero.\n\nIn general, passing an indexed capability to `glEnable` or `glDisable` will enable or disable that capability for all indices, resepectively.\n\n## Associated Gets\n\n[ glIsEnabled ](glisenabled.xhtml)\n\n[ glGet ](glget.xhtml)\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glDisable`                   |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glDisablei`                  |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glEnable`                    |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glEnablei`                   |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glBlendFunc](glblendfunc.xhtml), [glCullFace](glcullface.xhtml), [glDepthFunc](gldepthfunc.xhtml), [glDepthRange](gldepthrange.xhtml), [glGet](glget.xhtml), [glIsEnabled](glisenabled.xhtml), [glLineWidth](gllinewidth.xhtml), [glLogicOp](gllogicop.xhtml), [glPointSize](glpointsize.xhtml), [glPolygonMode](glpolygonmode.xhtml), [glPolygonOffset](glpolygonoffset.xhtml), [glSampleCoverage](glsamplecoverage.xhtml), [glScissor](glscissor.xhtml), [glStencilFunc](glstencilfunc.xhtml), [glStencilOp](glstencilop.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glEnable.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glEnable.xhtml)"
- name: glDisableVertexArrayAttrib
  id: glenablevertexattribarray.xhtml#glDisableVertexArrayAttrib
  summary: Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions
  belongs_to: glEnableVertexAttribArray
  description: "`void `**`glDisableVertexArrayAttrib`**`(` GLuint `vaobj`, GLuint `index``)`;\n\n## Parameters\n\n*`vaobj`*\n\nSpecifies the name of the vertex array object for `glDisableVertexArrayAttrib` and `glEnableVertexArrayAttrib` functions.\n\n*`index`*\n\nSpecifies the index of the generic vertex attribute to be enabled or disabled.\n\n## Description\n\n`glEnableVertexAttribArray` and `glEnableVertexArrayAttrib` enable the generic vertex attribute array specified by *`index`*. `glEnableVertexAttribArray` uses currently bound vertex array object for the operation, whereas `glEnableVertexArrayAttrib` updates state of the vertex array object with ID *`vaobj`*.\n\n`glDisableVertexAttribArray` and `glDisableVertexArrayAttrib` disable the generic vertex attribute array specified by *`index`*. `glDisableVertexAttribArray` uses currently bound vertex array object for the operation, whereas `glDisableVertexArrayAttrib` updates state of the vertex array object with ID *`vaobj`*.\n\nBy default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array commands such as [glDrawArrays](gldrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glMultiDrawElements](glmultidrawelements.xhtml), or [glMultiDrawArrays](glmultidrawarrays.xhtml).\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glEnableVertexAttribArray` and `glDisableVertexAttribArray` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glEnableVertexArrayAttrib` and `glDisableVertexArrayAttrib` if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIBS`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_ENABLED`\n\n[glGetVertexAttribPointerv](glgetvertexattribpointerv.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_POINTER`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glDisableVertexArrayAttrib`  |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glDisableVertexAttribArray`  |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glEnableVertexArrayAttrib`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glEnableVertexAttribArray`   |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glDrawArrays](gldrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glMultiDrawElements](glmultidrawelements.xhtml), [glVertexAttrib](glvertexattrib.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glEnableVertexAttribArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glEnableVertexAttribArray.xhtml)"
- name: glDisableVertexAttribArray
  id: glenablevertexattribarray.xhtml#glDisableVertexAttribArray
  summary: null
  belongs_to: glEnableVertexAttribArray
  description: '`void `**`glDisableVertexAttribArray`**`(` GLuint `index``)`;'
- name: glDispatchCompute
  id: gldispatchcompute.xhtml
  summary: num_groups_x The number of work groups to be launched in the X dimension
  description: "## Name\n\nglDispatchCompute — launch one or more compute work groups\n\n## C Specification\n\n`void `**`glDispatchCompute`**`(` GLuint `num_groups_x`, GLuint `num_groups_y`, GLuint `num_groups_z``)`;\n\n## Parameters\n\n *`num_groups_x`*  \nThe number of work groups to be launched in the X dimension.\n\n *`num_groups_y`*  \nThe number of work groups to be launched in the Y dimension.\n\n *`num_groups_z`*  \nThe number of work groups to be launched in the Z dimension.\n\n## Description\n\n`glDispatchCompute` launches one or more compute work groups. Each work group is processed by the active program object for the compute shader stage. While the individual shader invocations within a work group are executed as a unit, work groups are executed completely independently and in unspecified order. *`num_groups_x`*, *`num_groups_y`* and *`num_groups_z`* specify the number of local work groups that will be dispatched in the X, Y and Z dimensions, respectively.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if there is no active program for the compute shader stage.\n\n`GL_INVALID_VALUE` is generated if any of *`num_groups_x`*, *`num_groups_y`*, or *`num_groups_z`* is greater than or equal to the maximum work-group count for the corresponding dimension.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_COMPUTE_WORK_GROUP_COUNT`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDispatchCompute`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDispatchComputeIndirect](gldispatchcomputeindirect.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDispatchCompute.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDispatchCompute.xhtml)"
- name: glDispatchComputeIndirect
  id: gldispatchcomputeindirect.xhtml
  summary: indirect The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target at which the dispatch parameters are stored
  description: "## Name\n\nglDispatchComputeIndirect — launch one or more compute work groups using parameters stored in a buffer\n\n## C Specification\n\n`void `**`glDispatchComputeIndirect`**`(` GLintptr `indirect``)`;\n\n## Parameters\n\n *`indirect`*  \nThe offset into the buffer object currently bound to the `GL_DISPATCH_INDIRECT_BUFFER` buffer target at which the dispatch parameters are stored.\n\n## Description\n\n`glDispatchComputeIndirect` launches one or more compute work groups using parameters stored in the buffer object currently bound to the `GL_DISPATCH_INDIRECT_BUFFER` target. Each work group is processed by the active program object for the compute shader stage. While the individual shader invocations within a work group are executed as a unit, work groups are executed completely independently and in unspecified order. *`indirect`* contains the offset into the data store of the buffer object bound to the `GL_DISPATCH_INDIRECT_BUFFER` target at which the parameters are stored.\n\nThe parameters addressed by *`indirect`* are packed a structure, which takes the form (in C):\n\n``` programlisting\n    typedef  struct {\n        uint  num_groups_x;\n        uint  num_groups_y;\n        uint  num_groups_z;\n    } DispatchIndirectCommand;\n```\n\nA call to `glDispatchComputeIndirect` is equivalent, assuming no errors are generated, to:\n\n``` programlisting\n    cmd = (const DispatchIndirectCommand  *)indirect;\n    glDispatchCompute(cmd->num_groups_x, cmd->num_groups_y, cmd->num_groups_z);\n```\n\nUnlike [glDispatchCompute](gldispatchcompute.xhtml), no error is generated if any of the `num_groups_x`, `num_groups_y` or `num_groups_z` members of the `DispatchIndirectCommand` is larger than the value of `GL_MAX_COMPUTE_WORK_GROUP_COUNT` for the corresponding dimension. In such circumstances, behavior is undefined and may lead to application termination.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if there is no active program for the compute shader stage.\n\n`GL_INVALID_VALUE` is generated if *`indirect`* is less than zero or not a multiple of four.\n\n`GL_INVALID_OPERATION` is generated if no buffer is bound to the `GL_DISPATCH_INDIRECT_BUFFER` target or if the command would source data beyond the end of the buffer object's data store.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_COMPUTE_WORK_GROUP_COUNT`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDispatchComputeIndirect` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDispatchCompute](gldispatchcompute.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDispatchComputeIndirect.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDispatchComputeIndirect.xhtml)"
- name: glDrawArrays
  id: gldrawarrays.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawArrays — render primitives from array data\n\n## C Specification\n\n`void `**`glDrawArrays`**`(` GLenum `mode`, GLint `first`, GLsizei `count``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`first`*  \nSpecifies the starting index in the enabled arrays.\n\n *`count`*  \nSpecifies the number of indices to be rendered.\n\n## Description\n\n`glDrawArrays` specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to `glDrawArrays`.\n\nWhen `glDrawArrays` is called, it uses *`count`* sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element *`first`*. *`mode`* specifies what kind of primitives are constructed and how the array elements construct those primitives.\n\nVertex attributes that are modified by `glDrawArrays` have an unspecified value after `glDrawArrays` returns. Attributes that aren't modified remain well defined.\n\n## Notes\n\n`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`count`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawArrays`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml),\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawArrays.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawArrays.xhtml)"
- name: glDrawArraysIndirect
  id: gldrawarraysindirect.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawArraysIndirect — render primitives from array data, taking parameters from memory\n\n## C Specification\n\n`void `**`glDrawArraysIndirect`**`(` GLenum `mode`, const void \\*`indirect``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.\n\n *`indirect`*  \nSpecifies the address of a structure containing the draw parameters.\n\n## Description\n\n`glDrawArraysIndirect` specifies multiple geometric primitives with very few subroutine calls. `glDrawArraysIndirect` behaves similarly to [glDrawArraysInstancedBaseInstance](gldrawarraysinstancedbaseinstance.xhtml), execept that the parameters to [glDrawArraysInstancedBaseInstance](gldrawarraysinstancedbaseinstance.xhtml) are stored in memory at the address given by *`indirect`*.\n\nThe parameters addressed by *`indirect`* are packed into a structure that takes the form (in C):\n\n``` programlisting\n    typedef  struct {\n        uint  count;\n        uint  instanceCount;\n        uint  first;\n        uint  baseInstance;\n    } DrawArraysIndirectCommand;\n\n    const DrawArraysIndirectCommand *cmd = (const DrawArraysIndirectCommand *)indirect;\n    glDrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count, cmd->instanceCount, cmd->baseInstance);\n```\n\nIf a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to `glDrawArraysIndirect`, *`indirect`* is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.\n\nIn contrast to [glDrawArraysInstancedBaseInstance](gldrawarraysinstancedbaseinstance.xhtml), the `first` member of the parameter structure is unsigned, and out-of-range indices do not generate an error.\n\nVertex attributes that are modified by `glDrawArraysIndirect` have an unspecified value after `glDrawArraysIndirect` returns. Attributes that aren't modified remain well defined.\n\n## Notes\n\nThe *`baseInstance`* member of the *`DrawArraysIndirectCommand`* structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* is `GL_PATCHES` and no tessellation control shader is active.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawArraysIndirect`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml),\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawArraysIndirect.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawArraysIndirect.xhtml)"
- name: glDrawArraysInstanced
  id: gldrawarraysinstanced.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawArraysInstanced — draw multiple instances of a range of elements\n\n## C Specification\n\n`void `**`glDrawArraysInstanced`**`(` GLenum `mode`, GLint `first`, GLsizei `count`, GLsizei `instancecount``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES` `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`first`*  \nSpecifies the starting index in the enabled arrays.\n\n *`count`*  \nSpecifies the number of indices to be rendered.\n\n *`instancecount`*  \nSpecifies the number of instances of the specified range of indices to be rendered.\n\n## Description\n\n`glDrawArraysInstanced` behaves identically to [glDrawArrays](gldrawarrays.xhtml) except that *`instancecount`* instances of the range of elements are executed and the value of the internal counter *`instanceID`* advances for each iteration. *`instanceID`* is an internal 32-bit integer counter that may be read by a vertex shader as `gl_InstanceID`.\n\n`glDrawArraysInstanced` has the same effect as:\n\n``` programlisting\n    if ( mode or count is invalid )\n        generate appropriate error\n    else {\n        for (int i = 0; i < instancecount ; i++) {\n            instanceID = i;\n            glDrawArrays(mode, first, count);\n        }\n        instanceID = 0;\n    }\n```\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of the accepted values.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_VALUE` is generated if *`count`* or *`instancecount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawArraysInstanced`     |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawElementsInstanced](gldrawelementsinstanced.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawArraysInstanced.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawArraysInstanced.xhtml)"
- name: glDrawArraysInstancedBaseInstance
  id: gldrawarraysinstancedbaseinstance.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawArraysInstancedBaseInstance — draw multiple instances of a range of elements with offset applied to instanced attributes\n\n## C Specification\n\n`void `**`glDrawArraysInstancedBaseInstance`**`(` GLenum `mode`, GLint `first`, GLsizei `count`, GLsizei `instancecount`, GLuint `baseinstance``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES` `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`first`*  \nSpecifies the starting index in the enabled arrays.\n\n *`count`*  \nSpecifies the number of indices to be rendered.\n\n *`instancecount`*  \nSpecifies the number of instances of the specified range of indices to be rendered.\n\n *`baseinstance`*  \nSpecifies the base instance for use in fetching instanced vertex attributes.\n\n## Description\n\n`glDrawArraysInstancedBaseInstance` behaves identically to [glDrawArrays](gldrawarrays.xhtml) except that *`instancecount`* instances of the range of elements are executed and the value of the internal counter *`instanceID`* advances for each iteration. *`instanceID`* is an internal 32-bit integer counter that may be read by a vertex shader as `gl_InstanceID`.\n\n`glDrawArraysInstancedBaseInstance` has the same effect as:\n\n``` programlisting\n    if ( mode or count is invalid )\n        generate appropriate error\n    else {\n        for (int i = 0; i < instancecount ; i++) {\n            instanceID = i;\n            glDrawArrays(mode, first, count);\n        }\n        instanceID = 0;\n    }\n```\n\nSpecific vertex attributes may be classified as *instanced* through the use of [glVertexAttribDivisor](glvertexattribdivisor.xhtml). Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as: $\\left\\lfloor \\frac{{gl}\\\\{InstanceID}}{divisor} \\right\\rfloor + {baseInstance}$. Note that *`baseinstance`* does not affect the shader-visible value of `gl_InstanceID`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of the accepted values.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_VALUE` is generated if *`count`* or *`instancecount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                                     | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**         |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawArraysInstancedBaseInstance` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawElementsInstanced](gldrawelementsinstanced.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawArraysInstancedBaseInstance.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawArraysInstancedBaseInstance.xhtml)"
- name: glDrawBuffer
  id: gldrawbuffer.xhtml
  summary: framebuffer Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function
  description: "## Name\n\nglDrawBuffer, glNamedFramebufferDrawBuffer — specify which color buffers are to be drawn into\n\n## C Specification\n\n`void `**`glDrawBuffer`**`(` GLenum `buf``)`;\n\n`void `**`glNamedFramebufferDrawBuffer`**`(` GLuint `framebuffer`, GLenum `buf``)`;\n\n## Parameters\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glNamedFramebufferDrawBuffer` function. Must be zero or the name of a framebuffer object.\n\n *`buf`*  \nFor default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants `GL_NONE`, `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_FRONT` for single-buffered contexts, and `GL_BACK` for double-buffered contexts. For framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums are accepted, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`.\n\n## Description\n\nWhen colors are written to the frame buffer, they are written into the color buffers specified by `glDrawBuffer`. One of the following values can be used for default framebuffer:\n\n `GL_NONE`  \nNo color buffers are written.\n\n `GL_FRONT_LEFT`  \nOnly the front left color buffer is written.\n\n `GL_FRONT_RIGHT`  \nOnly the front right color buffer is written.\n\n `GL_BACK_LEFT`  \nOnly the back left color buffer is written.\n\n `GL_BACK_RIGHT`  \nOnly the back right color buffer is written.\n\n `GL_FRONT`  \nOnly the front left and front right color buffers are written. If there is no front right color buffer, only the front left color buffer is written.\n\n `GL_BACK`  \nOnly the back left and back right color buffers are written. If there is no back right color buffer, only the back left color buffer is written.\n\n `GL_LEFT`  \nOnly the front left and back left color buffers are written. If there is no back left color buffer, only the front left color buffer is written.\n\n `GL_RIGHT`  \nOnly the front right and back right color buffers are written. If there is no back right color buffer, only the front right color buffer is written.\n\n `GL_FRONT_AND_BACK`  \nAll the front and back color buffers (front left, front right, back left, back right) are written. If there are no back color buffers, only the front left and front right color buffers are written. If there are no right color buffers, only the front left and back left color buffers are written. If there are no right or back color buffers, only the front left color buffer is written.\n\nIf more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer.\n\nMonoscopic contexts include only *left* buffers, and stereoscopic contexts include both *left* and *right* buffers. Likewise, single-buffered contexts include only *front* buffers, and double-buffered contexts include both *front* and *back* buffers. The context is selected at GL initialization.\n\nFor framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums are accepted, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`. glDrawBuffer will set the draw buffer for fragment colors other than zero to `GL_NONE`.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated by `glNamedFramebufferDrawBuffer` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`buf`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if the default framebuffer is affected and none of the buffers indicated by *`buf`* exists.\n\n`GL_INVALID_OPERATION` is generated if a framebuffer object is affected and *`buf`* is not equal to `GL_NONE` or `GL_COLOR_ATTACHMENT$m$`, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DRAW_BUFFER`\n\n## Version Support\n\n|                                | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**    |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawBuffer`                 |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glNamedFramebufferDrawBuffer` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBlendFunc](glblendfunc.xhtml), [glColorMask](glcolormask.xhtml), [glDrawBuffers](gldrawbuffers.xhtml), [glLogicOp](gllogicop.xhtml), [glReadBuffer](glreadbuffer.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawBuffer.xhtml)"
- name: glDrawBuffers
  id: gldrawbuffers.xhtml
  summary: framebuffer Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers
  description: "## Name\n\nglDrawBuffers, glNamedFramebufferDrawBuffers — Specifies a list of color buffers to be drawn into\n\n## C Specification\n\n`void `**`glDrawBuffers`**`(` GLsizei `n`, const GLenum \\*`bufs``)`;\n\n`void `**`glNamedFramebufferDrawBuffers`**`(` GLuint `framebuffer`, GLsizei `n`, const GLenum \\*`bufs``)`;\n\n## Parameters\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glNamedFramebufferDrawBuffers`.\n\n *`n`*  \nSpecifies the number of buffers in *`bufs`*.\n\n *`bufs`*  \nPoints to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.\n\n## Description\n\n`glDrawBuffers` and `glNamedFramebufferDrawBuffers` define an array of buffers into which outputs from the fragment shader data will be written. If a fragment shader writes a value to one or more user defined output variables, then the value of each variable will be written into the buffer specified at a location within *`bufs`* corresponding to the location assigned to that user defined output. The draw buffer used for user defined outputs assigned to locations greater than or equal to *`n`* is implicitly set to `GL_NONE` and any data written to such an output is discarded.\n\nFor `glDrawBuffers`, the framebuffer object that is bound to the `GL_DRAW_FRAMEBUFFER` binding will be used. For `glNamedFramebufferDrawBuffers`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, then the default framebuffer is affected.\n\nThe symbolic constants contained in *`bufs`* may be any of the following:\n\n `GL_NONE`  \nThe fragment shader output value is not written into any color buffer.\n\n `GL_FRONT_LEFT`  \nThe fragment shader output value is written into the front left color buffer.\n\n `GL_FRONT_RIGHT`  \nThe fragment shader output value is written into the front right color buffer.\n\n `GL_BACK_LEFT`  \nThe fragment shader output value is written into the back left color buffer.\n\n `GL_BACK_RIGHT`  \nThe fragment shader output value is written into the back right color buffer.\n\n `GL_COLOR_ATTACHMENT`  *n*  \nThe fragment shader output value is written into the *n*th color attachment of the current framebuffer. *n* may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS`.\n\nExcept for `GL_NONE`, the preceding symbolic constants may not appear more than once in *`bufs`*. The maximum number of draw buffers supported is implementation dependent and can be queried by calling [glGet](glget.xhtml) with the argument `GL_MAX_DRAW_BUFFERS`.\n\n## Notes\n\nThe symbolic constants `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_FRONT_AND_BACK` are not allowed in the *`bufs`* array since they may refer to multiple buffers.\n\nIf a fragment shader does not write to a user defined output variable, the values of the fragment colors following shader execution are undefined. For each fragment generated in this situation, a different value may be written into each of the buffers specified by *`bufs`*.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated by `glNamedFramebufferDrawBuffers` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if one of the values in *`bufs`* is not an accepted value.\n\n`GL_INVALID_ENUM` is generated if the API call refers to the default framebuffer and one or more of the values in *`bufs`* is one of the `GL_COLOR_ATTACHMENT`*n* tokens.\n\n`GL_INVALID_ENUM` is generated if the API call refers to a framebuffer object and one or more of the values in *`bufs`* is anything other than `GL_NONE` or one of the `GL_COLOR_ATTACHMENT`*n* tokens.\n\n`GL_INVALID_ENUM` is generated if *`n`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if a symbolic constant other than `GL_NONE` appears more than once in *`bufs`*.\n\n`GL_INVALID_OPERATION` is generated if any of the entries in *`bufs`* (other than `GL_NONE` ) indicates a color buffer that does not exist in the current GL context.\n\n`GL_INVALID_OPERATION` is generated if any value in *`bufs`* is `GL_BACK`, and *`n`* is not one.\n\n`GL_INVALID_VALUE` is generated if *`n`* is greater than `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_DRAW_BUFFERS`\n\n[glGet](glget.xhtml) with argument `GL_DRAW_BUFFER`*i* where *`i`* indicates the number of the draw buffer whose value is to be queried.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawBuffers`                 |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glNamedFramebufferDrawBuffers` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBlendFunc](glblendfunc.xhtml), [glColorMask](glcolormask.xhtml), [glDrawBuffers](gldrawbuffers.xhtml), [glLogicOp](gllogicop.xhtml), [glReadBuffer](glreadbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawBuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawBuffers.xhtml)"
- name: glDrawElements
  id: gldrawelements.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawElements — render primitives from array data\n\n## C Specification\n\n`void `**`glDrawElements`**`(` GLenum `mode`, GLsizei `count`, GLenum `type`, const void \\* `indices``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`count`*  \nSpecifies the number of elements to be rendered.\n\n *`type`*  \nSpecifies the type of the values in *`indices`*. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n## Description\n\n`glDrawElements` specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to `glDrawElements`.\n\nWhen `glDrawElements` is called, it uses *`count`* sequential elements from an enabled array, starting at *`indices`* to construct a sequence of geometric primitives. *`mode`* specifies what kind of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used.\n\nVertex attributes that are modified by `glDrawElements` have an unspecified value after `glDrawElements` returns. Attributes that aren't modified maintain their previous values.\n\n## Notes\n\n`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`count`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawElements`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawElementsInstanced](gldrawelementsinstanced.xhtml), [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElements.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElements.xhtml)"
- name: glDrawElementsBaseVertex
  id: gldrawelementsbasevertex.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawElementsBaseVertex — render primitives from array data with a per-element offset\n\n## C Specification\n\n`void `**`glDrawElementsBaseVertex`**`(` GLenum `mode`, GLsizei `count`, GLenum `type`, void \\*`indices`, GLint `basevertex``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`count`*  \nSpecifies the number of elements to be rendered.\n\n *`type`*  \nSpecifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n *`basevertex`*  \nSpecifies a constant that should be added to each element of *`indices`* when chosing elements from the enabled vertex arrays.\n\n## Description\n\n`glDrawElementsBaseVertex` behaves identically to [glDrawElements](gldrawelements.xhtml) except that the *i*th element transferred by the corresponding draw call will be taken from element *`indices`*\\[i\\] + *`basevertex`* of each enabled array. If the resulting value is larger than the maximum value representable by *`type`*, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.\n\n## Notes\n\n`glDrawElementsBaseVertex` is only supported if the GL version is 3.2 or greater, or if the `ARB_draw_elements_base_vertex` extension is supported.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`count`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawElementsBaseVertex`  |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawRangeElementsBaseVertex](gldrawrangeelementsbasevertex.xhtml), [glDrawElementsInstanced](gldrawelementsinstanced.xhtml), [glDrawElementsInstancedBaseVertex](gldrawelementsinstancedbasevertex.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsBaseVertex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsBaseVertex.xhtml)"
- name: glDrawElementsIndirect
  id: gldrawelementsindirect.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawElementsIndirect — render indexed primitives from array data, taking parameters from memory\n\n## C Specification\n\n`void `**`glDrawElementsIndirect`**`(` GLenum `mode`, GLenum `type`, const void \\*`indirect``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.\n\n *`type`*  \nSpecifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER` binding.\n\n *`indirect`*  \nSpecifies the address of a structure containing the draw parameters.\n\n## Description\n\n`glDrawElementsIndirect` specifies multiple indexed geometric primitives with very few subroutine calls. `glDrawElementsIndirect` behaves similarly to [glDrawElementsInstancedBaseVertexBaseInstance](gldrawelementsinstancedbasevertexbaseinstance.xhtml), execpt that the parameters to [glDrawElementsInstancedBaseVertexBaseInstance](gldrawelementsinstancedbasevertexbaseinstance.xhtml) are stored in memory at the address given by *`indirect`*.\n\nThe parameters addressed by *`indirect`* are packed into a structure that takes the form (in C):\n\n``` programlisting\n    typedef  struct {\n        uint  count;\n        uint  instanceCount;\n        uint  firstIndex;\n        int  baseVertex;\n        uint  baseInstance;\n    } DrawElementsIndirectCommand;\n```\n\n`glDrawElementsIndirect` is equivalent to:\n\n``` programlisting\n    void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect) {\n        const DrawElementsIndirectCommand *cmd  = (const DrawElementsIndirectCommand *)indirect;\n        glDrawElementsInstancedBaseVertexBaseInstance(mode,\n                                                      cmd->count,\n                                                      type,\n                                                      cmd->firstIndex * size-of-type,\n                                                      cmd->instanceCount,\n                                                      cmd->baseVertex,\n                                                      cmd->baseInstance);\n    }\n```\n\nIf a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to `glDrawElementsIndirect`, *`indirect`* is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.\n\nNote that indices stored in client memory are not supported. If no buffer is bound to the `GL_ELEMENT_ARRAY_BUFFER` binding, an error will be generated.\n\nThe results of the operation are undefined if the `reservedMustBeZero` member of the parameter structure is non-zero. However, no error is generated in this case.\n\nVertex attributes that are modified by `glDrawElementsIndirect` have an unspecified value after `glDrawElementsIndirect` returns. Attributes that aren't modified remain well defined.\n\n## Notes\n\nThe *`baseInstance`* member of the *`DrawElementsIndirectCommand`* structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if zero is bound to the `GL_ELEMENT_ARRAY_BUFFER` binding, or if such a buffer's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* is `GL_PATCHES` and no tessellation control shader is active.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawElementsIndirect`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawArraysIndirect](gldrawarraysindirect.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml),\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsIndirect.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsIndirect.xhtml)"
- name: glDrawElementsInstanced
  id: gldrawelementsinstanced.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawElementsInstanced — draw multiple instances of a set of elements\n\n## C Specification\n\n`void `**`glDrawElementsInstanced`**`(` GLenum `mode`, GLsizei `count`, GLenum `type`, const void \\* `indices`, GLsizei `instancecount``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`count`*  \nSpecifies the number of elements to be rendered.\n\n *`type`*  \nSpecifies the type of the values in *`indices`*. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n *`instancecount`*  \nSpecifies the number of instances of the specified range of indices to be rendered.\n\n## Description\n\n`glDrawElementsInstanced` behaves identically to [glDrawElements](gldrawelements.xhtml) except that *`instancecount`* instances of the set of elements are executed and the value of the internal counter *`instanceID`* advances for each iteration. *`instanceID`* is an internal 32-bit integer counter that may be read by a vertex shader as `gl_InstanceID`.\n\n`glDrawElementsInstanced` has the same effect as:\n\n``` programlisting\n    if (mode, count, or type is invalid )\n        generate appropriate error\n    else {\n        for (int i = 0; i < instancecount ; i++) {\n            instanceID = i;\n            glDrawElements(mode, count, type, indices);\n        }\n        instanceID = 0;\n    }\n```\n\n## Notes\n\n`glDrawElementsInstanced` is available only if the GL version is 3.1 or greater.\n\n`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, or `GL_TRIANGLES`.\n\n`GL_INVALID_VALUE` is generated if *`count`* or *`instancecount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawElementsInstanced`   |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawElements](gldrawelements.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsInstanced.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsInstanced.xhtml)"
- name: glDrawElementsInstancedBaseInstance
  id: gldrawelementsinstancedbaseinstance.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawElementsInstancedBaseInstance — draw multiple instances of a set of elements with offset applied to instanced attributes\n\n## C Specification\n\n`void `**`glDrawElementsInstancedBaseInstance`**`(` GLenum `mode`, GLsizei `count`, GLenum `type`, const void \\* `indices`, GLsizei `instancecount`, GLuint `baseinstance``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`count`*  \nSpecifies the number of elements to be rendered.\n\n *`type`*  \nSpecifies the type of the values in *`indices`*. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n *`instancecount`*  \nSpecifies the number of instances of the specified range of indices to be rendered.\n\n *`baseinstance`*  \nSpecifies the base instance for use in fetching instanced vertex attributes.\n\n## Description\n\n`glDrawElementsInstancedBaseInstance` behaves identically to [glDrawElements](gldrawelements.xhtml) except that *`instancecount`* instances of the set of elements are executed and the value of the internal counter *`instanceID`* advances for each iteration. *`instanceID`* is an internal 32-bit integer counter that may be read by a vertex shader as `gl_InstanceID`.\n\n`glDrawElementsInstancedBaseInstance` has the same effect as:\n\n``` programlisting\n    if (mode, count, or type is invalid )\n        generate appropriate error\n    else {\n        for (int i = 0; i < instancecount ; i++) {\n            instanceID = i;\n            glDrawElements(mode, count, type, indices);\n        }\n        instanceID = 0;\n    }\n```\n\nSpecific vertex attributes may be classified as *instanced* through the use of [glVertexAttribDivisor](glvertexattribdivisor.xhtml). Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as $\\left\\lfloor \\frac{{gl}\\\\{InstanceID}}{divisor} \\right\\rfloor + {baseInstance}$. Note that *`baseinstance`* does not affect the shader-visible value of `gl_InstanceID`.\n\n## Notes\n\n`glDrawElementsInstancedBaseInstance` is available only if the GL version is 4.2 or greater.\n\n`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, or `GL_TRIANGLES`.\n\n`GL_INVALID_VALUE` is generated if *`count`* or *`instancecount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                                       | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**           |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawElementsInstancedBaseInstance` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawElements](gldrawelements.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsInstancedBaseInstance.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsInstancedBaseInstance.xhtml)"
- name: glDrawElementsInstancedBaseVertex
  id: gldrawelementsinstancedbasevertex.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawElementsInstancedBaseVertex — render multiple instances of a set of primitives from array data with a per-element offset\n\n## C Specification\n\n`void `**`glDrawElementsInstancedBaseVertex`**`(` GLenum `mode`, GLsizei `count`, GLenum `type`, void \\*`indices`, GLsizei `instancecount`, GLint `basevertex``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`count`*  \nSpecifies the number of elements to be rendered.\n\n *`type`*  \nSpecifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n *`instancecount`*  \nSpecifies the number of instances of the indexed geometry that should be drawn.\n\n *`basevertex`*  \nSpecifies a constant that should be added to each element of *`indices`* when chosing elements from the enabled vertex arrays.\n\n## Description\n\n`glDrawElementsInstancedBaseVertex` behaves identically to [glDrawElementsInstanced](gldrawelementsinstanced.xhtml) except that the *i*th element transferred by the corresponding draw call will be taken from element *`indices`*\\[i\\] + *`basevertex`* of each enabled array. If the resulting value is larger than the maximum value representable by *`type`*, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.\n\n## Notes\n\n`glDrawElementsInstancedBaseVertex` is only supported if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`count`* or *`instancecount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                                     | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**         |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawElementsInstancedBaseVertex` |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawRangeElementsBaseVertex](gldrawrangeelementsbasevertex.xhtml), [glDrawElementsInstanced](gldrawelementsinstanced.xhtml), [glDrawElementsInstancedBaseVertex](gldrawelementsinstancedbasevertex.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsInstancedBaseVertex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsInstancedBaseVertex.xhtml)"
- name: glDrawElementsInstancedBaseVertexBaseInstance
  id: gldrawelementsinstancedbasevertexbaseinstance.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawElementsInstancedBaseVertexBaseInstance — render multiple instances of a set of primitives from array data with a per-element offset\n\n## C Specification\n\n`void `**`glDrawElementsInstancedBaseVertexBaseInstance`**`(` GLenum `mode`, GLsizei `count`, GLenum `type`, void \\*`indices`, GLsizei `instancecount`, GLint `basevertex`, GLuint `baseinstance``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`count`*  \nSpecifies the number of elements to be rendered.\n\n *`type`*  \nSpecifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n *`instancecount`*  \nSpecifies the number of instances of the indexed geometry that should be drawn.\n\n *`basevertex`*  \nSpecifies a constant that should be added to each element of *`indices`* when chosing elements from the enabled vertex arrays.\n\n *`baseinstance`*  \nSpecifies the base instance for use in fetching instanced vertex attributes.\n\n## Description\n\n`glDrawElementsInstancedBaseVertexBaseInstance` behaves identically to [glDrawElementsInstanced](gldrawelementsinstanced.xhtml) except that the *i*th element transferred by the corresponding draw call will be taken from element *`indices`*\\[i\\] + *`basevertex`* of each enabled array. If the resulting value is larger than the maximum value representable by *`type`*, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.\n\nSpecific vertex attributes may be classified as *instanced* through the use of [glVertexAttribDivisor](glvertexattribdivisor.xhtml). Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as $\\left\\lfloor \\frac{{gl}\\\\{InstanceID}}{divisor} \\right\\rfloor + {baseInstance}$. Note that *`baseinstance`* does not affect the shader-visible value of `gl_InstanceID`.\n\n## Notes\n\n`glDrawElementsInstancedBaseVertex` is only supported if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`count`* or *`instancecount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**                     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawElementsInstancedBaseVertexBaseInstance` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawRangeElementsBaseVertex](gldrawrangeelementsbasevertex.xhtml), [glDrawElementsInstanced](gldrawelementsinstanced.xhtml), [glDrawElementsInstancedBaseVertex](gldrawelementsinstancedbasevertex.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsInstancedBaseVertexBaseInstance.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawElementsInstancedBaseVertexBaseInstance.xhtml)"
- name: glDrawRangeElements
  id: gldrawrangeelements.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawRangeElements — render primitives from array data\n\n## C Specification\n\n`void `**`glDrawRangeElements`**`(` GLenum `mode`, GLuint `start`, GLuint `end`, GLsizei `count`, GLenum `type`, const void \\* `indices``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`start`*  \nSpecifies the minimum array index contained in *`indices`*.\n\n *`end`*  \nSpecifies the maximum array index contained in *`indices`*.\n\n *`count`*  \nSpecifies the number of elements to be rendered.\n\n *`type`*  \nSpecifies the type of the values in *`indices`*. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n## Description\n\n`glDrawRangeElements` is a restricted form of [glDrawElements](gldrawelements.xhtml). *`mode`*, and *`count`* match the corresponding arguments to [glDrawElements](gldrawelements.xhtml), with the additional constraint that all values in the arrays *`count`* must lie between *`start`* and *`end`*, inclusive.\n\nImplementations denote recommended maximum amounts of vertex and index data, which may be queried by calling [glGet](glget.xhtml) with argument `GL_MAX_ELEMENTS_VERTICES` and `GL_MAX_ELEMENTS_INDICES`. If *e**n**d* − *s**t**a**r**t* + 1 is greater than the value of `GL_MAX_ELEMENTS_VERTICES`, or if *`count`* is greater than the value of `GL_MAX_ELEMENTS_INDICES`, then the call may operate at reduced performance. There is no requirement that all vertices in the range \\[*s**t**a**r**t*, *e**n**d*\\] be referenced. However, the implementation may partially process unused vertices, reducing performance from what could be achieved with an optimal index set.\n\nWhen `glDrawRangeElements` is called, it uses *`count`* sequential elements from an enabled array, starting at *`start`* to construct a sequence of geometric primitives. *`mode`* specifies what kind of primitives are constructed, and how the array elements construct these primitives. If more than one array is enabled, each is used.\n\nVertex attributes that are modified by `glDrawRangeElements` have an unspecified value after `glDrawRangeElements` returns. Attributes that aren't modified maintain their previous values.\n\n## Notes\n\n`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.\n\n## Errors\n\nIt is an error for indices to lie outside the range \\[*s**t**a**r**t*, *e**n**d*\\], but implementations may not check for this situation. Such indices cause implementation-dependent behavior.\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`count`* is negative.\n\n`GL_INVALID_VALUE` is generated if *e**n**d* \\< *s**t**a**r**t*.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_ELEMENTS_VERTICES`\n\n[glGet](glget.xhtml) with argument `GL_MAX_ELEMENTS_INDICES`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawRangeElements`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawRangeElements.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawRangeElements.xhtml)"
- name: glDrawRangeElementsBaseVertex
  id: gldrawrangeelementsbasevertex.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawRangeElementsBaseVertex — render primitives from array data with a per-element offset\n\n## C Specification\n\n`void `**`glDrawRangeElementsBaseVertex`**`(` GLenum `mode`, GLuint `start`, GLuint `end`, GLsizei `count`, GLenum `type`, void \\*`indices`, GLint `basevertex``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`start`*  \nSpecifies the minimum array index contained in *`indices`*.\n\n *`end`*  \nSpecifies the maximum array index contained in *`indices`*.\n\n *`count`*  \nSpecifies the number of elements to be rendered.\n\n *`type`*  \nSpecifies the type of the values in indices. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n *`basevertex`*  \nSpecifies a constant that should be added to each element of *`indices`* when chosing elements from the enabled vertex arrays.\n\n## Description\n\n`glDrawRangeElementsBaseVertex` is a restricted form of [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml). *`mode`*, *`count`* and *`basevertex`* match the corresponding arguments to [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml), with the additional constraint that all values in the array *`indices`* must lie between *`start`* and *`end`*, inclusive, prior to adding *`basevertex`*. Index values lying outside the range \\[*`start`*, *`end`*\\] are treated in the same way as [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml). The *i*th element transferred by the corresponding draw call will be taken from element *`indices`*\\[i\\] + *`basevertex`* of each enabled array. If the resulting value is larger than the maximum value representable by *`type`*, it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`count`* is negative.\n\n`GL_INVALID_VALUE` is generated if *`end`* \\< *`start`*.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawRangeElementsBaseVertex` |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawElements](gldrawelements.xhtml), [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawElementsInstanced](gldrawelementsinstanced.xhtml), [glDrawElementsInstancedBaseVertex](gldrawelementsinstancedbasevertex.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawRangeElementsBaseVertex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawRangeElementsBaseVertex.xhtml)"
- name: glDrawTransformFeedback
  id: gldrawtransformfeedback.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawTransformFeedback — render primitives using a count derived from a transform feedback object\n\n## C Specification\n\n`void `**`glDrawTransformFeedback`**`(` GLenum `mode`, GLuint `id``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.\n\n *`id`*  \nSpecifies the name of a transform feedback object from which to retrieve a primitive count.\n\n## Description\n\n`glDrawTransformFeedback` draws primitives of a type specified by *`mode`* using a count retrieved from the transform feedback specified by *`id`*. Calling `glDrawTransformFeedback` is equivalent to calling [glDrawArrays](gldrawarrays.xhtml) with *`mode`* as specified, *`first`* set to zero, and *`count`* set to the number of vertices captured on vertex stream zero the last time transform feedback was active on the transform feedback object named by *`id`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`id`* is not the name of a transform feedback object.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* is `GL_PATCHES` and no tessellation control shader is active.\n\n`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` has never been called while the transform feedback object named by *`id`* was bound.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawTransformFeedback`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawTransformFeedbackStream](gldrawtransformfeedbackstream.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawTransformFeedback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawTransformFeedback.xhtml)"
- name: glDrawTransformFeedbackInstanced
  id: gldrawtransformfeedbackinstanced.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawTransformFeedbackInstanced — render multiple instances of primitives using a count derived from a transform feedback object\n\n## C Specification\n\n`void `**`glDrawTransformFeedbackInstanced`**`(` GLenum `mode`, GLuint `id`, GLsizei `instancecount``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.\n\n *`id`*  \nSpecifies the name of a transform feedback object from which to retrieve a primitive count.\n\n *`instancecount`*  \nSpecifies the number of instances of the geometry to render.\n\n## Description\n\n`glDrawTransformFeedbackInstanced` draws multiple copies of a range of primitives of a type specified by *`mode`* using a count retrieved from the transform feedback stream specified by *`stream`* of the transform feedback object specified by *`id`*. Calling `glDrawTransformFeedbackInstanced` is equivalent to calling [glDrawArraysInstanced](gldrawarraysinstanced.xhtml) with *`mode`* and *`instancecount`* as specified, *`first`* set to zero, and *`count`* set to the number of vertices captured on vertex stream zero the last time transform feedback was active on the transform feedback object named by *`id`*.\n\nCalling `glDrawTransformFeedbackInstanced` is equivalent to calling [glDrawTransformFeedbackStreamInstanced](gldrawtransformfeedbackstreaminstanced.xhtml) with *`stream`* set to zero.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`id`* is not the name of a transform feedback object.\n\n`GL_INVALID_VALUE` is generated if *`stream`* is greater than or equal to the value of `GL_MAX_VERTEX_STREAMS`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* is `GL_PATCHES` and no tessellation control shader is active.\n\n`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` has never been called while the transform feedback object named by *`id`* was bound.\n\n## Version Support\n\n|                                    | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**        |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawTransformFeedbackInstanced` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawTransformFeedback](gldrawtransformfeedback.xhtml), [glDrawTransformFeedbackStreamInstanced](gldrawtransformfeedbackstreaminstanced.xhtml).\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawTransformFeedbackInstanced.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawTransformFeedbackInstanced.xhtml)"
- name: glDrawTransformFeedbackStream
  id: gldrawtransformfeedbackstream.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawTransformFeedbackStream — render primitives using a count derived from a specifed stream of a transform feedback object\n\n## C Specification\n\n`void `**`glDrawTransformFeedbackStream`**`(` GLenum `mode`, GLuint `id`, GLuint `stream``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.\n\n *`id`*  \nSpecifies the name of a transform feedback object from which to retrieve a primitive count.\n\n *`stream`*  \nSpecifies the index of the transform feedback stream from which to retrieve a primitive count.\n\n## Description\n\n`glDrawTransformFeedbackStream` draws primitives of a type specified by *`mode`* using a count retrieved from the transform feedback stream specified by *`stream`* of the transform feedback object specified by *`id`*. Calling `glDrawTransformFeedbackStream` is equivalent to calling [glDrawArrays](gldrawarrays.xhtml) with *`mode`* as specified, *`first`* set to zero, and *`count`* set to the number of vertices captured on vertex stream *`stream`* the last time transform feedback was active on the transform feedback object named by *`id`*.\n\nCalling [glDrawTransformFeedback](gldrawtransformfeedback.xhtml) is equivalent to calling `glDrawTransformFeedbackStream` with *`stream`* set to zero.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`id`* is not the name of a transform feedback object.\n\n`GL_INVALID_VALUE` is generated if *`stream`* is greater than or equal to the value of `GL_MAX_VERTEX_STREAMS`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* is `GL_PATCHES` and no tessellation control shader is active.\n\n`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` has never been called while the transform feedback object named by *`id`* was bound.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawTransformFeedbackStream` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawTransformFeedback](gldrawtransformfeedback.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawTransformFeedbackStream.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawTransformFeedbackStream.xhtml)"
- name: glDrawTransformFeedbackStreamInstanced
  id: gldrawtransformfeedbackstreaminstanced.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglDrawTransformFeedbackStreamInstanced — render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object\n\n## C Specification\n\n`void `**`glDrawTransformFeedbackStreamInstanced`**`(` GLenum `mode`, GLuint `id`, GLuint `stream`, GLsizei `instancecount``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.\n\n *`id`*  \nSpecifies the name of a transform feedback object from which to retrieve a primitive count.\n\n *`stream`*  \nSpecifies the index of the transform feedback stream from which to retrieve a primitive count.\n\n *`instancecount`*  \nSpecifies the number of instances of the geometry to render.\n\n## Description\n\n`glDrawTransformFeedbackStreamInstanced` draws multiple copies of a range of primitives of a type specified by *`mode`* using a count retrieved from the transform feedback stream specified by *`stream`* of the transform feedback object specified by *`id`*. Calling `glDrawTransformFeedbackStreamInstanced` is equivalent to calling [glDrawArraysInstanced](gldrawarraysinstanced.xhtml) with *`mode`* and *`instancecount`* as specified, *`first`* set to zero, and *`count`* set to the number of vertices captured on vertex stream *`stream`* the last time transform feedback was active on the transform feedback object named by *`id`*.\n\nCalling [glDrawTransformFeedbackInstanced](gldrawtransformfeedbackinstanced.xhtml) is equivalent to calling `glDrawTransformFeedbackStreamInstanced` with *`stream`* set to zero.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`id`* is not the name of a transform feedback object.\n\n`GL_INVALID_VALUE` is generated if *`stream`* is greater than or equal to the value of `GL_MAX_VERTEX_STREAMS`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* is `GL_PATCHES` and no tessellation control shader is active.\n\n`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` has never been called while the transform feedback object named by *`id`* was bound.\n\n## Version Support\n\n|                                          | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**              |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDrawTransformFeedbackStreamInstanced` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawTransformFeedback](gldrawtransformfeedback.xhtml), [glDrawTransformFeedbackStream](gldrawtransformfeedbackstream.xhtml).\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawTransformFeedbackStreamInstanced.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawTransformFeedbackStreamInstanced.xhtml)"
- name: glEnable
  id: glenable.xhtml
  summary: cap Specifies a symbolic constant indicating a GL capability
  description: "## Name\n\nglEnable — enable or disable server-side GL capabilities\n\n## C Specification\n\n`void `**`glEnable`**`(` GLenum `cap``)`;\n\n`void `**`glDisable`**`(` GLenum `cap``)`;\n\n`void `**`glEnablei`**`(` GLenum `cap`, GLuint `index``)`;\n\n`void `**`glDisablei`**`(` GLenum `cap`, GLuint `index``)`;\n\n## Parameters\n\n *`cap`*  \nSpecifies a symbolic constant indicating a GL capability.\n\n *`index`*  \nSpecifies the index of the switch to disable (for `glEnablei` and `glDisablei` only).\n\n## Description\n\n`glEnable` and `glDisable` enable and disable various capabilities. Use [glIsEnabled](glisenabled.xhtml) or [glGet](glget.xhtml) to determine the current setting of any capability. The initial value for each capability with the exception of `GL_DITHER` and `GL_MULTISAMPLE` is `GL_FALSE`. The initial value for `GL_DITHER` and `GL_MULTISAMPLE` is `GL_TRUE`.\n\nBoth `glEnable` and `glDisable` take a single argument, *`cap`*, which can assume one of the following values:\n\nSome of the GL's capabilities are indexed. `glEnablei` and `glDisablei` enable and disable indexed capabilities.\n\n `GL_BLEND`  \nIf enabled, blend the computed fragment color values with the values in the color buffers. See [glBlendFunc](glblendfunc.xhtml).\n\n `GL_CLIP_DISTANCE`  *i*  \nIf enabled, clip geometry against user-defined half space *i*.\n\n `GL_COLOR_LOGIC_OP`  \nIf enabled, apply the currently selected logical operation to the computed fragment color and color buffer values. See [glLogicOp](gllogicop.xhtml).\n\n `GL_CULL_FACE`  \nIf enabled, cull polygons based on their winding in window coordinates. See [glCullFace](glcullface.xhtml).\n\n `GL_DEBUG_OUTPUT`  \nIf enabled, debug messages are produced by a debug context. When disabled, the debug message log is silenced. Note that in a non-debug context, very few, if any messages might be produced, even when `GL_DEBUG_OUTPUT` is enabled.\n\n `GL_DEBUG_OUTPUT_SYNCHRONOUS`  \nIf enabled, debug messages are produced synchronously by a debug context. If disabled, debug messages may be produced asynchronously. In particular, they may be delayed relative to the execution of GL commands, and the debug callback function may be called from a thread other than that in which the commands are executed. See [glDebugMessageCallback](gldebugmessagecallback.xhtml).\n\n `GL_DEPTH_CLAMP`  \nIf enabled, the −*w*_(*c*) ≤ *z*_(*c*) ≤ *w*_(*c*) plane equation is ignored by view volume clipping (effectively, there is no near or far plane clipping). See [glDepthRange](gldepthrange.xhtml).\n\n `GL_DEPTH_TEST`  \nIf enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See [glDepthFunc](gldepthfunc.xhtml) and [glDepthRange](gldepthrange.xhtml).\n\n`GL_DITHER`  \nIf enabled, dither color components or indices before they are written to the color buffer.\n\n`GL_FRAMEBUFFER_SRGB`  \nIf enabled and the value of `GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING` for the framebuffer attachment corresponding to the destination buffer is `GL_SRGB`, the R, G, and B destination color values (after conversion from fixed-point to floating-point) are considered to be encoded for the sRGB color space and hence are linearized prior to their use in blending.\n\n `GL_LINE_SMOOTH`  \nIf enabled, draw lines with correct filtering. Otherwise, draw aliased lines. See [glLineWidth](gllinewidth.xhtml).\n\n `GL_MULTISAMPLE`  \nIf enabled, use multiple fragment samples in computing the final color of a pixel. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n `GL_POLYGON_OFFSET_FILL`  \nIf enabled, and if the polygon is rendered in `GL_FILL` mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n `GL_POLYGON_OFFSET_LINE`  \nIf enabled, and if the polygon is rendered in `GL_LINE` mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n `GL_POLYGON_OFFSET_POINT`  \nIf enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the polygon is rendered in `GL_POINT` mode. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n `GL_POLYGON_SMOOTH`  \nIf enabled, draw polygons with proper filtering. Otherwise, draw aliased polygons. For correct antialiased polygons, an alpha buffer is needed and the polygons must be sorted front to back.\n\n `GL_PRIMITIVE_RESTART`  \nEnables primitive restarting. If enabled, any one of the draw commands which transfers a set of generic attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the primitive restart index. See [glPrimitiveRestartIndex](glprimitiverestartindex.xhtml).\n\n `GL_PRIMITIVE_RESTART_FIXED_INDEX`  \nEnables primitive restarting with a fixed index. If enabled, any one of the draw commands which transfers a set of generic attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the fixed primitive index for the specified index type. The fixed index is equal to 2^(*n*) − 1 where *n* is equal to 8 for `GL_UNSIGNED_BYTE`, 16 for `GL_UNSIGNED_SHORT` and 32 for `GL_UNSIGNED_INT`.\n\n `GL_RASTERIZER_DISCARD`  \nIf enabled, primitives are discarded after the optional transform feedback stage, but before rasterization. Furthermore, when enabled, [glClear](glclear.xhtml), [glClearBufferData](glclearbufferdata.xhtml), [glClearBufferSubData](glclearbuffersubdata.xhtml), [glClearTexImage](glclearteximage.xhtml), and [glClearTexSubImage](glcleartexsubimage.xhtml) are ignored.\n\n `GL_SAMPLE_ALPHA_TO_COVERAGE`  \nIf enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location. The temporary coverage value is then ANDed with the fragment coverage value.\n\n `GL_SAMPLE_ALPHA_TO_ONE`  \nIf enabled, each sample alpha value is replaced by the maximum representable alpha value.\n\n `GL_SAMPLE_COVERAGE`  \nIf enabled, the fragment's coverage is ANDed with the temporary coverage value. If `GL_SAMPLE_COVERAGE_INVERT` is set to `GL_TRUE`, invert the coverage value. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n `GL_SAMPLE_SHADING`  \nIf enabled, the active fragment shader is run once for each covered sample, or at fraction of this rate as determined by the current value of `GL_MIN_SAMPLE_SHADING_VALUE`. See [glMinSampleShading](glminsampleshading.xhtml).\n\n `GL_SAMPLE_MASK`  \nIf enabled, the sample coverage mask generated for a fragment during rasterization will be ANDed with the value of `GL_SAMPLE_MASK_VALUE` before shading occurs. See [glSampleMaski](glsamplemaski.xhtml).\n\n `GL_SCISSOR_TEST`  \nIf enabled, discard fragments that are outside the scissor rectangle. See [glScissor](glscissor.xhtml).\n\n `GL_STENCIL_TEST`  \nIf enabled, do stencil testing and update the stencil buffer. See [glStencilFunc](glstencilfunc.xhtml) and [glStencilOp](glstencilop.xhtml).\n\n `GL_TEXTURE_CUBE_MAP_SEAMLESS`  \nIf enabled, cubemap textures are sampled such that when linearly sampling from the border between two adjacent faces, texels from both faces are used to generate the final sample value. When disabled, texels from only a single face are used to construct the final sample value.\n\n `GL_PROGRAM_POINT_SIZE`  \nIf enabled and a vertex or geometry shader is active, then the derived point size is taken from the (potentially clipped) shader builtin `gl_PointSize` and clamped to the implementation-dependent point size range.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`cap`* is not one of the values listed previously.\n\n`GL_INVALID_VALUE` is generated by `glEnablei` and `glDisablei` if *`index`* is greater than or equal to the number of indexed capabilities for *`cap`*.\n\n## Notes\n\n`GL_PRIMITIVE_RESTART` is available only if the GL version is 3.1 or greater.\n\n`GL_TEXTURE_CUBE_MAP_SEAMLESS` is available only if the GL version is 3.2 or greater.\n\n`GL_PRIMITIVE_RESTART_FIXED_INDEX` is available only if the GL version is 4.3 or greater.\n\n`GL_DEBUG_OUTPUT` and `GL_DEBUG_OUTPUT_SYNCHRONOUS` are available only if the GL version is 4.3 or greater.\n\nAny token accepted by `glEnable` or `glDisable` is also accepted by `glEnablei` and `glDisablei`, but if the capability is not indexed, the maximum value that *`index`* may take is zero.\n\nIn general, passing an indexed capability to `glEnable` or `glDisable` will enable or disable that capability for all indices, resepectively.\n\n## Associated Gets\n\n[glIsEnabled](glisenabled.xhtml)\n\n[glGet](glget.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDisable`                 |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glDisablei`                |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glEnable`                  |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glEnablei`                 |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glBlendFunc](glblendfunc.xhtml), [glCullFace](glcullface.xhtml), [glDepthFunc](gldepthfunc.xhtml), [glDepthRange](gldepthrange.xhtml), [glGet](glget.xhtml), [glIsEnabled](glisenabled.xhtml), [glLineWidth](gllinewidth.xhtml), [glLogicOp](gllogicop.xhtml), [glPointSize](glpointsize.xhtml), [glPolygonMode](glpolygonmode.xhtml), [glPolygonOffset](glpolygonoffset.xhtml), [glSampleCoverage](glsamplecoverage.xhtml), [glScissor](glscissor.xhtml), [glStencilFunc](glstencilfunc.xhtml), [glStencilOp](glstencilop.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glEnable.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glEnable.xhtml)"
- name: glEnablei
  id: glenable.xhtml#glEnablei
  summary: null
  belongs_to: glEnable
  description: '`void `**`glEnablei`**`(` GLenum `cap`, GLuint `index``)`;'
- name: glEnableVertexArrayAttrib
  id: glenablevertexattribarray.xhtml#glEnableVertexArrayAttrib
  summary: null
  belongs_to: glEnableVertexAttribArray
  description: '`void `**`glEnableVertexArrayAttrib`**`(` GLuint `vaobj`, GLuint `index``)`;'
- name: glEnableVertexAttribArray
  id: glenablevertexattribarray.xhtml
  summary: vaobj Specifies the name of the vertex array object for glDisableVertexArrayAttrib and glEnableVertexArrayAttrib functions
  description: "## Name\n\nglEnableVertexAttribArray — Enable or disable a generic vertex attribute array\n\n## C Specification\n\n`void `**`glEnableVertexAttribArray`**`(` GLuint `index``)`;\n\n`void `**`glDisableVertexAttribArray`**`(` GLuint `index``)`;\n\n`void `**`glEnableVertexArrayAttrib`**`(` GLuint `vaobj`, GLuint `index``)`;\n\n`void `**`glDisableVertexArrayAttrib`**`(` GLuint `vaobj`, GLuint `index``)`;\n\n## Parameters\n\n *`vaobj`*  \nSpecifies the name of the vertex array object for `glDisableVertexArrayAttrib` and `glEnableVertexArrayAttrib` functions.\n\n *`index`*  \nSpecifies the index of the generic vertex attribute to be enabled or disabled.\n\n## Description\n\n`glEnableVertexAttribArray` and `glEnableVertexArrayAttrib` enable the generic vertex attribute array specified by *`index`*. `glEnableVertexAttribArray` uses currently bound vertex array object for the operation, whereas `glEnableVertexArrayAttrib` updates state of the vertex array object with ID *`vaobj`*.\n\n`glDisableVertexAttribArray` and `glDisableVertexArrayAttrib` disable the generic vertex attribute array specified by *`index`*. `glDisableVertexAttribArray` uses currently bound vertex array object for the operation, whereas `glDisableVertexArrayAttrib` updates state of the vertex array object with ID *`vaobj`*.\n\nBy default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array commands such as [glDrawArrays](gldrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glMultiDrawElements](glmultidrawelements.xhtml), or [glMultiDrawArrays](glmultidrawarrays.xhtml).\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glEnableVertexAttribArray` and `glDisableVertexAttribArray` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glEnableVertexArrayAttrib` and `glDisableVertexArrayAttrib` if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIBS`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_ENABLED`\n\n[glGetVertexAttribPointerv](glgetvertexattribpointerv.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_POINTER`\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glDisableVertexArrayAttrib` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glDisableVertexAttribArray` |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glEnableVertexArrayAttrib`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glEnableVertexAttribArray`  |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glDrawArrays](gldrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glMultiDrawElements](glmultidrawelements.xhtml), [glVertexAttrib](glvertexattrib.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glEnableVertexAttribArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glEnableVertexAttribArray.xhtml)"
- name: glEndConditionalRender
  id: glbeginconditionalrender.xhtml#glEndConditionalRender
  summary: Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded
  belongs_to: glBeginConditionalRender
  description: "`void `**`glEndConditionalRender`**`(``void``)`;\n\n## Parameters for `glBeginConditionalRender`\n\n*`id`*\n\nSpecifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.\n\n*`mode`*\n\nSpecifies how `glBeginConditionalRender` interprets the results of the occlusion query.\n\n## Description\n\nConditional rendering is started using `glBeginConditionalRender` and ended using `glEndConditionalRender`. During conditional rendering, all vertex array commands, as well as [glClear](glclear.xhtml) and [glClearBuffer](glclearbuffer.xhtml) have no effect if the (`GL_SAMPLES_PASSED`) result of the query object *`id`* is zero, or if the (`GL_ANY_SAMPLES_PASSED`) result is `GL_FALSE`. The results of commands setting the current vertex state, such as [glVertexAttrib](glvertexattrib.xhtml) are undefined. If the (`GL_SAMPLES_PASSED`) result is non-zero or if the (`GL_ANY_SAMPLES_PASSED`) result is `GL_TRUE`, such commands are not discarded. The *`id`* parameter to `glBeginConditionalRender` must be the name of a query object previously returned from a call to [glGenQueries](glgenqueries.xhtml). *`mode`* specifies how the results of the query object are to be interpreted. If *`mode`* is `GL_QUERY_WAIT`, the GL waits for the results of the query to be available and then uses the results to determine if subsequent rendering commands are discarded. If *`mode`* is `GL_QUERY_NO_WAIT`, the GL may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.\n\nIf *`mode`* is `GL_QUERY_BY_REGION_WAIT`, the GL will also wait for occlusion query results and discard rendering commands if the result of the occlusion query is zero. If the query result is non-zero, subsequent rendering commands are executed, but the GL may discard the results of the commands for any region of the framebuffer that did not contribute to the sample count in the specified occlusion query. Any such discarding is done in an implementation-dependent manner, but the rendering command results may not be discarded for any samples that contributed to the occlusion query sample count. If *`mode`* is `GL_QUERY_BY_REGION_NO_WAIT`, the GL operates as in `GL_QUERY_BY_REGION_WAIT`, but may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.\n\n## Notes\n\n`glBeginConditionalRender` and `glEndConditionalRender` are available only if the GL version is 3.0 or greater.\n\nThe `GL_ANY_SAMPLES_PASSED` query result is available only if the GL version is 3.3 or greater.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`id`* is not the name of an existing query object.\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of the accepted tokens.\n\n`GL_INVALID_OPERATION` is generated if `glBeginConditionalRender` is called while conditional rendering is active, or if `glEndConditionalRender` is called while conditional rendering is inactive.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of a query object with a target other than `GL_SAMPLES_PASSED` or `GL_ANY_SAMPLES_PASSED`.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of a query currently in progress.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBeginConditionalRender`    |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glEndConditionalRender`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGenQueries](glgenqueries.xhtml), [glDeleteQueries](gldeletequeries.xhtml), [glBeginQuery](glbeginquery.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginConditionalRender.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginConditionalRender.xhtml)"
- name: glEndQuery
  id: glbeginquery.xhtml#glEndQuery
  summary: Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery
  belongs_to: glBeginQuery
  description: "`void `**`glEndQuery`**`(` GLenum `target``)`;\n\n## Parameters for `glBeginQuery`\n\n*`target`*\n\nSpecifies the target type of query object established between `glBeginQuery` and the subsequent `glEndQuery`. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.\n\n*`id`*\n\nSpecifies the name of a query object.\n\n## Parameters for `glEndQuery`\n\n*`target`*\n\nSpecifies the target type of query object to be concluded. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.\n\n## Description\n\n`glBeginQuery` and `glEndQuery` delimit the boundaries of a query object. *`query`* must be a name previously returned from a call to [glGenQueries](glgenqueries.xhtml). If a query object with name *`id`* does not yet exist it is created with the type determined by *`target`*. *`target`* must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. The behavior of the query object depends on its type and is as follows.\n\nIf *`target`* is `GL_SAMPLES_PASSED`, *`id`* must be an unused name, or the name of an existing occlusion query object. When `glBeginQuery` is executed, the query object's samples-passed counter is reset to 0. Subsequent rendering will increment the counter for every sample that passes the depth test. If the value of `GL_SAMPLE_BUFFERS` is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of `GL_SAMPLE_BUFFERS` is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of `GL_SAMPLES` if any sample in the fragment is covered. When `glEndQuery` is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nIf *`target`* is `GL_ANY_SAMPLES_PASSED` or `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`, *`id`* must be an unused name, or the name of an existing boolean occlusion query object. When `glBeginQuery` is executed, the query object's samples-passed flag is reset to `GL_FALSE`. Subsequent rendering causes the flag to be set to `GL_TRUE` if any sample passes the depth test in the case of `GL_ANY_SAMPLES_PASSED`, or if the implementation determines that any sample might pass the depth test in the case of `GL_ANY_SAMPLES_PASSED_CONSERVATIVE`. The implementation may be able to provide a more efficient test in the case of `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` if some false positives are acceptable to the application. When `glEndQuery` is executed, the samples-passed flag is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nIf *`target`* is `GL_PRIMITIVES_GENERATED`, *`id`* must be an unused name, or the name of an existing primitive query object previously bound to the `GL_PRIMITIVES_GENERATED` query binding. When `glBeginQuery` is executed, the query object's primitives-generated counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader, or from the vertex shader if no geometry shader is present. When `glEndQuery` is executed, the primitives-generated counter is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nIf *`target`* is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, *`id`* must be an unused name, or the name of an existing primitive query object previously bound to the `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN` query binding. When `glBeginQuery` is executed, the query object's primitives-written counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s). If transform feedback mode is not activated between the call to `glBeginQuery` and `glEndQuery`, the counter will not be incremented. When `glEndQuery` is executed, the primitives-written counter is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nIf *`target`* is `GL_TIME_ELAPSED`, *`id`* must be an unused name, or the name of an existing timer query object previously bound to the `GL_TIME_ELAPSED` query binding. When `glBeginQuery` is executed, the query object's time counter is reset to 0. When `glEndQuery` is executed, the elapsed server time that has passed since the call to `glBeginQuery` is written into the query object's time counter. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`.\n\nQuerying the `GL_QUERY_RESULT` implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. `GL_QUERY_RESULT_AVAILABLE` can be queried to determine if the result is immediately available or if the rendering is not yet complete.\n\n## Notes\n\nIf the query target's count exceeds the maximum value representable in the number of available bits, as reported by [glGetQueryiv](glgetqueryiv.xhtml) with *`target`* set to the appropriate query target and *`pname`* `GL_QUERY_COUNTER_BITS`, the count becomes undefined.\n\nAn implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.\n\nWhen `GL_SAMPLE_BUFFERS` is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test. When `GL_SAMPLE_BUFFERS` is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test.\n\nThe query targets `GL_ANY_SAMPLES_PASSED`, and `GL_TIME_ELAPSED` are availale only if the GL version is 3.3 or higher.\n\nThe query target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only of the GL version is 4.3 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of the accepted tokens.\n\n`GL_INVALID_OPERATION` is generated if `glBeginQuery` is executed while a query object of the same *`target`* is already active.\n\n`GL_INVALID_OPERATION` is generated if `glEndQuery` is executed when a query object of the same *`target`* is not active.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is 0.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of an already active query object.\n\n`GL_INVALID_OPERATION` is generated if *`id`* refers to an existing query object whose type does not does not match *`target`*.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBeginQuery`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glEndQuery`                  |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBeginQueryIndexed](glbeginqueryindexed.xhtml), [glDeleteQueries](gldeletequeries.xhtml), `glEndQuery`, [glGenQueries](glgenqueries.xhtml), [glGetQueryObject](glgetqueryobject.xhtml), [glGetQueryiv](glgetqueryiv.xhtml), [glIsQuery](glisquery.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginQuery.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginQuery.xhtml)"
- name: glEndQueryIndexed
  id: glbeginqueryindexed.xhtml#glEndQueryIndexed
  summary: Specifies the target type of query object established between glBeginQueryIndexed and the subsequent glEndQueryIndexed
  belongs_to: glBeginQueryIndexed
  description: "`void `**`glEndQueryIndexed`**`(` GLenum `target`, GLuint `index``)`;\n\n## Parameters for `glBeginQueryIndexed`\n\n*`target`*\n\nSpecifies the target type of query object established between `glBeginQueryIndexed` and the subsequent `glEndQueryIndexed`. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.\n\n*`index`*\n\nSpecifies the index of the query target upon which to begin the query.\n\n*`id`*\n\nSpecifies the name of a query object.\n\n## Parameters for `glEndQueryIndexed`\n\n*`target`*\n\nSpecifies the target type of query object to be concluded. The symbolic constant must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`.\n\n*`index`*\n\nSpecifies the index of the query target upon which to end the query.\n\n## Description\n\n`glBeginQueryIndexed` and `glEndQueryIndexed` delimit the boundaries of a query object. *`query`* must be a name previously returned from a call to [glGenQueries](glgenqueries.xhtml). If a query object with name *`id`* does not yet exist it is created with the type determined by *`target`*. *`target`* must be one of `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, or `GL_TIME_ELAPSED`. The behavior of the query object depends on its type and is as follows.\n\n*`index`* specifies the index of the query target and must be between a *`target`*-specific maximum.\n\nIf *`target`* is `GL_SAMPLES_PASSED`, *`id`* must be an unused name, or the name of an existing occlusion query object. When `glBeginQueryIndexed` is executed, the query object's samples-passed counter is reset to 0. Subsequent rendering will increment the counter for every sample that passes the depth test. If the value of `GL_SAMPLE_BUFFERS` is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of `GL_SAMPLE_BUFFERS` is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of `GL_SAMPLES` if any sample in the fragment is covered. When `glEndQueryIndexed` is executed, the samples-passed counter is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_SAMPLES_PASSED`, *`index`* must be zero.\n\nIf *`target`* is `GL_ANY_SAMPLES_PASSED`, *`id`* must be an unused name, or the name of an existing boolean occlusion query object. When `glBeginQueryIndexed` is executed, the query object's samples-passed flag is reset to `GL_FALSE`. Subsequent rendering causes the flag to be set to `GL_TRUE` if any sample passes the depth test. When `glEndQueryIndexed` is executed, the samples-passed flag is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_ANY_SAMPLES_PASSED`, *`index`* must be zero.\n\nIf *`target`* is `GL_PRIMITIVES_GENERATED`, *`id`* must be an unused name, or the name of an existing primitive query object previously bound to the `GL_PRIMITIVES_GENERATED` query binding. When `glBeginQueryIndexed` is executed, the query object's primitives-generated counter is reset to 0. Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader to the stream given by *`index`*, or from the vertex shader if *`index`* is zero and no geometry shader is present. When `glEndQueryIndexed` is executed, the primitives-generated counter for stream *`index`* is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_PRIMITIVES_GENERATED`, *`index`* must be less than the value of `GL_MAX_VERTEX_STREAMS`.\n\nIf *`target`* is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, *`id`* must be an unused name, or the name of an existing primitive query object previously bound to the `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN` query binding. When `glBeginQueryIndexed` is executed, the query object's primitives-written counter for the stream specified by *`index`* is reset to 0. Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s) for stream *`index`*. If transform feedback mode is not activated between the call to `glBeginQueryIndexed` and `glEndQueryIndexed`, the counter will not be incremented. When `glEndQueryIndexed` is executed, the primitives-written counter for stream *`index`* is assigned to the query object's result value. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, *`index`* must be less than the value of `GL_MAX_VERTEX_STREAMS`.\n\nIf *`target`* is `GL_TIME_ELAPSED`, *`id`* must be an unused name, or the name of an existing timer query object previously bound to the `GL_TIME_ELAPSED` query binding. When `glBeginQueryIndexed` is executed, the query object's time counter is reset to 0. When `glEndQueryIndexed` is executed, the elapsed server time that has passed since the call to `glBeginQueryIndexed` is written into the query object's time counter. This value can be queried by calling [glGetQueryObject](glgetqueryobject.xhtml) with *`pname`* `GL_QUERY_RESULT`. When *`target`* is `GL_TIME_ELAPSED`, *`index`* must be zero.\n\nQuerying the `GL_QUERY_RESULT` implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. `GL_QUERY_RESULT_AVAILABLE` can be queried to determine if the result is immediately available or if the rendering is not yet complete.\n\n## Notes\n\nIf the query target's count exceeds the maximum value representable in the number of available bits, as reported by [glGetQueryiv](glgetqueryiv.xhtml) with *`target`* set to the appropriate query target and *`pname`* `GL_QUERY_COUNTER_BITS`, the count becomes undefined.\n\nAn implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless.\n\nWhen `GL_SAMPLE_BUFFERS` is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test. When `GL_SAMPLE_BUFFERS` is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test.\n\nCalling [glBeginQuery](glbeginquery.xhtml) or `glEndQuery` is equivalent to calling [glBeginQueryIndexed](glbeginqueryindexed.xhtml) or `glEndQueryIndexed` with *`index`* set to zero, respectively.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of the accepted tokens.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than the query target-specific maximum.\n\n`GL_INVALID_OPERATION` is generated if `glBeginQueryIndexed` is executed while a query object of the same *`target`* is already active.\n\n`GL_INVALID_OPERATION` is generated if `glEndQueryIndexed` is executed when a query object of the same *`target`* is not active.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is 0.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of an already active query object.\n\n`GL_INVALID_OPERATION` is generated if *`id`* refers to an existing query object whose type does not does not match *`target`*.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBeginQueryIndexed`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glEndQueryIndexed`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBeginQuery](glbeginquery.xhtml), [glDeleteQueries](gldeletequeries.xhtml), `glEndQuery`, [glGenQueries](glgenqueries.xhtml), [glGetQueryObject](glgetqueryobject.xhtml), [glGetQueryiv](glgetqueryiv.xhtml), [glIsQuery](glisquery.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginQueryIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginQueryIndexed.xhtml)"
- name: glEndTransformFeedback
  id: glbegintransformfeedback.xhtml#glEndTransformFeedback
  summary: Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback
  belongs_to: glBeginTransformFeedback
  description: "`void `**`glEndTransformFeedback`**`(``void``)`;\n\n## Parameters for `glBeginTransformFeedback`\n\n*`primitiveMode`*\n\nSpecify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.\n\n## Description\n\nTransform feedback mode captures the values of varying variables written by the vertex shader (or, if active, the geometry shader). Transform feedback is said to be active after a call to `glBeginTransformFeedback` until a subsequent call to `glEndTransformFeedback`. Transform feedback commands must be paired.\n\nIf no geometry shader is present, while transform feedback is active the *`mode`* parameter to [glDrawArrays](gldrawarrays.xhtml) must match those specified in the following table:\n\n|  **Transform Feedback *`primitiveMode`***  |  **Allowed Render Primitive *`modes`***                                                                         |\n|:-------------------------------------------|:----------------------------------------------------------------------------------------------------------------|\n| `GL_POINTS`                                | `GL_POINTS`                                                                                                     |\n| `GL_LINES`                                 | `GL_LINES`, `GL_LINE_LOOP`, `GL_LINE_STRIP`, `GL_LINES_ADJACENCY`, `GL_LINE_STRIP_ADJACENCY`                    |\n| `GL_TRIANGLES`                             | `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` |\n\nIf a geometry shader is present, the output primitive type from the geometry shader must match those provided in the following table:\n\n|  **Transform Feedback *`primitiveMode`***  |  **Allowed Geometry Shader Output Primitive Type**  |\n|:-------------------------------------------|:----------------------------------------------------|\n| `GL_POINTS`                                | `points`                                            |\n| `GL_LINES`                                 | `line_strip`                                        |\n| `GL_TRIANGLES`                             | `triangle_strip`                                    |\n\n## Notes\n\nGeometry shaders, and the `GL_TRIANGLES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY` and `GL_LINE_STRIP_ADJACENCY` primtive modes are available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if `glBeginTransformFeedback` is executed while transform feedback is active.\n\n`GL_INVALID_OPERATION` is generated if `glEndTransformFeedback` is executed while transform feedback is not active.\n\n`GL_INVALID_OPERATION` is generated by [glDrawArrays](gldrawarrays.xhtml) if no geometry shader is present, transform feedback is active and *`mode`* is not one of the allowed modes.\n\n`GL_INVALID_OPERATION` is generated by [glDrawArrays](gldrawarrays.xhtml) if a geometry shader is present, transform feedback is active and the output primitive type of the geometry shader does not match the transform feedback *`primitiveMode`*.\n\n`GL_INVALID_OPERATION` is generated by `glBeginTransformFeedback` if any binding point used in transform feedback mode does not have a buffer object bound.\n\n`GL_INVALID_OPERATION` is generated by `glBeginTransformFeedback` if no binding points would be used, either because no program object is active of because the active program object has specified no varying variables to record.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBeginTransformFeedback`    |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glEndTransformFeedback`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginTransformFeedback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBeginTransformFeedback.xhtml)"
- name: glFenceSync
  id: glfencesync.xhtml
  summary: condition Specifies the condition that must be met to set the sync object's state to signaled
  description: "## Name\n\nglFenceSync — create a new sync object and insert it into the GL command stream\n\n## C Specification\n\n`GLsync `**`glFenceSync`**`(` GLenum `condition`, GLbitfield `flags``)`;\n\n## Parameters\n\n *`condition`*  \nSpecifies the condition that must be met to set the sync object's state to signaled. *`condition`* must be `GL_SYNC_GPU_COMMANDS_COMPLETE`.\n\n *`flags`*  \nSpecifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and *`flags`* must be zero.[^(\\[1\\])](#ftn.id-1.5.2.2.2.1.2)\n\n## Description\n\n`glFenceSync` creates a new fence sync object, inserts a fence command into the GL command stream and associates it with that sync object, and returns a non-zero name corresponding to the sync object.\n\nWhen the specified *`condition`* of the sync object is satisfied by the fence command, the sync object is signaled by the GL, causing any [glWaitSync](glwaitsync.xhtml), [glClientWaitSync](glclientwaitsync.xhtml) commands blocking in *`sync`* to *unblock*. No other state is affected by `glFenceSync` or by the execution of the associated fence command.\n\n*`condition`* must be `GL_SYNC_GPU_COMMANDS_COMPLETE`. This condition is satisfied by completion of the fence command corresponding to the sync object and all preceding commands in the same command stream. The sync object will not be signaled until all effects from these commands on GL client and server state and the framebuffer are fully realized. Note that completion of the fence command occurs once the state of the corresponding sync object has been changed, but commands waiting on that sync object may not be unblocked until after the fence command completes.\n\n## Notes\n\n`glFenceSync` is only supported if the GL version is 3.2 or greater, or if the `ARB_sync` extension is supported.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`condition`* is not `GL_SYNC_GPU_COMMANDS_COMPLETE`.\n\n`GL_INVALID_VALUE` is generated if *`flags`* is not zero.\n\nAdditionally, if `glFenceSync` fails, it will return zero.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glFenceSync`               |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDeleteSync](gldeletesync.xhtml), [glGetSync](glgetsync.xhtml), [glWaitSync](glwaitsync.xhtml), [glClientWaitSync](glclientwaitsync.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\n  \n\n------------------------------------------------------------------------\n\n[^(\\[1\\])](#id-1.5.2.2.2.1.2) *`flags`* is a placeholder for anticipated future extensions of fence sync object capabilities.\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFenceSync.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFenceSync.xhtml)"
- name: glFinish
  id: glfinish.xhtml
  summary: glFinish does not return until the effects of all previously called GL commands are complete
  description: "## Name\n\nglFinish — block until all GL execution is complete\n\n## C Specification\n\n`void `**`glFinish`**`(` `void``)`;\n\n## Description\n\n`glFinish` does not return until the effects of all previously called GL commands are complete. Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.\n\n## Notes\n\n`glFinish` requires a round trip to the server.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glFinish`                  |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glFlush](glflush.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFinish.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFinish.xhtml)"
- name: glFlush
  id: glflush.xhtml
  summary: Different GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself
  description: "## Name\n\nglFlush — force execution of GL commands in finite time\n\n## C Specification\n\n`void `**`glFlush`**`(` `void``)`;\n\n## Description\n\nDifferent GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. `glFlush` empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in finite time.\n\nBecause any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call `glFlush` whenever they count on having all of their previously issued commands completed. For example, call `glFlush` before waiting for user input that depends on the generated image.\n\n## Notes\n\n`glFlush` can return at any time. It does not wait until the execution of all previously issued GL commands is complete.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glFlush`                   |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glFinish](glfinish.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFlush.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFlush.xhtml)"
- name: glFlushMappedBufferRange
  id: glflushmappedbufferrange.xhtml
  summary: buffer Specifies the name of the buffer object for glFlushMappedNamedBufferRange
  description: "## Name\n\nglFlushMappedBufferRange, glFlushMappedNamedBufferRange — indicate modifications to a range of a mapped buffer\n\n## C Specification\n\n`void `**`glFlushMappedBufferRange`**`(` GLenum `target`, GLintptr `offset`, GLsizeiptr `length``)`;\n\n`void `**`glFlushMappedNamedBufferRange`**`(` GLuint `buffer`, GLintptr `offset`, GLsizeiptr `length``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glFlushMappedBufferRange`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glFlushMappedNamedBufferRange`.\n\n *`offset`*  \nSpecifies the start of the buffer subrange, in basic machine units.\n\n *`length`*  \nSpecifies the length of the buffer subrange, in basic machine units.\n\n## Description\n\n`glFlushMappedBufferRange` indicates that modifications have been made to a range of a mapped buffer object. The buffer object must previously have been mapped with the `GL_MAP_FLUSH_EXPLICIT_BIT` flag.\n\n*`offset`* and *`length`* indicate the modified subrange of the mapping, in basic machine units. The specified subrange to flush is relative to the start of the currently mapped range of the buffer. These commands may be called multiple times to indicate distinct subranges of the mapping which require flushing.\n\nIf a buffer range is mapped with both `GL_MAP_PERSISTENT_BIT` and `GL_MAP_FLUSH_EXPLICIT_BIT` set, then these commands may be called to ensure that data written by the client into the flushed region becomes visible to the server. Data written to a coherent store will always become visible to the server after an unspecified period of time.\n\n## Notes\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glFlushMappedBufferRange` if *`target`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glFlushMappedBufferRange` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glFlushMappedNamedBufferRange` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`length`* is negative, or if *`offset`* + *`length`* exceeds the size of the mapping.\n\n`GL_INVALID_OPERATION` is generated if the buffer object is not mapped, or is mapped without the `GL_MAP_FLUSH_EXPLICIT_BIT` flag.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glFlushMappedBufferRange`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glFlushMappedNamedBufferRange` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glMapBufferRange](glmapbufferrange.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFlushMappedBufferRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFlushMappedBufferRange.xhtml)"
- name: glFlushMappedNamedBufferRange
  id: glflushmappedbufferrange.xhtml#glFlushMappedNamedBufferRange
  summary: Specifies the name of the buffer object for glFlushMappedNamedBufferRange
  belongs_to: glFlushMappedBufferRange
  description: "`void `**`glFlushMappedNamedBufferRange`**`(` GLuint `buffer`, GLintptr `offset`, GLsizeiptr `length``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glFlushMappedBufferRange`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glFlushMappedNamedBufferRange`.\n\n*`offset`*\n\nSpecifies the start of the buffer subrange, in basic machine units.\n\n*`length`*\n\nSpecifies the length of the buffer subrange, in basic machine units.\n\n## Description\n\n`glFlushMappedBufferRange` indicates that modifications have been made to a range of a mapped buffer object. The buffer object must previously have been mapped with the `GL_MAP_FLUSH_EXPLICIT_BIT` flag.\n\n*`offset`* and *`length`* indicate the modified subrange of the mapping, in basic machine units. The specified subrange to flush is relative to the start of the currently mapped range of the buffer. These commands may be called multiple times to indicate distinct subranges of the mapping which require flushing.\n\nIf a buffer range is mapped with both `GL_MAP_PERSISTENT_BIT` and `GL_MAP_FLUSH_EXPLICIT_BIT` set, then these commands may be called to ensure that data written by the client into the flushed region becomes visible to the server. Data written to a coherent store will always become visible to the server after an unspecified period of time.\n\n## Notes\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glFlushMappedBufferRange` if *`target`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glFlushMappedBufferRange` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glFlushMappedNamedBufferRange` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`length`* is negative, or if *`offset`* + *`length`* exceeds the size of the mapping.\n\n`GL_INVALID_OPERATION` is generated if the buffer object is not mapped, or is mapped without the `GL_MAP_FLUSH_EXPLICIT_BIT` flag.\n\n## Version Support\n\n|                                 |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**    |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glFlushMappedBufferRange`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glFlushMappedNamedBufferRange` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glMapBufferRange](glmapbufferrange.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFlushMappedBufferRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFlushMappedBufferRange.xhtml)"
- name: glFramebufferParameteri
  id: glframebufferparameteri.xhtml
  summary: target Specifies the target to which the framebuffer is bound for glFramebufferParameteri
  description: "## Name\n\nglFramebufferParameteri, glNamedFramebufferParameteri — set a named parameter of a framebuffer object\n\n## C Specification\n\n`void `**`glFramebufferParameteri`**`(` GLenum `target`, GLenum `pname`, GLint `param``)`;\n\n`void `**`glNamedFramebufferParameteri`**`(` GLuint `framebuffer`, GLenum `pname`, GLint `param``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the framebuffer is bound for `glFramebufferParameteri`.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glNamedFramebufferParameteri`.\n\n *`pname`*  \nSpecifies the framebuffer parameter to be modified.\n\n *`param`*  \nThe new value for the parameter named *`pname`*.\n\n## Description\n\n`glFramebufferParameteri` and `glNamedFramebufferParameteri` modify the value of the parameter named *`pname`* in the specified framebuffer object. There are no modifiable parameters of the default draw and read framebuffer, so they are not valid targets of these commands.\n\nFor `glFramebufferParameteri`, the framebuffer object is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glNamedFramebufferParameteri`, *`framebuffer`* is the name of the framebuffer object.\n\n*`pname`* specifies the parameter to be modified. The following values are accepted:\n\n `GL_FRAMEBUFFER_DEFAULT_WIDTH`  \n*`param`* specifies the assumed width for a framebuffer object with no attachments. If a framebuffer has attachments then the width of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_WIDTH` is used for the framebuffer. *`param`* must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_WIDTH`.\n\n `GL_FRAMEBUFFER_DEFAULT_HEIGHT`  \n*`param`* specifies the assumed height for a framebuffer object with no attachments. If a framebuffer has attachments then the height of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_HEIGHT` is used for the framebuffer. *`param`* must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_HEIGHT`.\n\n `GL_FRAMEBUFFER_DEFAULT_LAYERS`  \n*`param`* specifies the assumed number of layers for a framebuffer object with no attachments. If a framebuffer has attachments then the layer count of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_LAYERS` is used for the framebuffer. *`param`* must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_LAYERS`.\n\n `GL_FRAMEBUFFER_DEFAULT_SAMPLES`  \n*`param`* specifies the assumed number of samples in a framebuffer object with no attachments. If a framebuffer has attachments then the sample count of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_SAMPLES` is used for the framebuffer. *`param`* must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_SAMPLE`.\n\n `GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`  \n*`param`* specifies whether the framebuffer should assume identical sample locations and the same number of samples for all texels in the virtual image. If *`param`* is zero, then the implementation may vary the position or the count of samples within the virtual image from pixel to pixel, otherwise it will use the same sample position and count for all pixels in the virtual image.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glFramebufferParameteri` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glFramebufferParameteri` if the default framebuffer is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferParameteri` if *`framebuffer`* is not the name of an existing framebuffer object.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_FRAMEBUFFER_DEFAULT_WIDTH` and *`param`* is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_WIDTH`.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_FRAMEBUFFER_DEFAULT_HEIGHT` and *`param`* is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_HEIGHT`.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_FRAMEBUFFER_DEFAULT_LAYERS` and *`param`* is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_LAYERS`.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_FRAMEBUFFER_DEFAULT_SAMPLES` and *`param`* is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_SAMPLES`.\n\n## Associated Gets\n\n`glGetFramebufferParameteriv`.\n\n## Version Support\n\n|                                | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**    |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glFramebufferParameteri`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glNamedFramebufferParameteri` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindFramebuffer](glbindframebuffer.xhtml), [glCreateFramebuffers](glcreateframebuffers.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml), [glGenFramebuffers](glgenframebuffers.xhtml), [glGetFramebufferParameter](glgetframebufferparameter.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferParameteri.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferParameteri.xhtml)"
- name: glFramebufferRenderbuffer
  id: glframebufferrenderbuffer.xhtml
  summary: target Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer
  description: "## Name\n\nglFramebufferRenderbuffer, glNamedFramebufferRenderbuffer — attach a renderbuffer as a logical buffer of a framebuffer object\n\n## C Specification\n\n`void `**`glFramebufferRenderbuffer`**`(` GLenum `target`, GLenum `attachment`, GLenum `renderbuffertarget`, GLuint `renderbuffer``)`;\n\n`void `**`glNamedFramebufferRenderbuffer`**`(` GLuint `framebuffer`, GLenum `attachment`, GLenum `renderbuffertarget`, GLuint `renderbuffer``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the framebuffer is bound for `glFramebufferRenderbuffer`.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glNamedFramebufferRenderbuffer`.\n\n *`attachment`*  \nSpecifies the attachment point of the framebuffer.\n\n *`renderbuffertarget`*  \nSpecifies the renderbuffer target. Must be `GL_RENDERBUFFER`.\n\n *`renderbuffer`*  \nSpecifies the name of an existing renderbuffer object of type *`renderbuffertarget`* to attach.\n\n## Description\n\n`glFramebufferRenderbuffer` and `glNamedFramebufferRenderbuffer` attaches a renderbuffer as one of the logical buffers of the specified framebuffer object. Renderbuffers cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands.\n\nFor `glFramebufferRenderbuffer`, the framebuffer object is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glNamedFramebufferRenderbuffer`, *`framebuffer`* is the name of the framebuffer object.\n\n*`renderbuffertarget`* must be `GL_RENDERBUFFER`.\n\n*`renderbuffer`* must be zero or the name of an existing renderbuffer object of type *`renderbuffertarget`*. If *`renderbuffer`* is not zero, then the specified renderbuffer will be used as the logical buffer identified by *`attachment`* of the specified framebuffer object. If *`renderbuffer`* is zero, then the value of *`renderbuffertarget`* is ignored.\n\n*`attachment`* specifies the logical attachment of the framebuffer and must be `GL_COLOR_ATTACHMENT`*i*, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. *i* in may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one. Setting *`attachment`* to the value `GL_DEPTH_STENCIL_ATTACHMENT` is a special case causing both the depth and stencil attachments of the specified framebuffer object to be set to *`renderbuffer`*, which should have the base internal format `GL_DEPTH_STENCIL`.\n\nThe value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` for the specified attachment point is set to `GL_RENDERBUFFER` and the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is set to *`renderbuffer`*. All other state values of specified attachment point are set to their default values. No change is made to the state of the renderbuuffer object and any previous attachment to the *`attachment`* logical buffer of the specified framebuffer object is broken.\n\nIf *`renderbuffer`* is zero, these commands will detach the image, if any, identified by the specified attachment point of the specified framebuffer object. All state values of the attachment point are set to their default values.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glFramebufferRenderbuffer` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glFramebufferRenderbuffer` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferRenderbuffer` if *`framebuffer`* is not the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`attachment`* is not one of the accepted attachment points.\n\n`GL_INVALID_ENUM` is generated if *`renderbuffertarget`* is not `GL_RENDERBUFFER`.\n\n`GL_INVALID_OPERATION` is generated if *`renderbuffertarget`* is not zero or the name of an existing renderbuffer object of type `GL_RENDERBUFFER`.\n\n## Version Support\n\n|                                  | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:---------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**      |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glFramebufferRenderbuffer`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glNamedFramebufferRenderbuffer` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml), [glGenRenderbuffers](glgenrenderbuffers.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml), `glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferRenderbuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferRenderbuffer.xhtml)"
- name: glFramebufferTexture
  id: glframebuffertexture.xhtml
  summary: target Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture
  description: "## Name\n\nglFramebufferTexture — attach a level of a texture object as a logical buffer of a framebuffer object\n\n## C Specification\n\n`void `**`glFramebufferTexture`**`(` GLenum `target`, GLenum `attachment`, GLuint `texture`, GLint `level``)`;\n\n`void `**`glFramebufferTexture1D`**`(` GLenum `target`, GLenum `attachment`, GLenum `textarget`, GLuint `texture`, GLint `level``)`;\n\n`void `**`glFramebufferTexture2D`**`(` GLenum `target`, GLenum `attachment`, GLenum `textarget`, GLuint `texture`, GLint `level``)`;\n\n`void `**`glFramebufferTexture3D`**`(` GLenum `target`, GLenum `attachment`, GLenum `textarget`, GLuint `texture`, GLint `level`, GLint `layer``)`;\n\n`void `**`glNamedFramebufferTexture`**`(` GLuint `framebuffer`, GLenum `attachment`, GLuint `texture`, GLint `level``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the framebuffer is bound for all commands *except* `glNamedFramebufferTexture`.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glNamedFramebufferTexture`.\n\n *`attachment`*  \nSpecifies the attachment point of the framebuffer.\n\n *`textarget`*  \nFor `glFramebufferTexture1D`, `glFramebufferTexture2D` and `glFramebufferTexture3D`, specifies what type of texture is expected in the *`texture`* parameter, or for cube map textures, which face is to be attached.\n\n *`texture`*  \nSpecifies the name of an existing texture object to attach.\n\n *`level`*  \nSpecifies the mipmap level of the texture object to attach.\n\n## Description\n\nThese commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands.\n\nFor all commands *except* `glNamedFramebufferTexture`, the framebuffer object is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glNamedFramebufferTexture`, *`framebuffer`* is the name of the framebuffer object.\n\n*`attachment`* specifies the logical attachment of the framebuffer and must be `GL_COLOR_ATTACHMENT`*i*, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. *i* in `GL_COLOR_ATTACHMENT`*i* may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one. Attaching a level of a texture to `GL_DEPTH_STENCIL_ATTACHMENT` is equivalent to attaching that level to both the `GL_DEPTH_ATTACHMENT` *and* the `GL_STENCIL_ATTACHMENT` attachment points simultaneously.\n\nFor `glFramebufferTexture1D`, `glFramebufferTexture2D` and `glFramebufferTexture3D`, *`textarget`* specifies what type of texture is named by *`texture`*, and for cube map textures, specifies the face that is to be attached. If *`texture`* is not zero, it must be the name of an existing texture object with effective target *`textarget`* unless it is a cube map texture, in which case *`textarget`* must be `GL_TEXTURE_CUBE_MAP_POSITIVE_X` `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.\n\nIf *`texture`* is non-zero, the specified *`level`* of the texture object named *`texture`* is attached to the framebuffer attachment point named by *`attachment`*. For `glFramebufferTexture1D`, `glFramebufferTexture2D`, and `glFramebufferTexture3D`, *`texture`* must be zero or the name of an existing texture with an effective target of *`textarget`*, or *`texture`* must be the name of an existing cube-map texture and *`textarget`* must be one of `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.\n\nIf *`textarget`* is `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, then *`level`* must be zero.\n\nIf *`textarget`* is `GL_TEXTURE_3D`, then *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_3D_TEXTURE_SIZE`.\n\nIf *`textarget`* is one of `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, then *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_CUBE_MAP_TEXTURE_SIZE`.\n\nFor all other values of *`textarget`*, *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_TEXTURE_SIZE`.\n\n*`layer`* specifies the layer of a 2-dimensional image within a 3-dimensional texture.\n\nFor `glFramebufferTexture1D`, if *`texture`* is not zero, then *`textarget`* must be `GL_TEXTURE_1D`. For `glFramebufferTexture2D`, if *`texture`* is not zero, *`textarget`* must be one of `GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_2D_MULTISAMPLE`. For `glFramebufferTexture3D`, if *`texture`* is not zero, then *`textarget`* must be `GL_TEXTURE_3D`.\n\nFor `glFramebufferTexture` and `glNamedFramebufferTexture`, if *`texture`* is the name of a three-dimensional, cube map array, cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an array of images, and the framebuffer attachment is considered to be *layered*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by all commands accepting a *`target`* parameter if it is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by all commands accepting a *`target`* parameter if zero is bound to that target.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferTexture` if *`framebuffer`* is not the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`attachment`* is not one of the accepted attachment points.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero or the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero and *`level`* is not a supported texture level for *`texture`*.\n\n`GL_INVALID_VALUE` is generated by `glFramebufferTexture3D` if *`texture`* is not zero and *`layer`* is larger than the value of `GL_MAX_3D_TEXTURE_SIZE` minus one.\n\n`GL_INVALID_OPERATION` is generated by all commands accepting a *`textarget`* parameter if *`texture`* is not zero, and *`textarget`* and the effective target of *`texture`* are not compatible.\n\n`GL_INVALID_OPERATION` is generated by if *`texture`* is a buffer texture.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glFramebufferTexture`      |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glFramebufferTexture1D`    |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glFramebufferTexture2D`    |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glFramebufferTexture3D`    |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glNamedFramebufferTexture` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml), [glGenRenderbuffers](glgenrenderbuffers.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml), `glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferTexture.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferTexture.xhtml)"
- name: glFramebufferTexture1D
  id: glframebuffertexture.xhtml#glFramebufferTexture1D
  summary: null
  belongs_to: glFramebufferTexture
  description: '`void `**`glFramebufferTexture1D`**`(` GLenum `target`, GLenum `attachment`, GLenum `textarget`, GLuint `texture`, GLint `level``)`;'
- name: glFramebufferTexture2D
  id: glframebuffertexture.xhtml#glFramebufferTexture2D
  summary: null
  belongs_to: glFramebufferTexture
  description: '`void `**`glFramebufferTexture2D`**`(` GLenum `target`, GLenum `attachment`, GLenum `textarget`, GLuint `texture`, GLint `level``)`;'
- name: glFramebufferTexture3D
  id: glframebuffertexture.xhtml#glFramebufferTexture3D
  summary: null
  belongs_to: glFramebufferTexture
  description: '`void `**`glFramebufferTexture3D`**`(` GLenum `target`, GLenum `attachment`, GLenum `textarget`, GLuint `texture`, GLint `level`, GLint `layer``)`;'
- name: glFramebufferTextureLayer
  id: glframebuffertexturelayer.xhtml
  summary: target Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer
  description: "## Name\n\nglFramebufferTextureLayer, glNamedFramebufferTextureLayer — attach a single layer of a texture object as a logical buffer of a framebuffer object\n\n## C Specification\n\n`void `**`glFramebufferTextureLayer`**`(` GLenum `target`, GLenum `attachment`, GLuint `texture`, GLint `level`, GLint `layer``)`;\n\n`void `**`glNamedFramebufferTextureLayer`**`(` GLuint `framebuffer`, GLenum `attachment`, GLuint `texture`, GLint `level`, GLint `layer``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the framebuffer is bound for `glFramebufferTextureLayer`.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glNamedFramebufferTextureLayer`.\n\n *`attachment`*  \nSpecifies the attachment point of the framebuffer.\n\n *`texture`*  \nSpecifies the name of an existing texture object to attach.\n\n *`level`*  \nSpecifies the mipmap level of the texture object to attach.\n\n *`layer`*  \nSpecifies the layer of the texture object to attach.\n\n## Description\n\n`glFramebufferTextureLayer` and `glNamedFramebufferTextureLayer` attach a single layer of a three-dimensional or array texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands.\n\nFor `glFramebufferTextureLayer`, the framebuffer object is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glNamedFramebufferTextureLayer`, *`framebuffer`* is the name of the framebuffer object.\n\n*`attachment`* specifies the logical attachment of the framebuffer and must be `GL_COLOR_ATTACHMENT`*i*, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. *i* in `GL_COLOR_ATTACHMENT`*i* may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one. Attaching a level of a texture to `GL_DEPTH_STENCIL_ATTACHMENT` is equivalent to attaching that level to both the `GL_DEPTH_ATTACHMENT` *and* the `GL_STENCIL_ATTACHMENT` attachment points simultaneously.\n\nIf *`texture`* is not zero, it must be the name of a three-dimensional, two-dimensional multisample array, one- or two-dimensional array, or cube map array texture.\n\nIf *`texture`* is a three-dimensional texture, then *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_3D_TEXTURE_SIZE`.\n\nIf *`texture`* is a two-dimensional array texture, then *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_TEXTURE_SIZE`.\n\nFor cube map textures, *`layer`* is translated into a cube map face according to $$ face = k \\bmod 6. $$ For cube map array textures, *`layer`* is translated into an array layer and face according to $$ layer = \\left\\lfloor { layer \\over 6 } \\right\\rfloor$$ and $$ face = k \\bmod 6. $$\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glFramebufferTexture` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glFramebufferTexture` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferTexture` if *`framebuffer`* is not the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`attachment`* is not one of the accepted attachment points.\n\n`GL_INVALID_OPERATION` is generated if *`texture`* is not zero and is not the name of an existing three-dimensional, two-dimensional multisample array, one- or two-dimensional array, cube map, or cube map array texture.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero and *`level`* is not a supported texture level for *`texture`*, as described above.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero and *`layer`* is larger than the value of `GL_MAX_3D_TEXTURE_SIZE` minus one (for three-dimensional texture objects), or larger than the value of `GL_MAX_ARRAY_TEXTURE_LAYERS` minus one (for array texture objects).\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero and *`layer`* is negative.\n\n`GL_INVALID_OPERATION` is generated by if *`texture`* is a buffer texture.\n\n## Version Support\n\n|                                  | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:---------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**      |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glFramebufferTextureLayer`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glNamedFramebufferTextureLayer` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml), [glGenRenderbuffers](glgenrenderbuffers.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml),\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferTextureLayer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferTextureLayer.xhtml)"
- name: glFrontFace
  id: glfrontface.xhtml
  summary: mode Specifies the orientation of front-facing polygons
  description: "## Name\n\nglFrontFace — define front- and back-facing polygons\n\n## C Specification\n\n`void `**`glFrontFace`**`(` GLenum `mode``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies the orientation of front-facing polygons. `GL_CW` and `GL_CCW` are accepted. The initial value is `GL_CCW`.\n\n## Description\n\nIn a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing polygons, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_CULL_FACE`.\n\nThe projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. `glFrontFace` specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing `GL_CCW` to *`mode`* selects counterclockwise polygons as front-facing; `GL_CW` selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_FRONT_FACE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glFrontFace`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCullFace](glcullface.xhtml),\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFrontFace.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFrontFace.xhtml)"
- name: glGenBuffers
  id: glgenbuffers.xhtml
  summary: n Specifies the number of buffer object names to be generated
  description: "## Name\n\nglGenBuffers — generate buffer object names\n\n## C Specification\n\n`void `**`glGenBuffers`**`(` GLsizei `n`, GLuint \\* `buffers``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of buffer object names to be generated.\n\n *`buffers`*  \nSpecifies an array in which the generated buffer object names are stored.\n\n## Description\n\n`glGenBuffers` returns *`n`* buffer object names in *`buffers`*. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to `glGenBuffers`.\n\nBuffer object names returned by a call to `glGenBuffers` are not returned by subsequent calls, unless they are first deleted with [glDeleteBuffers](gldeletebuffers.xhtml).\n\nNo buffer objects are associated with the returned buffer object names until they are first bound by calling [glBindBuffer](glbindbuffer.xhtml).\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Associated Gets\n\n[glIsBuffer](glisbuffer.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenBuffers`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glGet](glget.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenBuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenBuffers.xhtml)"
- name: glGenerateMipmap
  id: glgeneratemipmap.xhtml
  summary: target Specifies the target to which the texture object is bound for glGenerateMipmap
  description: "## Name\n\nglGenerateMipmap, glGenerateTextureMipmap — generate mipmaps for a specified texture object\n\n## C Specification\n\n`void `**`glGenerateMipmap`**`(` GLenum `target``)`;\n\n`void `**`glGenerateTextureMipmap`**`(` GLuint `texture``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glGenerateMipmap`. Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n *`texture`*  \nSpecifies the texture object name for `glGenerateTextureMipmap`.\n\n## Description\n\n`glGenerateMipmap` and `glGenerateTextureMipmap` generates mipmaps for the specified texture object. For `glGenerateMipmap`, the texture object that is bound to *`target`*. For `glGenerateTextureMipmap`, *`texture`* is the name of the texture object.\n\nFor cube map and cube map array textures, the texture object must be cube complete or cube array complete respectively.\n\nMipmap generation replaces texel image levels $level\\_{base} + 1$ through $q$ with images derived from the $level\\_{base}$ image, regardless of their previous contents. All other mimap images, including the $level\\_{base}$ image, are left unchanged by this computation.\n\nThe internal formats of the derived mipmap images all match those of the $level\\_{base}$ image. The contents of the derived images are computed by repeated, filtered reduction of the $level\\_{base}$ image. For one- and two-dimensional array and cube map array textures, each layer is filtered independently.\n\n## Notes\n\nCube map array textures are accepted only if the GL version is 4.0 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGenerateMipmap` if *`target`* is not one of the accepted texture targets.\n\n`GL_INVALID_OPERATION` is generated by `glGenerateTextureMipmap` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is `GL_TEXTURE_CUBE_MAP` or `GL_TEXTURE_CUBE_MAP_ARRAY`, and the specified texture object is not cube complete or cube array complete, respectively.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenerateMipmap`          |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGenerateTextureMipmap`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glTexImage2D](glteximage2d.xhtml), [glBindTexture](glbindtexture.xhtml), [glGenTextures](glgentextures.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenerateMipmap.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenerateMipmap.xhtml)"
- name: glGenerateTextureMipmap
  id: glgeneratemipmap.xhtml#glGenerateTextureMipmap
  summary: Specifies the target to which the texture object is bound for glGenerateMipmap
  belongs_to: glGenerateMipmap
  description: "`void `**`glGenerateTextureMipmap`**`(` GLuint `texture``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glGenerateMipmap`. Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n*`texture`*\n\nSpecifies the texture object name for `glGenerateTextureMipmap`.\n\n## Description\n\n`glGenerateMipmap` and `glGenerateTextureMipmap` generates mipmaps for the specified texture object. For `glGenerateMipmap`, the texture object that is bound to *`target`*. For `glGenerateTextureMipmap`, *`texture`* is the name of the texture object.\n\nFor cube map and cube map array textures, the texture object must be cube complete or cube array complete respectively.\n\nMipmap generation replaces texel image levels $level\\_{base} + 1$ through $q$ with images derived from the $level\\_{base}$ image, regardless of their previous contents. All other mimap images, including the $level\\_{base}$ image, are left unchanged by this computation.\n\nThe internal formats of the derived mipmap images all match those of the $level\\_{base}$ image. The contents of the derived images are computed by repeated, filtered reduction of the $level\\_{base}$ image. For one- and two-dimensional array and cube map array textures, each layer is filtered independently.\n\n## Notes\n\nCube map array textures are accepted only if the GL version is 4.0 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGenerateMipmap` if *`target`* is not one of the accepted texture targets.\n\n`GL_INVALID_OPERATION` is generated by `glGenerateTextureMipmap` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is `GL_TEXTURE_CUBE_MAP` or `GL_TEXTURE_CUBE_MAP_ARRAY`, and the specified texture object is not cube complete or cube array complete, respectively.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGenerateMipmap`            |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGenerateTextureMipmap`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glTexImage2D](glteximage2d.xhtml), [glBindTexture](glbindtexture.xhtml), [glGenTextures](glgentextures.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenerateMipmap.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenerateMipmap.xhtml)"
- name: glGenFramebuffers
  id: glgenframebuffers.xhtml
  summary: n Specifies the number of framebuffer object names to generate
  description: "## Name\n\nglGenFramebuffers — generate framebuffer object names\n\n## C Specification\n\n`void `**`glGenFramebuffers`**`(` GLsizei `n`, GLuint \\*`ids``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of framebuffer object names to generate.\n\n *`ids`*  \nSpecifies an array in which the generated framebuffer object names are stored.\n\n## Description\n\n`glGenFramebuffers` returns *`n`* framebuffer object names in *`ids`*. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to `glGenFramebuffers`.\n\nFramebuffer object names returned by a call to `glGenFramebuffers` are not returned by subsequent calls, unless they are first deleted with [glDeleteFramebuffers](gldeleteframebuffers.xhtml).\n\nThe names returned in *`ids`* are marked as used, for the purposes of `glGenFramebuffers` only, but they acquire state and type only when they are first bound.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenFramebuffers`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindFramebuffer](glbindframebuffer.xhtml), [glDeleteFramebuffers](gldeleteframebuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenFramebuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenFramebuffers.xhtml)"
- name: glGenProgramPipelines
  id: glgenprogrampipelines.xhtml
  summary: n Specifies the number of program pipeline object names to reserve
  description: "## Name\n\nglGenProgramPipelines — reserve program pipeline object names\n\n## C Specification\n\n`void `**`glGenProgramPipelines`**`(` GLsizei `n`, GLuint \\*`pipelines``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of program pipeline object names to reserve.\n\n *`pipelines`*  \nSpecifies an array of into which the reserved names will be written.\n\n## Description\n\n`glGenProgramPipelines` returns *`n`* previously unused program pipeline object names in *`pipelines`*. These names are marked as used, for the purposes of `glGenProgramPipelines` only, but they acquire program pipeline state only when they are first bound.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_PROGRAM_PIPELINE_BINDING`\n\n[glIsProgramPipeline](glisprogrampipeline.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenProgramPipelines`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml), [glBindProgramPipeline](glbindprogrampipeline.xhtml), [glIsProgramPipeline](glisprogrampipeline.xhtml), [glUseProgramStages](gluseprogramstages.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenProgramPipelines.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenProgramPipelines.xhtml)"
- name: glGenQueries
  id: glgenqueries.xhtml
  summary: n Specifies the number of query object names to be generated
  description: "## Name\n\nglGenQueries — generate query object names\n\n## C Specification\n\n`void `**`glGenQueries`**`(` GLsizei `n`, GLuint \\* `ids``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of query object names to be generated.\n\n *`ids`*  \nSpecifies an array in which the generated query object names are stored.\n\n## Description\n\n`glGenQueries` returns *`n`* query object names in *`ids`*. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to `glGenQueries`.\n\nQuery object names returned by a call to `glGenQueries` are not returned by subsequent calls, unless they are first deleted with [glDeleteQueries](gldeletequeries.xhtml).\n\nNo query objects are associated with the returned query object names until they are first used by calling [glBeginQuery](glbeginquery.xhtml).\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Associated Gets\n\n[glIsQuery](glisquery.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenQueries`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBeginQuery](glbeginquery.xhtml), [glDeleteQueries](gldeletequeries.xhtml), `glEndQuery`\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenQueries.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenQueries.xhtml)"
- name: glGenRenderbuffers
  id: glgenrenderbuffers.xhtml
  summary: n Specifies the number of renderbuffer object names to generate
  description: "## Name\n\nglGenRenderbuffers — generate renderbuffer object names\n\n## C Specification\n\n`void `**`glGenRenderbuffers`**`(` GLsizei `n`, GLuint \\*`renderbuffers``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of renderbuffer object names to generate.\n\n *`renderbuffers`*  \nSpecifies an array in which the generated renderbuffer object names are stored.\n\n## Description\n\n`glGenRenderbuffers` returns *`n`* renderbuffer object names in *`renderbuffers`*. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to `glGenRenderbuffers`.\n\nRenderbuffer object names returned by a call to `glGenRenderbuffers` are not returned by subsequent calls, unless they are first deleted with [glDeleteRenderbuffers](gldeleterenderbuffers.xhtml).\n\nThe names returned in *`renderbuffers`* are marked as used, for the purposes of `glGenRenderbuffers` only, but they acquire state and type only when they are first bound.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenRenderbuffers`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glDeleteRenderbuffers](gldeleterenderbuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenRenderbuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenRenderbuffers.xhtml)"
- name: glGenSamplers
  id: glgensamplers.xhtml
  summary: n Specifies the number of sampler object names to generate
  description: "## Name\n\nglGenSamplers — generate sampler object names\n\n## C Specification\n\n`void `**`glGenSamplers`**`(` GLsizei `n`, GLuint \\*`samplers``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of sampler object names to generate.\n\n *`samplers`*  \nSpecifies an array in which the generated sampler object names are stored.\n\n## Description\n\n`glGenSamplers` returns *`n`* sampler object names in *`samplers`*. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to `glGenSamplers`.\n\nSampler object names returned by a call to `glGenSamplers` are not returned by subsequent calls, unless they are first deleted with [glDeleteSamplers](gldeletesamplers.xhtml).\n\nThe names returned in *`samplers`* are marked as used, for the purposes of `glGenSamplers` only, but they acquire state and type only when they are first bound.\n\n## Notes\n\n`glGenSamplers` is available only if the GL version is 3.3 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenSamplers`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindSampler](glbindsampler.xhtml), [glIsSampler](glissampler.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenSamplers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenSamplers.xhtml)"
- name: glGenTextures
  id: glgentextures.xhtml
  summary: n Specifies the number of texture names to be generated
  description: "## Name\n\nglGenTextures — generate texture names\n\n## C Specification\n\n`void `**`glGenTextures`**`(` GLsizei `n`, GLuint \\* `textures``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of texture names to be generated.\n\n *`textures`*  \nSpecifies an array in which the generated texture names are stored.\n\n## Description\n\n`glGenTextures` returns *`n`* texture names in *`textures`*. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to `glGenTextures`.\n\nThe generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see [glBindTexture](glbindtexture.xhtml)).\n\nTexture names returned by a call to `glGenTextures` are not returned by subsequent calls, unless they are first deleted with [glDeleteTextures](gldeletetextures.xhtml).\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Associated Gets\n\n[glIsTexture](glistexture.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenTextures`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindTexture](glbindtexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glDeleteTextures](gldeletetextures.xhtml), [glGet](glget.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenTextures.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenTextures.xhtml)"
- name: glGenTransformFeedbacks
  id: glgentransformfeedbacks.xhtml
  summary: n Specifies the number of transform feedback object names to reserve
  description: "## Name\n\nglGenTransformFeedbacks — reserve transform feedback object names\n\n## C Specification\n\n`void `**`glGenTransformFeedbacks`**`(` GLsizei `n`, GLuint \\*`ids``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of transform feedback object names to reserve.\n\n *`ids`*  \nSpecifies an array of into which the reserved names will be written.\n\n## Description\n\n`glGenTransformFeedbacks` returns *`n`* previously unused transform feedback object names in *`ids`*. These names are marked as used, for the purposes of `glGenTransformFeedbacks` only, but they acquire transform feedback state only when they are first bound.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_TRANSFORM_FEEDBACK_BINDING`\n\n[glIsTransformFeedback](glistransformfeedback.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenTransformFeedbacks`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDeleteTransformFeedbacks](gldeletetransformfeedbacks.xhtml), [glBindTransformFeedback](glbindtransformfeedback.xhtml), [glIsTransformFeedback](glistransformfeedback.xhtml), [glBeginTransformFeedback](glbegintransformfeedback.xhtml), [glPauseTransformFeedback](glpausetransformfeedback.xhtml), [glResumeTransformFeedback](glresumetransformfeedback.xhtml), `glEndTransformFeedback`\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenTransformFeedbacks.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenTransformFeedbacks.xhtml)"
- name: glGenVertexArrays
  id: glgenvertexarrays.xhtml
  summary: n Specifies the number of vertex array object names to generate
  description: "## Name\n\nglGenVertexArrays — generate vertex array object names\n\n## C Specification\n\n`void `**`glGenVertexArrays`**`(` GLsizei `n`, GLuint \\*`arrays``)`;\n\n## Parameters\n\n *`n`*  \nSpecifies the number of vertex array object names to generate.\n\n *`arrays`*  \nSpecifies an array in which the generated vertex array object names are stored.\n\n## Description\n\n`glGenVertexArrays` returns *`n`* vertex array object names in *`arrays`*. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to `glGenVertexArrays`.\n\nVertex array object names returned by a call to `glGenVertexArrays` are not returned by subsequent calls, unless they are first deleted with [glDeleteVertexArrays](gldeletevertexarrays.xhtml).\n\nThe names returned in *`arrays`* are marked as used, for the purposes of `glGenVertexArrays` only, but they acquire state and type only when they are first bound.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`n`* is negative.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGenVertexArrays`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindVertexArray](glbindvertexarray.xhtml), [glDeleteVertexArrays](gldeletevertexarrays.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGenVertexArrays.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGenVertexArrays.xhtml)"
- name: glGet
  id: glget.xhtml
  summary: pname Specifies the parameter value to be returned for non-indexed versions of glGet
  description: "## Name\n\nglGet — return the value or values of a selected parameter\n\n## C Specification\n\n`void `**`glGetBooleanv`**`(` GLenum `pname`, GLboolean \\* `data``)`;\n\n`void `**`glGetDoublev`**`(` GLenum `pname`, GLdouble \\* `data``)`;\n\n`void `**`glGetFloatv`**`(` GLenum `pname`, GLfloat \\* `data``)`;\n\n`void `**`glGetIntegerv`**`(` GLenum `pname`, GLint \\* `data``)`;\n\n`void `**`glGetInteger64v`**`(` GLenum `pname`, GLint64 \\* `data``)`;\n\n`void `**`glGetBooleani_v`**`(` GLenum `target`, GLuint `index`, GLboolean \\* `data``)`;\n\n`void `**`glGetIntegeri_v`**`(` GLenum `target`, GLuint `index`, GLint \\* `data``)`;\n\n`void `**`glGetFloati_v`**`(` GLenum `target`, GLuint `index`, GLfloat \\* `data``)`;\n\n`void `**`glGetDoublei_v`**`(` GLenum `target`, GLuint `index`, GLdouble \\* `data``)`;\n\n`void `**`glGetInteger64i_v`**`(` GLenum `target`, GLuint `index`, GLint64 \\* `data``)`;\n\n## Parameters\n\n *`pname`*  \nSpecifies the parameter value to be returned for non-indexed versions of `glGet`. The symbolic constants in the list below are accepted.\n\n *`target`*  \nSpecifies the parameter value to be returned for indexed versions of `glGet`. The symbolic constants in the list below are accepted.\n\n *`index`*  \nSpecifies the index of the particular element being queried.\n\n *`data`*  \nReturns the value or values of the specified parameter.\n\n## Description\n\nThese commands return values for simple state variables in GL. *`pname`* is a symbolic constant indicating the state variable to be returned, and *`data`* is a pointer to an array of the indicated type in which to place the returned data.\n\nType conversion is performed if *`data`* has a different type than the state variable value being requested. If `glGetBooleanv` is called, a floating-point (or integer) value is converted to `GL_FALSE` if and only if it is 0.0 (or 0). Otherwise, it is converted to `GL_TRUE`. If `glGetIntegerv` is called, boolean values are returned as `GL_TRUE` or `GL_FALSE`, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and −1.0 to the most negative representable integer value. If `glGetFloatv` or `glGetDoublev` is called, boolean values are returned as `GL_TRUE` or `GL_FALSE`, and integer values are converted to floating-point values.\n\nThe following symbolic constants are accepted by *`pname`*:\n\n `GL_ACTIVE_TEXTURE`  \n*`data`* returns a single value indicating the active multitexture unit. The initial value is `GL_TEXTURE0`. See [glActiveTexture](glactivetexture.xhtml).\n\n `GL_ALIASED_LINE_WIDTH_RANGE`  \n*`data`* returns a pair of values indicating the range of widths supported for aliased lines. See [glLineWidth](gllinewidth.xhtml).\n\n `GL_ARRAY_BUFFER_BINDING`  \n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_ARRAY_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n `GL_BLEND`  \n*`data`* returns a single boolean value indicating whether blending is enabled. The initial value is `GL_FALSE`. See [glBlendFunc](glblendfunc.xhtml).\n\n `GL_BLEND_COLOR`  \n*`data`* returns four values, the red, green, blue, and alpha values which are the components of the blend color. See [glBlendColor](glblendcolor.xhtml).\n\n `GL_BLEND_DST_ALPHA`  \n*`data`* returns one value, the symbolic constant identifying the alpha destination blend function. The initial value is `GL_ZERO`. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n `GL_BLEND_DST_RGB`  \n*`data`* returns one value, the symbolic constant identifying the RGB destination blend function. The initial value is `GL_ZERO`. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n `GL_BLEND_EQUATION_RGB`  \n*`data`* returns one value, a symbolic constant indicating whether the RGB blend equation is `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN` or `GL_MAX`. See [glBlendEquationSeparate](glblendequationseparate.xhtml).\n\n `GL_BLEND_EQUATION_ALPHA`  \n*`data`* returns one value, a symbolic constant indicating whether the Alpha blend equation is `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN` or `GL_MAX`. See [glBlendEquationSeparate](glblendequationseparate.xhtml).\n\n `GL_BLEND_SRC_ALPHA`  \n*`data`* returns one value, the symbolic constant identifying the alpha source blend function. The initial value is `GL_ONE`. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n `GL_BLEND_SRC_RGB`  \n*`data`* returns one value, the symbolic constant identifying the RGB source blend function. The initial value is `GL_ONE`. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n `GL_COLOR_CLEAR_VALUE`  \n*`data`* returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See [glClearColor](glclearcolor.xhtml).\n\n `GL_COLOR_LOGIC_OP`  \n*`data`* returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is `GL_FALSE`. See [glLogicOp](gllogicop.xhtml).\n\n `GL_COLOR_WRITEMASK`  \n*`data`* returns four boolean values: the red, green, blue, and alpha write enables for the color buffers. The initial value is (`GL_TRUE`, `GL_TRUE`, `GL_TRUE`, `GL_TRUE`). See [glColorMask](glcolormask.xhtml).\n\n `GL_COMPRESSED_TEXTURE_FORMATS`  \n*`data`* returns a list of symbolic constants of length `GL_NUM_COMPRESSED_TEXTURE_FORMATS` indicating which compressed texture formats are available. See [glCompressedTexImage2D](glcompressedteximage2d.xhtml).\n\n `GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS`  \n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a compute shader.\n\n `GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS`  \n*`data`* returns one value, the maximum total number of active shader storage blocks that may be accessed by all active shaders.\n\n `GL_MAX_COMPUTE_UNIFORM_BLOCKS`  \n*`data`* returns one value, the maximum number of uniform blocks per compute shader. The value must be at least 14. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n `GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS`  \n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the compute shader. The value must be at least 16. See [glActiveTexture](glactivetexture.xhtml).\n\n `GL_MAX_COMPUTE_UNIFORM_COMPONENTS`  \n*`data`* returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a compute shader. The value must be at least 1024. See [glUniform](gluniform.xhtml).\n\n `GL_MAX_COMPUTE_ATOMIC_COUNTERS`  \n*`data`* returns a single value, the maximum number of atomic counters available to compute shaders.\n\n `GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS`  \n*`data`* returns a single value, the maximum number of atomic counter buffers that may be accessed by a compute shader.\n\n `GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS`  \n*`data`* returns one value, the number of words for compute shader uniform variables in all uniform blocks (including default). The value must be at least 1. See [glUniform](gluniform.xhtml).\n\n `GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS`  \n*`data`* returns one value, the number of invocations in a single local work group (i.e., the product of the three dimensions) that may be dispatched to a compute shader.\n\n `GL_MAX_COMPUTE_WORK_GROUP_COUNT`  \nAccepted by the indexed versions of `glGet`. *`data`* the maximum number of work groups that may be dispatched to a compute shader. Indices 0, 1, and 2 correspond to the X, Y and Z dimensions, respectively.\n\n `GL_MAX_COMPUTE_WORK_GROUP_SIZE`  \nAccepted by the indexed versions of `glGet`. *`data`* the maximum size of a work groups that may be used during compilation of a compute shader. Indices 0, 1, and 2 correspond to the X, Y and Z dimensions, respectively.\n\n `GL_DISPATCH_INDIRECT_BUFFER_BINDING`  \n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_DISPATCH_INDIRECT_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n `GL_MAX_DEBUG_GROUP_STACK_DEPTH`  \n*`data`* returns a single value, the maximum depth of the debug message group stack.\n\n `GL_DEBUG_GROUP_STACK_DEPTH`  \n*`data`* returns a single value, the current depth of the debug message group stack.\n\n `GL_CONTEXT_FLAGS`  \n*`data`* returns one value, the flags with which the context was created (such as debugging functionality).\n\n `GL_CULL_FACE`  \n*`data`* returns a single boolean value indicating whether polygon culling is enabled. The initial value is `GL_FALSE`. See [glCullFace](glcullface.xhtml).\n\n `GL_CULL_FACE_MODE`  \n*`data`* returns a single value indicating the mode of polygon culling. The initial value is `GL_BACK`. See [glCullFace](glcullface.xhtml).\n\n `GL_CURRENT_PROGRAM`  \n*`data`* returns one value, the name of the program object that is currently active, or 0 if no program object is active. See [glUseProgram](gluseprogram.xhtml).\n\n `GL_DEPTH_CLEAR_VALUE`  \n*`data`* returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is 1. See [glClearDepth](glcleardepth.xhtml).\n\n `GL_DEPTH_FUNC`  \n*`data`* returns one value, the symbolic constant that indicates the depth comparison function. The initial value is `GL_LESS`. See [glDepthFunc](gldepthfunc.xhtml).\n\n `GL_DEPTH_RANGE`  \n*`data`* returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 1). See [glDepthRange](gldepthrange.xhtml).\n\n `GL_DEPTH_TEST`  \n*`data`* returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is `GL_FALSE`. See [glDepthFunc](gldepthfunc.xhtml) and [glDepthRange](gldepthrange.xhtml).\n\n `GL_DEPTH_WRITEMASK`  \n*`data`* returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is `GL_TRUE`. See [glDepthMask](gldepthmask.xhtml).\n\n `GL_DITHER`  \n*`data`* returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is `GL_TRUE`.\n\n `GL_DOUBLEBUFFER`  \n*`data`* returns a single boolean value indicating whether double buffering is supported.\n\n `GL_DRAW_BUFFER`  \n*`data`* returns one value, a symbolic constant indicating which buffers are being drawn to. See [glDrawBuffer](gldrawbuffer.xhtml). The initial value is `GL_BACK` if there are back buffers, otherwise it is `GL_FRONT`.\n\n `GL_DRAW_BUFFER`  *i*  \n*`data`* returns one value, a symbolic constant indicating which buffers are being drawn to by the corresponding output color. See [glDrawBuffers](gldrawbuffers.xhtml). The initial value of `GL_DRAW_BUFFER0` is `GL_BACK` if there are back buffers, otherwise it is `GL_FRONT`. The initial values of draw buffers for all other output colors is `GL_NONE`.\n\n `GL_DRAW_FRAMEBUFFER_BINDING`  \n*`data`* returns one value, the name of the framebuffer object currently bound to the `GL_DRAW_FRAMEBUFFER` target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See [glBindFramebuffer](glbindframebuffer.xhtml).\n\n `GL_READ_FRAMEBUFFER_BINDING`  \n*`data`* returns one value, the name of the framebuffer object currently bound to the `GL_READ_FRAMEBUFFER` target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See [glBindFramebuffer](glbindframebuffer.xhtml).\n\n `GL_ELEMENT_ARRAY_BUFFER_BINDING`  \n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_ELEMENT_ARRAY_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n `GL_FRAGMENT_SHADER_DERIVATIVE_HINT`  \n*`data`* returns one value, a symbolic constant indicating the mode of the derivative accuracy hint for fragment shaders. The initial value is `GL_DONT_CARE`. See [glHint](glhint.xhtml).\n\n `GL_IMPLEMENTATION_COLOR_READ_FORMAT`  \n*`data`* returns a single GLenum value indicating the implementation's preferred pixel data format. See [glReadPixels](glreadpixels.xhtml).\n\n `GL_IMPLEMENTATION_COLOR_READ_TYPE`  \n*`data`* returns a single GLenum value indicating the implementation's preferred pixel data type. See [glReadPixels](glreadpixels.xhtml).\n\n `GL_LINE_SMOOTH`  \n*`data`* returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is `GL_FALSE`. See [glLineWidth](gllinewidth.xhtml).\n\n `GL_LINE_SMOOTH_HINT`  \n*`data`* returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is `GL_DONT_CARE`. See [glHint](glhint.xhtml).\n\n `GL_LINE_WIDTH`  \n*`data`* returns one value, the line width as specified with [glLineWidth](gllinewidth.xhtml). The initial value is 1.\n\n `GL_LAYER_PROVOKING_VERTEX`  \n*`data`* returns one value, the implementation dependent specifc vertex of a primitive that is used to select the rendering layer. If the value returned is equivalent to `GL_PROVOKING_VERTEX`, then the vertex selection follows the convention specified by [glProvokingVertex](glprovokingvertex.xhtml). If the value returned is equivalent to `GL_FIRST_VERTEX_CONVENTION`, then the selection is always taken from the first vertex in the primitive. If the value returned is equivalent to `GL_LAST_VERTEX_CONVENTION`, then the selection is always taken from the last vertex in the primitive. If the value returned is equivalent to `GL_UNDEFINED_VERTEX`, then the selection is not guaranteed to be taken from any specific vertex in the primitive.\n\n `GL_LOGIC_OP_MODE`  \n*`data`* returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is `GL_COPY`. See [glLogicOp](gllogicop.xhtml).\n\n `GL_MAJOR_VERSION`  \n*`data`* returns one value, the major version number of the OpenGL API supported by the current context.\n\n `GL_MAX_3D_TEXTURE_SIZE`  \n*`data`* returns one value, a rough estimate of the largest 3D texture that the GL can handle. The value must be at least 64. Use `GL_PROXY_TEXTURE_3D` to determine if a texture is too large. See [glTexImage3D](glteximage3d.xhtml).\n\n `GL_MAX_ARRAY_TEXTURE_LAYERS`  \n*`data`* returns one value. The value indicates the maximum number of layers allowed in an array texture, and must be at least 256. See [glTexImage2D](glteximage2d.xhtml).\n\n `GL_MAX_CLIP_DISTANCES`  \n*`data`* returns one value, the maximum number of application-defined clipping distances. The value must be at least 8.\n\n `GL_MAX_COLOR_TEXTURE_SAMPLES`  \n*`data`* returns one value, the maximum number of samples in a color multisample texture.\n\n `GL_MAX_COMBINED_ATOMIC_COUNTERS`  \n*`data`* returns a single value, the maximum number of atomic counters available to all active shaders.\n\n `GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS`  \n*`data`* returns one value, the number of words for fragment shader uniform variables in all uniform blocks (including default). The value must be at least 1. See [glUniform](gluniform.xhtml).\n\n `GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS`  \n*`data`* returns one value, the number of words for geometry shader uniform variables in all uniform blocks (including default). The value must be at least 1. See [glUniform](gluniform.xhtml).\n\n `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`  \n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader and the fragment processor combined. If both the vertex shader and the fragment processing stage access the same texture image unit, then that counts as using two texture image units against this limit. The value must be at least 48. See [glActiveTexture](glactivetexture.xhtml).\n\n `GL_MAX_COMBINED_UNIFORM_BLOCKS`  \n*`data`* returns one value, the maximum number of uniform blocks per program. The value must be at least 70. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n `GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS`  \n*`data`* returns one value, the number of words for vertex shader uniform variables in all uniform blocks (including default). The value must be at least 1. See [glUniform](gluniform.xhtml).\n\n `GL_MAX_CUBE_MAP_TEXTURE_SIZE`  \n*`data`* returns one value. The value gives a rough estimate of the largest cube-map texture that the GL can handle. The value must be at least 1024. Use `GL_PROXY_TEXTURE_CUBE_MAP` to determine if a texture is too large. See [glTexImage2D](glteximage2d.xhtml).\n\n `GL_MAX_DEPTH_TEXTURE_SAMPLES`  \n*`data`* returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.\n\n `GL_MAX_DRAW_BUFFERS`  \n*`data`* returns one value, the maximum number of simultaneous outputs that may be written in a fragment shader. The value must be at least 8. See [glDrawBuffers](gldrawbuffers.xhtml).\n\n `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`  \n*`data`* returns one value, the maximum number of active draw buffers when using dual-source blending. The value must be at least 1. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n `GL_MAX_ELEMENTS_INDICES`  \n*`data`* returns one value, the recommended maximum number of vertex array indices. See [glDrawRangeElements](gldrawrangeelements.xhtml).\n\n `GL_MAX_ELEMENTS_VERTICES`  \n*`data`* returns one value, the recommended maximum number of vertex array vertices. See [glDrawRangeElements](gldrawrangeelements.xhtml).\n\n `GL_MAX_FRAGMENT_ATOMIC_COUNTERS`  \n*`data`* returns a single value, the maximum number of atomic counters available to fragment shaders.\n\n `GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS`  \n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a fragment shader.\n\n `GL_MAX_FRAGMENT_INPUT_COMPONENTS`  \n*`data`* returns one value, the maximum number of components of the inputs read by the fragment shader, which must be at least 128.\n\n `GL_MAX_FRAGMENT_UNIFORM_COMPONENTS`  \n*`data`* returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value must be at least 1024. See [glUniform](gluniform.xhtml).\n\n `GL_MAX_FRAGMENT_UNIFORM_VECTORS`  \n*`data`* returns one value, the maximum number of individual 4-vectors of floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value is equal to the value of `GL_MAX_FRAGMENT_UNIFORM_COMPONENTS` divided by 4 and must be at least 256. See [glUniform](gluniform.xhtml).\n\n `GL_MAX_FRAGMENT_UNIFORM_BLOCKS`  \n*`data`* returns one value, the maximum number of uniform blocks per fragment shader. The value must be at least 12. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n `GL_MAX_FRAMEBUFFER_WIDTH`  \n*`data`* returns one value, the maximum width for a framebuffer that has no attachments, which must be at least 16384. See `glFramebufferParameter`.\n\n `GL_MAX_FRAMEBUFFER_HEIGHT`  \n*`data`* returns one value, the maximum height for a framebuffer that has no attachments, which must be at least 16384. See `glFramebufferParameter`.\n\n `GL_MAX_FRAMEBUFFER_LAYERS`  \n*`data`* returns one value, the maximum number of layers for a framebuffer that has no attachments, which must be at least 2048. See `glFramebufferParameter`.\n\n `GL_MAX_FRAMEBUFFER_SAMPLES`  \n*`data`* returns one value, the maximum samples in a framebuffer that has no attachments, which must be at least 4. See `glFramebufferParameter`.\n\n `GL_MAX_GEOMETRY_ATOMIC_COUNTERS`  \n*`data`* returns a single value, the maximum number of atomic counters available to geometry shaders.\n\n `GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS`  \n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a geometry shader.\n\n `GL_MAX_GEOMETRY_INPUT_COMPONENTS`  \n*`data`* returns one value, the maximum number of components of inputs read by a geometry shader, which must be at least 64.\n\n `GL_MAX_GEOMETRY_OUTPUT_COMPONENTS`  \n*`data`* returns one value, the maximum number of components of outputs written by a geometry shader, which must be at least 128.\n\n `GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS`  \n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the geometry shader. The value must be at least 16. See [glActiveTexture](glactivetexture.xhtml).\n\n `GL_MAX_GEOMETRY_UNIFORM_BLOCKS`  \n*`data`* returns one value, the maximum number of uniform blocks per geometry shader. The value must be at least 12. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n `GL_MAX_GEOMETRY_UNIFORM_COMPONENTS`  \n*`data`* returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a geometry shader. The value must be at least 1024. See [glUniform](gluniform.xhtml).\n\n `GL_MAX_INTEGER_SAMPLES`  \n*`data`* returns one value, the maximum number of samples supported in integer format multisample buffers.\n\n `GL_MIN_MAP_BUFFER_ALIGNMENT`  \n*`data`* returns one value, the minimum alignment in basic machine units of pointers returned from[glMapBuffer](glmapbuffer.xhtml) and [glMapBufferRange](glmapbufferrange.xhtml). This value must be a power of two and must be at least 64.\n\n `GL_MAX_LABEL_LENGTH`  \n*`data`* returns one value, the maximum length of a label that may be assigned to an object. See [glObjectLabel](globjectlabel.xhtml) and [glObjectPtrLabel](globjectptrlabel.xhtml).\n\n `GL_MAX_PROGRAM_TEXEL_OFFSET`  \n*`data`* returns one value, the maximum texel offset allowed in a texture lookup, which must be at least 7.\n\n `GL_MIN_PROGRAM_TEXEL_OFFSET`  \n*`data`* returns one value, the minimum texel offset allowed in a texture lookup, which must be at most -8.\n\n `GL_MAX_RECTANGLE_TEXTURE_SIZE`  \n*`data`* returns one value. The value gives a rough estimate of the largest rectangular texture that the GL can handle. The value must be at least 1024. Use `GL_PROXY_TEXTURE_RECTANGLE` to determine if a texture is too large. See [glTexImage2D](glteximage2d.xhtml).\n\n `GL_MAX_RENDERBUFFER_SIZE`  \n*`data`* returns one value. The value indicates the maximum supported size for renderbuffers. See [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml).\n\n `GL_MAX_SAMPLE_MASK_WORDS`  \n*`data`* returns one value, the maximum number of sample mask words.\n\n `GL_MAX_SERVER_WAIT_TIMEOUT`  \n*`data`* returns one value, the maximum [glWaitSync](glwaitsync.xhtml) timeout interval.\n\n `GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`  \n*`data`* returns one value, the maximum number of shader storage buffer binding points on the context, which must be at least 8.\n\n `GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS`  \n*`data`* returns a single value, the maximum number of atomic counters available to tessellation control shaders.\n\n `GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS`  \n*`data`* returns a single value, the maximum number of atomic counters available to tessellation evaluation shaders.\n\n `GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS`  \n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a tessellation control shader.\n\n `GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS`  \n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a tessellation evaluation shader.\n\n `GL_MAX_TEXTURE_BUFFER_SIZE`  \n*`data`* returns one value. The value gives the maximum number of texels allowed in the texel array of a texture buffer object. Value must be at least 65536.\n\n `GL_MAX_TEXTURE_IMAGE_UNITS`  \n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the fragment shader. The value must be at least 16. See [glActiveTexture](glactivetexture.xhtml).\n\n `GL_MAX_TEXTURE_LOD_BIAS`  \n*`data`* returns one value, the maximum, absolute value of the texture level-of-detail bias. The value must be at least 2.0.\n\n `GL_MAX_TEXTURE_SIZE`  \n*`data`* returns one value. The value gives a rough estimate of the largest texture that the GL can handle. The value must be at least 1024. Use a proxy texture target such as `GL_PROXY_TEXTURE_1D` or `GL_PROXY_TEXTURE_2D` to determine if a texture is too large. See [glTexImage1D](glteximage1d.xhtml) and [glTexImage2D](glteximage2d.xhtml).\n\n `GL_MAX_UNIFORM_BUFFER_BINDINGS`  \n*`data`* returns one value, the maximum number of uniform buffer binding points on the context, which must be at least 36.\n\n `GL_MAX_UNIFORM_BLOCK_SIZE`  \n*`data`* returns one value, the maximum size in basic machine units of a uniform block, which must be at least 16384.\n\n `GL_MAX_UNIFORM_LOCATIONS`  \n*`data`* returns one value, the maximum number of explicitly assignable uniform locations, which must be at least 1024.\n\n `GL_MAX_VARYING_COMPONENTS`  \n*`data`* returns one value, the number components for varying variables, which must be at least 60.\n\n `GL_MAX_VARYING_VECTORS`  \n*`data`* returns one value, the number 4-vectors for varying variables, which is equal to the value of `GL_MAX_VARYING_COMPONENTS` and must be at least 15.\n\n `GL_MAX_VARYING_FLOATS`  \n*`data`* returns one value, the maximum number of interpolators available for processing varying variables used by vertex and fragment shaders. This value represents the number of individual floating-point values that can be interpolated; varying variables declared as vectors, matrices, and arrays will all consume multiple interpolators. The value must be at least 32.\n\n `GL_MAX_VERTEX_ATOMIC_COUNTERS`  \n*`data`* returns a single value, the maximum number of atomic counters available to vertex shaders.\n\n `GL_MAX_VERTEX_ATTRIBS`  \n*`data`* returns one value, the maximum number of 4-component generic vertex attributes accessible to a vertex shader. The value must be at least 16. See [glVertexAttrib](glvertexattrib.xhtml).\n\n `GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS`  \n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a vertex shader.\n\n `GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS`  \n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader. The value may be at least 16. See [glActiveTexture](glactivetexture.xhtml).\n\n `GL_MAX_VERTEX_UNIFORM_COMPONENTS`  \n*`data`* returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a vertex shader. The value must be at least 1024. See [glUniform](gluniform.xhtml).\n\n `GL_MAX_VERTEX_UNIFORM_VECTORS`  \n*`data`* returns one value, the maximum number of 4-vectors that may be held in uniform variable storage for the vertex shader. The value of `GL_MAX_VERTEX_UNIFORM_VECTORS` is equal to the value of `GL_MAX_VERTEX_UNIFORM_COMPONENTS` and must be at least 256.\n\n `GL_MAX_VERTEX_OUTPUT_COMPONENTS`  \n*`data`* returns one value, the maximum number of components of output written by a vertex shader, which must be at least 64.\n\n `GL_MAX_VERTEX_UNIFORM_BLOCKS`  \n*`data`* returns one value, the maximum number of uniform blocks per vertex shader. The value must be at least 12. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n `GL_MAX_VIEWPORT_DIMS`  \n*`data`* returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See [glViewport](glviewport.xhtml).\n\n `GL_MAX_VIEWPORTS`  \n*`data`* returns one value, the maximum number of simultaneous viewports that are supported. The value must be at least 16. See [glViewportIndexed](glviewportindexed.xhtml).\n\n `GL_MINOR_VERSION`  \n*`data`* returns one value, the minor version number of the OpenGL API supported by the current context.\n\n `GL_NUM_COMPRESSED_TEXTURE_FORMATS`  \n*`data`* returns a single integer value indicating the number of available compressed texture formats. The minimum value is 4. See [glCompressedTexImage2D](glcompressedteximage2d.xhtml).\n\n `GL_NUM_EXTENSIONS`  \n*`data`* returns one value, the number of extensions supported by the GL implementation for the current context. See [glGetString](glgetstring.xhtml).\n\n `GL_NUM_PROGRAM_BINARY_FORMATS`  \n*`data`* returns one value, the number of program binary formats supported by the implementation.\n\n `GL_NUM_SHADER_BINARY_FORMATS`  \n*`data`* returns one value, the number of binary shader formats supported by the implementation. If this value is greater than zero, then the implementation supports loading binary shaders. If it is zero, then the loading of binary shaders by the implementation is not supported.\n\n `GL_PACK_ALIGNMENT`  \n*`data`* returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_PACK_IMAGE_HEIGHT`  \n*`data`* returns one value, the image height used for writing pixel data to memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_PACK_LSB_FIRST`  \n*`data`* returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is `GL_FALSE`. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_PACK_ROW_LENGTH`  \n*`data`* returns one value, the row length used for writing pixel data to memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_PACK_SKIP_IMAGES`  \n*`data`* returns one value, the number of pixel images skipped before the first pixel is written into memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_PACK_SKIP_PIXELS`  \n*`data`* returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_PACK_SKIP_ROWS`  \n*`data`* returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_PACK_SWAP_BYTES`  \n*`data`* returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is `GL_FALSE`. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_PIXEL_PACK_BUFFER_BINDING`  \n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_PIXEL_PACK_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n `GL_PIXEL_UNPACK_BUFFER_BINDING`  \n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_PIXEL_UNPACK_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n `GL_POINT_FADE_THRESHOLD_SIZE`  \n*`data`* returns one value, the point size threshold for determining the point size. See [glPointParameter](glpointparameter.xhtml).\n\n `GL_PRIMITIVE_RESTART_INDEX`  \n*`data`* returns one value, the current primitive restart index. The initial value is 0. See [glPrimitiveRestartIndex](glprimitiverestartindex.xhtml).\n\n `GL_PROGRAM_BINARY_FORMATS`  \n*`data`* an array of `GL_NUM_PROGRAM_BINARY_FORMATS` values, indicating the proram binary formats supported by the implementation.\n\n `GL_PROGRAM_PIPELINE_BINDING`  \n*`data`* a single value, the name of the currently bound program pipeline object, or zero if no program pipeline object is bound. See [glBindProgramPipeline](glbindprogrampipeline.xhtml).\n\n `GL_PROGRAM_POINT_SIZE`  \n*`data`* returns a single boolean value indicating whether vertex program point size mode is enabled. If enabled, then the point size is taken from the shader built-in `gl_PointSize`. If disabled, then the point size is taken from the point state as specified by [glPointSize](glpointsize.xhtml). The initial value is `GL_FALSE`.\n\n `GL_PROVOKING_VERTEX`  \n*`data`* returns one value, the currently selected provoking vertex convention. The initial value is `GL_LAST_VERTEX_CONVENTION`. See [glProvokingVertex](glprovokingvertex.xhtml).\n\n `GL_POINT_SIZE`  \n*`data`* returns one value, the point size as specified by [glPointSize](glpointsize.xhtml). The initial value is 1.\n\n `GL_POINT_SIZE_GRANULARITY`  \n*`data`* returns one value, the size difference between adjacent supported sizes for antialiased points. See [glPointSize](glpointsize.xhtml).\n\n `GL_POINT_SIZE_RANGE`  \n*`data`* returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See [glPointSize](glpointsize.xhtml).\n\n `GL_POLYGON_OFFSET_FACTOR`  \n*`data`* returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n `GL_POLYGON_OFFSET_UNITS`  \n*`data`* returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n `GL_POLYGON_OFFSET_FILL`  \n*`data`* returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is `GL_FALSE`. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n `GL_POLYGON_OFFSET_LINE`  \n*`data`* returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is `GL_FALSE`. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n `GL_POLYGON_OFFSET_POINT`  \n*`data`* returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is `GL_FALSE`. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n `GL_POLYGON_SMOOTH`  \n*`data`* returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is `GL_FALSE`. See [glPolygonMode](glpolygonmode.xhtml).\n\n `GL_POLYGON_SMOOTH_HINT`  \n*`data`* returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is `GL_DONT_CARE`. See [glHint](glhint.xhtml).\n\n `GL_READ_BUFFER`  \n*`data`* returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is `GL_BACK` if there is a back buffer, otherwise it is `GL_FRONT`. See [glReadPixels](glreadpixels.xhtml).\n\n `GL_RENDERBUFFER_BINDING`  \n*`data`* returns a single value, the name of the renderbuffer object currently bound to the target `GL_RENDERBUFFER`. If no renderbuffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindRenderbuffer](glbindrenderbuffer.xhtml).\n\n `GL_SAMPLE_BUFFERS`  \n*`data`* returns a single integer value indicating the number of sample buffers associated with the framebuffer. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n `GL_SAMPLE_COVERAGE_VALUE`  \n*`data`* returns a single positive floating-point value indicating the current sample coverage value. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n `GL_SAMPLE_COVERAGE_INVERT`  \n*`data`* returns a single boolean value indicating if the temporary coverage value should be inverted. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n `GL_SAMPLE_MASK_VALUE`  \n*`params`* returns one value indicating the current sample mask value. See [glSampleMaski](glsamplemaski.xhtml).\n\n `GL_SAMPLER_BINDING`  \n*`data`* returns a single value, the name of the sampler object currently bound to the active texture unit. The initial value is 0. See [glBindSampler](glbindsampler.xhtml).\n\n `GL_SAMPLES`  \n*`data`* returns a single integer value indicating the coverage mask size. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n `GL_SCISSOR_BOX`  \n*`data`* returns four values: the *x* and *y* window coordinates of the scissor box, followed by its width and height. Initially the *x* and *y* window coordinates are both 0 and the width and height are set to the size of the window. See [glScissor](glscissor.xhtml).\n\n `GL_SCISSOR_TEST`  \n*`data`* returns a single boolean value indicating whether scissoring is enabled. The initial value is `GL_FALSE`. See [glScissor](glscissor.xhtml).\n\n `GL_SHADER_COMPILER`  \n*`data`* returns a single boolean value indicating whether an online shader compiler is present in the implementation. All desktop OpenGL implementations must support online shader compilations, and therefore the value of `GL_SHADER_COMPILER` will always be `GL_TRUE`.\n\n `GL_SHADER_STORAGE_BUFFER_BINDING`  \nWhen used with non-indexed variants of `glGet` (such as `glGetIntegerv`), *`data`* returns a single value, the name of the buffer object currently bound to the target `GL_SHADER_STORAGE_BUFFER`. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), *`data`* returns a single value, the name of the buffer object bound to the indexed shader storage buffer binding points. The initial value is 0 for all targets. See [glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), and [glBindBufferRange](glbindbufferrange.xhtml).\n\n `GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT`  \n*`data`* returns a single value, the minimum required alignment for shader storage buffer sizes and offset. The initial value is 1. See [glShaderStorageBlockBinding](glshaderstorageblockbinding.xhtml).\n\n `GL_SHADER_STORAGE_BUFFER_START`  \nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the start offset of the binding range for each indexed shader storage buffer binding. The initial value is 0 for all bindings. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n `GL_SHADER_STORAGE_BUFFER_SIZE`  \nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the size of the binding range for each indexed shader storage buffer binding. The initial value is 0 for all bindings. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n `GL_SMOOTH_LINE_WIDTH_RANGE`  \n*`data`* returns a pair of values indicating the range of widths supported for smooth (antialiased) lines. See [glLineWidth](gllinewidth.xhtml).\n\n `GL_SMOOTH_LINE_WIDTH_GRANULARITY`  \n*`data`* returns a single value indicating the level of quantization applied to smooth line width parameters.\n\n `GL_STENCIL_BACK_FAIL`  \n*`data`* returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test fails. The initial value is `GL_KEEP`. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n `GL_STENCIL_BACK_FUNC`  \n*`data`* returns one value, a symbolic constant indicating what function is used for back-facing polygons to compare the stencil reference value with the stencil buffer value. The initial value is `GL_ALWAYS`. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n `GL_STENCIL_BACK_PASS_DEPTH_FAIL`  \n*`data`* returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes, but the depth test fails. The initial value is `GL_KEEP`. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n `GL_STENCIL_BACK_PASS_DEPTH_PASS`  \n*`data`* returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes and the depth test passes. The initial value is `GL_KEEP`. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n `GL_STENCIL_BACK_REF`  \n*`data`* returns one value, the reference value that is compared with the contents of the stencil buffer for back-facing polygons. The initial value is 0. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n `GL_STENCIL_BACK_VALUE_MASK`  \n*`data`* returns one value, the mask that is used for back-facing polygons to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n `GL_STENCIL_BACK_WRITEMASK`  \n*`data`* returns one value, the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value is all 1's. See [glStencilMaskSeparate](glstencilmaskseparate.xhtml).\n\n `GL_STENCIL_CLEAR_VALUE`  \n*`data`* returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See [glClearStencil](glclearstencil.xhtml).\n\n `GL_STENCIL_FAIL`  \n*`data`* returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is `GL_KEEP`. See [glStencilOp](glstencilop.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n `GL_STENCIL_FUNC`  \n*`data`* returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is `GL_ALWAYS`. See [glStencilFunc](glstencilfunc.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n `GL_STENCIL_PASS_DEPTH_FAIL`  \n*`data`* returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is `GL_KEEP`. See [glStencilOp](glstencilop.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n `GL_STENCIL_PASS_DEPTH_PASS`  \n*`data`* returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is `GL_KEEP`. See [glStencilOp](glstencilop.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n `GL_STENCIL_REF`  \n*`data`* returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See [glStencilFunc](glstencilfunc.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n `GL_STENCIL_TEST`  \n*`data`* returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is `GL_FALSE`. See [glStencilFunc](glstencilfunc.xhtml) and [glStencilOp](glstencilop.xhtml).\n\n `GL_STENCIL_VALUE_MASK`  \n*`data`* returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See [glStencilFunc](glstencilfunc.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n `GL_STENCIL_WRITEMASK`  \n*`data`* returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See [glStencilMask](glstencilmask.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilMaskSeparate](glstencilmaskseparate.xhtml).\n\n `GL_STEREO`  \n*`data`* returns a single boolean value indicating whether stereo buffers (left and right) are supported.\n\n `GL_SUBPIXEL_BITS`  \n*`data`* returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The value must be at least 4.\n\n `GL_TEXTURE_BINDING_1D`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_1D`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_BINDING_1D_ARRAY`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_1D_ARRAY`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_BINDING_2D`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_2D`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_BINDING_2D_ARRAY`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_2D_ARRAY`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_BINDING_2D_MULTISAMPLE`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_2D_MULTISAMPLE`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_BINDING_3D`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_3D`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_BINDING_BUFFER`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_BUFFER`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_BINDING_CUBE_MAP`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_CUBE_MAP`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_BINDING_RECTANGLE`  \n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_RECTANGLE`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n `GL_TEXTURE_COMPRESSION_HINT`  \n*`data`* returns a single value indicating the mode of the texture compression hint. The initial value is `GL_DONT_CARE`.\n\n `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`  \n*`data`* returns a single value, the minimum required alignment for texture buffer sizes and offset. The initial value is 1. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n `GL_TIMESTAMP`  \n*`data`* returns a single value, the 64-bit value of the current GL time. See [glQueryCounter](glquerycounter.xhtml).\n\n `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`  \nWhen used with non-indexed variants of `glGet` (such as `glGetIntegerv`), *`data`* returns a single value, the name of the buffer object currently bound to the target `GL_TRANSFORM_FEEDBACK_BUFFER`. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), *`data`* returns a single value, the name of the buffer object bound to the indexed transform feedback attribute stream. The initial value is 0 for all targets. See [glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), and [glBindBufferRange](glbindbufferrange.xhtml).\n\n `GL_TRANSFORM_FEEDBACK_BUFFER_START`  \nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the start offset of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n `GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`  \nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the size of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n `GL_UNIFORM_BUFFER_BINDING`  \nWhen used with non-indexed variants of `glGet` (such as `glGetIntegerv`), *`data`* returns a single value, the name of the buffer object currently bound to the target `GL_UNIFORM_BUFFER`. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), *`data`* returns a single value, the name of the buffer object bound to the indexed uniform buffer binding point. The initial value is 0 for all targets. See [glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), and [glBindBufferRange](glbindbufferrange.xhtml).\n\n `GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT`  \n*`data`* returns a single value, the minimum required alignment for uniform buffer sizes and offset. The initial value is 1. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n `GL_UNIFORM_BUFFER_SIZE`  \nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the size of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n `GL_UNIFORM_BUFFER_START`  \nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the start offset of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n `GL_UNPACK_ALIGNMENT`  \n*`data`* returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_UNPACK_IMAGE_HEIGHT`  \n*`data`* returns one value, the image height used for reading pixel data from memory. The initial is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_UNPACK_LSB_FIRST`  \n*`data`* returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is `GL_FALSE`. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_UNPACK_ROW_LENGTH`  \n*`data`* returns one value, the row length used for reading pixel data from memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_UNPACK_SKIP_IMAGES`  \n*`data`* returns one value, the number of pixel images skipped before the first pixel is read from memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_UNPACK_SKIP_PIXELS`  \n*`data`* returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_UNPACK_SKIP_ROWS`  \n*`data`* returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_UNPACK_SWAP_BYTES`  \n*`data`* returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is `GL_FALSE`. See [glPixelStore](glpixelstore.xhtml).\n\n `GL_VERTEX_ARRAY_BINDING`  \n*`data`* returns a single value, the name of the vertex array object currently bound to the context. If no vertex array object is bound to the context, 0 is returned. The initial value is 0. See [glBindVertexArray](glbindvertexarray.xhtml).\n\n `GL_VERTEX_BINDING_DIVISOR`  \nAccepted by the indexed forms. *`data`* returns a single integer value representing the instance step divisor of the first element in the bound buffer's data store for vertex attribute bound to *`index`*.\n\n `GL_VERTEX_BINDING_OFFSET`  \nAccepted by the indexed forms. *`data`* returns a single integer value representing the byte offset of the first element in the bound buffer's data store for vertex attribute bound to *`index`*.\n\n `GL_VERTEX_BINDING_STRIDE`  \nAccepted by the indexed forms. *`data`* returns a single integer value representing the byte offset between the start of each element in the bound buffer's data store for vertex attribute bound to *`index`*.\n\n `GL_VERTEX_BINDING_BUFFER`  \nAccepted by the indexed forms. *`data`* returns a single integer value representing the name of the buffer bound to vertex binding *`index`*.\n\n `GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET`  \n*`data`* returns a single integer value containing the maximum offset that may be added to a vertex binding offset.\n\n `GL_MAX_VERTEX_ATTRIB_BINDINGS`  \n*`data`* returns a single integer value containing the maximum number of vertex buffers that may be bound.\n\n `GL_VIEWPORT`  \nWhen used with non-indexed variants of `glGet` (such as `glGetIntegerv`), *`data`* returns four values: the *x* and *y* window coordinates of the viewport, followed by its width and height. Initially the *x* and *y* window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See [glViewport](glviewport.xhtml).\n\nWhen used with indexed variants of `glGet` (such as `glGetIntegeri_v`), *`data`* returns four values: the *x* and *y* window coordinates of the indexed viewport, followed by its width and height. Initially the *x* and *y* window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See `glViewportIndexedf`.\n\n `GL_VIEWPORT_BOUNDS_RANGE`  \n*`data`* returns two values, the minimum and maximum viewport bounds range. The minimum range should be at least \\[-32768, 32767\\].\n\n `GL_VIEWPORT_INDEX_PROVOKING_VERTEX`  \n*`data`* returns one value, the implementation dependent specifc vertex of a primitive that is used to select the viewport index. If the value returned is equivalent to `GL_PROVOKING_VERTEX`, then the vertex selection follows the convention specified by [glProvokingVertex](glprovokingvertex.xhtml). If the value returned is equivalent to `GL_FIRST_VERTEX_CONVENTION`, then the selection is always taken from the first vertex in the primitive. If the value returned is equivalent to `GL_LAST_VERTEX_CONVENTION`, then the selection is always taken from the last vertex in the primitive. If the value returned is equivalent to `GL_UNDEFINED_VERTEX`, then the selection is not guaranteed to be taken from any specific vertex in the primitive.\n\n `GL_VIEWPORT_SUBPIXEL_BITS`  \n*`data`* returns a single value, the number of bits of sub-pixel precision which the GL uses to interpret the floating point viewport bounds. The minimum value is 0.\n\n `GL_MAX_ELEMENT_INDEX`  \n*`data`* returns a single value, the maximum index that may be specified during the transfer of generic vertex attributes to the GL.\n\nMany of the boolean parameters can also be queried more easily using [glIsEnabled](glisenabled.xhtml).\n\n## Notes\n\nThe following parameters return the associated value for the active texture unit: `GL_TEXTURE_1D`, `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_BINDING_2D`, `GL_TEXTURE_3D` and `GL_TEXTURE_BINDING_3D`.\n\n`GL_MAX_VIEWPORTS`, `GL_VIEWPORT_SUBPIXEL_BITS`, `GL_VIEWPORT_BOUNDS_RANGE`, `GL_LAYER_PROVOKING_VERTEX`, and `GL_VIEWPORT_INDEX_PROVOKING_VERTEX` are available only if the GL version is 4.1 or greater.\n\n`GL_MAX_VERTEX_ATOMIC_COUNTERS`, `GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS`, `GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS`, `GL_MAX_GEOMETRY_ATOMIC_COUNTERS`, `GL_MAX_FRAMGENT_ATOMIC_COUNTERS`, and `GL_MIN_MAP_BUFFER_ALIGNMENT` are accepted by *`pname`* only if the GL version is 4.2 or greater.\n\n`GL_MAX_ELEMENT_INDEX` is accepted by *`pname`* only if the GL version is 4.3 or greater.\n\n`GL_MAX_COMPUTE_UNIFORM_BLOCKS`, `GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS`, `GL_MAX_COMPUTE_UNIFORM_COMPONENTS`, `GL_MAX_COMPUTE_ATOMIC_COUNTERS`, `GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS`, `GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS`, `GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS`, `GL_MAX_COMPUTE_WORK_GROUP_COUNT`, and `GL_MAX_COMPUTE_WORK_GROUP_SIZE` and `GL_DISPATCH_INDIRECT_BUFFER_BINDING` are available only if the GL version is 4.3 or greater.\n\n`GL_MAX_DEBUG_GROUP_STACK_DEPTH`, `GL_DEBUG_GROUP_STACK_DEPTH` and `GL_MAX_LABEL_LENGTH` are accepted only if the GL version is 4.3 or greater.\n\n`GL_MAX_UNIFORM_LOCATIONS` is accepted only if the GL version is 4.3 or greater.\n\n`GL_MAX_FRAMEBUFFER_WIDTH`, `GL_MAX_FRAMEBUFFER_HEIGHT`, `GL_MAX_FRAMEBUFFER_LAYERS`, and `GL_MAX_FRAMEBUFFER_SAMPLES` are available only if the GL version is 4.3 or greater.\n\n`GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS`, `GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS`, `GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS`, `GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS`, `GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS`, and `GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS` are available only if the GL version is 4.3 or higher.\n\n`GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT` is available only if the GL version is 4.3 or greater.\n\n`GL_VERTEX_BINDING_DIVISOR`, `GL_VERTEX_BINDING_OFFSET`, `GL_VERTEX_BINDING_STRIDE`, `GL_VERTEX_BINDING_BUFFER`, `GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET` and `GL_MAX_VERTEX_ATTRIB_BINDINGS` are available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated on any of `glGetBooleani_v`, `glGetIntegeri_v`, or `glGetInteger64i_v` if *`index`* is outside of the valid range for the indexed state *`target`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetBooleani_v`           |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetBooleanv`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetDoublei_v`            |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetDoublev`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetFloati_v`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetFloatv`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetInteger64i_v`         |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetInteger64v`           |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetIntegeri_v`           |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetIntegerv`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetActiveUniform](glgetactiveuniform.xhtml), [glGetAttachedShaders](glgetattachedshaders.xhtml), [glGetAttribLocation](glgetattriblocation.xhtml), [glGetBufferParameter](glgetbufferparameter.xhtml), [glGetBufferPointerv](glgetbufferpointerv.xhtml), [glGetBufferSubData](glgetbuffersubdata.xhtml), [glGetCompressedTexImage](glgetcompressedteximage.xhtml), [glGetError](glgeterror.xhtml), [glGetProgram](glgetprogram.xhtml), [glGetProgramInfoLog](glgetprograminfolog.xhtml), [glGetQueryiv](glgetqueryiv.xhtml), [glGetQueryObject](glgetqueryobject.xhtml), [glGetShader](glgetshader.xhtml), [glGetShaderInfoLog](glgetshaderinfolog.xhtml), [glGetShaderSource](glgetshadersource.xhtml), [glGetString](glgetstring.xhtml), [glGetTexImage](glgetteximage.xhtml), [glGetTexLevelParameter](glgettexlevelparameter.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glGetUniform](glgetuniform.xhtml), [glGetUniformLocation](glgetuniformlocation.xhtml), [glGetVertexAttrib](glgetvertexattrib.xhtml), [glGetVertexAttribPointerv](glgetvertexattribpointerv.xhtml), [glIsEnabled](glisenabled.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGet.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGet.xhtml)"
- name: glGetActiveAtomicCounterBufferiv
  id: glgetactiveatomiccounterbufferiv.xhtml
  summary: program The name of a program object from which to retrieve information
  description: "## Name\n\nglGetActiveAtomicCounterBufferiv — retrieve information about the set of active atomic counter buffers for a program\n\n## C Specification\n\n`void `**`glGetActiveAtomicCounterBufferiv`**`(` GLuint `program`, GLuint `bufferIndex`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n *`program`*  \nThe name of a program object from which to retrieve information.\n\n *`bufferIndex`*  \nSpecifies index of an active atomic counter buffer.\n\n *`pname`*  \nSpecifies which parameter of the atomic counter buffer to retrieve.\n\n *`params`*  \nSpecifies the address of a variable into which to write the retrieved information.\n\n## Description\n\n`glGetActiveAtomicCounterBufferiv` retrieves information about the set of active atomic counter buffers for a program object. *`program`* is the name of a program object for which the command [glLinkProgram](gllinkprogram.xhtml) has been issued in the past. It is not necessary for *`program`* to have been linked successfully. The link may have failed because the number of active atomic counters exceeded the limits.\n\n*`bufferIndex`* specifies the index of an active atomic counter buffer and must be in the range zero to the value of `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` minus one. The value of `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` for *`program`* indicates the number of active atomic counter buffer and can be queried with [glGetProgram](glgetprogram.xhtml).\n\nIf no error occurs, the parameter(s) specified by *`pname`* are returned in *`params`*. If an error is generated, the contents of *`params`* are not modified.\n\nIf *`pname`* is `GL_ATOMIC_COUNTER_BUFFER_BINDING`, then the index of the counter buffer binding point associated with the active atomic counter buffer *`bufferIndex`* for *`program`* is returned.\n\nIf *`pname`* is `GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE`, then the implementation-dependent minimum total buffer object size, in baseic machine units, required to hold all active atomic counters in the atomic counter binding point identified by *`bufferIndex`* is returned.\n\nIf *`pname`* is `GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS`, then the number of active atomic counters for the atomic counter buffer identified by *`bufferIndex`* is returned.\n\nIf *`pname`* is `GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES`, then a list of the active atomic counter indices for the atomic counter buffer identified by *`bufferIndex`* is returned. The number of elements that will be written into *`params`* is the value of `GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS` for *`bufferIndex`*.\n\nIf *`pname`* is `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER`, `GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER` then a boolean value indicating whether the atomic counter buffer identified by *`bufferIndex`* is referenced by the vertex, tessellation control, tessellation evaluation, geometry, fragment or compute processing stages of *`program`*, respectively, is returned.\n\n## Notes\n\n`glGetActiveAtomicCounterBufferiv` is available only if the GL version is 4.2 or higher.\n\n`GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER` is available only of the GL version is 4.3 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of a program object for which [glLinkProgram](gllinkprogram.xhtml) has been called in the past.\n\n`GL_INVALID_VALUE` is generated if *`bufferIndex`* is greater than or equal to the value of `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS` for *`program`*.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted tokens.\n\n## Version Support\n\n|                                    | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**        |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveAtomicCounterBufferiv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetActiveSubroutineUniform](glgetactivesubroutineuniform.xhtml), [glGetActiveSubroutineUniformName](glgetactivesubroutineuniformname.xhtml), [glGetUniformLocation](glgetuniformlocation.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveAtomicCounterBufferiv.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveAtomicCounterBufferiv.xhtml)"
- name: glGetActiveAttrib
  id: glgetactiveattrib.xhtml
  summary: program Specifies the program object to be queried
  description: "## Name\n\nglGetActiveAttrib — Returns information about an active attribute variable for the specified program object\n\n## C Specification\n\n`void `**`glGetActiveAttrib`**`(` GLuint `program`, GLuint `index`, GLsizei `bufSize`, GLsizei \\*`length`, GLint \\*`size`, GLenum \\*`type`, GLchar \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to be queried.\n\n *`index`*  \nSpecifies the index of the attribute variable to be queried.\n\n *`bufSize`*  \nSpecifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by *`name`*.\n\n *`length`*  \nReturns the number of characters actually written by OpenGL in the string indicated by *`name`* (excluding the null terminator) if a value other than `NULL` is passed.\n\n *`size`*  \nReturns the size of the attribute variable.\n\n *`type`*  \nReturns the data type of the attribute variable.\n\n *`name`*  \nReturns a null terminated string containing the name of the attribute variable.\n\n## Description\n\n`glGetActiveAttrib` returns information about an active attribute variable in the program object specified by *`program`*. The number of active attributes can be obtained by calling [glGetProgram](glgetprogram.xhtml) with the value `GL_ACTIVE_ATTRIBUTES`. A value of 0 for *`index`* selects the first active attribute variable. Permissible values for *`index`* range from zero to the number of active attribute variables minus one.\n\nA vertex shader may use either built-in attribute variables, user-defined attribute variables, or both. Built-in attribute variables have a prefix of \"gl\\_\" and reference conventional OpenGL vertex attribtes (e.g., *`gl_Vertex`*, *`gl_Normal`*, etc., see the OpenGL Shading Language specification for a complete list.) User-defined attribute variables have arbitrary names and obtain their values through numbered generic vertex attributes. An attribute variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, *`program`* should have previously been the target of a call to [glLinkProgram](gllinkprogram.xhtml), but it is not necessary for it to have been linked successfully.\n\nThe size of the character buffer required to store the longest attribute variable name in *`program`* can be obtained by calling [glGetProgram](glgetprogram.xhtml) with the value `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`. This value should be used to allocate a buffer of sufficient size to store the returned attribute name. The size of this character buffer is passed in *`bufSize`*, and a pointer to this character buffer is passed in *`name`*.\n\n`glGetActiveAttrib` returns the name of the attribute variable indicated by *`index`*, storing it in the character buffer specified by *`name`*. The string returned will be null terminated. The actual number of characters written into this buffer is returned in *`length`*, and this count does not include the null termination character. If the length of the returned string is not required, a value of `NULL` can be passed in the *`length`* argument.\n\nThe *`type`* argument specifies a pointer to a variable into which the attribute variable's data type will be written. The symbolic constants `GL_FLOAT`, `GL_FLOAT_VEC2`, `GL_FLOAT_VEC3`, `GL_FLOAT_VEC4`, `GL_FLOAT_MAT2`, `GL_FLOAT_MAT3`, `GL_FLOAT_MAT4`, `GL_FLOAT_MAT2x3`, `GL_FLOAT_MAT2x4`, `GL_FLOAT_MAT3x2`, `GL_FLOAT_MAT3x4`, `GL_FLOAT_MAT4x2`, `GL_FLOAT_MAT4x3`, `GL_INT`, `GL_INT_VEC2`, `GL_INT_VEC3`, `GL_INT_VEC4`, `GL_UNSIGNED_INT`, `GL_UNSIGNED_INT_VEC2`, `GL_UNSIGNED_INT_VEC3`, `GL_UNSIGNED_INT_VEC4`, `GL_DOUBLE`, `GL_DOUBLE_VEC2`, `GL_DOUBLE_VEC3`, `GL_DOUBLE_VEC4`, `GL_DOUBLE_MAT2`, `GL_DOUBLE_MAT3`, `GL_DOUBLE_MAT4`, `GL_DOUBLE_MAT2x3`, `GL_DOUBLE_MAT2x4`, `GL_DOUBLE_MAT3x2`, `GL_DOUBLE_MAT3x4`, `GL_DOUBLE_MAT4x2`, or `GL_DOUBLE_MAT4x3` may be returned. The *`size`* argument will return the size of the attribute, in units of the type returned in *`type`*.\n\nThe list of active attribute variables may include both built-in attribute variables (which begin with the prefix \"gl\\_\") as well as user-defined attribute variable names.\n\nThis function will return as much information as it can about the specified active attribute variable. If no information is available, *`length`* will be 0, and *`name`* will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values *`length`*, *`size`*, *`type`*, and *`name`* will be unmodified.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the number of active attribute variables in *`program`*.\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is less than 0.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIBS`.\n\n[glGetProgram](glgetprogram.xhtml) with argument `GL_ACTIVE_ATTRIBUTES` or `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`.\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveAttrib`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glVertexAttrib](glvertexattrib.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveAttrib.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveAttrib.xhtml)"
- name: glGetActiveSubroutineName
  id: glgetactivesubroutinename.xhtml
  summary: program Specifies the name of the program containing the subroutine
  description: "## Name\n\nglGetActiveSubroutineName — query the name of an active shader subroutine\n\n## C Specification\n\n`void `**`glGetActiveSubroutineName`**`(` GLuint `program`, GLenum `shadertype`, GLuint `index`, GLsizei `bufSize`, GLsizei \\*`length`, GLchar \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of the program containing the subroutine.\n\n *`shadertype`*  \nSpecifies the shader stage from which to query the subroutine name.\n\n *`index`*  \nSpecifies the index of the shader subroutine uniform.\n\n *`bufSize`*  \nSpecifies the size of the buffer whose address is given in *`name`*.\n\n *`length`*  \nSpecifies the address of a variable which is to receive the length of the shader subroutine uniform name.\n\n *`name`*  \nSpecifies the address of an array into which the name of the shader subroutine uniform will be written.\n\n## Description\n\n`glGetActiveSubroutineName` queries the name of an active shader subroutine uniform from the program object given in *`program`*. *`index`* specifies the index of the shader subroutine uniform within the shader stage given by *`stage`*, and must between zero and the value of `GL_ACTIVE_SUBROUTINES` minus one for the shader stage.\n\nThe name of the selected subroutine is returned as a null-terminated string in *`name`*. The actual number of characters written into *`name`*, not including the null-terminator, is returned in *`length`*. If *`length`* is `NULL`, no length is returned. The maximum number of characters that may be written into *`name`*, including the null-terminator, is given in *`bufSize`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_ACTIVE_SUBROUTINES`.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n## Associated Gets\n\n[glGetProgramStage](glgetprogramstage.xhtml) with argument `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveSubroutineName` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetSubroutineIndex](glgetsubroutineindex.xhtml), [glGetActiveSubroutineUniform](glgetactivesubroutineuniform.xhtml), [glGetProgramStage](glgetprogramstage.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveSubroutineName.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveSubroutineName.xhtml)"
- name: glGetActiveSubroutineUniform
  id: glgetactivesubroutineuniform.xhtml
  summary: program Specifies the name of the program containing the subroutine
  description: "## Name\n\nglGetActiveSubroutineUniform — query a property of an active shader subroutine uniform\n\n## C Specification\n\n`void `**`glGetActiveSubroutineUniformiv`**`(` GLuint `program`, GLenum `shadertype`, GLuint `index`, GLenum `pname`, GLint \\*`values``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of the program containing the subroutine.\n\n *`shadertype`*  \nSpecifies the shader stage from which to query for the subroutine parameter. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n *`index`*  \nSpecifies the index of the shader subroutine uniform.\n\n *`pname`*  \nSpecifies the parameter of the shader subroutine uniform to query. *`pname`* must be `GL_NUM_COMPATIBLE_SUBROUTINES`, `GL_COMPATIBLE_SUBROUTINES`, `GL_UNIFORM_SIZE` or `GL_UNIFORM_NAME_LENGTH`.\n\n *`values`*  \nSpecifies the address of a into which the queried value or values will be placed.\n\n## Description\n\n`glGetActiveSubroutineUniform` queries a parameter of an active shader subroutine uniform. *`program`* contains the name of the program containing the uniform. *`shadertype`* specifies the stage which the uniform location, given by *`index`*, is valid. *`index`* must be between zero and the value of `GL_ACTIVE_SUBROUTINE_UNIFORMS` minus one for the shader stage.\n\nIf *`pname`* is `GL_NUM_COMPATIBLE_SUBROUTINES`, a single integer indicating the number of subroutines that can be assigned to the uniform is returned in *`values`*.\n\nIf *`pname`* is `GL_COMPATIBLE_SUBROUTINES`, an array of integers is returned in *`values`*, with each integer specifying the index of an active subroutine that can be assigned to the selected subroutine uniform. The number of integers returned is the same as the value returned for `GL_NUM_COMPATIBLE_SUBROUTINES`.\n\nIf *`pname`* is `GL_UNIFORM_SIZE`, a single integer is returned in *`values`*. If the selected subroutine uniform is an array, the declared size of the array is returned; otherwise, one is returned.\n\nIf *`pname`* is `GL_UNIFORM_NAME_LENGTH`, a single integer specifying the length of the subroutine uniform name (including the terminating null character) is returned in *`values`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* or *`pname`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_ACTIVE_SUBROUTINES`.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n## Associated Gets\n\n[glGetProgramStage](glgetprogramstage.xhtml) with argument `GL_ACTIVE_SUBROUTINE_UNIFORMS`\n\n## Version Support\n\n|                                  | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:---------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**      |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveSubroutineUniformiv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetSubroutineIndex](glgetsubroutineindex.xhtml), [glGetActiveSubroutineUniformName](glgetactivesubroutineuniformname.xhtml), [glGetProgramStage](glgetprogramstage.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveSubroutineUniform.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveSubroutineUniform.xhtml)"
- name: glGetActiveSubroutineUniformiv
  id: glgetactivesubroutineuniform.xhtml#glGetActiveSubroutineUniformiv
  summary: Specifies the name of the program containing the subroutine
  belongs_to: glGetActiveSubroutineUniform
  description: "`void `**`glGetActiveSubroutineUniformiv`**`(` GLuint `program`, GLenum `shadertype`, GLuint `index`, GLenum `pname`, GLint \\*`values``)`;\n\n## Parameters\n\n*`program`*\n\nSpecifies the name of the program containing the subroutine.\n\n*`shadertype`*\n\nSpecifies the shader stage from which to query for the subroutine parameter. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n*`index`*\n\nSpecifies the index of the shader subroutine uniform.\n\n*`pname`*\n\nSpecifies the parameter of the shader subroutine uniform to query. *`pname`* must be `GL_NUM_COMPATIBLE_SUBROUTINES`, `GL_COMPATIBLE_SUBROUTINES`, `GL_UNIFORM_SIZE` or `GL_UNIFORM_NAME_LENGTH`.\n\n*`values`*\n\nSpecifies the address of a into which the queried value or values will be placed.\n\n## Description\n\n`glGetActiveSubroutineUniform` queries a parameter of an active shader subroutine uniform. *`program`* contains the name of the program containing the uniform. *`shadertype`* specifies the stage which the uniform location, given by *`index`*, is valid. *`index`* must be between zero and the value of `GL_ACTIVE_SUBROUTINE_UNIFORMS` minus one for the shader stage.\n\nIf *`pname`* is `GL_NUM_COMPATIBLE_SUBROUTINES`, a single integer indicating the number of subroutines that can be assigned to the uniform is returned in *`values`*.\n\nIf *`pname`* is `GL_COMPATIBLE_SUBROUTINES`, an array of integers is returned in *`values`*, with each integer specifying the index of an active subroutine that can be assigned to the selected subroutine uniform. The number of integers returned is the same as the value returned for `GL_NUM_COMPATIBLE_SUBROUTINES`.\n\nIf *`pname`* is `GL_UNIFORM_SIZE`, a single integer is returned in *`values`*. If the selected subroutine uniform is an array, the declared size of the array is returned; otherwise, one is returned.\n\nIf *`pname`* is `GL_UNIFORM_NAME_LENGTH`, a single integer specifying the length of the subroutine uniform name (including the terminating null character) is returned in *`values`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* or *`pname`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_ACTIVE_SUBROUTINES`.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n## Associated Gets\n\n[glGetProgramStage](glgetprogramstage.xhtml) with argument `GL_ACTIVE_SUBROUTINE_UNIFORMS`\n\n## Version Support\n\n|                                  |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:---------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**     |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetActiveSubroutineUniformiv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGetSubroutineIndex](glgetsubroutineindex.xhtml), [glGetActiveSubroutineUniformName](glgetactivesubroutineuniformname.xhtml), [glGetProgramStage](glgetprogramstage.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveSubroutineUniform.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveSubroutineUniform.xhtml)"
- name: glGetActiveSubroutineUniformName
  id: glgetactivesubroutineuniformname.xhtml
  summary: program Specifies the name of the program containing the subroutine
  description: "## Name\n\nglGetActiveSubroutineUniformName — query the name of an active shader subroutine uniform\n\n## C Specification\n\n`void `**`glGetActiveSubroutineUniformName`**`(` GLuint `program`, GLenum `shadertype`, GLuint `index`, GLsizei `bufSize`, GLsizei \\*`length`, GLchar \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of the program containing the subroutine.\n\n *`shadertype`*  \nSpecifies the shader stage from which to query for the subroutine parameter. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n *`index`*  \nSpecifies the index of the shader subroutine uniform.\n\n *`bufSize`*  \nSpecifies the size of the buffer whose address is given in *`name`*.\n\n *`length`*  \nSpecifies the address of a variable into which is written the number of characters copied into *`name`*.\n\n *`name`*  \nSpecifies the address of a buffer that will receive the name of the specified shader subroutine uniform.\n\n## Description\n\n`glGetActiveSubroutineUniformName` retrieves the name of an active shader subroutine uniform. *`program`* contains the name of the program containing the uniform. *`shadertype`* specifies the stage for which the uniform location, given by *`index`*, is valid. *`index`* must be between zero and the value of `GL_ACTIVE_SUBROUTINE_UNIFORMS` minus one for the shader stage.\n\nThe uniform name is returned as a null-terminated string in *`name`*. The actual number of characters written into *`name`*, excluding the null terminator is returned in *`length`*. If *`length`* is `NULL`, no length is returned. The maximum number of characters that may be written into *`name`*, including the null terminator, is specified by *`bufSize`*. The length of the longest subroutine uniform name in *`program`* and *`shadertype`* is given by the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, which can be queried with [glGetProgramStage](glgetprogramstage.xhtml).\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* or *`pname`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_ACTIVE_SUBROUTINE_UNIFORMS`.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n## Associated Gets\n\n[glGetProgramStage](glgetprogramstage.xhtml) with argument `GL_ACTIVE_SUBROUTINE_UNIFORMS`\n\n## Version Support\n\n|                                    | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**        |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveSubroutineUniformName` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetSubroutineIndex](glgetsubroutineindex.xhtml), [glGetActiveSubroutineUniform](glgetactivesubroutineuniform.xhtml), [glGetProgramStage](glgetprogramstage.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveSubroutineUniformName.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveSubroutineUniformName.xhtml)"
- name: glGetActiveUniform
  id: glgetactiveuniform.xhtml
  summary: program Specifies the program object to be queried
  description: "## Name\n\nglGetActiveUniform — Returns information about an active uniform variable for the specified program object\n\n## C Specification\n\n`void `**`glGetActiveUniform`**`(` GLuint `program`, GLuint `index`, GLsizei `bufSize`, GLsizei \\*`length`, GLint \\*`size`, GLenum \\*`type`, GLchar \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to be queried.\n\n *`index`*  \nSpecifies the index of the uniform variable to be queried.\n\n *`bufSize`*  \nSpecifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by *`name`*.\n\n *`length`*  \nReturns the number of characters actually written by OpenGL in the string indicated by *`name`* (excluding the null terminator) if a value other than `NULL` is passed.\n\n *`size`*  \nReturns the size of the uniform variable.\n\n *`type`*  \nReturns the data type of the uniform variable.\n\n *`name`*  \nReturns a null terminated string containing the name of the uniform variable.\n\n## Description\n\n`glGetActiveUniform` returns information about an active uniform variable in the program object specified by *`program`*. The number of active uniform variables can be obtained by calling [glGetProgram](glgetprogram.xhtml) with the value `GL_ACTIVE_UNIFORMS`. A value of 0 for *`index`* selects the first active uniform variable. Permissible values for *`index`* range from zero to the number of active uniform variables minus one.\n\nShaders may use either built-in uniform variables, user-defined uniform variables, or both. Built-in uniform variables have a prefix of \"gl\\_\" and reference existing OpenGL state or values derived from such state (e.g., *`gl_DepthRangeParameters`*, see the OpenGL Shading Language specification for a complete list.) User-defined uniform variables have arbitrary names and obtain their values from the application through calls to [glUniform](gluniform.xhtml). A uniform variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, *`program`* should have previously been the target of a call to [glLinkProgram](gllinkprogram.xhtml), but it is not necessary for it to have been linked successfully.\n\nThe size of the character buffer required to store the longest uniform variable name in *`program`* can be obtained by calling [glGetProgram](glgetprogram.xhtml) with the value `GL_ACTIVE_UNIFORM_MAX_LENGTH`. This value should be used to allocate a buffer of sufficient size to store the returned uniform variable name. The size of this character buffer is passed in *`bufSize`*, and a pointer to this character buffer is passed in *`name.`*\n\n`glGetActiveUniform` returns the name of the uniform variable indicated by *`index`*, storing it in the character buffer specified by *`name`*. The string returned will be null terminated. The actual number of characters written into this buffer is returned in *`length`*, and this count does not include the null termination character. If the length of the returned string is not required, a value of `NULL` can be passed in the *`length`* argument.\n\nThe *`type`* argument will return a pointer to the uniform variable's data type. The symbolic constants returned for uniform types are shown in the table below.\n\n|  **Returned Symbolic Contant**                 |  **Shader Uniform Type**  |\n|:-----------------------------------------------|:--------------------------|\n| `GL_FLOAT`                                     | `float`                   |\n| `GL_FLOAT_VEC2`                                | `vec2`                    |\n| `GL_FLOAT_VEC3`                                | `vec3`                    |\n| `GL_FLOAT_VEC4`                                | `vec4`                    |\n| `GL_DOUBLE`                                    | `double`                  |\n| `GL_DOUBLE_VEC2`                               | `dvec2`                   |\n| `GL_DOUBLE_VEC3`                               | `dvec3`                   |\n| `GL_DOUBLE_VEC4`                               | `dvec4`                   |\n| `GL_INT`                                       | `int`                     |\n| `GL_INT_VEC2`                                  | `ivec2`                   |\n| `GL_INT_VEC3`                                  | `ivec3`                   |\n| `GL_INT_VEC4`                                  | `ivec4`                   |\n| `GL_UNSIGNED_INT`                              | `unsigned int`            |\n| `GL_UNSIGNED_INT_VEC2`                         | `uvec2`                   |\n| `GL_UNSIGNED_INT_VEC3`                         | `uvec3`                   |\n| `GL_UNSIGNED_INT_VEC4`                         | `uvec4`                   |\n| `GL_BOOL`                                      | `bool`                    |\n| `GL_BOOL_VEC2`                                 | `bvec2`                   |\n| `GL_BOOL_VEC3`                                 | `bvec3`                   |\n| `GL_BOOL_VEC4`                                 | `bvec4`                   |\n| `GL_FLOAT_MAT2`                                | `mat2`                    |\n| `GL_FLOAT_MAT3`                                | `mat3`                    |\n| `GL_FLOAT_MAT4`                                | `mat4`                    |\n| `GL_FLOAT_MAT2x3`                              | `mat2x3`                  |\n| `GL_FLOAT_MAT2x4`                              | `mat2x4`                  |\n| `GL_FLOAT_MAT3x2`                              | `mat3x2`                  |\n| `GL_FLOAT_MAT3x4`                              | `mat3x4`                  |\n| `GL_FLOAT_MAT4x2`                              | `mat4x2`                  |\n| `GL_FLOAT_MAT4x3`                              | `mat4x3`                  |\n| `GL_DOUBLE_MAT2`                               | `dmat2`                   |\n| `GL_DOUBLE_MAT3`                               | `dmat3`                   |\n| `GL_DOUBLE_MAT4`                               | `dmat4`                   |\n| `GL_DOUBLE_MAT2x3`                             | `dmat2x3`                 |\n| `GL_DOUBLE_MAT2x4`                             | `dmat2x4`                 |\n| `GL_DOUBLE_MAT3x2`                             | `dmat3x2`                 |\n| `GL_DOUBLE_MAT3x4`                             | `dmat3x4`                 |\n| `GL_DOUBLE_MAT4x2`                             | `dmat4x2`                 |\n| `GL_DOUBLE_MAT4x3`                             | `dmat4x3`                 |\n| `GL_SAMPLER_1D`                                | `sampler1D`               |\n| `GL_SAMPLER_2D`                                | `sampler2D`               |\n| `GL_SAMPLER_3D`                                | `sampler3D`               |\n| `GL_SAMPLER_CUBE`                              | `samplerCube`             |\n| `GL_SAMPLER_1D_SHADOW`                         | `sampler1DShadow`         |\n| `GL_SAMPLER_2D_SHADOW`                         | `sampler2DShadow`         |\n| `GL_SAMPLER_1D_ARRAY`                          | `sampler1DArray`          |\n| `GL_SAMPLER_2D_ARRAY`                          | `sampler2DArray`          |\n| `GL_SAMPLER_1D_ARRAY_SHADOW`                   | `sampler1DArrayShadow`    |\n| `GL_SAMPLER_2D_ARRAY_SHADOW`                   | `sampler2DArrayShadow`    |\n| `GL_SAMPLER_2D_MULTISAMPLE`                    | `sampler2DMS`             |\n| `GL_SAMPLER_2D_MULTISAMPLE_ARRAY`              | `sampler2DMSArray`        |\n| `GL_SAMPLER_CUBE_SHADOW`                       | `samplerCubeShadow`       |\n| `GL_SAMPLER_BUFFER`                            | `samplerBuffer`           |\n| `GL_SAMPLER_2D_RECT`                           | `sampler2DRect`           |\n| `GL_SAMPLER_2D_RECT_SHADOW`                    | `sampler2DRectShadow`     |\n| `GL_INT_SAMPLER_1D`                            | `isampler1D`              |\n| `GL_INT_SAMPLER_2D`                            | `isampler2D`              |\n| `GL_INT_SAMPLER_3D`                            | `isampler3D`              |\n| `GL_INT_SAMPLER_CUBE`                          | `isamplerCube`            |\n| `GL_INT_SAMPLER_1D_ARRAY`                      | `isampler1DArray`         |\n| `GL_INT_SAMPLER_2D_ARRAY`                      | `isampler2DArray`         |\n| `GL_INT_SAMPLER_2D_MULTISAMPLE`                | `isampler2DMS`            |\n| `GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY`          | `isampler2DMSArray`       |\n| `GL_INT_SAMPLER_BUFFER`                        | `isamplerBuffer`          |\n| `GL_INT_SAMPLER_2D_RECT`                       | `isampler2DRect`          |\n| `GL_UNSIGNED_INT_SAMPLER_1D`                   | `usampler1D`              |\n| `GL_UNSIGNED_INT_SAMPLER_2D`                   | `usampler2D`              |\n| `GL_UNSIGNED_INT_SAMPLER_3D`                   | `usampler3D`              |\n| `GL_UNSIGNED_INT_SAMPLER_CUBE`                 | `usamplerCube`            |\n| `GL_UNSIGNED_INT_SAMPLER_1D_ARRAY`             | `usampler2DArray`         |\n| `GL_UNSIGNED_INT_SAMPLER_2D_ARRAY`             | `usampler2DArray`         |\n| `GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE`       | `usampler2DMS`            |\n| `GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` | `usampler2DMSArray`       |\n| `GL_UNSIGNED_INT_SAMPLER_BUFFER`               | `usamplerBuffer`          |\n| `GL_UNSIGNED_INT_SAMPLER_2D_RECT`              | `usampler2DRect`          |\n| `GL_IMAGE_1D`                                  | `image1D`                 |\n| `GL_IMAGE_2D`                                  | `image2D`                 |\n| `GL_IMAGE_3D`                                  | `image3D`                 |\n| `GL_IMAGE_2D_RECT`                             | `image2DRect`             |\n| `GL_IMAGE_CUBE`                                | `imageCube`               |\n| `GL_IMAGE_BUFFER`                              | `imageBuffer`             |\n| `GL_IMAGE_1D_ARRAY`                            | `image1DArray`            |\n| `GL_IMAGE_2D_ARRAY`                            | `image2DArray`            |\n| `GL_IMAGE_2D_MULTISAMPLE`                      | `image2DMS`               |\n| `GL_IMAGE_2D_MULTISAMPLE_ARRAY`                | `image2DMSArray`          |\n| `GL_INT_IMAGE_1D`                              | `iimage1D`                |\n| `GL_INT_IMAGE_2D`                              | `iimage2D`                |\n| `GL_INT_IMAGE_3D`                              | `iimage3D`                |\n| `GL_INT_IMAGE_2D_RECT`                         | `iimage2DRect`            |\n| `GL_INT_IMAGE_CUBE`                            | `iimageCube`              |\n| `GL_INT_IMAGE_BUFFER`                          | `iimageBuffer`            |\n| `GL_INT_IMAGE_1D_ARRAY`                        | `iimage1DArray`           |\n| `GL_INT_IMAGE_2D_ARRAY`                        | `iimage2DArray`           |\n| `GL_INT_IMAGE_2D_MULTISAMPLE`                  | `iimage2DMS`              |\n| `GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY`            | `iimage2DMSArray`         |\n| `GL_UNSIGNED_INT_IMAGE_1D`                     | `uimage1D`                |\n| `GL_UNSIGNED_INT_IMAGE_2D`                     | `uimage2D`                |\n| `GL_UNSIGNED_INT_IMAGE_3D`                     | `uimage3D`                |\n| `GL_UNSIGNED_INT_IMAGE_2D_RECT`                | `uimage2DRect`            |\n| `GL_UNSIGNED_INT_IMAGE_CUBE`                   | `uimageCube`              |\n| `GL_UNSIGNED_INT_IMAGE_BUFFER`                 | `uimageBuffer`            |\n| `GL_UNSIGNED_INT_IMAGE_1D_ARRAY`               | `uimage1DArray`           |\n| `GL_UNSIGNED_INT_IMAGE_2D_ARRAY`               | `uimage2DArray`           |\n| `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE`         | `uimage2DMS`              |\n| `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY`   | `uimage2DMSArray`         |\n| `GL_UNSIGNED_INT_ATOMIC_COUNTER`               | `atomic_uint`             |\n\nIf one or more elements of an array are active, the name of the array is returned in *`name`*, the type is returned in *`type`*, and the *`size`* parameter returns the highest array element index used, plus one, as determined by the compiler and/or linker. Only one active uniform variable will be reported for a uniform array.\n\nUniform variables that are declared as structures or arrays of structures will not be returned directly by this function. Instead, each of these uniform variables will be reduced to its fundamental components containing the \".\" and \"\\[\\]\" operators such that each of the names is valid as an argument to [glGetUniformLocation](glgetuniformlocation.xhtml). Each of these reduced uniform variables is counted as one active uniform variable and is assigned an index. A valid name cannot be a structure, an array of structures, or a subcomponent of a vector or matrix.\n\nThe size of the uniform variable will be returned in *`size`*. Uniform variables other than arrays will have a size of 1. Structures and arrays of structures will be reduced as described earlier, such that each of the names returned will be a data type in the earlier list. If this reduction results in an array, the size returned will be as described for uniform arrays; otherwise, the size returned will be 1.\n\nThe list of active uniform variables may include both built-in uniform variables (which begin with the prefix \"gl\\_\") as well as user-defined uniform variable names.\n\nThis function will return as much information as it can about the specified active uniform variable. If no information is available, *`length`* will be 0, and *`name`* will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values *`length`*, *`size`*, *`type`*, and *`name`* will be unmodified.\n\n## Notes\n\nThe double types, `GL_DOUBLE`, `GL_DOUBLE_VEC2`, `GL_DOUBLE_VEC3`, `GL_DOUBLE_VEC4`, `GL_DOUBLE_MAT2`, `GL_DOUBLE_MAT3`, `GL_DOUBLE_MAT4`, `GL_DOUBLE_MAT2x3`, `GL_DOUBLE_MAT2x4`, `GL_DOUBLE_MAT3x2`, `GL_DOUBLE_MAT3x4`, `GL_DOUBLE_MAT4x2`, and `GL_DOUBLE_MAT4x3` are only available if the GL version is 4.1 or higher.\n\nThe image types, `GL_IMAGE_1D`, `GL_IMAGE_2D`, `GL_IMAGE_3D`, `GL_IMAGE_2D_RECT`, `GL_IMAGE_CUBE`, `GL_IMAGE_BUFFER`, `GL_IMAGE_1D_ARRAY`, `GL_IMAGE_2D_ARRAY`, `GL_IMAGE_2D_MULTISAMPLE`, `GL_IMAGE_2D_MULTISAMPLE_ARRAY`, `GL_INT_IMAGE_1D`, `GL_INT_IMAGE_2D`, `GL_INT_IMAGE_3D`, `GL_INT_IMAGE_2D_RECT`, `GL_INT_IMAGE_CUBE`, `GL_INT_IMAGE_BUFFER`, `GL_INT_IMAGE_1D_ARRAY`, `GL_INT_IMAGE_2D_ARRAY`, `GL_INT_IMAGE_2D_MULTISAMPLE`, `GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY`, `GL_UNSIGNED_INT_IMAGE_1D`, `GL_UNSIGNED_INT_IMAGE_2D`, `GL_UNSIGNED_INT_IMAGE_3D`, `GL_UNSIGNED_INT_IMAGE_2D_RECT`, `GL_UNSIGNED_INT_IMAGE_CUBE`, `GL_UNSIGNED_INT_IMAGE_BUFFER`, `GL_UNSIGNED_INT_IMAGE_1D_ARRAY`, `GL_UNSIGNED_INT_IMAGE_2D_ARRAY`, `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE`, `GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY`, and the atomic counter type, `GL_UNSIGNED_INT_ATOMIC_COUNTER` are only available if the GL version is 4.2 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the number of active uniform variables in *`program`*.\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is less than 0.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_UNIFORM_COMPONENTS`, `GL_MAX_GEOMETRY_UNIFORM_COMPONENTS`, `GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS`, `GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS`, `GL_MAX_FRAGMENT_UNIFORM_COMPONENTS`.\n\n[glGetProgram](glgetprogram.xhtml) with argument `GL_ACTIVE_UNIFORMS` or `GL_ACTIVE_UNIFORM_MAX_LENGTH`.\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveUniform`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetUniform](glgetuniform.xhtml), [glGetUniformLocation](glgetuniformlocation.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glUniform](gluniform.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniform.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniform.xhtml)"
- name: glGetActiveUniformBlock
  id: glgetactiveuniformblock.xhtml
  summary: program Specifies the name of a program containing the uniform block
  description: "## Name\n\nglGetActiveUniformBlock — query information about an active uniform block\n\n## C Specification\n\n`void `**`glGetActiveUniformBlockiv`**`(` GLuint `program`, GLuint `uniformBlockIndex`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of a program containing the uniform block.\n\n *`uniformBlockIndex`*  \nSpecifies the index of the uniform block within *`program`*.\n\n *`pname`*  \nSpecifies the name of the parameter to query.\n\n *`params`*  \nSpecifies the address of a variable to receive the result of the query.\n\n## Description\n\n`glGetActiveUniformBlockiv` retrieves information about an active uniform block within *`program`*.\n\n*`program`* must be the name of a program object for which the command [glLinkProgram](gllinkprogram.xhtml) must have been called in the past, although it is not required that [glLinkProgram](gllinkprogram.xhtml) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.\n\n*`uniformBlockIndex`* is an active uniform block index of *`program`*, and must be less than the value of `GL_ACTIVE_UNIFORM_BLOCKS`.\n\nUpon success, the uniform block parameter(s) specified by *`pname`* are returned in *`params`*. If an error occurs, nothing will be written to *`params`*.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_BINDING`, then the index of the uniform buffer binding point last selected by the uniform block specified by *`uniformBlockIndex`* for *`program`* is returned. If no uniform block has been previously specified, zero is returned.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_DATA_SIZE`, then the implementation-dependent minimum total buffer object size, in basic machine units, required to hold all active uniforms in the uniform block identified by *`uniformBlockIndex`* is returned. It is neither guaranteed nor expected that a given implementation will arrange uniform values as tightly packed in a buffer object. The exception to this is the *std140 uniform block layout*, which guarantees specific packing behavior and does not require the application to query for offsets and strides. In this case the minimum size may still be queried, even though it is determined in advance based only on the uniform block declaration.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_NAME_LENGTH`, then the total length (including the nul terminator) of the name of the uniform block identified by *`uniformBlockIndex`* is returned.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS`, then the number of active uniforms in the uniform block identified by *`uniformBlockIndex`* is returned.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES`, then a list of the active uniform indices for the uniform block identified by *`uniformBlockIndex`* is returned. The number of elements that will be written to *`params`* is the value of `GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS` for *`uniformBlockIndex`*.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER`, `GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER`, `GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER`, `GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER`, `GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER`, or `GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER` then a boolean value indicating whether the uniform block identified by *`uniformBlockIndex`* is referenced by the vertex, tessellation control, tessellation evaluation, geometry, fragment or compute programming stages of program, respectively, is returned.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`uniformBlockIndex`* is greater than or equal to the value of `GL_ACTIVE_UNIFORM_BLOCKS` or is not the index of an active uniform block in *`program`*.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted tokens.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of a program object for which [glLinkProgram](gllinkprogram.xhtml) has been called in the past.\n\n## Notes\n\n`glGetActiveUniformBlockiv` is available only if the GL version is 3.1 or greater.\n\n`GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER` is accepted only if the GL version is 4.3 or greater.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveUniformBlockiv` |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetActiveUniformBlockName](glgetactiveuniformblockname.xhtml), [glGetUniformBlockIndex](glgetuniformblockindex.xhtml), [glLinkProgram](gllinkprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformBlock.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformBlock.xhtml)"
- name: glGetActiveUniformBlockiv
  id: glgetactiveuniformblock.xhtml#glGetActiveUniformBlockiv
  summary: Specifies the name of a program containing the uniform block
  belongs_to: glGetActiveUniformBlock
  description: "`void `**`glGetActiveUniformBlockiv`**`(` GLuint `program`, GLuint `uniformBlockIndex`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n*`program`*\n\nSpecifies the name of a program containing the uniform block.\n\n*`uniformBlockIndex`*\n\nSpecifies the index of the uniform block within *`program`*.\n\n*`pname`*\n\nSpecifies the name of the parameter to query.\n\n*`params`*\n\nSpecifies the address of a variable to receive the result of the query.\n\n## Description\n\n`glGetActiveUniformBlockiv` retrieves information about an active uniform block within *`program`*.\n\n*`program`* must be the name of a program object for which the command [glLinkProgram](gllinkprogram.xhtml) must have been called in the past, although it is not required that [glLinkProgram](gllinkprogram.xhtml) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.\n\n*`uniformBlockIndex`* is an active uniform block index of *`program`*, and must be less than the value of `GL_ACTIVE_UNIFORM_BLOCKS`.\n\nUpon success, the uniform block parameter(s) specified by *`pname`* are returned in *`params`*. If an error occurs, nothing will be written to *`params`*.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_BINDING`, then the index of the uniform buffer binding point last selected by the uniform block specified by *`uniformBlockIndex`* for *`program`* is returned. If no uniform block has been previously specified, zero is returned.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_DATA_SIZE`, then the implementation-dependent minimum total buffer object size, in basic machine units, required to hold all active uniforms in the uniform block identified by *`uniformBlockIndex`* is returned. It is neither guaranteed nor expected that a given implementation will arrange uniform values as tightly packed in a buffer object. The exception to this is the *std140 uniform block layout*, which guarantees specific packing behavior and does not require the application to query for offsets and strides. In this case the minimum size may still be queried, even though it is determined in advance based only on the uniform block declaration.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_NAME_LENGTH`, then the total length (including the nul terminator) of the name of the uniform block identified by *`uniformBlockIndex`* is returned.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS`, then the number of active uniforms in the uniform block identified by *`uniformBlockIndex`* is returned.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES`, then a list of the active uniform indices for the uniform block identified by *`uniformBlockIndex`* is returned. The number of elements that will be written to *`params`* is the value of `GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS` for *`uniformBlockIndex`*.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER`, `GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER`, `GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER`, `GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER`, `GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER`, or `GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER` then a boolean value indicating whether the uniform block identified by *`uniformBlockIndex`* is referenced by the vertex, tessellation control, tessellation evaluation, geometry, fragment or compute programming stages of program, respectively, is returned.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`uniformBlockIndex`* is greater than or equal to the value of `GL_ACTIVE_UNIFORM_BLOCKS` or is not the index of an active uniform block in *`program`*.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted tokens.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of a program object for which [glLinkProgram](gllinkprogram.xhtml) has been called in the past.\n\n## Notes\n\n`glGetActiveUniformBlockiv` is available only if the GL version is 3.1 or greater.\n\n`GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER` is accepted only if the GL version is 4.3 or greater.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetActiveUniformBlockiv`   |          \\-          |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGetActiveUniformBlockName](glgetactiveuniformblockname.xhtml), [glGetUniformBlockIndex](glgetuniformblockindex.xhtml), [glLinkProgram](gllinkprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformBlock.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformBlock.xhtml)"
- name: glGetActiveUniformBlockName
  id: glgetactiveuniformblockname.xhtml
  summary: program Specifies the name of a program containing the uniform block
  description: "## Name\n\nglGetActiveUniformBlockName — retrieve the name of an active uniform block\n\n## C Specification\n\n`void `**`glGetActiveUniformBlockName`**`(` GLuint `program`, GLuint `uniformBlockIndex`, GLsizei `bufSize`, GLsizei \\*`length`, GLchar \\*`uniformBlockName``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of a program containing the uniform block.\n\n *`uniformBlockIndex`*  \nSpecifies the index of the uniform block within *`program`*.\n\n *`bufSize`*  \nSpecifies the size of the buffer addressed by *`uniformBlockName`*.\n\n *`length`*  \nSpecifies the address of a variable to receive the number of characters that were written to *`uniformBlockName`*.\n\n *`uniformBlockName`*  \nSpecifies the address an array of characters to receive the name of the uniform block at *`uniformBlockIndex`*.\n\n## Description\n\n`glGetActiveUniformBlockName` retrieves the name of the active uniform block at *`uniformBlockIndex`* within *`program`*.\n\n*`program`* must be the name of a program object for which the command [glLinkProgram](gllinkprogram.xhtml) must have been called in the past, although it is not required that [glLinkProgram](gllinkprogram.xhtml) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.\n\n*`uniformBlockIndex`* is an active uniform block index of *`program`*, and must be less than the value of `GL_ACTIVE_UNIFORM_BLOCKS`.\n\nUpon success, the name of the uniform block identified by *`unifomBlockIndex`* is returned into *`uniformBlockName`*. The name is nul-terminated. The actual number of characters written into *`uniformBlockName`*, excluding the nul terminator, is returned in *`length`*. If *`length`* is `NULL`, no length is returned.\n\n*`bufSize`* contains the maximum number of characters (including the nul terminator) that will be written into *`uniformBlockName`*.\n\nIf an error occurs, nothing will be written to *`uniformBlockName`* or *`length`*.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of a program object for which [glLinkProgram](gllinkprogram.xhtml) has been called in the past.\n\n`GL_INVALID_VALUE` is generated if *`uniformBlockIndex`* is greater than or equal to the value of `GL_ACTIVE_UNIFORM_BLOCKS` or is not the index of an active uniform block in *`program`*.\n\n## Notes\n\n`glGetActiveUniformBlockName` is available only if the GL version is 3.1 or greater.\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveUniformBlockName` |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetActiveUniformBlock](glgetactiveuniformblock.xhtml), [glGetUniformBlockIndex](glgetuniformblockindex.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformBlockName.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformBlockName.xhtml)"
- name: glGetActiveUniformName
  id: glgetactiveuniformname.xhtml
  summary: program Specifies the program containing the active uniform index uniformIndex
  description: "## Name\n\nglGetActiveUniformName — query the name of an active uniform\n\n## C Specification\n\n`void `**`glGetActiveUniformName`**`(` GLuint `program`, GLuint `uniformIndex`, GLsizei `bufSize`, GLsizei \\*`length`, GLchar \\*`uniformName``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program containing the active uniform index *`uniformIndex`*.\n\n *`uniformIndex`*  \nSpecifies the index of the active uniform whose name to query.\n\n *`bufSize`*  \nSpecifies the size of the buffer, in units of `GLchar`, of the buffer whose address is specified in *`uniformName`*.\n\n *`length`*  \nSpecifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by *`uniformName`*.\n\n *`uniformName`*  \nSpecifies the address of a buffer into which the GL will place the name of the active uniform at *`uniformIndex`* within *`program`*.\n\n## Description\n\n`glGetActiveUniformName` returns the name of the active uniform at *`uniformIndex`* within *`program`*. If *`uniformName`* is not `NULL`, up to *`bufSize`* characters (including a nul-terminator) will be written into the array whose address is specified by *`uniformName`*. If *`length`* is not `NULL`, the number of characters that were (or would have been) written into *`uniformName`* (not including the nul-terminator) will be placed in the variable whose address is specified in *`length`*. If *`length`* is `NULL`, no length is returned. The length of the longest uniform name in *`program`* is given by the value of `GL_ACTIVE_UNIFORM_MAX_LENGTH`, which can be queried with [glGetProgram](glgetprogram.xhtml).\n\nIf `glGetActiveUniformName` is not successful, nothing is written to *`length`* or *`uniformName`*.\n\n*`program`* must be the name of a program for which the command [glLinkProgram](gllinkprogram.xhtml) has been issued in the past. It is not necessary for *`program`* to have been linked successfully. The link could have failed because the number of active uniforms exceeded the limit.\n\n*`uniformIndex`* must be an active uniform index of the program *`program`*, in the range zero to the value of `GL_ACTIVE_UNIFORMS` minus one. The value of `GL_ACTIVE_UNIFORMS` can be queried with [glGetProgram](glgetprogram.xhtml).\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`uniformIndex`* is greater than or equal to the value of `GL_ACTIVE_UNIFORMS`.\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is negative.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of a program object for which [glLinkProgram](gllinkprogram.xhtml) has been issued.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveUniformName`    |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetActiveUniform](glgetactiveuniform.xhtml), [glGetUniformIndices](glgetuniformindices.xhtml), [glGetProgram](glgetprogram.xhtml), [glLinkProgram](gllinkprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformName.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformName.xhtml)"
- name: glGetActiveUniformsiv
  id: glgetactiveuniformsiv.xhtml
  summary: program Specifies the program object to be queried
  description: "## Name\n\nglGetActiveUniformsiv — Returns information about several active uniform variables for the specified program object\n\n## C Specification\n\n`void `**`glGetActiveUniformsiv`**`(` GLuint `program`, GLsizei `uniformCount`, const GLuint \\*`uniformIndices`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to be queried.\n\n *`uniformCount`*  \nSpecifies both the number of elements in the array of indices *`uniformIndices`* and the number of parameters written to *`params`* upon successful return.\n\n *`uniformIndices`*  \nSpecifies the address of an array of *`uniformCount`* integers containing the indices of uniforms within *`program`* whose parameter *`pname`* should be queried.\n\n *`pname`*  \nSpecifies the property of each uniform in *`uniformIndices`* that should be written into the corresponding element of *`params`*.\n\n *`params`*  \nSpecifies the address of an array of *`uniformCount`* integers which are to receive the value of *`pname`* for each uniform in *`uniformIndices`*.\n\n## Description\n\n`glGetActiveUniformsiv` queries the value of the parameter named *`pname`* for each of the uniforms within *`program`* whose indices are specified in the array of *`uniformCount`* unsigned integers *`uniformIndices`*. Upon success, the value of the parameter for each uniform is written into the corresponding entry in the array whose address is given in *`params`*. If an error is generated, nothing is written into *`params`*.\n\nIf *`pname`* is `GL_UNIFORM_TYPE`, then an array identifying the types of uniforms specified by the corresponding array of *`uniformIndices`* is returned. The returned types can be any of the values from the following table:\n\n|  **Returned Symbolic Contant**                 |  **Shader Uniform Type**  |\n|:-----------------------------------------------|:--------------------------|\n| `GL_FLOAT`                                     | `float`                   |\n| `GL_FLOAT_VEC2`                                | `vec2`                    |\n| `GL_FLOAT_VEC3`                                | `vec3`                    |\n| `GL_FLOAT_VEC4`                                | `vec4`                    |\n| `GL_DOUBLE`                                    | `double`                  |\n| `GL_DOUBLE_VEC2`                               | `dvec2`                   |\n| `GL_DOUBLE_VEC3`                               | `dvec3`                   |\n| `GL_DOUBLE_VEC4`                               | `dvec4`                   |\n| `GL_INT`                                       | `int`                     |\n| `GL_INT_VEC2`                                  | `ivec2`                   |\n| `GL_INT_VEC3`                                  | `ivec3`                   |\n| `GL_INT_VEC4`                                  | `ivec4`                   |\n| `GL_UNSIGNED_INT`                              | `unsigned int`            |\n| `GL_UNSIGNED_INT_VEC2`                         | `uvec2`                   |\n| `GL_UNSIGNED_INT_VEC3`                         | `uvec3`                   |\n| `GL_UNSIGNED_INT_VEC4`                         | `uvec4`                   |\n| `GL_BOOL`                                      | `bool`                    |\n| `GL_BOOL_VEC2`                                 | `bvec2`                   |\n| `GL_BOOL_VEC3`                                 | `bvec3`                   |\n| `GL_BOOL_VEC4`                                 | `bvec4`                   |\n| `GL_FLOAT_MAT2`                                | `mat2`                    |\n| `GL_FLOAT_MAT3`                                | `mat3`                    |\n| `GL_FLOAT_MAT4`                                | `mat4`                    |\n| `GL_FLOAT_MAT2x3`                              | `mat2x3`                  |\n| `GL_FLOAT_MAT2x4`                              | `mat2x4`                  |\n| `GL_FLOAT_MAT3x2`                              | `mat3x2`                  |\n| `GL_FLOAT_MAT3x4`                              | `mat3x4`                  |\n| `GL_FLOAT_MAT4x2`                              | `mat4x2`                  |\n| `GL_FLOAT_MAT4x3`                              | `mat4x3`                  |\n| `GL_DOUBLE_MAT2`                               | `dmat2`                   |\n| `GL_DOUBLE_MAT3`                               | `dmat3`                   |\n| `GL_DOUBLE_MAT4`                               | `dmat4`                   |\n| `GL_DOUBLE_MAT2x3`                             | `dmat2x3`                 |\n| `GL_DOUBLE_MAT2x4`                             | `dmat2x4`                 |\n| `GL_DOUBLE_MAT3x2`                             | `dmat3x2`                 |\n| `GL_DOUBLE_MAT3x4`                             | `dmat3x4`                 |\n| `GL_DOUBLE_MAT4x2`                             | `dmat4x2`                 |\n| `GL_DOUBLE_MAT4x3`                             | `dmat4x3`                 |\n| `GL_SAMPLER_1D`                                | `sampler1D`               |\n| `GL_SAMPLER_2D`                                | `sampler2D`               |\n| `GL_SAMPLER_3D`                                | `sampler3D`               |\n| `GL_SAMPLER_CUBE`                              | `samplerCube`             |\n| `GL_SAMPLER_1D_SHADOW`                         | `sampler1DShadow`         |\n| `GL_SAMPLER_2D_SHADOW`                         | `sampler2DShadow`         |\n| `GL_SAMPLER_1D_ARRAY`                          | `sampler1DArray`          |\n| `GL_SAMPLER_2D_ARRAY`                          | `sampler2DArray`          |\n| `GL_SAMPLER_1D_ARRAY_SHADOW`                   | `sampler1DArrayShadow`    |\n| `GL_SAMPLER_2D_ARRAY_SHADOW`                   | `sampler2DArrayShadow`    |\n| `GL_SAMPLER_2D_MULTISAMPLE`                    | `sampler2DMS`             |\n| `GL_SAMPLER_2D_MULTISAMPLE_ARRAY`              | `sampler2DMSArray`        |\n| `GL_SAMPLER_CUBE_SHADOW`                       | `samplerCubeShadow`       |\n| `GL_SAMPLER_BUFFER`                            | `samplerBuffer`           |\n| `GL_SAMPLER_2D_RECT`                           | `sampler2DRect`           |\n| `GL_SAMPLER_2D_RECT_SHADOW`                    | `sampler2DRectShadow`     |\n| `GL_INT_SAMPLER_1D`                            | `isampler1D`              |\n| `GL_INT_SAMPLER_2D`                            | `isampler2D`              |\n| `GL_INT_SAMPLER_3D`                            | `isampler3D`              |\n| `GL_INT_SAMPLER_CUBE`                          | `isamplerCube`            |\n| `GL_INT_SAMPLER_1D_ARRAY`                      | `isampler1DArray`         |\n| `GL_INT_SAMPLER_2D_ARRAY`                      | `isampler2DArray`         |\n| `GL_INT_SAMPLER_2D_MULTISAMPLE`                | `isampler2DMS`            |\n| `GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY`          | `isampler2DMSArray`       |\n| `GL_INT_SAMPLER_BUFFER`                        | `isamplerBuffer`          |\n| `GL_INT_SAMPLER_2D_RECT`                       | `isampler2DRect`          |\n| `GL_UNSIGNED_INT_SAMPLER_1D`                   | `usampler1D`              |\n| `GL_UNSIGNED_INT_SAMPLER_2D`                   | `usampler2D`              |\n| `GL_UNSIGNED_INT_SAMPLER_3D`                   | `usampler3D`              |\n| `GL_UNSIGNED_INT_SAMPLER_CUBE`                 | `usamplerCube`            |\n| `GL_UNSIGNED_INT_SAMPLER_1D_ARRAY`             | `usampler2DArray`         |\n| `GL_UNSIGNED_INT_SAMPLER_2D_ARRAY`             | `usampler2DArray`         |\n| `GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE`       | `usampler2DMS`            |\n| `GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY` | `usampler2DMSArray`       |\n| `GL_UNSIGNED_INT_SAMPLER_BUFFER`               | `usamplerBuffer`          |\n| `GL_UNSIGNED_INT_SAMPLER_2D_RECT`              | `usampler2DRect`          |\n\nIf *`pname`* is `GL_UNIFORM_SIZE`, then an array identifying the size of the uniforms specified by the corresponding array of *`uniformIndices`* is returned. The sizes returned are in units of the type returned by a query of `GL_UNIFORM_TYPE`. For active uniforms that are arrays, the size is the number of active elements in the array; for all other uniforms, the size is one.\n\nIf *`pname`* is `GL_UNIFORM_NAME_LENGTH`, then an array identifying the length, including the terminating null character, of the uniform name strings specified by the corresponding array of *`uniformIndices`* is returned.\n\nIf *`pname`* is `GL_UNIFORM_BLOCK_INDEX`, then an array identifying the uniform block index of each of the uniforms specified by the corresponding array of *`uniformIndices`* is returned. The uniform block index of a uniform associated with the default uniform block is -1.\n\nIf *`pname`* is `GL_UNIFORM_OFFSET`, then an array of uniform buffer offsets is returned. For uniforms in a named uniform block, the returned value will be its offset, in basic machine units, relative to the beginning of the uniform block in the buffer object data store. For atomic counter uniforms, the returned value will be its offset relative to the beginning of its active atomic counter buffer. For all other uniforms, -1 will be returned.\n\nIf *`pname`* is `GL_UNIFORM_ARRAY_STRIDE`, then an array identifying the stride between elements of each of the uniforms specified by the corresponding array of *`uniformIndices`* is returned. For uniforms in named uniform blocks and for uniforms declared as atomic counters, the stride is the difference, in basic machine units, of consecutive elements in an array, or zero for uniforms not declared as an array. For all other uniforms, a stride of -1 will be returned.\n\nIf *`pname`* is `GL_UNIFORM_MATRIX_STRIDE`, then an array identifying the stride between columns of a column-major matrix or rows of a row-major matrix, in basic machine units, of each of the uniforms specified by the corresponding array of *`uniformIndices`* is returned. The matrix stride of a uniform associated with the default uniform block is -1. Note that this information only makes sense for uniforms that are matrices. For uniforms that are not matrices, but are declared in a named uniform block, a matrix stride of zero is returned.\n\nIf *`pname`* is `GL_UNIFORM_IS_ROW_MAJOR`, then an array identifying whether each of the uniforms specified by the corresponding array of *`uniformIndices`* is a row-major matrix or not is returned. A value of one indicates a row-major matrix, and a value of zero indicates a column-major matrix, a matrix in the default uniform block, or a non-matrix.\n\nIf *`pname`* is `GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX`, then an array identifying the active atomic counter buffer index of each of the uniforms specified by the corresponding array of *`uniformIndices`* is returned. For uniforms other than atomic counters, the returned buffer index is -1. The returned indices may be passed to [glGetActiveAtomicCounterBufferiv](glgetactiveatomiccounterbufferiv.xhtml) to query the properties of the associated buffer, and not necessarily the binding point specified in the uniform declaration.\n\n## Notes\n\nThe double types, `GL_DOUBLE`, `GL_DOUBLE_VEC2`, `GL_DOUBLE_VEC3`, `GL_DOUBLE_VEC4`, `GL_DOUBLE_MAT2`, `GL_DOUBLE_MAT3`, `GL_DOUBLE_MAT4`, `GL_DOUBLE_MAT2x3`, `GL_DOUBLE_MAT2x4`, `GL_DOUBLE_MAT3x2`, `GL_DOUBLE_MAT3x4`, `GL_DOUBLE_MAT4x2`, and `GL_DOUBLE_MAT4x3` are only available if the GL version is 4.1 or higher.\n\n`GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX` is only accepted by *`pname`* if the GL version is 4.2 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_VALUE` is generated if *`uniformCount`* is greater than or equal to the value of `GL_ACTIVE_UNIFORMS` for *`program`*.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted token.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_UNIFORM_COMPONENTS`, `GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS`, `GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS`, `GL_MAX_GEOMETRY_UNIFORM_COMPONENTS`, `GL_MAX_FRAGMENT_UNIFORM_COMPONENTS`, or `GL_MAX_COMBINED_UNIFORM_COMPONENTS`.\n\n[glGetProgram](glgetprogram.xhtml) with argument `GL_ACTIVE_UNIFORMS` or `GL_ACTIVE_UNIFORM_MAX_LENGTH`.\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetActiveUniformsiv`     |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetUniform](glgetuniform.xhtml), [glGetActiveUniform](glgetactiveuniform.xhtml), [glGetUniformLocation](glgetuniformlocation.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glUniform](gluniform.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformsiv.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetActiveUniformsiv.xhtml)"
- name: glGetAttachedShaders
  id: glgetattachedshaders.xhtml
  summary: program Specifies the program object to be queried
  description: "## Name\n\nglGetAttachedShaders — Returns the handles of the shader objects attached to a program object\n\n## C Specification\n\n`void `**`glGetAttachedShaders`**`(` GLuint `program`, GLsizei `maxCount`, GLsizei \\*`count`, GLuint \\*`shaders``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to be queried.\n\n *`maxCount`*  \nSpecifies the size of the array for storing the returned object names.\n\n *`count`*  \nReturns the number of names actually returned in *`shaders`*.\n\n *`shaders`*  \nSpecifies an array that is used to return the names of attached shader objects.\n\n## Description\n\n`glGetAttachedShaders` returns the names of the shader objects attached to *`program`*. The names of shader objects that are attached to *`program`* will be returned in *`shaders.`* The actual number of shader names written into *`shaders`* is returned in *`count.`* If no shader objects are attached to *`program`*, *`count`* is set to 0. The maximum number of shader names that may be returned in *`shaders`* is specified by *`maxCount`*.\n\nIf the number of names actually returned is not required (for instance, if it has just been obtained by calling [glGetProgram](glgetprogram.xhtml)), a value of `NULL` may be passed for count. If no shader objects are attached to *`program`*, a value of 0 will be returned in *`count`*. The actual number of attached shaders can be obtained by calling [glGetProgram](glgetprogram.xhtml) with the value `GL_ATTACHED_SHADERS`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_VALUE` is generated if *`maxCount`* is less than 0.\n\n## Associated Gets\n\n[glGetProgram](glgetprogram.xhtml) with argument `GL_ATTACHED_SHADERS`\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetAttachedShaders`      |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glAttachShader](glattachshader.xhtml), [glDetachShader](gldetachshader.xhtml).\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetAttachedShaders.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetAttachedShaders.xhtml)"
- name: glGetAttribLocation
  id: glgetattriblocation.xhtml
  summary: program Specifies the program object to be queried
  description: "## Name\n\nglGetAttribLocation — Returns the location of an attribute variable\n\n## C Specification\n\n`GLint `**`glGetAttribLocation`**`(` GLuint `program`, const GLchar \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to be queried.\n\n *`name`*  \nPoints to a null terminated string containing the name of the attribute variable whose location is to be queried.\n\n## Description\n\n`glGetAttribLocation` queries the previously linked program object specified by *`program`* for the attribute variable specified by *`name`* and returns the index of the generic vertex attribute that is bound to that attribute variable. If *`name`* is a matrix attribute variable, the index of the first column of the matrix is returned. If the named attribute variable is not an active attribute in the specified program object or if *`name`* starts with the reserved prefix \"gl\\_\", a value of -1 is returned.\n\nThe association between an attribute variable name and a generic attribute index can be specified at any time by calling [glBindAttribLocation](glbindattriblocation.xhtml). Attribute bindings do not go into effect until [glLinkProgram](gllinkprogram.xhtml) is called. After a program object has been linked successfully, the index values for attribute variables remain fixed until the next link command occurs. The attribute values can only be queried after a link if the link was successful. `glGetAttribLocation` returns the binding that actually went into effect the last time [glLinkProgram](gllinkprogram.xhtml) was called for the specified program object. Attribute bindings that have been specified since the last link operation are not returned by `glGetAttribLocation`.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_OPERATION` is generated if *`program`* has not been successfully linked.\n\n## Associated Gets\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with argument *`program`* and the index of an active attribute\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetAttribLocation`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glVertexAttrib](glvertexattrib.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetAttribLocation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetAttribLocation.xhtml)"
- name: glGetBooleani_v
  id: glget.xhtml#glGetBooleani_v
  summary: null
  belongs_to: glGet
  description: '`void `**`glGetBooleani_v`**`(` GLenum `target`, GLuint `index`, GLboolean \* `data``)`;'
- name: glGetBooleanv
  id: glget.xhtml#glGetBooleanv
  summary: null
  belongs_to: glGet
  description: '`void `**`glGetBooleanv`**`(` GLenum `pname`, GLboolean \* `data``)`;'
- name: glGetBufferParameter
  id: glgetbufferparameter.xhtml
  summary: target Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v
  description: "## Name\n\nglGetBufferParameter — return parameters of a buffer object\n\n## C Specification\n\n`void `**`glGetBufferParameteriv`**`(` GLenum `target`, GLenum `value`, GLint \\* `data``)`;\n\n`void `**`glGetBufferParameteri64v`**`(` GLenum `target`, GLenum `value`, GLint64 \\* `data``)`;\n\n`void `**`glGetNamedBufferParameteriv`**`(` GLuint `buffer`, GLenum `pname`, GLint \\*`params``)`;\n\n`void `**`glGetNamedBufferParameteri64v`**`(` GLuint `buffer`, GLenum `pname`, GLint64 \\*`params``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glGetBufferParameteriv` and `glGetBufferParameteri64v`. Must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glGetNamedBufferParameteriv` and `glGetNamedBufferParameteri64v`.\n\n *`value`*  \nSpecifies the name of the buffer object parameter to query.\n\n *`data`*  \nReturns the requested parameter.\n\n## Description\n\nThese functions return in *`data`* a selected parameter of the specified buffer object.\n\n*`pname`* names a specific buffer object parameter, as follows:\n\n `GL_BUFFER_ACCESS`  \n*`params`* returns the access policy set while mapping the buffer object (the value of the *`access`* parameter enum passed to `glMapBuffer`). If the buffer was mapped with `glMapBufferRange`, the access policy is determined by translating the bits in that *`access`* parameter to one of the supported enums for `glMapBuffer` as described in the OpenGL Specification.\n\n `GL_BUFFER_ACCESS_FLAGS`  \n*`params`* returns the access policy set while mapping the buffer object (the value of the *`access`* parameter bitfield passed to `glMapBufferRange`). If the buffer was mapped with `glMapBuffer`, the access policy is determined by translating the enums in that *`access`* parameter to the corresponding bits for `glMapBufferRange` as described in the OpenGL Specification. The initial value is zero.\n\n `GL_BUFFER_IMMUTABLE_STORAGE`  \n*`params`* returns a boolean flag indicating whether the buffer object is immutable. The initial value is `GL_FALSE`.\n\n `GL_BUFFER_MAPPED`  \n*`params`* returns a flag indicating whether the buffer object is currently mapped. The initial value is `GL_FALSE`.\n\n `GL_BUFFER_MAP_LENGTH`  \n*`params`* returns the length of the mapping into the buffer object established with `glMapBuffer*`. The `i64v` versions of these queries should be used for this parameter. The initial value is zero.\n\n `GL_BUFFER_MAP_OFFSET`  \n*`params`* returns the offset of the mapping into the buffer object established with `glMapBuffer*`. The `i64v` versions of these queries should be used for this parameter. The initial value is zero.\n\n `GL_BUFFER_SIZE`  \n*`params`* returns the size of the buffer object, measured in bytes. The initial value is 0.\n\n `GL_BUFFER_STORAGE_FLAGS`  \n*`params`* returns a bitfield indicating the storage flags for the buffer object. If the buffer object is immutable, the value returned will be that specified when the data store was established with `glBufferStorage`. If the data store was established with `glBufferData`, the value will be `GL_MAP_READ_BIT` \\| `GL_MAP_WRITE_BIT` \\| `GL_DYNAMIC_STORAGE_BIT` \\| `GL_MAP_WRITE_BIT`. The initial value is zero.\n\n `GL_BUFFER_USAGE`  \n*`params`* returns the buffer object's usage pattern. The initial value is `GL_STATIC_DRAW`.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`data`*.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetBufferParameter*` if *`target`* is not one of the accepted buffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetBufferParameter*` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedBufferParameter*` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the buffer object parameter names described above.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetBufferParameteri64v`      |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetBufferParameteriv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetNamedBufferParameteri64v` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetNamedBufferParameteriv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glGetBufferPointerv](glgetbufferpointerv.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferParameter.xhtml)"
- name: glGetBufferParameteri64v
  id: glgetbufferparameter.xhtml#glGetBufferParameteri64v
  summary: null
  belongs_to: glGetBufferParameter
  description: '`void `**`glGetBufferParameteri64v`**`(` GLenum `target`, GLenum `value`, GLint64 \* `data``)`;'
- name: glGetBufferParameteriv
  id: glgetbufferparameter.xhtml#glGetBufferParameteriv
  summary: null
  belongs_to: glGetBufferParameter
  description: '`void `**`glGetBufferParameteriv`**`(` GLenum `target`, GLenum `value`, GLint \* `data``)`;'
- name: glGetBufferPointerv
  id: glgetbufferpointerv.xhtml
  summary: buffer Specifies the name of the buffer object for glGetNamedBufferPointerv
  description: "## Name\n\nglGetBufferPointerv, glGetNamedBufferPointerv — return the pointer to a mapped buffer object's data store\n\n## C Specification\n\n`void `**`glGetBufferPointerv`**`(` GLenum `target`, GLenum `pname`, void \\*\\* `params``)`;\n\n`void `**`glGetNamedBufferPointerv`**`(` GLuint `buffer`, GLenum `pname`, void \\*\\*`params``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glGetBufferPointerv`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glGetNamedBufferPointerv`.\n\n *`pname`*  \nSpecifies the name of the pointer to be returned. Must be `GL_BUFFER_MAP_POINTER`.\n\n *`params`*  \nReturns the pointer value specified by *`pname`*.\n\n## Description\n\n`glGetBufferPointerv` and `glGetNamedBufferPointerv` return the buffer pointer *`pname`*, which must be `GL_BUFFER_MAP_POINTER`. The single buffer map pointer is returned in *`params`*. A `NULL` pointer is returned if the buffer object's data store is not currently mapped; or if the requesting context did not map the buffer object's data store, and the implementation is unable to support mappings on multiple clients.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\nThe initial value for the pointer is `NULL`.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if by `glGetBufferPointerv` if *`target`* is not one of the accepted buffer targets, or if *`pname`* is not `GL_BUFFER_MAP_POINTER`.\n\n`GL_INVALID_OPERATION` is generated by `glGetBufferPointerv` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedBufferPointerv` if *`buffer`* is not the name of an existing buffer object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetBufferPointerv`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetNamedBufferPointerv`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glMapBuffer](glmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferPointerv.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferPointerv.xhtml)"
- name: glGetBufferSubData
  id: glgetbuffersubdata.xhtml
  summary: buffer Specifies the name of the buffer object for glGetNamedBufferSubData
  description: "## Name\n\nglGetBufferSubData, glGetNamedBufferSubData — returns a subset of a buffer object's data store\n\n## C Specification\n\n`void `**`glGetBufferSubData`**`(` GLenum `target`, GLintptr `offset`, GLsizeiptr `size`, void \\* `data``)`;\n\n`void `**`glGetNamedBufferSubData`**`(` GLuint `buffer`, GLintptr `offset`, GLsizeiptr `size`, void \\*`data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glGetBufferSubData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glGetNamedBufferSubData`.\n\n *`offset`*  \nSpecifies the offset into the buffer object's data store from which data will be returned, measured in bytes.\n\n *`size`*  \nSpecifies the size in bytes of the data store region being returned.\n\n *`data`*  \nSpecifies a pointer to the location where buffer object data is returned.\n\n## Description\n\n`glGetBufferSubData` and `glGetNamedBufferSubData` return some or all of the data contents of the data store of the specified buffer object. Data starting at byte offset *`offset`* and extending for *`size`* bytes is copied from the buffer object's data store to the memory pointed to by *`data`*. An error is thrown if the buffer object is currently mapped, or if *`offset`* and *`size`* together define a range beyond the bounds of the buffer object's data store.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`data`*.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetBufferSubData` if *`target`* is not one of the generic buffer binding targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetBufferSubData` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedBufferSubData` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`size`* is negative, or if $offset + size$ is greater than the value of `GL_BUFFER_SIZE` for the buffer object.\n\n`GL_INVALID_OPERATION` is generated if the buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *`access`* flags.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetBufferSubData`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetNamedBufferSubData`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferSubData.xhtml)"
- name: glGetCompressedTexImage
  id: glgetcompressedteximage.xhtml
  summary: target Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions
  description: "## Name\n\nglGetCompressedTexImage — return a compressed texture image\n\n## C Specification\n\n`void `**`glGetCompressedTexImage`**`(` GLenum `target`, GLint `level`, void \\* `pixels``)`;\n\n`void `**`glGetnCompressedTexImage`**`(` GLenum `target`, GLint `level`, GLsizei `bufSize`, void \\*`pixels``)`;\n\n`void `**`glGetCompressedTextureImage`**`(` GLuint `texture`, GLint `level`, GLsizei `bufSize`, void \\*`pixels``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glGetCompressedTexImage` and `glGetnCompressedTexImage` functions. `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, and `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_TEXTURE_RECTANGLE` are accepted.\n\n *`texture`*  \nSpecifies the texture object name for `glGetCompressedTextureImage` function.\n\n *`level`*  \nSpecifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.\n\n *`bufSize`*  \nSpecifies the size of the buffer *`pixels`* for `glGetCompressedTextureImage` and `glGetnCompressedTexImage` functions.\n\n *`pixels`*  \nReturns the compressed texture image.\n\n## Description\n\n`glGetCompressedTexImage` and `glGetnCompressedTexImage` return the compressed texture image associated with *`target`* and *`lod`* into *`pixels`*. `glGetCompressedTextureImage` serves the same purpose, but instead of taking a texture target, it takes the ID of the texture object. *`pixels`* should be an array of *`bufSize`* bytes for `glGetnCompresedTexImage` and `glGetCompressedTextureImage` functions, and of `GL_TEXTURE_COMPRESSED_IMAGE_SIZE` bytes in case of `glGetCompressedTexImage`. If the actual data takes less space than *`bufSize`*, the remaining bytes will not be touched. *`target`* specifies the texture target, to which the texture the data the function should extract the data from is bound to. *`lod`* specifies the level-of-detail number of the desired image.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is requested, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\nTo minimize errors, first verify that the texture is compressed by calling [glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_COMPRESSED`. If the texture is compressed, you can determine the amount of memory required to store the compressed texture by calling [glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`. Finally, retrieve the internal format of the texture by calling [glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_INTERNAL_FORMAT`. To store the texture for later use, associate the internal format and size with the retrieved texture image. These data can be used by the respective texture or subtexture loading routine used for loading *`target`* textures.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glGetCompressedTextureImage` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than zero or greater than the maximum number of LODs permitted by the implementation.\n\n`GL_INVALID_OPERATION` is generated if `glGetCompressedTexImage`, `glGetnCompressedTexImage`, and `glGetCompressedTextureImage` is used to retrieve a texture that is in an uncompressed internal format.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target, the buffer storage was not initialized with `glBufferStorage` using `GL_MAP_PERSISTENT_BIT` flag, and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.\n\n## Associated Gets\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_INTERNAL_FORMAT`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_PACK_BUFFER_BINDING`\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetCompressedTexImage`     |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetCompressedTextureImage` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetnCompressedTexImage`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glReadPixels](glreadpixels.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetCompressedTexImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetCompressedTexImage.xhtml)"
- name: glGetCompressedTextureImage
  id: glgetcompressedteximage.xhtml#glGetCompressedTextureImage
  summary: Specifies the target to which the texture is bound for glGetCompressedTexImage and glGetnCompressedTexImage functions
  belongs_to: glGetCompressedTexImage
  description: "`void `**`glGetCompressedTextureImage`**`(` GLuint `texture`, GLint `level`, GLsizei `bufSize`, void \\*`pixels``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glGetCompressedTexImage` and `glGetnCompressedTexImage` functions. `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, and `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_TEXTURE_RECTANGLE` are accepted.\n\n*`texture`*\n\nSpecifies the texture object name for `glGetCompressedTextureImage` function.\n\n*`level`*\n\nSpecifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.\n\n*`bufSize`*\n\nSpecifies the size of the buffer *`pixels`* for `glGetCompressedTextureImage` and `glGetnCompressedTexImage` functions.\n\n*`pixels`*\n\nReturns the compressed texture image.\n\n## Description\n\n`glGetCompressedTexImage` and `glGetnCompressedTexImage` return the compressed texture image associated with *`target`* and *`lod`* into *`pixels`*. `glGetCompressedTextureImage` serves the same purpose, but instead of taking a texture target, it takes the ID of the texture object. *`pixels`* should be an array of *`bufSize`* bytes for `glGetnCompresedTexImage` and `glGetCompressedTextureImage` functions, and of `GL_TEXTURE_COMPRESSED_IMAGE_SIZE` bytes in case of `glGetCompressedTexImage`. If the actual data takes less space than *`bufSize`*, the remaining bytes will not be touched. *`target`* specifies the texture target, to which the texture the data the function should extract the data from is bound to. *`lod`* specifies the level-of-detail number of the desired image.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is requested, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\nTo minimize errors, first verify that the texture is compressed by calling [glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_COMPRESSED`. If the texture is compressed, you can determine the amount of memory required to store the compressed texture by calling [glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`. Finally, retrieve the internal format of the texture by calling [glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_INTERNAL_FORMAT`. To store the texture for later use, associate the internal format and size with the retrieved texture image. These data can be used by the respective texture or subtexture loading routine used for loading *`target`* textures.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glGetCompressedTextureImage` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than zero or greater than the maximum number of LODs permitted by the implementation.\n\n`GL_INVALID_OPERATION` is generated if `glGetCompressedTexImage`, `glGetnCompressedTexImage`, and `glGetCompressedTextureImage` is used to retrieve a texture that is in an uncompressed internal format.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target, the buffer storage was not initialized with `glBufferStorage` using `GL_MAP_PERSISTENT_BIT` flag, and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.\n\n## Associated Gets\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_COMPRESSED`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_INTERNAL_FORMAT`\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_PACK_BUFFER_BINDING`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetCompressedTexImage`     |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetCompressedTextureImage` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetnCompressedTexImage`    |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glReadPixels](glreadpixels.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetCompressedTexImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetCompressedTexImage.xhtml)"
- name: glGetCompressedTextureSubImage
  id: glgetcompressedtexturesubimage.xhtml
  summary: texture Specifies the name of the source texture object
  description: "## Name\n\nglGetCompressedTextureSubImage — retrieve a sub-region of a compressed texture image from a compressed texture object\n\n## C Specification\n\n`void `**`glGetCompressedTextureSubImage`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLsizei `bufSize`, void \\*`pixels``)`;\n\n## Parameters\n\n *`texture`*  \nSpecifies the name of the source texture object. Must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_RECTANGLE`. In specific, buffer and multisample textures are not permitted.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`yoffset`*  \nSpecifies a texel offset in the y direction within the texture array.\n\n *`zoffset`*  \nSpecifies a texel offset in the z direction within the texture array.\n\n *`width`*  \nSpecifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the *`offset`* is zero and the size equals the texture image size.\n\n *`height`*  \nSpecifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the *`offset`* is zero and the size equals the texture image size.\n\n *`depth`*  \nSpecifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the *`offset`* is zero and the size equals the texture image size.\n\n *`bufSize`*  \nSpecifies the size of the buffer to receive the retrieved pixel data.\n\n *`pixels`*  \nReturns the texture subimage. Should be a pointer to an array of the type specified by type.\n\n## Description\n\n`glGetCompressedTextureSubImage` can be used to obtain a sub-region of a compressed texture image instead of the whole image, as long as the compressed data are arranged into fixed-size blocks of texels. *`texture`* is the name of the texture object, and must not be a buffer or multisample texture. The effective *`target`* is the value of `GL_TEXTURE_TARGET` for texture. *`level`* and *`pixels`* have the same meaning as the corresponding arguments of `glCompressedTexSubImage3D`. *`bufSize`* indicates the size of the buffer to receive the retrieved pixel data.\n\nFor cube map textures, the behavior is as though `glGetCompressedTexImage` were called once for each requested face (selected by *`zoffset`* and *`depth`*, as described below) with target corresponding to the requested texture cube map face as indicated by the table presented below. *`pixels`* is offset appropriately for each successive image.\n\n|              |                                  |\n|--------------|----------------------------------|\n| Layer number | Cube Map Face                    |\n| 0            | `GL_TEXTURE_CUBE_MAP_POSITIVE_X` |\n| 1            | `GL_TEXTURE_CUBE_MAP_NEGATIVE_X` |\n| 2            | `GL_TEXTURE_CUBE_MAP_POSITIVE_Y` |\n| 3            | `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y` |\n| 4            | `GL_TEXTURE_CUBE_MAP_POSITIVE_Z` |\n| 5            | `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z` |\n\n*`xoffset`*, *`yoffset`* and *`zoffset`* indicate the position of the subregion to return. *`width`*, *`height`* and *`depth`* indicate the size of the region to return. These arguments have the same meaning as for `glCompressedTexSubImage3D`, though there are extra restrictions, described in the errors section below.\n\nThe mapping between the *`xoffset`*, *`yoffset`*, *`zoffset`*, *`width`*, *`height`* and *`depth`* parameters and the faces, layers, and layer-faces for cube map, array, and cube map array textures is the same as for glGetTextureSubImage.\n\nThe *`xoffset`*, *`yoffset`*, *`zoffset`* offsets and *`width`*, *`height`* and *`depth`* sizes must be multiples of the values of `GL_PACK_COMPRESSED_BLOCK_WIDTH`, `GL_PACK_COMPRESSED_BLOCK_HEIGHT`, and `GL_PACK_COMPRESSED_BLOCK_DEPTH` respectively, unless *`offset`* is zero and the corresponding *`size`* is the same as the texture size in that dimension.\n\nPixel storage modes are treated as for `glGetCompressedTexSubImage`. The texel at (*`xoffset`*, *`yoffset`*, *`zoffset`*) will be stored at the location indicated by *`pixels`* and the current pixel packing parameters.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated if *`texture`* is the name of a buffer or multisample texture.\n\n`GL_INVALID_OPERATION` error is generated if the buffer size required to store the requested data is greater than *`bufSize`*.\n\n`GL_INVALID_OPERATION` error is generated if the texture compression format is not based on fixed-size blocks.\n\n`GL_INVALID_VALUE` error is generated if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`xoffset`*, *`yoffset`* or *`zoffset`* are negative.\n\n`GL_INVALID_VALUE` is generated if *`xoffset`* + *`width`* is greater than the texture's width, *`yoffset`* + *`height`* is greater than the texture's height, or *`zoffset`* + *`depth`* is greater than the texture's depth.\n\n`GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D` and either *`yoffset`* is not zero, or *`height`* is not one.\n\n`GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D` or `GL_TEXTURE_RECTANGLE` and either *`zoffset`* is not zero, or *`depth`* is not one.\n\n`GL_INVALID_VALUE` error is generated if *`xoffset`*, *`yoffset`* or *`zoffset`* is not a multiple of the compressed block width, height or depth respectively.\n\n`GL_INVALID_VALUE` error is generated if *`width`*, *`height`* or *`depth`* is not a multiple of the compressed block width, height or depth respectively, unless the *`offset`* is zero and the *`size`* equals the texture image size.\n\n## Version Support\n\n|                                  | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:---------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**      |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetCompressedTextureSubImage` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glGetCompressedTexImage](glgetcompressedteximage.xhtml), `glGetCompressedTextureImage`, [glReadPixels](glreadpixels.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetCompressedTextureSubImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetCompressedTextureSubImage.xhtml)"
- name: glGetDebugMessageLog
  id: glgetdebugmessagelog.xhtml
  summary: count The number of debug messages to retrieve from the log
  description: "## Name\n\nglGetDebugMessageLog — retrieve messages from the debug message log\n\n## C Specification\n\n`GLuint `**`glGetDebugMessageLog`**`(` GLuint `count`, GLsizei `bufSize`, GLenum \\*`sources`, GLenum \\*`types`, GLuint \\*`ids`, GLenum \\*`severities`, GLsizei \\*`lengths`, GLchar \\*`messageLog``)`;\n\n## Parameters\n\n *`count`*  \nThe number of debug messages to retrieve from the log.\n\n *`bufSize`*  \nThe size of the buffer whose address is given by *`messageLog`*.\n\n *`sources`*  \nThe address of an array of variables to receive the sources of the retrieved messages.\n\n *`types`*  \nThe address of an array of variables to receive the types of the retrieved messages.\n\n *`ids`*  \nThe address of an array of unsigned integers to receive the ids of the retrieved messages.\n\n *`severities`*  \nThe address of an array of variables to receive the severites of the retrieved messages.\n\n *`lengths`*  \nThe address of an array of variables to receive the lengths of the received messages.\n\n *`messageLog`*  \nThe address of an array of characters that will receive the messages.\n\n## Description\n\n`glGetDebugMessageLog` retrieves messages from the debug message log. A maximum of *`count`* messages are retrieved from the log. If *`sources`* is not NULL then the source of each message is written into up to *`count`* elements of the array. If *`types`* is not NULL then the type of each message is written into up to *`count`* elements of the array. If *`id`* is not NULL then the identifier of each message is written into up to *`count`* elements of the array. If *`severities`* is not NULL then the severity of each message is written into up to *`count`* elements of the array. If *`lengths`* is not NULL then the length of each message is written into up to *`count`* elements of the array.\n\n*`messageLog`* specifies the address of a character array into which the debug messages will be written. Each message will be concatenated onto the array starting at the first element of *`messageLog`*. *`bufSize`* specifies the size of the array *`messageLog`*. If a message will not fit into the remaining space in *`messageLog`* then the function terminates and returns the number of messages written so far, which may be zero.\n\nIf `glGetDebugMessageLog` returns zero then no messages are present in the debug log, or there was not enough space in *`messageLog`* to retrieve the first message in the queue. If *`messageLog`* is NULL then no messages are written and the value of *`bufSize`* is ignored.\n\n## Notes\n\nAlthough debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug context may produce no messages at all.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`count`* or *`bufSize`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DEBUG_LOGGED_MESSAGES`\n\n[glGet](glget.xhtml) with argument `GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH`\n\n[glGet](glget.xhtml) with argument `GL_MAX_DEBUG_MESSAGE_LENGTH`\n\n[glGet](glget.xhtml) with argument `GL_MAX_DEBUG_LOGGED_MESSAGES`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetDebugMessageLog`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDebugMessageInsert](gldebugmessageinsert.xhtml), [glDebugMessageCallback](gldebugmessagecallback.xhtml), [glDebugMessageControl](gldebugmessagecontrol.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetDebugMessageLog.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetDebugMessageLog.xhtml)"
- name: glGetDoublei_v
  id: glget.xhtml#glGetDoublei_v
  summary: null
  belongs_to: glGet
  description: '`void `**`glGetDoublei_v`**`(` GLenum `target`, GLuint `index`, GLdouble \* `data``)`;'
- name: glGetDoublev
  id: glget.xhtml#glGetDoublev
  summary: null
  belongs_to: glGet
  description: '`void `**`glGetDoublev`**`(` GLenum `pname`, GLdouble \* `data``)`;'
- name: glGetError
  id: glgeterror.xhtml
  summary: glGetError returns the value of the error flag
  description: "## Name\n\nglGetError — return error information\n\n## C Specification\n\n`GLenum `**`glGetError`**`(` `void``)`;\n\n## Description\n\n`glGetError` returns the value of the error flag. Each detectable error is assigned a numeric code and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until `glGetError` is called, the error code is returned, and the flag is reset to `GL_NO_ERROR`. If a call to `glGetError` returns `GL_NO_ERROR`, there has been no detectable error since the last call to `glGetError`, or since the GL was initialized.\n\nTo allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to `GL_NO_ERROR` when `glGetError` is called. If more than one flag has recorded an error, `glGetError` returns and clears an arbitrary error flag value. Thus, `glGetError` should always be called in a loop, until it returns `GL_NO_ERROR`, if all error flags are to be reset.\n\nInitially, all error flags are set to `GL_NO_ERROR`.\n\nThe following errors are currently defined:\n\n `GL_NO_ERROR`  \nNo error has been recorded. The value of this symbolic constant is guaranteed to be 0.\n\n `GL_INVALID_ENUM`  \nAn unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.\n\n `GL_INVALID_VALUE`  \nA numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.\n\n `GL_INVALID_OPERATION`  \nThe specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.\n\n `GL_INVALID_FRAMEBUFFER_OPERATION`  \nThe framebuffer object is not complete. The offending command is ignored and has no other side effect than to set the error flag.\n\n `GL_OUT_OF_MEMORY`  \nThere is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.\n\n `GL_STACK_UNDERFLOW`  \nAn attempt has been made to perform an operation that would cause an internal stack to underflow.\n\n `GL_STACK_OVERFLOW`  \nAn attempt has been made to perform an operation that would cause an internal stack to overflow.\n\nWhen an error flag is set, results of a GL operation are undefined only if `GL_OUT_OF_MEMORY` has occurred. In all other cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents. If the generating command returns a value, it returns 0. If `glGetError` itself generates an error, it returns 0.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetError`                |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetError.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetError.xhtml)"
- name: glGetFloati_v
  id: glget.xhtml#glGetFloati_v
  summary: null
  belongs_to: glGet
  description: '`void `**`glGetFloati_v`**`(` GLenum `target`, GLuint `index`, GLfloat \* `data``)`;'
- name: glGetFloatv
  id: glget.xhtml#glGetFloatv
  summary: null
  belongs_to: glGet
  description: '`void `**`glGetFloatv`**`(` GLenum `pname`, GLfloat \* `data``)`;'
- name: glGetFragDataIndex
  id: glgetfragdataindex.xhtml
  summary: glGetFragDataIndex returns the index of the fragment color to which the variable name was bound when the program object program was last linked
  description: "## Name\n\nglGetFragDataIndex — query the bindings of color indices to user-defined varying out variables\n\n## C Specification\n\n`GLint `**`glGetFragDataIndex`**`(` GLuint `program`, const char \\* `name``)`;\n\n## Parameters\n\n *`program`*  \nThe name of the program containing varying out variable whose binding to query\n\n *`name`*  \nThe name of the user-defined varying out variable whose index to query\n\n## Description\n\n`glGetFragDataIndex` returns the index of the fragment color to which the variable *`name`* was bound when the program object *`program`* was last linked. If *`name`* is not a varying out variable of *`program`*, or if an error occurs, -1 will be returned.\n\n## Notes\n\n`glGetFragDataIndex` is available only if the GL version is 3.3 or greater.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of a program object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetFragDataIndex`        |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateProgram](glcreateprogram.xhtml), [glBindFragDataLocation](glbindfragdatalocation.xhtml), [glBindFragDataLocationIndexed](glbindfragdatalocationindexed.xhtml), [glGetFragDataLocation](glgetfragdatalocation.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFragDataIndex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFragDataIndex.xhtml)"
- name: glGetFragDataLocation
  id: glgetfragdatalocation.xhtml
  summary: glGetFragDataLocation retrieves the assigned color number binding for the user-defined varying out variable name for program program
  description: "## Name\n\nglGetFragDataLocation — query the bindings of color numbers to user-defined varying out variables\n\n## C Specification\n\n`GLint `**`glGetFragDataLocation`**`(` GLuint `program`, const char \\* `name``)`;\n\n## Parameters\n\n *`program`*  \nThe name of the program containing varying out variable whose binding to query\n\n *`name`*  \nThe name of the user-defined varying out variable whose binding to query\n\n## Description\n\n`glGetFragDataLocation` retrieves the assigned color number binding for the user-defined varying out variable *`name`* for program *`program`*. *`program`* must have previously been linked. *`name`* must be a null-terminated string. If *`name`* is not the name of an active user-defined varying out fragment shader variable within *`program`*, -1 will be returned.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of a program object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetFragDataLocation`     |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateProgram](glcreateprogram.xhtml), [glBindFragDataLocation](glbindfragdatalocation.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFragDataLocation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFragDataLocation.xhtml)"
- name: glGetFramebufferAttachmentParameter
  id: glgetframebufferattachmentparameter.xhtml
  summary: target Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv
  description: "## Name\n\nglGetFramebufferAttachmentParameteriv, glGetNamedFramebufferAttachmentParameteriv — retrieve information about attachments of a framebuffer object\n\n## C Specification\n\n`void `**`glGetFramebufferAttachmentParameteriv`**`(` GLenum `target`, GLenum `attachment`, GLenum `pname`, GLint \\*`params``)`;\n\n`void `**`glGetNamedFramebufferAttachmentParameteriv`**`(` GLuint `framebuffer`, GLenum `attachment`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the framebuffer object is bound for `glGetFramebufferAttachmentParameteriv`.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glGetNamedFramebufferAttachmentParameteriv`.\n\n *`attachment`*  \nSpecifies the attachment of the framebuffer object to query.\n\n *`pname`*  \nSpecifies the parameter of *`attachment`* to query.\n\n *`params`*  \nReturns the value of parameter *`pname`* for *`attachment`*.\n\n## Description\n\n`glGetFramebufferAttachmentParameteriv` and `glGetNamedFramebufferAttachmentParameteriv` return parameters of attachments of a specified framebuffer object.\n\nFor `glGetFramebufferAttachmentParameteriv`, the framebuffer object is that bound to *`target`*, which must be one of `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Buffers of default framebuffers may also be queried if bound to *`target`*.\n\nFor `glGetNamedFramebufferAttachmentParameteriv`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, the default draw framebuffer is queried.\n\nIf the specified framebuffer is a framebuffer object, *`attachment`* must be one of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or `GL_COLOR_ATTACHMENT`*i*, where *i* is between zero and the value of `GL_MAX_COLOR_ATTACHMENTS` minus one.\n\nIf the specified framebuffer is a default framebuffer, *`target`*, *`attachment`* must be one of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_DEPTH` or `GL_STENCIL`, identifying the corresponding buffer.\n\nIf *`attachment`* is `GL_DEPTH_STENCIL_ATTACHMENT`, the same object must be bound to both the depth and stencil attachment points of the framebuffer object, and information about that object is returned.\n\nUpon successful return, if *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`, then *`params`* will contain one of `GL_NONE`, `GL_FRAMEBUFFER_DEFAULT`, `GL_TEXTURE`, or `GL_RENDERBUFFER`, identifying the type of object which contains the attached image. Other values accepted for *`pname`* depend on the type of object, as described below.\n\nIf the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE`, then either no framebuffer is bound to *`target`*; or a default framebuffer is queried, *`attachment`* is `GL_DEPTH` or `GL_STENCIL`, and the number of depth or stencil bits, respectively, is zero. In this case querying *`pname`* `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` will return zero, and all other queries will generate an error.\n\nIf the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is not `GL_NONE`, these queries apply to all other framebuffer types:\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE` or `GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE`, then *`params`* will contain the number of bits in the corresponding red, green, blue, alpha, depth, or stencil component of the specified attachment. If the requested component is not present in the attachment, or if no data storage or texture image has been specified for the attachment, then *`params`* will contain zero.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE`, then *`params`* will contain the format of components of the specified attachment, one of `GL_FLOAT`, `GL_INT`, `GL_UNSIGNED_INT`, `GL_SIGNED_NORMALIZED`, or `GL_UNSIGNED_NORMALIZED` for floating-point, signed integer, unsigned integer, signed normalized fixed-point, or unsigned normalized fixed-point components respectively. Only color buffers may have integer components. If no data storage or texture image has been specified for the attachment, then *`params`* will contain `GL_NONE`. This query cannot be performed for a combined depth+stencil attachment, since it does not have a single format.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING`, then *`params`* will contain the encoding of components of the specified attachment, one of `GL_LINEAR` or `GL_SRGB` for linear or sRGB-encoded components, respectively. Only color buffer components may be sRGB-encoded; such components are treated as described in the OpenGL Specification. For a default framebuffer, color encoding is determined by the implementation. For framebuffer objects, components are sRGB-encoded if the internal format of a color attachment is one of the color-renderable SRGB formats. If the attachment is not a color attachment, or if no data storage or texture image has been specified for the attachment, then *`params`* will contain `GL_LINEAR`.\n\nIf the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_RENDERBUFFER`, then\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`, *`params`* will contain the name of the renderbuffer object which contains the attached image.\n\nIf the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_TEXTURE`, then\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`, then *`params`* will contain the name of the texture object which contains the attached image.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL`, then *`params`* will contain the mipmap level of the texture object which contains the attached image.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE` and the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is the name of a cube map texture object, then *`params`* will contain the cube map face of the cubemap texture object which contains the attached image. Otherwise *`params`* will contain zero.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_LAYERED`, then *`params`* will contain `GL_TRUE` if an entire level of a three-dimensional texture, cube map texture, or one-or two-dimensional array texture is attached. Otherwise, *`params`* will contain `GL_FALSE`.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER`; the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is the name of a three-dimensional, or a one- or two-dimensional array texture; and the value of `GL_FRAMEBUFFER_ATTACHMENT_LAYERED` is `GL_FALSE`, then *`params`* will contain the texture layer which contains the attached image. Otherwise *`params`* will contain zero.\n\n## Notes\n\nThe `GL_FRAMEBUFFER_ATTACHMENT_LAYERED` query is supported only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetFramebufferAttachmentParameteriv` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedFramebufferAttachmentParameteriv` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not valid for the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`, as described above.\n\n`GL_INVALID_OPERATION` is generated if *`attachment`* is not one of the accepted framebuffer attachment points, as described above.\n\n`GL_INVALID_OPERATION` is generated if the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` and *`pname`* is not `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` or `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`.\n\n`GL_INVALID_OPERATION` is generated if *`attachment`* is `GL_DEPTH_STENCIL_ATTACHMENT` and different objects are bound to the depth and stencil attachment points of *`target`*.\n\n`GL_INVALID_OPERATION` is generated if *`attachment`* is `GL_DEPTH_STENCIL_ATTACHMENT` and *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE`.\n\n## Version Support\n\n|                                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:---------------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**                  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetFramebufferAttachmentParameteriv`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetNamedFramebufferAttachmentParameteriv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml) [glGetFramebufferParameter](glgetframebufferparameter.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFramebufferAttachmentParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFramebufferAttachmentParameter.xhtml)"
- name: glGetFramebufferAttachmentParameteriv
  id: glgetframebufferattachmentparameter.xhtml#glGetFramebufferAttachmentParameteriv
  summary: null
  belongs_to: glGetFramebufferAttachmentParameter
  description: '`void `**`glGetFramebufferAttachmentParameteriv`**`(` GLenum `target`, GLenum `attachment`, GLenum `pname`, GLint \*`params``)`;'
- name: glGetFramebufferParameter
  id: glgetframebufferparameter.xhtml
  summary: target Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv
  description: "## Name\n\nglGetFramebufferParameteriv, glGetNamedFramebufferParameteriv — query a named parameter of a framebuffer object\n\n## C Specification\n\n`void `**`glGetFramebufferParameteriv`**`(` GLenum `target`, GLenum `pname`, GLint \\*`params``)`;\n\n`void `**`glGetNamedFramebufferParameteriv`**`(` GLuint `framebuffer`, GLenum `pname`, GLint \\*`param``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the framebuffer object is bound for `glGetFramebufferParameteriv`.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glGetNamedFramebufferParameteriv`.\n\n *`pname`*  \nSpecifies the parameter of the framebuffer object to query.\n\n *`params`*  \nReturns the value of parameter *`pname`* for the framebuffer object.\n\n## Description\n\n`glGetFramebufferParameteriv` and `glGetNamedFramebufferParameteriv` query parameters of a specified framebuffer object.\n\nFor `glGetFramebufferParameteriv`, the framebuffer object is that bound to *`target`*, which must be one of `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be queried if bound to *`target`*.\n\nFor `glGetNamedFramebufferParameteriv`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, the default draw framebuffer is queried.\n\nUpon successful return, *`param`* will contain the value of the framebuffer parameter specified by *`pname`*, as described below.\n\nThe following parameters can only be queried for framebuffer objects:\n\n `GL_FRAMEBUFFER_DEFAULT_WIDTH`  \n*`params`* returns the value of `GL_FRAMEBUFFER_DEFAULT_WIDTH` for the framebuffer object.\n\n `GL_FRAMEBUFFER_DEFAULT_HEIGHT`  \n*`params`* returns the value of `GL_FRAMEBUFFER_DEFAULT_HEIGHT` for the framebuffer object.\n\n `GL_FRAMEBUFFER_DEFAULT_LAYERS`  \n*`params`* returns the value of `GL_FRAMEBUFFER_DEFAULT_LAYERS` for the framebuffer object.\n\n `GL_FRAMEBUFFER_DEFAULT_SAMPLES`  \n*`params`* returns the value of `GL_FRAMEBUFFER_DEFAULT_SAMPLES` for the framebuffer object.\n\n `GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`  \n*`params`* returns the boolean value of `GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`.\n\nThe following parameters can be queried for both default framebuffers and framebuffer objects:\n\n `GL_DOUBLEBUFFER`  \n*`param`* returns a boolean value indicating whether double buffering is supported for the framebuffer object.\n\n `GL_IMPLEMENTATION_COLOR_READ_FORMAT`  \n*`param`* returns a GLenum value indicating the preferred pixel data format for the framebuffer object. See [glReadPixels](glreadpixels.xhtml).\n\n `GL_IMPLEMENTATION_COLOR_READ_TYPE`  \n*`param`* returns a GLenum value indicating the implementation's preferred pixel data type for the framebuffer object. See [glReadPixels](glreadpixels.xhtml).\n\n `GL_SAMPLES`  \n*`param`* returns an integer value indicating the coverage mask size for the framebuffer object. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n `GL_SAMPLE_BUFFERS`  \n*`param`* returns an integer value indicating the number of sample buffers associated with the framebuffer object. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n `GL_STEREO`  \n*`param`* returns a boolean value indicating whether stereo buffers (left and right) are supported for the framebuffer object.\n\n## Notes\n\nQueries of default framebuffers are supported only if the GL version is 4.5 or higher. Otherwise, an `GL_INVALID_OPERATION` error is generated.\n\nQueries of the framebuffer-dependent parameters `GL_DOUBLEBUFFER`, `GL_IMPLEMENTATION_COLOR_READ_FORMAT`, `GL_IMPLEMENTATION_COLOR_READ_TYPE`, `GL_SAMPLES`, `GL_SAMPLE_BUFFERS` and `GL_STEREO` are supported only if the GL version is 4.5 or higher.\n\nThe framebuffer-dependent state `GL_SAMPLE_POSITION` cannot be queried with these commands.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetFramebufferParameteriv` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedFramebufferAttachmentParameteriv` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted parameter names.\n\n`GL_INVALID_OPERATION` is generated if a default framebuffer is queried, and *`pname`* is not one of `GL_DOUBLEBUFFER`, `GL_IMPLEMENTATION_COLOR_READ_FORMAT`, `GL_IMPLEMENTATION_COLOR_READ_TYPE`, `GL_SAMPLES`, `GL_SAMPLE_BUFFERS` or `GL_STEREO`.\n\n## Associated Gets\n\n[glGetFramebufferAttachmentParameter](glgetframebufferattachmentparameter.xhtml)\n\n## Version Support\n\n|                                    | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**        |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetFramebufferParameteriv`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glGetNamedFramebufferParameteriv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glFramebufferParameteri](glframebufferparameteri.xhtml), [glGetFramebufferAttachmentParameter](glgetframebufferattachmentparameter.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFramebufferParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFramebufferParameter.xhtml)"
- name: glGetFramebufferParameteriv
  id: glgetframebufferparameter.xhtml#glGetFramebufferParameteriv
  summary: null
  belongs_to: glGetFramebufferParameter
  description: '`void `**`glGetFramebufferParameteriv`**`(` GLenum `target`, GLenum `pname`, GLint \*`params``)`;'
- name: glGetGraphicsResetStatus
  id: glgetgraphicsresetstatus.xhtml
  summary: Certain events can result in a reset of the GL context
  description: "## Name\n\nglGetGraphicsResetStatus — check if the rendering context has not been lost due to software or hardware issues\n\n## C Specification\n\n`GLenum `**`glGetGraphicsResetStatus`**`(` `void``)`;\n\n## Description\n\nCertain events can result in a reset of the GL context. Such a reset causes all context state to be lost and requires the application to recreate all objects in the affected context.\n\n`glGetGraphicsResetStatus` can return one of the following constants:\n\n `GL_NO_ERROR`  \nIndicates that the GL context has not been in a reset state since the last call.\n\n `GL_GUILTY_CONTEXT_RESET`  \nIndicates that a reset has been detected that is attributable to the current GL context.\n\n `GL_INNOCENT_CONTEXT_RESET`  \nIndicates a reset has been detected that is not attributable to the current GL context.\n\n `GL_UNKNOWN_CONTEXT_RESET`  \nIndicates a detected graphics reset whose cause is unknown.\n\nIf a reset status other than `GL_NO_ERROR` is returned and subsequent calls return `GL_NO_ERROR`, the context reset was encountered and completed. If a reset status is repeatedly returned, the context may be in the process of resetting.\n\nReset notification behavior is determined at context creation time, and may be queried by calling `GetIntegerv` with the symbolic constant `GL_RESET_NOTIFICATION_STRATEGY`.\n\nIf the reset notification behavior is `GL_NO_RESET_NOTIFICATION`, then the implementation will never deliver notification of reset events, and `glGetGraphicsResetStatus` will always return `GL_NO_ERROR`.\n\nIf the behavior is `GL_LOSE_CONTEXT_ON_RESET`, a graphics reset will result in the loss of all context state, requiring the recreation of all associated objects. In this case `glGetGraphicsResetStatus` may return any of the values described above.\n\nIf a graphics reset notification occurs in a context, a notification must also occur in all other contexts which share objects with that context.\n\nAfter a graphics reset has occurred on a context, subsequent GL commands on that context (or any context which shares with that context) will generate a `GL_CONTEXT_LOST` error. Such commands will not have side effects (in particular, they will not modify memory passed by pointer for query results), and will not block indefinitely or cause termination of the application. There are two important exceptions to this behavior:\n\n- `glGetError` and `glGetGraphicsResetStatus` behave normally following a graphics reset, so that the application can determine a reset has occurred, and when it is safe to destroy and re-create the context.\n\n- Any commands which might cause a polling application to block indefinitely will generate a `GL_CONTEXT_LOST` error, but will also return a value indicating completion to the application. Such commands include:\n\n  - `glGetSynciv` with pname `GL_SYNC_STATUS` ignores the other parameters and returns `GL_SIGNALED` in *`values`*.\n\n  - `glGetQueryObjectuiv` with pname `GL_QUERY_RESULT_AVAILABLE` ignores the other parameters and returns `TRUE` in *`params`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetGraphicsResetStatus`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGetError](glgeterror.xhtml) `glGetIntegerv`, `glGetQueryObjectuiv` `glGetSynciv`\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetGraphicsResetStatus.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetGraphicsResetStatus.xhtml)"
- name: glGetInteger64i_v
  id: glget.xhtml#glGetInteger64i_v
  summary: Specifies the parameter value to be returned for non-indexed versions of glGet
  belongs_to: glGet
  description: "`void `**`glGetInteger64i_v`**`(` GLenum `target`, GLuint `index`, GLint64 \\* `data``)`;\n\n## Parameters\n\n*`pname`*\n\nSpecifies the parameter value to be returned for non-indexed versions of `glGet`. The symbolic constants in the list below are accepted.\n\n*`target`*\n\nSpecifies the parameter value to be returned for indexed versions of `glGet`. The symbolic constants in the list below are accepted.\n\n*`index`*\n\nSpecifies the index of the particular element being queried.\n\n*`data`*\n\nReturns the value or values of the specified parameter.\n\n## Description\n\nThese commands return values for simple state variables in GL. *`pname`* is a symbolic constant indicating the state variable to be returned, and *`data`* is a pointer to an array of the indicated type in which to place the returned data.\n\nType conversion is performed if *`data`* has a different type than the state variable value being requested. If `glGetBooleanv` is called, a floating-point (or integer) value is converted to `GL_FALSE` if and only if it is 0.0 (or 0). Otherwise, it is converted to `GL_TRUE`. If `glGetIntegerv` is called, boolean values are returned as `GL_TRUE` or `GL_FALSE`, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and −1.0 to the most negative representable integer value. If `glGetFloatv` or `glGetDoublev` is called, boolean values are returned as `GL_TRUE` or `GL_FALSE`, and integer values are converted to floating-point values.\n\nThe following symbolic constants are accepted by *`pname`*:\n\n`GL_ACTIVE_TEXTURE`\n\n*`data`* returns a single value indicating the active multitexture unit. The initial value is `GL_TEXTURE0`. See [glActiveTexture](glactivetexture.xhtml).\n\n`GL_ALIASED_LINE_WIDTH_RANGE`\n\n*`data`* returns a pair of values indicating the range of widths supported for aliased lines. See [glLineWidth](gllinewidth.xhtml).\n\n`GL_ARRAY_BUFFER_BINDING`\n\n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_ARRAY_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n`GL_BLEND`\n\n*`data`* returns a single boolean value indicating whether blending is enabled. The initial value is `GL_FALSE`. See [glBlendFunc](glblendfunc.xhtml).\n\n`GL_BLEND_COLOR`\n\n*`data`* returns four values, the red, green, blue, and alpha values which are the components of the blend color. See [glBlendColor](glblendcolor.xhtml).\n\n`GL_BLEND_DST_ALPHA`\n\n*`data`* returns one value, the symbolic constant identifying the alpha destination blend function. The initial value is `GL_ZERO`. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n`GL_BLEND_DST_RGB`\n\n*`data`* returns one value, the symbolic constant identifying the RGB destination blend function. The initial value is `GL_ZERO`. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n`GL_BLEND_EQUATION_RGB`\n\n*`data`* returns one value, a symbolic constant indicating whether the RGB blend equation is `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN` or `GL_MAX`. See [glBlendEquationSeparate](glblendequationseparate.xhtml).\n\n`GL_BLEND_EQUATION_ALPHA`\n\n*`data`* returns one value, a symbolic constant indicating whether the Alpha blend equation is `GL_FUNC_ADD`, `GL_FUNC_SUBTRACT`, `GL_FUNC_REVERSE_SUBTRACT`, `GL_MIN` or `GL_MAX`. See [glBlendEquationSeparate](glblendequationseparate.xhtml).\n\n`GL_BLEND_SRC_ALPHA`\n\n*`data`* returns one value, the symbolic constant identifying the alpha source blend function. The initial value is `GL_ONE`. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n`GL_BLEND_SRC_RGB`\n\n*`data`* returns one value, the symbolic constant identifying the RGB source blend function. The initial value is `GL_ONE`. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n`GL_COLOR_CLEAR_VALUE`\n\n*`data`* returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See [glClearColor](glclearcolor.xhtml).\n\n`GL_COLOR_LOGIC_OP`\n\n*`data`* returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is `GL_FALSE`. See [glLogicOp](gllogicop.xhtml).\n\n`GL_COLOR_WRITEMASK`\n\n*`data`* returns four boolean values: the red, green, blue, and alpha write enables for the color buffers. The initial value is (`GL_TRUE`, `GL_TRUE`, `GL_TRUE`, `GL_TRUE`). See [glColorMask](glcolormask.xhtml).\n\n`GL_COMPRESSED_TEXTURE_FORMATS`\n\n*`data`* returns a list of symbolic constants of length `GL_NUM_COMPRESSED_TEXTURE_FORMATS` indicating which compressed texture formats are available. See [glCompressedTexImage2D](glcompressedteximage2d.xhtml).\n\n`GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS`\n\n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a compute shader.\n\n`GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS`\n\n*`data`* returns one value, the maximum total number of active shader storage blocks that may be accessed by all active shaders.\n\n`GL_MAX_COMPUTE_UNIFORM_BLOCKS`\n\n*`data`* returns one value, the maximum number of uniform blocks per compute shader. The value must be at least 14. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n`GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS`\n\n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the compute shader. The value must be at least 16. See [glActiveTexture](glactivetexture.xhtml).\n\n`GL_MAX_COMPUTE_UNIFORM_COMPONENTS`\n\n*`data`* returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a compute shader. The value must be at least 1024. See [glUniform](gluniform.xhtml).\n\n`GL_MAX_COMPUTE_ATOMIC_COUNTERS`\n\n*`data`* returns a single value, the maximum number of atomic counters available to compute shaders.\n\n`GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS`\n\n*`data`* returns a single value, the maximum number of atomic counter buffers that may be accessed by a compute shader.\n\n`GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS`\n\n*`data`* returns one value, the number of words for compute shader uniform variables in all uniform blocks (including default). The value must be at least 1. See [glUniform](gluniform.xhtml).\n\n`GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS`\n\n*`data`* returns one value, the number of invocations in a single local work group (i.e., the product of the three dimensions) that may be dispatched to a compute shader.\n\n`GL_MAX_COMPUTE_WORK_GROUP_COUNT`\n\nAccepted by the indexed versions of `glGet`. *`data`* the maximum number of work groups that may be dispatched to a compute shader. Indices 0, 1, and 2 correspond to the X, Y and Z dimensions, respectively.\n\n`GL_MAX_COMPUTE_WORK_GROUP_SIZE`\n\nAccepted by the indexed versions of `glGet`. *`data`* the maximum size of a work groups that may be used during compilation of a compute shader. Indices 0, 1, and 2 correspond to the X, Y and Z dimensions, respectively.\n\n`GL_DISPATCH_INDIRECT_BUFFER_BINDING`\n\n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_DISPATCH_INDIRECT_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n`GL_MAX_DEBUG_GROUP_STACK_DEPTH`\n\n*`data`* returns a single value, the maximum depth of the debug message group stack.\n\n`GL_DEBUG_GROUP_STACK_DEPTH`\n\n*`data`* returns a single value, the current depth of the debug message group stack.\n\n`GL_CONTEXT_FLAGS`\n\n*`data`* returns one value, the flags with which the context was created (such as debugging functionality).\n\n`GL_CULL_FACE`\n\n*`data`* returns a single boolean value indicating whether polygon culling is enabled. The initial value is `GL_FALSE`. See [glCullFace](glcullface.xhtml).\n\n`GL_CULL_FACE_MODE`\n\n*`data`* returns a single value indicating the mode of polygon culling. The initial value is `GL_BACK`. See [glCullFace](glcullface.xhtml).\n\n`GL_CURRENT_PROGRAM`\n\n*`data`* returns one value, the name of the program object that is currently active, or 0 if no program object is active. See [glUseProgram](gluseprogram.xhtml).\n\n`GL_DEPTH_CLEAR_VALUE`\n\n*`data`* returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is 1. See [glClearDepth](glcleardepth.xhtml).\n\n`GL_DEPTH_FUNC`\n\n*`data`* returns one value, the symbolic constant that indicates the depth comparison function. The initial value is `GL_LESS`. See [glDepthFunc](gldepthfunc.xhtml).\n\n`GL_DEPTH_RANGE`\n\n*`data`* returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 1). See [glDepthRange](gldepthrange.xhtml).\n\n`GL_DEPTH_TEST`\n\n*`data`* returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is `GL_FALSE`. See [glDepthFunc](gldepthfunc.xhtml) and [glDepthRange](gldepthrange.xhtml).\n\n`GL_DEPTH_WRITEMASK`\n\n*`data`* returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is `GL_TRUE`. See [glDepthMask](gldepthmask.xhtml).\n\n`GL_DITHER`\n\n*`data`* returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is `GL_TRUE`.\n\n`GL_DOUBLEBUFFER`\n\n*`data`* returns a single boolean value indicating whether double buffering is supported.\n\n`GL_DRAW_BUFFER`\n\n*`data`* returns one value, a symbolic constant indicating which buffers are being drawn to. See [glDrawBuffer](gldrawbuffer.xhtml). The initial value is `GL_BACK` if there are back buffers, otherwise it is `GL_FRONT`.\n\n`GL_DRAW_BUFFER` *i*\n\n*`data`* returns one value, a symbolic constant indicating which buffers are being drawn to by the corresponding output color. See [glDrawBuffers](gldrawbuffers.xhtml). The initial value of `GL_DRAW_BUFFER0` is `GL_BACK` if there are back buffers, otherwise it is `GL_FRONT`. The initial values of draw buffers for all other output colors is `GL_NONE`.\n\n`GL_DRAW_FRAMEBUFFER_BINDING`\n\n*`data`* returns one value, the name of the framebuffer object currently bound to the `GL_DRAW_FRAMEBUFFER` target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See [glBindFramebuffer](glbindframebuffer.xhtml).\n\n`GL_READ_FRAMEBUFFER_BINDING`\n\n*`data`* returns one value, the name of the framebuffer object currently bound to the `GL_READ_FRAMEBUFFER` target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See [glBindFramebuffer](glbindframebuffer.xhtml).\n\n`GL_ELEMENT_ARRAY_BUFFER_BINDING`\n\n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_ELEMENT_ARRAY_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n`GL_FRAGMENT_SHADER_DERIVATIVE_HINT`\n\n*`data`* returns one value, a symbolic constant indicating the mode of the derivative accuracy hint for fragment shaders. The initial value is `GL_DONT_CARE`. See [glHint](glhint.xhtml).\n\n`GL_IMPLEMENTATION_COLOR_READ_FORMAT`\n\n*`data`* returns a single GLenum value indicating the implementation's preferred pixel data format. See [glReadPixels](glreadpixels.xhtml).\n\n`GL_IMPLEMENTATION_COLOR_READ_TYPE`\n\n*`data`* returns a single GLenum value indicating the implementation's preferred pixel data type. See [glReadPixels](glreadpixels.xhtml).\n\n`GL_LINE_SMOOTH`\n\n*`data`* returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is `GL_FALSE`. See [glLineWidth](gllinewidth.xhtml).\n\n`GL_LINE_SMOOTH_HINT`\n\n*`data`* returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is `GL_DONT_CARE`. See [glHint](glhint.xhtml).\n\n`GL_LINE_WIDTH`\n\n*`data`* returns one value, the line width as specified with [glLineWidth](gllinewidth.xhtml). The initial value is 1.\n\n`GL_LAYER_PROVOKING_VERTEX`\n\n*`data`* returns one value, the implementation dependent specifc vertex of a primitive that is used to select the rendering layer. If the value returned is equivalent to `GL_PROVOKING_VERTEX`, then the vertex selection follows the convention specified by [glProvokingVertex](glprovokingvertex.xhtml). If the value returned is equivalent to `GL_FIRST_VERTEX_CONVENTION`, then the selection is always taken from the first vertex in the primitive. If the value returned is equivalent to `GL_LAST_VERTEX_CONVENTION`, then the selection is always taken from the last vertex in the primitive. If the value returned is equivalent to `GL_UNDEFINED_VERTEX`, then the selection is not guaranteed to be taken from any specific vertex in the primitive.\n\n`GL_LOGIC_OP_MODE`\n\n*`data`* returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is `GL_COPY`. See [glLogicOp](gllogicop.xhtml).\n\n`GL_MAJOR_VERSION`\n\n*`data`* returns one value, the major version number of the OpenGL API supported by the current context.\n\n`GL_MAX_3D_TEXTURE_SIZE`\n\n*`data`* returns one value, a rough estimate of the largest 3D texture that the GL can handle. The value must be at least 64. Use `GL_PROXY_TEXTURE_3D` to determine if a texture is too large. See [glTexImage3D](glteximage3d.xhtml).\n\n`GL_MAX_ARRAY_TEXTURE_LAYERS`\n\n*`data`* returns one value. The value indicates the maximum number of layers allowed in an array texture, and must be at least 256. See [glTexImage2D](glteximage2d.xhtml).\n\n`GL_MAX_CLIP_DISTANCES`\n\n*`data`* returns one value, the maximum number of application-defined clipping distances. The value must be at least 8.\n\n`GL_MAX_COLOR_TEXTURE_SAMPLES`\n\n*`data`* returns one value, the maximum number of samples in a color multisample texture.\n\n`GL_MAX_COMBINED_ATOMIC_COUNTERS`\n\n*`data`* returns a single value, the maximum number of atomic counters available to all active shaders.\n\n`GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS`\n\n*`data`* returns one value, the number of words for fragment shader uniform variables in all uniform blocks (including default). The value must be at least 1. See [glUniform](gluniform.xhtml).\n\n`GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS`\n\n*`data`* returns one value, the number of words for geometry shader uniform variables in all uniform blocks (including default). The value must be at least 1. See [glUniform](gluniform.xhtml).\n\n`GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`\n\n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader and the fragment processor combined. If both the vertex shader and the fragment processing stage access the same texture image unit, then that counts as using two texture image units against this limit. The value must be at least 48. See [glActiveTexture](glactivetexture.xhtml).\n\n`GL_MAX_COMBINED_UNIFORM_BLOCKS`\n\n*`data`* returns one value, the maximum number of uniform blocks per program. The value must be at least 70. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n`GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS`\n\n*`data`* returns one value, the number of words for vertex shader uniform variables in all uniform blocks (including default). The value must be at least 1. See [glUniform](gluniform.xhtml).\n\n`GL_MAX_CUBE_MAP_TEXTURE_SIZE`\n\n*`data`* returns one value. The value gives a rough estimate of the largest cube-map texture that the GL can handle. The value must be at least 1024. Use `GL_PROXY_TEXTURE_CUBE_MAP` to determine if a texture is too large. See [glTexImage2D](glteximage2d.xhtml).\n\n`GL_MAX_DEPTH_TEXTURE_SAMPLES`\n\n*`data`* returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.\n\n`GL_MAX_DRAW_BUFFERS`\n\n*`data`* returns one value, the maximum number of simultaneous outputs that may be written in a fragment shader. The value must be at least 8. See [glDrawBuffers](gldrawbuffers.xhtml).\n\n`GL_MAX_DUAL_SOURCE_DRAW_BUFFERS`\n\n*`data`* returns one value, the maximum number of active draw buffers when using dual-source blending. The value must be at least 1. See [glBlendFunc](glblendfunc.xhtml) and [glBlendFuncSeparate](glblendfuncseparate.xhtml).\n\n`GL_MAX_ELEMENTS_INDICES`\n\n*`data`* returns one value, the recommended maximum number of vertex array indices. See [glDrawRangeElements](gldrawrangeelements.xhtml).\n\n`GL_MAX_ELEMENTS_VERTICES`\n\n*`data`* returns one value, the recommended maximum number of vertex array vertices. See [glDrawRangeElements](gldrawrangeelements.xhtml).\n\n`GL_MAX_FRAGMENT_ATOMIC_COUNTERS`\n\n*`data`* returns a single value, the maximum number of atomic counters available to fragment shaders.\n\n`GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS`\n\n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a fragment shader.\n\n`GL_MAX_FRAGMENT_INPUT_COMPONENTS`\n\n*`data`* returns one value, the maximum number of components of the inputs read by the fragment shader, which must be at least 128.\n\n`GL_MAX_FRAGMENT_UNIFORM_COMPONENTS`\n\n*`data`* returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value must be at least 1024. See [glUniform](gluniform.xhtml).\n\n`GL_MAX_FRAGMENT_UNIFORM_VECTORS`\n\n*`data`* returns one value, the maximum number of individual 4-vectors of floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value is equal to the value of `GL_MAX_FRAGMENT_UNIFORM_COMPONENTS` divided by 4 and must be at least 256. See [glUniform](gluniform.xhtml).\n\n`GL_MAX_FRAGMENT_UNIFORM_BLOCKS`\n\n*`data`* returns one value, the maximum number of uniform blocks per fragment shader. The value must be at least 12. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n`GL_MAX_FRAMEBUFFER_WIDTH`\n\n*`data`* returns one value, the maximum width for a framebuffer that has no attachments, which must be at least 16384. See `glFramebufferParameter`.\n\n`GL_MAX_FRAMEBUFFER_HEIGHT`\n\n*`data`* returns one value, the maximum height for a framebuffer that has no attachments, which must be at least 16384. See `glFramebufferParameter`.\n\n`GL_MAX_FRAMEBUFFER_LAYERS`\n\n*`data`* returns one value, the maximum number of layers for a framebuffer that has no attachments, which must be at least 2048. See `glFramebufferParameter`.\n\n`GL_MAX_FRAMEBUFFER_SAMPLES`\n\n*`data`* returns one value, the maximum samples in a framebuffer that has no attachments, which must be at least 4. See `glFramebufferParameter`.\n\n`GL_MAX_GEOMETRY_ATOMIC_COUNTERS`\n\n*`data`* returns a single value, the maximum number of atomic counters available to geometry shaders.\n\n`GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS`\n\n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a geometry shader.\n\n`GL_MAX_GEOMETRY_INPUT_COMPONENTS`\n\n*`data`* returns one value, the maximum number of components of inputs read by a geometry shader, which must be at least 64.\n\n`GL_MAX_GEOMETRY_OUTPUT_COMPONENTS`\n\n*`data`* returns one value, the maximum number of components of outputs written by a geometry shader, which must be at least 128.\n\n`GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS`\n\n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the geometry shader. The value must be at least 16. See [glActiveTexture](glactivetexture.xhtml).\n\n`GL_MAX_GEOMETRY_UNIFORM_BLOCKS`\n\n*`data`* returns one value, the maximum number of uniform blocks per geometry shader. The value must be at least 12. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n`GL_MAX_GEOMETRY_UNIFORM_COMPONENTS`\n\n*`data`* returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a geometry shader. The value must be at least 1024. See [glUniform](gluniform.xhtml).\n\n`GL_MAX_INTEGER_SAMPLES`\n\n*`data`* returns one value, the maximum number of samples supported in integer format multisample buffers.\n\n`GL_MIN_MAP_BUFFER_ALIGNMENT`\n\n*`data`* returns one value, the minimum alignment in basic machine units of pointers returned from[glMapBuffer](glmapbuffer.xhtml) and [glMapBufferRange](glmapbufferrange.xhtml). This value must be a power of two and must be at least 64.\n\n`GL_MAX_LABEL_LENGTH`\n\n*`data`* returns one value, the maximum length of a label that may be assigned to an object. See [glObjectLabel](globjectlabel.xhtml) and [glObjectPtrLabel](globjectptrlabel.xhtml).\n\n`GL_MAX_PROGRAM_TEXEL_OFFSET`\n\n*`data`* returns one value, the maximum texel offset allowed in a texture lookup, which must be at least 7.\n\n`GL_MIN_PROGRAM_TEXEL_OFFSET`\n\n*`data`* returns one value, the minimum texel offset allowed in a texture lookup, which must be at most -8.\n\n`GL_MAX_RECTANGLE_TEXTURE_SIZE`\n\n*`data`* returns one value. The value gives a rough estimate of the largest rectangular texture that the GL can handle. The value must be at least 1024. Use `GL_PROXY_TEXTURE_RECTANGLE` to determine if a texture is too large. See [glTexImage2D](glteximage2d.xhtml).\n\n`GL_MAX_RENDERBUFFER_SIZE`\n\n*`data`* returns one value. The value indicates the maximum supported size for renderbuffers. See [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml).\n\n`GL_MAX_SAMPLE_MASK_WORDS`\n\n*`data`* returns one value, the maximum number of sample mask words.\n\n`GL_MAX_SERVER_WAIT_TIMEOUT`\n\n*`data`* returns one value, the maximum [glWaitSync](glwaitsync.xhtml) timeout interval.\n\n`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`\n\n*`data`* returns one value, the maximum number of shader storage buffer binding points on the context, which must be at least 8.\n\n`GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS`\n\n*`data`* returns a single value, the maximum number of atomic counters available to tessellation control shaders.\n\n`GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS`\n\n*`data`* returns a single value, the maximum number of atomic counters available to tessellation evaluation shaders.\n\n`GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS`\n\n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a tessellation control shader.\n\n`GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS`\n\n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a tessellation evaluation shader.\n\n`GL_MAX_TEXTURE_BUFFER_SIZE`\n\n*`data`* returns one value. The value gives the maximum number of texels allowed in the texel array of a texture buffer object. Value must be at least 65536.\n\n`GL_MAX_TEXTURE_IMAGE_UNITS`\n\n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the fragment shader. The value must be at least 16. See [glActiveTexture](glactivetexture.xhtml).\n\n`GL_MAX_TEXTURE_LOD_BIAS`\n\n*`data`* returns one value, the maximum, absolute value of the texture level-of-detail bias. The value must be at least 2.0.\n\n`GL_MAX_TEXTURE_SIZE`\n\n*`data`* returns one value. The value gives a rough estimate of the largest texture that the GL can handle. The value must be at least 1024. Use a proxy texture target such as `GL_PROXY_TEXTURE_1D` or `GL_PROXY_TEXTURE_2D` to determine if a texture is too large. See [glTexImage1D](glteximage1d.xhtml) and [glTexImage2D](glteximage2d.xhtml).\n\n`GL_MAX_UNIFORM_BUFFER_BINDINGS`\n\n*`data`* returns one value, the maximum number of uniform buffer binding points on the context, which must be at least 36.\n\n`GL_MAX_UNIFORM_BLOCK_SIZE`\n\n*`data`* returns one value, the maximum size in basic machine units of a uniform block, which must be at least 16384.\n\n`GL_MAX_UNIFORM_LOCATIONS`\n\n*`data`* returns one value, the maximum number of explicitly assignable uniform locations, which must be at least 1024.\n\n`GL_MAX_VARYING_COMPONENTS`\n\n*`data`* returns one value, the number components for varying variables, which must be at least 60.\n\n`GL_MAX_VARYING_VECTORS`\n\n*`data`* returns one value, the number 4-vectors for varying variables, which is equal to the value of `GL_MAX_VARYING_COMPONENTS` and must be at least 15.\n\n`GL_MAX_VARYING_FLOATS`\n\n*`data`* returns one value, the maximum number of interpolators available for processing varying variables used by vertex and fragment shaders. This value represents the number of individual floating-point values that can be interpolated; varying variables declared as vectors, matrices, and arrays will all consume multiple interpolators. The value must be at least 32.\n\n`GL_MAX_VERTEX_ATOMIC_COUNTERS`\n\n*`data`* returns a single value, the maximum number of atomic counters available to vertex shaders.\n\n`GL_MAX_VERTEX_ATTRIBS`\n\n*`data`* returns one value, the maximum number of 4-component generic vertex attributes accessible to a vertex shader. The value must be at least 16. See [glVertexAttrib](glvertexattrib.xhtml).\n\n`GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS`\n\n*`data`* returns one value, the maximum number of active shader storage blocks that may be accessed by a vertex shader.\n\n`GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS`\n\n*`data`* returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader. The value may be at least 16. See [glActiveTexture](glactivetexture.xhtml).\n\n`GL_MAX_VERTEX_UNIFORM_COMPONENTS`\n\n*`data`* returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a vertex shader. The value must be at least 1024. See [glUniform](gluniform.xhtml).\n\n`GL_MAX_VERTEX_UNIFORM_VECTORS`\n\n*`data`* returns one value, the maximum number of 4-vectors that may be held in uniform variable storage for the vertex shader. The value of `GL_MAX_VERTEX_UNIFORM_VECTORS` is equal to the value of `GL_MAX_VERTEX_UNIFORM_COMPONENTS` and must be at least 256.\n\n`GL_MAX_VERTEX_OUTPUT_COMPONENTS`\n\n*`data`* returns one value, the maximum number of components of output written by a vertex shader, which must be at least 64.\n\n`GL_MAX_VERTEX_UNIFORM_BLOCKS`\n\n*`data`* returns one value, the maximum number of uniform blocks per vertex shader. The value must be at least 12. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n`GL_MAX_VIEWPORT_DIMS`\n\n*`data`* returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See [glViewport](glviewport.xhtml).\n\n`GL_MAX_VIEWPORTS`\n\n*`data`* returns one value, the maximum number of simultaneous viewports that are supported. The value must be at least 16. See [glViewportIndexed](glviewportindexed.xhtml).\n\n`GL_MINOR_VERSION`\n\n*`data`* returns one value, the minor version number of the OpenGL API supported by the current context.\n\n`GL_NUM_COMPRESSED_TEXTURE_FORMATS`\n\n*`data`* returns a single integer value indicating the number of available compressed texture formats. The minimum value is 4. See [glCompressedTexImage2D](glcompressedteximage2d.xhtml).\n\n`GL_NUM_EXTENSIONS`\n\n*`data`* returns one value, the number of extensions supported by the GL implementation for the current context. See [glGetString](glgetstring.xhtml).\n\n`GL_NUM_PROGRAM_BINARY_FORMATS`\n\n*`data`* returns one value, the number of program binary formats supported by the implementation.\n\n`GL_NUM_SHADER_BINARY_FORMATS`\n\n*`data`* returns one value, the number of binary shader formats supported by the implementation. If this value is greater than zero, then the implementation supports loading binary shaders. If it is zero, then the loading of binary shaders by the implementation is not supported.\n\n`GL_PACK_ALIGNMENT`\n\n*`data`* returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_PACK_IMAGE_HEIGHT`\n\n*`data`* returns one value, the image height used for writing pixel data to memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_PACK_LSB_FIRST`\n\n*`data`* returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is `GL_FALSE`. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_PACK_ROW_LENGTH`\n\n*`data`* returns one value, the row length used for writing pixel data to memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_PACK_SKIP_IMAGES`\n\n*`data`* returns one value, the number of pixel images skipped before the first pixel is written into memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_PACK_SKIP_PIXELS`\n\n*`data`* returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_PACK_SKIP_ROWS`\n\n*`data`* returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_PACK_SWAP_BYTES`\n\n*`data`* returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is `GL_FALSE`. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_PIXEL_PACK_BUFFER_BINDING`\n\n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_PIXEL_PACK_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n`GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n*`data`* returns a single value, the name of the buffer object currently bound to the target `GL_PIXEL_UNPACK_BUFFER`. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindBuffer](glbindbuffer.xhtml).\n\n`GL_POINT_FADE_THRESHOLD_SIZE`\n\n*`data`* returns one value, the point size threshold for determining the point size. See [glPointParameter](glpointparameter.xhtml).\n\n`GL_PRIMITIVE_RESTART_INDEX`\n\n*`data`* returns one value, the current primitive restart index. The initial value is 0. See [glPrimitiveRestartIndex](glprimitiverestartindex.xhtml).\n\n`GL_PROGRAM_BINARY_FORMATS`\n\n*`data`* an array of `GL_NUM_PROGRAM_BINARY_FORMATS` values, indicating the proram binary formats supported by the implementation.\n\n`GL_PROGRAM_PIPELINE_BINDING`\n\n*`data`* a single value, the name of the currently bound program pipeline object, or zero if no program pipeline object is bound. See [glBindProgramPipeline](glbindprogrampipeline.xhtml).\n\n`GL_PROGRAM_POINT_SIZE`\n\n*`data`* returns a single boolean value indicating whether vertex program point size mode is enabled. If enabled, then the point size is taken from the shader built-in `gl_PointSize`. If disabled, then the point size is taken from the point state as specified by [glPointSize](glpointsize.xhtml). The initial value is `GL_FALSE`.\n\n`GL_PROVOKING_VERTEX`\n\n*`data`* returns one value, the currently selected provoking vertex convention. The initial value is `GL_LAST_VERTEX_CONVENTION`. See [glProvokingVertex](glprovokingvertex.xhtml).\n\n`GL_POINT_SIZE`\n\n*`data`* returns one value, the point size as specified by [glPointSize](glpointsize.xhtml). The initial value is 1.\n\n`GL_POINT_SIZE_GRANULARITY`\n\n*`data`* returns one value, the size difference between adjacent supported sizes for antialiased points. See [glPointSize](glpointsize.xhtml).\n\n`GL_POINT_SIZE_RANGE`\n\n*`data`* returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See [glPointSize](glpointsize.xhtml).\n\n`GL_POLYGON_OFFSET_FACTOR`\n\n*`data`* returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n`GL_POLYGON_OFFSET_UNITS`\n\n*`data`* returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n`GL_POLYGON_OFFSET_FILL`\n\n*`data`* returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is `GL_FALSE`. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n`GL_POLYGON_OFFSET_LINE`\n\n*`data`* returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is `GL_FALSE`. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n`GL_POLYGON_OFFSET_POINT`\n\n*`data`* returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is `GL_FALSE`. See [glPolygonOffset](glpolygonoffset.xhtml).\n\n`GL_POLYGON_SMOOTH`\n\n*`data`* returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is `GL_FALSE`. See [glPolygonMode](glpolygonmode.xhtml).\n\n`GL_POLYGON_SMOOTH_HINT`\n\n*`data`* returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is `GL_DONT_CARE`. See [glHint](glhint.xhtml).\n\n`GL_READ_BUFFER`\n\n*`data`* returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is `GL_BACK` if there is a back buffer, otherwise it is `GL_FRONT`. See [glReadPixels](glreadpixels.xhtml).\n\n`GL_RENDERBUFFER_BINDING`\n\n*`data`* returns a single value, the name of the renderbuffer object currently bound to the target `GL_RENDERBUFFER`. If no renderbuffer object is bound to this target, 0 is returned. The initial value is 0. See [glBindRenderbuffer](glbindrenderbuffer.xhtml).\n\n`GL_SAMPLE_BUFFERS`\n\n*`data`* returns a single integer value indicating the number of sample buffers associated with the framebuffer. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n`GL_SAMPLE_COVERAGE_VALUE`\n\n*`data`* returns a single positive floating-point value indicating the current sample coverage value. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n`GL_SAMPLE_COVERAGE_INVERT`\n\n*`data`* returns a single boolean value indicating if the temporary coverage value should be inverted. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n`GL_SAMPLE_MASK_VALUE`\n\n*`params`* returns one value indicating the current sample mask value. See [glSampleMaski](glsamplemaski.xhtml).\n\n`GL_SAMPLER_BINDING`\n\n*`data`* returns a single value, the name of the sampler object currently bound to the active texture unit. The initial value is 0. See [glBindSampler](glbindsampler.xhtml).\n\n`GL_SAMPLES`\n\n*`data`* returns a single integer value indicating the coverage mask size. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n`GL_SCISSOR_BOX`\n\n*`data`* returns four values: the *x* and *y* window coordinates of the scissor box, followed by its width and height. Initially the *x* and *y* window coordinates are both 0 and the width and height are set to the size of the window. See [glScissor](glscissor.xhtml).\n\n`GL_SCISSOR_TEST`\n\n*`data`* returns a single boolean value indicating whether scissoring is enabled. The initial value is `GL_FALSE`. See [glScissor](glscissor.xhtml).\n\n`GL_SHADER_COMPILER`\n\n*`data`* returns a single boolean value indicating whether an online shader compiler is present in the implementation. All desktop OpenGL implementations must support online shader compilations, and therefore the value of `GL_SHADER_COMPILER` will always be `GL_TRUE`.\n\n`GL_SHADER_STORAGE_BUFFER_BINDING`\n\nWhen used with non-indexed variants of `glGet` (such as `glGetIntegerv`), *`data`* returns a single value, the name of the buffer object currently bound to the target `GL_SHADER_STORAGE_BUFFER`. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), *`data`* returns a single value, the name of the buffer object bound to the indexed shader storage buffer binding points. The initial value is 0 for all targets. See [glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), and [glBindBufferRange](glbindbufferrange.xhtml).\n\n`GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT`\n\n*`data`* returns a single value, the minimum required alignment for shader storage buffer sizes and offset. The initial value is 1. See [glShaderStorageBlockBinding](glshaderstorageblockbinding.xhtml).\n\n`GL_SHADER_STORAGE_BUFFER_START`\n\nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the start offset of the binding range for each indexed shader storage buffer binding. The initial value is 0 for all bindings. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n`GL_SHADER_STORAGE_BUFFER_SIZE`\n\nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the size of the binding range for each indexed shader storage buffer binding. The initial value is 0 for all bindings. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n`GL_SMOOTH_LINE_WIDTH_RANGE`\n\n*`data`* returns a pair of values indicating the range of widths supported for smooth (antialiased) lines. See [glLineWidth](gllinewidth.xhtml).\n\n`GL_SMOOTH_LINE_WIDTH_GRANULARITY`\n\n*`data`* returns a single value indicating the level of quantization applied to smooth line width parameters.\n\n`GL_STENCIL_BACK_FAIL`\n\n*`data`* returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test fails. The initial value is `GL_KEEP`. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n`GL_STENCIL_BACK_FUNC`\n\n*`data`* returns one value, a symbolic constant indicating what function is used for back-facing polygons to compare the stencil reference value with the stencil buffer value. The initial value is `GL_ALWAYS`. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n`GL_STENCIL_BACK_PASS_DEPTH_FAIL`\n\n*`data`* returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes, but the depth test fails. The initial value is `GL_KEEP`. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n`GL_STENCIL_BACK_PASS_DEPTH_PASS`\n\n*`data`* returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes and the depth test passes. The initial value is `GL_KEEP`. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n`GL_STENCIL_BACK_REF`\n\n*`data`* returns one value, the reference value that is compared with the contents of the stencil buffer for back-facing polygons. The initial value is 0. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n`GL_STENCIL_BACK_VALUE_MASK`\n\n*`data`* returns one value, the mask that is used for back-facing polygons to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n`GL_STENCIL_BACK_WRITEMASK`\n\n*`data`* returns one value, the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value is all 1's. See [glStencilMaskSeparate](glstencilmaskseparate.xhtml).\n\n`GL_STENCIL_CLEAR_VALUE`\n\n*`data`* returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See [glClearStencil](glclearstencil.xhtml).\n\n`GL_STENCIL_FAIL`\n\n*`data`* returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is `GL_KEEP`. See [glStencilOp](glstencilop.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n`GL_STENCIL_FUNC`\n\n*`data`* returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is `GL_ALWAYS`. See [glStencilFunc](glstencilfunc.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n`GL_STENCIL_PASS_DEPTH_FAIL`\n\n*`data`* returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is `GL_KEEP`. See [glStencilOp](glstencilop.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n`GL_STENCIL_PASS_DEPTH_PASS`\n\n*`data`* returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is `GL_KEEP`. See [glStencilOp](glstencilop.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilOpSeparate](glstencilopseparate.xhtml).\n\n`GL_STENCIL_REF`\n\n*`data`* returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See [glStencilFunc](glstencilfunc.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n`GL_STENCIL_TEST`\n\n*`data`* returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is `GL_FALSE`. See [glStencilFunc](glstencilfunc.xhtml) and [glStencilOp](glstencilop.xhtml).\n\n`GL_STENCIL_VALUE_MASK`\n\n*`data`* returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See [glStencilFunc](glstencilfunc.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\n`GL_STENCIL_WRITEMASK`\n\n*`data`* returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See [glStencilMask](glstencilmask.xhtml). This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See [glStencilMaskSeparate](glstencilmaskseparate.xhtml).\n\n`GL_STEREO`\n\n*`data`* returns a single boolean value indicating whether stereo buffers (left and right) are supported.\n\n`GL_SUBPIXEL_BITS`\n\n*`data`* returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The value must be at least 4.\n\n`GL_TEXTURE_BINDING_1D`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_1D`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_BINDING_1D_ARRAY`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_1D_ARRAY`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_BINDING_2D`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_2D`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_BINDING_2D_ARRAY`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_2D_ARRAY`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_BINDING_2D_MULTISAMPLE`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_2D_MULTISAMPLE`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_BINDING_3D`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_3D`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_BINDING_BUFFER`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_BUFFER`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_BINDING_CUBE_MAP`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_CUBE_MAP`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_BINDING_RECTANGLE`\n\n*`data`* returns a single value, the name of the texture currently bound to the target `GL_TEXTURE_RECTANGLE`. The initial value is 0. See [glBindTexture](glbindtexture.xhtml).\n\n`GL_TEXTURE_COMPRESSION_HINT`\n\n*`data`* returns a single value indicating the mode of the texture compression hint. The initial value is `GL_DONT_CARE`.\n\n`GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`\n\n*`data`* returns a single value, the minimum required alignment for texture buffer sizes and offset. The initial value is 1. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n`GL_TIMESTAMP`\n\n*`data`* returns a single value, the 64-bit value of the current GL time. See [glQueryCounter](glquerycounter.xhtml).\n\n`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`\n\nWhen used with non-indexed variants of `glGet` (such as `glGetIntegerv`), *`data`* returns a single value, the name of the buffer object currently bound to the target `GL_TRANSFORM_FEEDBACK_BUFFER`. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), *`data`* returns a single value, the name of the buffer object bound to the indexed transform feedback attribute stream. The initial value is 0 for all targets. See [glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), and [glBindBufferRange](glbindbufferrange.xhtml).\n\n`GL_TRANSFORM_FEEDBACK_BUFFER_START`\n\nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the start offset of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`\n\nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the size of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n`GL_UNIFORM_BUFFER_BINDING`\n\nWhen used with non-indexed variants of `glGet` (such as `glGetIntegerv`), *`data`* returns a single value, the name of the buffer object currently bound to the target `GL_UNIFORM_BUFFER`. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), *`data`* returns a single value, the name of the buffer object bound to the indexed uniform buffer binding point. The initial value is 0 for all targets. See [glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), and [glBindBufferRange](glbindbufferrange.xhtml).\n\n`GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT`\n\n*`data`* returns a single value, the minimum required alignment for uniform buffer sizes and offset. The initial value is 1. See [glUniformBlockBinding](gluniformblockbinding.xhtml).\n\n`GL_UNIFORM_BUFFER_SIZE`\n\nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the size of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n`GL_UNIFORM_BUFFER_START`\n\nWhen used with indexed variants of `glGet` (such as `glGetInteger64i_v`), *`data`* returns a single value, the start offset of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See [glBindBufferRange](glbindbufferrange.xhtml).\n\n`GL_UNPACK_ALIGNMENT`\n\n*`data`* returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_UNPACK_IMAGE_HEIGHT`\n\n*`data`* returns one value, the image height used for reading pixel data from memory. The initial is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_UNPACK_LSB_FIRST`\n\n*`data`* returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is `GL_FALSE`. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_UNPACK_ROW_LENGTH`\n\n*`data`* returns one value, the row length used for reading pixel data from memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_UNPACK_SKIP_IMAGES`\n\n*`data`* returns one value, the number of pixel images skipped before the first pixel is read from memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_UNPACK_SKIP_PIXELS`\n\n*`data`* returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_UNPACK_SKIP_ROWS`\n\n*`data`* returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_UNPACK_SWAP_BYTES`\n\n*`data`* returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is `GL_FALSE`. See [glPixelStore](glpixelstore.xhtml).\n\n`GL_VERTEX_ARRAY_BINDING`\n\n*`data`* returns a single value, the name of the vertex array object currently bound to the context. If no vertex array object is bound to the context, 0 is returned. The initial value is 0. See [glBindVertexArray](glbindvertexarray.xhtml).\n\n`GL_VERTEX_BINDING_DIVISOR`\n\nAccepted by the indexed forms. *`data`* returns a single integer value representing the instance step divisor of the first element in the bound buffer's data store for vertex attribute bound to *`index`*.\n\n`GL_VERTEX_BINDING_OFFSET`\n\nAccepted by the indexed forms. *`data`* returns a single integer value representing the byte offset of the first element in the bound buffer's data store for vertex attribute bound to *`index`*.\n\n`GL_VERTEX_BINDING_STRIDE`\n\nAccepted by the indexed forms. *`data`* returns a single integer value representing the byte offset between the start of each element in the bound buffer's data store for vertex attribute bound to *`index`*.\n\n`GL_VERTEX_BINDING_BUFFER`\n\nAccepted by the indexed forms. *`data`* returns a single integer value representing the name of the buffer bound to vertex binding *`index`*.\n\n`GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET`\n\n*`data`* returns a single integer value containing the maximum offset that may be added to a vertex binding offset.\n\n`GL_MAX_VERTEX_ATTRIB_BINDINGS`\n\n*`data`* returns a single integer value containing the maximum number of vertex buffers that may be bound.\n\n`GL_VIEWPORT`\n\nWhen used with non-indexed variants of `glGet` (such as `glGetIntegerv`), *`data`* returns four values: the *x* and *y* window coordinates of the viewport, followed by its width and height. Initially the *x* and *y* window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See [glViewport](glviewport.xhtml).\n\nWhen used with indexed variants of `glGet` (such as `glGetIntegeri_v`), *`data`* returns four values: the *x* and *y* window coordinates of the indexed viewport, followed by its width and height. Initially the *x* and *y* window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See `glViewportIndexedf`.\n\n`GL_VIEWPORT_BOUNDS_RANGE`\n\n*`data`* returns two values, the minimum and maximum viewport bounds range. The minimum range should be at least \\[-32768, 32767\\].\n\n`GL_VIEWPORT_INDEX_PROVOKING_VERTEX`\n\n*`data`* returns one value, the implementation dependent specifc vertex of a primitive that is used to select the viewport index. If the value returned is equivalent to `GL_PROVOKING_VERTEX`, then the vertex selection follows the convention specified by [glProvokingVertex](glprovokingvertex.xhtml). If the value returned is equivalent to `GL_FIRST_VERTEX_CONVENTION`, then the selection is always taken from the first vertex in the primitive. If the value returned is equivalent to `GL_LAST_VERTEX_CONVENTION`, then the selection is always taken from the last vertex in the primitive. If the value returned is equivalent to `GL_UNDEFINED_VERTEX`, then the selection is not guaranteed to be taken from any specific vertex in the primitive.\n\n`GL_VIEWPORT_SUBPIXEL_BITS`\n\n*`data`* returns a single value, the number of bits of sub-pixel precision which the GL uses to interpret the floating point viewport bounds. The minimum value is 0.\n\n`GL_MAX_ELEMENT_INDEX`\n\n*`data`* returns a single value, the maximum index that may be specified during the transfer of generic vertex attributes to the GL.\n\nMany of the boolean parameters can also be queried more easily using [glIsEnabled](glisenabled.xhtml).\n\n## Notes\n\nThe following parameters return the associated value for the active texture unit: `GL_TEXTURE_1D`, `GL_TEXTURE_BINDING_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_BINDING_2D`, `GL_TEXTURE_3D` and `GL_TEXTURE_BINDING_3D`.\n\n`GL_MAX_VIEWPORTS`, `GL_VIEWPORT_SUBPIXEL_BITS`, `GL_VIEWPORT_BOUNDS_RANGE`, `GL_LAYER_PROVOKING_VERTEX`, and `GL_VIEWPORT_INDEX_PROVOKING_VERTEX` are available only if the GL version is 4.1 or greater.\n\n`GL_MAX_VERTEX_ATOMIC_COUNTERS`, `GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS`, `GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS`, `GL_MAX_GEOMETRY_ATOMIC_COUNTERS`, `GL_MAX_FRAMGENT_ATOMIC_COUNTERS`, and `GL_MIN_MAP_BUFFER_ALIGNMENT` are accepted by *`pname`* only if the GL version is 4.2 or greater.\n\n`GL_MAX_ELEMENT_INDEX` is accepted by *`pname`* only if the GL version is 4.3 or greater.\n\n`GL_MAX_COMPUTE_UNIFORM_BLOCKS`, `GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS`, `GL_MAX_COMPUTE_UNIFORM_COMPONENTS`, `GL_MAX_COMPUTE_ATOMIC_COUNTERS`, `GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS`, `GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS`, `GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS`, `GL_MAX_COMPUTE_WORK_GROUP_COUNT`, and `GL_MAX_COMPUTE_WORK_GROUP_SIZE` and `GL_DISPATCH_INDIRECT_BUFFER_BINDING` are available only if the GL version is 4.3 or greater.\n\n`GL_MAX_DEBUG_GROUP_STACK_DEPTH`, `GL_DEBUG_GROUP_STACK_DEPTH` and `GL_MAX_LABEL_LENGTH` are accepted only if the GL version is 4.3 or greater.\n\n`GL_MAX_UNIFORM_LOCATIONS` is accepted only if the GL version is 4.3 or greater.\n\n`GL_MAX_FRAMEBUFFER_WIDTH`, `GL_MAX_FRAMEBUFFER_HEIGHT`, `GL_MAX_FRAMEBUFFER_LAYERS`, and `GL_MAX_FRAMEBUFFER_SAMPLES` are available only if the GL version is 4.3 or greater.\n\n`GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS`, `GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS`, `GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS`, `GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS`, `GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS`, and `GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS` are available only if the GL version is 4.3 or higher.\n\n`GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT` is available only if the GL version is 4.3 or greater.\n\n`GL_VERTEX_BINDING_DIVISOR`, `GL_VERTEX_BINDING_OFFSET`, `GL_VERTEX_BINDING_STRIDE`, `GL_VERTEX_BINDING_BUFFER`, `GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET` and `GL_MAX_VERTEX_ATTRIB_BINDINGS` are available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated on any of `glGetBooleani_v`, `glGetIntegeri_v`, or `glGetInteger64i_v` if *`index`* is outside of the valid range for the indexed state *`target`*.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetBooleani_v`             |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetBooleanv`               |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetDoublei_v`              |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetDoublev`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetFloati_v`               |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetFloatv`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetInteger64i_v`           |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetInteger64v`             |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetIntegeri_v`             |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetIntegerv`               |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGetActiveUniform](glgetactiveuniform.xhtml), [glGetAttachedShaders](glgetattachedshaders.xhtml), [glGetAttribLocation](glgetattriblocation.xhtml), [glGetBufferParameter](glgetbufferparameter.xhtml), [glGetBufferPointerv](glgetbufferpointerv.xhtml), [glGetBufferSubData](glgetbuffersubdata.xhtml), [glGetCompressedTexImage](glgetcompressedteximage.xhtml), [glGetError](glgeterror.xhtml), [glGetProgram](glgetprogram.xhtml), [glGetProgramInfoLog](glgetprograminfolog.xhtml), [glGetQueryiv](glgetqueryiv.xhtml), [glGetQueryObject](glgetqueryobject.xhtml), [glGetShader](glgetshader.xhtml), [glGetShaderInfoLog](glgetshaderinfolog.xhtml), [glGetShaderSource](glgetshadersource.xhtml), [glGetString](glgetstring.xhtml), [glGetTexImage](glgetteximage.xhtml), [glGetTexLevelParameter](glgettexlevelparameter.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glGetUniform](glgetuniform.xhtml), [glGetUniformLocation](glgetuniformlocation.xhtml), [glGetVertexAttrib](glgetvertexattrib.xhtml), [glGetVertexAttribPointerv](glgetvertexattribpointerv.xhtml), [glIsEnabled](glisenabled.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGet.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGet.xhtml)"
- name: glGetInteger64v
  id: glget.xhtml#glGetInteger64v
  summary: null
  belongs_to: glGet
  description: '`void `**`glGetInteger64v`**`(` GLenum `pname`, GLint64 \* `data``)`;'
- name: glGetIntegeri_v
  id: glget.xhtml#glGetIntegeri_v
  summary: null
  belongs_to: glGet
  description: '`void `**`glGetIntegeri_v`**`(` GLenum `target`, GLuint `index`, GLint \* `data``)`;'
- name: glGetIntegerv
  id: glget.xhtml#glGetIntegerv
  summary: null
  belongs_to: glGet
  description: '`void `**`glGetIntegerv`**`(` GLenum `pname`, GLint \* `data``)`;'
- name: glGetInternalformat
  id: glgetinternalformat.xhtml
  summary: target Indicates the usage of the internal format
  description: "## Name\n\nglGetInternalformat — retrieve information about implementation-dependent support for internal formats\n\n## C Specification\n\n`void `**`glGetInternalformativ`**`(` GLenum `target`, GLenum `internalformat`, GLenum `pname`, GLsizei `bufSize`, GLint \\*`params``)`;\n\n`void `**`glGetInternalformati64v`**`(` GLenum `target`, GLenum `internalformat`, GLenum `pname`, GLsizei `bufSize`, GLint64 \\*`params``)`;\n\n## Parameters\n\n *`target`*  \nIndicates the usage of the internal format. *`target`* must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_RENDERBUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n *`internalformat`*  \nSpecifies the internal format about which to retrieve information.\n\n *`pname`*  \nSpecifies the type of information to query.\n\n *`bufSize`*  \nSpecifies the maximum number of integers of the specified width that may be written to *`params`* by the function.\n\n *`params`*  \nSpecifies the address of a variable into which to write the retrieved information.\n\n## Description\n\n`glGetInternalformativ` and `glGetInternalformati64v` retrieve information about implementation-dependent support for internal formats. *`target`* indicates the target with which the internal format will be used and must be one of `GL_RENDERBUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, corresponding to usage as a renderbuffer, two-dimensional multisample texture or two-dimensional multisample array texture, respectively.\n\n*`internalformat`* specifies the internal format about which to retrieve information and must be a color-renderable, depth-renderable or stencil-renderable format.\n\nThe information retrieved will be written to memory addressed by the pointer specified in *`params`*. No more than *`bufSize`* integers will be written to this memory.\n\nIf *`pname`* is `GL_NUM_SAMPLE_COUNTS`, the number of sample counts that would be returned by querying `GL_SAMPLES` will be returned in *`params`*.\n\nIf *`pname`* is `GL_SAMPLES`, the sample counts supported for *`internalformat`* and *`target`* are written into *`params`* in descending numeric order. Only positive values are returned. Querying `GL_SAMPLES` with *`bufSize`* of one will return just the maximum supported number of samples for this format. The maximum value in `GL_SAMPLES` is guaranteed to be at least the lowest of the following:\n\n- The value of `GL_MAX_INTEGER_SAMPLES` if *`internalformat`* is a signed or unsigned integer format.\n\n- The value of `GL_MAX_DEPTH_TEXTURE_SAMPLES` if *`internalformat`* is a depth- or stencil-renderable format and *`target`* is `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n- The value of `GL_MAX_COLOR_TEXTURE_SAMPLES` if *`internalformat`* is a color-renderable format and *`target`* is `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n- The value of `GL_MAX_SAMPLES`.\n\nIf *`pname`* is `GL_INTERNALFORMAT_SUPPORTED`, *`params`* is set to `GL_TRUE` if *`internalformat`* is a supported internal format for *`target`* and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_INTERNALFORMAT_PREFERRED`, *`params`* is set to `GL_TRUE` if *`internalformat`* is an format for *`target`* that is preferred by the implementation and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_INTERNALFORMAT_RED_SIZE`, `GL_INTERNALFORMAT_GREEN_SIZE`, `GL_INTERNALFORMAT_BLUE_SIZE`, `GL_INTERNALFORMAT_ALPHA_SIZE`, `GL_INTERNALFORMAT_DEPTH_SIZE`, `GL_INTERNALFORMAT_STENCIL_SIZE`, or `GL_INTERNALFORMAT_SHARED_SIZE` then *`params`* is set to the actual resolutions that would be used for storing image array components for the resource for the red, green, blue, alpha, depth, stencil and shared channels respectively. If *`internalformat`* is a compressed internal format, then *`params`* is set to the component resolution of an uncompressed internal format that produces an image of roughly the same quality as the compressed algorithm. If the internal format is unsupported, or if a particular component is not present in the format, 0 is written to *`params`*.\n\nIf *`pname`* is `GL_INTERNALFORMAT_RED_TYPE`, `GL_INTERNALFORMAT_GREEN_TYPE`, `GL_INTERNALFORMAT_BLUE_TYPE`, `GL_INTERNALFORMAT_ALPHA_TYPE`, `GL_INTERNALFORMAT_DEPTH_TYPE`, or `GL_INTERNALFORMAT_STENCIL_TYPE` then *`params`* is set to a token identifying the data type used to store the respective component. If the *`internalformat`* represents a compressed internal format then the types returned specify how components are interpreted after decompression.\n\nIf *`pname`* is `GL_MAX_WIDTH`, `GL_MAX_HEIGHT`, `GL_MAX_DEPTH`, or `GL_MAX_LAYERS` then *`pname`* is filled with the maximum width, height, depth or layer count for textures with internal format *`internalformat`*, respectively. If *`pname`* is `GL_MAX_COMBINED_DIMENSIONS` then *`pname`* is filled with the maximum combined dimensions of a texture of the specified internal format.\n\nIf *`pname`* is `GL_COLOR_COMPONENTS` then *`params`* is set to the value `GL_TRUE` if the internal format contains any color component (i.e., red, green, blue or alpha) and to `GL_FALSE` otherwise. If *`pname`* is `GL_DEPTH_COMPONENTS` or `GL_STENCIL_COMPONENTS` then *`params`* is set to `GL_TRUE` if the internal format contains a depth or stencil component, respectively, and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_COLOR_RENDERABLE`, `GL_DEPTH_RENDERABLE` or `GL_STENCIL_RENDERABLE` then *`params`* is set to `GL_TRUE` if the specified internal format is color, depth or stencil renderable, respectively, and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_FRAMEBUFFER_RENDERABLE` or `GL_FRAMEBUFFER_RENDERABLE_LAYERED` then *`params`* is set to one of `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate that framebuffer attachments (layered attachments in the case of `GL_FRAMEBUFFER_RENDERABLE_LAYERED`) with that internal format are either renderable with no restrictions, renderable with some restrictions or not renderable at all.\n\nIf *`pname`* is `GL_FRAMEBUFFER_BLEND`, *`params`* is set to `GL_TRUE` to indicate that the internal format is supported for blending operations when attached to a framebuffer, and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_READ_PIXELS` then *`params`* is set to `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to that either full support, limited support or no support at all is supplied for reading pixels from framebuffer attachments in the specified internal format.\n\nIf *`pname`* is `GL_READ_PIXELS_FORMAT` or `GL_READ_PIXELS_TYPE` then *`params`* is filled with the format or type, respectively, most recommended to obtain the highest image quality and performance. For `GL_READ_PIXELS_FORMAT`, the value returned in *`params`* is a token that is accepted for the *`format`* argument to [glReadPixels](glreadpixels.xhtml). For `GL_READ_PIXELS_TYPE`, the value returned in *`params`* is a token that is accepted for the *`type`* argument to [glReadPixels](glreadpixels.xhtml).\n\nIf *`pname`* is `GL_TEXTURE_IMAGE_FORMAT` or `GL_TEXTURE_IMAGE_TYPE` then *`params`* is filled with the implementation-recommended format or type to be used in calls to [glTexImage2D](glteximage2d.xhtml) and other similar functions. For `GL_TEXTURE_IMAGE_FORMAT`, *`params`* is filled with a token suitable for use as the *`format`* argument to [glTexImage2D](glteximage2d.xhtml). For `GL_TEXTURE_IMAGE_TYPE`, *`params`* is filled with a token suitable for use as the *`type`* argument to [glTexImage2D](glteximage2d.xhtml).\n\nIf *`pname`* is `GL_GET_TEXTURE_IMAGE_FORMAT` or `GL_GET_TEXTURE_IMAGE_TYPE` then *`params`* is filled with the implementation-recommended format or type to be used in calls to [glGetTexImage](glgetteximage.xhtml) and other similar functions. For `GL_GET_TEXTURE_IMAGE_FORMAT`, *`params`* is filled with a token suitable for use as the *`format`* argument to [glGetTexImage](glgetteximage.xhtml). For `GL_GET_TEXTURE_IMAGE_TYPE`, *`params`* is filled with a token suitable for use as the *`type`* argument to [glGetTexImage](glgetteximage.xhtml).\n\nIf *`pname`* is `GL_MIPMAP` then *`pname`* is set to `GL_TRUE` to indicate that the specified internal format supports mipmaps and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_GENERATE_MIPMAP` or `GL_AUTO_GENERATE_MIPMAP` then *`params`* is indicates the level of support for manual or automatic mipmap generation for the specified internal format, respectively. Returned values may be one of `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` and `GL_NONE` to indicate either full support, limited support or no support at all.\n\nIf *`pname`* is `GL_COLOR_ENCODING` then the color encoding for the resource is returned in *`params`*. Possible values for color buffers are `GL_LINEAR` or `GL_SRGB`, for linear or sRGB-encoded color components, respectively. For non-color formats (such as depth or stencil), or for unsupported resources, the value `GL_NONE` is returned.\n\nIf *`pname`* is `GL_SRGB_READ`, or `GL_SRGB_WRITE` then *`params`* indicates the level of support for reading and writing to sRGB encoded images, respectively. For `GL_SRGB_READ`, support for converting from sRGB colorspace on read operations is returned in *`params`* and for `GL_SRGB_WRITE`, support for converting to sRGB colorspace on write operations to the resource is returned in *`params`*. *`params`* may be set to `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all, respecitively.\n\nIf *`pname`* is `GL_FILTER` the *`params`* is set to either `GL_TRUE` or `GL_FALSE` to indicate support or lack thereof for filter modes other than `GL_NEAREST` or `GL_NEAREST_MIPMAP` for the specified internal format.\n\nIf *`pname`* is `GL_VERTEX_TEXTURE`, `GL_TESS_CONTROL_TEXTURE`, `GL_TESS_EVALUATION_TEXTURE`, `GL_GEOMETRY_TEXTURE`, `GL_FRAGMENT_TEXTURE`, or `GL_COMPUTE_TEXTURE`, then the value written to *`params`* indicates support for use of the resource as a source of texturing in the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages, respectively. *`params`* may be set to `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate full support, limited support or no support at all, respectively.\n\nIf *`pname`* is `GL_TEXTURE_SHADOW`, `GL_TEXTURE_GATHER` or `GL_TEXTURE_GATHER_SHADOW` then the value written to *`params`* indicates the level of support for using the resource with a shadow sampler, in gather operations or as a shadow sampler in gather operations, respectively. Returned values may be `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate full support, limited support or no support at all, respectively.\n\nIf *`pname`* is `GL_SHADER_IMAGE_LOAD`, `GL_SHADER_IMAGE_STORE` or `GL_SHADER_IMAGE_ATOMIC` then the value returned in *`params`* indicates the level of support for image loads, stores and atomics for resources of the specified internal format. Returned values may be `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate full support, limited support or no support at all, respectively.\n\nIf *`pname`* is `GL_IMAGE_TEXEL_SIZE` then the size of a texel when the resource when used as an image texture is returned in *`params`*. If the resource is not supported for image textures zero is returned.\n\nIf *`pname`* is `GL_IMAGE_COMPATIBILITY_CLASS` then the compatibility class of the resource when used as an image texture is returned in *`params`*. The possible values returned are `GL_IMAGE_CLASS_4_X_32`, `GL_IMAGE_CLASS_2_X_32`, `GL_IMAGE_CLASS_1_X_32`, `GL_IMAGE_CLASS_4_X_16`, `GL_IMAGE_CLASS_2_X_16`, `GL_IMAGE_CLASS_1_X_16`, `GL_IMAGE_CLASS_4_X_8`, `GL_IMAGE_CLASS_2_X_8`, `GL_IMAGE_CLASS_1_X_8`, `GL_IMAGE_CLASS_11_11_10`, and `GL_IMAGE_CLASS_10_10_10_2`, which correspond to the 4x32, 2x32, 1x32, 4x16, 2x16, 1x16, 4x8, 2x8, 1x8, the class (a) 11/11/10 packed floating-point format, and the class (b) 10/10/10/2 packed formats, respectively. If the resource is not supported for image textures, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_IMAGE_PIXEL_FORMAT` or `GL_IMAGE_PIXEL_TYPE` then the pixel format or type of the resource when used as an image texture is returned in *`params`*, respectively. In either case, the resource is not supported for image textures `GL_NONE` is returned.\n\nIf *`pname`* is `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, the matching criteria use for the resource when used as an image textures is returned in *`params`*. Possible values returned in *`params`* are `GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE` or `GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS`. If the resource is not supported for image textures, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST` or `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST`, support for using the resource both as a source for texture sampling while it is bound as a buffer for depth or stencil test, respectively, is written to *`params`*. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all. If the resource or operation is not supported, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE` or `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE`, support for using the resource both as a source for texture sampling while performing depth or stencil writes to the resources, respectively, is written to *`params`*. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all. If the resource or operation is not supported, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_TEXTURE_COMPRESSED` then `GL_TRUE` is returned in *`params`* if *`internalformat`* is a compressed internal format. `GL_FALSE` is returned in *`params`* otherwise.\n\nIf *`pname`* is `GL_TEXTURE_COMPRESSED_BLOCK_WIDTH`, `GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT` or `GL_TEXTURE_COMPRESSED_BLOCK_SIZE` then the width, height or total size, respectively of a block (in basic machine units) is returned in *`params`*. If the internal format is not compressed, or the resource is not supported, 0 is returned.\n\nIf *`pname`* is `GL_CLEAR_BUFFER`, the level of support for using the resource with [glClearBufferData](glclearbufferdata.xhtml) and [glClearBufferSubData](glclearbuffersubdata.xhtml) is returned in *`params`*. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_TEXTURE_VIEW`, the level of support for using the resource with the [glTextureView](gltextureview.xhtml) command is returned in *`params`*. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_VIEW_COMPATIBILITY_CLASS` then the compatibility class of the resource when used as a texture view is returned in *`params`*. The possible values returned are `GL_VIEW_CLASS_128_BITS`, `GL_VIEW_CLASS_96_BITS`, `GL_VIEW_CLASS_64_BITS`, `GL_VIEW_CLASS_48_BITS`, `GL_VIEW_CLASS_32_BITS`, `GL_VIEW_CLASS_24_BITS`, `GL_VIEW_CLASS_16_BITS`, `GL_VIEW_CLASS_8_BITS`, `GL_VIEW_CLASS_S3TC_DXT1_RGB`, `GL_VIEW_CLASS_S3TC_DXT1_RGBA`, `GL_VIEW_CLASS_S3TC_DXT3_RGBA`, `GL_VIEW_CLASS_S3TC_DXT5_RGBA`, `GL_VIEW_CLASS_RGTC1_RED`, `GL_VIEW_CLASS_RGTC2_RG`, `GL_VIEW_CLASS_BPTC_UNORM`, and `GL_VIEW_CLASS_BPTC_FLOAT`.\n\nIf *`pname`* is `GL_CLEAR_TEXTURE` then the presence of support for using the [glClearTexImage](glclearteximage.xhtml) and [glClearTexSubImage](glcleartexsubimage.xhtml) commands with the resource is written to *`params`*. Possible values written are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, `GL_NONE` is returned.\n\n## Notes\n\n`glGetInternalformativ` is available only if the GL version is 4.2 or higher.\n\nThe tokens `GL_INTERNALFORMAT_SUPPORTED`, `GL_INTERNALFORMAT_PREFERRED`, `GL_INTERNALFORMAT_RED_SIZE`, `GL_INTERNALFORMAT_GREEN_SIZE`, `GL_INTERNALFORMAT_BLUE_SIZE`, `GL_INTERNALFORMAT_ALPHA_SIZE`, `GL_INTERNALFORMAT_DEPTH_SIZE`, `GL_INTERNALFORMAT_STENCIL_SIZE`, `GL_INTERNALFORMAT_SHARED_SIZE`, `GL_INTERNALFORMAT_RED_TYPE`, `GL_INTERNALFORMAT_GREEN_TYPE`, `GL_INTERNALFORMAT_BLUE_TYPE`, `GL_INTERNALFORMAT_ALPHA_TYPE`, `GL_INTERNALFORMAT_DEPTH_TYPE`, `GL_INTERNALFORMAT_STENCIL_TYPE`, `GL_MAX_WIDTH`, `GL_MAX_HEIGHT`, `GL_MAX_DEPTH`, `GL_MAX_LAYERS`, `GL_MAX_COMBINED_DIMENSIONS`, `GL_COLOR_COMPONENTS`, `GL_DEPTH_COMPONENTS`, `GL_STENCIL_COMPONENTS`, `GL_COLOR_RENDERABLE`, `GL_DEPTH_RENDERABLE`, `GL_STENCIL_RENDERABLE`, `GL_FRAMEBUFFER_RENDERABLE`, `GL_FRAMEBUFFER_RENDERABLE_LAYERED`, `GL_FRAMEBUFFER_BLEND`, `GL_READ_PIXELS`, `GL_READ_PIXELS_FORMAT`, `GL_READ_PIXELS_TYPE`, `GL_TEXTURE_IMAGE_FORMAT`, `GL_TEXTURE_IMAGE_TYPE`, `GL_GET_TEXTURE_IMAGE_FORMAT`, `GL_GET_TEXTURE_IMAGE_TYPE`, `GL_MIPMAP`, `GL_GENERATE_MIPMAP`, `GL_AUTO_GENERATE_MIPMAP`, `GL_COLOR_ENCODING`, `GL_SRGB_READ`, `GL_SRGB_WRITE`, `GL_SRGB_DECODE_ARB`, `GL_FILTER`, `GL_VERTEX_TEXTURE`, `GL_TESS_CONTROL_TEXTURE`, `GL_TESS_EVALUATION_TEXTURE`, `GL_GEOMETRY_TEXTURE`, `GL_FRAGMENT_TEXTURE`, `GL_COMPUTE_TEXTURE`, `GL_TEXTURE_SHADOW`, `GL_TEXTURE_GATHER`, `GL_TEXTURE_GATHER_SHADOW`, `GL_SHADER_IMAGE_LOAD`, `GL_SHADER_IMAGE_STORE`, `GL_SHADER_IMAGE_ATOMIC`, `GL_IMAGE_TEXEL_SIZE`, `GL_IMAGE_COMPATIBILITY_CLASS`, `GL_IMAGE_PIXEL_FORMAT`, `GL_IMAGE_PIXEL_TYPE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST`, `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST`, `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE`, `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_BLOCK_WIDTH`, `GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT`, `GL_TEXTURE_COMPRESSED_BLOCK_SIZE`, `GL_CLEAR_BUFFER`, `GL_TEXTURE_VIEW`, and `GL_VIEW_COMPATIBILITY_CLASS` are supported only if the GL version is 4.3 or higher.\n\nThe `GL_CLEAR_TEXTURE` token is accepted for *`pname`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is negative.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not `GL_SAMPLES` or `GL_NUM_SAMPLE_COUNTS`.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not color-, depth-, or stencil-renderable.\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_RENDERBUFFER`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetInternalformati64v`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glGetInternalformativ`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGet](glget.xhtml)\n\n## Copyright\n\nCopyright © 2011-2018 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2018 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetInternalformat.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetInternalformat.xhtml)"
- name: glGetInternalformati64v
  id: glgetinternalformat.xhtml#glGetInternalformati64v
  summary: Indicates the usage of the internal format
  belongs_to: glGetInternalformat
  description: "`void `**`glGetInternalformati64v`**`(` GLenum `target`, GLenum `internalformat`, GLenum `pname`, GLsizei `bufSize`, GLint64 \\*`params``)`;\n\n## Parameters\n\n*`target`*\n\nIndicates the usage of the internal format. *`target`* must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_RENDERBUFFER`, `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n*`internalformat`*\n\nSpecifies the internal format about which to retrieve information.\n\n*`pname`*\n\nSpecifies the type of information to query.\n\n*`bufSize`*\n\nSpecifies the maximum number of integers of the specified width that may be written to *`params`* by the function.\n\n*`params`*\n\nSpecifies the address of a variable into which to write the retrieved information.\n\n## Description\n\n`glGetInternalformativ` and `glGetInternalformati64v` retrieve information about implementation-dependent support for internal formats. *`target`* indicates the target with which the internal format will be used and must be one of `GL_RENDERBUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, corresponding to usage as a renderbuffer, two-dimensional multisample texture or two-dimensional multisample array texture, respectively.\n\n*`internalformat`* specifies the internal format about which to retrieve information and must be a color-renderable, depth-renderable or stencil-renderable format.\n\nThe information retrieved will be written to memory addressed by the pointer specified in *`params`*. No more than *`bufSize`* integers will be written to this memory.\n\nIf *`pname`* is `GL_NUM_SAMPLE_COUNTS`, the number of sample counts that would be returned by querying `GL_SAMPLES` will be returned in *`params`*.\n\nIf *`pname`* is `GL_SAMPLES`, the sample counts supported for *`internalformat`* and *`target`* are written into *`params`* in descending numeric order. Only positive values are returned. Querying `GL_SAMPLES` with *`bufSize`* of one will return just the maximum supported number of samples for this format. The maximum value in `GL_SAMPLES` is guaranteed to be at least the lowest of the following:\n\n- The value of `GL_MAX_INTEGER_SAMPLES` if *`internalformat`* is a signed or unsigned integer format.\n\n- The value of `GL_MAX_DEPTH_TEXTURE_SAMPLES` if *`internalformat`* is a depth- or stencil-renderable format and *`target`* is `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n- The value of `GL_MAX_COLOR_TEXTURE_SAMPLES` if *`internalformat`* is a color-renderable format and *`target`* is `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n- The value of `GL_MAX_SAMPLES`.\n\nIf *`pname`* is `GL_INTERNALFORMAT_SUPPORTED`, *`params`* is set to `GL_TRUE` if *`internalformat`* is a supported internal format for *`target`* and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_INTERNALFORMAT_PREFERRED`, *`params`* is set to `GL_TRUE` if *`internalformat`* is an format for *`target`* that is preferred by the implementation and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_INTERNALFORMAT_RED_SIZE`, `GL_INTERNALFORMAT_GREEN_SIZE`, `GL_INTERNALFORMAT_BLUE_SIZE`, `GL_INTERNALFORMAT_ALPHA_SIZE`, `GL_INTERNALFORMAT_DEPTH_SIZE`, `GL_INTERNALFORMAT_STENCIL_SIZE`, or `GL_INTERNALFORMAT_SHARED_SIZE` then *`params`* is set to the actual resolutions that would be used for storing image array components for the resource for the red, green, blue, alpha, depth, stencil and shared channels respectively. If *`internalformat`* is a compressed internal format, then *`params`* is set to the component resolution of an uncompressed internal format that produces an image of roughly the same quality as the compressed algorithm. If the internal format is unsupported, or if a particular component is not present in the format, 0 is written to *`params`*.\n\nIf *`pname`* is `GL_INTERNALFORMAT_RED_TYPE`, `GL_INTERNALFORMAT_GREEN_TYPE`, `GL_INTERNALFORMAT_BLUE_TYPE`, `GL_INTERNALFORMAT_ALPHA_TYPE`, `GL_INTERNALFORMAT_DEPTH_TYPE`, or `GL_INTERNALFORMAT_STENCIL_TYPE` then *`params`* is set to a token identifying the data type used to store the respective component. If the *`internalformat`* represents a compressed internal format then the types returned specify how components are interpreted after decompression.\n\nIf *`pname`* is `GL_MAX_WIDTH`, `GL_MAX_HEIGHT`, `GL_MAX_DEPTH`, or `GL_MAX_LAYERS` then *`pname`* is filled with the maximum width, height, depth or layer count for textures with internal format *`internalformat`*, respectively. If *`pname`* is `GL_MAX_COMBINED_DIMENSIONS` then *`pname`* is filled with the maximum combined dimensions of a texture of the specified internal format.\n\nIf *`pname`* is `GL_COLOR_COMPONENTS` then *`params`* is set to the value `GL_TRUE` if the internal format contains any color component (i.e., red, green, blue or alpha) and to `GL_FALSE` otherwise. If *`pname`* is `GL_DEPTH_COMPONENTS` or `GL_STENCIL_COMPONENTS` then *`params`* is set to `GL_TRUE` if the internal format contains a depth or stencil component, respectively, and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_COLOR_RENDERABLE`, `GL_DEPTH_RENDERABLE` or `GL_STENCIL_RENDERABLE` then *`params`* is set to `GL_TRUE` if the specified internal format is color, depth or stencil renderable, respectively, and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_FRAMEBUFFER_RENDERABLE` or `GL_FRAMEBUFFER_RENDERABLE_LAYERED` then *`params`* is set to one of `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate that framebuffer attachments (layered attachments in the case of `GL_FRAMEBUFFER_RENDERABLE_LAYERED`) with that internal format are either renderable with no restrictions, renderable with some restrictions or not renderable at all.\n\nIf *`pname`* is `GL_FRAMEBUFFER_BLEND`, *`params`* is set to `GL_TRUE` to indicate that the internal format is supported for blending operations when attached to a framebuffer, and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_READ_PIXELS` then *`params`* is set to `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to that either full support, limited support or no support at all is supplied for reading pixels from framebuffer attachments in the specified internal format.\n\nIf *`pname`* is `GL_READ_PIXELS_FORMAT` or `GL_READ_PIXELS_TYPE` then *`params`* is filled with the format or type, respectively, most recommended to obtain the highest image quality and performance. For `GL_READ_PIXELS_FORMAT`, the value returned in *`params`* is a token that is accepted for the *`format`* argument to [glReadPixels](glreadpixels.xhtml). For `GL_READ_PIXELS_TYPE`, the value returned in *`params`* is a token that is accepted for the *`type`* argument to [glReadPixels](glreadpixels.xhtml).\n\nIf *`pname`* is `GL_TEXTURE_IMAGE_FORMAT` or `GL_TEXTURE_IMAGE_TYPE` then *`params`* is filled with the implementation-recommended format or type to be used in calls to [glTexImage2D](glteximage2d.xhtml) and other similar functions. For `GL_TEXTURE_IMAGE_FORMAT`, *`params`* is filled with a token suitable for use as the *`format`* argument to [glTexImage2D](glteximage2d.xhtml). For `GL_TEXTURE_IMAGE_TYPE`, *`params`* is filled with a token suitable for use as the *`type`* argument to [glTexImage2D](glteximage2d.xhtml).\n\nIf *`pname`* is `GL_GET_TEXTURE_IMAGE_FORMAT` or `GL_GET_TEXTURE_IMAGE_TYPE` then *`params`* is filled with the implementation-recommended format or type to be used in calls to [glGetTexImage](glgetteximage.xhtml) and other similar functions. For `GL_GET_TEXTURE_IMAGE_FORMAT`, *`params`* is filled with a token suitable for use as the *`format`* argument to [glGetTexImage](glgetteximage.xhtml). For `GL_GET_TEXTURE_IMAGE_TYPE`, *`params`* is filled with a token suitable for use as the *`type`* argument to [glGetTexImage](glgetteximage.xhtml).\n\nIf *`pname`* is `GL_MIPMAP` then *`pname`* is set to `GL_TRUE` to indicate that the specified internal format supports mipmaps and to `GL_FALSE` otherwise.\n\nIf *`pname`* is `GL_GENERATE_MIPMAP` or `GL_AUTO_GENERATE_MIPMAP` then *`params`* is indicates the level of support for manual or automatic mipmap generation for the specified internal format, respectively. Returned values may be one of `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` and `GL_NONE` to indicate either full support, limited support or no support at all.\n\nIf *`pname`* is `GL_COLOR_ENCODING` then the color encoding for the resource is returned in *`params`*. Possible values for color buffers are `GL_LINEAR` or `GL_SRGB`, for linear or sRGB-encoded color components, respectively. For non-color formats (such as depth or stencil), or for unsupported resources, the value `GL_NONE` is returned.\n\nIf *`pname`* is `GL_SRGB_READ`, or `GL_SRGB_WRITE` then *`params`* indicates the level of support for reading and writing to sRGB encoded images, respectively. For `GL_SRGB_READ`, support for converting from sRGB colorspace on read operations is returned in *`params`* and for `GL_SRGB_WRITE`, support for converting to sRGB colorspace on write operations to the resource is returned in *`params`*. *`params`* may be set to `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all, respecitively.\n\nIf *`pname`* is `GL_FILTER` the *`params`* is set to either `GL_TRUE` or `GL_FALSE` to indicate support or lack thereof for filter modes other than `GL_NEAREST` or `GL_NEAREST_MIPMAP` for the specified internal format.\n\nIf *`pname`* is `GL_VERTEX_TEXTURE`, `GL_TESS_CONTROL_TEXTURE`, `GL_TESS_EVALUATION_TEXTURE`, `GL_GEOMETRY_TEXTURE`, `GL_FRAGMENT_TEXTURE`, or `GL_COMPUTE_TEXTURE`, then the value written to *`params`* indicates support for use of the resource as a source of texturing in the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages, respectively. *`params`* may be set to `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate full support, limited support or no support at all, respectively.\n\nIf *`pname`* is `GL_TEXTURE_SHADOW`, `GL_TEXTURE_GATHER` or `GL_TEXTURE_GATHER_SHADOW` then the value written to *`params`* indicates the level of support for using the resource with a shadow sampler, in gather operations or as a shadow sampler in gather operations, respectively. Returned values may be `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate full support, limited support or no support at all, respectively.\n\nIf *`pname`* is `GL_SHADER_IMAGE_LOAD`, `GL_SHADER_IMAGE_STORE` or `GL_SHADER_IMAGE_ATOMIC` then the value returned in *`params`* indicates the level of support for image loads, stores and atomics for resources of the specified internal format. Returned values may be `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT` or `GL_NONE` to indicate full support, limited support or no support at all, respectively.\n\nIf *`pname`* is `GL_IMAGE_TEXEL_SIZE` then the size of a texel when the resource when used as an image texture is returned in *`params`*. If the resource is not supported for image textures zero is returned.\n\nIf *`pname`* is `GL_IMAGE_COMPATIBILITY_CLASS` then the compatibility class of the resource when used as an image texture is returned in *`params`*. The possible values returned are `GL_IMAGE_CLASS_4_X_32`, `GL_IMAGE_CLASS_2_X_32`, `GL_IMAGE_CLASS_1_X_32`, `GL_IMAGE_CLASS_4_X_16`, `GL_IMAGE_CLASS_2_X_16`, `GL_IMAGE_CLASS_1_X_16`, `GL_IMAGE_CLASS_4_X_8`, `GL_IMAGE_CLASS_2_X_8`, `GL_IMAGE_CLASS_1_X_8`, `GL_IMAGE_CLASS_11_11_10`, and `GL_IMAGE_CLASS_10_10_10_2`, which correspond to the 4x32, 2x32, 1x32, 4x16, 2x16, 1x16, 4x8, 2x8, 1x8, the class (a) 11/11/10 packed floating-point format, and the class (b) 10/10/10/2 packed formats, respectively. If the resource is not supported for image textures, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_IMAGE_PIXEL_FORMAT` or `GL_IMAGE_PIXEL_TYPE` then the pixel format or type of the resource when used as an image texture is returned in *`params`*, respectively. In either case, the resource is not supported for image textures `GL_NONE` is returned.\n\nIf *`pname`* is `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, the matching criteria use for the resource when used as an image textures is returned in *`params`*. Possible values returned in *`params`* are `GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE` or `GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS`. If the resource is not supported for image textures, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST` or `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST`, support for using the resource both as a source for texture sampling while it is bound as a buffer for depth or stencil test, respectively, is written to *`params`*. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all. If the resource or operation is not supported, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE` or `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE`, support for using the resource both as a source for texture sampling while performing depth or stencil writes to the resources, respectively, is written to *`params`*. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all. If the resource or operation is not supported, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_TEXTURE_COMPRESSED` then `GL_TRUE` is returned in *`params`* if *`internalformat`* is a compressed internal format. `GL_FALSE` is returned in *`params`* otherwise.\n\nIf *`pname`* is `GL_TEXTURE_COMPRESSED_BLOCK_WIDTH`, `GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT` or `GL_TEXTURE_COMPRESSED_BLOCK_SIZE` then the width, height or total size, respectively of a block (in basic machine units) is returned in *`params`*. If the internal format is not compressed, or the resource is not supported, 0 is returned.\n\nIf *`pname`* is `GL_CLEAR_BUFFER`, the level of support for using the resource with [glClearBufferData](glclearbufferdata.xhtml) and [glClearBufferSubData](glclearbuffersubdata.xhtml) is returned in *`params`*. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_TEXTURE_VIEW`, the level of support for using the resource with the [glTextureView](gltextureview.xhtml) command is returned in *`params`*. Possible values returned are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, `GL_NONE` is returned.\n\nIf *`pname`* is `GL_VIEW_COMPATIBILITY_CLASS` then the compatibility class of the resource when used as a texture view is returned in *`params`*. The possible values returned are `GL_VIEW_CLASS_128_BITS`, `GL_VIEW_CLASS_96_BITS`, `GL_VIEW_CLASS_64_BITS`, `GL_VIEW_CLASS_48_BITS`, `GL_VIEW_CLASS_32_BITS`, `GL_VIEW_CLASS_24_BITS`, `GL_VIEW_CLASS_16_BITS`, `GL_VIEW_CLASS_8_BITS`, `GL_VIEW_CLASS_S3TC_DXT1_RGB`, `GL_VIEW_CLASS_S3TC_DXT1_RGBA`, `GL_VIEW_CLASS_S3TC_DXT3_RGBA`, `GL_VIEW_CLASS_S3TC_DXT5_RGBA`, `GL_VIEW_CLASS_RGTC1_RED`, `GL_VIEW_CLASS_RGTC2_RG`, `GL_VIEW_CLASS_BPTC_UNORM`, and `GL_VIEW_CLASS_BPTC_FLOAT`.\n\nIf *`pname`* is `GL_CLEAR_TEXTURE` then the presence of support for using the [glClearTexImage](glclearteximage.xhtml) and [glClearTexSubImage](glcleartexsubimage.xhtml) commands with the resource is written to *`params`*. Possible values written are `GL_FULL_SUPPORT`, `GL_CAVEAT_SUPPORT`, or `GL_NONE` to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, `GL_NONE` is returned.\n\n## Notes\n\n`glGetInternalformativ` is available only if the GL version is 4.2 or higher.\n\nThe tokens `GL_INTERNALFORMAT_SUPPORTED`, `GL_INTERNALFORMAT_PREFERRED`, `GL_INTERNALFORMAT_RED_SIZE`, `GL_INTERNALFORMAT_GREEN_SIZE`, `GL_INTERNALFORMAT_BLUE_SIZE`, `GL_INTERNALFORMAT_ALPHA_SIZE`, `GL_INTERNALFORMAT_DEPTH_SIZE`, `GL_INTERNALFORMAT_STENCIL_SIZE`, `GL_INTERNALFORMAT_SHARED_SIZE`, `GL_INTERNALFORMAT_RED_TYPE`, `GL_INTERNALFORMAT_GREEN_TYPE`, `GL_INTERNALFORMAT_BLUE_TYPE`, `GL_INTERNALFORMAT_ALPHA_TYPE`, `GL_INTERNALFORMAT_DEPTH_TYPE`, `GL_INTERNALFORMAT_STENCIL_TYPE`, `GL_MAX_WIDTH`, `GL_MAX_HEIGHT`, `GL_MAX_DEPTH`, `GL_MAX_LAYERS`, `GL_MAX_COMBINED_DIMENSIONS`, `GL_COLOR_COMPONENTS`, `GL_DEPTH_COMPONENTS`, `GL_STENCIL_COMPONENTS`, `GL_COLOR_RENDERABLE`, `GL_DEPTH_RENDERABLE`, `GL_STENCIL_RENDERABLE`, `GL_FRAMEBUFFER_RENDERABLE`, `GL_FRAMEBUFFER_RENDERABLE_LAYERED`, `GL_FRAMEBUFFER_BLEND`, `GL_READ_PIXELS`, `GL_READ_PIXELS_FORMAT`, `GL_READ_PIXELS_TYPE`, `GL_TEXTURE_IMAGE_FORMAT`, `GL_TEXTURE_IMAGE_TYPE`, `GL_GET_TEXTURE_IMAGE_FORMAT`, `GL_GET_TEXTURE_IMAGE_TYPE`, `GL_MIPMAP`, `GL_GENERATE_MIPMAP`, `GL_AUTO_GENERATE_MIPMAP`, `GL_COLOR_ENCODING`, `GL_SRGB_READ`, `GL_SRGB_WRITE`, `GL_SRGB_DECODE_ARB`, `GL_FILTER`, `GL_VERTEX_TEXTURE`, `GL_TESS_CONTROL_TEXTURE`, `GL_TESS_EVALUATION_TEXTURE`, `GL_GEOMETRY_TEXTURE`, `GL_FRAGMENT_TEXTURE`, `GL_COMPUTE_TEXTURE`, `GL_TEXTURE_SHADOW`, `GL_TEXTURE_GATHER`, `GL_TEXTURE_GATHER_SHADOW`, `GL_SHADER_IMAGE_LOAD`, `GL_SHADER_IMAGE_STORE`, `GL_SHADER_IMAGE_ATOMIC`, `GL_IMAGE_TEXEL_SIZE`, `GL_IMAGE_COMPATIBILITY_CLASS`, `GL_IMAGE_PIXEL_FORMAT`, `GL_IMAGE_PIXEL_TYPE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST`, `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST`, `GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE`, `GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_BLOCK_WIDTH`, `GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT`, `GL_TEXTURE_COMPRESSED_BLOCK_SIZE`, `GL_CLEAR_BUFFER`, `GL_TEXTURE_VIEW`, and `GL_VIEW_COMPATIBILITY_CLASS` are supported only if the GL version is 4.3 or higher.\n\nThe `GL_CLEAR_TEXTURE` token is accepted for *`pname`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is negative.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not `GL_SAMPLES` or `GL_NUM_SAMPLE_COUNTS`.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not color-, depth-, or stencil-renderable.\n\n`GL_INVALID_ENUM` is generated if *`target`* is not one of `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_RENDERBUFFER`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetInternalformati64v`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glGetInternalformativ`       |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[ glGet ](glget.xhtml)\n\n## Copyright\n\nCopyright © 2011-2018 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2018 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetInternalformat.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetInternalformat.xhtml)"
- name: glGetInternalformativ
  id: glgetinternalformat.xhtml#glGetInternalformativ
  summary: null
  belongs_to: glGetInternalformat
  description: '`void `**`glGetInternalformativ`**`(` GLenum `target`, GLenum `internalformat`, GLenum `pname`, GLsizei `bufSize`, GLint \*`params``)`;'
- name: glGetMultisample
  id: glgetmultisample.xhtml
  summary: pname Specifies the sample parameter name
  description: "## Name\n\nglGetMultisamplefv — retrieve the location of a sample\n\n## C Specification\n\n`void `**`glGetMultisamplefv`**`(` GLenum `pname`, GLuint `index`, GLfloat \\*`val``)`;\n\n## Parameters\n\n *`pname`*  \nSpecifies the sample parameter name. *`pname`* must be `GL_SAMPLE_POSITION`.\n\n *`index`*  \nSpecifies the index of the sample whose position to query.\n\n *`val`*  \nSpecifies the address of an array to receive the position of the sample.\n\n## Description\n\n`glGetMultisamplefv` queries the location of a given sample. *`pname`* specifies the sample parameter to retrieve and must be `GL_SAMPLE_POSITION`. *`index`* corresponds to the sample for which the location should be returned. The sample location is returned as two floating-point values in *`val[0]`* and *`val[1]`*, each between 0 and 1, corresponding to the *`x`* and *`y`* locations respectively in the GL pixel space of that sample. (0.5, 0.5) this corresponds to the pixel center. *`index`* must be between zero and the value of `GL_SAMPLES` minus one.\n\nIf the multisample mode does not have fixed sample locations, the returned values may only reflect the locations of samples within some pixels.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one `GL_SAMPLE_POSITION`.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_SAMPLES`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetMultisamplefv`        |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetMultisample.xhtml)"
- name: glGetMultisamplefv
  id: glgetmultisample.xhtml#glGetMultisamplefv
  summary: Specifies the sample parameter name
  belongs_to: glGetMultisample
  description: "`void `**`glGetMultisamplefv`**`(` GLenum `pname`, GLuint `index`, GLfloat \\*`val``)`;\n\n## Parameters\n\n*`pname`*\n\nSpecifies the sample parameter name. *`pname`* must be `GL_SAMPLE_POSITION`.\n\n*`index`*\n\nSpecifies the index of the sample whose position to query.\n\n*`val`*\n\nSpecifies the address of an array to receive the position of the sample.\n\n## Description\n\n`glGetMultisamplefv` queries the location of a given sample. *`pname`* specifies the sample parameter to retrieve and must be `GL_SAMPLE_POSITION`. *`index`* corresponds to the sample for which the location should be returned. The sample location is returned as two floating-point values in *`val[0]`* and *`val[1]`*, each between 0 and 1, corresponding to the *`x`* and *`y`* locations respectively in the GL pixel space of that sample. (0.5, 0.5) this corresponds to the pixel center. *`index`* must be between zero and the value of `GL_SAMPLES` minus one.\n\nIf the multisample mode does not have fixed sample locations, the returned values may only reflect the locations of samples within some pixels.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one `GL_SAMPLE_POSITION`.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_SAMPLES`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetMultisamplefv`          |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetMultisample.xhtml)"
- name: glGetNamedBufferParameteri64v
  id: glgetbufferparameter.xhtml#glGetNamedBufferParameteri64v
  summary: Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v
  belongs_to: glGetBufferParameter
  description: "`void `**`glGetNamedBufferParameteri64v`**`(` GLuint `buffer`, GLenum `pname`, GLint64 \\*`params``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glGetBufferParameteriv` and `glGetBufferParameteri64v`. Must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glGetNamedBufferParameteriv` and `glGetNamedBufferParameteri64v`.\n\n*`value`*\n\nSpecifies the name of the buffer object parameter to query.\n\n*`data`*\n\nReturns the requested parameter.\n\n## Description\n\nThese functions return in *`data`* a selected parameter of the specified buffer object.\n\n*`pname`* names a specific buffer object parameter, as follows:\n\n`GL_BUFFER_ACCESS`\n\n*`params`* returns the access policy set while mapping the buffer object (the value of the *`access`* parameter enum passed to `glMapBuffer`). If the buffer was mapped with `glMapBufferRange`, the access policy is determined by translating the bits in that *`access`* parameter to one of the supported enums for `glMapBuffer` as described in the OpenGL Specification.\n\n`GL_BUFFER_ACCESS_FLAGS`\n\n*`params`* returns the access policy set while mapping the buffer object (the value of the *`access`* parameter bitfield passed to `glMapBufferRange`). If the buffer was mapped with `glMapBuffer`, the access policy is determined by translating the enums in that *`access`* parameter to the corresponding bits for `glMapBufferRange` as described in the OpenGL Specification. The initial value is zero.\n\n`GL_BUFFER_IMMUTABLE_STORAGE`\n\n*`params`* returns a boolean flag indicating whether the buffer object is immutable. The initial value is `GL_FALSE`.\n\n`GL_BUFFER_MAPPED`\n\n*`params`* returns a flag indicating whether the buffer object is currently mapped. The initial value is `GL_FALSE`.\n\n`GL_BUFFER_MAP_LENGTH`\n\n*`params`* returns the length of the mapping into the buffer object established with `glMapBuffer*`. The `i64v` versions of these queries should be used for this parameter. The initial value is zero.\n\n`GL_BUFFER_MAP_OFFSET`\n\n*`params`* returns the offset of the mapping into the buffer object established with `glMapBuffer*`. The `i64v` versions of these queries should be used for this parameter. The initial value is zero.\n\n`GL_BUFFER_SIZE`\n\n*`params`* returns the size of the buffer object, measured in bytes. The initial value is 0.\n\n`GL_BUFFER_STORAGE_FLAGS`\n\n*`params`* returns a bitfield indicating the storage flags for the buffer object. If the buffer object is immutable, the value returned will be that specified when the data store was established with `glBufferStorage`. If the data store was established with `glBufferData`, the value will be `GL_MAP_READ_BIT` \\| `GL_MAP_WRITE_BIT` \\| `GL_DYNAMIC_STORAGE_BIT` \\| `GL_MAP_WRITE_BIT`. The initial value is zero.\n\n`GL_BUFFER_USAGE`\n\n*`params`* returns the buffer object's usage pattern. The initial value is `GL_STATIC_DRAW`.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`data`*.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetBufferParameter*` if *`target`* is not one of the accepted buffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetBufferParameter*` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedBufferParameter*` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the buffer object parameter names described above.\n\n## Version Support\n\n|                                 |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**    |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetBufferParameteri64v`      |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetBufferParameteriv`        |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetNamedBufferParameteri64v` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetNamedBufferParameteriv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glGetBufferPointerv](glgetbufferpointerv.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferParameter.xhtml)"
- name: glGetNamedBufferParameteriv
  id: glgetbufferparameter.xhtml#glGetNamedBufferParameteriv
  summary: null
  belongs_to: glGetBufferParameter
  description: '`void `**`glGetNamedBufferParameteriv`**`(` GLuint `buffer`, GLenum `pname`, GLint \*`params``)`;'
- name: glGetNamedBufferPointerv
  id: glgetbufferpointerv.xhtml#glGetNamedBufferPointerv
  summary: Specifies the name of the buffer object for glGetNamedBufferPointerv
  belongs_to: glGetBufferPointerv
  description: "`void `**`glGetNamedBufferPointerv`**`(` GLuint `buffer`, GLenum `pname`, void \\*\\*`params``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glGetBufferPointerv`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glGetNamedBufferPointerv`.\n\n*`pname`*\n\nSpecifies the name of the pointer to be returned. Must be `GL_BUFFER_MAP_POINTER`.\n\n*`params`*\n\nReturns the pointer value specified by *`pname`*.\n\n## Description\n\n`glGetBufferPointerv` and `glGetNamedBufferPointerv` return the buffer pointer *`pname`*, which must be `GL_BUFFER_MAP_POINTER`. The single buffer map pointer is returned in *`params`*. A `NULL` pointer is returned if the buffer object's data store is not currently mapped; or if the requesting context did not map the buffer object's data store, and the implementation is unable to support mappings on multiple clients.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\nThe initial value for the pointer is `NULL`.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if by `glGetBufferPointerv` if *`target`* is not one of the accepted buffer targets, or if *`pname`* is not `GL_BUFFER_MAP_POINTER`.\n\n`GL_INVALID_OPERATION` is generated by `glGetBufferPointerv` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedBufferPointerv` if *`buffer`* is not the name of an existing buffer object.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetBufferPointerv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetNamedBufferPointerv`    |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glMapBuffer](glmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferPointerv.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferPointerv.xhtml)"
- name: glGetNamedBufferSubData
  id: glgetbuffersubdata.xhtml#glGetNamedBufferSubData
  summary: Specifies the name of the buffer object for glGetNamedBufferSubData
  belongs_to: glGetBufferSubData
  description: "`void `**`glGetNamedBufferSubData`**`(` GLuint `buffer`, GLintptr `offset`, GLsizeiptr `size`, void \\*`data``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glGetBufferSubData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glGetNamedBufferSubData`.\n\n*`offset`*\n\nSpecifies the offset into the buffer object's data store from which data will be returned, measured in bytes.\n\n*`size`*\n\nSpecifies the size in bytes of the data store region being returned.\n\n*`data`*\n\nSpecifies a pointer to the location where buffer object data is returned.\n\n## Description\n\n`glGetBufferSubData` and `glGetNamedBufferSubData` return some or all of the data contents of the data store of the specified buffer object. Data starting at byte offset *`offset`* and extending for *`size`* bytes is copied from the buffer object's data store to the memory pointed to by *`data`*. An error is thrown if the buffer object is currently mapped, or if *`offset`* and *`size`* together define a range beyond the bounds of the buffer object's data store.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`data`*.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetBufferSubData` if *`target`* is not one of the generic buffer binding targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetBufferSubData` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedBufferSubData` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`size`* is negative, or if $offset + size$ is greater than the value of `GL_BUFFER_SIZE` for the buffer object.\n\n`GL_INVALID_OPERATION` is generated if the buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *`access`* flags.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetBufferSubData`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetNamedBufferSubData`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetBufferSubData.xhtml)"
- name: glGetNamedFramebufferAttachmentParameteriv
  id: glgetframebufferattachmentparameter.xhtml#glGetNamedFramebufferAttachmentParameteriv
  summary: Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv
  belongs_to: glGetFramebufferAttachmentParameter
  description: "`void `**`glGetNamedFramebufferAttachmentParameteriv`**`(` GLuint `framebuffer`, GLenum `attachment`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the framebuffer object is bound for `glGetFramebufferAttachmentParameteriv`.\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glGetNamedFramebufferAttachmentParameteriv`.\n\n*`attachment`*\n\nSpecifies the attachment of the framebuffer object to query.\n\n*`pname`*\n\nSpecifies the parameter of *`attachment`* to query.\n\n*`params`*\n\nReturns the value of parameter *`pname`* for *`attachment`*.\n\n## Description\n\n`glGetFramebufferAttachmentParameteriv` and `glGetNamedFramebufferAttachmentParameteriv` return parameters of attachments of a specified framebuffer object.\n\nFor `glGetFramebufferAttachmentParameteriv`, the framebuffer object is that bound to *`target`*, which must be one of `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Buffers of default framebuffers may also be queried if bound to *`target`*.\n\nFor `glGetNamedFramebufferAttachmentParameteriv`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, the default draw framebuffer is queried.\n\nIf the specified framebuffer is a framebuffer object, *`attachment`* must be one of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or `GL_COLOR_ATTACHMENT`*i*, where *i* is between zero and the value of `GL_MAX_COLOR_ATTACHMENTS` minus one.\n\nIf the specified framebuffer is a default framebuffer, *`target`*, *`attachment`* must be one of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_DEPTH` or `GL_STENCIL`, identifying the corresponding buffer.\n\nIf *`attachment`* is `GL_DEPTH_STENCIL_ATTACHMENT`, the same object must be bound to both the depth and stencil attachment points of the framebuffer object, and information about that object is returned.\n\nUpon successful return, if *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`, then *`params`* will contain one of `GL_NONE`, `GL_FRAMEBUFFER_DEFAULT`, `GL_TEXTURE`, or `GL_RENDERBUFFER`, identifying the type of object which contains the attached image. Other values accepted for *`pname`* depend on the type of object, as described below.\n\nIf the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE`, then either no framebuffer is bound to *`target`*; or a default framebuffer is queried, *`attachment`* is `GL_DEPTH` or `GL_STENCIL`, and the number of depth or stencil bits, respectively, is zero. In this case querying *`pname`* `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` will return zero, and all other queries will generate an error.\n\nIf the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is not `GL_NONE`, these queries apply to all other framebuffer types:\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE`, `GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE` or `GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE`, then *`params`* will contain the number of bits in the corresponding red, green, blue, alpha, depth, or stencil component of the specified attachment. If the requested component is not present in the attachment, or if no data storage or texture image has been specified for the attachment, then *`params`* will contain zero.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE`, then *`params`* will contain the format of components of the specified attachment, one of `GL_FLOAT`, `GL_INT`, `GL_UNSIGNED_INT`, `GL_SIGNED_NORMALIZED`, or `GL_UNSIGNED_NORMALIZED` for floating-point, signed integer, unsigned integer, signed normalized fixed-point, or unsigned normalized fixed-point components respectively. Only color buffers may have integer components. If no data storage or texture image has been specified for the attachment, then *`params`* will contain `GL_NONE`. This query cannot be performed for a combined depth+stencil attachment, since it does not have a single format.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING`, then *`params`* will contain the encoding of components of the specified attachment, one of `GL_LINEAR` or `GL_SRGB` for linear or sRGB-encoded components, respectively. Only color buffer components may be sRGB-encoded; such components are treated as described in the OpenGL Specification. For a default framebuffer, color encoding is determined by the implementation. For framebuffer objects, components are sRGB-encoded if the internal format of a color attachment is one of the color-renderable SRGB formats. If the attachment is not a color attachment, or if no data storage or texture image has been specified for the attachment, then *`params`* will contain `GL_LINEAR`.\n\nIf the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_RENDERBUFFER`, then\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`, *`params`* will contain the name of the renderbuffer object which contains the attached image.\n\nIf the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_TEXTURE`, then\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME`, then *`params`* will contain the name of the texture object which contains the attached image.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL`, then *`params`* will contain the mipmap level of the texture object which contains the attached image.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE` and the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is the name of a cube map texture object, then *`params`* will contain the cube map face of the cubemap texture object which contains the attached image. Otherwise *`params`* will contain zero.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_LAYERED`, then *`params`* will contain `GL_TRUE` if an entire level of a three-dimensional texture, cube map texture, or one-or two-dimensional array texture is attached. Otherwise, *`params`* will contain `GL_FALSE`.\n\n- If *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER`; the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is the name of a three-dimensional, or a one- or two-dimensional array texture; and the value of `GL_FRAMEBUFFER_ATTACHMENT_LAYERED` is `GL_FALSE`, then *`params`* will contain the texture layer which contains the attached image. Otherwise *`params`* will contain zero.\n\n## Notes\n\nThe `GL_FRAMEBUFFER_ATTACHMENT_LAYERED` query is supported only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetFramebufferAttachmentParameteriv` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedFramebufferAttachmentParameteriv` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not valid for the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`, as described above.\n\n`GL_INVALID_OPERATION` is generated if *`attachment`* is not one of the accepted framebuffer attachment points, as described above.\n\n`GL_INVALID_OPERATION` is generated if the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` is `GL_NONE` and *`pname`* is not `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` or `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE`.\n\n`GL_INVALID_OPERATION` is generated if *`attachment`* is `GL_DEPTH_STENCIL_ATTACHMENT` and different objects are bound to the depth and stencil attachment points of *`target`*.\n\n`GL_INVALID_OPERATION` is generated if *`attachment`* is `GL_DEPTH_STENCIL_ATTACHMENT` and *`pname`* is `GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE`.\n\n## Version Support\n\n|                                              |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:---------------------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**                 |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetFramebufferAttachmentParameteriv`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetNamedFramebufferAttachmentParameteriv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml)[glGetFramebufferParameter](glgetframebufferparameter.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFramebufferAttachmentParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFramebufferAttachmentParameter.xhtml)"
- name: glGetNamedFramebufferParameteriv
  id: glgetframebufferparameter.xhtml#glGetNamedFramebufferParameteriv
  summary: Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv
  belongs_to: glGetFramebufferParameter
  description: "`void `**`glGetNamedFramebufferParameteriv`**`(` GLuint `framebuffer`, GLenum `pname`, GLint \\*`param``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the framebuffer object is bound for `glGetFramebufferParameteriv`.\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glGetNamedFramebufferParameteriv`.\n\n*`pname`*\n\nSpecifies the parameter of the framebuffer object to query.\n\n*`params`*\n\nReturns the value of parameter *`pname`* for the framebuffer object.\n\n## Description\n\n`glGetFramebufferParameteriv` and `glGetNamedFramebufferParameteriv` query parameters of a specified framebuffer object.\n\nFor `glGetFramebufferParameteriv`, the framebuffer object is that bound to *`target`*, which must be one of `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be queried if bound to *`target`*.\n\nFor `glGetNamedFramebufferParameteriv`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, the default draw framebuffer is queried.\n\nUpon successful return, *`param`* will contain the value of the framebuffer parameter specified by *`pname`*, as described below.\n\nThe following parameters can only be queried for framebuffer objects:\n\n`GL_FRAMEBUFFER_DEFAULT_WIDTH`\n\n*`params`* returns the value of `GL_FRAMEBUFFER_DEFAULT_WIDTH` for the framebuffer object.\n\n`GL_FRAMEBUFFER_DEFAULT_HEIGHT`\n\n*`params`* returns the value of `GL_FRAMEBUFFER_DEFAULT_HEIGHT` for the framebuffer object.\n\n`GL_FRAMEBUFFER_DEFAULT_LAYERS`\n\n*`params`* returns the value of `GL_FRAMEBUFFER_DEFAULT_LAYERS` for the framebuffer object.\n\n`GL_FRAMEBUFFER_DEFAULT_SAMPLES`\n\n*`params`* returns the value of `GL_FRAMEBUFFER_DEFAULT_SAMPLES` for the framebuffer object.\n\n`GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`\n\n*`params`* returns the boolean value of `GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`.\n\nThe following parameters can be queried for both default framebuffers and framebuffer objects:\n\n`GL_DOUBLEBUFFER`\n\n*`param`* returns a boolean value indicating whether double buffering is supported for the framebuffer object.\n\n`GL_IMPLEMENTATION_COLOR_READ_FORMAT`\n\n*`param`* returns a GLenum value indicating the preferred pixel data format for the framebuffer object. See [glReadPixels](glreadpixels.xhtml).\n\n`GL_IMPLEMENTATION_COLOR_READ_TYPE`\n\n*`param`* returns a GLenum value indicating the implementation's preferred pixel data type for the framebuffer object. See [glReadPixels](glreadpixels.xhtml).\n\n`GL_SAMPLES`\n\n*`param`* returns an integer value indicating the coverage mask size for the framebuffer object. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n`GL_SAMPLE_BUFFERS`\n\n*`param`* returns an integer value indicating the number of sample buffers associated with the framebuffer object. See [glSampleCoverage](glsamplecoverage.xhtml).\n\n`GL_STEREO`\n\n*`param`* returns a boolean value indicating whether stereo buffers (left and right) are supported for the framebuffer object.\n\n## Notes\n\nQueries of default framebuffers are supported only if the GL version is 4.5 or higher. Otherwise, an `GL_INVALID_OPERATION` error is generated.\n\nQueries of the framebuffer-dependent parameters `GL_DOUBLEBUFFER`, `GL_IMPLEMENTATION_COLOR_READ_FORMAT`, `GL_IMPLEMENTATION_COLOR_READ_TYPE`, `GL_SAMPLES`, `GL_SAMPLE_BUFFERS` and `GL_STEREO` are supported only if the GL version is 4.5 or higher.\n\nThe framebuffer-dependent state `GL_SAMPLE_POSITION` cannot be queried with these commands.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetFramebufferParameteriv` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedFramebufferAttachmentParameteriv` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted parameter names.\n\n`GL_INVALID_OPERATION` is generated if a default framebuffer is queried, and *`pname`* is not one of `GL_DOUBLEBUFFER`, `GL_IMPLEMENTATION_COLOR_READ_FORMAT`, `GL_IMPLEMENTATION_COLOR_READ_TYPE`, `GL_SAMPLES`, `GL_SAMPLE_BUFFERS` or `GL_STEREO`.\n\n## Associated Gets\n\n[ glGetFramebufferAttachmentParameter ](glgetframebufferattachmentparameter.xhtml)\n\n## Version Support\n\n|                                    |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:-----------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**       |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetFramebufferParameteriv`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glGetNamedFramebufferParameteriv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glFramebufferParameteri](glframebufferparameteri.xhtml), [glGetFramebufferAttachmentParameter](glgetframebufferattachmentparameter.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFramebufferParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetFramebufferParameter.xhtml)"
- name: glGetNamedRenderbufferParameteriv
  id: glgetrenderbufferparameter.xhtml#glGetNamedRenderbufferParameteriv
  summary: Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv
  belongs_to: glGetRenderbufferParameter
  description: "`void `**`glGetNamedRenderbufferParameteriv`**`(` GLuint `renderbuffer`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the renderbuffer object is bound for `glGetRenderbufferParameteriv`. *`target`* must be `GL_RENDERBUFFER`.\n\n*`renderbuffer`*\n\nSpecifies the name of the renderbuffer object for `glGetNamedRenderbufferParameteriv`.\n\n*`pname`*\n\nSpecifies the parameter of the renderbuffer object to query.\n\n*`params`*\n\nReturns the value of parameter *`pname`* for the renderbuffer object.\n\n## Description\n\n`glGetRenderbufferParameteriv` and `glGetNamedRenderbufferParameteriv` query parameters of a specified renderbuffer object.\n\nFor `glGetRenderbufferParameteriv`, the renderbuffer object is that bound to *`target`*, which must be `GL_RENDERBUFFER`.\n\nFor `glGetNamedRenderbufferParameteriv`, *`renderbuffer`* is the name of the renderbuffer object.\n\nUpon successful return, *`param`* will contain the value of the renderbuffer parameter specified by *`pname`*, as described below.\n\n`GL_RENDERBUFFER_WIDTH`, `GL_RENDERBUFFER_HEIGHT`, `GL_RENDERBUFFER_INTERNAL_FORMAT` or `GL_RENDERBUFFER_SAMPLES`\n\n*`params`* returns the width in pixels, the height in pixels, internal format, or the number of samples, respectively, of the image of the specified renderbuffer object.\n\n`GL_RENDERBUFFER_RED_SIZE`, `GL_RENDERBUFFER_GREEN_SIZE`, `GL_RENDERBUFFER_BLUE_SIZE`, `GL_RENDERBUFFER_ALPHA_SIZE`, `GL_RENDERBUFFER_DEPTH_SIZE` or `GL_RENDERBUFFER_STENCIL_SIZE`\n\n*`params`* returns the actual resolution in bits (not the resolution specified when the image was defined) for the red, green, blue, alpha, depth or stencil components, respectively, of the image of the renderbuffer object.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetRenderbufferParameteriv` if *`target`* is not `GL_RENDERBUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glGetRenderbufferParameteriv` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedRenderbufferParameteriv` if *`renderbuffer`* is not the name of an existing renderbuffer object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted parameter names described above.\n\n## Version Support\n\n|                                     |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**        |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetNamedRenderbufferParameteriv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetRenderbufferParameteriv`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGenRenderbuffers](glgenrenderbuffers.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glBindRenderbuffer](glbindrenderbuffer.xhtml), [glRenderbufferStorage](glrenderbufferstorage.xhtml), [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetRenderbufferParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetRenderbufferParameter.xhtml)"
- name: glGetnCompressedTexImage
  id: glgetcompressedteximage.xhtml#glGetnCompressedTexImage
  summary: null
  belongs_to: glGetCompressedTexImage
  description: '`void `**`glGetnCompressedTexImage`**`(` GLenum `target`, GLint `level`, GLsizei `bufSize`, void \*`pixels``)`;'
- name: glGetnTexImage
  id: glgetteximage.xhtml#glGetnTexImage
  summary: null
  belongs_to: glGetTexImage
  description: '`void `**`glGetnTexImage`**`(` GLenum `target`, GLint `level`, GLenum `format`, GLenum `type`, GLsizei `bufSize`, void \*`pixels``)`;'
- name: glGetnUniformdv
  id: glgetuniform.xhtml#glGetnUniformdv
  summary: Specifies the program object to be queried
  belongs_to: glGetUniform
  description: "`void `**`glGetnUniformdv`**`(` GLuint `program`, GLint `location`, GLsizei `bufSize`, GLdouble \\*`params``)`;\n\n## Parameters\n\n*`program`*\n\nSpecifies the program object to be queried.\n\n*`location`*\n\nSpecifies the location of the uniform variable to be queried.\n\n*`bufSize`*\n\nSpecifies the size of the buffer *`params`*.\n\n*`params`*\n\nReturns the value of the specified uniform variable.\n\n## Description\n\n`glGetUniform` and `glGetnUniform` return in *`params`* the value(s) of the specified uniform variable. The type of the uniform variable specified by *`location`* determines the number of values returned. If the uniform variable is defined in the shader as a boolean, int, or float, a single value will be returned. If it is defined as a vec2, ivec2, or bvec2, two values will be returned. If it is defined as a vec3, ivec3, or bvec3, three values will be returned, and so on. To query values stored in uniform variables declared as arrays, call `glGetUniform` for each element of the array. To query values stored in uniform variables declared as structures, call `glGetUniform` for each field in the structure. The values for uniform variables declared as a matrix will be returned in column major order.\n\nThe locations assigned to uniform variables are not known until the program object is linked. After linking has occurred, the command [glGetUniformLocation](glgetuniformlocation.xhtml) can be used to obtain the location of a uniform variable. This location value can then be passed to `glGetUniform` or `glGetnUniform` in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. The uniform variable values can only be queried after a link if the link was successful.\n\nThe only difference between `glGetUniform` and `glGetnUniform` is that `glGetnUniform` will generate an error if size of the *`params`* buffer,as described by *`bufSize`*, is not large enough to hold the result data.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_OPERATION` is generated if *`program`* has not been successfully linked.\n\n`GL_INVALID_OPERATION` is generated if *`location`* does not correspond to a valid uniform variable location for the specified program object.\n\n`GL_INVALID_OPERATION` is generated by `glGetnUniform` if the buffer size required to store the requested data is greater than *`bufSize`*.\n\n## Associated Gets\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with arguments *`program`* and the index of an active uniform variable\n\n[glGetProgram](glgetprogram.xhtml) with arguments *`program`* and `GL_ACTIVE_UNIFORMS` or `GL_ACTIVE_UNIFORM_MAX_LENGTH`\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with arguments *`program`* and the name of a uniform variable\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetUniformdv`              |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetUniformfv`              |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetUniformiv`              |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetUniformuiv`             |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetnUniformdv`             |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetnUniformfv`             |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetnUniformiv`             |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetnUniformuiv`            |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glCreateProgram](glcreateprogram.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glUniform](gluniform.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniform.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniform.xhtml)"
- name: glGetnUniformfv
  id: glgetuniform.xhtml#glGetnUniformfv
  summary: null
  belongs_to: glGetUniform
  description: '`void `**`glGetnUniformfv`**`(` GLuint `program`, GLint `location`, GLsizei `bufSize`, GLfloat \*`params``)`;'
- name: glGetnUniformiv
  id: glgetuniform.xhtml#glGetnUniformiv
  summary: null
  belongs_to: glGetUniform
  description: '`void `**`glGetnUniformiv`**`(` GLuint `program`, GLint `location`, GLsizei `bufSize`, GLint \*`params``)`;'
- name: glGetnUniformuiv
  id: glgetuniform.xhtml#glGetnUniformuiv
  summary: null
  belongs_to: glGetUniform
  description: '`void `**`glGetnUniformuiv`**`(` GLuint `program`, GLint `location`, GLsizei `bufSize`, GLuint \*`params``)`;'
- name: glGetObjectLabel
  id: glgetobjectlabel.xhtml
  summary: identifier The namespace from which the name of the object is allocated
  description: "## Name\n\nglGetObjectLabel — retrieve the label of a named object identified within a namespace\n\n## C Specification\n\n`void `**`glGetObjectLabel`**`(` GLenum `identifier`, GLuint `name`, GLsizei `bufSize`, GLsizei \\* `length`, char \\* `label``)`;\n\n## Parameters\n\n *`identifier`*  \nThe namespace from which the name of the object is allocated.\n\n *`name`*  \nThe name of the object whose label to retrieve.\n\n *`bufSize`*  \nThe length of the buffer whose address is in *`label`*.\n\n *`length`*  \nThe address of a variable to receive the length of the object label.\n\n *`label`*  \nThe address of a string that will receive the object label.\n\n## Description\n\n`glGetObjectLabel` retrieves the label of the object identified by *`name`* within the namespace given by *`identifier`*. *`identifier`* must be one of `GL_BUFFER`, `GL_SHADER`, `GL_PROGRAM`, `GL_VERTEX_ARRAY`, `GL_QUERY`, `GL_PROGRAM_PIPELINE`, `GL_TRANSFORM_FEEDBACK`, `GL_SAMPLER`, `GL_TEXTURE`, `GL_RENDERBUFFER`, `GL_FRAMEBUFFER`, to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively.\n\n*`label`* is the address of a string that will be used to store the object label. *`bufSize`* specifies the number of characters in the array identified by *`label`*. *`length`* contains the address of a variable which will receive the number of characters in the object label. If *`length`* is NULL, then it is ignored and no data is written. Likewise, if *`label`* is NULL, or if *`bufSize`* is zero then no data is written to *`label`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`identifier`* is not one of the accepted object types.\n\n`GL_INVALID_OPERATION` is generated if *`name`* is not the name of an existing object of the type specified by *`identifier`*.\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is zero.\n\nIf not NULL, *`length`* and *`label`* should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_LABEL_LENGTH`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetObjectLabel`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glPushDebugGroup](glpushdebuggroup.xhtml), [glPopDebugGroup](glpopdebuggroup.xhtml), [glObjectLabel](globjectlabel.xhtml), [glGetObjectPtrLabel](glgetobjectptrlabel.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetObjectLabel.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetObjectLabel.xhtml)"
- name: glGetObjectPtrLabel
  id: glgetobjectptrlabel.xhtml
  summary: ptr The name of the sync object whose label to retrieve
  description: "## Name\n\nglGetObjectPtrLabel — retrieve the label of a sync object identified by a pointer\n\n## C Specification\n\n`void `**`glGetObjectPtrLabel`**`(` void \\* `ptr`, GLsizei `bufSize`, GLsizei \\* `length`, char \\* `label``)`;\n\n## Parameters\n\n *`ptr`*  \nThe name of the sync object whose label to retrieve.\n\n *`bufSize`*  \nThe length of the buffer whose address is in *`label`*.\n\n *`length`*  \nThe address of a variable to receive the length of the object label.\n\n *`label`*  \nThe address of a string that will receive the object label.\n\n## Description\n\n`glGetObjectPtrLabel` retrieves the label of the sync object identified by *`ptr`*.\n\n*`label`* is the address of a string that will be used to store the object label. *`bufSize`* specifies the number of characters in the array identified by *`label`*. *`length`* contains the address of a variable which will receive the number of characters in the object label. If *`length`* is NULL, then it is ignored and no data is written. Likewise, if *`label`* is NULL, or if *`bufSize`* is zero then no data is written to *`label`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`identifier`* is not one of the accepted object types.\n\n`GL_INVALID_VALUE` is generated if *`ptr`* is not the name of an existing sync object.\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is zero.\n\nIf not NULL, *`length`* and *`label`* should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_LABEL_LENGTH`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetObjectPtrLabel`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glPushDebugGroup](glpushdebuggroup.xhtml), [glPopDebugGroup](glpopdebuggroup.xhtml), [glObjectLabel](globjectlabel.xhtml), [glGetObjectLabel](glgetobjectlabel.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetObjectPtrLabel.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetObjectPtrLabel.xhtml)"
- name: glGetPointerv
  id: glgetpointerv.xhtml
  summary: pname Specifies the pointer to be returned
  description: "## Name\n\nglGetPointerv — return the address of the specified pointer\n\n## C Specification\n\n`void `**`glGetPointerv`**`(` GLenum `pname`, void \\*\\* `params``)`;\n\n## Parameters\n\n *`pname`*  \nSpecifies the pointer to be returned. Must be one of `GL_DEBUG_CALLBACK_FUNCTION` or `GL_DEBUG_CALLBACK_USER_PARAM`.\n\n *`params`*  \nReturns the pointer value specified by *`pname`*.\n\n## Description\n\n`glGetPointerv` returns pointer information. *`pname`* indicates the pointer to be returned, and *`params`* is a pointer to a location in which to place the returned data. The parameters that may be queried include:\n\n `GL_DEBUG_CALLBACK_FUNCTION`  \nReturns the current callback function set with the *`callback`* argument of [glDebugMessageCallback](gldebugmessagecallback.xhtml).\n\n `GL_DEBUG_CALLBACK_USER_PARAM`  \nReturns the user parameter to the current callback function set with the *`userParam`* argument of [glDebugMessageCallback](gldebugmessagecallback.xhtml).\n\n## Notes\n\n`glGetPointerv` is available in the OpenGL core profile only if the GL version is 4.3 or later. It is available in the compatibility profile for all GL versions, and accepts additional queries. However, these reference pages document only the core profile.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetPointerv`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDebugMessageCallback](gldebugmessagecallback.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetPointerv.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetPointerv.xhtml)"
- name: glGetProgram
  id: glgetprogram.xhtml
  summary: program Specifies the program object to be queried
  description: "## Name\n\nglGetProgramiv — Returns a parameter from a program object\n\n## C Specification\n\n`void `**`glGetProgramiv`**`(` GLuint `program`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to be queried.\n\n *`pname`*  \nSpecifies the object parameter. Accepted symbolic names are `GL_DELETE_STATUS`, `GL_LINK_STATUS`, `GL_VALIDATE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_ATTACHED_SHADERS`, `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`, `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`, `GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_BLOCKS`, `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`, `GL_ACTIVE_UNIFORM_MAX_LENGTH`, `GL_COMPUTE_WORK_GROUP_SIZE`, `GL_PROGRAM_BINARY_LENGTH`, `GL_TRANSFORM_FEEDBACK_BUFFER_MODE`, `GL_TRANSFORM_FEEDBACK_VARYINGS`, `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`, `GL_GEOMETRY_VERTICES_OUT`, `GL_GEOMETRY_INPUT_TYPE`, and `GL_GEOMETRY_OUTPUT_TYPE`.\n\n *`params`*  \nReturns the requested object parameter.\n\n## Description\n\n`glGetProgram` returns in *`params`* the value of a parameter for a specific program object. The following parameters are defined:\n\n `GL_DELETE_STATUS`  \n*`params`* returns `GL_TRUE` if *`program`* is currently flagged for deletion, and `GL_FALSE` otherwise.\n\n `GL_LINK_STATUS`  \n*`params`* returns `GL_TRUE` if the last link operation on *`program`* was successful, and `GL_FALSE` otherwise.\n\n `GL_VALIDATE_STATUS`  \n*`params`* returns `GL_TRUE` or if the last validation operation on *`program`* was successful, and `GL_FALSE` otherwise.\n\n `GL_INFO_LOG_LENGTH`  \n*`params`* returns the number of characters in the information log for *`program`* including the null termination character (i.e., the size of the character buffer required to store the information log). If *`program`* has no information log, a value of 0 is returned.\n\n `GL_ATTACHED_SHADERS`  \n*`params`* returns the number of shader objects attached to *`program`*.\n\n `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`  \n*`params`* returns the number of active attribute atomic counter buffers used by *`program`*.\n\n `GL_ACTIVE_ATTRIBUTES`  \n*`params`* returns the number of active attribute variables for *`program`*.\n\n `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`  \n*`params`* returns the length of the longest active attribute name for *`program`*, including the null termination character (i.e., the size of the character buffer required to store the longest attribute name). If no active attributes exist, 0 is returned.\n\n `GL_ACTIVE_UNIFORMS`  \n*`params`* returns the number of active uniform variables for *`program`*.\n\n `GL_ACTIVE_UNIFORM_MAX_LENGTH`  \n*`params`* returns the length of the longest active uniform variable name for *`program`*, including the null termination character (i.e., the size of the character buffer required to store the longest uniform variable name). If no active uniform variables exist, 0 is returned.\n\n `GL_PROGRAM_BINARY_LENGTH`  \n*`params`* returns the length of the program binary, in bytes that will be returned by a call to [glGetProgramBinary](glgetprogrambinary.xhtml). When a progam's `GL_LINK_STATUS` is `GL_FALSE`, its program binary length is zero.\n\n `GL_COMPUTE_WORK_GROUP_SIZE`  \n*`params`* returns an array of three integers containing the local work group size of the compute program as specified by its input layout qualifier(s). *`program`* must be the name of a program object that has been previously linked successfully and contains a binary for the compute shader stage.\n\n `GL_TRANSFORM_FEEDBACK_BUFFER_MODE`  \n*`params`* returns a symbolic constant indicating the buffer mode used when transform feedback is active. This may be `GL_SEPARATE_ATTRIBS` or `GL_INTERLEAVED_ATTRIBS`.\n\n `GL_TRANSFORM_FEEDBACK_VARYINGS`  \n*`params`* returns the number of varying variables to capture in transform feedback mode for the program.\n\n `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`  \n*`params`* returns the length of the longest variable name to be used for transform feedback, including the null-terminator.\n\n `GL_GEOMETRY_VERTICES_OUT`  \n*`params`* returns the maximum number of vertices that the geometry shader in *`program`* will output.\n\n `GL_GEOMETRY_INPUT_TYPE`  \n*`params`* returns a symbolic constant indicating the primitive type accepted as input to the geometry shader contained in *`program`*.\n\n `GL_GEOMETRY_OUTPUT_TYPE`  \n*`params`* returns a symbolic constant indicating the primitive type that will be output by the geometry shader contained in *`program`*.\n\n## Notes\n\n`GL_ACTIVE_UNIFORM_BLOCKS` and `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH` are available only if the GL version 3.1 or greater.\n\n`GL_GEOMETRY_VERTICES_OUT`, `GL_GEOMETRY_INPUT_TYPE` and `GL_GEOMETRY_OUTPUT_TYPE` are accepted only if the GL version is 3.2 or greater.\n\n`GL_COMPUTE_WORK_GROUP_SIZE` is accepted only if the GL version is 4.3 or greater.\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* does not refer to a program object.\n\n`GL_INVALID_OPERATION` is generated if *`pname`* is `GL_GEOMETRY_VERTICES_OUT`, `GL_GEOMETRY_INPUT_TYPE`, or `GL_GEOMETRY_OUTPUT_TYPE`, and *`program`* does not contain a geometry shader.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if *`pname`* is `GL_COMPUTE_WORK_GROUP_SIZE` and *`program`* does not contain a binary for the compute shader stage.\n\n## Associated Gets\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with argument *`program`*\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with argument *`program`*\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with argument *`program`*\n\n[glGetProgramInfoLog](glgetprograminfolog.xhtml) with argument *`program`*\n\n[glIsProgram](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramiv`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glAttachShader](glattachshader.xhtml), [glCreateProgram](glcreateprogram.xhtml), [glDeleteProgram](gldeleteprogram.xhtml), [glGetShader](glgetshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glValidateProgram](glvalidateprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgram.xhtml)"
- name: glGetProgramBinary
  id: glgetprogrambinary.xhtml
  summary: program Specifies the name of a program object whose binary representation to retrieve
  description: "## Name\n\nglGetProgramBinary — return a binary representation of a program object's compiled and linked executable source\n\n## C Specification\n\n`void `**`glGetProgramBinary`**`(` GLuint `program`, GLsizei `bufSize`, GLsizei \\*`length`, GLenum \\*`binaryFormat`, void \\*`binary``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of a program object whose binary representation to retrieve.\n\n *`bufSize`*  \nSpecifies the size of the buffer whose address is given by *`binary`*.\n\n *`length`*  \nSpecifies the address of a variable to receive the number of bytes written into *`binary`*.\n\n *`binaryFormat`*  \nSpecifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.\n\n *`binary`*  \nSpecifies the address an array into which the GL will return *`program`*'s binary representation.\n\n## Description\n\n`glGetProgramBinary` returns a binary representation of the compiled and linked executable for *`program`* into the array of bytes whose address is specified in *`binary`*. The maximum number of bytes that may be written into *`binary`* is specified by *`bufSize`*. If the program binary is greater in size than *`bufSize`* bytes, then an error is generated, otherwise the actual number of bytes written into *`binary`* is returned in the variable whose address is given by *`length`*. If *`length`* is `NULL`, then no length is returned.\n\nThe format of the program binary written into *`binary`* is returned in the variable whose address is given by *`binaryFormat`*, and may be implementation dependent. The binary produced by the GL may subsequently be returned to the GL by calling [glProgramBinary](glprogrambinary.xhtml), with *`binaryFormat`* and *`length`* set to the values returned by `glGetProgramBinary`, and passing the returned binary data in the *`binary`* parameter.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`bufSize`* is less than the size of `GL_PROGRAM_BINARY_LENGTH` for *`program`*.\n\n`GL_INVALID_OPERATION` is generated if `GL_LINK_STATUS` for the program object is false.\n\n## Associated Gets\n\n[glGetProgram](glgetprogram.xhtml) with argument `GL_PROGRAM_BINARY_LENGTH`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramBinary`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glProgramBinary](glprogrambinary.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramBinary.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramBinary.xhtml)"
- name: glGetProgramInfoLog
  id: glgetprograminfolog.xhtml
  summary: program Specifies the program object whose information log is to be queried
  description: "## Name\n\nglGetProgramInfoLog — Returns the information log for a program object\n\n## C Specification\n\n`void `**`glGetProgramInfoLog`**`(` GLuint `program`, GLsizei `maxLength`, GLsizei \\*`length`, GLchar \\*`infoLog``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object whose information log is to be queried.\n\n *`maxLength`*  \nSpecifies the size of the character buffer for storing the returned information log.\n\n *`length`*  \nReturns the length of the string returned in *`infoLog`* (excluding the null terminator).\n\n *`infoLog`*  \nSpecifies an array of characters that is used to return the information log.\n\n## Description\n\n`glGetProgramInfoLog` returns the information log for the specified program object. The information log for a program object is modified when the program object is linked or validated. The string that is returned will be null terminated.\n\n`glGetProgramInfoLog` returns in *`infoLog`* as much of the information log as it can, up to a maximum of *`maxLength`* characters. The number of characters actually returned, excluding the null termination character, is specified by *`length`*. If the length of the returned string is not required, a value of `NULL` can be passed in the *`length`* argument. The size of the buffer required to store the returned information log can be obtained by calling [glGetProgram](glgetprogram.xhtml) with the value `GL_INFO_LOG_LENGTH`.\n\nThe information log for a program object is either an empty string, or a string containing information about the last link operation, or a string containing information about the last validation operation. It may contain diagnostic messages, warning messages, and other information. When a program object is created, its information log will be a string of length 0.\n\n## Notes\n\nThe information log for a program object is the OpenGL implementer's primary mechanism for conveying information about linking and validating. Therefore, the information log can be helpful to application developers during the development process, even when these operations are successful. Application developers should not expect different OpenGL implementations to produce identical information logs.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_VALUE` is generated if *`maxLength`* is less than 0.\n\n## Associated Gets\n\n[glGetProgram](glgetprogram.xhtml) with argument `GL_INFO_LOG_LENGTH`\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramInfoLog`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCompileShader](glcompileshader.xhtml), [glGetShaderInfoLog](glgetshaderinfolog.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glValidateProgram](glvalidateprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramInfoLog.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramInfoLog.xhtml)"
- name: glGetProgramInterface
  id: glgetprograminterface.xhtml
  summary: program The name of a program object whose interface to query
  description: "## Name\n\nglGetProgramInterface — query a property of an interface in a program\n\n## C Specification\n\n`void `**`glGetProgramInterfaceiv`**`(` GLuint `program`, GLenum `programInterface`, GLenum `pname`, GLint \\* `params``)`;\n\n## Parameters\n\n *`program`*  \nThe name of a program object whose interface to query.\n\n *`programInterface`*  \nA token identifying the interface within *`program`* to query.\n\n *`pname`*  \nThe name of the parameter within *`programInterface`* to query.\n\n *`params`*  \nThe address of a variable to retrieve the value of *`pname`* for the program interface.\n\n## Description\n\n`glGetProgramInterfaceiv` queries the property of the interface identifed by *`programInterface`* in *`program`*, the property name of which is given by *`pname`*.\n\n*`program`* must be the name of an existing program object. *`programInterface`* is the name of the interface within *`program`* to query and must be one of the following values:\n\n `GL_UNIFORM`  \nThe query is targeted at the set of active uniforms within *`program`*.\n\n `GL_UNIFORM_BLOCK`  \nThe query is targeted at the set of active uniform blocks within *`program`*.\n\n `GL_ATOMIC_COUNTER_BUFFER`  \nThe query is targeted at the set of active atomic counter buffer binding points within *`program`*.\n\n `GL_PROGRAM_INPUT`  \nThe query is targeted at the set of active input variables used by the first shader stage of *`program`*. If *`program`* contains multiple shader stages then input variables from any stage other than the first will not be enumerated.\n\n `GL_PROGRAM_OUTPUT`  \nThe query is targeted at the set of active output variables produced by the last shader stage of *`program`*. If *`program`* contains multiple shader stages then output variables from any stage other than the last will not be enumerated.\n\n`GL_VERTEX_SUBROUTINE`,  `GL_TESS_CONTROL_SUBROUTINE`,  `GL_TESS_EVALUATION_SUBROUTINE`,  `GL_GEOMETRY_SUBROUTINE`,  `GL_FRAGMENT_SUBROUTINE`,   `GL_COMPUTE_SUBROUTINE`  \nThe query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of *`program`*, respectively.\n\n`GL_VERTEX_SUBROUTINE_UNIFORM`,  `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`,  `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`,  `GL_GEOMETRY_SUBROUTINE_UNIFORM`,  `GL_FRAGMENT_SUBROUTINE_UNIFORM`,   `GL_COMPUTE_SUBROUTINE_UNIFORM`  \nThe query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of *`program`*, respectively.\n\n `GL_TRANSFORM_FEEDBACK_VARYING`  \nThe query is targeted at the set of output variables from the last non-fragment stage of *`program`* that would be captured if transform feedback were active.\n\n `GL_BUFFER_VARIABLE`  \nThe query is targeted at the set of active buffer variables used by *`program`*.\n\n `GL_SHADER_STORAGE_BLOCK`  \nThe query is targeted at the set of active shader storage blocks used by *`program`*.\n\n `GL_TRANSFORM_FEEDBACK_BUFFER`  \nThe query is targeted at the set of active buffer binding points to which output variables in the `GL_TRANSFORM_FEEDBACK_VARYING` interface are written.\n\n*`pname`* identifies the property of *`programInterface`* to return in *`params`*.\n\nIf *`pname`* is `GL_ACTIVE_RESOURCES`, the value returned is the number of resources in the active resource list for *`programInterface`*. If the list of active resources for *`programInterface`* is empty, zero is returned.\n\nIf *`pname`* is `GL_MAX_NAME_LENGTH`, the value returned is the length of the longest active name string for an active resource in *`programInterface`*. This length includes an extra character for the null terminator. If the list of active resources for *`programInterface`* is empty, zero is returned. It is an error to specify `GL_MAX_NAME_LENGTH` when *`programInterface`* is `GL_ATOMIC_COUNTER_BUFFER`, as active atomic counter buffer resources are not assigned name strings.\n\nIf *`pname`* is `GL_MAX_NUM_ACTIVE_VARIABLES`, the value returned is the number of active variables belonging to the interface block or atomic counter buffer resource in *`programInterface`* with the most active variables. If the list of active resources for *`programInterface`* is empty, zero is returned. When *`pname`* is `GL_MAX_NUM_ACTIVE_VARIABLES`, *`programInterface`* must be `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, or `GL_SHADER_STORAGE_BLOCK`.\n\nIf *`pname`* is `GL_MAX_NUM_COMPATIBLE_SUBROUTINES`, the value returned is the number of compatible subroutines belonging to the active subroutine uniform in *`programInterface`* with the most compatible subroutines. If the list of active resources for *`programInterface`* is empty, zero is returned. When *`pname`* is `GL_MAX_NUM_COMPATIBLE_SUBROUTINES`, *`programInterface`* must be one of `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, or `GL_COMPUTE_SUBROUTINE_UNIFORM`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`identifier`* is not one of the accepted object types.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing sync object.\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is zero.\n\n`GL_INVALID_OPERATION` is generated if *`pname`* is `GL_MAX_NAME_LENGTH` and *`programInterface`* is `GL_ATOMIC_COUNTER_BUFFER` or `GL_TRANSFORM_FEEDBACK_BUFFER`, since active atomic counter and transform feedback buffer resources are not assigned name strings.\n\n`GL_INVALID_OPERATION` error is generated if *`pname`* is `GL_MAX_NUM_ACTIVE_VARIABLES` and *`programInterface`* is not `GL_UNIFORM_BLOCK`, `GL_SHADER_STORAGE_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, or `GL_TRANSFORM_FEEDBACK_BUFFER`.\n\nIf not NULL, *`length`* and *`label`* should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_LABEL_LENGTH`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramInterfaceiv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glPushDebugGroup](glpushdebuggroup.xhtml), [glPopDebugGroup](glpopdebuggroup.xhtml), [glObjectLabel](globjectlabel.xhtml), [glGetObjectLabel](glgetobjectlabel.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramInterface.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramInterface.xhtml)"
- name: glGetProgramInterfaceiv
  id: glgetprograminterface.xhtml#glGetProgramInterfaceiv
  summary: The name of a program object whose interface to query
  belongs_to: glGetProgramInterface
  description: "`void `**`glGetProgramInterfaceiv`**`(` GLuint `program`, GLenum `programInterface`, GLenum `pname`, GLint \\* `params``)`;\n\n## Parameters\n\n*`program`*\n\nThe name of a program object whose interface to query.\n\n*`programInterface`*\n\nA token identifying the interface within *`program`* to query.\n\n*`pname`*\n\nThe name of the parameter within *`programInterface`* to query.\n\n*`params`*\n\nThe address of a variable to retrieve the value of *`pname`* for the program interface.\n\n## Description\n\n`glGetProgramInterfaceiv` queries the property of the interface identifed by *`programInterface`* in *`program`*, the property name of which is given by *`pname`*.\n\n*`program`* must be the name of an existing program object. *`programInterface`* is the name of the interface within *`program`* to query and must be one of the following values:\n\n`GL_UNIFORM`\n\nThe query is targeted at the set of active uniforms within *`program`*.\n\n`GL_UNIFORM_BLOCK`\n\nThe query is targeted at the set of active uniform blocks within *`program`*.\n\n`GL_ATOMIC_COUNTER_BUFFER`\n\nThe query is targeted at the set of active atomic counter buffer binding points within *`program`*.\n\n`GL_PROGRAM_INPUT`\n\nThe query is targeted at the set of active input variables used by the first shader stage of *`program`*. If *`program`* contains multiple shader stages then input variables from any stage other than the first will not be enumerated.\n\n`GL_PROGRAM_OUTPUT`\n\nThe query is targeted at the set of active output variables produced by the last shader stage of *`program`*. If *`program`* contains multiple shader stages then output variables from any stage other than the last will not be enumerated.\n\n`GL_VERTEX_SUBROUTINE`, `GL_TESS_CONTROL_SUBROUTINE`, `GL_TESS_EVALUATION_SUBROUTINE`, `GL_GEOMETRY_SUBROUTINE`, `GL_FRAGMENT_SUBROUTINE`, `GL_COMPUTE_SUBROUTINE`\n\nThe query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of *`program`*, respectively.\n\n`GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`\n\nThe query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of *`program`*, respectively.\n\n`GL_TRANSFORM_FEEDBACK_VARYING`\n\nThe query is targeted at the set of output variables from the last non-fragment stage of *`program`* that would be captured if transform feedback were active.\n\n`GL_BUFFER_VARIABLE`\n\nThe query is targeted at the set of active buffer variables used by *`program`*.\n\n`GL_SHADER_STORAGE_BLOCK`\n\nThe query is targeted at the set of active shader storage blocks used by *`program`*.\n\n`GL_TRANSFORM_FEEDBACK_BUFFER`\n\nThe query is targeted at the set of active buffer binding points to which output variables in the `GL_TRANSFORM_FEEDBACK_VARYING` interface are written.\n\n*`pname`* identifies the property of *`programInterface`* to return in *`params`*.\n\nIf *`pname`* is `GL_ACTIVE_RESOURCES`, the value returned is the number of resources in the active resource list for *`programInterface`*. If the list of active resources for *`programInterface`* is empty, zero is returned.\n\nIf *`pname`* is `GL_MAX_NAME_LENGTH`, the value returned is the length of the longest active name string for an active resource in *`programInterface`*. This length includes an extra character for the null terminator. If the list of active resources for *`programInterface`* is empty, zero is returned. It is an error to specify `GL_MAX_NAME_LENGTH` when *`programInterface`* is `GL_ATOMIC_COUNTER_BUFFER`, as active atomic counter buffer resources are not assigned name strings.\n\nIf *`pname`* is `GL_MAX_NUM_ACTIVE_VARIABLES`, the value returned is the number of active variables belonging to the interface block or atomic counter buffer resource in *`programInterface`* with the most active variables. If the list of active resources for *`programInterface`* is empty, zero is returned. When *`pname`* is `GL_MAX_NUM_ACTIVE_VARIABLES`, *`programInterface`* must be `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, or `GL_SHADER_STORAGE_BLOCK`.\n\nIf *`pname`* is `GL_MAX_NUM_COMPATIBLE_SUBROUTINES`, the value returned is the number of compatible subroutines belonging to the active subroutine uniform in *`programInterface`* with the most compatible subroutines. If the list of active resources for *`programInterface`* is empty, zero is returned. When *`pname`* is `GL_MAX_NUM_COMPATIBLE_SUBROUTINES`, *`programInterface`* must be one of `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, or `GL_COMPUTE_SUBROUTINE_UNIFORM`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`identifier`* is not one of the accepted object types.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing sync object.\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is zero.\n\n`GL_INVALID_OPERATION` is generated if *`pname`* is `GL_MAX_NAME_LENGTH` and *`programInterface`* is `GL_ATOMIC_COUNTER_BUFFER` or `GL_TRANSFORM_FEEDBACK_BUFFER`, since active atomic counter and transform feedback buffer resources are not assigned name strings.\n\n`GL_INVALID_OPERATION` error is generated if *`pname`* is `GL_MAX_NUM_ACTIVE_VARIABLES` and *`programInterface`* is not `GL_UNIFORM_BLOCK`, `GL_SHADER_STORAGE_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, or `GL_TRANSFORM_FEEDBACK_BUFFER`.\n\nIf not NULL, *`length`* and *`label`* should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_LABEL_LENGTH`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetProgramInterfaceiv`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glPushDebugGroup](glpushdebuggroup.xhtml), [glPopDebugGroup](glpopdebuggroup.xhtml), [glObjectLabel](globjectlabel.xhtml), [glGetObjectLabel](glgetobjectlabel.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramInterface.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramInterface.xhtml)"
- name: glGetProgramiv
  id: glgetprogram.xhtml#glGetProgramiv
  summary: Specifies the program object to be queried
  belongs_to: glGetProgram
  description: "`void `**`glGetProgramiv`**`(` GLuint `program`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n*`program`*\n\nSpecifies the program object to be queried.\n\n*`pname`*\n\nSpecifies the object parameter. Accepted symbolic names are `GL_DELETE_STATUS`, `GL_LINK_STATUS`, `GL_VALIDATE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_ATTACHED_SHADERS`, `GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`, `GL_ACTIVE_ATTRIBUTES`, `GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`, `GL_ACTIVE_UNIFORMS`, `GL_ACTIVE_UNIFORM_BLOCKS`, `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH`, `GL_ACTIVE_UNIFORM_MAX_LENGTH`, `GL_COMPUTE_WORK_GROUP_SIZE`, `GL_PROGRAM_BINARY_LENGTH`, `GL_TRANSFORM_FEEDBACK_BUFFER_MODE`, `GL_TRANSFORM_FEEDBACK_VARYINGS`, `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`, `GL_GEOMETRY_VERTICES_OUT`, `GL_GEOMETRY_INPUT_TYPE`, and `GL_GEOMETRY_OUTPUT_TYPE`.\n\n*`params`*\n\nReturns the requested object parameter.\n\n## Description\n\n`glGetProgram` returns in *`params`* the value of a parameter for a specific program object. The following parameters are defined:\n\n`GL_DELETE_STATUS`\n\n*`params`* returns `GL_TRUE` if *`program`* is currently flagged for deletion, and `GL_FALSE` otherwise.\n\n`GL_LINK_STATUS`\n\n*`params`* returns `GL_TRUE` if the last link operation on *`program`* was successful, and `GL_FALSE` otherwise.\n\n`GL_VALIDATE_STATUS`\n\n*`params`* returns `GL_TRUE` or if the last validation operation on *`program`* was successful, and `GL_FALSE` otherwise.\n\n`GL_INFO_LOG_LENGTH`\n\n*`params`* returns the number of characters in the information log for *`program`* including the null termination character (i.e., the size of the character buffer required to store the information log). If *`program`* has no information log, a value of 0 is returned.\n\n`GL_ATTACHED_SHADERS`\n\n*`params`* returns the number of shader objects attached to *`program`*.\n\n`GL_ACTIVE_ATOMIC_COUNTER_BUFFERS`\n\n*`params`* returns the number of active attribute atomic counter buffers used by *`program`*.\n\n`GL_ACTIVE_ATTRIBUTES`\n\n*`params`* returns the number of active attribute variables for *`program`*.\n\n`GL_ACTIVE_ATTRIBUTE_MAX_LENGTH`\n\n*`params`* returns the length of the longest active attribute name for *`program`*, including the null termination character (i.e., the size of the character buffer required to store the longest attribute name). If no active attributes exist, 0 is returned.\n\n`GL_ACTIVE_UNIFORMS`\n\n*`params`* returns the number of active uniform variables for *`program`*.\n\n`GL_ACTIVE_UNIFORM_MAX_LENGTH`\n\n*`params`* returns the length of the longest active uniform variable name for *`program`*, including the null termination character (i.e., the size of the character buffer required to store the longest uniform variable name). If no active uniform variables exist, 0 is returned.\n\n`GL_PROGRAM_BINARY_LENGTH`\n\n*`params`* returns the length of the program binary, in bytes that will be returned by a call to [glGetProgramBinary](glgetprogrambinary.xhtml). When a progam's `GL_LINK_STATUS` is `GL_FALSE`, its program binary length is zero.\n\n`GL_COMPUTE_WORK_GROUP_SIZE`\n\n*`params`* returns an array of three integers containing the local work group size of the compute program as specified by its input layout qualifier(s). *`program`* must be the name of a program object that has been previously linked successfully and contains a binary for the compute shader stage.\n\n`GL_TRANSFORM_FEEDBACK_BUFFER_MODE`\n\n*`params`* returns a symbolic constant indicating the buffer mode used when transform feedback is active. This may be `GL_SEPARATE_ATTRIBS` or `GL_INTERLEAVED_ATTRIBS`.\n\n`GL_TRANSFORM_FEEDBACK_VARYINGS`\n\n*`params`* returns the number of varying variables to capture in transform feedback mode for the program.\n\n`GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`\n\n*`params`* returns the length of the longest variable name to be used for transform feedback, including the null-terminator.\n\n`GL_GEOMETRY_VERTICES_OUT`\n\n*`params`* returns the maximum number of vertices that the geometry shader in *`program`* will output.\n\n`GL_GEOMETRY_INPUT_TYPE`\n\n*`params`* returns a symbolic constant indicating the primitive type accepted as input to the geometry shader contained in *`program`*.\n\n`GL_GEOMETRY_OUTPUT_TYPE`\n\n*`params`* returns a symbolic constant indicating the primitive type that will be output by the geometry shader contained in *`program`*.\n\n## Notes\n\n`GL_ACTIVE_UNIFORM_BLOCKS` and `GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH` are available only if the GL version 3.1 or greater.\n\n`GL_GEOMETRY_VERTICES_OUT`, `GL_GEOMETRY_INPUT_TYPE` and `GL_GEOMETRY_OUTPUT_TYPE` are accepted only if the GL version is 3.2 or greater.\n\n`GL_COMPUTE_WORK_GROUP_SIZE` is accepted only if the GL version is 4.3 or greater.\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* does not refer to a program object.\n\n`GL_INVALID_OPERATION` is generated if *`pname`* is `GL_GEOMETRY_VERTICES_OUT`, `GL_GEOMETRY_INPUT_TYPE`, or `GL_GEOMETRY_OUTPUT_TYPE`, and *`program`* does not contain a geometry shader.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if *`pname`* is `GL_COMPUTE_WORK_GROUP_SIZE` and *`program`* does not contain a binary for the compute shader stage.\n\n## Associated Gets\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with argument *`program`*\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with argument *`program`*\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with argument *`program`*\n\n[glGetProgramInfoLog](glgetprograminfolog.xhtml) with argument *`program`*\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetProgramiv`              |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glAttachShader](glattachshader.xhtml), [glCreateProgram](glcreateprogram.xhtml), [glDeleteProgram](gldeleteprogram.xhtml), [glGetShader](glgetshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glValidateProgram](glvalidateprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgram.xhtml)"
- name: glGetProgramPipeline
  id: glgetprogrampipeline.xhtml
  summary: pipeline Specifies the name of a program pipeline object whose parameter retrieve
  description: "## Name\n\nglGetProgramPipeline — retrieve properties of a program pipeline object\n\n## C Specification\n\n`void `**`glGetProgramPipelineiv`**`(` GLuint `pipeline`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n *`pipeline`*  \nSpecifies the name of a program pipeline object whose parameter retrieve.\n\n *`pname`*  \nSpecifies the name of the parameter to retrieve.\n\n *`params`*  \nSpecifies the address of a variable into which will be written the value or values of *`pname`* for *`pipeline`*.\n\n## Description\n\n`glGetProgramPipelineiv` retrieves the value of a property of the program pipeline object *`pipeline`*. *`pname`* specifies the name of the parameter whose value to retrieve. The value of the parameter is written to the variable whose address is given by *`params`*.\n\nIf *`pname`* is `GL_ACTIVE_PROGRAM`, the name of the active program object of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_VERTEX_SHADER`, the name of the current program object for the vertex shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_TESS_CONTROL_SHADER`, the name of the current program object for the tessellation control shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_TESS_EVALUATION_SHADER`, the name of the current program object for the tessellation evaluation shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_GEOMETRY_SHADER`, the name of the current program object for the geometry shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_FRAGMENT_SHADER`, the name of the current program object for the fragment shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_INFO_LOG_LENGTH`, the length of the info log, including the null terminator, is returned in *`params`*. If there is no info log, zero is returned.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`pipeline`* is not zero or a name previously returned from a call to [glGenProgramPipelines](glgenprogrampipelines.xhtml) or if such a name has been deleted by a call to [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml).\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted values.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramPipelineiv`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenProgramPipelines](glgenprogrampipelines.xhtml), [glBindProgramPipeline](glbindprogrampipeline.xhtml), [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramPipeline.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramPipeline.xhtml)"
- name: glGetProgramPipelineInfoLog
  id: glgetprogrampipelineinfolog.xhtml
  summary: pipeline Specifies the name of a program pipeline object from which to retrieve the info log
  description: "## Name\n\nglGetProgramPipelineInfoLog — retrieve the info log string from a program pipeline object\n\n## C Specification\n\n`void `**`glGetProgramPipelineInfoLog`**`(` GLuint `pipeline`, GLsizei `bufSize`, GLsizei \\*`length`, GLchar \\*`infoLog``)`;\n\n## Parameters\n\n *`pipeline`*  \nSpecifies the name of a program pipeline object from which to retrieve the info log.\n\n *`bufSize`*  \nSpecifies the maximum number of characters, including the null terminator, that may be written into *`infoLog`*.\n\n *`length`*  \nSpecifies the address of a variable into which will be written the number of characters written into *`infoLog`*.\n\n *`infoLog`*  \nSpecifies the address of an array of characters into which will be written the info log for *`pipeline`*.\n\n## Description\n\n`glGetProgramPipelineInfoLog` retrieves the info log for the program pipeline object *`pipeline`*. The info log, including its null terminator, is written into the array of characters whose address is given by *`infoLog`*. The maximum number of characters that may be written into *`infoLog`* is given by *`bufSize`*, and the actual number of characters written into *`infoLog`* is returned in the integer whose address is given by *`length`*. If *`length`* is `NULL`, no length is returned.\n\nThe actual length of the info log for the program pipeline may be determined by calling [glGetProgramPipeline](glgetprogrampipeline.xhtml) with *`pname`* set to `GL_INFO_LOG_LENGTH`.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`pipeline`* is not a name previously returned from a call to [glGenProgramPipelines](glgenprogrampipelines.xhtml) or if such a name has been deleted by a call to [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml).\n\n## Associated Gets\n\n[glGetProgramPipeline](glgetprogrampipeline.xhtml) with parameter `GL_INFO_LOG_LENGTH`.\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramPipelineInfoLog` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenProgramPipelines](glgenprogrampipelines.xhtml), [glBindProgramPipeline](glbindprogrampipeline.xhtml), [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml), [glGetProgramPipeline](glgetprogrampipeline.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramPipelineInfoLog.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramPipelineInfoLog.xhtml)"
- name: glGetProgramPipelineiv
  id: glgetprogrampipeline.xhtml#glGetProgramPipelineiv
  summary: Specifies the name of a program pipeline object whose parameter retrieve
  belongs_to: glGetProgramPipeline
  description: "`void `**`glGetProgramPipelineiv`**`(` GLuint `pipeline`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n*`pipeline`*\n\nSpecifies the name of a program pipeline object whose parameter retrieve.\n\n*`pname`*\n\nSpecifies the name of the parameter to retrieve.\n\n*`params`*\n\nSpecifies the address of a variable into which will be written the value or values of *`pname`* for *`pipeline`*.\n\n## Description\n\n`glGetProgramPipelineiv` retrieves the value of a property of the program pipeline object *`pipeline`*. *`pname`* specifies the name of the parameter whose value to retrieve. The value of the parameter is written to the variable whose address is given by *`params`*.\n\nIf *`pname`* is `GL_ACTIVE_PROGRAM`, the name of the active program object of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_VERTEX_SHADER`, the name of the current program object for the vertex shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_TESS_CONTROL_SHADER`, the name of the current program object for the tessellation control shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_TESS_EVALUATION_SHADER`, the name of the current program object for the tessellation evaluation shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_GEOMETRY_SHADER`, the name of the current program object for the geometry shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_FRAGMENT_SHADER`, the name of the current program object for the fragment shader type of the program pipeline object is returned in *`params`*.\n\nIf *`pname`* is `GL_INFO_LOG_LENGTH`, the length of the info log, including the null terminator, is returned in *`params`*. If there is no info log, zero is returned.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`pipeline`* is not zero or a name previously returned from a call to [glGenProgramPipelines](glgenprogrampipelines.xhtml) or if such a name has been deleted by a call to [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml).\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted values.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetProgramPipelineiv`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGenProgramPipelines](glgenprogrampipelines.xhtml), [glBindProgramPipeline](glbindprogrampipeline.xhtml), [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramPipeline.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramPipeline.xhtml)"
- name: glGetProgramResource
  id: glgetprogramresource.xhtml
  summary: program The name of a program object whose resources to query
  description: "## Name\n\nglGetProgramResource — retrieve values for multiple properties of a single active resource within a program object\n\n## C Specification\n\n`void `**`glGetProgramResourceiv`**`(` GLuint `program`, GLenum `programInterface`, GLuint `index`, GLsizei `propCount`, const GLenum \\* `props`, GLsizei `bufSize`, GLsizei \\* `length`, GLint \\* `params``)`;\n\n## Parameters\n\n *`program`*  \nThe name of a program object whose resources to query.\n\n *`programInterface`*  \nA token identifying the interface within *`program`* containing the resource named *`name`*.\n\n## Description\n\n`glGetProgramResourceiv` returns values for multiple properties of a single active resource with an index of *`index`* in the interface *`programInterface`* of program object *`program`*. For each resource, values for *`propCount`* properties specified by the array *`props`* are returned. *`propCount`* may not be zero. An error is generated if any value in *`props`* is not one of the properties described immediately belowor if any value in *`props`* is not allowed for *`programInterface`*. The set of allowed *`programInterface`* values for each property can be found in the following table:\n\n| Property                                  | Supported Interfaces                                                                                                                                                                                                                                                                                                        |\n|:------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `GL_NAME_LENGTH`                          | Any except `GL_ATOMIC_COUNTER_BUFFER` and `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                                                    |\n| `GL_TYPE`                                 | `GL_UNIFORM`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`, `GL_TRANSFORM_FEEDBACK_VARYING`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                |\n| `GL_ARRAY_SIZE`                           | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT, VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`, `GL_TRANSFORM_FEEDBACK_VARYING` |\n| `GL_OFFSET`                               | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`, `GL_TRANSFORM_FEEDBACK_VARYING`                                                                                                                                                                                                                                                         |\n| `GL_BLOCK_INDEX`                          | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                          |\n| `GL_ARRAY_STRIDE`                         | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                          |\n| `GL_MATRIX_STRIDE`                        | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                          |\n| `GL_IS_ROW_MAJOR`                         | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                          |\n| `GL_ATOMIC_COUNTER_BUFFER_INDEX`          | `GL_UNIFORM`                                                                                                                                                                                                                                                                                                                |\n| `GL_TEXTURE_BUFFER`                       |  *none*                                                                                                                                                                                                                                                                                                                     |\n| `GL_BUFFER_BINDING`                       | `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                   |\n| `GL_BUFFER_DATA_SIZE`                     | `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`                                                                                                                                                                                                                                                   |\n| `GL_NUM_ACTIVE_VARIABLES`                 | `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                   |\n| `GL_ACTIVE_VARIABLES`                     | `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                   |\n| `GL_REFERENCED_BY_VERTEX_SHADER`          | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_TESS_CONTROL_SHADER`    | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_TESS_EVALUATION_SHADER` | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_GEOMETRY_SHADER`        | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_FRAGMENT_SHADER`        | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_COMPUTE_SHADER`         | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_NUM_COMPATIBLE_SUBROUTINES`           | `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`                                                                                                          |\n| `GL_COMPATIBLE_SUBROUTINES`               | `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`                                                                                                          |\n| `GL_TOP_LEVEL_ARRAY_SIZE`                 | `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                                        |\n| `GL_TOP_LEVEL_ARRAY_STRIDE`               | `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                                        |\n| `GL_LOCATION`                             | `GL_UNIFORM`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`, `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`                                                   |\n| `GL_LOCATION_INDEX`                       | `GL_PROGRAM_OUTPUT`                                                                                                                                                                                                                                                                                                         |\n| `GL_IS_PER_PATCH`                         | `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                                                                                                                                                     |\n| `GL_LOCATION_COMPONENT`                   | `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                                                                                                                                                     |\n| `GL_TRANSFORM_FEEDBACK_BUFFER_INDEX`      | `GL_TRANSFORM_FEEDBACK_VARYING`                                                                                                                                                                                                                                                                                             |\n| `GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE`     | `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                                                                                              |\n\nFor the property `GL_NAME_LENGTH`, a single integer identifying the length of the name string associated with an active variable, interface block, or subroutine is written to *`params`*. The name length includes a terminating null character.\n\nFor the property `GL_TYPE`, a single integer identifying the type of an active variable is written to *`params`*. The integer returned is one of the values found in table 2.16.\n\nFor the property `GL_ARRAY_SIZE`, a single integer identifying the number of active array elements of an active variable is written to *`params`*. The array size returned is in units of the type associated with the property `GL_TYPE`. For active variables not corresponding to an array of basic types, the value zero is written to *`params`*.\n\nFor the property `GL_BLOCK_INDEX`, a single integer identifying the index of the active interface block containing an active variable is written to *`params`*. If the variable is not the member of an interface block, the value -1 is written to *`params`*.\n\nFor the property `GL_OFFSET`, a single integer identifying the offset of an active variable is written to *`params`*. For variables in the `GL_UNIFORM` and `GL_BUFFER_VARIABLE` interfaces that are backed by a buffer object, the value written is the offset of that variable relative to the base of the buffer range holding its value. For variables in the `GL_TRANSFORM_FEEDBACK_VARYING` interface, the value written is the offset in the transform feedback buffer storage assigned to each vertex captured in transform feedback mode where the value of the variable will be stored. Such offsets are specified via the `xfb_offset` layout qualifier or assigned according to the variables position in the list of strings passed to [glTransformFeedbackVaryings](gltransformfeedbackvaryings.xhtml). Offsets are expressed in basic machine units. For all variables not recorded in transform feedback mode, including the special names `\"gl_NextBuffer\"`, `\"gl_SkipComponents1\"`, `\"gl_SkipComponents2\"`, `\"gl_SkipComponents3\"`, and `\"gl_SkipComponents4\"`, -1 is written to *`params`*.\n\nFor the property `GL_ARRAY_STRIDE`, a single integer identifying the stride between array elements in an active variable is written to *`params`*. For active variables declared as an array of basic types, the value written is the difference, in basic machine units, between the offsets of consecutive elements in an array. For active variables not declared as an array of basic types, zero is written to *`params`*. For active variables not backed by a buffer object, -1 is written to *`params`*, regardless of the variable type.\n\nFor the property `GL_MATRIX_STRIDE`, a single integer identifying the stride between columns of a column-major matrix or rows of a row-major matrix is written to *`params`*. For active variables declared a single matrix or array of matrices, the value written is the difference, in basic machine units, between the offsets of consecutive columns or rows in each matrix. For active variables not declared as a matrix or array of matrices, zero is written to *`params`*. For active variables not backed by a buffer object, -1 is written to *`params`*, regardless of the variable type.\n\nFor the property `GL_IS_ROW_MAJOR`, a single integer identifying whether an active variable is a row-major matrix is written to *`params`*. For active variables backed by a buffer object, declared as a single matrix or array of matrices, and stored in row-major order, one is written to *`params`*. For all other active variables, zero is written to *`params`*.\n\nFor the property `GL_ATOMIC_COUNTER_BUFFER_INDEX`, a single integer identifying the index of the active atomic counter buffer containing an active variable is written to *`params`*. If the variable is not an atomic counter uniform, the value -1 is written to *`params`*.\n\nFor the property `GL_BUFFER_BINDING`, to index of the buffer binding point associated with the active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to *`params`*.\n\nFor the property `GL_BUFFER_DATA_SIZE`, then the implementation-dependent minimum total buffer object size, in basic machine units, required to hold all active variables associated with an active uniform block, shader storage block, or atomic counter buffer is written to *`params`*. If the final member of an active shader storage block is array with no declared size, the minimum buffer size is computed assuming the array was declared as an array with one element.\n\nFor the property `GL_NUM_ACTIVE_VARIABLES`, the number of active variables associated with an active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to *`params`*.\n\nFor the property `GL_ACTIVE_VARIABLES`, an array of active variable indices associated with an active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to *`params`*. The number of values written to *`params`* for an active resource is given by the value of the property `GL_NUM_ACTIVE_VARIABLES` for the resource.\n\nFor the properties `GL_REFERENCED_BY_VERTEX_SHADER`, `GL_REFERENCED_BY_TESS_CONTROL_SHADER`, `GL_REFERENCED_BY_TESS_EVALUATION_SHADER`, `GL_REFERENCED_BY_GEOMETRY_SHADER`, `GL_REFERENCED_BY_FRAGMENT_SHADER`, and `GL_REFERENCED_BY_COMPUTE_SHADER`, a single integer is written to *`params`*, identifying whether the active resource is referenced by the vertex, tessellation control, tessellation evaluation, geometry, or fragment shaders, respectively, in the program object. The value one is written to *`params`* if an active variable is referenced by the corresponding shader, or if an active uniform block, shader storage block, or atomic counter buffer contains at least one variable referenced by the corresponding shader. Otherwise, the value zero is written to *`params`*.\n\nFor the property `GL_TOP_LEVEL_ARRAY_SIZE`, a single integer identifying the number of active array elements of the top-level shader storage block member containing to the active variable is written to *`params`*. If the top-level block member is not declared as an array, the value one is written to *`params`*. If the top-level block member is an array with no declared size, the value zero is written to *`params`*.\n\nFor the property `GL_TOP_LEVEL_ARRAY_STRIDE`, a single integer identifying the stride between array elements of the top-level shader storage block member containing the active variable is written to *`params`*. For top-level block members declared as arrays, the value written is the difference, in basic machine units, between the offsets of the active variable for consecutive elements in the top-level array. For top-level block members not declared as an array, zero is written to *`params`*.\n\nFor the property `GL_LOCATION`, a single integer identifying the assigned location for an active uniform, input, output, or subroutine uniform variable is written to *`params`*. For input, output, or uniform variables with locations specified by a layout qualifier, the specified location is used. For vertex shader input or fragment shader output variables without a layout qualifier, the location assigned when a program is linked is written to *`params`*. For all other input and output variables, the value -1 is written to *`params`*. For uniforms in uniform blocks, the value -1 is written to *`params`*.\n\nFor the property `GL_LOCATION_INDEX`, a single integer identifying the fragment color index of an active fragment shader output variable is written to *`params`*. If the active variable is an output for a non-fragment shader, the value -1 will be written to *`params`*.\n\nFor the property `GL_IS_PER_PATCH`, a single integer identifying whether the input or output is a per-patch attribute. If the active variable is a per-patch attribute (declared with the `patch` qualifier), the value one is written to *`params`*; otherwise, the value zero is written to *`params`*.\n\nFor the property `GL_LOCATION_COMPONENT`, a single integer indicating the first component of the location assigned to an active input or output variable is written to *`params`*. For input and output variables with a component specified by a `layout` qualifier, the specified component is written. For all other input and output variables, the value zero is written.\n\nFor the property `GL_TRANSFORM_FEEDBACK_BUFFER_INDEX`, a single integer identifying the index of the active transform feedback buffer associated with an active variable is written to *`params`*. For variables corresponding to the special names `\"gl_NextBuffer\"`, `\"gl_SkipComponents1\"`, `\"gl_SkipComponents2\"`, `\"gl_SkipComponents3\"`, and `\"gl_SkipComponents4\"`, -1 is written to *`params`*.\n\nFor the property `GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE`, a single integer identifying the stride, in basic machine units, between consecutive vertices written to the transform feedback buffer is written to *`params`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n`GL_INVALID_VALUE` is generated if *`propCount`* is zero.\n\n`GL_INVALID_ENUM` is generated if *`programInterface`* is not one of the accepted interface types.\n\n`GL_INVLALID_ENUM` is generated if any value in *`props`* is not one of the accepted tokens for the interface *`programInterface`*\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramResourceiv`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgramResourceName](glgetprogramresourcename.xhtml), [glGetProgramResourceIndex](glgetprogramresourceindex.xhtml), [glGetProgramResourceLocation](glgetprogramresourcelocation.xhtml), [glGetProgramResourceLocationIndex](glgetprogramresourcelocationindex.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResource.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResource.xhtml)"
- name: glGetProgramResourceIndex
  id: glgetprogramresourceindex.xhtml
  summary: program The name of a program object whose resources to query
  description: "## Name\n\nglGetProgramResourceIndex — query the index of a named resource within a program\n\n## C Specification\n\n`GLuint `**`glGetProgramResourceIndex`**`(` GLuint `program`, GLenum `programInterface`, const char \\* `name``)`;\n\n## Parameters\n\n *`program`*  \nThe name of a program object whose resources to query.\n\n *`programInterface`*  \nA token identifying the interface within *`program`* containing the resource named *`name`*.\n\n *`name`*  \nThe name of the resource to query the index of.\n\n## Description\n\n`glGetProgramResourceIndex` returns the unsigned integer index assigned to a resource named *`name`* in the interface type *`programInterface`* of program object *`program`*.\n\n*`program`* must be the name of an existing program object. *`programInterface`* is the name of the interface within *`program`* which contains the resource named *`name`*and must be one of the following values:\n\n `GL_UNIFORM`  \nThe query is targeted at the set of active uniforms within *`program`*.\n\n `GL_UNIFORM_BLOCK`  \nThe query is targeted at the set of active uniform blocks within *`program`*.\n\n `GL_PROGRAM_INPUT`  \nThe query is targeted at the set of active input variables used by the first shader stage of *`program`*. If *`program`* contains multiple shader stages then input variables from any stage other than the first will not be enumerated.\n\n `GL_PROGRAM_OUTPUT`  \nThe query is targeted at the set of active output variables produced by the last shader stage of *`program`*. If *`program`* contains multiple shader stages then output variables from any stage other than the last will not be enumerated.\n\n`GL_VERTEX_SUBROUTINE`,  `GL_TESS_CONTROL_SUBROUTINE`,  `GL_TESS_EVALUATION_SUBROUTINE`,  `GL_GEOMETRY_SUBROUTINE`,  `GL_FRAGMENT_SUBROUTINE`,   `GL_COMPUTE_SUBROUTINE`  \nThe query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of *`program`*, respectively.\n\n`GL_VERTEX_SUBROUTINE_UNIFORM`,  `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`,  `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`,  `GL_GEOMETRY_SUBROUTINE_UNIFORM`,  `GL_FRAGMENT_SUBROUTINE_UNIFORM`,   `GL_COMPUTE_SUBROUTINE_UNIFORM`  \nThe query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of *`program`*, respectively.\n\n `GL_TRANSFORM_FEEDBACK_VARYING`  \nThe query is targeted at the set of output variables from the last non-fragment stage of *`program`* that would be captured if transform feedback were active.\n\n `GL_TRANSFORM_FEEDBACK_BUFFER`  \nThe query is targeted at the set of active buffer binding points to which output variables in the `GL_TRANSFORM_FEEDBACK_VARYING` interface are written.\n\n `GL_BUFFER_VARIABLE`  \nThe query is targeted at the set of active buffer variables used by *`program`*.\n\n `GL_SHADER_STORAGE_BLOCK`  \nThe query is targeted at the set of active shader storage blocks used by *`program`*.\n\nIf *`name`* exactly matches the name string of one of the active resources for *`programInterface`*, the index of the matched resource is returned. Additionally, if *`name`* would exactly match the name string of an active resource if \"\\[0\\]\" were appended to *`name`*, the index of the matched resource is returned. Otherwise, *`name`* is considered not to be the name of an active resource, and `GL_INVALID_INDEX` is returned.\n\nFor the interface `GL_TRANSFORM_FEEDBACK_VARYING`, the value `GL_INVALID_INDEX` should be returned when querying the index assigned to the special names `gl_NextBuffer`, `gl_SkipComponents1`, `gl_SkipComponents2`, `gl_SkipComponents3`, or `gl_SkipComponents4`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`programInterface`* is not one of the accepted interface types.\n\n`GL_INVALID_ENUM` is generated if *`programInterface`* is `GL_ATOMIC_COUNTER_BUFFER` or `GL_TRANSFORM_FEEDBACK_BUFFER`, since active atomic counter and transform feedback buffer resources are not assigned name strings.\n\nAlthough not an error, `GL_INVALID_INDEX` is returned if *`name`* is not the name of a resource within the interface identified by *`programInterface`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramResourceIndex` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgramResourceName](glgetprogramresourcename.xhtml), [glGetProgramResource](glgetprogramresource.xhtml), [glGetProgramResourceLocation](glgetprogramresourcelocation.xhtml), [glGetProgramResourceLocationIndex](glgetprogramresourcelocationindex.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResourceIndex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResourceIndex.xhtml)"
- name: glGetProgramResourceiv
  id: glgetprogramresource.xhtml#glGetProgramResourceiv
  summary: The name of a program object whose resources to query
  belongs_to: glGetProgramResource
  description: "`void `**`glGetProgramResourceiv`**`(` GLuint `program`, GLenum `programInterface`, GLuint `index`, GLsizei `propCount`, const GLenum \\* `props`, GLsizei `bufSize`, GLsizei \\* `length`, GLint \\* `params``)`;\n\n## Parameters\n\n*`program`*\n\nThe name of a program object whose resources to query.\n\n*`programInterface`*\n\nA token identifying the interface within *`program`* containing the resource named *`name`*.\n\n## Description\n\n`glGetProgramResourceiv` returns values for multiple properties of a single active resource with an index of *`index`* in the interface *`programInterface`* of program object *`program`*. For each resource, values for *`propCount`* properties specified by the array *`props`* are returned. *`propCount`* may not be zero. An error is generated if any value in *`props`* is not one of the properties described immediately belowor if any value in *`props`* is not allowed for *`programInterface`*. The set of allowed *`programInterface`* values for each property can be found in the following table:\n\n| Property                                  | Supported Interfaces                                                                                                                                                                                                                                                                                                        |\n|:------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `GL_NAME_LENGTH`                          | Any except `GL_ATOMIC_COUNTER_BUFFER` and `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                                                    |\n| `GL_TYPE`                                 | `GL_UNIFORM`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`, `GL_TRANSFORM_FEEDBACK_VARYING`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                |\n| `GL_ARRAY_SIZE`                           | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT, VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`, `GL_TRANSFORM_FEEDBACK_VARYING` |\n| `GL_OFFSET`                               | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`, `GL_TRANSFORM_FEEDBACK_VARYING`                                                                                                                                                                                                                                                         |\n| `GL_BLOCK_INDEX`                          | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                          |\n| `GL_ARRAY_STRIDE`                         | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                          |\n| `GL_MATRIX_STRIDE`                        | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                          |\n| `GL_IS_ROW_MAJOR`                         | `GL_UNIFORM`, `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                          |\n| `GL_ATOMIC_COUNTER_BUFFER_INDEX`          | `GL_UNIFORM`                                                                                                                                                                                                                                                                                                                |\n| `GL_TEXTURE_BUFFER`                       |  *none*                                                                                                                                                                                                                                                                                                                     |\n| `GL_BUFFER_BINDING`                       | `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                   |\n| `GL_BUFFER_DATA_SIZE`                     | `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`                                                                                                                                                                                                                                                   |\n| `GL_NUM_ACTIVE_VARIABLES`                 | `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                   |\n| `GL_ACTIVE_VARIABLES`                     | `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                   |\n| `GL_REFERENCED_BY_VERTEX_SHADER`          | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_TESS_CONTROL_SHADER`    | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_TESS_EVALUATION_SHADER` | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_GEOMETRY_SHADER`        | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_FRAGMENT_SHADER`        | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_REFERENCED_BY_COMPUTE_SHADER`         | `GL_UNIFORM`, `GL_UNIFORM_BLOCK`, `GL_ATOMIC_COUNTER_SHADER`, `GL_BUFFER`, `GL_SHADER_STORAGE_BLOCK`, `GL_BUFFER_VARIABLE`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                         |\n| `GL_NUM_COMPATIBLE_SUBROUTINES`           | `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`                                                                                                          |\n| `GL_COMPATIBLE_SUBROUTINES`               | `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`                                                                                                          |\n| `GL_TOP_LEVEL_ARRAY_SIZE`                 | `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                                        |\n| `GL_TOP_LEVEL_ARRAY_STRIDE`               | `GL_BUFFER_VARIABLE`                                                                                                                                                                                                                                                                                                        |\n| `GL_LOCATION`                             | `GL_UNIFORM`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`, `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`                                                   |\n| `GL_LOCATION_INDEX`                       | `GL_PROGRAM_OUTPUT`                                                                                                                                                                                                                                                                                                         |\n| `GL_IS_PER_PATCH`                         | `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                                                                                                                                                     |\n| `GL_LOCATION_COMPONENT`                   | `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`                                                                                                                                                                                                                                                                                     |\n| `GL_TRANSFORM_FEEDBACK_BUFFER_INDEX`      | `GL_TRANSFORM_FEEDBACK_VARYING`                                                                                                                                                                                                                                                                                             |\n| `GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE`     | `GL_TRANSFORM_FEEDBACK_BUFFER`                                                                                                                                                                                                                                                                                              |\n\nFor the property `GL_NAME_LENGTH`, a single integer identifying the length of the name string associated with an active variable, interface block, or subroutine is written to *`params`*. The name length includes a terminating null character.\n\nFor the property `GL_TYPE`, a single integer identifying the type of an active variable is written to *`params`*. The integer returned is one of the values found in table 2.16.\n\nFor the property `GL_ARRAY_SIZE`, a single integer identifying the number of active array elements of an active variable is written to *`params`*. The array size returned is in units of the type associated with the property `GL_TYPE`. For active variables not corresponding to an array of basic types, the value zero is written to *`params`*.\n\nFor the property `GL_BLOCK_INDEX`, a single integer identifying the index of the active interface block containing an active variable is written to *`params`*. If the variable is not the member of an interface block, the value -1 is written to *`params`*.\n\nFor the property `GL_OFFSET`, a single integer identifying the offset of an active variable is written to *`params`*. For variables in the `GL_UNIFORM` and `GL_BUFFER_VARIABLE` interfaces that are backed by a buffer object, the value written is the offset of that variable relative to the base of the buffer range holding its value. For variables in the `GL_TRANSFORM_FEEDBACK_VARYING` interface, the value written is the offset in the transform feedback buffer storage assigned to each vertex captured in transform feedback mode where the value of the variable will be stored. Such offsets are specified via the `xfb_offset` layout qualifier or assigned according to the variables position in the list of strings passed to [glTransformFeedbackVaryings](gltransformfeedbackvaryings.xhtml). Offsets are expressed in basic machine units. For all variables not recorded in transform feedback mode, including the special names `\"gl_NextBuffer\"`, `\"gl_SkipComponents1\"`, `\"gl_SkipComponents2\"`, `\"gl_SkipComponents3\"`, and `\"gl_SkipComponents4\"`, -1 is written to *`params`*.\n\nFor the property `GL_ARRAY_STRIDE`, a single integer identifying the stride between array elements in an active variable is written to *`params`*. For active variables declared as an array of basic types, the value written is the difference, in basic machine units, between the offsets of consecutive elements in an array. For active variables not declared as an array of basic types, zero is written to *`params`*. For active variables not backed by a buffer object, -1 is written to *`params`*, regardless of the variable type.\n\nFor the property `GL_MATRIX_STRIDE`, a single integer identifying the stride between columns of a column-major matrix or rows of a row-major matrix is written to *`params`*. For active variables declared a single matrix or array of matrices, the value written is the difference, in basic machine units, between the offsets of consecutive columns or rows in each matrix. For active variables not declared as a matrix or array of matrices, zero is written to *`params`*. For active variables not backed by a buffer object, -1 is written to *`params`*, regardless of the variable type.\n\nFor the property `GL_IS_ROW_MAJOR`, a single integer identifying whether an active variable is a row-major matrix is written to *`params`*. For active variables backed by a buffer object, declared as a single matrix or array of matrices, and stored in row-major order, one is written to *`params`*. For all other active variables, zero is written to *`params`*.\n\nFor the property `GL_ATOMIC_COUNTER_BUFFER_INDEX`, a single integer identifying the index of the active atomic counter buffer containing an active variable is written to *`params`*. If the variable is not an atomic counter uniform, the value -1 is written to *`params`*.\n\nFor the property `GL_BUFFER_BINDING`, to index of the buffer binding point associated with the active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to *`params`*.\n\nFor the property `GL_BUFFER_DATA_SIZE`, then the implementation-dependent minimum total buffer object size, in basic machine units, required to hold all active variables associated with an active uniform block, shader storage block, or atomic counter buffer is written to *`params`*. If the final member of an active shader storage block is array with no declared size, the minimum buffer size is computed assuming the array was declared as an array with one element.\n\nFor the property `GL_NUM_ACTIVE_VARIABLES`, the number of active variables associated with an active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to *`params`*.\n\nFor the property `GL_ACTIVE_VARIABLES`, an array of active variable indices associated with an active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to *`params`*. The number of values written to *`params`* for an active resource is given by the value of the property `GL_NUM_ACTIVE_VARIABLES` for the resource.\n\nFor the properties `GL_REFERENCED_BY_VERTEX_SHADER`, `GL_REFERENCED_BY_TESS_CONTROL_SHADER`, `GL_REFERENCED_BY_TESS_EVALUATION_SHADER`, `GL_REFERENCED_BY_GEOMETRY_SHADER`, `GL_REFERENCED_BY_FRAGMENT_SHADER`, and `GL_REFERENCED_BY_COMPUTE_SHADER`, a single integer is written to *`params`*, identifying whether the active resource is referenced by the vertex, tessellation control, tessellation evaluation, geometry, or fragment shaders, respectively, in the program object. The value one is written to *`params`* if an active variable is referenced by the corresponding shader, or if an active uniform block, shader storage block, or atomic counter buffer contains at least one variable referenced by the corresponding shader. Otherwise, the value zero is written to *`params`*.\n\nFor the property `GL_TOP_LEVEL_ARRAY_SIZE`, a single integer identifying the number of active array elements of the top-level shader storage block member containing to the active variable is written to *`params`*. If the top-level block member is not declared as an array, the value one is written to *`params`*. If the top-level block member is an array with no declared size, the value zero is written to *`params`*.\n\nFor the property `GL_TOP_LEVEL_ARRAY_STRIDE`, a single integer identifying the stride between array elements of the top-level shader storage block member containing the active variable is written to *`params`*. For top-level block members declared as arrays, the value written is the difference, in basic machine units, between the offsets of the active variable for consecutive elements in the top-level array. For top-level block members not declared as an array, zero is written to *`params`*.\n\nFor the property `GL_LOCATION`, a single integer identifying the assigned location for an active uniform, input, output, or subroutine uniform variable is written to *`params`*. For input, output, or uniform variables with locations specified by a layout qualifier, the specified location is used. For vertex shader input or fragment shader output variables without a layout qualifier, the location assigned when a program is linked is written to *`params`*. For all other input and output variables, the value -1 is written to *`params`*. For uniforms in uniform blocks, the value -1 is written to *`params`*.\n\nFor the property `GL_LOCATION_INDEX`, a single integer identifying the fragment color index of an active fragment shader output variable is written to *`params`*. If the active variable is an output for a non-fragment shader, the value -1 will be written to *`params`*.\n\nFor the property `GL_IS_PER_PATCH`, a single integer identifying whether the input or output is a per-patch attribute. If the active variable is a per-patch attribute (declared with the `patch` qualifier), the value one is written to *`params`*; otherwise, the value zero is written to *`params`*.\n\nFor the property `GL_LOCATION_COMPONENT`, a single integer indicating the first component of the location assigned to an active input or output variable is written to *`params`*. For input and output variables with a component specified by a `layout` qualifier, the specified component is written. For all other input and output variables, the value zero is written.\n\nFor the property `GL_TRANSFORM_FEEDBACK_BUFFER_INDEX`, a single integer identifying the index of the active transform feedback buffer associated with an active variable is written to *`params`*. For variables corresponding to the special names `\"gl_NextBuffer\"`, `\"gl_SkipComponents1\"`, `\"gl_SkipComponents2\"`, `\"gl_SkipComponents3\"`, and `\"gl_SkipComponents4\"`, -1 is written to *`params`*.\n\nFor the property `GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE`, a single integer identifying the stride, in basic machine units, between consecutive vertices written to the transform feedback buffer is written to *`params`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n`GL_INVALID_VALUE` is generated if *`propCount`* is zero.\n\n`GL_INVALID_ENUM` is generated if *`programInterface`* is not one of the accepted interface types.\n\n`GL_INVLALID_ENUM` is generated if any value in *`props`* is not one of the accepted tokens for the interface *`programInterface`*\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetProgramResourceiv`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGetProgramResourceName](glgetprogramresourcename.xhtml), [glGetProgramResourceIndex](glgetprogramresourceindex.xhtml), [glGetProgramResourceLocation](glgetprogramresourcelocation.xhtml), [glGetProgramResourceLocationIndex](glgetprogramresourcelocationindex.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResource.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResource.xhtml)"
- name: glGetProgramResourceLocation
  id: glgetprogramresourcelocation.xhtml
  summary: program The name of a program object whose resources to query
  description: "## Name\n\nglGetProgramResourceLocation — query the location of a named resource within a program\n\n## C Specification\n\n`GLint `**`glGetProgramResourceLocation`**`(` GLuint `program`, GLenum `programInterface`, const char \\* `name``)`;\n\n## Parameters\n\n *`program`*  \nThe name of a program object whose resources to query.\n\n *`programInterface`*  \nA token identifying the interface within *`program`* containing the resource named *`name`*.\n\n *`name`*  \nThe name of the resource to query the location of.\n\n## Description\n\n`glGetProgramResourceLocation` returns the location assigned to the variable named *`name`* in interface *`programInterface`* of program object *`program`*. *`program`* must be the name of a program that has been linked successfully. *`programInterface`* must be one of `GL_UNIFORM`, `GL_PROGRAM_INPUT`, `GL_PROGRAM_OUTPUT`, `GL_VERTEX_SUBROUTINE_UNIFORM`, `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`, `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`, `GL_GEOMETRY_SUBROUTINE_UNIFORM`, `GL_FRAGMENT_SUBROUTINE_UNIFORM`, `GL_COMPUTE_SUBROUTINE_UNIFORM`, or `GL_TRANSFORM_FEEDBACK_BUFFER`.\n\nThe value -1 will be returned if an error occurs, if *`name`* does not identify an active variable on *`programInterface`*, or if *`name`* identifies an active variable that does not have a valid location assigned, as described above. The locations returned by these commands are the same locations returned when querying the `GL_LOCATION` and `GL_LOCATION_INDEX` resource properties.\n\nA string provided to `glGetProgramResourceLocation` is considered to match an active variable if:\n\n- the string exactly matches the name of the active variable\n\n- if the string identifies the base name of an active array, where the string would exactly match the name of the variable if the suffix \"\\[0\\]\" were appended to the string\n\n- if the string identifies an active element of the array, where the string ends with the concatenation of the \"\\[\" character, an integer *with no \"+\" sign, extra leading zeroes, or whitespace* identifying an array element, and the \"\\]\" character, the integer is less than the number of active elements of the array variable, and where the string would exactly match the enumerated name of the array if the decimal integer were replaced with zero.\n\nAny other string is considered not to identify an active variable. If the string specifies an element of an array variable, `glGetProgramResourceLocation` returns the location assigned to that element. If it specifies the base name of an array, it identifies the resources associated with the first element of the array.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n`GL_INVALID_ENUM` is generated if *`programInterface`* is not one of the accepted interface types.\n\n`GL_INVALID_OPERATION` is generated if *`program`* has not been linked successfully.\n\n## Version Support\n\n|                                | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**    |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramResourceLocation` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgramResourceName](glgetprogramresourcename.xhtml), [glGetProgramResourceIndex](glgetprogramresourceindex.xhtml), [glGetProgramResource](glgetprogramresource.xhtml), [glGetProgramResourceLocationIndex](glgetprogramresourcelocationindex.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResourceLocation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResourceLocation.xhtml)"
- name: glGetProgramResourceLocationIndex
  id: glgetprogramresourcelocationindex.xhtml
  summary: program The name of a program object whose resources to query
  description: "## Name\n\nglGetProgramResourceLocationIndex — query the fragment color index of a named variable within a program\n\n## C Specification\n\n`GLint `**`glGetProgramResourceLocationIndex`**`(` GLuint `program`, GLenum `programInterface`, const char \\* `name``)`;\n\n## Parameters\n\n *`program`*  \nThe name of a program object whose resources to query.\n\n *`programInterface`*  \nA token identifying the interface within *`program`* containing the resource named *`name`*.\n\n *`name`*  \nThe name of the resource to query the location of.\n\n## Description\n\n`glGetProgramResourceLocationIndex` returns the fragment color index assigned to the variable named *`name`* in interface *`programInterface`* of program object *`program`*. *`program`* must be the name of a program that has been linked successfully. *`programInterface`* must be `GL_PROGRAM_OUTPUT`.\n\nThe value -1 will be returned if an error occurs, if *`name`* does not identify an active variable on *`programInterface`*, or if *`name`* identifies an active variable that does not have a valid location assigned, as described above. The locations returned by these commands are the same locations returned when querying the `GL_LOCATION` and `GL_LOCATION_INDEX` resource properties.\n\nA string provided to `glGetProgramResourceLocationIndex` is considered to match an active variable if:\n\n- the string exactly matches the name of the active variable\n\n- if the string identifies the base name of an active array, where the string would exactly match the name of the variable if the suffix \"\\[0\\]\" were appended to the string\n\n- if the string identifies an active element of the array, where the string ends with the concatenation of the \"\\[\" character, an integer *with no \"+\" sign, extra leading zeroes, or whitespace* identifying an array element, and the \"\\]\" character, the integer is less than the number of active elements of the array variable, and where the string would exactly match the enumerated name of the array if the decimal integer were replaced with zero.\n\nAny other string is considered not to identify an active variable. If the string specifies an element of an array variable, `glGetProgramResourceLocation` returns the location assigned to that element. If it specifies the base name of an array, it identifies the resources associated with the first element of the array.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n`GL_INVALID_ENUM` is generated if *`programInterface`* is not one of the accepted interface types.\n\n`GL_INVALID_OPERATION` is generated if *`program`* has not been linked successfully.\n\n## Version Support\n\n|                                     | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**         |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramResourceLocationIndex` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgramResourceName](glgetprogramresourcename.xhtml), [glGetProgramResourceIndex](glgetprogramresourceindex.xhtml), [glGetProgramResource](glgetprogramresource.xhtml), [glGetProgramResourceLocationIndex](glgetprogramresourcelocationindex.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResourceLocationIndex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResourceLocationIndex.xhtml)"
- name: glGetProgramResourceName
  id: glgetprogramresourcename.xhtml
  summary: program The name of a program object whose resources to query
  description: "## Name\n\nglGetProgramResourceName — query the name of an indexed resource within a program\n\n## C Specification\n\n`void `**`glGetProgramResourceName`**`(` GLuint `program`, GLenum `programInterface`, GLuint `index`, GLsizei `bufSize`, GLsizei \\* `length`, char \\* `name``)`;\n\n## Parameters\n\n *`program`*  \nThe name of a program object whose resources to query.\n\n *`programInterface`*  \nA token identifying the interface within *`program`* containing the indexed resource.\n\n *`index`*  \nThe index of the resource within *`programInterface`* of *`program`*.\n\n *`bufSize`*  \nThe size of the character array whose address is given by *`name`*.\n\n *`length`*  \nThe address of a variable which will receive the length of the resource name.\n\n *`name`*  \nThe address of a character array into which will be written the name of the resource.\n\n## Description\n\n`glGetProgramResourceName` retrieves the name string assigned to the single active resource with an index of *`index`* in the interface *`programInterface`* of program object *`program`*. *`index`* must be less than the number of entries in the active resource list for *`programInterface`*.\n\n*`program`* must be the name of an existing program object. *`programInterface`* is the name of the interface within *`program`* which contains the resource and must be one of the following values:\n\n `GL_UNIFORM`  \nThe query is targeted at the set of active uniforms within *`program`*.\n\n `GL_UNIFORM_BLOCK`  \nThe query is targeted at the set of active uniform blocks within *`program`*.\n\n `GL_PROGRAM_INPUT`  \nThe query is targeted at the set of active input variables used by the first shader stage of *`program`*. If *`program`* contains multiple shader stages then input variables from any stage other than the first will not be enumerated.\n\n `GL_PROGRAM_OUTPUT`  \nThe query is targeted at the set of active output variables produced by the last shader stage of *`program`*. If *`program`* contains multiple shader stages then output variables from any stage other than the last will not be enumerated.\n\n`GL_VERTEX_SUBROUTINE`,  `GL_TESS_CONTROL_SUBROUTINE`,  `GL_TESS_EVALUATION_SUBROUTINE`,  `GL_GEOMETRY_SUBROUTINE`,  `GL_FRAGMENT_SUBROUTINE`,   `GL_COMPUTE_SUBROUTINE`  \nThe query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of *`program`*, respectively.\n\n`GL_VERTEX_SUBROUTINE_UNIFORM`,  `GL_TESS_CONTROL_SUBROUTINE_UNIFORM`,  `GL_TESS_EVALUATION_SUBROUTINE_UNIFORM`,  `GL_GEOMETRY_SUBROUTINE_UNIFORM`,  `GL_FRAGMENT_SUBROUTINE_UNIFORM`,   `GL_COMPUTE_SUBROUTINE_UNIFORM`  \nThe query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages of *`program`*, respectively.\n\n `GL_TRANSFORM_FEEDBACK_VARYING`  \nThe query is targeted at the set of output variables from the last non-fragment stage of *`program`* that would be captured if transform feedback were active.\n\n `GL_BUFFER_VARIABLE`  \nThe query is targeted at the set of active buffer variables used by *`program`*.\n\n `GL_SHADER_STORAGE_BLOCK`  \nThe query is targeted at the set of active shader storage blocks used by *`program`*.\n\nThe name string assigned to the active resource identified by *`index`* is returned as a null-terminated string in the character array whose address is given in *`name`*. The actual number of characters written into *`name`*, excluding the null terminator, is returned in *`length`*. If *`length`* is NULL, no length is returned. The maximum number of characters that may be written into *`name`*, including the null terminator, is specified by *`bufSize`*. If the length of the name string *including the null terminator* is greater than *`bufSize`*, the first *`bufSize`*-1 characters of the name string will be written to *`name`*, followed by a null terminator. If *`bufSize`* is zero, no error will be generated but no characters will be written to *`name`*. The length of the longest name string for *`programInterface`*\\>, including a null terminator, can be queried by calling [glGetProgramInterface](glgetprograminterface.xhtml) with a *`pname`* of `GL_MAX_NAME_LENGTH`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`programInterface`* is not one of the accepted interface types.\n\n`GL_INVALID_VALUE` is generated if *`progam`* is not the name of an existing program.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the number of entries in the active resource list for *`programInterface`*.\n\n`GL_INVALID_ENUM` is generated if *`programInterface`* is `GL_ATOMIC_COUNTER_BUFFER` or `GL_TRANSFORM_FEEDBACK_BUFFER`, since active atomic counter and transform feedback buffer resources are not assigned name strings.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramResourceName`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgramResourceIndex](glgetprogramresourceindex.xhtml), [glGetProgramResource](glgetprogramresource.xhtml), [glGetProgramResourceLocation](glgetprogramresourcelocation.xhtml), [glGetProgramResourceLocationIndex](glgetprogramresourcelocationindex.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResourceName.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramResourceName.xhtml)"
- name: glGetProgramStage
  id: glgetprogramstage.xhtml
  summary: program Specifies the name of the program containing shader stage
  description: "## Name\n\nglGetProgramStage — retrieve properties of a program object corresponding to a specified shader stage\n\n## C Specification\n\n`void `**`glGetProgramStageiv`**`(` GLuint `program`, GLenum `shadertype`, GLenum `pname`, GLint \\*`values``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of the program containing shader stage.\n\n *`shadertype`*  \nSpecifies the shader stage from which to query for the subroutine parameter. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n *`pname`*  \nSpecifies the parameter of the shader to query. *`pname`* must be `GL_ACTIVE_SUBROUTINE_UNIFORMS`, `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`, `GL_ACTIVE_SUBROUTINES`, `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, or `GL_ACTIVE_SUBROUTINE_MAX_LENGTH`.\n\n *`values`*  \nSpecifies the address of a variable into which the queried value or values will be placed.\n\n## Description\n\n`glGetProgramStage` queries a parameter of a shader stage attached to a program object. *`program`* contains the name of the program to which the shader is attached. *`shadertype`* specifies the stage from which to query the parameter. *`pname`* specifies which parameter should be queried. The value or values of the parameter to be queried is returned in the variable whose address is given in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINE_UNIFORMS`, the number of active subroutine variables in the stage is returned in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`, the number of active subroutine variable locations in the stage is returned in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINES`, the number of active subroutines in the stage is returned in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, the length of the longest subroutine uniform for the stage is returned in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINE_MAX_LENGTH`, the length of the longest subroutine name for the stage is returned in *`values`*. The returned name length includes space for the null-terminator.\n\nIf there is no shader present of type *`shadertype`*, the returned value will be consistent with a shader containing no subroutines or subroutine uniforms.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* or *`pname`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetProgramStageiv`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramStage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramStage.xhtml)"
- name: glGetProgramStageiv
  id: glgetprogramstage.xhtml#glGetProgramStageiv
  summary: Specifies the name of the program containing shader stage
  belongs_to: glGetProgramStage
  description: "`void `**`glGetProgramStageiv`**`(` GLuint `program`, GLenum `shadertype`, GLenum `pname`, GLint \\*`values``)`;\n\n## Parameters\n\n*`program`*\n\nSpecifies the name of the program containing shader stage.\n\n*`shadertype`*\n\nSpecifies the shader stage from which to query for the subroutine parameter. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n*`pname`*\n\nSpecifies the parameter of the shader to query. *`pname`* must be `GL_ACTIVE_SUBROUTINE_UNIFORMS`, `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`, `GL_ACTIVE_SUBROUTINES`, `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, or `GL_ACTIVE_SUBROUTINE_MAX_LENGTH`.\n\n*`values`*\n\nSpecifies the address of a variable into which the queried value or values will be placed.\n\n## Description\n\n`glGetProgramStage` queries a parameter of a shader stage attached to a program object. *`program`* contains the name of the program to which the shader is attached. *`shadertype`* specifies the stage from which to query the parameter. *`pname`* specifies which parameter should be queried. The value or values of the parameter to be queried is returned in the variable whose address is given in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINE_UNIFORMS`, the number of active subroutine variables in the stage is returned in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`, the number of active subroutine variable locations in the stage is returned in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINES`, the number of active subroutines in the stage is returned in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH`, the length of the longest subroutine uniform for the stage is returned in *`values`*.\n\nIf *`pname`* is `GL_ACTIVE_SUBROUTINE_MAX_LENGTH`, the length of the longest subroutine name for the stage is returned in *`values`*. The returned name length includes space for the null-terminator.\n\nIf there is no shader present of type *`shadertype`*, the returned value will be consistent with a shader containing no subroutines or subroutine uniforms.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* or *`pname`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetProgramStageiv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[ glGetProgram ](glgetprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramStage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetProgramStage.xhtml)"
- name: glGetQueryBufferObjecti64v
  id: glgetqueryobject.xhtml#glGetQueryBufferObjecti64v
  summary: null
  belongs_to: glGetQueryObject
  description: '`void `**`glGetQueryBufferObjecti64v`**`(` GLuint `id`, GLuint `buffer`, GLenum `pname`, GLintptr `offset``)`;'
- name: glGetQueryBufferObjectiv
  id: glgetqueryobject.xhtml#glGetQueryBufferObjectiv
  summary: null
  belongs_to: glGetQueryObject
  description: '`void `**`glGetQueryBufferObjectiv`**`(` GLuint `id`, GLuint `buffer`, GLenum `pname`, GLintptr `offset``)`;'
- name: glGetQueryBufferObjectui64v
  id: glgetqueryobject.xhtml#glGetQueryBufferObjectui64v
  summary: Specifies the name of a query object
  belongs_to: glGetQueryObject
  description: "`void `**`glGetQueryBufferObjectui64v`**`(` GLuint `id`, GLuint `buffer`, GLenum `pname`, GLintptr `offset``)`;\n\n## Parameters\n\n*`id`*\n\nSpecifies the name of a query object.\n\n*`buffer`*\n\nSpecifies the name of a buffer object.\n\n*`pname`*\n\nSpecifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`.\n\n*`params`*\n\nIf a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then *`params`* is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then *`params`* is treated as an address in client memory of a variable to receive the resulting data.\n\n*`offset`*\n\nSpecifies the byte offset into *`buffer`*'s data store where the queried result will be written.\n\n## Description\n\nThese commands return a selected parameter of the query object specified by *`id`*. `glGetQueryObject` returns in *`params`* a selected parameter of the query object specified by *`id`*. `glGetQueryBufferObject` returns in *`buffer`* a selected parameter of the query object specified by *`id`*, by writing it to *`buffer`*'s data store at the byte offset specified by *`offset`*.\n\n*`pname`* names a specific query object parameter. *`pname`* can be as follows:\n\n`GL_QUERY_RESULT`\n\n*`params`* or *`buffer`* returns the value of the query object's passed samples counter. The initial value is 0.\n\n`GL_QUERY_RESULT_NO_WAIT`\n\nIf the result of the query is available (that is, a query of `GL_QUERY_RESULT_AVAILABLE` would return non-zero), then *`params`* or *`buffer`* returns the value of the query object's passed samples counter, otherwise, the data referred to by *`params`* or *`buffer`* is not modified. The initial value is 0.\n\n`GL_QUERY_RESULT_AVAILABLE`\n\n*`params`* or *`buffer`* returns whether the passed samples counter is immediately available. If a delay would occur waiting for the query result, `GL_FALSE` is returned. Otherwise, `GL_TRUE` is returned, which also indicates that the results of all previous queries are available as well.\n\n`GL_QUERY_TARGET`\n\n*`params`* or *`buffer`* returns the query object's target.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`* or *`buffer`*.\n\n`glGetQueryObject` and `glGetQueryBufferObject` implicitly flush the GL pipeline so that any incomplete rendering delimited by the occlusion query completes in finite time.\n\nIf multiple queries are issued using the same query object *`id`* before calling `glGetQueryObject` or `glGetQueryBufferObject`, the results of the most recent query will be returned. In this case, when issuing a new query, the results of the previous query are discarded.\n\n`glGetQueryObjecti64v` and `glGetQueryObjectui64v` are available only if the GL version is 3.3 or greater.\n\n`GL_QUERY_RESULT_NO_WAIT` is accepted for *`pname`* only if the GL version is 4.4 or greater.\n\nThe `GL_QUERY_RESULT_BUFFER` target is available only if the GL version is 4.4 or higher. On earlier versions of the GL, *`params`* is always an address in client memory.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is not the name of a query object.\n\n`GL_INVALID_OPERATION` is generated by `glGetQueryBufferObject` if *`buffer`* is not the name of an already created buffer object.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of a currently active query object.\n\n`GL_INVALID_OPERATION` is generated by `glGetQueryObject` if a buffer is currently bound to the `GL_QUERY_RESULT_BUFFER` target and the command would cause data to be written beyond the bounds of that buffer's data store.\n\n`GL_INVALID_OPERATION` is generated by `glGetQueryBufferObject` if the command would cause data to be written beyond the bounds of *`buffer`*'s data store.\n\n`GL_INVALID_VALUE` is generated by `glGetQueryBufferObject` if *`offset`* is negative.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetQueryObjecti64v`        |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetQueryObjectiv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetQueryObjectui64v`       |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetQueryObjectuiv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetQueryBufferObjecti64v`  |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetQueryBufferObjectiv`    |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetQueryBufferObjectui64v` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetQueryBufferObjectuiv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBeginQuery](glbeginquery.xhtml), `glEndQuery`, [glGetQueryiv](glgetqueryiv.xhtml), [glIsQuery](glisquery.xhtml), [glQueryCounter](glquerycounter.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryObject.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryObject.xhtml)"
- name: glGetQueryBufferObjectuiv
  id: glgetqueryobject.xhtml#glGetQueryBufferObjectuiv
  summary: null
  belongs_to: glGetQueryObject
  description: '`void `**`glGetQueryBufferObjectuiv`**`(` GLuint `id`, GLuint `buffer`, GLenum `pname`, GLintptr `offset``)`;'
- name: glGetQueryIndexed
  id: glgetqueryindexed.xhtml
  summary: target Specifies a query object target
  description: "## Name\n\nglGetQueryIndexediv — return parameters of an indexed query object target\n\n## C Specification\n\n`void `**`glGetQueryIndexediv`**`(` GLenum `target`, GLuint `index`, GLenum `pname`, GLint \\* `params``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies a query object target. Must be `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `GL_TIME_ELAPSED`, or `GL_TIMESTAMP`.\n\n *`index`*  \nSpecifies the index of the query object target.\n\n *`pname`*  \nSpecifies the symbolic name of a query object target parameter. Accepted values are `GL_CURRENT_QUERY` or `GL_QUERY_COUNTER_BITS`.\n\n *`params`*  \nReturns the requested data.\n\n## Description\n\n`glGetQueryIndexediv` returns in *`params`* a selected parameter of the indexed query object target specified by *`target`* and *`index`*. *`index`* specifies the index of the query object target and must be between zero and a target-specific maxiumum.\n\n*`pname`* names a specific query object target parameter. When *`pname`* is `GL_CURRENT_QUERY`, the name of the currently active query for the specified *`index`* of *`target`*, or zero if no query is active, will be placed in *`params`*. If *`pname`* is `GL_QUERY_COUNTER_BITS`, the implementation-dependent number of bits used to hold the result of queries for *`target`* is returned in *`params`*.\n\n## Notes\n\nThe target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only if the GL version is 4.3 or greater.\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\nCalling [glGetQueryiv](glgetqueryiv.xhtml) is equivalent to calling `glGetQueryIndexediv` with *`index`* set to zero.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* or *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the *`target`*-specific maximum.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetQueryIndexediv`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetQueryObject](glgetqueryobject.xhtml), [glIsQuery](glisquery.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryIndexed.xhtml)"
- name: glGetQueryIndexediv
  id: glgetqueryindexed.xhtml#glGetQueryIndexediv
  summary: Specifies a query object target
  belongs_to: glGetQueryIndexed
  description: "`void `**`glGetQueryIndexediv`**`(` GLenum `target`, GLuint `index`, GLenum `pname`, GLint \\* `params``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies a query object target. Must be `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `GL_TIME_ELAPSED`, or `GL_TIMESTAMP`.\n\n*`index`*\n\nSpecifies the index of the query object target.\n\n*`pname`*\n\nSpecifies the symbolic name of a query object target parameter. Accepted values are `GL_CURRENT_QUERY` or `GL_QUERY_COUNTER_BITS`.\n\n*`params`*\n\nReturns the requested data.\n\n## Description\n\n`glGetQueryIndexediv` returns in *`params`* a selected parameter of the indexed query object target specified by *`target`* and *`index`*. *`index`* specifies the index of the query object target and must be between zero and a target-specific maxiumum.\n\n*`pname`* names a specific query object target parameter. When *`pname`* is `GL_CURRENT_QUERY`, the name of the currently active query for the specified *`index`* of *`target`*, or zero if no query is active, will be placed in *`params`*. If *`pname`* is `GL_QUERY_COUNTER_BITS`, the implementation-dependent number of bits used to hold the result of queries for *`target`* is returned in *`params`*.\n\n## Notes\n\nThe target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only if the GL version is 4.3 or greater.\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\nCalling [glGetQueryiv](glgetqueryiv.xhtml) is equivalent to calling `glGetQueryIndexediv` with *`index`* set to zero.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* or *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the *`target`*-specific maximum.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetQueryIndexediv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGetQueryObject](glgetqueryobject.xhtml), [glIsQuery](glisquery.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryIndexed.xhtml)"
- name: glGetQueryiv
  id: glgetqueryiv.xhtml
  summary: target Specifies a query object target
  description: "## Name\n\nglGetQueryiv — return parameters of a query object target\n\n## C Specification\n\n`void `**`glGetQueryiv`**`(` GLenum `target`, GLenum `pname`, GLint \\* `params``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies a query object target. Must be `GL_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED`, `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` `GL_PRIMITIVES_GENERATED`, `GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN`, `GL_TIME_ELAPSED`, or `GL_TIMESTAMP`.\n\n *`pname`*  \nSpecifies the symbolic name of a query object target parameter. Accepted values are `GL_CURRENT_QUERY` or `GL_QUERY_COUNTER_BITS`.\n\n *`params`*  \nReturns the requested data.\n\n## Description\n\n`glGetQueryiv` returns in *`params`* a selected parameter of the query object target specified by *`target`*.\n\n*`pname`* names a specific query object target parameter. When *`pname`* is `GL_CURRENT_QUERY`, the name of the currently active query for *`target`*, or zero if no query is active, will be placed in *`params`*. If *`pname`* is `GL_QUERY_COUNTER_BITS`, the implementation-dependent number of bits used to hold the result of queries for *`target`* is returned in *`params`*.\n\n## Notes\n\nThe target `GL_ANY_SAMPLES_PASSED_CONSERVATIVE` is available only if the GL version is 4.3 or greater.\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* or *`pname`* is not an accepted value.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetQueryiv`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetQueryObject](glgetqueryobject.xhtml), [glIsQuery](glisquery.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryiv.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryiv.xhtml)"
- name: glGetQueryObject
  id: glgetqueryobject.xhtml
  summary: id Specifies the name of a query object
  description: "## Name\n\nglGetQueryObject, glGetQueryBufferObject — return parameters of a query object\n\n## C Specification\n\n`void `**`glGetQueryObjectiv`**`(` GLuint `id`, GLenum `pname`, GLint \\* `params``)`;\n\n`void `**`glGetQueryObjectuiv`**`(` GLuint `id`, GLenum `pname`, GLuint \\* `params``)`;\n\n`void `**`glGetQueryObjecti64v`**`(` GLuint `id`, GLenum `pname`, GLint64 \\* `params``)`;\n\n`void `**`glGetQueryObjectui64v`**`(` GLuint `id`, GLenum `pname`, GLuint64 \\* `params``)`;\n\n`void `**`glGetQueryBufferObjectiv`**`(` GLuint `id`, GLuint `buffer`, GLenum `pname`, GLintptr `offset``)`;\n\n`void `**`glGetQueryBufferObjectuiv`**`(` GLuint `id`, GLuint `buffer`, GLenum `pname`, GLintptr `offset``)`;\n\n`void `**`glGetQueryBufferObjecti64v`**`(` GLuint `id`, GLuint `buffer`, GLenum `pname`, GLintptr `offset``)`;\n\n`void `**`glGetQueryBufferObjectui64v`**`(` GLuint `id`, GLuint `buffer`, GLenum `pname`, GLintptr `offset``)`;\n\n## Parameters\n\n *`id`*  \nSpecifies the name of a query object.\n\n *`buffer`*  \nSpecifies the name of a buffer object.\n\n *`pname`*  \nSpecifies the symbolic name of a query object parameter. Accepted values are `GL_QUERY_RESULT`, `GL_QUERY_RESULT_AVAILABLE`, `GL_QUERY_RESULT_NO_WAIT`, or `GL_QUERY_TARGET`.\n\n *`params`*  \nIf a buffer is bound to the `GL_QUERY_RESULT_BUFFER` target, then *`params`* is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to `GL_QUERY_RESULT_BUFFER`, then *`params`* is treated as an address in client memory of a variable to receive the resulting data.\n\n *`offset`*  \nSpecifies the byte offset into *`buffer`*'s data store where the queried result will be written.\n\n## Description\n\nThese commands return a selected parameter of the query object specified by *`id`*. `glGetQueryObject` returns in *`params`* a selected parameter of the query object specified by *`id`*. `glGetQueryBufferObject` returns in *`buffer`* a selected parameter of the query object specified by *`id`*, by writing it to *`buffer`*'s data store at the byte offset specified by *`offset`*.\n\n*`pname`* names a specific query object parameter. *`pname`* can be as follows:\n\n `GL_QUERY_RESULT`  \n*`params`* or *`buffer`* returns the value of the query object's passed samples counter. The initial value is 0.\n\n `GL_QUERY_RESULT_NO_WAIT`  \nIf the result of the query is available (that is, a query of `GL_QUERY_RESULT_AVAILABLE` would return non-zero), then *`params`* or *`buffer`* returns the value of the query object's passed samples counter, otherwise, the data referred to by *`params`* or *`buffer`* is not modified. The initial value is 0.\n\n `GL_QUERY_RESULT_AVAILABLE`  \n*`params`* or *`buffer`* returns whether the passed samples counter is immediately available. If a delay would occur waiting for the query result, `GL_FALSE` is returned. Otherwise, `GL_TRUE` is returned, which also indicates that the results of all previous queries are available as well.\n\n `GL_QUERY_TARGET`  \n*`params`* or *`buffer`* returns the query object's target.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`* or *`buffer`*.\n\n`glGetQueryObject` and `glGetQueryBufferObject` implicitly flush the GL pipeline so that any incomplete rendering delimited by the occlusion query completes in finite time.\n\nIf multiple queries are issued using the same query object *`id`* before calling `glGetQueryObject` or `glGetQueryBufferObject`, the results of the most recent query will be returned. In this case, when issuing a new query, the results of the previous query are discarded.\n\n`glGetQueryObjecti64v` and `glGetQueryObjectui64v` are available only if the GL version is 3.3 or greater.\n\n`GL_QUERY_RESULT_NO_WAIT` is accepted for *`pname`* only if the GL version is 4.4 or greater.\n\nThe `GL_QUERY_RESULT_BUFFER` target is available only if the GL version is 4.4 or higher. On earlier versions of the GL, *`params`* is always an address in client memory.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is not the name of a query object.\n\n`GL_INVALID_OPERATION` is generated by `glGetQueryBufferObject` if *`buffer`* is not the name of an already created buffer object.\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of a currently active query object.\n\n`GL_INVALID_OPERATION` is generated by `glGetQueryObject` if a buffer is currently bound to the `GL_QUERY_RESULT_BUFFER` target and the command would cause data to be written beyond the bounds of that buffer's data store.\n\n`GL_INVALID_OPERATION` is generated by `glGetQueryBufferObject` if the command would cause data to be written beyond the bounds of *`buffer`*'s data store.\n\n`GL_INVALID_VALUE` is generated by `glGetQueryBufferObject` if *`offset`* is negative.\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetQueryObjecti64v`        |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetQueryObjectiv`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetQueryObjectui64v`       |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetQueryObjectuiv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetQueryBufferObjecti64v`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetQueryBufferObjectiv`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetQueryBufferObjectui64v` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetQueryBufferObjectuiv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBeginQuery](glbeginquery.xhtml), `glEndQuery`, [glGetQueryiv](glgetqueryiv.xhtml), [glIsQuery](glisquery.xhtml), [glQueryCounter](glquerycounter.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryObject.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetQueryObject.xhtml)"
- name: glGetQueryObjecti64v
  id: glgetqueryobject.xhtml#glGetQueryObjecti64v
  summary: null
  belongs_to: glGetQueryObject
  description: '`void `**`glGetQueryObjecti64v`**`(` GLuint `id`, GLenum `pname`, GLint64 \* `params``)`;'
- name: glGetQueryObjectiv
  id: glgetqueryobject.xhtml#glGetQueryObjectiv
  summary: null
  belongs_to: glGetQueryObject
  description: '`void `**`glGetQueryObjectiv`**`(` GLuint `id`, GLenum `pname`, GLint \* `params``)`;'
- name: glGetQueryObjectui64v
  id: glgetqueryobject.xhtml#glGetQueryObjectui64v
  summary: null
  belongs_to: glGetQueryObject
  description: '`void `**`glGetQueryObjectui64v`**`(` GLuint `id`, GLenum `pname`, GLuint64 \* `params``)`;'
- name: glGetQueryObjectuiv
  id: glgetqueryobject.xhtml#glGetQueryObjectuiv
  summary: null
  belongs_to: glGetQueryObject
  description: '`void `**`glGetQueryObjectuiv`**`(` GLuint `id`, GLenum `pname`, GLuint \* `params``)`;'
- name: glGetRenderbufferParameter
  id: glgetrenderbufferparameter.xhtml
  summary: target Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv
  description: "## Name\n\nglGetRenderbufferParameteriv, glGetNamedRenderbufferParameteriv — query a named parameter of a renderbuffer object\n\n## C Specification\n\n`void `**`glGetRenderbufferParameteriv`**`(` GLenum `target`, GLenum `pname`, GLint \\*`params``)`;\n\n`void `**`glGetNamedRenderbufferParameteriv`**`(` GLuint `renderbuffer`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the renderbuffer object is bound for `glGetRenderbufferParameteriv`. *`target`* must be `GL_RENDERBUFFER`.\n\n *`renderbuffer`*  \nSpecifies the name of the renderbuffer object for `glGetNamedRenderbufferParameteriv`.\n\n *`pname`*  \nSpecifies the parameter of the renderbuffer object to query.\n\n *`params`*  \nReturns the value of parameter *`pname`* for the renderbuffer object.\n\n## Description\n\n`glGetRenderbufferParameteriv` and `glGetNamedRenderbufferParameteriv` query parameters of a specified renderbuffer object.\n\nFor `glGetRenderbufferParameteriv`, the renderbuffer object is that bound to *`target`*, which must be `GL_RENDERBUFFER`.\n\nFor `glGetNamedRenderbufferParameteriv`, *`renderbuffer`* is the name of the renderbuffer object.\n\nUpon successful return, *`param`* will contain the value of the renderbuffer parameter specified by *`pname`*, as described below.\n\n `GL_RENDERBUFFER_WIDTH`, `GL_RENDERBUFFER_HEIGHT`, `GL_RENDERBUFFER_INTERNAL_FORMAT` or `GL_RENDERBUFFER_SAMPLES`  \n*`params`* returns the width in pixels, the height in pixels, internal format, or the number of samples, respectively, of the image of the specified renderbuffer object.\n\n `GL_RENDERBUFFER_RED_SIZE`, `GL_RENDERBUFFER_GREEN_SIZE`, `GL_RENDERBUFFER_BLUE_SIZE`, `GL_RENDERBUFFER_ALPHA_SIZE`, `GL_RENDERBUFFER_DEPTH_SIZE` or `GL_RENDERBUFFER_STENCIL_SIZE`  \n*`params`* returns the actual resolution in bits (not the resolution specified when the image was defined) for the red, green, blue, alpha, depth or stencil components, respectively, of the image of the renderbuffer object.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetRenderbufferParameteriv` if *`target`* is not `GL_RENDERBUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glGetRenderbufferParameteriv` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetNamedRenderbufferParameteriv` if *`renderbuffer`* is not the name of an existing renderbuffer object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted parameter names described above.\n\n## Version Support\n\n|                                     | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**         |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetNamedRenderbufferParameteriv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetRenderbufferParameteriv`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenRenderbuffers](glgenrenderbuffers.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glBindRenderbuffer](glbindrenderbuffer.xhtml), [glRenderbufferStorage](glrenderbufferstorage.xhtml), [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetRenderbufferParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetRenderbufferParameter.xhtml)"
- name: glGetRenderbufferParameteriv
  id: glgetrenderbufferparameter.xhtml#glGetRenderbufferParameteriv
  summary: null
  belongs_to: glGetRenderbufferParameter
  description: '`void `**`glGetRenderbufferParameteriv`**`(` GLenum `target`, GLenum `pname`, GLint \*`params``)`;'
- name: glGetSamplerParameter
  id: glgetsamplerparameter.xhtml
  summary: sampler Specifies name of the sampler object from which to retrieve parameters
  description: "## Name\n\nglGetSamplerParameter — return sampler parameter values\n\n## C Specification\n\n`void `**`glGetSamplerParameterfv`**`(` GLuint `sampler`, GLenum `pname`, GLfloat \\* `params``)`;\n\n`void `**`glGetSamplerParameteriv`**`(` GLuint `sampler`, GLenum `pname`, GLint \\* `params``)`;\n\n`void `**`glGetSamplerParameterIiv`**`(` GLuint `sampler`, GLenum `pname`, GLint \\* `params``)`;\n\n`void `**`glGetSamplerParameterIuiv`**`(` GLuint `sampler`, GLenum `pname`, GLuint \\* `params``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies name of the sampler object from which to retrieve parameters.\n\n *`pname`*  \nSpecifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted.\n\n *`params`*  \nReturns the sampler parameters.\n\n## Description\n\n`glGetSamplerParameter` returns in *`params`* the value or values of the sampler parameter specified as *`pname`*. *`sampler`* defines the target sampler, and must be the name of an existing sampler object, returned from a previous call to [glGenSamplers](glgensamplers.xhtml). *`pname`* accepts the same symbols as [glSamplerParameter](glsamplerparameter.xhtml), with the same interpretations:\n\n `GL_TEXTURE_MAG_FILTER`  \nReturns the single-valued texture magnification filter, a symbolic constant. The initial value is `GL_LINEAR`.\n\n `GL_TEXTURE_MIN_FILTER`  \nReturns the single-valued texture minification filter, a symbolic constant. The initial value is `GL_NEAREST_MIPMAP_LINEAR`.\n\n `GL_TEXTURE_MIN_LOD`  \nReturns the single-valued texture minimum level-of-detail value. The initial value is −1000.\n\n `GL_TEXTURE_MAX_LOD`  \nReturns the single-valued texture maximum level-of-detail value. The initial value is 1000.\n\n `GL_TEXTURE_WRAP_S`  \nReturns the single-valued wrapping function for texture coordinate *s*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n `GL_TEXTURE_WRAP_T`  \nReturns the single-valued wrapping function for texture coordinate *t*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n `GL_TEXTURE_WRAP_R`  \nReturns the single-valued wrapping function for texture coordinate *r*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n `GL_TEXTURE_BORDER_COLOR`  \nReturns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range \\[0, 1\\]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and −1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).\n\n `GL_TEXTURE_COMPARE_MODE`  \nReturns a single-valued texture comparison mode, a symbolic constant. The initial value is `GL_NONE`. See [glSamplerParameter](glsamplerparameter.xhtml).\n\n `GL_TEXTURE_COMPARE_FUNC`  \nReturns a single-valued texture comparison function, a symbolic constant. The initial value is `GL_LEQUAL`. See [glSamplerParameter](glsamplerparameter.xhtml).\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n`glGetSamplerParameter` is available only if the GL version is 3.3 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`sampler`* is not the name of a sampler object returned from a previous call to [glGenSamplers](glgensamplers.xhtml).\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetSamplerParameterIiv`  |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetSamplerParameterIuiv` |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetSamplerParameterfv`   |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetSamplerParameteriv`   |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glSamplerParameter](glsamplerparameter.xhtml), [glGenSamplers](glgensamplers.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml), [glSamplerParameter](glsamplerparameter.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSamplerParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSamplerParameter.xhtml)"
- name: glGetSamplerParameterfv
  id: glgetsamplerparameter.xhtml#glGetSamplerParameterfv
  summary: null
  belongs_to: glGetSamplerParameter
  description: '`void `**`glGetSamplerParameterfv`**`(` GLuint `sampler`, GLenum `pname`, GLfloat \* `params``)`;'
- name: glGetSamplerParameterIiv
  id: glgetsamplerparameter.xhtml#glGetSamplerParameterIiv
  summary: null
  belongs_to: glGetSamplerParameter
  description: '`void `**`glGetSamplerParameterIiv`**`(` GLuint `sampler`, GLenum `pname`, GLint \* `params``)`;'
- name: glGetSamplerParameterIuiv
  id: glgetsamplerparameter.xhtml#glGetSamplerParameterIuiv
  summary: Specifies name of the sampler object from which to retrieve parameters
  belongs_to: glGetSamplerParameter
  description: "`void `**`glGetSamplerParameterIuiv`**`(` GLuint `sampler`, GLenum `pname`, GLuint \\* `params``)`;\n\n## Parameters\n\n*`sampler`*\n\nSpecifies name of the sampler object from which to retrieve parameters.\n\n*`pname`*\n\nSpecifies the symbolic name of a sampler parameter. `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, and `GL_TEXTURE_COMPARE_FUNC` are accepted.\n\n*`params`*\n\nReturns the sampler parameters.\n\n## Description\n\n`glGetSamplerParameter` returns in *`params`* the value or values of the sampler parameter specified as *`pname`*. *`sampler`* defines the target sampler, and must be the name of an existing sampler object, returned from a previous call to [glGenSamplers](glgensamplers.xhtml). *`pname`* accepts the same symbols as [glSamplerParameter](glsamplerparameter.xhtml), with the same interpretations:\n\n`GL_TEXTURE_MAG_FILTER`\n\nReturns the single-valued texture magnification filter, a symbolic constant. The initial value is `GL_LINEAR`.\n\n`GL_TEXTURE_MIN_FILTER`\n\nReturns the single-valued texture minification filter, a symbolic constant. The initial value is `GL_NEAREST_MIPMAP_LINEAR`.\n\n`GL_TEXTURE_MIN_LOD`\n\nReturns the single-valued texture minimum level-of-detail value. The initial value is −1000.\n\n`GL_TEXTURE_MAX_LOD`\n\nReturns the single-valued texture maximum level-of-detail value. The initial value is 1000.\n\n`GL_TEXTURE_WRAP_S`\n\nReturns the single-valued wrapping function for texture coordinate *s*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n`GL_TEXTURE_WRAP_T`\n\nReturns the single-valued wrapping function for texture coordinate *t*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n`GL_TEXTURE_WRAP_R`\n\nReturns the single-valued wrapping function for texture coordinate *r*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n`GL_TEXTURE_BORDER_COLOR`\n\nReturns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range \\[0, 1\\]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and −1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).\n\n`GL_TEXTURE_COMPARE_MODE`\n\nReturns a single-valued texture comparison mode, a symbolic constant. The initial value is `GL_NONE`. See [glSamplerParameter](glsamplerparameter.xhtml).\n\n`GL_TEXTURE_COMPARE_FUNC`\n\nReturns a single-valued texture comparison function, a symbolic constant. The initial value is `GL_LEQUAL`. See [glSamplerParameter](glsamplerparameter.xhtml).\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n`glGetSamplerParameter` is available only if the GL version is 3.3 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`sampler`* is not the name of a sampler object returned from a previous call to [glGenSamplers](glgensamplers.xhtml).\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetSamplerParameterIiv`    |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetSamplerParameterIuiv`   |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetSamplerParameterfv`     |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetSamplerParameteriv`     |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glSamplerParameter](glsamplerparameter.xhtml), [glGenSamplers](glgensamplers.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml), [glSamplerParameter](glsamplerparameter.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSamplerParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSamplerParameter.xhtml)"
- name: glGetSamplerParameteriv
  id: glgetsamplerparameter.xhtml#glGetSamplerParameteriv
  summary: null
  belongs_to: glGetSamplerParameter
  description: '`void `**`glGetSamplerParameteriv`**`(` GLuint `sampler`, GLenum `pname`, GLint \* `params``)`;'
- name: glGetShader
  id: glgetshader.xhtml
  summary: shader Specifies the shader object to be queried
  description: "## Name\n\nglGetShaderiv — Returns a parameter from a shader object\n\n## C Specification\n\n`void `**`glGetShaderiv`**`(` GLuint `shader`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n *`shader`*  \nSpecifies the shader object to be queried.\n\n *`pname`*  \nSpecifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.\n\n *`params`*  \nReturns the requested object parameter.\n\n## Description\n\n`glGetShader` returns in *`params`* the value of a parameter for a specific shader object. The following parameters are defined:\n\n `GL_SHADER_TYPE`  \n*`params`* returns `GL_VERTEX_SHADER` if *`shader`* is a vertex shader object, `GL_GEOMETRY_SHADER` if *`shader`* is a geometry shader object, and `GL_FRAGMENT_SHADER` if *`shader`* is a fragment shader object.\n\n `GL_DELETE_STATUS`  \n*`params`* returns `GL_TRUE` if *`shader`* is currently flagged for deletion, and `GL_FALSE` otherwise.\n\n `GL_COMPILE_STATUS`  \n*`params`* returns `GL_TRUE` if the last compile operation on *`shader`* was successful, and `GL_FALSE` otherwise.\n\n `GL_INFO_LOG_LENGTH`  \n*`params`* returns the number of characters in the information log for *`shader`* including the null termination character (i.e., the size of the character buffer required to store the information log). If *`shader`* has no information log, a value of 0 is returned.\n\n `GL_SHADER_SOURCE_LENGTH`  \n*`params`* returns the length of the concatenation of the source strings that make up the shader source for the *`shader`*, including the null termination character. (i.e., the size of the character buffer required to store the shader source). If no source code exists, 0 is returned.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`shader`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* does not refer to a shader object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n## Associated Gets\n\n[glGetShaderInfoLog](glgetshaderinfolog.xhtml) with argument *`shader`*\n\n[glGetShaderSource](glgetshadersource.xhtml) with argument *`shader`*\n\n[ glIsShader ](glisshader.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetShaderiv`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCompileShader](glcompileshader.xhtml), [glCreateShader](glcreateshader.xhtml), [glDeleteShader](gldeleteshader.xhtml), [glGetProgram](glgetprogram.xhtml), [glShaderSource](glshadersource.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShader.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShader.xhtml)"
- name: glGetShaderInfoLog
  id: glgetshaderinfolog.xhtml
  summary: shader Specifies the shader object whose information log is to be queried
  description: "## Name\n\nglGetShaderInfoLog — Returns the information log for a shader object\n\n## C Specification\n\n`void `**`glGetShaderInfoLog`**`(` GLuint `shader`, GLsizei `maxLength`, GLsizei \\*`length`, GLchar \\*`infoLog``)`;\n\n## Parameters\n\n *`shader`*  \nSpecifies the shader object whose information log is to be queried.\n\n *`maxLength`*  \nSpecifies the size of the character buffer for storing the returned information log.\n\n *`length`*  \nReturns the length of the string returned in *`infoLog`* (excluding the null terminator).\n\n *`infoLog`*  \nSpecifies an array of characters that is used to return the information log.\n\n## Description\n\n`glGetShaderInfoLog` returns the information log for the specified shader object. The information log for a shader object is modified when the shader is compiled. The string that is returned will be null terminated.\n\n`glGetShaderInfoLog` returns in *`infoLog`* as much of the information log as it can, up to a maximum of *`maxLength`* characters. The number of characters actually returned, excluding the null termination character, is specified by *`length`*. If the length of the returned string is not required, a value of `NULL` can be passed in the *`length`* argument. The size of the buffer required to store the returned information log can be obtained by calling [glGetShader](glgetshader.xhtml) with the value `GL_INFO_LOG_LENGTH`.\n\nThe information log for a shader object is a string that may contain diagnostic messages, warning messages, and other information about the last compile operation. When a shader object is created, its information log will be a string of length 0.\n\n## Notes\n\nThe information log for a shader object is the OpenGL implementer's primary mechanism for conveying information about the compilation process. Therefore, the information log can be helpful to application developers during the development process, even when compilation is successful. Application developers should not expect different OpenGL implementations to produce identical information logs.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`shader`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* is not a shader object.\n\n`GL_INVALID_VALUE` is generated if *`maxLength`* is less than 0.\n\n## Associated Gets\n\n[glGetShader](glgetshader.xhtml) with argument `GL_INFO_LOG_LENGTH`\n\n[ glIsShader ](glisshader.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetShaderInfoLog`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCompileShader](glcompileshader.xhtml), [glGetProgramInfoLog](glgetprograminfolog.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glValidateProgram](glvalidateprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShaderInfoLog.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShaderInfoLog.xhtml)"
- name: glGetShaderiv
  id: glgetshader.xhtml#glGetShaderiv
  summary: Specifies the shader object to be queried
  belongs_to: glGetShader
  description: "`void `**`glGetShaderiv`**`(` GLuint `shader`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n*`shader`*\n\nSpecifies the shader object to be queried.\n\n*`pname`*\n\nSpecifies the object parameter. Accepted symbolic names are `GL_SHADER_TYPE`, `GL_DELETE_STATUS`, `GL_COMPILE_STATUS`, `GL_INFO_LOG_LENGTH`, `GL_SHADER_SOURCE_LENGTH`.\n\n*`params`*\n\nReturns the requested object parameter.\n\n## Description\n\n`glGetShader` returns in *`params`* the value of a parameter for a specific shader object. The following parameters are defined:\n\n`GL_SHADER_TYPE`\n\n*`params`* returns `GL_VERTEX_SHADER` if *`shader`* is a vertex shader object, `GL_GEOMETRY_SHADER` if *`shader`* is a geometry shader object, and `GL_FRAGMENT_SHADER` if *`shader`* is a fragment shader object.\n\n`GL_DELETE_STATUS`\n\n*`params`* returns `GL_TRUE` if *`shader`* is currently flagged for deletion, and `GL_FALSE` otherwise.\n\n`GL_COMPILE_STATUS`\n\n*`params`* returns `GL_TRUE` if the last compile operation on *`shader`* was successful, and `GL_FALSE` otherwise.\n\n`GL_INFO_LOG_LENGTH`\n\n*`params`* returns the number of characters in the information log for *`shader`* including the null termination character (i.e., the size of the character buffer required to store the information log). If *`shader`* has no information log, a value of 0 is returned.\n\n`GL_SHADER_SOURCE_LENGTH`\n\n*`params`* returns the length of the concatenation of the source strings that make up the shader source for the *`shader`*, including the null termination character. (i.e., the size of the character buffer required to store the shader source). If no source code exists, 0 is returned.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`shader`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* does not refer to a shader object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n## Associated Gets\n\n[glGetShaderInfoLog](glgetshaderinfolog.xhtml) with argument *`shader`*\n\n[glGetShaderSource](glgetshadersource.xhtml) with argument *`shader`*\n\n[ glIsShader ](glisshader.xhtml)\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetShaderiv`               |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glCompileShader](glcompileshader.xhtml), [glCreateShader](glcreateshader.xhtml), [glDeleteShader](gldeleteshader.xhtml), [glGetProgram](glgetprogram.xhtml), [glShaderSource](glshadersource.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShader.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShader.xhtml)"
- name: glGetShaderPrecisionFormat
  id: glgetshaderprecisionformat.xhtml
  summary: shaderType Specifies the type of shader whose precision to query
  description: "## Name\n\nglGetShaderPrecisionFormat — retrieve the range and precision for numeric formats supported by the shader compiler\n\n## C Specification\n\n`void `**`glGetShaderPrecisionFormat`**`(` GLenum `shaderType`, GLenum `precisionType`, GLint \\*`range`, GLint \\*`precision``)`;\n\n## Parameters\n\n *`shaderType`*  \nSpecifies the type of shader whose precision to query. *`shaderType`* must be `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`.\n\n *`precisionType`*  \nSpecifies the numeric format whose precision and range to query.\n\n *`range`*  \nSpecifies the address of array of two integers into which encodings of the implementation's numeric range are returned.\n\n *`precision`*  \nSpecifies the address of an integer into which the numeric precision of the implementation is written.\n\n## Description\n\n`glGetShaderPrecisionFormat` retrieves the numeric range and precision for the implementation's representation of quantities in different numeric formats in specified shader type. *`shaderType`* specifies the type of shader for which the numeric precision and range is to be retrieved and must be one of `GL_VERTEX_SHADER` or `GL_FRAGMENT_SHADER`. *`precisionType`* specifies the numeric format to query and must be one of `GL_LOW_FLOAT`, `GL_MEDIUM_FLOAT` `GL_HIGH_FLOAT`, `GL_LOW_INT`, `GL_MEDIUM_INT`, or `GL_HIGH_INT`.\n\n*`range`* points to an array of two integers into which the format's numeric range will be returned. If min and max are the smallest values representable in the format, then the values returned are defined to be: *`range`*\\[0\\] = floor(log2(\\|min\\|)) and *`range`*\\[1\\] = floor(log2(\\|max\\|)).\n\n*`precision`* specifies the address of an integer into which will be written the log2 value of the number of bits of precision of the format. If the smallest representable value greater than 1 is 1 + *eps*, then the integer addressed by *`precision`* will contain floor(-log2(eps)).\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shaderType`* or *`precisionType`* is not an accepted value.\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetShaderPrecisionFormat` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShaderPrecisionFormat.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShaderPrecisionFormat.xhtml)"
- name: glGetShaderSource
  id: glgetshadersource.xhtml
  summary: shader Specifies the shader object to be queried
  description: "## Name\n\nglGetShaderSource — Returns the source code string from a shader object\n\n## C Specification\n\n`void `**`glGetShaderSource`**`(` GLuint `shader`, GLsizei `bufSize`, GLsizei \\*`length`, GLchar \\*`source``)`;\n\n## Parameters\n\n *`shader`*  \nSpecifies the shader object to be queried.\n\n *`bufSize`*  \nSpecifies the size of the character buffer for storing the returned source code string.\n\n *`length`*  \nReturns the length of the string returned in *`source`* (excluding the null terminator).\n\n *`source`*  \nSpecifies an array of characters that is used to return the source code string.\n\n## Description\n\n`glGetShaderSource` returns the concatenation of the source code strings from the shader object specified by *`shader`*. The source code strings for a shader object are the result of a previous call to [glShaderSource](glshadersource.xhtml). The string returned by the function will be null terminated.\n\n`glGetShaderSource` returns in *`source`* as much of the source code string as it can, up to a maximum of *`bufSize`* characters. The number of characters actually returned, excluding the null termination character, is specified by *`length`*. If the length of the returned string is not required, a value of `NULL` can be passed in the *`length`* argument. The size of the buffer required to store the returned source code string can be obtained by calling [glGetShader](glgetshader.xhtml) with the value `GL_SHADER_SOURCE_LENGTH`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`shader`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* is not a shader object.\n\n`GL_INVALID_VALUE` is generated if *`bufSize`* is less than 0.\n\n## Associated Gets\n\n[glGetShader](glgetshader.xhtml) with argument `GL_SHADER_SOURCE_LENGTH`\n\n[ glIsShader ](glisshader.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetShaderSource`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCreateShader](glcreateshader.xhtml), [glShaderSource](glshadersource.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShaderSource.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetShaderSource.xhtml)"
- name: glGetString
  id: glgetstring.xhtml
  summary: name Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION
  description: "## Name\n\nglGetString — return a string describing the current GL connection\n\n## C Specification\n\n`const GLubyte *`**`glGetString`**`(` GLenum `name``)`;\n\n`const GLubyte *`**`glGetStringi`**`(` GLenum `name`, GLuint `index``)`;\n\n## Parameters\n\n *`name`*  \nSpecifies a symbolic constant, one of `GL_VENDOR`, `GL_RENDERER`, `GL_VERSION`, or `GL_SHADING_LANGUAGE_VERSION`. Additionally, `glGetStringi` accepts the `GL_EXTENSIONS` token.\n\n *`index`*  \nFor `glGetStringi`, specifies the index of the string to return.\n\n## Description\n\n`glGetString` returns a pointer to a static string describing some aspect of the current GL connection. *`name`* can be one of the following:\n\n `GL_VENDOR`  \nReturns the company responsible for this GL implementation. This name does not change from release to release.\n\n `GL_RENDERER`  \nReturns the name of the renderer. This name is typically specific to a particular configuration of a hardware platform. It does not change from release to release.\n\n `GL_VERSION`  \nReturns a version or release number.\n\n `GL_SHADING_LANGUAGE_VERSION`  \nReturns a version or release number for the shading language.\n\n`glGetStringi` returns a pointer to a static string indexed by *`index`*. *`name`* can be one of the following:\n\n `GL_EXTENSIONS`  \nFor `glGetStringi` only, returns the extension string supported by the implementation at *`index`*.\n\nStrings `GL_VENDOR` and `GL_RENDERER` together uniquely specify a platform. They do not change from release to release and should be used by platform-recognition algorithms.\n\nThe `GL_VERSION` and `GL_SHADING_LANGUAGE_VERSION` strings begin with a version number. The version number uses one of these forms:\n\n*major_number.minor_number* *major_number.minor_number.release_number*\n\nVendor-specific information may follow the version number. Its format depends on the implementation, but a space always separates the version number and the vendor-specific information.\n\nAll strings are null-terminated.\n\n## Notes\n\nIf an error is generated, `glGetString` returns 0.\n\nThe client and server may support different versions. `glGetString` always returns a compatible version number. The release number always describes the server.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`name`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated by `glGetStringi` if *`index`* is outside the valid range for indexed state *`name`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetString`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetStringi`              |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetString.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetString.xhtml)"
- name: glGetStringi
  id: glgetstring.xhtml#glGetStringi
  summary: Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION
  belongs_to: glGetString
  description: "`const GLubyte *`**`glGetStringi`**`(` GLenum `name`, GLuint `index``)`;\n\n## Parameters\n\n*`name`*\n\nSpecifies a symbolic constant, one of `GL_VENDOR`, `GL_RENDERER`, `GL_VERSION`, or `GL_SHADING_LANGUAGE_VERSION`. Additionally, `glGetStringi` accepts the `GL_EXTENSIONS` token.\n\n*`index`*\n\nFor `glGetStringi`, specifies the index of the string to return.\n\n## Description\n\n`glGetString` returns a pointer to a static string describing some aspect of the current GL connection. *`name`* can be one of the following:\n\n`GL_VENDOR`\n\nReturns the company responsible for this GL implementation. This name does not change from release to release.\n\n`GL_RENDERER`\n\nReturns the name of the renderer. This name is typically specific to a particular configuration of a hardware platform. It does not change from release to release.\n\n`GL_VERSION`\n\nReturns a version or release number.\n\n`GL_SHADING_LANGUAGE_VERSION`\n\nReturns a version or release number for the shading language.\n\n`glGetStringi` returns a pointer to a static string indexed by *`index`*. *`name`* can be one of the following:\n\n`GL_EXTENSIONS`\n\nFor `glGetStringi` only, returns the extension string supported by the implementation at *`index`*.\n\nStrings `GL_VENDOR` and `GL_RENDERER` together uniquely specify a platform. They do not change from release to release and should be used by platform-recognition algorithms.\n\nThe `GL_VERSION` and `GL_SHADING_LANGUAGE_VERSION` strings begin with a version number. The version number uses one of these forms:\n\n*major_number.minor_number* *major_number.minor_number.release_number*\n\nVendor-specific information may follow the version number. Its format depends on the implementation, but a space always separates the version number and the vendor-specific information.\n\nAll strings are null-terminated.\n\n## Notes\n\nIf an error is generated, `glGetString` returns 0.\n\nThe client and server may support different versions. `glGetString` always returns a compatible version number. The release number always describes the server.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`name`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated by `glGetStringi` if *`index`* is outside the valid range for indexed state *`name`*.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetString`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetStringi`                |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetString.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetString.xhtml)"
- name: glGetSubroutineIndex
  id: glgetsubroutineindex.xhtml
  summary: program Specifies the name of the program containing shader stage
  description: "## Name\n\nglGetSubroutineIndex — retrieve the index of a subroutine uniform of a given shader stage within a program\n\n## C Specification\n\n`GLuint `**`glGetSubroutineIndex`**`(` GLuint `program`, GLenum `shadertype`, const GLchar \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of the program containing shader stage.\n\n *`shadertype`*  \nSpecifies the shader stage from which to query for subroutine uniform index. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n *`name`*  \nSpecifies the name of the subroutine uniform whose index to query.\n\n## Description\n\n`glGetSubroutineIndex` returns the index of a subroutine uniform within a shader stage attached to a program object. *`program`* contains the name of the program to which the shader is attached. *`shadertype`* specifies the stage from which to query shader subroutine index. *`name`* contains the null-terminated name of the subroutine uniform whose name to query.\n\nIf *`name`* is not the name of a subroutine uniform in the shader stage, `GL_INVALID_INDEX` is returned, but no error is generated. If *`name`* is the name of a subroutine uniform in the shader stage, a value between zero and the value of `GL_ACTIVE_SUBROUTINES` minus one will be returned. Subroutine indices are assigned using consecutive integers in the range from zero to the value of `GL_ACTIVE_SUBROUTINES` minus one for the shader stage.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* or *`pname`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetSubroutineIndex`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetActiveSubroutineUniform](glgetactivesubroutineuniform.xhtml), [glGetActiveSubroutineUniformName](glgetactivesubroutineuniformname.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSubroutineIndex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSubroutineIndex.xhtml)"
- name: glGetSubroutineUniformLocation
  id: glgetsubroutineuniformlocation.xhtml
  summary: program Specifies the name of the program containing shader stage
  description: "## Name\n\nglGetSubroutineUniformLocation — retrieve the location of a subroutine uniform of a given shader stage within a program\n\n## C Specification\n\n`GLint `**`glGetSubroutineUniformLocation`**`(` GLuint `program`, GLenum `shadertype`, const GLchar \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of the program containing shader stage.\n\n *`shadertype`*  \nSpecifies the shader stage from which to query for subroutine uniform index. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n *`name`*  \nSpecifies the name of the subroutine uniform whose index to query.\n\n## Description\n\n`glGetSubroutineUniformLocation` returns the location of the subroutine uniform variable *`name`* in the shader stage of type *`shadertype`* attached to *`program`*, with behavior otherwise identical to [glGetUniformLocation](glgetuniformlocation.xhtml).\n\nIf *`name`* is not the name of a subroutine uniform in the shader stage, -1 is returned, but no error is generated. If *`name`* is the name of a subroutine uniform in the shader stage, a value between zero and the value of `GL_ACTIVE_SUBROUTINE_LOCATIONS` minus one will be returned. Subroutine locations are assigned using consecutive integers in the range from zero to the value of `GL_ACTIVE_SUBROUTINE_LOCATIONS` minus one for the shader stage. For active subroutine uniforms declared as arrays, the declared array elements are assigned consecutive locations.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* or *`pname`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of an existing program object.\n\n## Version Support\n\n|                                  | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:---------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**      |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetSubroutineUniformLocation` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetActiveSubroutineUniform](glgetactivesubroutineuniform.xhtml), [glGetActiveSubroutineUniformName](glgetactivesubroutineuniformname.xhtml), [glGetUniformLocation](glgetuniformlocation.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSubroutineUniformLocation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSubroutineUniformLocation.xhtml)"
- name: glGetSync
  id: glgetsync.xhtml
  summary: sync Specifies the sync object whose properties to query
  description: "## Name\n\nglGetSynciv — query the properties of a sync object\n\n## C Specification\n\n`void `**`glGetSynciv`**`(` GLsync `sync`, GLenum `pname`, GLsizei `bufSize`, GLsizei \\*`length`, GLint \\*`values``)`;\n\n## Parameters\n\n *`sync`*  \nSpecifies the sync object whose properties to query.\n\n *`pname`*  \nSpecifies the parameter whose value to retrieve from the sync object specified in *`sync`*.\n\n *`bufSize`*  \nSpecifies the size of the buffer whose address is given in *`values`*.\n\n *`length`*  \nSpecifies the address of an variable to receive the number of integers placed in *`values`*.\n\n *`values`*  \nSpecifies the address of an array to receive the values of the queried parameter.\n\n## Description\n\n`glGetSynciv` retrieves properties of a sync object. *`sync`* specifies the name of the sync object whose properties to retrieve.\n\nOn success, `glGetSynciv` replaces up to *`bufSize`* integers in *`values`* with the corresponding property values of the object being queried. The actual number of integers replaced is returned in the variable whose address is specified in *`length`*. If *`length`* is `NULL`, no length is returned.\n\nIf *`pname`* is `GL_OBJECT_TYPE`, a single value representing the specific type of the sync object is placed in *`values`*. The only type supported is `GL_SYNC_FENCE`.\n\nIf *`pname`* is `GL_SYNC_STATUS`, a single value representing the status of the sync object (`GL_SIGNALED` or `GL_UNSIGNALED`) is placed in *`values`*.\n\nIf *`pname`* is `GL_SYNC_CONDITION`, a single value representing the condition of the sync object is placed in *`values`*. The only condition supported is `GL_SYNC_GPU_COMMANDS_COMPLETE`.\n\nIf *`pname`* is `GL_SYNC_FLAGS`, a single value representing the flags with which the sync object was created is placed in *`values`*. No flags are currently supported[^(\\[1\\])](#ftn.id-1.6.7.4).\n\nIf an error occurs, nothing will be written to *`values`* or *`length`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`sync`* is not the name of a sync object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted tokens.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetSynciv`               |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glFenceSync](glfencesync.xhtml), [glWaitSync](glwaitsync.xhtml), [glClientWaitSync](glclientwaitsync.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\n  \n\n------------------------------------------------------------------------\n\n[^(\\[1\\])](#id-1.6.7.4) *`flags`* is expected to be used in future extensions to the sync objects.\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSync.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSync.xhtml)"
- name: glGetSynciv
  id: glgetsync.xhtml#glGetSynciv
  summary: Specifies the sync object whose properties to query
  belongs_to: glGetSync
  description: "`void `**`glGetSynciv`**`(` GLsync `sync`, GLenum `pname`, GLsizei `bufSize`, GLsizei \\*`length`, GLint \\*`values``)`;\n\n## Parameters\n\n*`sync`*\n\nSpecifies the sync object whose properties to query.\n\n*`pname`*\n\nSpecifies the parameter whose value to retrieve from the sync object specified in *`sync`*.\n\n*`bufSize`*\n\nSpecifies the size of the buffer whose address is given in *`values`*.\n\n*`length`*\n\nSpecifies the address of an variable to receive the number of integers placed in *`values`*.\n\n*`values`*\n\nSpecifies the address of an array to receive the values of the queried parameter.\n\n## Description\n\n`glGetSynciv` retrieves properties of a sync object. *`sync`* specifies the name of the sync object whose properties to retrieve.\n\nOn success, `glGetSynciv` replaces up to *`bufSize`* integers in *`values`* with the corresponding property values of the object being queried. The actual number of integers replaced is returned in the variable whose address is specified in *`length`*. If *`length`* is `NULL`, no length is returned.\n\nIf *`pname`* is `GL_OBJECT_TYPE`, a single value representing the specific type of the sync object is placed in *`values`*. The only type supported is `GL_SYNC_FENCE`.\n\nIf *`pname`* is `GL_SYNC_STATUS`, a single value representing the status of the sync object (`GL_SIGNALED` or `GL_UNSIGNALED`) is placed in *`values`*.\n\nIf *`pname`* is `GL_SYNC_CONDITION`, a single value representing the condition of the sync object is placed in *`values`*. The only condition supported is `GL_SYNC_GPU_COMMANDS_COMPLETE`.\n\nIf *`pname`* is `GL_SYNC_FLAGS`, a single value representing the flags with which the sync object was created is placed in *`values`*. No flags are currently supported[^(\\[1\\])](#ftn.id-1.6.7.4).\n\nIf an error occurs, nothing will be written to *`values`* or *`length`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`sync`* is not the name of a sync object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted tokens.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetSynciv`                 |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glFenceSync](glfencesync.xhtml), [glWaitSync](glwaitsync.xhtml), [glClientWaitSync](glclientwaitsync.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\n  \n\n------------------------------------------------------------------------\n\n[^(\\[1\\])](#id-1.6.7.4) *`flags`* is expected to be used in future extensions to the sync objects.\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSync.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetSync.xhtml)"
- name: glGetTexImage
  id: glgetteximage.xhtml
  summary: target Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions
  description: "## Name\n\nglGetTexImage — return a texture image\n\n## C Specification\n\n`void `**`glGetTexImage`**`(` GLenum `target`, GLint `level`, GLenum `format`, GLenum `type`, void \\* `pixels``)`;\n\n`void `**`glGetnTexImage`**`(` GLenum `target`, GLint `level`, GLenum `format`, GLenum `type`, GLsizei `bufSize`, void \\*`pixels``)`;\n\n`void `**`glGetTextureImage`**`(` GLuint `texture`, GLint `level`, GLenum `format`, GLenum `type`, GLsizei `bufSize`, void \\*`pixels``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glGetTexImage` and `glGetnTexImage` functions. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are acceptable.\n\n *`texture`*  \nSpecifies the texture object name.\n\n *`level`*  \nSpecifies the level-of-detail number of the desired image. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`format`*  \nSpecifies a pixel format for the returned data. The supported formats are `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RG`, `GL_RGB`, `GL_RGBA`, `GL_BGR`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_GREEN_INTEGER`, `GL_BLUE_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGR_INTEGER`, `GL_BGRA_INTEGER`.\n\n *`type`*  \nSpecifies a pixel type for the returned data. The supported types are `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.\n\n *`bufSize`*  \nSpecifies the size of the buffer *`pixels`* for `glGetnTexImage` and `glGetTextureImage` functions.\n\n *`pixels`*  \nReturns the texture image. Should be a pointer to an array of the type specified by *`type`*.\n\n## Description\n\n`glGetTexImage`, `glGetnTexImage` and `glGetTextureImage` functions return a texture image into *`pixels`*. For `glGetTexImage` and `glGetnTexImage`, *`target`* specifies whether the desired texture image is one specified by [glTexImage1D](glteximage1d.xhtml) (`GL_TEXTURE_1D`), [glTexImage2D](glteximage2d.xhtml) (`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D` or any of `GL_TEXTURE_CUBE_MAP_*`), or [glTexImage3D](glteximage3d.xhtml) (`GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_ARRAY`). For `glGetTextureImage`, *`texture`* specifies the texture object name. In addition to types of textures accepted by `glGetTexImage` and `glGetnTexImage`, the function also accepts cube map texture objects (with effective target `GL_TEXTURE_CUBE_MAP`). *`level`* specifies the level-of-detail number of the desired image. *`format`* and *`type`* specify the format and type of the desired image array. See the reference page for [glTexImage1D](glteximage1d.xhtml) for a description of the acceptable values for the *`format`* and *`type`* parameters, respectively. For glGetnTexImage and glGetTextureImage functions, bufSize tells the size of the buffer to receive the retrieved pixel data. `glGetnTexImage` and `glGetTextureImage` do not write more than *`bufSize`* bytes into *`pixels`*.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is requested, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\nTo understand the operation of `glGetTexImage`, consider the selected internal four-component texture image to be an RGBA color buffer the size of the image. The semantics of `glGetTexImage` are then identical to those of [glReadPixels](glreadpixels.xhtml), with the exception that no pixel transfer operations are performed, when called with the same *`format`* and *`type`*, with *x* and *y* set to 0, *width* set to the width of the texture image and *height* set to 1 for 1D images, or to the height of the texture image for 2D images.\n\nIf the selected texture image does not contain four components, the following mappings are applied. Single-component textures are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to 1.\n\nTo determine the required size of *`pixels`*, use [glGetTexLevelParameter](glgettexlevelparameter.xhtml) to determine the dimensions of the internal texture image, then scale the required number of pixels by the storage required for each pixel, based on *`format`* and *`type`*. Be sure to take the pixel storage parameters into account, especially `GL_PACK_ALIGNMENT`.\n\nIf `glGetTextureImage` is used against a cube map texture object, the texture is treated as a three-dimensional image of a depth of 6, where the cube map faces are ordered as image layers, in an order presented in the table below:\n\n| Layer number | Cube Map Face                  |\n|--------------|--------------------------------|\n| 0            | GL_TEXTURE_CUBE_MAP_POSITIVE_X |\n| 1            | GL_TEXTURE_CUBE_MAP_NEGATIVE_X |\n| 2            | GL_TEXTURE_CUBE_MAP_POSITIVE_Y |\n| 3            | GL_TEXTURE_CUBE_MAP_NEGATIVE_Y |\n| 4            | GL_TEXTURE_CUBE_MAP_POSITIVE_Z |\n| 5            | GL_TEXTURE_CUBE_MAP_NEGATIVE_Z |\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`pixels`*.\n\n`glGetTexImage` and `glGetnTexImage` return the texture image for the active texture unit.\n\n`GL_STENCIL_INDEX` is accepted for *`format`* only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetTexImage` and `glGetnTexImage` functions if *`target`* is not an accepted value. These include:\n\n- `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, and `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z` for `glGetTexImage` and `glGetnTexImage` functions.\n\n- `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, and `GL_TEXTURE_CUBE_MAP` for `glGetTextureImage` function.\n\n`GL_INVALID_OPERATION` is generated by `glGetTextureImage` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`format`*, or *`type`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂(*max* ), where *max*  is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`level`* is non-zero and the effective target is `GL_TEXTURE_RECTANGLE`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, or `GL_UNSIGNED_INT_10F_11F_11F_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, or `GL_UNSIGNED_INT_5_9_9_9_REV` and *`format`* is neither `GL_RGBA` or `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX` or `GL_DEPTH_STENCIL`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and *`pixels`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetTextureImage` and `glGetnTexImage` if the buffer size required to store the requested data is greater than *`bufSize`*.\n\n## Associated Gets\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_WIDTH`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_HEIGHT`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_INTERNAL_FORMAT`\n\n[glGet](glget.xhtml) with arguments `GL_PACK_ALIGNMENT` and others\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_PACK_BUFFER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetTexImage`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetTextureImage`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetnTexImage`            |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glReadPixels](glreadpixels.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexImage.xhtml)"
- name: glGetTexLevelParameter
  id: glgettexlevelparameter.xhtml
  summary: target Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions
  description: "## Name\n\nglGetTexLevelParameter — return texture parameter values for a specific level of detail\n\n## C Specification\n\n`void `**`glGetTexLevelParameterfv`**`(` GLenum `target`, GLint `level`, GLenum `pname`, GLfloat \\* `params``)`;\n\n`void `**`glGetTexLevelParameteriv`**`(` GLenum `target`, GLint `level`, GLenum `pname`, GLint \\* `params``)`;\n\n`void `**`glGetTextureLevelParameterfv`**`(` GLuint `texture`, GLint `level`, GLenum `pname`, GLfloat \\*`params``)`;\n\n`void `**`glGetTextureLevelParameteriv`**`(` GLuint `texture`, GLint `level`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glGetTexLevelParameterfv` and `glGetTexLevelParameteriv` functions. Must be one of the following values: `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_PROXY_TEXTURE_1D`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_3D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_2D_MULTISAMPLE`, `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_PROXY_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_BUFFER`.\n\n *`texture`*  \nSpecifies the texture object name for `glGetTextureLevelParameterfv` and `glGetTextureLevelParameteriv` functions.\n\n *`level`*  \nSpecifies the level-of-detail number of the desired image. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`pname`*  \nSpecifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`, and `GL_TEXTURE_BUFFER_OFFSET` are accepted.\n\n *`params`*  \nReturns the requested data.\n\n## Description\n\n`glGetTexLevelParameterfv`, `glGetTexLevelParameteriv`, `glGetTextureLevelParameterfv` and `glGetTextureLevelParameteriv` return in *`params`* texture parameter values for a specific level-of-detail value, specified as *`level`*. For the first two functions, *`target`* defines the target texture, either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_1D`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`. The remaining two take a *`texture`* argument which specifies the name of the texture object.\n\n`GL_MAX_TEXTURE_SIZE`, and `GL_MAX_3D_TEXTURE_SIZE` are not really descriptive enough. It has to report the largest square texture image that can be accommodated with mipmaps but a long skinny texture, or a texture without mipmaps may easily fit in texture memory. The proxy targets allow the user to more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot be accommodated, the texture state variables, which may be queried with `glGetTexLevelParameter` and `glGetTextureLevelParameter`, are set to 0. If the texture can be accommodated, the texture state values will be set as they would be set for a non-proxy target.\n\n*`pname`* specifies the texture parameter whose value or values will be returned.\n\nThe accepted parameter names are as follows:\n\n `GL_TEXTURE_WIDTH`  \n*`params`* returns a single value, the width of the texture image. The initial value is 0.\n\n `GL_TEXTURE_HEIGHT`  \n*`params`* returns a single value, the height of the texture image. The initial value is 0.\n\n `GL_TEXTURE_DEPTH`  \n*`params`* returns a single value, the depth of the texture image. The initial value is 0.\n\n `GL_TEXTURE_INTERNAL_FORMAT`  \n*`params`* returns a single value, the internal format of the texture image.\n\n`GL_TEXTURE_RED_TYPE`, `GL_TEXTURE_GREEN_TYPE`, `GL_TEXTURE_BLUE_TYPE`, `GL_TEXTURE_ALPHA_TYPE`, `GL_TEXTURE_DEPTH_TYPE`  \nThe data type used to store the component. The types `GL_NONE`, `GL_SIGNED_NORMALIZED`, `GL_UNSIGNED_NORMALIZED`, `GL_FLOAT`, `GL_INT`, and `GL_UNSIGNED_INT` may be returned to indicate signed normalized fixed-point, unsigned normalized fixed-point, floating-point, integer unnormalized, and unsigned integer unnormalized components, respectively.\n\n`GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`  \nThe internal storage resolution of an individual component. The resolution chosen by the GL will be a close match for the resolution requested by the user with the component argument of [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), and [glCopyTexImage2D](glcopyteximage2d.xhtml). The initial value is 0.\n\n `GL_TEXTURE_COMPRESSED`  \n*`params`* returns a single boolean value indicating if the texture image is stored in a compressed internal format. The initiali value is `GL_FALSE`.\n\n `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`  \n*`params`* returns a single integer value, the number of unsigned bytes of the compressed texture image that would be returned from [glGetCompressedTexImage](glgetcompressedteximage.xhtml).\n\n `GL_TEXTURE_BUFFER_OFFSET`  \n*`params`* returns a single integer value, the offset into the data store of the buffer bound to a buffer texture. [glTexBufferRange](gltexbufferrange.xhtml).\n\n `GL_TEXTURE_BUFFER_SIZE`  \n*`params`* returns a single integer value, the size of the range of a data store of the buffer bound to a buffer texture. [glTexBufferRange](gltexbufferrange.xhtml).\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n`glGetTexLevelParameter` returns the texture level parameters for the active texture unit.\n\n`GL_TEXTURE_BUFFER_OFFSET` and `GL_TEXTURE_BUFFER_SIZE` are available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glGetTextureLevelParameterfv` and `glGetTextureLevelParameteriv` functions if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated by `glGetTexLevelParameterfv` and `glGetTexLevelParameteriv` functions if *`target`* or *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂ *max*, where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`target`* is `GL_TEXTURE_BUFFER` and *`level`* is not zero.\n\n`GL_INVALID_OPERATION` is generated if `GL_TEXTURE_COMPRESSED_IMAGE_SIZE` is queried on texture images with an uncompressed internal format or on proxy targets.\n\n## Version Support\n\n|                                | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**    |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetTexLevelParameterfv`     |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetTexLevelParameteriv`     |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetTextureLevelParameterfv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetTextureLevelParameteriv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexLevelParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexLevelParameter.xhtml)"
- name: glGetTexLevelParameterfv
  id: glgettexlevelparameter.xhtml#glGetTexLevelParameterfv
  summary: null
  belongs_to: glGetTexLevelParameter
  description: '`void `**`glGetTexLevelParameterfv`**`(` GLenum `target`, GLint `level`, GLenum `pname`, GLfloat \* `params``)`;'
- name: glGetTexLevelParameteriv
  id: glgettexlevelparameter.xhtml#glGetTexLevelParameteriv
  summary: null
  belongs_to: glGetTexLevelParameter
  description: '`void `**`glGetTexLevelParameteriv`**`(` GLenum `target`, GLint `level`, GLenum `pname`, GLint \* `params``)`;'
- name: glGetTexParameter
  id: glgettexparameter.xhtml
  summary: target Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions
  description: "## Name\n\nglGetTexParameter — return texture parameter values\n\n## C Specification\n\n`void `**`glGetTexParameterfv`**`(` GLenum `target`, GLenum `pname`, GLfloat \\* `params``)`;\n\n`void `**`glGetTexParameteriv`**`(` GLenum `target`, GLenum `pname`, GLint \\* `params``)`;\n\n`void `**`glGetTexParameterIiv`**`(` GLenum `target`, GLenum `pname`, GLint \\* `params``)`;\n\n`void `**`glGetTexParameterIuiv`**`(` GLenum `target`, GLenum `pname`, GLuint \\* `params``)`;\n\n`void `**`glGetTextureParameterfv`**`(` GLuint `texture`, GLenum `pname`, GLfloat \\*`params``)`;\n\n`void `**`glGetTextureParameteriv`**`(` GLuint `texture`, GLenum `pname`, GLint \\*`params``)`;\n\n`void `**`glGetTextureParameterIiv`**`(` GLuint `texture`, GLenum `pname`, GLint \\*`params``)`;\n\n`void `**`glGetTextureParameterIuiv`**`(` GLuint `texture`, GLenum `pname`, GLuint \\*`params``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glGetTexParameterfv`, `glGetTexParameteriv`, `glGetTexParameterIiv`, and `glGetTexParameterIuiv` functions. `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_RECTANGLE`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are accepted.\n\n *`texture`*  \nSpecifies the texture object name for `glGetTextureParameterfv`, `glGetTextureParameteriv`, `glGetTextureParameterIiv`, and `glGetTextureParameterIuiv` functions.\n\n *`pname`*  \nSpecifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.\n\n *`params`*  \nReturns the texture parameters.\n\n## Description\n\n`glGetTexParameter` and `glGetTextureParameter` return in *`params`* the value or values of the texture parameter specified as *`pname`*. *`target`* defines the target texture. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` specify one-, two-, or three-dimensional, one-dimensional array, two-dimensional array, rectangle, cube-mapped or cube-mapped array, two-dimensional multisample, or two-dimensional multisample array texturing, respectively. *`pname`* accepts the same symbols as [glTexParameter](gltexparameter.xhtml), with the same interpretations:\n\n `GL_DEPTH_STENCIL_TEXTURE_MODE`  \nReturns the single-value depth stencil texture mode, a symbolic constant. The initial value is `GL_DEPTH_COMPONENT`.\n\n `GL_TEXTURE_MAG_FILTER`  \nReturns the single-valued texture magnification filter, a symbolic constant. The initial value is `GL_LINEAR`.\n\n `GL_TEXTURE_MIN_FILTER`  \nReturns the single-valued texture minification filter, a symbolic constant. The initial value is `GL_NEAREST_MIPMAP_LINEAR`.\n\n `GL_TEXTURE_MIN_LOD`  \nReturns the single-valued texture minimum level-of-detail value. The initial value is −1000.\n\n `GL_TEXTURE_MAX_LOD`  \nReturns the single-valued texture maximum level-of-detail value. The initial value is 1000.\n\n `GL_TEXTURE_BASE_LEVEL`  \nReturns the single-valued base texture mipmap level. The initial value is 0.\n\n `GL_TEXTURE_MAX_LEVEL`  \nReturns the single-valued maximum texture mipmap array level. The initial value is 1000.\n\n `GL_TEXTURE_SWIZZLE_R`  \nReturns the red component swizzle. The initial value is `GL_RED`.\n\n `GL_TEXTURE_SWIZZLE_G`  \nReturns the green component swizzle. The initial value is `GL_GREEN`.\n\n `GL_TEXTURE_SWIZZLE_B`  \nReturns the blue component swizzle. The initial value is `GL_BLUE`.\n\n `GL_TEXTURE_SWIZZLE_A`  \nReturns the alpha component swizzle. The initial value is `GL_ALPHA`.\n\n `GL_TEXTURE_SWIZZLE_RGBA`  \nReturns the component swizzle for all channels in a single query.\n\n `GL_TEXTURE_WRAP_S`  \nReturns the single-valued wrapping function for texture coordinate *s*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n `GL_TEXTURE_WRAP_T`  \nReturns the single-valued wrapping function for texture coordinate *t*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n `GL_TEXTURE_WRAP_R`  \nReturns the single-valued wrapping function for texture coordinate *r*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n `GL_TEXTURE_BORDER_COLOR`  \nReturns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range \\[0, 1\\]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and −1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).\n\n `GL_TEXTURE_COMPARE_MODE`  \nReturns a single-valued texture comparison mode, a symbolic constant. The initial value is `GL_NONE`. See [glTexParameter](gltexparameter.xhtml).\n\n `GL_TEXTURE_COMPARE_FUNC`  \nReturns a single-valued texture comparison function, a symbolic constant. The initial value is `GL_LEQUAL`. See [glTexParameter](gltexparameter.xhtml).\n\n `GL_TEXTURE_VIEW_MIN_LEVEL`  \nReturns a single-valued base level of a texture view relative to its parent. The initial value is 0. See [glTextureView](gltextureview.xhtml).\n\n `GL_TEXTURE_VIEW_NUM_LEVELS`  \nReturns a single-valued number of levels of detail of a texture view. See [glTextureView](gltextureview.xhtml).\n\n `GL_TEXTURE_VIEW_MIN_LAYER`  \nReturns a single-valued first level of a texture array view relative to its parent. See [glTextureView](gltextureview.xhtml).\n\n `GL_TEXTURE_VIEW_NUM_LAYERS`  \nReturns a single-valued number of layers in a texture array view. See [glTextureView](gltextureview.xhtml).\n\n `GL_TEXTURE_IMMUTABLE_LEVELS`  \nReturns a single-valued number of immutable texture levels in a texture view. See [glTextureView](gltextureview.xhtml).\n\nIn addition to the parameters that may be set with [glTexParameter](gltexparameter.xhtml), `glGetTexParameter` and `glGetTextureParameter` accept the following read-only parameters:\n\n `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`  \nReturns the matching criteria use for the texture when used as an image texture. Can return `GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE`, `GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS` or `GL_NONE`.\n\n `GL_TEXTURE_IMMUTABLE_FORMAT`  \nReturns non-zero if the texture has an immutable format. Textures become immutable if their storage is specified with [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml) or [glTexStorage3D](gltexstorage3d.xhtml). The initial value is `GL_FALSE`.\n\n `GL_TEXTURE_TARGET`  \nReturns the effective target of the texture object. For `glGetTex*Parameter` functions, this is the target parameter. For `glGetTextureParameter*`, it is the target to which the texture was initially bound when it was created, or the value of the target parameter to the call to `glCreateTextures` which created the texture.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE` is available only if the GL version is 4.2 or greater.\n\n`GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_NUM_LAYERS` and `GL_TEXTURE_IMMUTABLE_LEVELS` are available only if the GL version is 4.3 or greater.\n\n`GL_TEXTURE_TARGET` are available only if the GL version is 4.5 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_ENUM` error is generated by `glGetTexParameter` if the effective *`target`* is not one of the accepted texture targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetTextureParameter*` if *`texture`* is not the name of an existing texture object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetTexParameterIiv`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetTexParameterIuiv`     |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetTexParameterfv`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetTexParameteriv`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetTextureParameterIiv`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetTextureParameterIuiv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetTextureParameterfv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetTextureParameteriv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glTexParameter](gltexparameter.xhtml), `glTextureParameter`, [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml), `glTextureStorage1D`, `glTextureStorage2D`, `glTextureStorage3D`, [glTextureView](gltextureview.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexParameter.xhtml)"
- name: glGetTexParameterfv
  id: glgettexparameter.xhtml#glGetTexParameterfv
  summary: null
  belongs_to: glGetTexParameter
  description: '`void `**`glGetTexParameterfv`**`(` GLenum `target`, GLenum `pname`, GLfloat \* `params``)`;'
- name: glGetTexParameterIiv
  id: glgettexparameter.xhtml#glGetTexParameterIiv
  summary: null
  belongs_to: glGetTexParameter
  description: '`void `**`glGetTexParameterIiv`**`(` GLenum `target`, GLenum `pname`, GLint \* `params``)`;'
- name: glGetTexParameterIuiv
  id: glgettexparameter.xhtml#glGetTexParameterIuiv
  summary: null
  belongs_to: glGetTexParameter
  description: '`void `**`glGetTexParameterIuiv`**`(` GLenum `target`, GLenum `pname`, GLuint \* `params``)`;'
- name: glGetTexParameteriv
  id: glgettexparameter.xhtml#glGetTexParameteriv
  summary: null
  belongs_to: glGetTexParameter
  description: '`void `**`glGetTexParameteriv`**`(` GLenum `target`, GLenum `pname`, GLint \* `params``)`;'
- name: glGetTextureImage
  id: glgetteximage.xhtml#glGetTextureImage
  summary: Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions
  belongs_to: glGetTexImage
  description: "`void `**`glGetTextureImage`**`(` GLuint `texture`, GLint `level`, GLenum `format`, GLenum `type`, GLsizei `bufSize`, void \\*`pixels``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glGetTexImage` and `glGetnTexImage` functions. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are acceptable.\n\n*`texture`*\n\nSpecifies the texture object name.\n\n*`level`*\n\nSpecifies the level-of-detail number of the desired image. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`format`*\n\nSpecifies a pixel format for the returned data. The supported formats are `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RG`, `GL_RGB`, `GL_RGBA`, `GL_BGR`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_GREEN_INTEGER`, `GL_BLUE_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGR_INTEGER`, `GL_BGRA_INTEGER`.\n\n*`type`*\n\nSpecifies a pixel type for the returned data. The supported types are `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, and `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.\n\n*`bufSize`*\n\nSpecifies the size of the buffer *`pixels`* for `glGetnTexImage` and `glGetTextureImage` functions.\n\n*`pixels`*\n\nReturns the texture image. Should be a pointer to an array of the type specified by *`type`*.\n\n## Description\n\n`glGetTexImage`, `glGetnTexImage` and `glGetTextureImage` functions return a texture image into *`pixels`*. For `glGetTexImage` and `glGetnTexImage`, *`target`* specifies whether the desired texture image is one specified by [glTexImage1D](glteximage1d.xhtml) (`GL_TEXTURE_1D`), [glTexImage2D](glteximage2d.xhtml) (`GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D` or any of `GL_TEXTURE_CUBE_MAP_*`), or [glTexImage3D](glteximage3d.xhtml) (`GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_ARRAY`). For `glGetTextureImage`, *`texture`* specifies the texture object name. In addition to types of textures accepted by `glGetTexImage` and `glGetnTexImage`, the function also accepts cube map texture objects (with effective target `GL_TEXTURE_CUBE_MAP`). *`level`* specifies the level-of-detail number of the desired image. *`format`* and *`type`* specify the format and type of the desired image array. See the reference page for [glTexImage1D](glteximage1d.xhtml) for a description of the acceptable values for the *`format`* and *`type`* parameters, respectively. For glGetnTexImage and glGetTextureImage functions, bufSize tells the size of the buffer to receive the retrieved pixel data. `glGetnTexImage` and `glGetTextureImage` do not write more than *`bufSize`* bytes into *`pixels`*.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is requested, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\nTo understand the operation of `glGetTexImage`, consider the selected internal four-component texture image to be an RGBA color buffer the size of the image. The semantics of `glGetTexImage` are then identical to those of [glReadPixels](glreadpixels.xhtml), with the exception that no pixel transfer operations are performed, when called with the same *`format`* and *`type`*, with *x* and *y* set to 0, *width* set to the width of the texture image and *height* set to 1 for 1D images, or to the height of the texture image for 2D images.\n\nIf the selected texture image does not contain four components, the following mappings are applied. Single-component textures are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to 1.\n\nTo determine the required size of *`pixels`*, use [glGetTexLevelParameter](glgettexlevelparameter.xhtml) to determine the dimensions of the internal texture image, then scale the required number of pixels by the storage required for each pixel, based on *`format`* and *`type`*. Be sure to take the pixel storage parameters into account, especially `GL_PACK_ALIGNMENT`.\n\nIf `glGetTextureImage` is used against a cube map texture object, the texture is treated as a three-dimensional image of a depth of 6, where the cube map faces are ordered as image layers, in an order presented in the table below:\n\n| Layer number | Cube Map Face                  |\n|--------------|--------------------------------|\n| 0            | GL_TEXTURE_CUBE_MAP_POSITIVE_X |\n| 1            | GL_TEXTURE_CUBE_MAP_NEGATIVE_X |\n| 2            | GL_TEXTURE_CUBE_MAP_POSITIVE_Y |\n| 3            | GL_TEXTURE_CUBE_MAP_NEGATIVE_Y |\n| 4            | GL_TEXTURE_CUBE_MAP_POSITIVE_Z |\n| 5            | GL_TEXTURE_CUBE_MAP_NEGATIVE_Z |\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`pixels`*.\n\n`glGetTexImage` and `glGetnTexImage` return the texture image for the active texture unit.\n\n`GL_STENCIL_INDEX` is accepted for *`format`* only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glGetTexImage` and `glGetnTexImage` functions if *`target`* is not an accepted value. These include:\n\n- `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, and `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z` for `glGetTexImage` and `glGetnTexImage` functions.\n\n- `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_RECTANGLE`, and `GL_TEXTURE_CUBE_MAP` for `glGetTextureImage` function.\n\n`GL_INVALID_OPERATION` is generated by `glGetTextureImage` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`format`*, or *`type`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂(*max* ), where *max*  is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`level`* is non-zero and the effective target is `GL_TEXTURE_RECTANGLE`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, or `GL_UNSIGNED_INT_10F_11F_11F_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, or `GL_UNSIGNED_INT_5_9_9_9_REV` and *`format`* is neither `GL_RGBA` or `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX` or `GL_DEPTH_STENCIL`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and *`pixels`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n`GL_INVALID_OPERATION` is generated by `glGetTextureImage` and `glGetnTexImage` if the buffer size required to store the requested data is greater than *`bufSize`*.\n\n## Associated Gets\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_WIDTH`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_HEIGHT`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_INTERNAL_FORMAT`\n\n[glGet](glget.xhtml) with arguments `GL_PACK_ALIGNMENT` and others\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_PACK_BUFFER_BINDING`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetTexImage`               |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetTextureImage`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetnTexImage`              |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glReadPixels](glreadpixels.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexImage.xhtml)"
- name: glGetTextureLevelParameterfv
  id: glgettexlevelparameter.xhtml#glGetTextureLevelParameterfv
  summary: null
  belongs_to: glGetTexLevelParameter
  description: '`void `**`glGetTextureLevelParameterfv`**`(` GLuint `texture`, GLint `level`, GLenum `pname`, GLfloat \*`params``)`;'
- name: glGetTextureLevelParameteriv
  id: glgettexlevelparameter.xhtml#glGetTextureLevelParameteriv
  summary: Specifies the target to which the texture is bound for glGetTexLevelParameterfv and glGetTexLevelParameteriv functions
  belongs_to: glGetTexLevelParameter
  description: "`void `**`glGetTextureLevelParameteriv`**`(` GLuint `texture`, GLint `level`, GLenum `pname`, GLint \\*`params``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glGetTexLevelParameterfv` and `glGetTexLevelParameteriv` functions. Must be one of the following values: `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, `GL_PROXY_TEXTURE_1D`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_3D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_2D_MULTISAMPLE`, `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_PROXY_TEXTURE_CUBE_MAP`, or `GL_TEXTURE_BUFFER`.\n\n*`texture`*\n\nSpecifies the texture object name for `glGetTextureLevelParameterfv` and `glGetTextureLevelParameteriv` functions.\n\n*`level`*\n\nSpecifies the level-of-detail number of the desired image. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`pname`*\n\nSpecifies the symbolic name of a texture parameter. `GL_TEXTURE_WIDTH`, `GL_TEXTURE_HEIGHT`, `GL_TEXTURE_DEPTH`, `GL_TEXTURE_INTERNAL_FORMAT`, `GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`, `GL_TEXTURE_COMPRESSED`, `GL_TEXTURE_COMPRESSED_IMAGE_SIZE`, and `GL_TEXTURE_BUFFER_OFFSET` are accepted.\n\n*`params`*\n\nReturns the requested data.\n\n## Description\n\n`glGetTexLevelParameterfv`, `glGetTexLevelParameteriv`, `glGetTextureLevelParameterfv` and `glGetTextureLevelParameteriv` return in *`params`* texture parameter values for a specific level-of-detail value, specified as *`level`*. For the first two functions, *`target`* defines the target texture, either `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_1D`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`. The remaining two take a *`texture`* argument which specifies the name of the texture object.\n\n`GL_MAX_TEXTURE_SIZE`, and `GL_MAX_3D_TEXTURE_SIZE` are not really descriptive enough. It has to report the largest square texture image that can be accommodated with mipmaps but a long skinny texture, or a texture without mipmaps may easily fit in texture memory. The proxy targets allow the user to more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot be accommodated, the texture state variables, which may be queried with `glGetTexLevelParameter` and `glGetTextureLevelParameter`, are set to 0. If the texture can be accommodated, the texture state values will be set as they would be set for a non-proxy target.\n\n*`pname`* specifies the texture parameter whose value or values will be returned.\n\nThe accepted parameter names are as follows:\n\n`GL_TEXTURE_WIDTH`\n\n*`params`* returns a single value, the width of the texture image. The initial value is 0.\n\n`GL_TEXTURE_HEIGHT`\n\n*`params`* returns a single value, the height of the texture image. The initial value is 0.\n\n`GL_TEXTURE_DEPTH`\n\n*`params`* returns a single value, the depth of the texture image. The initial value is 0.\n\n`GL_TEXTURE_INTERNAL_FORMAT`\n\n*`params`* returns a single value, the internal format of the texture image.\n\n`GL_TEXTURE_RED_TYPE`, `GL_TEXTURE_GREEN_TYPE`, `GL_TEXTURE_BLUE_TYPE`, `GL_TEXTURE_ALPHA_TYPE`, `GL_TEXTURE_DEPTH_TYPE`\n\nThe data type used to store the component. The types `GL_NONE`, `GL_SIGNED_NORMALIZED`, `GL_UNSIGNED_NORMALIZED`, `GL_FLOAT`, `GL_INT`, and `GL_UNSIGNED_INT` may be returned to indicate signed normalized fixed-point, unsigned normalized fixed-point, floating-point, integer unnormalized, and unsigned integer unnormalized components, respectively.\n\n`GL_TEXTURE_RED_SIZE`, `GL_TEXTURE_GREEN_SIZE`, `GL_TEXTURE_BLUE_SIZE`, `GL_TEXTURE_ALPHA_SIZE`, `GL_TEXTURE_DEPTH_SIZE`\n\nThe internal storage resolution of an individual component. The resolution chosen by the GL will be a close match for the resolution requested by the user with the component argument of [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), and [glCopyTexImage2D](glcopyteximage2d.xhtml). The initial value is 0.\n\n`GL_TEXTURE_COMPRESSED`\n\n*`params`* returns a single boolean value indicating if the texture image is stored in a compressed internal format. The initiali value is `GL_FALSE`.\n\n`GL_TEXTURE_COMPRESSED_IMAGE_SIZE`\n\n*`params`* returns a single integer value, the number of unsigned bytes of the compressed texture image that would be returned from [glGetCompressedTexImage](glgetcompressedteximage.xhtml).\n\n`GL_TEXTURE_BUFFER_OFFSET`\n\n*`params`* returns a single integer value, the offset into the data store of the buffer bound to a buffer texture. [glTexBufferRange](gltexbufferrange.xhtml).\n\n`GL_TEXTURE_BUFFER_SIZE`\n\n*`params`* returns a single integer value, the size of the range of a data store of the buffer bound to a buffer texture. [glTexBufferRange](gltexbufferrange.xhtml).\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n`glGetTexLevelParameter` returns the texture level parameters for the active texture unit.\n\n`GL_TEXTURE_BUFFER_OFFSET` and `GL_TEXTURE_BUFFER_SIZE` are available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glGetTextureLevelParameterfv` and `glGetTextureLevelParameteriv` functions if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated by `glGetTexLevelParameterfv` and `glGetTexLevelParameteriv` functions if *`target`* or *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂ *max*, where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`target`* is `GL_TEXTURE_BUFFER` and *`level`* is not zero.\n\n`GL_INVALID_OPERATION` is generated if `GL_TEXTURE_COMPRESSED_IMAGE_SIZE` is queried on texture images with an uncompressed internal format or on proxy targets.\n\n## Version Support\n\n|                                |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:-------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**   |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetTexLevelParameterfv`     |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetTexLevelParameteriv`     |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetTextureLevelParameterfv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetTextureLevelParameteriv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexLevelParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexLevelParameter.xhtml)"
- name: glGetTextureParameterfv
  id: glgettexparameter.xhtml#glGetTextureParameterfv
  summary: null
  belongs_to: glGetTexParameter
  description: '`void `**`glGetTextureParameterfv`**`(` GLuint `texture`, GLenum `pname`, GLfloat \*`params``)`;'
- name: glGetTextureParameterIiv
  id: glgettexparameter.xhtml#glGetTextureParameterIiv
  summary: null
  belongs_to: glGetTexParameter
  description: '`void `**`glGetTextureParameterIiv`**`(` GLuint `texture`, GLenum `pname`, GLint \*`params``)`;'
- name: glGetTextureParameterIuiv
  id: glgettexparameter.xhtml#glGetTextureParameterIuiv
  summary: Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv, glGetTexParameterIiv, and glGetTexParameterIuiv functions
  belongs_to: glGetTexParameter
  description: "`void `**`glGetTextureParameterIuiv`**`(` GLuint `texture`, GLenum `pname`, GLuint \\*`params``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glGetTexParameterfv`, `glGetTexParameteriv`, `glGetTexParameterIiv`, and `glGetTexParameterIuiv` functions. `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_RECTANGLE`, and `GL_TEXTURE_CUBE_MAP_ARRAY` are accepted.\n\n*`texture`*\n\nSpecifies the texture object name for `glGetTextureParameterfv`, `glGetTextureParameteriv`, `glGetTextureParameterIiv`, and `glGetTextureParameterIuiv` functions.\n\n*`pname`*\n\nSpecifies the symbolic name of a texture parameter. `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_IMMUTABLE_FORMAT`, `GL_TEXTURE_IMMUTABLE_LEVELS`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_SWIZZLE_RGBA`, `GL_TEXTURE_TARGET`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LAYERS`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, and `GL_TEXTURE_WRAP_R` are accepted.\n\n*`params`*\n\nReturns the texture parameters.\n\n## Description\n\n`glGetTexParameter` and `glGetTextureParameter` return in *`params`* the value or values of the texture parameter specified as *`pname`*. *`target`* defines the target texture. `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` specify one-, two-, or three-dimensional, one-dimensional array, two-dimensional array, rectangle, cube-mapped or cube-mapped array, two-dimensional multisample, or two-dimensional multisample array texturing, respectively. *`pname`* accepts the same symbols as [glTexParameter](gltexparameter.xhtml), with the same interpretations:\n\n`GL_DEPTH_STENCIL_TEXTURE_MODE`\n\nReturns the single-value depth stencil texture mode, a symbolic constant. The initial value is `GL_DEPTH_COMPONENT`.\n\n`GL_TEXTURE_MAG_FILTER`\n\nReturns the single-valued texture magnification filter, a symbolic constant. The initial value is `GL_LINEAR`.\n\n`GL_TEXTURE_MIN_FILTER`\n\nReturns the single-valued texture minification filter, a symbolic constant. The initial value is `GL_NEAREST_MIPMAP_LINEAR`.\n\n`GL_TEXTURE_MIN_LOD`\n\nReturns the single-valued texture minimum level-of-detail value. The initial value is −1000.\n\n`GL_TEXTURE_MAX_LOD`\n\nReturns the single-valued texture maximum level-of-detail value. The initial value is 1000.\n\n`GL_TEXTURE_BASE_LEVEL`\n\nReturns the single-valued base texture mipmap level. The initial value is 0.\n\n`GL_TEXTURE_MAX_LEVEL`\n\nReturns the single-valued maximum texture mipmap array level. The initial value is 1000.\n\n`GL_TEXTURE_SWIZZLE_R`\n\nReturns the red component swizzle. The initial value is `GL_RED`.\n\n`GL_TEXTURE_SWIZZLE_G`\n\nReturns the green component swizzle. The initial value is `GL_GREEN`.\n\n`GL_TEXTURE_SWIZZLE_B`\n\nReturns the blue component swizzle. The initial value is `GL_BLUE`.\n\n`GL_TEXTURE_SWIZZLE_A`\n\nReturns the alpha component swizzle. The initial value is `GL_ALPHA`.\n\n`GL_TEXTURE_SWIZZLE_RGBA`\n\nReturns the component swizzle for all channels in a single query.\n\n`GL_TEXTURE_WRAP_S`\n\nReturns the single-valued wrapping function for texture coordinate *s*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n`GL_TEXTURE_WRAP_T`\n\nReturns the single-valued wrapping function for texture coordinate *t*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n`GL_TEXTURE_WRAP_R`\n\nReturns the single-valued wrapping function for texture coordinate *r*, a symbolic constant. The initial value is `GL_REPEAT`.\n\n`GL_TEXTURE_BORDER_COLOR`\n\nReturns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range \\[0, 1\\]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and −1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).\n\n`GL_TEXTURE_COMPARE_MODE`\n\nReturns a single-valued texture comparison mode, a symbolic constant. The initial value is `GL_NONE`. See [glTexParameter](gltexparameter.xhtml).\n\n`GL_TEXTURE_COMPARE_FUNC`\n\nReturns a single-valued texture comparison function, a symbolic constant. The initial value is `GL_LEQUAL`. See [glTexParameter](gltexparameter.xhtml).\n\n`GL_TEXTURE_VIEW_MIN_LEVEL`\n\nReturns a single-valued base level of a texture view relative to its parent. The initial value is 0. See [glTextureView](gltextureview.xhtml).\n\n`GL_TEXTURE_VIEW_NUM_LEVELS`\n\nReturns a single-valued number of levels of detail of a texture view. See [glTextureView](gltextureview.xhtml).\n\n`GL_TEXTURE_VIEW_MIN_LAYER`\n\nReturns a single-valued first level of a texture array view relative to its parent. See [glTextureView](gltextureview.xhtml).\n\n`GL_TEXTURE_VIEW_NUM_LAYERS`\n\nReturns a single-valued number of layers in a texture array view. See [glTextureView](gltextureview.xhtml).\n\n`GL_TEXTURE_IMMUTABLE_LEVELS`\n\nReturns a single-valued number of immutable texture levels in a texture view. See [glTextureView](gltextureview.xhtml).\n\nIn addition to the parameters that may be set with [glTexParameter](gltexparameter.xhtml), `glGetTexParameter` and `glGetTextureParameter` accept the following read-only parameters:\n\n`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE`\n\nReturns the matching criteria use for the texture when used as an image texture. Can return `GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE`, `GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS` or `GL_NONE`.\n\n`GL_TEXTURE_IMMUTABLE_FORMAT`\n\nReturns non-zero if the texture has an immutable format. Textures become immutable if their storage is specified with [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml) or [glTexStorage3D](gltexstorage3d.xhtml). The initial value is `GL_FALSE`.\n\n`GL_TEXTURE_TARGET`\n\nReturns the effective target of the texture object. For `glGetTex*Parameter` functions, this is the target parameter. For `glGetTextureParameter*`, it is the target to which the texture was initially bound when it was created, or the value of the target parameter to the call to `glCreateTextures` which created the texture.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n`GL_IMAGE_FORMAT_COMPATIBILITY_TYPE` is available only if the GL version is 4.2 or greater.\n\n`GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_NUM_LAYERS` and `GL_TEXTURE_IMMUTABLE_LEVELS` are available only if the GL version is 4.3 or greater.\n\n`GL_TEXTURE_TARGET` are available only if the GL version is 4.5 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_ENUM` error is generated by `glGetTexParameter` if the effective *`target`* is not one of the accepted texture targets.\n\n`GL_INVALID_OPERATION` is generated by `glGetTextureParameter*` if *`texture`* is not the name of an existing texture object.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetTexParameterIiv`        |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetTexParameterIuiv`       |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetTexParameterfv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetTexParameteriv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetTextureParameterIiv`    |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetTextureParameterIuiv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetTextureParameterfv`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetTextureParameteriv`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glTexParameter](gltexparameter.xhtml), `glTextureParameter`, [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml), `glTextureStorage1D`, `glTextureStorage2D`, `glTextureStorage3D`, [glTextureView](gltextureview.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTexParameter.xhtml)"
- name: glGetTextureParameteriv
  id: glgettexparameter.xhtml#glGetTextureParameteriv
  summary: null
  belongs_to: glGetTexParameter
  description: '`void `**`glGetTextureParameteriv`**`(` GLuint `texture`, GLenum `pname`, GLint \*`params``)`;'
- name: glGetTextureSubImage
  id: glgettexturesubimage.xhtml
  summary: texture Specifies the name of the source texture object
  description: "## Name\n\nglGetTextureSubImage — retrieve a sub-region of a texture image from a texture object\n\n## C Specification\n\n`void `**`glGetTextureSubImage`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLenum `format`, GLenum `type`, GLsizei `bufSize`, void \\*`pixels``)`;\n\n## Parameters\n\n *`texture`*  \nSpecifies the name of the source texture object. Must be `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY` or `GL_TEXTURE_RECTANGLE`. In specific, buffer and multisample textures are not permitted.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`yoffset`*  \nSpecifies a texel offset in the y direction within the texture array.\n\n *`zoffset`*  \nSpecifies a texel offset in the z direction within the texture array.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n *`height`*  \nSpecifies the height of the texture subimage.\n\n *`depth`*  \nSpecifies the depth of the texture subimage.\n\n *`format`*  \nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT` and `GL_STENCIL_INDEX`.\n\n *`type`*  \nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n *`bufSize`*  \nSpecifies the size of the buffer to receive the retrieved pixel data.\n\n *`pixels`*  \nReturns the texture subimage. Should be a pointer to an array of the type specified by *`type`*.\n\n## Description\n\n`glGetTextureSubImage` returns a texture subimage into pixels.\n\n*`texture`* is the name of the source texture object and must not be a buffer or multisample texture. The effective *`target`* parameter is the value of `GL_TEXTURE_TARGET` for texture. *`Level`*, *`format`*, *`type`* and *`pixels`* have the same meaning as for `glGetTexImage`. *`bufSize`* is the size of the buffer to receive the retrieved pixel data.\n\nFor cube map textures, the behavior is as though `GetTextureImage` were called, but only texels from the requested cube map faces (selected by *`zoffset`* and *`depth`*, as described below) were returned.\n\n*`xoffset`*, *`yoffset`* and *`zoffset`* values indicate the position of the subregion to return. *`width`*, *`height`* and *`depth`* indicate the size of the region to return. These parameters have the same meaning as for `glTexSubImage3D`, though for one- and two-dimensional textures there are extra restrictions, described in the errors section below.\n\nFor one-dimensional array textures, *`yoffset`* is interpreted as the first layer to access and *`height`* is the number of layers to access.\n\nFor two-dimensional array textures, *`zoffset`* is interpreted as the first layer to access and *`depth`* is the number of layers to access.\n\nCube map textures are treated as an array of six slices in the z-dimension, where the value of *`zoffset`* is interpreted as specifying the cube map face for the corresponding layer (as presented in the table below) and *`depth`* is the number of faces to access:\n\n|              |                                |\n|--------------|--------------------------------|\n| Layer number | Cube Map Face                  |\n| 0            | GL_TEXTURE_CUBE_MAP_POSITIVE_X |\n| 1            | GL_TEXTURE_CUBE_MAP_NEGATIVE_X |\n| 2            | GL_TEXTURE_CUBE_MAP_POSITIVE_Y |\n| 3            | GL_TEXTURE_CUBE_MAP_NEGATIVE_Y |\n| 4            | GL_TEXTURE_CUBE_MAP_POSITIVE_Z |\n| 5            | GL_TEXTURE_CUBE_MAP_NEGATIVE_Z |\n\nFor cube map array textures, *`zoffset`* is the first layer-face to access, and *`depth`* is the number of layer-faces to access. A layer-face described by $k$ is translated into an array layer and face according to $$ layer = \\left\\lfloor { layer \\over 6 } \\right\\rfloor$$ and $$ face = k \\bmod 6. $$\n\nComponent groups from the specified sub-region are packed and placed into memory as described for `glGetTextureImage`, starting with the texel at (*`xoffset`*, *`yoffset`*, *`zoffset`*).\n\n## Errors\n\n`GL_INVALID_VALUE` error is generated if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` error is generated if *`texture`* is the name of a buffer or multisample texture.\n\n`GL_INVALID_VALUE` is generated if *`xoffset`*, *`yoffset`* or *`zoffset`* are negative.\n\n`GL_INVALID_VALUE` is generated if *`xoffset`* + *`width`* is greater than the texture's width, *`yoffset`* + *`height`* is greater than the texture's height, or *`zoffset`* + *`depth`* is greater than the texture's depth.\n\n`GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D` and either *`yoffset`* is not zero, or *`height`* is not one.\n\n`GL_INVALID_VALUE` error is generated if the effective target is `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D` or `GL_TEXTURE_RECTANGLE` and either *`zoffset`* is not zero, or *`depth`* is not one.\n\n`GL_INVALID_OPERATION` error is generated if the buffer size required to store the requested data is greater than *`bufSize`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetTextureSubImage`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGetTexImage](glgetteximage.xhtml), `glGetTextureImage`, [glReadPixels](glreadpixels.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTextureSubImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTextureSubImage.xhtml)"
- name: glGetTransformFeedback
  id: glgettransformfeedback.xhtml
  summary: glGetTransformFeedbackiv — query the state of a transform feedback object
  description: "## Name\n\nglGetTransformFeedbackiv — query the state of a transform feedback object.\n\n## C Specification\n\n`void `**`glGetTransformFeedbackiv`**`(` GLuint `xfb`, GLenum `pname`, GLint \\*`param``)`;\n\n`void `**`glGetTransformFeedbacki_v`**`(` GLuint `xfb`, GLenum `pname`, GLuint `index`, GLint \\*`param``)`;\n\n`void `**`glGetTransformFeedbacki64_v`**`(` GLuint `xfb`, GLenum `pname`, GLuint `index`, GLint64 \\*`param``)`;\n\n## Parameters\n\n *`xfb`*  \nThe name of an existing transform feedback object, or zero for the default transform feedback object.\n\n *`pname`*  \nProperty to use for the query. Must be one of the values: `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`, `GL_TRANSFORM_FEEDBACK_BUFFER_START`, `GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`, `GL_TRANSFORM_FEEDBACK_PAUSED`, `GL_TRANSFORM_FEEDBACK_ACTIVE`.\n\n *`index`*  \nIndex of the transform feedback stream (for indexed state).\n\n *`param`*  \nThe address of a buffer into which will be written the requested state information.\n\n## Description\n\nIn order to use the Transform Feedback functionality, you need to configure the Transform Feedback Buffer indexed bindings. This can be achieved by either using `glBindBufferBase` or `glBindBuffersBase` to associate whole buffer object storage to one of the Transform Feedback Binding Points, or by calling `glBindBufferRange` or `glBindBuffersRange` to use a region of a buffer object storage for the binding. You may want to (but are not required to) bind a Transform Feedback Object first, in order to cache the binding configuration. This usually allows you to restore the Transform Feedback configuration faster, than if you were to execute a list of API calls necessary to set up the Transform Feedback state of your liking.\n\nThis reference page discusses two types of getters that operate on Transform Feedback Objects and their bindings.\n\nThe first class operates on general Transform Feedback binding point and includes `glGetTransformFeedbackiv` function. `glGetTransformFeedbackiv` can be used to retrieve information about Transform Feedback object bound to the general Transform Feedback binding point, as configured with a `glBindTransformFeedback` call. In this case, you can check:\n\n- What the ID of the currently bound Transform Feedback Object is; (`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`)\n\n- Whether the Transform Feedback process is currently paused; (`GL_TRANSFORM_FEEDBACK_PAUSED`)\n\n- Whether the Transform Feedback process has been begun and is currently undergoing; (`GL_TRANSFORM_FEEDBACK_ACTIVE`)\n\nThe latter class, which includes `glGetTransformFeedbacki_v` and `glGetTransformFeedbacki64_v` functions, can be used to check what the current configuration of each of the buffer object regions bound to Transform Feedback Buffer binding points is. This allows you to query for the following information:\n\n- `glGetTransformFeedbacki_v` only: What the ID of the Buffer Object bound to a Transform Feedback Binding Point of user-specified index is; (`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`).\n\n- `glGetTransformFeedbacki64_v` only: What the start offset configured for the binding is; (`GL_TRANSFORM_FEEDBACK_BUFFER_START`);\n\n- `glGetTransformFeedbacki64_v` only: What the length of the region used for the binding is; (`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`);\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated if *`xfb`* is not zero or the name of an existing transform feedback object.\n\n`GL_INVALID_ENUM` error is generated by `glGetTransformFeedbackiv` if *`pname`* is not `GL_TRANSFORM_FEEDBACK_PAUSED` or `GL_TRANSFORM_FEEDBACK_ACTIVE`.\n\n`GL_INVALID_ENUM` error is generated by `glGetTransformFeedbacki_v` if *`pname`* is not `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`.\n\n`GL_INVALID_ENUM` error is generated by `glGetTransformFeedbacki64_v` if *`pname`* is not `GL_TRANSFORM_FEEDBACK_BUFFER_START` or `GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`.\n\n`GL_INVALID_VALUE` error is generated by `glGetTransformFeedbacki_v` and `glGetTransformFeedbacki64_v` if *`index`* is greater than or equal to the number of binding points for transform feedback (the value of `GL_MAX_TRANSFORM_FEEDBACK_BUFFERS`).\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetTransformFeedbackiv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetTransformFeedbacki_v`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetTransformFeedbacki64v` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBufferBase](glbindbufferbase.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glBindBuffersBase](glbindbuffersbase.xhtml), [glBindBuffersRange](glbindbuffersrange.xhtml), [glBindTransformFeedback](glbindtransformfeedback.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTransformFeedback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTransformFeedback.xhtml)"
- name: glGetTransformFeedbacki64_v
  id: glgettransformfeedback.xhtml#glGetTransformFeedbacki64_v
  summary: The name of an existing transform feedback object, or zero for the default transform feedback object
  belongs_to: glGetTransformFeedback
  description: "`void `**`glGetTransformFeedbacki64_v`**`(` GLuint `xfb`, GLenum `pname`, GLuint `index`, GLint64 \\*`param``)`;\n\n## Parameters\n\n*`xfb`*\n\nThe name of an existing transform feedback object, or zero for the default transform feedback object.\n\n*`pname`*\n\nProperty to use for the query. Must be one of the values: `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`, `GL_TRANSFORM_FEEDBACK_BUFFER_START`, `GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`, `GL_TRANSFORM_FEEDBACK_PAUSED`, `GL_TRANSFORM_FEEDBACK_ACTIVE`.\n\n*`index`*\n\nIndex of the transform feedback stream (for indexed state).\n\n*`param`*\n\nThe address of a buffer into which will be written the requested state information.\n\n## Description\n\nIn order to use the Transform Feedback functionality, you need to configure the Transform Feedback Buffer indexed bindings. This can be achieved by either using `glBindBufferBase` or `glBindBuffersBase` to associate whole buffer object storage to one of the Transform Feedback Binding Points, or by calling `glBindBufferRange` or `glBindBuffersRange` to use a region of a buffer object storage for the binding. You may want to (but are not required to) bind a Transform Feedback Object first, in order to cache the binding configuration. This usually allows you to restore the Transform Feedback configuration faster, than if you were to execute a list of API calls necessary to set up the Transform Feedback state of your liking.\n\nThis reference page discusses two types of getters that operate on Transform Feedback Objects and their bindings.\n\nThe first class operates on general Transform Feedback binding point and includes `glGetTransformFeedbackiv` function. `glGetTransformFeedbackiv` can be used to retrieve information about Transform Feedback object bound to the general Transform Feedback binding point, as configured with a `glBindTransformFeedback` call. In this case, you can check:\n\n- What the ID of the currently bound Transform Feedback Object is; (`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`)\n\n- Whether the Transform Feedback process is currently paused; (`GL_TRANSFORM_FEEDBACK_PAUSED`)\n\n- Whether the Transform Feedback process has been begun and is currently undergoing; (`GL_TRANSFORM_FEEDBACK_ACTIVE`)\n\nThe latter class, which includes `glGetTransformFeedbacki_v` and `glGetTransformFeedbacki64_v` functions, can be used to check what the current configuration of each of the buffer object regions bound to Transform Feedback Buffer binding points is. This allows you to query for the following information:\n\n- `glGetTransformFeedbacki_v` only: What the ID of the Buffer Object bound to a Transform Feedback Binding Point of user-specified index is; (`GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`).\n\n- `glGetTransformFeedbacki64_v` only: What the start offset configured for the binding is; (`GL_TRANSFORM_FEEDBACK_BUFFER_START`);\n\n- `glGetTransformFeedbacki64_v` only: What the length of the region used for the binding is; (`GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`);\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated if *`xfb`* is not zero or the name of an existing transform feedback object.\n\n`GL_INVALID_ENUM` error is generated by `glGetTransformFeedbackiv` if *`pname`* is not `GL_TRANSFORM_FEEDBACK_PAUSED` or `GL_TRANSFORM_FEEDBACK_ACTIVE`.\n\n`GL_INVALID_ENUM` error is generated by `glGetTransformFeedbacki_v` if *`pname`* is not `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`.\n\n`GL_INVALID_ENUM` error is generated by `glGetTransformFeedbacki64_v` if *`pname`* is not `GL_TRANSFORM_FEEDBACK_BUFFER_START` or `GL_TRANSFORM_FEEDBACK_BUFFER_SIZE`.\n\n`GL_INVALID_VALUE` error is generated by `glGetTransformFeedbacki_v` and `glGetTransformFeedbacki64_v` if *`index`* is greater than or equal to the number of binding points for transform feedback (the value of `GL_MAX_TRANSFORM_FEEDBACK_BUFFERS`).\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetTransformFeedbackiv`    |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetTransformFeedbacki_v`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetTransformFeedbacki64v`  |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindBufferBase](glbindbufferbase.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glBindBuffersBase](glbindbuffersbase.xhtml), [glBindBuffersRange](glbindbuffersrange.xhtml), [glBindTransformFeedback](glbindtransformfeedback.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTransformFeedback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTransformFeedback.xhtml)"
- name: glGetTransformFeedbacki_v
  id: glgettransformfeedback.xhtml#glGetTransformFeedbacki_v
  summary: null
  belongs_to: glGetTransformFeedback
  description: '`void `**`glGetTransformFeedbacki_v`**`(` GLuint `xfb`, GLenum `pname`, GLuint `index`, GLint \*`param``)`;'
- name: glGetTransformFeedbackiv
  id: glgettransformfeedback.xhtml#glGetTransformFeedbackiv
  summary: null
  belongs_to: glGetTransformFeedback
  description: '`void `**`glGetTransformFeedbackiv`**`(` GLuint `xfb`, GLenum `pname`, GLint \*`param``)`;'
- name: glGetTransformFeedbackVarying
  id: glgettransformfeedbackvarying.xhtml
  summary: program The name of the target program object
  description: "## Name\n\nglGetTransformFeedbackVarying — retrieve information about varying variables selected for transform feedback\n\n## C Specification\n\n`void `**`glGetTransformFeedbackVarying`**`(` GLuint `program`, GLuint `index`, GLsizei `bufSize`, GLsizei \\*`length`, GLsizei \\*`size`, GLenum \\*`type`, char \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nThe name of the target program object.\n\n *`index`*  \nThe index of the varying variable whose information to retrieve.\n\n *`bufSize`*  \nThe maximum number of characters, including the null terminator, that may be written into *`name`*.\n\n *`length`*  \nThe address of a variable which will receive the number of characters written into *`name`*, excluding the null-terminator. If *`length`* is `NULL` no length is returned.\n\n *`size`*  \nThe address of a variable that will receive the size of the varying.\n\n *`type`*  \nThe address of a variable that will receive the type of the varying.\n\n *`name`*  \nThe address of a buffer into which will be written the name of the varying.\n\n## Description\n\nInformation about the set of varying variables in a linked program that will be captured during transform feedback may be retrieved by calling `glGetTransformFeedbackVarying`. `glGetTransformFeedbackVarying` provides information about the varying variable selected by *`index`*. An *`index`* of 0 selects the first varying variable specified in the *`varyings`* array passed to [glTransformFeedbackVaryings](gltransformfeedbackvaryings.xhtml), and an *`index`* of the value of `GL_TRANSFORM_FEEDBACK_VARYINGS` minus one selects the last such variable.\n\nThe name of the selected varying is returned as a null-terminated string in *`name`*. The actual number of characters written into *`name`*, excluding the null terminator, is returned in *`length`*. If *`length`* is NULL, no length is returned. The maximum number of characters that may be written into *`name`*, including the null terminator, is specified by *`bufSize`*.\n\nThe length of the longest varying name in program is given by `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`, which can be queried with [glGetProgram](glgetprogram.xhtml).\n\nFor the selected varying variable, its type is returned into *`type`*. The size of the varying is returned into *`size`*. The value in *`size`* is in units of the type returned in *`type`*. The type returned can be any of the scalar, vector, or matrix attribute types returned by [glGetActiveAttrib](glgetactiveattrib.xhtml). If an error occurred, the return parameters *`length`*, *`size`*, *`type`* and *`name`* will be unmodified. This command will return as much information about the varying variables as possible. If no information is available, *`length`* will be set to zero and *`name`* will be an empty string. This situation could arise if `glGetTransformFeedbackVarying` is called after a failed link.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of a program object.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater or equal to the value of `GL_TRANSFORM_FEEDBACK_VARYINGS`.\n\n`GL_INVALID_OPERATION` is generated *`program`* has not been linked.\n\n## Associated Gets\n\n[glGetProgram](glgetprogram.xhtml) with argument `GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH`.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetTransformFeedbackVarying` |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBeginTransformFeedback](glbegintransformfeedback.xhtml), `glEndTransformFeedback`, [glTransformFeedbackVaryings](gltransformfeedbackvaryings.xhtml), [glGetProgram](glgetprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTransformFeedbackVarying.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetTransformFeedbackVarying.xhtml)"
- name: glGetUniform
  id: glgetuniform.xhtml
  summary: program Specifies the program object to be queried
  description: "## Name\n\nglGetUniform — Returns the value of a uniform variable\n\n## C Specification\n\n`void `**`glGetUniformfv`**`(` GLuint `program`, GLint `location`, GLfloat \\*`params``)`;\n\n`void `**`glGetUniformiv`**`(` GLuint `program`, GLint `location`, GLint \\*`params``)`;\n\n`void `**`glGetUniformuiv`**`(` GLuint `program`, GLint `location`, GLuint \\*`params``)`;\n\n`void `**`glGetUniformdv`**`(` GLuint `program`, GLint `location`, GLdouble \\*`params``)`;\n\n`void `**`glGetnUniformfv`**`(` GLuint `program`, GLint `location`, GLsizei `bufSize`, GLfloat \\*`params``)`;\n\n`void `**`glGetnUniformiv`**`(` GLuint `program`, GLint `location`, GLsizei `bufSize`, GLint \\*`params``)`;\n\n`void `**`glGetnUniformuiv`**`(` GLuint `program`, GLint `location`, GLsizei `bufSize`, GLuint \\*`params``)`;\n\n`void `**`glGetnUniformdv`**`(` GLuint `program`, GLint `location`, GLsizei `bufSize`, GLdouble \\*`params``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to be queried.\n\n *`location`*  \nSpecifies the location of the uniform variable to be queried.\n\n *`bufSize`*  \nSpecifies the size of the buffer *`params`*.\n\n *`params`*  \nReturns the value of the specified uniform variable.\n\n## Description\n\n`glGetUniform` and `glGetnUniform` return in *`params`* the value(s) of the specified uniform variable. The type of the uniform variable specified by *`location`* determines the number of values returned. If the uniform variable is defined in the shader as a boolean, int, or float, a single value will be returned. If it is defined as a vec2, ivec2, or bvec2, two values will be returned. If it is defined as a vec3, ivec3, or bvec3, three values will be returned, and so on. To query values stored in uniform variables declared as arrays, call `glGetUniform` for each element of the array. To query values stored in uniform variables declared as structures, call `glGetUniform` for each field in the structure. The values for uniform variables declared as a matrix will be returned in column major order.\n\nThe locations assigned to uniform variables are not known until the program object is linked. After linking has occurred, the command [glGetUniformLocation](glgetuniformlocation.xhtml) can be used to obtain the location of a uniform variable. This location value can then be passed to `glGetUniform` or `glGetnUniform` in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. The uniform variable values can only be queried after a link if the link was successful.\n\nThe only difference between `glGetUniform` and `glGetnUniform` is that `glGetnUniform` will generate an error if size of the *`params`* buffer,as described by *`bufSize`*, is not large enough to hold the result data.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_OPERATION` is generated if *`program`* has not been successfully linked.\n\n`GL_INVALID_OPERATION` is generated if *`location`* does not correspond to a valid uniform variable location for the specified program object.\n\n`GL_INVALID_OPERATION` is generated by `glGetnUniform` if the buffer size required to store the requested data is greater than *`bufSize`*.\n\n## Associated Gets\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with arguments *`program`* and the index of an active uniform variable\n\n[glGetProgram](glgetprogram.xhtml) with arguments *`program`* and `GL_ACTIVE_UNIFORMS` or `GL_ACTIVE_UNIFORM_MAX_LENGTH`\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with arguments *`program`* and the name of a uniform variable\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetUniformdv`            |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetUniformfv`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetUniformiv`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetUniformuiv`           |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetnUniformdv`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetnUniformfv`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetnUniformiv`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetnUniformuiv`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glCreateProgram](glcreateprogram.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glUniform](gluniform.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniform.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniform.xhtml)"
- name: glGetUniformBlockIndex
  id: glgetuniformblockindex.xhtml
  summary: program Specifies the name of a program containing the uniform block
  description: "## Name\n\nglGetUniformBlockIndex — retrieve the index of a named uniform block\n\n## C Specification\n\n`GLuint `**`glGetUniformBlockIndex`**`(` GLuint `program`, const GLchar \\*`uniformBlockName``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of a program containing the uniform block.\n\n *`uniformBlockName`*  \nSpecifies the address an array of characters to containing the name of the uniform block whose index to retrieve.\n\n## Description\n\n`glGetUniformBlockIndex` retrieves the index of a uniform block within *`program`*.\n\n*`program`* must be the name of a program object for which the command [glLinkProgram](gllinkprogram.xhtml) must have been called in the past, although it is not required that [glLinkProgram](gllinkprogram.xhtml) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.\n\n*`uniformBlockName`* must contain a nul-terminated string specifying the name of the uniform block.\n\n`glGetUniformBlockIndex` returns the uniform block index for the uniform block named *`uniformBlockName`* of *`program`*. If *`uniformBlockName`* does not identify an active uniform block of *`program`*, `glGetUniformBlockIndex` returns the special identifier, `GL_INVALID_INDEX`. Indices of the active uniform blocks of a program are assigned in consecutive order, beginning with zero.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of a program object for which [glLinkProgram](gllinkprogram.xhtml) has been called in the past.\n\n## Notes\n\n`glGetUniformBlockIndex` is available only if the GL version is 3.1 or greater.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetUniformBlockIndex`    |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetActiveUniformBlockName](glgetactiveuniformblockname.xhtml), [glGetActiveUniformBlock](glgetactiveuniformblock.xhtml), [glLinkProgram](gllinkprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformBlockIndex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformBlockIndex.xhtml)"
- name: glGetUniformdv
  id: glgetuniform.xhtml#glGetUniformdv
  summary: null
  belongs_to: glGetUniform
  description: '`void `**`glGetUniformdv`**`(` GLuint `program`, GLint `location`, GLdouble \*`params``)`;'
- name: glGetUniformfv
  id: glgetuniform.xhtml#glGetUniformfv
  summary: null
  belongs_to: glGetUniform
  description: '`void `**`glGetUniformfv`**`(` GLuint `program`, GLint `location`, GLfloat \*`params``)`;'
- name: glGetUniformIndices
  id: glgetuniformindices.xhtml
  summary: program Specifies the name of a program containing uniforms whose indices to query
  description: "## Name\n\nglGetUniformIndices — retrieve the index of a named uniform block\n\n## C Specification\n\n`void `**`glGetUniformIndices`**`(` GLuint `program`, GLsizei `uniformCount`, const GLchar \\*\\*`uniformNames`, GLuint \\*`uniformIndices``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of a program containing uniforms whose indices to query.\n\n *`uniformCount`*  \nSpecifies the number of uniforms whose indices to query.\n\n *`uniformNames`*  \nSpecifies the address of an array of pointers to buffers containing the names of the queried uniforms.\n\n *`uniformIndices`*  \nSpecifies the address of an array that will receive the indices of the uniforms.\n\n## Description\n\n`glGetUniformIndices` retrieves the indices of a number of uniforms within *`program`*.\n\n*`program`* must be the name of a program object for which the command [glLinkProgram](gllinkprogram.xhtml) must have been called in the past, although it is not required that [glLinkProgram](gllinkprogram.xhtml) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit.\n\n*`uniformCount`* indicates both the number of elements in the array of names *`uniformNames`* and the number of indices that may be written to *`uniformIndices`*.\n\n*`uniformNames`* contains a list of *`uniformCount`* name strings identifying the uniform names to be queried for indices. For each name string in *`uniformNames`*, the index assigned to the active uniform of that name will be written to the corresponding element of *`uniformIndices`*. If a string in *`uniformNames`* is not the name of an active uniform, the special value `GL_INVALID_INDEX` will be written to the corresponding element of *`uniformIndices`*.\n\nIf an error occurs, nothing is written to *`uniformIndices`*.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of a program object for which [glLinkProgram](gllinkprogram.xhtml) has been called in the past.\n\n## Notes\n\n`glGetUniformIndices` is available only if the GL version is 3.1 or greater.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetUniformIndices`       |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetActiveUniform](glgetactiveuniform.xhtml), [glGetActiveUniformName](glgetactiveuniformname.xhtml), [glLinkProgram](gllinkprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformIndices.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformIndices.xhtml)"
- name: glGetUniformiv
  id: glgetuniform.xhtml#glGetUniformiv
  summary: null
  belongs_to: glGetUniform
  description: '`void `**`glGetUniformiv`**`(` GLuint `program`, GLint `location`, GLint \*`params``)`;'
- name: glGetUniformLocation
  id: glgetuniformlocation.xhtml
  summary: program Specifies the program object to be queried
  description: "## Name\n\nglGetUniformLocation — Returns the location of a uniform variable\n\n## C Specification\n\n`GLint `**`glGetUniformLocation`**`(` GLuint `program`, const GLchar \\*`name``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the program object to be queried.\n\n *`name`*  \nPoints to a null terminated string containing the name of the uniform variable whose location is to be queried.\n\n## Description\n\n`glGetUniformLocation ` returns an integer that represents the location of a specific uniform variable within a program object. *`name`* must be a null terminated string that contains no white space. *`name`* must be an active uniform variable name in *`program`* that is not a structure, an array of structures, or a subcomponent of a vector or a matrix. This function returns -1 if *`name`* does not correspond to an active uniform variable in *`program`*, if *`name`* starts with the reserved prefix \"gl\\_\", or if *`name`* is associated with an atomic counter or a named uniform block.\n\nUniform variables that are structures or arrays of structures may be queried by calling `glGetUniformLocation` for each field within the structure. The array element operator \"\\[\\]\" and the structure field operator \".\" may be used in *`name`* in order to select elements within an array or fields within a structure. The result of using these operators is not allowed to be another structure, an array of structures, or a subcomponent of a vector or a matrix. Except if the last part of *`name`* indicates a uniform variable array, the location of the first element of an array can be retrieved by using the name of the array, or by using the name appended by \"\\[0\\]\".\n\nThe actual locations assigned to uniform variables are not known until the program object is linked successfully. After linking has occurred, the command `glGetUniformLocation` can be used to obtain the location of a uniform variable. This location value can then be passed to [glUniform](gluniform.xhtml) to set the value of the uniform variable or to [glGetUniform](glgetuniform.xhtml) in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. Uniform variable locations and values can only be queried after a link if the link was successful.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_OPERATION` is generated if *`program`* has not been successfully linked.\n\n## Associated Gets\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with arguments *`program`* and the index of an active uniform variable\n\n[glGetProgram](glgetprogram.xhtml) with arguments *`program`* and `GL_ACTIVE_UNIFORMS` or `GL_ACTIVE_UNIFORM_MAX_LENGTH`\n\n[glGetUniform](glgetuniform.xhtml) with arguments *`program`* and the name of a uniform variable\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetUniformLocation`      |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glLinkProgram](gllinkprogram.xhtml), [glUniform](gluniform.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformLocation.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformLocation.xhtml)"
- name: glGetUniformSubroutine
  id: glgetuniformsubroutine.xhtml
  summary: shadertype Specifies the shader stage from which to query for subroutine uniform index
  description: "## Name\n\nglGetUniformSubroutine — retrieve the value of a subroutine uniform of a given shader stage of the current program\n\n## C Specification\n\n`void `**`glGetUniformSubroutineuiv`**`(` GLenum `shadertype`, GLint `location`, GLuint \\*`values``)`;\n\n## Parameters\n\n *`shadertype`*  \nSpecifies the shader stage from which to query for subroutine uniform index. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n *`location`*  \nSpecifies the location of the subroutine uniform.\n\n *`values`*  \nSpecifies the address of a variable to receive the value or values of the subroutine uniform.\n\n## Description\n\n`glGetUniformSubroutine` retrieves the value of the subroutine uniform at location *`location`* for shader stage *`shadertype`* of the current program. *`location`* must be less than the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the shader currently in use at shader stage *`shadertype`*. The value of the subroutine uniform is returned in *`values`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`location`* is greater than or equal to the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the shader currently in use at shader stage *`shadertype`*.\n\n`GL_INVALID_OPERATION` is generated if no program is active.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetUniformSubroutineuiv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetActiveSubroutineUniform](glgetactivesubroutineuniform.xhtml), [glGetActiveSubroutineUniformName](glgetactivesubroutineuniformname.xhtml), [glGetUniformLocation](glgetuniformlocation.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformSubroutine.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformSubroutine.xhtml)"
- name: glGetUniformSubroutineuiv
  id: glgetuniformsubroutine.xhtml#glGetUniformSubroutineuiv
  summary: Specifies the shader stage from which to query for subroutine uniform index
  belongs_to: glGetUniformSubroutine
  description: "`void `**`glGetUniformSubroutineuiv`**`(` GLenum `shadertype`, GLint `location`, GLuint \\*`values``)`;\n\n## Parameters\n\n*`shadertype`*\n\nSpecifies the shader stage from which to query for subroutine uniform index. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n*`location`*\n\nSpecifies the location of the subroutine uniform.\n\n*`values`*\n\nSpecifies the address of a variable to receive the value or values of the subroutine uniform.\n\n## Description\n\n`glGetUniformSubroutine` retrieves the value of the subroutine uniform at location *`location`* for shader stage *`shadertype`* of the current program. *`location`* must be less than the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the shader currently in use at shader stage *`shadertype`*. The value of the subroutine uniform is returned in *`values`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`location`* is greater than or equal to the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the shader currently in use at shader stage *`shadertype`*.\n\n`GL_INVALID_OPERATION` is generated if no program is active.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetUniformSubroutineuiv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetActiveSubroutineUniform](glgetactivesubroutineuniform.xhtml), [glGetActiveSubroutineUniformName](glgetactivesubroutineuniformname.xhtml), [glGetUniformLocation](glgetuniformlocation.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformSubroutine.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetUniformSubroutine.xhtml)"
- name: glGetUniformuiv
  id: glgetuniform.xhtml#glGetUniformuiv
  summary: null
  belongs_to: glGetUniform
  description: '`void `**`glGetUniformuiv`**`(` GLuint `program`, GLint `location`, GLuint \*`params``)`;'
- name: glGetVertexArrayIndexed
  id: glgetvertexarrayindexed.xhtml
  summary: vaobj Specifies the name of a vertex array object
  description: "## Name\n\nglGetVertexArrayIndexed — retrieve parameters of an attribute of a vertex array object\n\n## C Specification\n\n`void `**`glGetVertexArrayIndexed64iv`**`(` GLuint `vaobj`, GLuint `index`, GLenum `pname`, GLint64 \\*`param``)`;\n\n`void `**`glGetVertexArrayIndexediv`**`(` GLuint `vaobj`, GLuint `index`, GLenum `pname`, GLint \\*`param``)`;\n\n## Parameters\n\n *`vaobj`*  \nSpecifies the name of a vertex array object.\n\n *`index`*  \nSpecifies the index of the vertex array object attribute. Must be a number between 0 and (`GL_MAX_VERTEX_ATTRIBS` - 1).\n\n *`pname`*  \nSpecifies the property to be used for the query. For `glGetVertexArrayIndexediv`, it must be one of the following values: `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`. For `glGetVertexArrayIndexed64v`, it must be equal to `GL_VERTEX_BINDING_OFFSET`.\n\n *`param`*  \nReturns the requested value.\n\n## Description\n\n`glGetVertexArrayIndexediv` and `glGetVertexArrayIndexed64iv` provide a way of querying parameters of an attribute at an user-specified index of a vertex array object. The vertex array object does not have to be bound to the rendering context at the time of the call, but must have been bound at least once prior to this call.\n\nThe following parameter values can be retrieved with `glGetVertexArrayIndexediv` for each of the attributes defined for a vertex array object:\n\n- `GL_VERTEX_ATTRIB_ARRAY_ENABLED`: *`param`* returns a value that is non-zero (true) if the vertex attribute array for index is enabled and 0 (false) if it is disabled. The initial value is `GL_FALSE`.\n\n- `GL_VERTEX_ATTRIB_ARRAY_SIZE`: *`param`* returns a single value, the size of the vertex attribute array for index. The size is the number of values for each element of the vertex attribute array, and it will be 1, 2, 3 or 4. The initial value is 4.\n\n- `GL_VERTEX_ATTRIB_ARRAY_STRIDE`: *`param`* returns a single value, the array stride for (number of bytes between successive elements in) the vertex attribute array for index. A value of 0 indicates the array elements are stored sequentially in memory. The initial value is 0.\n\n- `GL_VERTEX_ATTRIB_ARRAY_TYPE`: *`param`* returns a single value, a symbolic constant indicating the array type for the vertex attribute array for index. Possible values are `GL_BYTE`, `GL_DOUBLE`, `GL_FIXED`, `GL_FLOAT`, `GL_HALF_FLOAT`, `GL_INT`, `GL_INT_2_10_10_10_REV`, `GL_SHORT`, `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, `GL_UNSIGNED_INT`, `GL_UNSIGNED_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_10F_11F_11F_REV` . The initial value is `GL_FLOAT`.\n\n- `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`: *`param`* returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by index are normalized when they are converted to floating-point, and 0 (false) otherwise. The initial value is `GL_FALSE`.\n\n- `GL_VERTEX_ATTRIB_ARRAY_INTEGER`: *`param`* returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by index have integer data type, and 0 (false) otherwise. The initial value is 0 (`GL_FALSE`).\n\n- `GL_VERTEX_ATTRIB_ARRAY_LONG`: *`param`* returns a single value that is non-zero (true) if a vertex attribute is stored as an unconverted double, and 0 (false) otherwise. The initial value is 0 (`GL_FALSE`).\n\n- `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`: *`param`* returns a single value that is the frequency divisor used for instanced rendering. See glVertexAttribDivisor. The initial value is 0.\n\n- `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`: *`param`* returns a single value that is the byte offset of the first element relative to the start of the vertex buffer binding specified attribute fetches from. The initial value is 0.\n\n`glGetVertexArrayIndexed64iv` can be used to retrieve `GL_VERTEX_BINDING_OFFSET` parameter value for any of the attributes defined for a vertex array object. When *`pname`* is set to `GL_VERTEX_BINDING_OFFSET`, *`param`* returns a single value that is the byte offset of the first element in the bound buffer's data store. The initial value for this parameter is 0.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_VALUE` error is generated if index is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_ENUM` error is generated if *`pname`* is not one of the valid values. For more details, please see above.\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetVertexArrayIndexed64iv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glGetVertexArrayIndexediv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml), [glVertexAttribBinding](glvertexattribbinding.xhtml), `glVertexAttribIPointer`, `glVertexAttribLPointer`, [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexArrayIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexArrayIndexed.xhtml)"
- name: glGetVertexArrayIndexed64iv
  id: glgetvertexarrayindexed.xhtml#glGetVertexArrayIndexed64iv
  summary: null
  belongs_to: glGetVertexArrayIndexed
  description: '`void `**`glGetVertexArrayIndexed64iv`**`(` GLuint `vaobj`, GLuint `index`, GLenum `pname`, GLint64 \*`param``)`;'
- name: glGetVertexArrayIndexediv
  id: glgetvertexarrayindexed.xhtml#glGetVertexArrayIndexediv
  summary: Specifies the name of a vertex array object
  belongs_to: glGetVertexArrayIndexed
  description: "`void `**`glGetVertexArrayIndexediv`**`(` GLuint `vaobj`, GLuint `index`, GLenum `pname`, GLint \\*`param``)`;\n\n## Parameters\n\n*`vaobj`*\n\nSpecifies the name of a vertex array object.\n\n*`index`*\n\nSpecifies the index of the vertex array object attribute. Must be a number between 0 and (`GL_MAX_VERTEX_ATTRIBS` - 1).\n\n*`pname`*\n\nSpecifies the property to be used for the query. For `glGetVertexArrayIndexediv`, it must be one of the following values: `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, or `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`. For `glGetVertexArrayIndexed64v`, it must be equal to `GL_VERTEX_BINDING_OFFSET`.\n\n*`param`*\n\nReturns the requested value.\n\n## Description\n\n`glGetVertexArrayIndexediv` and `glGetVertexArrayIndexed64iv` provide a way of querying parameters of an attribute at an user-specified index of a vertex array object. The vertex array object does not have to be bound to the rendering context at the time of the call, but must have been bound at least once prior to this call.\n\nThe following parameter values can be retrieved with `glGetVertexArrayIndexediv` for each of the attributes defined for a vertex array object:\n\n- `GL_VERTEX_ATTRIB_ARRAY_ENABLED`: *`param`* returns a value that is non-zero (true) if the vertex attribute array for index is enabled and 0 (false) if it is disabled. The initial value is `GL_FALSE`.\n\n- `GL_VERTEX_ATTRIB_ARRAY_SIZE`: *`param`* returns a single value, the size of the vertex attribute array for index. The size is the number of values for each element of the vertex attribute array, and it will be 1, 2, 3 or 4. The initial value is 4.\n\n- `GL_VERTEX_ATTRIB_ARRAY_STRIDE`: *`param`* returns a single value, the array stride for (number of bytes between successive elements in) the vertex attribute array for index. A value of 0 indicates the array elements are stored sequentially in memory. The initial value is 0.\n\n- `GL_VERTEX_ATTRIB_ARRAY_TYPE`: *`param`* returns a single value, a symbolic constant indicating the array type for the vertex attribute array for index. Possible values are `GL_BYTE`, `GL_DOUBLE`, `GL_FIXED`, `GL_FLOAT`, `GL_HALF_FLOAT`, `GL_INT`, `GL_INT_2_10_10_10_REV`, `GL_SHORT`, `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, `GL_UNSIGNED_INT`, `GL_UNSIGNED_INT_2_10_10_10_REV`, and `GL_UNSIGNED_INT_10F_11F_11F_REV` . The initial value is `GL_FLOAT`.\n\n- `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`: *`param`* returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by index are normalized when they are converted to floating-point, and 0 (false) otherwise. The initial value is `GL_FALSE`.\n\n- `GL_VERTEX_ATTRIB_ARRAY_INTEGER`: *`param`* returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by index have integer data type, and 0 (false) otherwise. The initial value is 0 (`GL_FALSE`).\n\n- `GL_VERTEX_ATTRIB_ARRAY_LONG`: *`param`* returns a single value that is non-zero (true) if a vertex attribute is stored as an unconverted double, and 0 (false) otherwise. The initial value is 0 (`GL_FALSE`).\n\n- `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`: *`param`* returns a single value that is the frequency divisor used for instanced rendering. See glVertexAttribDivisor. The initial value is 0.\n\n- `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`: *`param`* returns a single value that is the byte offset of the first element relative to the start of the vertex buffer binding specified attribute fetches from. The initial value is 0.\n\n`glGetVertexArrayIndexed64iv` can be used to retrieve `GL_VERTEX_BINDING_OFFSET` parameter value for any of the attributes defined for a vertex array object. When *`pname`* is set to `GL_VERTEX_BINDING_OFFSET`, *`param`* returns a single value that is the byte offset of the first element in the bound buffer's data store. The initial value for this parameter is 0.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_VALUE` error is generated if index is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_ENUM` error is generated if *`pname`* is not one of the valid values. For more details, please see above.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetVertexArrayIndexed64iv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glGetVertexArrayIndexediv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml), [glVertexAttribBinding](glvertexattribbinding.xhtml), `glVertexAttribIPointer`, `glVertexAttribLPointer`, [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexArrayIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexArrayIndexed.xhtml)"
- name: glGetVertexArrayiv
  id: glgetvertexarrayiv.xhtml
  summary: vaobj specifies the name of the vertex array object to use for the query
  description: "## Name\n\nglGetVertexArrayiv — retrieve parameters of a vertex array object\n\n## C Specification\n\n`void `**`glGetVertexArrayiv`**`(` GLuint `vaobj`, GLenum `pname`, GLint \\*`param``)`;\n\n## Parameters\n\n *`vaobj`*  \nspecifies the name of the vertex array object to use for the query.\n\n *`pname`*  \nName of the property to use for the query. Must be `GL_ELEMENT_ARRAY_BUFFER_BINDING`.\n\n *`param`*  \nReturns the requested value.\n\n## Description\n\nThis function provides a mean of querying properties of an existing vertex array object. The vertex array object does not have to be bound to the rendering context at the time of the call, but must have been bound at least once prior to this call.\n\n`glGetVertexArrayiv` can be used to retrieve ID of a buffer object that will be bound to the `GL_ELEMENT_ARRAY_BUFFER` binding point whenever the queried vertex array object is bound to the rendering context. The binding can be changed for an active vertex array object with a `glBindBuffer` call.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_ENUM` error is generated if *`pname`* is not `GL_ELEMENT_ARRAY_BUFFER_BINDING`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetVertexArrayiv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBindVertexArray](glbindvertexarray.xhtml), [glGet](glget.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexArrayiv.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexArrayiv.xhtml)"
- name: glGetVertexAttrib
  id: glgetvertexattrib.xhtml
  summary: index Specifies the generic vertex attribute parameter to be queried
  description: "## Name\n\nglGetVertexAttrib — Return a generic vertex attribute parameter\n\n## C Specification\n\n`void `**`glGetVertexAttribdv`**`(` GLuint `index`, GLenum `pname`, GLdouble \\*`params``)`;\n\n`void `**`glGetVertexAttribfv`**`(` GLuint `index`, GLenum `pname`, GLfloat \\*`params``)`;\n\n`void `**`glGetVertexAttribiv`**`(` GLuint `index`, GLenum `pname`, GLint \\*`params``)`;\n\n`void `**`glGetVertexAttribIiv`**`(` GLuint `index`, GLenum `pname`, GLint \\*`params``)`;\n\n`void `**`glGetVertexAttribIuiv`**`(` GLuint `index`, GLenum `pname`, GLuint \\*`params``)`;\n\n`void `**`glGetVertexAttribLdv`**`(` GLuint `index`, GLenum `pname`, GLdouble \\*`params``)`;\n\n## Parameters\n\n *`index`*  \nSpecifies the generic vertex attribute parameter to be queried.\n\n *`pname`*  \nSpecifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, `GL_VERTEX_ATTRIB_BINDING`, `GL_VERTEX_ATTRIB_RELATIVE_OFFSET` or `GL_CURRENT_VERTEX_ATTRIB`.\n\n *`params`*  \nReturns the requested data.\n\n## Description\n\n`glGetVertexAttrib` returns in *`params`* the value of a generic vertex attribute parameter. The generic vertex attribute to be queried is specified by *`index`*, and the parameter to be queried is specified by *`pname`*.\n\nThe accepted parameter names are as follows:\n\n `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`  \n*`params`* returns a single value, the name of the buffer object currently bound to the binding point corresponding to generic vertex attribute array *`index`*. If no buffer object is bound, 0 is returned. The initial value is 0.\n\n `GL_VERTEX_ATTRIB_ARRAY_ENABLED`  \n*`params`* returns a single value that is non-zero (true) if the vertex attribute array for *`index`* is enabled and 0 (false) if it is disabled. The initial value is `GL_FALSE`.\n\n `GL_VERTEX_ATTRIB_ARRAY_SIZE`  \n*`params`* returns a single value, the size of the vertex attribute array for *`index`*. The size is the number of values for each element of the vertex attribute array, and it will be 1, 2, 3, or 4. The initial value is 4.\n\n `GL_VERTEX_ATTRIB_ARRAY_STRIDE`  \n*`params`* returns a single value, the array stride for (number of bytes between successive elements in) the vertex attribute array for *`index`*. A value of 0 indicates that the array elements are stored sequentially in memory. The initial value is 0.\n\n `GL_VERTEX_ATTRIB_ARRAY_TYPE`  \n*`params`* returns a single value, a symbolic constant indicating the array type for the vertex attribute array for *`index`*. Possible values are `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT`, `GL_FLOAT`, and `GL_DOUBLE`. The initial value is `GL_FLOAT`.\n\n `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`  \n*`params`* returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by *`index`* are normalized when they are converted to floating point, and 0 (false) otherwise. The initial value is `GL_FALSE`.\n\n `GL_VERTEX_ATTRIB_ARRAY_INTEGER`  \n*`params`* returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by *`index`* have integer data types, and 0 (false) otherwise. The initial value is 0 (`GL_FALSE`).\n\n `GL_VERTEX_ATTRIB_ARRAY_LONG`  \n*`param`* returns a single value that is non-zero (true) if a vertex attribute is stored as an unconverted double, and 0 (false) otherwise. The initial value is 0 (`GL_FALSE`).\n\n `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`  \n*`params`* returns a single value that is the frequency divisor used for instanced rendering. See [glVertexAttribDivisor](glvertexattribdivisor.xhtml). The initial value is 0.\n\n `GL_VERTEX_ATTRIB_BINDING`  \n*`params`* returns a single value, the vertex buffer binding of the vertex attribute array *`index`*.\n\n `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`  \n*`params`* returns a single value that is the byte offset of the first element relative to the start of the vertex buffer binding specified attribute fetches from. The initial value is 0.\n\n `GL_CURRENT_VERTEX_ATTRIB`  \n*`params`* returns four values that represent the current value for the generic vertex attribute specified by index. Generic vertex attribute 0 is unique in that it has no current state, so an error will be generated if *`index`* is 0. The initial value for all other generic vertex attributes is (0,0,0,1).\n\n`glGetVertexAttribdv` and `glGetVertexAttribfv` return the current attribute values as four single-precision floating-point values; `glGetVertexAttribiv` reads them as floating-point values and converts them to four integer values; `glGetVertexAttribIiv` and `glGetVertexAttribIuiv` read and return them as signed or unsigned integer values, respectively; `glGetVertexAttribLdv` reads and returns them as four double-precision floating-point values.\n\nAll of the parameters except `GL_CURRENT_VERTEX_ATTRIB` represent state stored in the currently bound vertex array object.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`pname`* is not `GL_CURRENT_VERTEX_ATTRIB` and there is no currently bound vertex array object.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if *`index`* is 0 and *`pname`* is `GL_CURRENT_VERTEX_ATTRIB`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIBS`\n\n[glGetVertexAttribPointerv](glgetvertexattribpointerv.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_POINTER`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetVertexAttribIiv`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetVertexAttribIuiv`     |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetVertexAttribLdv`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetVertexAttribdv`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetVertexAttribfv`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glGetVertexAttribiv`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glBindBuffer](glbindbuffer.xhtml), `glDisableVertexAttribArray`, [glEnableVertexAttribArray](glenablevertexattribarray.xhtml), [glVertexAttrib](glvertexattrib.xhtml), [glVertexAttribDivisor](glvertexattribdivisor.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexAttrib.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexAttrib.xhtml)"
- name: glGetVertexAttribdv
  id: glgetvertexattrib.xhtml#glGetVertexAttribdv
  summary: null
  belongs_to: glGetVertexAttrib
  description: '`void `**`glGetVertexAttribdv`**`(` GLuint `index`, GLenum `pname`, GLdouble \*`params``)`;'
- name: glGetVertexAttribfv
  id: glgetvertexattrib.xhtml#glGetVertexAttribfv
  summary: null
  belongs_to: glGetVertexAttrib
  description: '`void `**`glGetVertexAttribfv`**`(` GLuint `index`, GLenum `pname`, GLfloat \*`params``)`;'
- name: glGetVertexAttribIiv
  id: glgetvertexattrib.xhtml#glGetVertexAttribIiv
  summary: null
  belongs_to: glGetVertexAttrib
  description: '`void `**`glGetVertexAttribIiv`**`(` GLuint `index`, GLenum `pname`, GLint \*`params``)`;'
- name: glGetVertexAttribIuiv
  id: glgetvertexattrib.xhtml#glGetVertexAttribIuiv
  summary: null
  belongs_to: glGetVertexAttrib
  description: '`void `**`glGetVertexAttribIuiv`**`(` GLuint `index`, GLenum `pname`, GLuint \*`params``)`;'
- name: glGetVertexAttribiv
  id: glgetvertexattrib.xhtml#glGetVertexAttribiv
  summary: null
  belongs_to: glGetVertexAttrib
  description: '`void `**`glGetVertexAttribiv`**`(` GLuint `index`, GLenum `pname`, GLint \*`params``)`;'
- name: glGetVertexAttribLdv
  id: glgetvertexattrib.xhtml#glGetVertexAttribLdv
  summary: Specifies the generic vertex attribute parameter to be queried
  belongs_to: glGetVertexAttrib
  description: "`void `**`glGetVertexAttribLdv`**`(` GLuint `index`, GLenum `pname`, GLdouble \\*`params``)`;\n\n## Parameters\n\n*`index`*\n\nSpecifies the generic vertex attribute parameter to be queried.\n\n*`pname`*\n\nSpecifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`, `GL_VERTEX_ATTRIB_ARRAY_ENABLED`, `GL_VERTEX_ATTRIB_ARRAY_SIZE`, `GL_VERTEX_ATTRIB_ARRAY_STRIDE`, `GL_VERTEX_ATTRIB_ARRAY_TYPE`, `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`, `GL_VERTEX_ATTRIB_ARRAY_INTEGER`, `GL_VERTEX_ATTRIB_ARRAY_LONG`, `GL_VERTEX_ATTRIB_ARRAY_DIVISOR`, `GL_VERTEX_ATTRIB_BINDING`, `GL_VERTEX_ATTRIB_RELATIVE_OFFSET` or `GL_CURRENT_VERTEX_ATTRIB`.\n\n*`params`*\n\nReturns the requested data.\n\n## Description\n\n`glGetVertexAttrib` returns in *`params`* the value of a generic vertex attribute parameter. The generic vertex attribute to be queried is specified by *`index`*, and the parameter to be queried is specified by *`pname`*.\n\nThe accepted parameter names are as follows:\n\n`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`\n\n*`params`* returns a single value, the name of the buffer object currently bound to the binding point corresponding to generic vertex attribute array *`index`*. If no buffer object is bound, 0 is returned. The initial value is 0.\n\n`GL_VERTEX_ATTRIB_ARRAY_ENABLED`\n\n*`params`* returns a single value that is non-zero (true) if the vertex attribute array for *`index`* is enabled and 0 (false) if it is disabled. The initial value is `GL_FALSE`.\n\n`GL_VERTEX_ATTRIB_ARRAY_SIZE`\n\n*`params`* returns a single value, the size of the vertex attribute array for *`index`*. The size is the number of values for each element of the vertex attribute array, and it will be 1, 2, 3, or 4. The initial value is 4.\n\n`GL_VERTEX_ATTRIB_ARRAY_STRIDE`\n\n*`params`* returns a single value, the array stride for (number of bytes between successive elements in) the vertex attribute array for *`index`*. A value of 0 indicates that the array elements are stored sequentially in memory. The initial value is 0.\n\n`GL_VERTEX_ATTRIB_ARRAY_TYPE`\n\n*`params`* returns a single value, a symbolic constant indicating the array type for the vertex attribute array for *`index`*. Possible values are `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT`, `GL_FLOAT`, and `GL_DOUBLE`. The initial value is `GL_FLOAT`.\n\n`GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`\n\n*`params`* returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by *`index`* are normalized when they are converted to floating point, and 0 (false) otherwise. The initial value is `GL_FALSE`.\n\n`GL_VERTEX_ATTRIB_ARRAY_INTEGER`\n\n*`params`* returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by *`index`* have integer data types, and 0 (false) otherwise. The initial value is 0 (`GL_FALSE`).\n\n`GL_VERTEX_ATTRIB_ARRAY_LONG`\n\n*`param`* returns a single value that is non-zero (true) if a vertex attribute is stored as an unconverted double, and 0 (false) otherwise. The initial value is 0 (`GL_FALSE`).\n\n`GL_VERTEX_ATTRIB_ARRAY_DIVISOR`\n\n*`params`* returns a single value that is the frequency divisor used for instanced rendering. See [glVertexAttribDivisor](glvertexattribdivisor.xhtml). The initial value is 0.\n\n`GL_VERTEX_ATTRIB_BINDING`\n\n*`params`* returns a single value, the vertex buffer binding of the vertex attribute array *`index`*.\n\n`GL_VERTEX_ATTRIB_RELATIVE_OFFSET`\n\n*`params`* returns a single value that is the byte offset of the first element relative to the start of the vertex buffer binding specified attribute fetches from. The initial value is 0.\n\n`GL_CURRENT_VERTEX_ATTRIB`\n\n*`params`* returns four values that represent the current value for the generic vertex attribute specified by index. Generic vertex attribute 0 is unique in that it has no current state, so an error will be generated if *`index`* is 0. The initial value for all other generic vertex attributes is (0,0,0,1).\n\n`glGetVertexAttribdv` and `glGetVertexAttribfv` return the current attribute values as four single-precision floating-point values; `glGetVertexAttribiv` reads them as floating-point values and converts them to four integer values; `glGetVertexAttribIiv` and `glGetVertexAttribIuiv` read and return them as signed or unsigned integer values, respectively; `glGetVertexAttribLdv` reads and returns them as four double-precision floating-point values.\n\nAll of the parameters except `GL_CURRENT_VERTEX_ATTRIB` represent state stored in the currently bound vertex array object.\n\n## Notes\n\nIf an error is generated, no change is made to the contents of *`params`*.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`pname`* is not `GL_CURRENT_VERTEX_ATTRIB` and there is no currently bound vertex array object.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if *`index`* is 0 and *`pname`* is `GL_CURRENT_VERTEX_ATTRIB`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIBS`\n\n[glGetVertexAttribPointerv](glgetvertexattribpointerv.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_POINTER`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glGetVertexAttribIiv`        |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetVertexAttribIuiv`       |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetVertexAttribLdv`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetVertexAttribdv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetVertexAttribfv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glGetVertexAttribiv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glBindBuffer](glbindbuffer.xhtml), `glDisableVertexAttribArray`, [glEnableVertexAttribArray](glenablevertexattribarray.xhtml), [glVertexAttrib](glvertexattrib.xhtml), [glVertexAttribDivisor](glvertexattribdivisor.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexAttrib.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexAttrib.xhtml)"
- name: glGetVertexAttribPointerv
  id: glgetvertexattribpointerv.xhtml
  summary: index Specifies the generic vertex attribute parameter to be returned
  description: "## Name\n\nglGetVertexAttribPointerv — return the address of the specified generic vertex attribute pointer\n\n## C Specification\n\n`void `**`glGetVertexAttribPointerv`**`(` GLuint `index`, GLenum `pname`, void \\*\\*`pointer``)`;\n\n## Parameters\n\n *`index`*  \nSpecifies the generic vertex attribute parameter to be returned.\n\n *`pname`*  \nSpecifies the symbolic name of the generic vertex attribute parameter to be returned. Must be `GL_VERTEX_ATTRIB_ARRAY_POINTER`.\n\n *`pointer`*  \nReturns the pointer value.\n\n## Description\n\n`glGetVertexAttribPointerv` returns pointer information. *`index`* is the generic vertex attribute to be queried, *`pname`* is a symbolic constant indicating the pointer to be returned, and *`params`* is a pointer to a location in which to place the returned data.\n\nThe *`pointer`* returned is a byte offset into the data store of the buffer object that was bound to the `GL_ARRAY_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) when the desired pointer was previously specified.\n\n## Notes\n\nThe state returned is retrieved from the currently bound vertex array object.\n\nThe initial value for each pointer is 0.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if no vertex array object is currently bound.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIBS`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glGetVertexAttribPointerv` |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexAttribPointerv.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glGetVertexAttribPointerv.xhtml)"
- name: glHint
  id: glhint.xhtml
  summary: target Specifies a symbolic constant indicating the behavior to be controlled
  description: "## Name\n\nglHint — specify implementation-specific hints\n\n## C Specification\n\n`void `**`glHint`**`(` GLenum `target`, GLenum `mode``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies a symbolic constant indicating the behavior to be controlled. `GL_LINE_SMOOTH_HINT`, `GL_POLYGON_SMOOTH_HINT`, `GL_TEXTURE_COMPRESSION_HINT`, and `GL_FRAGMENT_SHADER_DERIVATIVE_HINT` are accepted.\n\n *`mode`*  \nSpecifies a symbolic constant indicating the desired behavior. `GL_FASTEST`, `GL_NICEST`, and `GL_DONT_CARE` are accepted.\n\n## Description\n\nCertain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is specified with two arguments. *`target`* is a symbolic constant indicating the behavior to be controlled, and *`mode`* is another symbolic constant indicating the desired behavior. The initial value for each *`target`* is `GL_DONT_CARE`. *`mode`* can be one of the following:\n\n `GL_FASTEST`  \nThe most efficient option should be chosen.\n\n `GL_NICEST`  \nThe most correct, or highest quality, option should be chosen.\n\n `GL_DONT_CARE`  \nNo preference.\n\nThough the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation. The hint aspects that can be specified with *`target`*, along with suggested semantics, are as follows:\n\n `GL_FRAGMENT_SHADER_DERIVATIVE_HINT`  \nIndicates the accuracy of the derivative calculation for the GL shading language fragment processing built-in functions: `dFdx`, `dFdy`, and `fwidth`.\n\n `GL_LINE_SMOOTH_HINT`  \nIndicates the sampling quality of antialiased lines. If a larger filter function is applied, hinting `GL_NICEST` can result in more pixel fragments being generated during rasterization.\n\n `GL_POLYGON_SMOOTH_HINT`  \nIndicates the sampling quality of antialiased polygons. Hinting `GL_NICEST` can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.\n\n `GL_TEXTURE_COMPRESSION_HINT`  \nIndicates the quality and performance of the compressing texture images. Hinting `GL_FASTEST` indicates that texture images should be compressed as quickly as possible, while `GL_NICEST` indicates that texture images should be compressed with as little image quality loss as possible. `GL_NICEST` should be selected if the texture is to be retrieved by [glGetCompressedTexImage](glgetcompressedteximage.xhtml) for reuse.\n\n## Notes\n\nThe interpretation of hints depends on the implementation. Some implementations ignore `glHint` settings.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if either *`target`* or *`mode`* is not an accepted value.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glHint`                    |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glHint.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glHint.xhtml)"
- name: glInvalidateBufferData
  id: glinvalidatebufferdata.xhtml
  summary: buffer The name of a buffer object whose data store to invalidate
  description: "## Name\n\nglInvalidateBufferData — invalidate the content of a buffer object's data store\n\n## C Specification\n\n`void `**`glInvalidateBufferData`**`(` GLuint `buffer``)`;\n\n## Parameters\n\n *`buffer`*  \nThe name of a buffer object whose data store to invalidate.\n\n## Description\n\n`glInvalidateBufferData` invalidates all of the content of the data store of a buffer object. After invalidation, the content of the buffer's data store becomes undefined.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_OPERATION` is generated if any part of *`buffer`* is currently mapped.\n\n## Associated Gets\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_SIZE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glInvalidateBufferData`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glInvalidateTexSubImage](glinvalidatetexsubimage.xhtml),, [glInvalidateTexImage](glinvalidateteximage.xhtml), [glInvalidateBufferSubData](glinvalidatebuffersubdata.xhtml), [glInvalidateFramebuffer](glinvalidateframebuffer.xhtml), [glInvalidateSubFramebuffer](glinvalidatesubframebuffer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateBufferData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateBufferData.xhtml)"
- name: glInvalidateBufferSubData
  id: glinvalidatebuffersubdata.xhtml
  summary: buffer The name of a buffer object, a subrange of whose data store to invalidate
  description: "## Name\n\nglInvalidateBufferSubData — invalidate a region of a buffer object's data store\n\n## C Specification\n\n`void `**`glInvalidateBufferSubData`**`(` GLuint `buffer`, GLintptr `offset`, GLsizeiptr `length``)`;\n\n## Parameters\n\n *`buffer`*  \nThe name of a buffer object, a subrange of whose data store to invalidate.\n\n *`offset`*  \nThe offset within the buffer's data store of the start of the range to be invalidated.\n\n *`length`*  \nThe length of the range within the buffer's data store to be invalidated.\n\n## Description\n\n`glInvalidateBufferSubData` invalidates all or part of the content of the data store of a buffer object. After invalidation, the content of the specified range of the buffer's data store becomes undefined. The start of the range is given by *`offset`* and its size is given by *`length`*, both measured in basic machine units.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`length`* is negative, or if *`offset`* + *`length`* is greater than the value of `GL_BUFFER_SIZE` for *`buffer`*.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_OPERATION` is generated if any part of *`buffer`* is currently mapped.\n\n## Associated Gets\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_SIZE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glInvalidateBufferSubData` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glInvalidateTexSubImage](glinvalidatetexsubimage.xhtml),, [glInvalidateTexImage](glinvalidateteximage.xhtml), [glInvalidateBufferData](glinvalidatebufferdata.xhtml), [glInvalidateFramebuffer](glinvalidateframebuffer.xhtml), [glInvalidateSubFramebuffer](glinvalidatesubframebuffer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateBufferSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateBufferSubData.xhtml)"
- name: glInvalidateFramebuffer
  id: glinvalidateframebuffer.xhtml
  summary: target Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer
  description: "## Name\n\nglInvalidateFramebuffer, glInvalidateNamedFramebufferData — invalidate the content of some or all of a framebuffer's attachments\n\n## C Specification\n\n`void `**`glInvalidateFramebuffer`**`(` GLenum `target`, GLsizei `numAttachments`, const GLenum \\* `attachments``)`;\n\n`void `**`glInvalidateNamedFramebufferData`**`(` GLuint `framebuffer`, GLsizei `numAttachments`, const GLenum \\*`attachments``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the framebuffer object is attached for `glInvalidateFramebuffer`.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glInvalidateNamedFramebufferData`.\n\n *`numAttachments`*  \nSpecifies the number of entries in the *`attachments`* array.\n\n *`attachments`*  \nSpecifies a pointer to an array identifying the attachments to be invalidated.\n\n## Description\n\n`glInvalidateFramebuffer` and `glInvalidateNamedFramebufferData` invalidate the entire contents of a specified set of attachments of a framebuffer.\n\nFor `glInvalidateFramebuffer`, the framebuffer object is that bound to *`target`*. *`target`* must be `GL_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_DRAW_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be invalidated if bound to *`target`*.\n\nFor `glInvalidateNamedFramebufferData`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, the default draw framebuffer is affected.\n\nThe set of attachments whose contents are to be invalidated are specified in the *`attachments`* array, which contains *`numAttachments`* elements.\n\nIf the specified framebuffer is a framebuffer object, each element of *`attachments`* must be one of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or `GL_COLOR_ATTACHMENT`*i*, where *i* is between zero and the value of `GL_MAX_FRAMEBUFFER_ATTACHMENTS` minus one.\n\nIf the specified framebuffer is a default framebuffer, each element of *`attachments`* must be one of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_AUX`*i*, `GL_ACCUM`, `GL_COLOR`, `GL_DEPTH`, or `GL_STENCIL`. `GL_COLOR`, is treated as `GL_BACK_LEFT` for a double-buffered context and `GL_FRONT_LEFT` for a single-buffered context. The other attachments identify the corresponding specific buffer.\n\nThe entire contents of each specified attachment become undefined after execution of `glInvalidateFramebuffer` or `glInvalidateNamedFramebufferData`.\n\nIf the framebuffer object is not complete, `glInvalidateFramebuffer` and `glInvalidateNamedFramebufferData` may be ignored. This is not an error.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glInvalidateFramebuffer` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glInvalidateNamedFramebufferData` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_VALUE` is generated if *`numAttachments`* is negative.\n\n`GL_INVALID_ENUM` is generated if any element of *`attachments`* is not one of the accepted framebuffer attachment points, as described above.\n\n`GL_INVALID_OPERATION` is generated if element of *`attachments`* is `GL_COLOR_ATTACHMENT`*m* where *m* is greater than or equal to the value of `GL_MAX_COLOR_ATTACHMENTS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_COLOR_ATTACHMENTS`\n\n## Version Support\n\n|                                    | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**        |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glInvalidateFramebuffer`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glInvalidateNamedFramebufferData` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glInvalidateTexSubImage](glinvalidatetexsubimage.xhtml), [glInvalidateTexImage](glinvalidateteximage.xhtml), [glInvalidateBufferSubData](glinvalidatebuffersubdata.xhtml), [glInvalidateBufferData](glinvalidatebufferdata.xhtml), [glInvalidateSubFramebuffer](glinvalidatesubframebuffer.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateFramebuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateFramebuffer.xhtml)"
- name: glInvalidateNamedFramebufferData
  id: glinvalidateframebuffer.xhtml#glInvalidateNamedFramebufferData
  summary: Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer
  belongs_to: glInvalidateFramebuffer
  description: "`void `**`glInvalidateNamedFramebufferData`**`(` GLuint `framebuffer`, GLsizei `numAttachments`, const GLenum \\*`attachments``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the framebuffer object is attached for `glInvalidateFramebuffer`.\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glInvalidateNamedFramebufferData`.\n\n*`numAttachments`*\n\nSpecifies the number of entries in the *`attachments`* array.\n\n*`attachments`*\n\nSpecifies a pointer to an array identifying the attachments to be invalidated.\n\n## Description\n\n`glInvalidateFramebuffer` and `glInvalidateNamedFramebufferData` invalidate the entire contents of a specified set of attachments of a framebuffer.\n\nFor `glInvalidateFramebuffer`, the framebuffer object is that bound to *`target`*. *`target`* must be `GL_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_DRAW_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be invalidated if bound to *`target`*.\n\nFor `glInvalidateNamedFramebufferData`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, the default draw framebuffer is affected.\n\nThe set of attachments whose contents are to be invalidated are specified in the *`attachments`* array, which contains *`numAttachments`* elements.\n\nIf the specified framebuffer is a framebuffer object, each element of *`attachments`* must be one of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or `GL_COLOR_ATTACHMENT`*i*, where *i* is between zero and the value of `GL_MAX_FRAMEBUFFER_ATTACHMENTS` minus one.\n\nIf the specified framebuffer is a default framebuffer, each element of *`attachments`* must be one of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_AUX`*i*, `GL_ACCUM`, `GL_COLOR`, `GL_DEPTH`, or `GL_STENCIL`. `GL_COLOR`, is treated as `GL_BACK_LEFT` for a double-buffered context and `GL_FRONT_LEFT` for a single-buffered context. The other attachments identify the corresponding specific buffer.\n\nThe entire contents of each specified attachment become undefined after execution of `glInvalidateFramebuffer` or `glInvalidateNamedFramebufferData`.\n\nIf the framebuffer object is not complete, `glInvalidateFramebuffer` and `glInvalidateNamedFramebufferData` may be ignored. This is not an error.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glInvalidateFramebuffer` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glInvalidateNamedFramebufferData` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_VALUE` is generated if *`numAttachments`* is negative.\n\n`GL_INVALID_ENUM` is generated if any element of *`attachments`* is not one of the accepted framebuffer attachment points, as described above.\n\n`GL_INVALID_OPERATION` is generated if element of *`attachments`* is `GL_COLOR_ATTACHMENT`*m* where *m* is greater than or equal to the value of `GL_MAX_COLOR_ATTACHMENTS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_COLOR_ATTACHMENTS`\n\n## Version Support\n\n|                                    |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:-----------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**       |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glInvalidateFramebuffer`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glInvalidateNamedFramebufferData` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glInvalidateTexSubImage](glinvalidatetexsubimage.xhtml), [glInvalidateTexImage](glinvalidateteximage.xhtml), [glInvalidateBufferSubData](glinvalidatebuffersubdata.xhtml), [glInvalidateBufferData](glinvalidatebufferdata.xhtml), [glInvalidateSubFramebuffer](glinvalidatesubframebuffer.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateFramebuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateFramebuffer.xhtml)"
- name: glInvalidateNamedFramebufferSubData
  id: glinvalidatesubframebuffer.xhtml#glInvalidateNamedFramebufferSubData
  summary: Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer
  belongs_to: glInvalidateSubFramebuffer
  description: "`void `**`glInvalidateNamedFramebufferSubData`**`(` GLuint `framebuffer`, GLsizei `numAttachments`, const GLenum \\*`attachments`, GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the framebuffer object is attached for `glInvalidateSubFramebuffer`.\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glInvalidateNamedFramebufferSubData`.\n\n*`numAttachments`*\n\nSpecifies the number of entries in the *`attachments`* array.\n\n*`attachments`*\n\nSpecifies a pointer to an array identifying the attachments to be invalidated.\n\n*`x`*\n\nSpecifies the X offset of the region to be invalidated.\n\n*`y`*\n\nSpecifies the Y offset of the region to be invalidated.\n\n*`width`*\n\nSpecifies the width of the region to be invalidated.\n\n*`height`*\n\nSpecifies the height of the region to be invalidated.\n\n## Description\n\n`glInvalidateSubFramebuffer` and `glInvalidateNamedFramebufferSubData` invalidate the contents of a specified region of a specified set of attachments of a framebuffer.\n\nFor `glInvalidateSubFramebuffer`, the framebuffer object is that bound to *`target`*, which must be one of `GL_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_DRAW_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be invalidated if bound to *`target`*.\n\nFor `glInvalidateNamedFramebufferSubData`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, the default draw framebuffer is affected.\n\nThe set of attachments of which a region is to be invalidated are specified in the *`attachments`* array, which contains *`numAttachments`* elements.\n\nIf the specified framebuffer is a framebuffer object, each element of *`attachments`* must be one of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or `GL_COLOR_ATTACHMENT`*i*, where *i* is between zero and the value of `GL_MAX_FRAMEBUFFER_ATTACHMENTS` minus one.\n\nIf the specified framebuffer is a default framebuffer, each element of *`attachments`* must be one of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_AUX`*i*, `GL_ACCUM`, `GL_COLOR`, `GL_DEPTH`, or `GL_STENCIL`. `GL_COLOR`, is treated as `GL_BACK_LEFT` for a double-buffered context and `GL_FRONT_LEFT` for a single-buffered context. The other attachments identify the corresponding specific buffer.\n\nThe contents of the specified region of each specified attachment become undefined after execution of `glInvalidateSubFramebuffer` or `glInvalidateNamedFramebufferSubData`. The region to be invalidated is specified by *`x`*, *`y`*, *`width`* and *`height`* where *`x`* and *`y`* give the offset from the origin (with lower-left corner at $(0,0)$) and *`width`* and *`height`* are the width and height, respectively, of the region. Any pixels lying outside of the window allocated to the current GL context (for the default framebuffer), or outside of the attachments of the framebuffer object, are ignored. If the framebuffer object is not complete, these commands may be ignored.\n\nIf the framebuffer object is not complete, `glInvalidateSubFramebuffer` and `glInvalidateNamedFramebufferSubData` may be ignored. This is not an error.\n\n## Errors\n\n`GL_INVALID_ENUM` by `glInvalidateSubFramebuffer` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` by `glInvalidateNamedFramebufferSubData` if *`framebuffer`* is not zero of the name of an existing framebuffer object.\n\n`GL_INVALID_VALUE` is generated if *`numAttachments`*, *`width`* or *`height`* is negative.\n\n`GL_INVALID_ENUM` is generated if any element of *`attachments`* is not one of the accepted framebuffer attachment points, as described above.\n\n`GL_INVALID_OPERATION` is generated if element of *`attachments`* is `GL_COLOR_ATTACHMENT`*m* where *m* is greater than or equal to the value of `GL_MAX_COLOR_ATTACHMENTS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_COLOR_ATTACHMENTS`\n\n## Version Support\n\n|                                       |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**          |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glInvalidateNamedFramebufferSubData` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glInvalidateSubFramebuffer`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glInvalidateTexSubImage](glinvalidatetexsubimage.xhtml), [glInvalidateTexImage](glinvalidateteximage.xhtml), [glInvalidateBufferSubData](glinvalidatebuffersubdata.xhtml), [glInvalidateBufferData](glinvalidatebufferdata.xhtml), [glInvalidateFramebuffer](glinvalidateframebuffer.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateSubFramebuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateSubFramebuffer.xhtml)"
- name: glInvalidateSubFramebuffer
  id: glinvalidatesubframebuffer.xhtml
  summary: target Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer
  description: "## Name\n\nglInvalidateSubFramebuffer, glInvalidateNamedFramebufferSubData — invalidate the content of a region of some or all of a framebuffer's attachments\n\n## C Specification\n\n`void `**`glInvalidateSubFramebuffer`**`(` GLenum `target`, GLsizei `numAttachments`, const GLenum \\* `attachments`, GLint `x`, GLint `y`, GLint `width`, GLint `height``)`;\n\n`void `**`glInvalidateNamedFramebufferSubData`**`(` GLuint `framebuffer`, GLsizei `numAttachments`, const GLenum \\*`attachments`, GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the framebuffer object is attached for `glInvalidateSubFramebuffer`.\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glInvalidateNamedFramebufferSubData`.\n\n *`numAttachments`*  \nSpecifies the number of entries in the *`attachments`* array.\n\n *`attachments`*  \nSpecifies a pointer to an array identifying the attachments to be invalidated.\n\n *`x`*  \nSpecifies the X offset of the region to be invalidated.\n\n *`y`*  \nSpecifies the Y offset of the region to be invalidated.\n\n *`width`*  \nSpecifies the width of the region to be invalidated.\n\n *`height`*  \nSpecifies the height of the region to be invalidated.\n\n## Description\n\n`glInvalidateSubFramebuffer` and `glInvalidateNamedFramebufferSubData` invalidate the contents of a specified region of a specified set of attachments of a framebuffer.\n\nFor `glInvalidateSubFramebuffer`, the framebuffer object is that bound to *`target`*, which must be one of `GL_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_DRAW_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`. Default framebuffers may also be invalidated if bound to *`target`*.\n\nFor `glInvalidateNamedFramebufferSubData`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, the default draw framebuffer is affected.\n\nThe set of attachments of which a region is to be invalidated are specified in the *`attachments`* array, which contains *`numAttachments`* elements.\n\nIf the specified framebuffer is a framebuffer object, each element of *`attachments`* must be one of `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` `GL_DEPTH_STENCIL_ATTACHMENT`, or `GL_COLOR_ATTACHMENT`*i*, where *i* is between zero and the value of `GL_MAX_FRAMEBUFFER_ATTACHMENTS` minus one.\n\nIf the specified framebuffer is a default framebuffer, each element of *`attachments`* must be one of `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_AUX`*i*, `GL_ACCUM`, `GL_COLOR`, `GL_DEPTH`, or `GL_STENCIL`. `GL_COLOR`, is treated as `GL_BACK_LEFT` for a double-buffered context and `GL_FRONT_LEFT` for a single-buffered context. The other attachments identify the corresponding specific buffer.\n\nThe contents of the specified region of each specified attachment become undefined after execution of `glInvalidateSubFramebuffer` or `glInvalidateNamedFramebufferSubData`. The region to be invalidated is specified by *`x`*, *`y`*, *`width`* and *`height`* where *`x`* and *`y`* give the offset from the origin (with lower-left corner at $(0,0)$) and *`width`* and *`height`* are the width and height, respectively, of the region. Any pixels lying outside of the window allocated to the current GL context (for the default framebuffer), or outside of the attachments of the framebuffer object, are ignored. If the framebuffer object is not complete, these commands may be ignored.\n\nIf the framebuffer object is not complete, `glInvalidateSubFramebuffer` and `glInvalidateNamedFramebufferSubData` may be ignored. This is not an error.\n\n## Errors\n\n`GL_INVALID_ENUM` by `glInvalidateSubFramebuffer` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` by `glInvalidateNamedFramebufferSubData` if *`framebuffer`* is not zero of the name of an existing framebuffer object.\n\n`GL_INVALID_VALUE` is generated if *`numAttachments`*, *`width`* or *`height`* is negative.\n\n`GL_INVALID_ENUM` is generated if any element of *`attachments`* is not one of the accepted framebuffer attachment points, as described above.\n\n`GL_INVALID_OPERATION` is generated if element of *`attachments`* is `GL_COLOR_ATTACHMENT`*m* where *m* is greater than or equal to the value of `GL_MAX_COLOR_ATTACHMENTS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_COLOR_ATTACHMENTS`\n\n## Version Support\n\n|                                       | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**           |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glInvalidateNamedFramebufferSubData` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glInvalidateSubFramebuffer`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glInvalidateTexSubImage](glinvalidatetexsubimage.xhtml), [glInvalidateTexImage](glinvalidateteximage.xhtml), [glInvalidateBufferSubData](glinvalidatebuffersubdata.xhtml), [glInvalidateBufferData](glinvalidatebufferdata.xhtml), [glInvalidateFramebuffer](glinvalidateframebuffer.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateSubFramebuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateSubFramebuffer.xhtml)"
- name: glInvalidateTexImage
  id: glinvalidateteximage.xhtml
  summary: texture The name of a texture object to invalidate
  description: "## Name\n\nglInvalidateTexImage — invalidate the entirety a texture image\n\n## C Specification\n\n`void `**`glInvalidateTexImage`**`(` GLuint `texture`, GLint `level``)`;\n\n## Parameters\n\n *`texture`*  \nThe name of a texture object to invalidate.\n\n *`level`*  \nThe level of detail of the texture object to invalidate.\n\n## Description\n\n`glInvalidateTexSubImage` invalidates all of a texture image. *`texture`* and *`level`* indicated which texture image is being invalidated. After this command, data in the texture image has undefined values.\n\n*`level`* must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height, or depth.\n\nFor textures of targets `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, level must be zero.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than zero or if it is greater or equal to the base 2 logarithm of the maximum texture width, height, or depth.\n\n`GL_INVALID_VALUE` is generated if the target of *`texture`* is any of `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` and *`level`* is not zero.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not the name of an existing texture object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_TEXTURE_SIZE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glInvalidateTexImage`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glInvalidateTexSubImage](glinvalidatetexsubimage.xhtml),, [glInvalidateBufferSubData](glinvalidatebuffersubdata.xhtml), [glInvalidateBufferData](glinvalidatebufferdata.xhtml), [glInvalidateFramebuffer](glinvalidateframebuffer.xhtml), [glInvalidateSubFramebuffer](glinvalidatesubframebuffer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateTexImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateTexImage.xhtml)"
- name: glInvalidateTexSubImage
  id: glinvalidatetexsubimage.xhtml
  summary: texture The name of a texture object a subregion of which to invalidate
  description: "## Name\n\nglInvalidateTexSubImage — invalidate a region of a texture image\n\n## C Specification\n\n`void `**`glInvalidateTexSubImage`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth``)`;\n\n## Parameters\n\n *`texture`*  \nThe name of a texture object a subregion of which to invalidate.\n\n *`level`*  \nThe level of detail of the texture object within which the region resides.\n\n *`xoffset`*  \nThe X offset of the region to be invalidated.\n\n *`yoffset`*  \nThe Y offset of the region to be invalidated.\n\n *`zoffset`*  \nThe Z offset of the region to be invalidated.\n\n *`width`*  \nThe width of the region to be invalidated.\n\n *`height`*  \nThe height of the region to be invalidated.\n\n *`depth`*  \nThe depth of the region to be invalidated.\n\n## Description\n\n`glInvalidateTexSubImage` invalidates all or part of a texture image. *`texture`* and *`level`* indicated which texture image is being invalidated. After this command, data in that subregion have undefined values. *`xoffset`*, *`yoffset`*, *`zoffset`*, *`width`*, *`height`*, and *`depth`* are interpreted as they are in [glTexSubImage3D](gltexsubimage3d.xhtml). For texture targets that don't have certain dimensions, this command treats those dimensions as having a size of 1. For example, to invalidate a portion of a two- dimensional texture, the application would use *`zoffset`* equal to zero and *`depth`* equal to one. Cube map textures are treated as an array of six slices in the z-dimension, where a value of *`zoffset`* is interpreted as specifying face `GL_TEXTURE_CUBE_MAP_POSITIVE_X` + *`zoffset`*.\n\n*`level`* must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height, or depth. *`xoffset`*, *`yoffset`* and *`zoffset`* must be greater than or equal to zero and be less than the width, height or depth of the image, respectively. Furthermore, *`xoffset`* + *`width`*, *`yoffset`* + *`height`*, and *`zoffset`* + *`depth`* must be less than or equal to the width, height or depth of the image, respectively.\n\nFor textures of targets `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, level must be zero.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`xoffset`*, *`yoffset`* or *`zoffset`* is less than zero, or if any of them is greater than the size of the image in the corresponding dimension.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than zero or if it is greater or equal to the base 2 logarithm of the maximum texture width, height, or depth.\n\n`GL_INVALID_VALUE` is generated if the target of *`texture`* is any of `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_BUFFER`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` and *`level`* is not zero.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not the name of an existing texture object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_TEXTURE_SIZE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glInvalidateTexSubImage`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glInvalidateTexImage](glinvalidateteximage.xhtml),, [glInvalidateBufferSubData](glinvalidatebuffersubdata.xhtml), [glInvalidateBufferData](glinvalidatebufferdata.xhtml), [glInvalidateFramebuffer](glinvalidateframebuffer.xhtml), [glInvalidateSubFramebuffer](glinvalidatesubframebuffer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateTexSubImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glInvalidateTexSubImage.xhtml)"
- name: glIsBuffer
  id: glisbuffer.xhtml
  summary: buffer Specifies a value that may be the name of a buffer object
  description: "## Name\n\nglIsBuffer — determine if a name corresponds to a buffer object\n\n## C Specification\n\n`GLboolean `**`glIsBuffer`**`(` GLuint `buffer``)`;\n\n## Parameters\n\n *`buffer`*  \nSpecifies a value that may be the name of a buffer object.\n\n## Description\n\n`glIsBuffer` returns `GL_TRUE` if *`buffer`* is currently the name of a buffer object. If *`buffer`* is zero, or is a non-zero value that is not currently the name of a buffer object, or if an error occurs, `glIsBuffer` returns `GL_FALSE`.\n\nA name returned by [glGenBuffers](glgenbuffers.xhtml), but not yet associated with a buffer object by calling [glBindBuffer](glbindbuffer.xhtml), is not the name of a buffer object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsBuffer`                |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glGenBuffers](glgenbuffers.xhtml), [glGet](glget.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsBuffer.xhtml)"
- name: glIsEnabled
  id: glisenabled.xhtml
  summary: cap Specifies a symbolic constant indicating a GL capability
  description: "## Name\n\nglIsEnabled, glIsEnabledi — test whether a capability is enabled\n\n## C Specification\n\n`GLboolean `**`glIsEnabled`**`(` GLenum `cap``)`;\n\n`GLboolean `**`glIsEnabledi`**`(` GLenum `cap`, GLuint `index``)`;\n\n## Parameters\n\n *`cap`*  \nSpecifies a symbolic constant indicating a GL capability.\n\n *`index`*  \nSpecifies the index of the capability.\n\n## Description\n\n`glIsEnabled` returns `GL_TRUE` if *`cap`* is an enabled capability and returns `GL_FALSE` otherwise. Boolean states that are indexed may be tested with `glIsEnabledi`. For `glIsEnabledi`, *`index`* specifies the index of the capability to test. *`index`* must be between zero and the count of indexed capabilities for *`cap`*. Initially all capabilities except `GL_DITHER` are disabled; `GL_DITHER` is initially enabled.\n\nThe following capabilities are accepted for *`cap`*:\n\n|  **Constant**                      |  **See**                                                                             |\n|:-----------------------------------|:-------------------------------------------------------------------------------------|\n| `GL_BLEND`                         | [glBlendFunc](glblendfunc.xhtml), [glLogicOp](gllogicop.xhtml)                       |\n| `GL_CLIP_DISTANCE`*i*              | [glEnable](glenable.xhtml)                                                           |\n| `GL_COLOR_LOGIC_OP`                | [glLogicOp](gllogicop.xhtml)                                                         |\n| `GL_CULL_FACE`                     | [glCullFace](glcullface.xhtml)                                                       |\n| `GL_DEPTH_CLAMP`                   | [glEnable](glenable.xhtml)                                                           |\n| `GL_DEBUG_OUTPUT`                  | [glEnable](glenable.xhtml)                                                           |\n| `GL_DEBUG_OUTPUT_SYNCHRONOUS`      | [glEnable](glenable.xhtml)                                                           |\n| `GL_DEPTH_TEST`                    | [glDepthFunc](gldepthfunc.xhtml), [glDepthRange](gldepthrange.xhtml)                 |\n| `GL_DITHER`                        | [glEnable](glenable.xhtml)                                                           |\n| `GL_FRAMEBUFFER_SRGB`              | [glEnable](glenable.xhtml)                                                           |\n| `GL_LINE_SMOOTH`                   | [glLineWidth](gllinewidth.xhtml)                                                     |\n| `GL_MULTISAMPLE`                   | [glSampleCoverage](glsamplecoverage.xhtml)                                           |\n| `GL_POLYGON_SMOOTH`                | [glPolygonMode](glpolygonmode.xhtml)                                                 |\n| `GL_POLYGON_OFFSET_FILL`           | [glPolygonOffset](glpolygonoffset.xhtml)                                             |\n| `GL_POLYGON_OFFSET_LINE`           | [glPolygonOffset](glpolygonoffset.xhtml)                                             |\n| `GL_POLYGON_OFFSET_POINT`          | [glPolygonOffset](glpolygonoffset.xhtml)                                             |\n| `GL_PROGRAM_POINT_SIZE`            | [glEnable](glenable.xhtml)                                                           |\n| `GL_PRIMITIVE_RESTART`             | [glEnable](glenable.xhtml), [glPrimitiveRestartIndex](glprimitiverestartindex.xhtml) |\n| `GL_PRIMITIVE_RESTART_FIXED_INDEX` | [glEnable](glenable.xhtml),                                                          |\n| `GL_SAMPLE_ALPHA_TO_COVERAGE`      | [glSampleCoverage](glsamplecoverage.xhtml)                                           |\n| `GL_SAMPLE_ALPHA_TO_ONE`           | [glSampleCoverage](glsamplecoverage.xhtml)                                           |\n| `GL_SAMPLE_COVERAGE`               | [glSampleCoverage](glsamplecoverage.xhtml)                                           |\n| `GL_SAMPLE_MASK`                   | [glEnable](glenable.xhtml)                                                           |\n| `GL_SCISSOR_TEST`                  | [glScissor](glscissor.xhtml)                                                         |\n| `GL_STENCIL_TEST`                  | [glStencilFunc](glstencilfunc.xhtml), [glStencilOp](glstencilop.xhtml)               |\n| `GL_TEXTURE_CUBE_MAP_SEAMLESS`     | [glEnable](glenable.xhtml)                                                           |\n\n## Notes\n\nIf an error is generated, `glIsEnabled` and `glIsEnabledi` return `GL_FALSE`.\n\n`GL_PRIMITIVE_RESTART_FIXED_INDEX` are available only if the GL version is 4.3 or greater.\n\n`GL_DEBUG_OUTPUT` and `GL_DEBUG_OUTPUT_SYNCHRONOUS` are available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`cap`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated by `glIsEnabledi` if *`index`* is outside the valid range for the indexed state *`cap`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsEnabled`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glIsEnabledi`              |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glEnable](glenable.xhtml), `glDisable`, [glGet](glget.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsEnabled.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsEnabled.xhtml)"
- name: glIsEnabledi
  id: glisenabled.xhtml#glIsEnabledi
  summary: Specifies a symbolic constant indicating a GL capability
  belongs_to: glIsEnabled
  description: "`GLboolean `**`glIsEnabledi`**`(` GLenum `cap`, GLuint `index``)`;\n\n## Parameters\n\n*`cap`*\n\nSpecifies a symbolic constant indicating a GL capability.\n\n*`index`*\n\nSpecifies the index of the capability.\n\n## Description\n\n`glIsEnabled` returns `GL_TRUE` if *`cap`* is an enabled capability and returns `GL_FALSE` otherwise. Boolean states that are indexed may be tested with `glIsEnabledi`. For `glIsEnabledi`, *`index`* specifies the index of the capability to test. *`index`* must be between zero and the count of indexed capabilities for *`cap`*. Initially all capabilities except `GL_DITHER` are disabled; `GL_DITHER` is initially enabled.\n\nThe following capabilities are accepted for *`cap`*:\n\n|  **Constant**                      |  **See**                                                                             |\n|:-----------------------------------|:-------------------------------------------------------------------------------------|\n| `GL_BLEND`                         | [glBlendFunc](glblendfunc.xhtml), [glLogicOp](gllogicop.xhtml)                       |\n| `GL_CLIP_DISTANCE` *i*             | [ glEnable ](glenable.xhtml)                                                         |\n| `GL_COLOR_LOGIC_OP`                | [ glLogicOp ](gllogicop.xhtml)                                                       |\n| `GL_CULL_FACE`                     | [ glCullFace ](glcullface.xhtml)                                                     |\n| `GL_DEPTH_CLAMP`                   | [ glEnable ](glenable.xhtml)                                                         |\n| `GL_DEBUG_OUTPUT`                  | [ glEnable ](glenable.xhtml)                                                         |\n| `GL_DEBUG_OUTPUT_SYNCHRONOUS`      | [ glEnable ](glenable.xhtml)                                                         |\n| `GL_DEPTH_TEST`                    | [glDepthFunc](gldepthfunc.xhtml), [glDepthRange](gldepthrange.xhtml)                 |\n| `GL_DITHER`                        | [ glEnable ](glenable.xhtml)                                                         |\n| `GL_FRAMEBUFFER_SRGB`              | [ glEnable ](glenable.xhtml)                                                         |\n| `GL_LINE_SMOOTH`                   | [ glLineWidth ](gllinewidth.xhtml)                                                   |\n| `GL_MULTISAMPLE`                   | [ glSampleCoverage ](glsamplecoverage.xhtml)                                         |\n| `GL_POLYGON_SMOOTH`                | [ glPolygonMode ](glpolygonmode.xhtml)                                               |\n| `GL_POLYGON_OFFSET_FILL`           | [ glPolygonOffset ](glpolygonoffset.xhtml)                                           |\n| `GL_POLYGON_OFFSET_LINE`           | [ glPolygonOffset ](glpolygonoffset.xhtml)                                           |\n| `GL_POLYGON_OFFSET_POINT`          | [ glPolygonOffset ](glpolygonoffset.xhtml)                                           |\n| `GL_PROGRAM_POINT_SIZE`            | [ glEnable ](glenable.xhtml)                                                         |\n| `GL_PRIMITIVE_RESTART`             | [glEnable](glenable.xhtml), [glPrimitiveRestartIndex](glprimitiverestartindex.xhtml) |\n| `GL_PRIMITIVE_RESTART_FIXED_INDEX` | [glEnable](glenable.xhtml),                                                          |\n| `GL_SAMPLE_ALPHA_TO_COVERAGE`      | [ glSampleCoverage ](glsamplecoverage.xhtml)                                         |\n| `GL_SAMPLE_ALPHA_TO_ONE`           | [ glSampleCoverage ](glsamplecoverage.xhtml)                                         |\n| `GL_SAMPLE_COVERAGE`               | [ glSampleCoverage ](glsamplecoverage.xhtml)                                         |\n| `GL_SAMPLE_MASK`                   | [ glEnable ](glenable.xhtml)                                                         |\n| `GL_SCISSOR_TEST`                  | [ glScissor ](glscissor.xhtml)                                                       |\n| `GL_STENCIL_TEST`                  | [glStencilFunc](glstencilfunc.xhtml), [glStencilOp](glstencilop.xhtml)               |\n| `GL_TEXTURE_CUBE_MAP_SEAMLESS`     | [ glEnable ](glenable.xhtml)                                                         |\n\n## Notes\n\nIf an error is generated, `glIsEnabled` and `glIsEnabledi` return `GL_FALSE`.\n\n`GL_PRIMITIVE_RESTART_FIXED_INDEX` are available only if the GL version is 4.3 or greater.\n\n`GL_DEBUG_OUTPUT` and `GL_DEBUG_OUTPUT_SYNCHRONOUS` are available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`cap`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated by `glIsEnabledi` if *`index`* is outside the valid range for the indexed state *`cap`*.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glIsEnabled`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glIsEnabledi`                |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glEnable](glenable.xhtml), `glDisable`, [glGet](glget.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsEnabled.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsEnabled.xhtml)"
- name: glIsFramebuffer
  id: glisframebuffer.xhtml
  summary: framebuffer Specifies a value that may be the name of a framebuffer object
  description: "## Name\n\nglIsFramebuffer — determine if a name corresponds to a framebuffer object\n\n## C Specification\n\n`GLboolean `**`glIsFramebuffer`**`(` GLuint `framebuffer``)`;\n\n## Parameters\n\n *`framebuffer`*  \nSpecifies a value that may be the name of a framebuffer object.\n\n## Description\n\n`glIsFramebuffer` returns `GL_TRUE` if *`framebuffer`* is currently the name of a framebuffer object. If *`framebuffer`* is zero, or if `framebuffer` is not the name of a framebuffer object, or if an error occurs, `glIsFramebuffer` returns `GL_FALSE`. If *`framebuffer`* is a name returned by [glGenFramebuffers](glgenframebuffers.xhtml), by that has not yet been bound through a call to [glBindFramebuffer](glbindframebuffer.xhtml), then the name is not a framebuffer object and `glIsFramebuffer` returns `GL_FALSE`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsFramebuffer`           |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml), [glDeleteFramebuffers](gldeleteframebuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsFramebuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsFramebuffer.xhtml)"
- name: glIsProgram
  id: glisprogram.xhtml
  summary: program Specifies a potential program object
  description: "## Name\n\nglIsProgram — Determines if a name corresponds to a program object\n\n## C Specification\n\n`GLboolean `**`glIsProgram`**`(` GLuint `program``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies a potential program object.\n\n## Description\n\n`glIsProgram` returns `GL_TRUE` if *`program`* is the name of a program object previously created with [glCreateProgram](glcreateprogram.xhtml) and not yet deleted with [glDeleteProgram](gldeleteprogram.xhtml). If *`program`* is zero or a non-zero value that is not the name of a program object, or if an error occurs, `glIsProgram` returns `GL_FALSE`.\n\n## Notes\n\nNo error is generated if *`program`* is not a valid program object name.\n\nA program object marked for deletion with [glDeleteProgram](gldeleteprogram.xhtml) but still in use as part of current rendering state is still considered a program object and `glIsProgram` will return `GL_TRUE`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with the argument `GL_CURRENT_PROGRAM`\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with arguments *`program`* and the index of an active attribute variable\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with arguments *`program`* and the index of an active uniform variable\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with argument *`program`*\n\n[glGetAttribLocation](glgetattriblocation.xhtml) with arguments *`program`* and the name of an attribute variable\n\n[glGetProgram](glgetprogram.xhtml) with arguments *`program`* and the parameter to be queried\n\n[glGetProgramInfoLog](glgetprograminfolog.xhtml) with argument *`program`*\n\n[glGetUniform](glgetuniform.xhtml) with arguments *`program`* and the location of a uniform variable\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with arguments *`program`* and the name of a uniform variable\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsProgram`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glAttachShader](glattachshader.xhtml), [glBindAttribLocation](glbindattriblocation.xhtml), [glCreateProgram](glcreateprogram.xhtml), [glDeleteProgram](gldeleteprogram.xhtml), [glDetachShader](gldetachshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glUniform](gluniform.xhtml), [glUseProgram](gluseprogram.xhtml), [glValidateProgram](glvalidateprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsProgram.xhtml)"
- name: glIsProgramPipeline
  id: glisprogrampipeline.xhtml
  summary: pipeline Specifies a value that may be the name of a program pipeline object
  description: "## Name\n\nglIsProgramPipeline — determine if a name corresponds to a program pipeline object\n\n## C Specification\n\n`GLboolean `**`glIsProgramPipeline`**`(` GLuint `pipeline``)`;\n\n## Parameters\n\n *`pipeline`*  \nSpecifies a value that may be the name of a program pipeline object.\n\n## Description\n\n`glIsProgramPipeline` returns `GL_TRUE` if *`pipeline`* is currently the name of a program pipeline object. If *`pipeline`* is zero, or if `pipeline` is not the name of a program pipeline object, or if an error occurs, `glIsProgramPipeline` returns `GL_FALSE`. If *`pipeline`* is a name returned by [glGenProgramPipelines](glgenprogrampipelines.xhtml), but that has not yet been bound through a call to [glBindProgramPipeline](glbindprogrampipeline.xhtml), then the name is not a program pipeline object and `glIsProgramPipeline` returns `GL_FALSE`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsProgramPipeline`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenProgramPipelines](glgenprogrampipelines.xhtml), [glBindProgramPipeline](glbindprogrampipeline.xhtml), [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsProgramPipeline.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsProgramPipeline.xhtml)"
- name: glIsQuery
  id: glisquery.xhtml
  summary: id Specifies a value that may be the name of a query object
  description: "## Name\n\nglIsQuery — determine if a name corresponds to a query object\n\n## C Specification\n\n`GLboolean `**`glIsQuery`**`(` GLuint `id``)`;\n\n## Parameters\n\n *`id`*  \nSpecifies a value that may be the name of a query object.\n\n## Description\n\n`glIsQuery` returns `GL_TRUE` if *`id`* is currently the name of a query object. If *`id`* is zero, or is a non-zero value that is not currently the name of a query object, or if an error occurs, `glIsQuery` returns `GL_FALSE`.\n\nA name returned by [glGenQueries](glgenqueries.xhtml), but not yet associated with a query object by calling [glBeginQuery](glbeginquery.xhtml), is not the name of a query object.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsQuery`                 |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBeginQuery](glbeginquery.xhtml), [glDeleteQueries](gldeletequeries.xhtml), `glEndQuery`, [glGenQueries](glgenqueries.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsQuery.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsQuery.xhtml)"
- name: glIsRenderbuffer
  id: glisrenderbuffer.xhtml
  summary: renderbuffer Specifies a value that may be the name of a renderbuffer object
  description: "## Name\n\nglIsRenderbuffer — determine if a name corresponds to a renderbuffer object\n\n## C Specification\n\n`GLboolean `**`glIsRenderbuffer`**`(` GLuint `renderbuffer``)`;\n\n## Parameters\n\n *`renderbuffer`*  \nSpecifies a value that may be the name of a renderbuffer object.\n\n## Description\n\n`glIsRenderbuffer` returns `GL_TRUE` if *`renderbuffer`* is currently the name of a renderbuffer object. If *`renderbuffer`* is zero, or if *`renderbuffer`* is not the name of a renderbuffer object, or if an error occurs, `glIsRenderbuffer` returns `GL_FALSE`. If *`renderbuffer`* is a name returned by [glGenRenderbuffers](glgenrenderbuffers.xhtml), by that has not yet been bound through a call to [glBindRenderbuffer](glbindrenderbuffer.xhtml) or [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), then the name is not a renderbuffer object and `glIsRenderbuffer` returns `GL_FALSE`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsRenderbuffer`          |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenRenderbuffers](glgenrenderbuffers.xhtml), [glBindRenderbuffer](glbindrenderbuffer.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glDeleteRenderbuffers](gldeleterenderbuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsRenderbuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsRenderbuffer.xhtml)"
- name: glIsSampler
  id: glissampler.xhtml
  summary: id Specifies a value that may be the name of a sampler object
  description: "## Name\n\nglIsSampler — determine if a name corresponds to a sampler object\n\n## C Specification\n\n`GLboolean `**`glIsSampler`**`(` GLuint `id``)`;\n\n## Parameters\n\n *`id`*  \nSpecifies a value that may be the name of a sampler object.\n\n## Description\n\n`glIsSampler` returns `GL_TRUE` if *`id`* is currently the name of a sampler object. If *`id`* is zero, or is a non-zero value that is not currently the name of a sampler object, or if an error occurs, `glIsSampler` returns `GL_FALSE`.\n\nA name returned by [glGenSamplers](glgensamplers.xhtml), is the name of a sampler object.\n\n## Notes\n\n`glIsSampler` is available only if the GL version is 3.3 or higher.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsSampler`               |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenSamplers](glgensamplers.xhtml), [glBindSampler](glbindsampler.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsSampler.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsSampler.xhtml)"
- name: glIsShader
  id: glisshader.xhtml
  summary: shader Specifies a potential shader object
  description: "## Name\n\nglIsShader — Determines if a name corresponds to a shader object\n\n## C Specification\n\n`GLboolean `**`glIsShader`**`(` GLuint `shader``)`;\n\n## Parameters\n\n *`shader`*  \nSpecifies a potential shader object.\n\n## Description\n\n`glIsShader` returns `GL_TRUE` if *`shader`* is the name of a shader object previously created with [glCreateShader](glcreateshader.xhtml) and not yet deleted with [glDeleteShader](gldeleteshader.xhtml). If *`shader`* is zero or a non-zero value that is not the name of a shader object, or if an error occurs, `glIsShader ` returns `GL_FALSE`.\n\n## Notes\n\nNo error is generated if *`shader`* is not a valid shader object name.\n\nA shader object marked for deletion with [glDeleteShader](gldeleteshader.xhtml) but still attached to a program object is still considered a shader object and `glIsShader` will return `GL_TRUE`.\n\n## Associated Gets\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with a valid program object\n\n[glGetShader](glgetshader.xhtml) with arguments *`shader`* and a parameter to be queried\n\n[glGetShaderInfoLog](glgetshaderinfolog.xhtml) with argument *`object`*\n\n[glGetShaderSource](glgetshadersource.xhtml) with argument *`object`*\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsShader`                |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glAttachShader](glattachshader.xhtml), [glCompileShader](glcompileshader.xhtml), [glCreateShader](glcreateshader.xhtml), [glDeleteShader](gldeleteshader.xhtml), [glDetachShader](gldetachshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glShaderSource](glshadersource.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsShader.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsShader.xhtml)"
- name: glIsSync
  id: glissync.xhtml
  summary: sync Specifies a value that may be the name of a sync object
  description: "## Name\n\nglIsSync — determine if a name corresponds to a sync object\n\n## C Specification\n\n`GLboolean `**`glIsSync`**`(` GLsync `sync``)`;\n\n## Parameters\n\n *`sync`*  \nSpecifies a value that may be the name of a sync object.\n\n## Description\n\n`glIsSync` returns `GL_TRUE` if *`sync`* is currently the name of a sync object. If *`sync`* is not the name of a sync object, or if an error occurs, `glIsSync` returns `GL_FALSE`. Note that zero is not the name of a sync object.\n\n## Notes\n\n`glIsSync` is available only if the GL version is 3.2 or greater.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsSync`                  |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glFenceSync](glfencesync.xhtml), [glWaitSync](glwaitsync.xhtml), [glClientWaitSync](glclientwaitsync.xhtml), [glDeleteSync](gldeletesync.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsSync.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsSync.xhtml)"
- name: glIsTexture
  id: glistexture.xhtml
  summary: texture Specifies a value that may be the name of a texture
  description: "## Name\n\nglIsTexture — determine if a name corresponds to a texture\n\n## C Specification\n\n`GLboolean `**`glIsTexture`**`(` GLuint `texture``)`;\n\n## Parameters\n\n *`texture`*  \nSpecifies a value that may be the name of a texture.\n\n## Description\n\n`glIsTexture` returns `GL_TRUE` if *`texture`* is currently the name of a texture. If *`texture`* is zero, or is a non-zero value that is not currently the name of a texture, or if an error occurs, `glIsTexture` returns `GL_FALSE`.\n\nA name returned by [glGenTextures](glgentextures.xhtml), but not yet associated with a texture by calling [glBindTexture](glbindtexture.xhtml), is not the name of a texture.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsTexture`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindTexture](glbindtexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glDeleteTextures](gldeletetextures.xhtml), [glGenTextures](glgentextures.xhtml), [glGet](glget.xhtml), [glGetTexParameter](glgettexparameter.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsTexture.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsTexture.xhtml)"
- name: glIsTransformFeedback
  id: glistransformfeedback.xhtml
  summary: id Specifies a value that may be the name of a transform feedback object
  description: "## Name\n\nglIsTransformFeedback — determine if a name corresponds to a transform feedback object\n\n## C Specification\n\n`GLboolean `**`glIsTransformFeedback`**`(` GLuint `id``)`;\n\n## Parameters\n\n *`id`*  \nSpecifies a value that may be the name of a transform feedback object.\n\n## Description\n\n`glIsTransformFeedback` returns `GL_TRUE` if *`id`* is currently the name of a transform feedback object. If *`id`* is zero, or if `id` is not the name of a transform feedback object, or if an error occurs, `glIsTransformFeedback` returns `GL_FALSE`. If *`id`* is a name returned by [glGenTransformFeedbacks](glgentransformfeedbacks.xhtml), but that has not yet been bound through a call to [glBindTransformFeedback](glbindtransformfeedback.xhtml), then the name is not a transform feedback object and `glIsTransformFeedback` returns `GL_FALSE`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsTransformFeedback`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenTransformFeedbacks](glgentransformfeedbacks.xhtml), [glBindTransformFeedback](glbindtransformfeedback.xhtml), [glDeleteTransformFeedbacks](gldeletetransformfeedbacks.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsTransformFeedback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsTransformFeedback.xhtml)"
- name: glIsVertexArray
  id: glisvertexarray.xhtml
  summary: array Specifies a value that may be the name of a vertex array object
  description: "## Name\n\nglIsVertexArray — determine if a name corresponds to a vertex array object\n\n## C Specification\n\n`GLboolean `**`glIsVertexArray`**`(` GLuint `array``)`;\n\n## Parameters\n\n *`array`*  \nSpecifies a value that may be the name of a vertex array object.\n\n## Description\n\n`glIsVertexArray` returns `GL_TRUE` if *`array`* is currently the name of a vertex array object. If *`array`* is zero, or if *`array`* is not the name of a vertex array object, or if an error occurs, `glIsVertexArray` returns `GL_FALSE`. If *`array`* is a name returned by [glGenVertexArrays](glgenvertexarrays.xhtml), by that has not yet been bound through a call to [glBindVertexArray](glbindvertexarray.xhtml), then the name is not a vertex array object and `glIsVertexArray` returns `GL_FALSE`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glIsVertexArray`           |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenVertexArrays](glgenvertexarrays.xhtml), [glBindVertexArray](glbindvertexarray.xhtml), [glDeleteVertexArrays](gldeletevertexarrays.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glIsVertexArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glIsVertexArray.xhtml)"
- name: glLineWidth
  id: gllinewidth.xhtml
  summary: width Specifies the width of rasterized lines
  description: "## Name\n\nglLineWidth — specify the width of rasterized lines\n\n## C Specification\n\n`void `**`glLineWidth`**`(` GLfloat `width``)`;\n\n## Parameters\n\n *`width`*  \nSpecifies the width of rasterized lines. The initial value is 1.\n\n## Description\n\n`glLineWidth` specifies the rasterized width of both aliased and antialiased lines. Using a line width other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and disable line antialiasing, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_LINE_SMOOTH`. Line antialiasing is initially disabled.\n\nIf line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer. (If the rounding results in the value 0, it is as if the line width were 1.) If ∣*Δ**x*∣ \\>  = ∣*Δ**y*∣, *i* pixels are filled in each column that is rasterized, where *i* is the rounded value of *`width`*. Otherwise, *i* pixels are filled in each row that is rasterized.\n\nIf antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization step.\n\nNot all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported width is used. Only width 1 is guaranteed to be supported; others depend on the implementation. Likewise, there is a range for aliased line widths as well. To query the range of supported widths and the size difference between supported widths within the range, call [glGet](glget.xhtml) with arguments `GL_ALIASED_LINE_WIDTH_RANGE`, `GL_SMOOTH_LINE_WIDTH_RANGE`, and `GL_SMOOTH_LINE_WIDTH_GRANULARITY`.\n\n## Notes\n\nThe line width specified by `glLineWidth` is always returned when `GL_LINE_WIDTH` is queried. Clamping and rounding for aliased and antialiased lines have no effect on the specified value.\n\nNonantialiased line width may be clamped to an implementation-dependent maximum. Call [glGet](glget.xhtml) with `GL_ALIASED_LINE_WIDTH_RANGE` to determine the maximum width.\n\nIn OpenGL 1.2, the tokens `GL_LINE_WIDTH_RANGE` and `GL_LINE_WIDTH_GRANULARITY` were replaced by `GL_ALIASED_LINE_WIDTH_RANGE`, `GL_SMOOTH_LINE_WIDTH_RANGE`, and `GL_SMOOTH_LINE_WIDTH_GRANULARITY`. The old names are retained for backward compatibility, but should not be used in new code.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`width`* is less than or equal to 0.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_LINE_WIDTH`\n\n[glGet](glget.xhtml) with argument `GL_ALIASED_LINE_WIDTH_RANGE`\n\n[glGet](glget.xhtml) with argument `GL_SMOOTH_LINE_WIDTH_RANGE`\n\n[glGet](glget.xhtml) with argument `GL_SMOOTH_LINE_WIDTH_GRANULARITY`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_LINE_SMOOTH`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glLineWidth`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glEnable](glenable.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glLineWidth.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glLineWidth.xhtml)"
- name: glLinkProgram
  id: gllinkprogram.xhtml
  summary: program Specifies the handle of the program object to be linked
  description: "## Name\n\nglLinkProgram — Links a program object\n\n## C Specification\n\n`void `**`glLinkProgram`**`(` GLuint `program``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the handle of the program object to be linked.\n\n## Description\n\n`glLinkProgram` links the program object specified by *`program`*. If any shader objects of type `GL_VERTEX_SHADER` are attached to *`program`*, they will be used to create an executable that will run on the programmable vertex processor. If any shader objects of type `GL_GEOMETRY_SHADER` are attached to *`program`*, they will be used to create an executable that will run on the programmable geometry processor. If any shader objects of type `GL_FRAGMENT_SHADER` are attached to *`program`*, they will be used to create an executable that will run on the programmable fragment processor.\n\nThe status of the link operation will be stored as part of the program object's state. This value will be set to `GL_TRUE` if the program object was linked without errors and is ready for use, and `GL_FALSE` otherwise. It can be queried by calling [glGetProgram](glgetprogram.xhtml) with arguments *`program`* and `GL_LINK_STATUS`.\n\nAs a result of a successful link operation, all active user-defined uniform variables belonging to *`program`* will be initialized to 0, and each of the program object's active uniform variables will be assigned a location that can be queried by calling [glGetUniformLocation](glgetuniformlocation.xhtml). Also, any active user-defined attribute variables that have not been bound to a generic vertex attribute index will be bound to one at this time.\n\nLinking of a program object can fail for a number of reasons as specified in the *OpenGL Shading Language Specification*. The following lists some of the conditions that will cause a link error.\n\n- The number of active attribute variables supported by the implementation has been exceeded.\n\n- The storage limit for uniform variables has been exceeded.\n\n- The number of active uniform variables supported by the implementation has been exceeded.\n\n- The `main` function is missing for the vertex, geometry or fragment shader.\n\n- A varying variable actually used in the fragment shader is not declared in the same way (or is not declared at all) in the vertex shader, or geometry shader if present.\n\n- A reference to a function or variable name is unresolved.\n\n- A shared global is declared with two different types or two different initial values.\n\n- One or more of the attached shader objects has not been successfully compiled.\n\n- Binding a generic attribute matrix caused some rows of the matrix to fall outside the allowed maximum of `GL_MAX_VERTEX_ATTRIBS`.\n\n- Not enough contiguous vertex attribute slots could be found to bind attribute matrices.\n\n- The program object contains objects to form a fragment shader but does not contain objects to form a vertex shader.\n\n- The program object contains objects to form a geometry shader but does not contain objects to form a vertex shader.\n\n- The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is not specified in any compiled geometry shader object.\n\n- The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is specified differently in multiple geometry shader objects.\n\n- The number of active outputs in the fragment shader is greater than the value of `GL_MAX_DRAW_BUFFERS`.\n\n- The program has an active output assigned to a location greater than or equal to the value of `GL_MAX_DUAL_SOURCE_DRAW_BUFFERS` and has an active output assigned an index greater than or equal to one.\n\n- More than one varying out variable is bound to the same number and index.\n\n- The explicit binding assigments do not leave enough space for the linker to automatically assign a location for a varying out array, which requires multiple contiguous locations.\n\n- The *`count`* specified by [glTransformFeedbackVaryings](gltransformfeedbackvaryings.xhtml) is non-zero, but the program object has no vertex or geometry shader.\n\n- Any variable name specified to [glTransformFeedbackVaryings](gltransformfeedbackvaryings.xhtml) in the *`varyings`* array is not declared as an output in the vertex shader (or the geometry shader, if active).\n\n- Any two entries in the *`varyings`* array given [glTransformFeedbackVaryings](gltransformfeedbackvaryings.xhtml) specify the same varying variable.\n\n- The total number of components to capture in any transform feedback varying variable is greater than the constant `GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS` and the buffer mode is `GL_SEPARATE_ATTRIBS`.\n\nWhen a program object has been successfully linked, the program object can be made part of current state by calling [glUseProgram](gluseprogram.xhtml). Whether or not the link operation was successful, the program object's information log will be overwritten. The information log can be retrieved by calling [glGetProgramInfoLog](glgetprograminfolog.xhtml).\n\n`glLinkProgram` will also install the generated executables as part of the current rendering state if the link operation was successful and the specified program object is already currently in use as a result of a previous call to [glUseProgram](gluseprogram.xhtml). If the program object currently in use is relinked unsuccessfully, its link status will be set to `GL_FALSE` , but the executables and associated state will remain part of the current state until a subsequent call to `glUseProgram` removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked.\n\nIf *`program`* contains shader objects of type `GL_VERTEX_SHADER`, and optionally of type `GL_GEOMETRY_SHADER`, but does not contain shader objects of type `GL_FRAGMENT_SHADER`, the vertex shader executable will be installed on the programmable vertex processor, the geometry shader executable, if present, will be installed on the programmable geometry processor, but no executable will be installed on the fragment processor. The results of rasterizing primitives with such a program will be undefined.\n\nThe program object's information log is updated and the program is generated at the time of the link operation. After the link operation, applications are free to modify attached shader objects, compile attached shader objects, detach shader objects, delete shader objects, and attach additional shader objects. None of these operations affects the information log or the program that is part of the program object.\n\n## Notes\n\nIf the link operation is unsuccessful, any information about a previous link operation on *`program`* is lost (i.e., a failed link does not restore the old state of *`program`* ). Certain information can still be retrieved from *`program`* even after an unsuccessful link operation. See for instance [glGetActiveAttrib](glgetactiveattrib.xhtml) and [glGetActiveUniform](glgetactiveuniform.xhtml).\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is the currently active program object and transform feedback mode is active.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with the argument `GL_CURRENT_PROGRAM`\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with argument *`program`* and the index of an active attribute variable\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with argument *`program`* and the index of an active uniform variable\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with argument *`program`*\n\n[glGetAttribLocation](glgetattriblocation.xhtml) with argument *`program`* and an attribute variable name\n\n[glGetProgram](glgetprogram.xhtml) with arguments *`program`* and `GL_LINK_STATUS`\n\n[glGetProgramInfoLog](glgetprograminfolog.xhtml) with argument *`program`*\n\n[glGetUniform](glgetuniform.xhtml) with argument *`program`* and a uniform variable location\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with argument *`program`* and a uniform variable name\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glLinkProgram`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glAttachShader](glattachshader.xhtml), [glBindAttribLocation](glbindattriblocation.xhtml), [glCompileShader](glcompileshader.xhtml), [glCreateProgram](glcreateprogram.xhtml), [glDeleteProgram](gldeleteprogram.xhtml), [glDetachShader](gldetachshader.xhtml), [glUniform](gluniform.xhtml), [glUseProgram](gluseprogram.xhtml), [glValidateProgram](glvalidateprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glLinkProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glLinkProgram.xhtml)"
- name: glLogicOp
  id: gllogicop.xhtml
  summary: opcode Specifies a symbolic constant that selects a logical operation
  description: "## Name\n\nglLogicOp — specify a logical pixel operation for rendering\n\n## C Specification\n\n`void `**`glLogicOp`**`(` GLenum `opcode``)`;\n\n## Parameters\n\n *`opcode`*  \nSpecifies a symbolic constant that selects a logical operation. The following symbols are accepted: `GL_CLEAR`, `GL_SET`, `GL_COPY`, `GL_COPY_INVERTED`, `GL_NOOP`, `GL_INVERT`, `GL_AND`, `GL_NAND`, `GL_OR`, `GL_NOR`, `GL_XOR`, `GL_EQUIV`, `GL_AND_REVERSE`, `GL_AND_INVERTED`, `GL_OR_REVERSE`, and `GL_OR_INVERTED`. The initial value is `GL_COPY`.\n\n## Description\n\n`glLogicOp` specifies a logical operation that, when enabled, is applied between the incoming RGBA color and the RGBA color at the corresponding location in the frame buffer. To enable or disable the logical operation, call [glEnable](glenable.xhtml) and `glDisable` using the symbolic constant `GL_COLOR_LOGIC_OP`. The initial value is disabled.\n\n|  **Opcode**        |  **Resulting Operation**  |\n|:-------------------|:-------------------------:|\n| `GL_CLEAR`         |             0             |\n| `GL_SET`           |             1             |\n| `GL_COPY`          |             s             |\n| `GL_COPY_INVERTED` |            ~s             |\n| `GL_NOOP`          |             d             |\n| `GL_INVERT`        |            ~d             |\n| `GL_AND`           |           s & d           |\n| `GL_NAND`          |         ~(s & d)          |\n| `GL_OR`            |          s \\| d           |\n| `GL_NOR`           |         ~(s \\| d)         |\n| `GL_XOR`           |           s ^ d           |\n| `GL_EQUIV`         |         ~(s ^ d)          |\n| `GL_AND_REVERSE`   |          s & ~d           |\n| `GL_AND_INVERTED`  |          ~s & d           |\n| `GL_OR_REVERSE`    |          s \\| ~d          |\n| `GL_OR_INVERTED`   |          ~s \\| d          |\n\n*`opcode`* is a symbolic constant chosen from the list above. In the explanation of the logical operations, *s* represents the incoming color and *d* represents the color in the frame buffer. Standard C-language operators are used. As these bitwise operators suggest, the logical operation is applied independently to each bit pair of the source and destination colors.\n\n## Notes\n\nWhen more than one RGBA color buffer is enabled for drawing, logical operations are performed separately for each enabled buffer, using for the destination value the contents of that buffer (see [glDrawBuffer](gldrawbuffer.xhtml)).\n\nLogic operations have no effect on floating point draw buffers. However, if `GL_COLOR_LOGIC_OP` is enabled, blending is still disabled in this case.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`opcode`* is not an accepted value.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_LOGIC_OP_MODE`.\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_COLOR_LOGIC_OP`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glLogicOp`                 |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBlendFunc](glblendfunc.xhtml), [glDrawBuffer](gldrawbuffer.xhtml), [glEnable](glenable.xhtml), [glStencilOp](glstencilop.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glLogicOp.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glLogicOp.xhtml)"
- name: glMapBuffer
  id: glmapbuffer.xhtml
  summary: buffer Specifies the name of the buffer object for glMapNamedBuffer
  description: "## Name\n\nglMapBuffer, glMapNamedBuffer — map all of a buffer object's data store into the client's address space\n\n## C Specification\n\n`void *`**`glMapBuffer`**`(` GLenum `target`, GLenum `access``)`;\n\n`void *`**`glMapNamedBuffer`**`(` GLuint `buffer`, GLenum `access``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glMapBuffer`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glMapNamedBuffer`.\n\n *`access`*  \nSpecifies the access policy for `glMapBuffer` and `glMapNamedBuffer`, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE`.\n\n## Description\n\n`glMapBuffer` and `glMapNamedBuffer` map the entire data store of a specified buffer object into the client's address space. The data can then be directly read and/or written relative to the returned pointer, depending on the specified *`access`* policy.\n\nA pointer to the beginning of the mapped range is returned once all pending operations on that buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the value of *`access`*:\n\n- `GL_READ_ONLY` indicates that the returned pointer may be used to read buffer object data.\n\n- `GL_WRITE_ONLY` indicates that the returned pointer may be used to modify buffer object data.\n\n- `GL_READ_WRITE` indicates that the returned pointer may be used to read and to modify buffer object data.\n\nIf an error is generated, a `NULL` pointer is returned.\n\nIf no error occurs, the returned pointer will reflect an allocation aligned to the value of `GL_MIN_MAP_BUFFER_ALIGNMENT` basic machine units.\n\nThe returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons.\n\nNo GL error is generated if the returned pointer is accessed in a way inconsistent with *`access`* (e.g. used to read from a mapping made with *`access`* `GL_WRITE_ONLY` or write to a mapping made with *`access`* `GL_READ_ONLY`), but the result is undefined and system errors (possibly including program termination) may occur.\n\nMappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of `GL_BUFFER_USAGE` for the buffer object and of *`access`*. Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.\n\n## Notes\n\nAlignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glMapBuffer` if *`target`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glMapBuffer` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glMapNamedBuffer` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_ENUM` is generated if *`access`* is not `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE`.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific reasons, such as the absence of sufficient remaining virtual memory.\n\n`GL_INVALID_OPERATION` is generated if the buffer object is in a mapped state.\n\n## Associated Gets\n\n[glGetBufferPointerv](glgetbufferpointerv.xhtml) with argument `GL_BUFFER_MAP_POINTER`\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_MAPPED`, `GL_BUFFER_ACCESS`, or `GL_BUFFER_USAGE`\n\n[glGet](glget.xhtml) with *`pname`* `GL_MIN_MAP_BUFFER_ALIGNMENT`. The value must be a power of two that is at least 64.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glMapBuffer`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glMapNamedBuffer`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glBufferData](glbufferdata.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glMapBufferRange](glmapbufferrange.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMapBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMapBuffer.xhtml)"
- name: glMapBufferRange
  id: glmapbufferrange.xhtml
  summary: buffer Specifies the name of the buffer object for glMapNamedBufferRange
  description: "## Name\n\nglMapBufferRange, glMapNamedBufferRange — map all or part of a buffer object's data store into the client's address space\n\n## C Specification\n\n`void *`**`glMapBufferRange`**`(` GLenum `target`, GLintptr `offset`, GLsizeiptr `length`, GLbitfield `access``)`;\n\n`void *`**`glMapNamedBufferRange`**`(` GLuint `buffer`, GLintptr `offset`, GLsizeiptr `length`, GLbitfield `access``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glMapBufferRange`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glMapNamedBufferRange`.\n\n *`offset`*  \nSpecifies the starting offset within the buffer of the range to be mapped.\n\n *`length`*  \nSpecifies the length of the range to be mapped.\n\n *`access`*  \nSpecifies a combination of access flags indicating the desired access to the mapped range.\n\n## Description\n\n`glMapBufferRange` and `glMapNamedBufferRange` map all or part of the data store of a specified buffer object into the client's address space. *`offset`* and *`length`* indicate the range of data in the buffer object that is to be mapped, in terms of basic machine units. *`access`* is a bitfield containing flags which describe the requested mapping. These flags are described below.\n\nA pointer to the beginning of the mapped range is returned once all pending operations on the buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the following flag bits set in *`access`*:\n\n- `GL_MAP_READ_BIT` indicates that the returned pointer may be used to read buffer object data. No GL error is generated if the pointer is used to query a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.\n\n- `GL_MAP_WRITE_BIT` indicates that the returned pointer may be used to modify buffer object data. No GL error is generated if the pointer is used to modify a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.\n\n- `GL_MAP_PERSISTENT_BIT` indicates that the mapping is to be made in a persistent fashion and that the client intends to hold and use the returned pointer during subsequent GL operation. It is not an error to call drawing commands (render) while buffers are mapped using this flag. It is an error to specify this flag if the buffer's data store was not allocated through a call to the [glBufferStorage](glbufferstorage.xhtml) command in which the `GL_MAP_PERSISTENT_BIT` was also set.\n\n- `GL_MAP_COHERENT_BIT` indicates that a persistent mapping is also to be coherent. Coherent maps guarantee that the effect of writes to a buffer's data store by either the client or server will eventually become visible to the other without further intervention from the application. In the absence of this bit, persistent mappings are not coherent and modified ranges of the buffer store must be explicitly communicated to the GL, either by unmapping the buffer, or through a call to [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml) or [glMemoryBarrier](glmemorybarrier.xhtml).\n\nThe following *optional* flag bits in *`access`* may be used to modify the mapping:\n\n- `GL_MAP_INVALIDATE_RANGE_BIT` indicates that the previous contents of the specified range may be discarded. Data within this range are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with `GL_MAP_READ_BIT`.\n\n- `GL_MAP_INVALIDATE_BUFFER_BIT` indicates that the previous contents of the entire buffer may be discarded. Data within the entire buffer are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with `GL_MAP_READ_BIT`.\n\n- `GL_MAP_FLUSH_EXPLICIT_BIT` indicates that one or more discrete subranges of the mapping may be modified. When this flag is set, modifications to each subrange must be explicitly flushed by calling [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml). No GL error is set if a subrange of the mapping is modified and not flushed, but data within the corresponding subrange of the buffer are undefined. This flag may only be used in conjunction with `GL_MAP_WRITE_BIT`. When this option is selected, flushing is strictly limited to regions that are explicitly indicated with calls to [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml) prior to unmap; if this option is not selected [glUnmapBuffer](glunmapbuffer.xhtml) will automatically flush the entire mapped range when called.\n\n- `GL_MAP_UNSYNCHRONIZED_BIT` indicates that the GL should not attempt to synchronize pending operations on the buffer prior to returning from `glMapBufferRange` or `glMapNamedBufferRange`. No GL error is generated if pending operations which source or modify the buffer overlap the mapped region, but the result of such previous and any subsequent operations is undefined.\n\nIf an error occurs, a `NULL` pointer is returned.\n\nIf no error occurs, the returned pointer will reflect an allocation aligned to the value of `GL_MIN_MAP_BUFFER_ALIGNMENT` basic machine units. Subtracting *`offset`* from this returned pointer will always produce a multiple of the value of `GL_MIN_MAP_BUFFER_ALIGNMENT`.\n\nThe returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons.\n\nMappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of `GL_BUFFER_USAGE` for the buffer object and of *`access`*. Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.\n\n## Notes\n\nAlignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are accepted only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\nThe `GL_MAP_PERSISTENT_BIT` and `GL_MAP_COHERENT_BIT` flags are available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glMapBufferRange` if *`target`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glMapBufferRange` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glMapNamedBufferRange` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`length`* is negative, if $offset + length$ is greater than the value of `GL_BUFFER_SIZE` for the buffer object, or if *`access`* has any bits set other than those defined above.\n\n`GL_INVALID_OPERATION` is generated for any of the following conditions:\n\n- *`length`* is zero.\n\n- The buffer object is already in a mapped state.\n\n- Neither `GL_MAP_READ_BIT` nor `GL_MAP_WRITE_BIT` is set.\n\n- `GL_MAP_READ_BIT` is set and any of `GL_MAP_INVALIDATE_RANGE_BIT`, `GL_MAP_INVALIDATE_BUFFER_BIT` or `GL_MAP_UNSYNCHRONIZED_BIT` is set.\n\n- `GL_MAP_FLUSH_EXPLICIT_BIT` is set and `GL_MAP_WRITE_BIT` is not set.\n\n- Any of `GL_MAP_READ_BIT`, `GL_MAP_WRITE_BIT`, `GL_MAP_PERSISTENT_BIT`, or `GL_MAP_COHERENT_BIT` are set, but the same bit is not included in the buffer's storage flags.\n\nNo error is generated if memory outside the mapped range is modified or queried, but the result is undefined and system errors (possibly including program termination) may occur.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with *`pname`* `GL_MIN_MAP_BUFFER_ALIGNMENT`. The value must be a power of two that is at least 64.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glMapBufferRange`          |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glMapNamedBufferRange`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml), [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBufferStorage](glbufferstorage.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMapBufferRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMapBufferRange.xhtml)"
- name: glMapNamedBuffer
  id: glmapbuffer.xhtml#glMapNamedBuffer
  summary: Specifies the name of the buffer object for glMapNamedBuffer
  belongs_to: glMapBuffer
  description: "`void *`**`glMapNamedBuffer`**`(` GLuint `buffer`, GLenum `access``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glMapBuffer`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glMapNamedBuffer`.\n\n*`access`*\n\nSpecifies the access policy for `glMapBuffer` and `glMapNamedBuffer`, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE`.\n\n## Description\n\n`glMapBuffer` and `glMapNamedBuffer` map the entire data store of a specified buffer object into the client's address space. The data can then be directly read and/or written relative to the returned pointer, depending on the specified *`access`* policy.\n\nA pointer to the beginning of the mapped range is returned once all pending operations on that buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the value of *`access`*:\n\n- `GL_READ_ONLY` indicates that the returned pointer may be used to read buffer object data.\n\n- `GL_WRITE_ONLY` indicates that the returned pointer may be used to modify buffer object data.\n\n- `GL_READ_WRITE` indicates that the returned pointer may be used to read and to modify buffer object data.\n\nIf an error is generated, a `NULL` pointer is returned.\n\nIf no error occurs, the returned pointer will reflect an allocation aligned to the value of `GL_MIN_MAP_BUFFER_ALIGNMENT` basic machine units.\n\nThe returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons.\n\nNo GL error is generated if the returned pointer is accessed in a way inconsistent with *`access`* (e.g. used to read from a mapping made with *`access`* `GL_WRITE_ONLY` or write to a mapping made with *`access`* `GL_READ_ONLY`), but the result is undefined and system errors (possibly including program termination) may occur.\n\nMappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of `GL_BUFFER_USAGE` for the buffer object and of *`access`*. Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.\n\n## Notes\n\nAlignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glMapBuffer` if *`target`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glMapBuffer` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glMapNamedBuffer` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_ENUM` is generated if *`access`* is not `GL_READ_ONLY`, `GL_WRITE_ONLY`, or `GL_READ_WRITE`.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific reasons, such as the absence of sufficient remaining virtual memory.\n\n`GL_INVALID_OPERATION` is generated if the buffer object is in a mapped state.\n\n## Associated Gets\n\n[glGetBufferPointerv](glgetbufferpointerv.xhtml) with argument `GL_BUFFER_MAP_POINTER`\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_MAPPED`, `GL_BUFFER_ACCESS`, or `GL_BUFFER_USAGE`\n\n[glGet](glget.xhtml) with *`pname`* `GL_MIN_MAP_BUFFER_ALIGNMENT`. The value must be a power of two that is at least 64.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glMapBuffer`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glMapNamedBuffer`            |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glBufferData](glbufferdata.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glMapBufferRange](glmapbufferrange.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMapBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMapBuffer.xhtml)"
- name: glMapNamedBufferRange
  id: glmapbufferrange.xhtml#glMapNamedBufferRange
  summary: Specifies the name of the buffer object for glMapNamedBufferRange
  belongs_to: glMapBufferRange
  description: "`void *`**`glMapNamedBufferRange`**`(` GLuint `buffer`, GLintptr `offset`, GLsizeiptr `length`, GLbitfield `access``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glMapBufferRange`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glMapNamedBufferRange`.\n\n*`offset`*\n\nSpecifies the starting offset within the buffer of the range to be mapped.\n\n*`length`*\n\nSpecifies the length of the range to be mapped.\n\n*`access`*\n\nSpecifies a combination of access flags indicating the desired access to the mapped range.\n\n## Description\n\n`glMapBufferRange` and `glMapNamedBufferRange` map all or part of the data store of a specified buffer object into the client's address space. *`offset`* and *`length`* indicate the range of data in the buffer object that is to be mapped, in terms of basic machine units. *`access`* is a bitfield containing flags which describe the requested mapping. These flags are described below.\n\nA pointer to the beginning of the mapped range is returned once all pending operations on the buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the following flag bits set in *`access`*:\n\n- `GL_MAP_READ_BIT` indicates that the returned pointer may be used to read buffer object data. No GL error is generated if the pointer is used to query a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.\n\n- `GL_MAP_WRITE_BIT` indicates that the returned pointer may be used to modify buffer object data. No GL error is generated if the pointer is used to modify a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.\n\n- `GL_MAP_PERSISTENT_BIT` indicates that the mapping is to be made in a persistent fashion and that the client intends to hold and use the returned pointer during subsequent GL operation. It is not an error to call drawing commands (render) while buffers are mapped using this flag. It is an error to specify this flag if the buffer's data store was not allocated through a call to the [glBufferStorage](glbufferstorage.xhtml) command in which the `GL_MAP_PERSISTENT_BIT` was also set.\n\n- `GL_MAP_COHERENT_BIT` indicates that a persistent mapping is also to be coherent. Coherent maps guarantee that the effect of writes to a buffer's data store by either the client or server will eventually become visible to the other without further intervention from the application. In the absence of this bit, persistent mappings are not coherent and modified ranges of the buffer store must be explicitly communicated to the GL, either by unmapping the buffer, or through a call to [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml) or [glMemoryBarrier](glmemorybarrier.xhtml).\n\nThe following *optional* flag bits in *`access`* may be used to modify the mapping:\n\n- `GL_MAP_INVALIDATE_RANGE_BIT` indicates that the previous contents of the specified range may be discarded. Data within this range are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with `GL_MAP_READ_BIT`.\n\n- `GL_MAP_INVALIDATE_BUFFER_BIT` indicates that the previous contents of the entire buffer may be discarded. Data within the entire buffer are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with `GL_MAP_READ_BIT`.\n\n- `GL_MAP_FLUSH_EXPLICIT_BIT` indicates that one or more discrete subranges of the mapping may be modified. When this flag is set, modifications to each subrange must be explicitly flushed by calling [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml). No GL error is set if a subrange of the mapping is modified and not flushed, but data within the corresponding subrange of the buffer are undefined. This flag may only be used in conjunction with `GL_MAP_WRITE_BIT`. When this option is selected, flushing is strictly limited to regions that are explicitly indicated with calls to [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml) prior to unmap; if this option is not selected [glUnmapBuffer](glunmapbuffer.xhtml) will automatically flush the entire mapped range when called.\n\n- `GL_MAP_UNSYNCHRONIZED_BIT` indicates that the GL should not attempt to synchronize pending operations on the buffer prior to returning from `glMapBufferRange` or `glMapNamedBufferRange`. No GL error is generated if pending operations which source or modify the buffer overlap the mapped region, but the result of such previous and any subsequent operations is undefined.\n\nIf an error occurs, a `NULL` pointer is returned.\n\nIf no error occurs, the returned pointer will reflect an allocation aligned to the value of `GL_MIN_MAP_BUFFER_ALIGNMENT` basic machine units. Subtracting *`offset`* from this returned pointer will always produce a multiple of the value of `GL_MIN_MAP_BUFFER_ALIGNMENT`.\n\nThe returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons.\n\nMappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of `GL_BUFFER_USAGE` for the buffer object and of *`access`*. Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.\n\n## Notes\n\nAlignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are accepted only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\nThe `GL_MAP_PERSISTENT_BIT` and `GL_MAP_COHERENT_BIT` flags are available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glMapBufferRange` if *`target`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glMapBufferRange` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glMapNamedBufferRange` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`length`* is negative, if $offset + length$ is greater than the value of `GL_BUFFER_SIZE` for the buffer object, or if *`access`* has any bits set other than those defined above.\n\n`GL_INVALID_OPERATION` is generated for any of the following conditions:\n\n- *`length`* is zero.\n\n- The buffer object is already in a mapped state.\n\n- Neither `GL_MAP_READ_BIT` nor `GL_MAP_WRITE_BIT` is set.\n\n- `GL_MAP_READ_BIT` is set and any of `GL_MAP_INVALIDATE_RANGE_BIT`, `GL_MAP_INVALIDATE_BUFFER_BIT` or `GL_MAP_UNSYNCHRONIZED_BIT` is set.\n\n- `GL_MAP_FLUSH_EXPLICIT_BIT` is set and `GL_MAP_WRITE_BIT` is not set.\n\n- Any of `GL_MAP_READ_BIT`, `GL_MAP_WRITE_BIT`, `GL_MAP_PERSISTENT_BIT`, or `GL_MAP_COHERENT_BIT` are set, but the same bit is not included in the buffer's storage flags.\n\nNo error is generated if memory outside the mapped range is modified or queried, but the result is undefined and system errors (possibly including program termination) may occur.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with *`pname`* `GL_MIN_MAP_BUFFER_ALIGNMENT`. The value must be a power of two that is at least 64.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glMapBufferRange`            |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glMapNamedBufferRange`       |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml), [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBufferStorage](glbufferstorage.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMapBufferRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMapBufferRange.xhtml)"
- name: glMemoryBarrier
  id: glmemorybarrier.xhtml
  summary: barriers Specifies the barriers to insert
  description: "## Name\n\nglMemoryBarrier — defines a barrier ordering memory transactions\n\n## C Specification\n\n`void `**`glMemoryBarrier`**`(` GLbitfield `barriers``)`;\n\n`void `**`glMemoryBarrierByRegion`**`(` GLbitfield `barriers``)`;\n\n## Parameters\n\n *`barriers`*  \nSpecifies the barriers to insert.\n\nFor `glMemoryBarrier`, must be a bitwise combination of any of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`, `GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`, `GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_SHADER_STORAGE_BARRIER_BIT`.\n\nFor `glMemoryBarrier`, must be a bitwise combination of any of `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_SHADER_STORAGE_BARRIER_BIT`. `GL_TEXTURE_FETCH_BARRIER_BIT`, or `GL_UNIFORM_BARRIER_BIT`.\n\nIf the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers for the corresponding command will be inserted.\n\n## Description for `glMemoryBarrier`\n\n`glMemoryBarrier` defines a barrier ordering the memory transactions issued prior to the command relative to those issued after the barrier. For the purposes of this ordering, memory transactions performed by shaders are considered to be issued by the rendering command that triggered the execution of the shader. *`barriers`* is a bitfield indicating the set of operations that are synchronized with shader stores; the bits used in *`barriers`* are as follows:\n\n `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`  \nIf set, vertex data sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier. The set of buffer objects affected by this bit is derived from the buffer object bindings used for generic vertex attributes derived from the `GL_VERTEX_ATTRIB_ARRAY_BUFFER` bindings.\n\n `GL_ELEMENT_ARRAY_BARRIER_BIT`  \nIf set, vertex array indices sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier. The buffer objects affected by this bit are derived from the `GL_ELEMENT_ARRAY_BUFFER` binding.\n\n `GL_UNIFORM_BARRIER_BIT`  \nShader uniforms sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier.\n\n `GL_TEXTURE_FETCH_BARRIER_BIT`  \nTexture fetches from shaders, including fetches from buffer object memory via buffer textures, after the barrier will reflect data written by shaders prior to the barrier.\n\n `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`  \nMemory accesses using shader image load, store, and atomic built-in functions issued after the barrier will reflect data written by shaders prior to the barrier. Additionally, image stores and atomics issued after the barrier will not execute until all memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to the barrier complete.\n\n `GL_COMMAND_BARRIER_BIT`  \nCommand data sourced from buffer objects by Draw\\*Indirect commands after the barrier will reflect data written by shaders prior to the barrier. The buffer objects affected by this bit are derived from the `GL_DRAW_INDIRECT_BUFFER` binding.\n\n `GL_PIXEL_BUFFER_BARRIER_BIT`  \nReads and writes of buffer objects via the `GL_PIXEL_PACK_BUFFER` and `GL_PIXEL_UNPACK_BUFFER` bindings (via [glReadPixels](glreadpixels.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), etc.) after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer object writes issued after the barrier will wait on the completion of all shader writes initiated prior to the barrier.\n\n `GL_TEXTURE_UPDATE_BARRIER_BIT`  \nWrites to a texture via `glTex(Sub)Image*`, `glCopyTex(Sub)Image*`, `glCompressedTex(Sub)Image*`, and reads via [glGetTexImage](glgetteximage.xhtml) after the barrier will reflect data written by shaders prior to the barrier. Additionally, texture writes from these commands issued after the barrier will not execute until all shader writes initiated prior to the barrier complete.\n\n `GL_BUFFER_UPDATE_BARRIER_BIT`  \nReads or writes via [glBufferSubData](glbuffersubdata.xhtml), [glCopyBufferSubData](glcopybuffersubdata.xhtml), or [glGetBufferSubData](glgetbuffersubdata.xhtml), or to buffer object memory mapped by [glMapBuffer](glmapbuffer.xhtml) or [glMapBufferRange](glmapbufferrange.xhtml) after the barrier will reflect data written by shaders prior to the barrier. Additionally, writes via these commands issued after the barrier will wait on the completion of any shader writes to the same memory initiated prior to the barrier.\n\n `GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT`  \nAccess by the client to persistent mapped regions of buffer objects will reflect data written by shaders prior to the barrier. Note that this may cause additional synchronization operations.\n\n `GL_FRAMEBUFFER_BARRIER_BIT`  \nReads and writes via framebuffer object attachments after the barrier will reflect data written by shaders prior to the barrier. Additionally, framebuffer writes issued after the barrier will wait on the completion of all shader writes issued prior to the barrier.\n\n `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`  \nWrites via transform feedback bindings after the barrier will reflect data written by shaders prior to the barrier. Additionally, transform feedback writes issued after the barrier will wait on the completion of all shader writes issued prior to the barrier.\n\n `GL_ATOMIC_COUNTER_BARRIER_BIT`  \nAccesses to atomic counters after the barrier will reflect writes prior to the barrier.\n\n `GL_SHADER_STORAGE_BARRIER_BIT`  \nAccesses to shader storage blocks after the barrier will reflect writes prior to the barrier.\n\n `GL_QUERY_BUFFER_BARRIER_BIT`  \nWrites of buffer objects via the `GL_QUERY_BUFFER` binding after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer object writes issued after the barrier will wait on the completion of all shader writes initiated prior to the barrier.\n\nIf *`barriers`* is `GL_ALL_BARRIER_BITS`, shader memory accesses will be synchronized relative to all the operations described above.\n\nImplementations may cache buffer object and texture image memory that could be written by shaders in multiple caches; for example, there may be separate caches for texture, vertex fetching, and one or more caches for shader memory accesses. Implementations are not required to keep these caches coherent with shader memory writes. Stores issued by one invocation may not be immediately observable by other pipeline stages or other shader invocations because the value stored may remain in a cache local to the processor executing the store, or because data overwritten by the store is still in a cache elsewhere in the system. When `glMemoryBarrier` is called, the GL flushes and/or invalidates any caches relevant to the operations specified by the *`barriers`* parameter to ensure consistent ordering of operations across the barrier.\n\nTo allow for independent shader invocations to communicate by reads and writes to a common memory address, image variables in the OpenGL Shading Language may be declared as \"coherent\". Buffer object or texture image memory accessed through such variables may be cached only if caches are automatically updated due to stores issued by any other shader invocation. If the same address is accessed using both coherent and non-coherent variables, the accesses using variables declared as coherent will observe the results stored using coherent variables in other invocations. Using variables declared as \"coherent\" guarantees only that the results of stores will be immediately visible to shader invocations using similarly-declared variables; calling `glMemoryBarrier` is required to ensure that the stores are visible to other operations.\n\nThe following guidelines may be helpful in choosing when to use coherent memory accesses and when to use barriers.\n\n- Data that are read-only or constant may be accessed without using coherent variables or calling `MemoryBarrier`(). Updates to the read-only data via API calls such as `glBufferSubData` will invalidate shader caches implicitly as required.\n\n- Data that are shared between shader invocations at a fine granularity (e.g., written by one invocation, consumed by another invocation) should use coherent variables to read and write the shared data.\n\n- Data written by one shader invocation and consumed by other shader invocations launched as a result of its execution (\"dependent invocations\") should use coherent variables in the producing shader invocation and call `memoryBarrier`() after the last write. The consuming shader invocation should also use coherent variables.\n\n- Data written to image variables in one rendering pass and read by the shader in a later pass need not use coherent variables or memoryBarrier(). Calling `glMemoryBarrier` with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in *`barriers`* between passes is necessary.\n\n- Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or index buffer pulling) in a later pass need not use coherent variables or `memoryBarrier`(). Calling `glMemoryBarrier` with the appropriate bits set in *`barriers`* between passes is necessary.\n\n## Description for `glMemoryBarrierByRegion`\n\n`glMemoryBarrierByRegion` behaves as described above for `glMemoryBarrier`, with two differences:\n\nFirst, it narrows the region under consideration so that only reads and writes of prior fragment shaders that are invoked for a smaller region of the framebuffer will be completed/reflected prior to subsequent reads and writes of following fragment shaders. The size of the region is implementation-dependent and may be as small as one framebuffer pixel.\n\nSecond, it only applies to memory transactions that may be read by or written by a fragment shader. Therefore, only the barrier bits\n\n- `GL_ATOMIC_COUNTER_BARRIER_BIT`\n\n- `GL_FRAMEBUFFER_BARRIER_BIT`\n\n- `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`\n\n- `GL_SHADER_STORAGE_BARRIER_BIT`\n\n- `GL_TEXTURE_FETCH_BARRIER_BIT`\n\n- `GL_UNIFORM_BARRIER_BIT`\n\nare supported.\n\nWhen *`barriers`* is `GL_ALL_BARRIER_BITS`, shader memory accesses will be synchronized relative to all these barrier bits, but not to other barrier bits specific to `glMemoryBarrier`. This implies that reads and writes for scatter/gather-like algorithms may or may not be completed/reflected after a `glMemoryBarrierByRegion` command. However, for uses such as deferred shading, where a linked list of visible surfaces with the head at a framebuffer address may be constructed, and the entirety of the list is only dependent on previous executions at that framebuffer address, `glMemoryBarrierByRegion` may be significantly more efficient than `glMemoryBarrier`.\n\n## Notes\n\n`GL_SHADER_STORAGE_BARRIER_BIT` is available only if the GL version is 4.3 or higher.\n\n`GL_QUERY_BUFFER_BARRIER_BIT` is available only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`barriers`* is not the special value `GL_ALL_BARRIER_BITS`, and has any bits set other than those described above for `glMemoryBarrier` or `glMemoryBarrierByRegion` respectively.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glMemoryBarrier`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glMemoryBarrierByRegion`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindImageTexture](glbindimagetexture.xhtml), [glBufferData](glbufferdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glMapBufferRange](glmapbufferrange.xhtml), [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml), [memoryBarrier](memorybarrier.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMemoryBarrier.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMemoryBarrier.xhtml)"
- name: glMemoryBarrierByRegion
  id: glmemorybarrier.xhtml#glMemoryBarrierByRegion
  summary: Specifies the barriers to insert
  belongs_to: glMemoryBarrier
  description: "`void `**`glMemoryBarrierByRegion`**`(` GLbitfield `barriers``)`;\n\n## Parameters\n\n*`barriers`*\n\nSpecifies the barriers to insert.\n\nFor `glMemoryBarrier`, must be a bitwise combination of any of `GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`, `GL_ELEMENT_ARRAY_BARRIER_BIT`, `GL_UNIFORM_BARRIER_BIT`, `GL_TEXTURE_FETCH_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_COMMAND_BARRIER_BIT`, `GL_PIXEL_BUFFER_BARRIER_BIT`, `GL_TEXTURE_UPDATE_BARRIER_BIT`, `GL_BUFFER_UPDATE_BARRIER_BIT`, `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_TRANSFORM_FEEDBACK_BARRIER_BIT`, `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_SHADER_STORAGE_BARRIER_BIT`.\n\nFor `glMemoryBarrier`, must be a bitwise combination of any of `GL_ATOMIC_COUNTER_BARRIER_BIT`, or `GL_FRAMEBUFFER_BARRIER_BIT`, `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`, `GL_SHADER_STORAGE_BARRIER_BIT`. `GL_TEXTURE_FETCH_BARRIER_BIT`, or `GL_UNIFORM_BARRIER_BIT`.\n\nIf the special value `GL_ALL_BARRIER_BITS` is specified, all supported barriers for the corresponding command will be inserted.\n\n## Description for `glMemoryBarrier`\n\n`glMemoryBarrier` defines a barrier ordering the memory transactions issued prior to the command relative to those issued after the barrier. For the purposes of this ordering, memory transactions performed by shaders are considered to be issued by the rendering command that triggered the execution of the shader. *`barriers`* is a bitfield indicating the set of operations that are synchronized with shader stores; the bits used in *`barriers`* are as follows:\n\n`GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT`\n\nIf set, vertex data sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier. The set of buffer objects affected by this bit is derived from the buffer object bindings used for generic vertex attributes derived from the `GL_VERTEX_ATTRIB_ARRAY_BUFFER` bindings.\n\n`GL_ELEMENT_ARRAY_BARRIER_BIT`\n\nIf set, vertex array indices sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier. The buffer objects affected by this bit are derived from the `GL_ELEMENT_ARRAY_BUFFER` binding.\n\n`GL_UNIFORM_BARRIER_BIT`\n\nShader uniforms sourced from buffer objects after the barrier will reflect data written by shaders prior to the barrier.\n\n`GL_TEXTURE_FETCH_BARRIER_BIT`\n\nTexture fetches from shaders, including fetches from buffer object memory via buffer textures, after the barrier will reflect data written by shaders prior to the barrier.\n\n`GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`\n\nMemory accesses using shader image load, store, and atomic built-in functions issued after the barrier will reflect data written by shaders prior to the barrier. Additionally, image stores and atomics issued after the barrier will not execute until all memory accesses (e.g., loads, stores, texture fetches, vertex fetches) initiated prior to the barrier complete.\n\n`GL_COMMAND_BARRIER_BIT`\n\nCommand data sourced from buffer objects by Draw\\*Indirect commands after the barrier will reflect data written by shaders prior to the barrier. The buffer objects affected by this bit are derived from the `GL_DRAW_INDIRECT_BUFFER` binding.\n\n`GL_PIXEL_BUFFER_BARRIER_BIT`\n\nReads and writes of buffer objects via the `GL_PIXEL_PACK_BUFFER` and `GL_PIXEL_UNPACK_BUFFER` bindings (via [glReadPixels](glreadpixels.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), etc.) after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer object writes issued after the barrier will wait on the completion of all shader writes initiated prior to the barrier.\n\n`GL_TEXTURE_UPDATE_BARRIER_BIT`\n\nWrites to a texture via `glTex(Sub)Image*`, `glCopyTex(Sub)Image*`, `glCompressedTex(Sub)Image*`, and reads via [glGetTexImage](glgetteximage.xhtml) after the barrier will reflect data written by shaders prior to the barrier. Additionally, texture writes from these commands issued after the barrier will not execute until all shader writes initiated prior to the barrier complete.\n\n`GL_BUFFER_UPDATE_BARRIER_BIT`\n\nReads or writes via [glBufferSubData](glbuffersubdata.xhtml), [glCopyBufferSubData](glcopybuffersubdata.xhtml), or [glGetBufferSubData](glgetbuffersubdata.xhtml), or to buffer object memory mapped by [glMapBuffer](glmapbuffer.xhtml) or [glMapBufferRange](glmapbufferrange.xhtml) after the barrier will reflect data written by shaders prior to the barrier. Additionally, writes via these commands issued after the barrier will wait on the completion of any shader writes to the same memory initiated prior to the barrier.\n\n`GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT`\n\nAccess by the client to persistent mapped regions of buffer objects will reflect data written by shaders prior to the barrier. Note that this may cause additional synchronization operations.\n\n`GL_FRAMEBUFFER_BARRIER_BIT`\n\nReads and writes via framebuffer object attachments after the barrier will reflect data written by shaders prior to the barrier. Additionally, framebuffer writes issued after the barrier will wait on the completion of all shader writes issued prior to the barrier.\n\n`GL_TRANSFORM_FEEDBACK_BARRIER_BIT`\n\nWrites via transform feedback bindings after the barrier will reflect data written by shaders prior to the barrier. Additionally, transform feedback writes issued after the barrier will wait on the completion of all shader writes issued prior to the barrier.\n\n`GL_ATOMIC_COUNTER_BARRIER_BIT`\n\nAccesses to atomic counters after the barrier will reflect writes prior to the barrier.\n\n`GL_SHADER_STORAGE_BARRIER_BIT`\n\nAccesses to shader storage blocks after the barrier will reflect writes prior to the barrier.\n\n`GL_QUERY_BUFFER_BARRIER_BIT`\n\nWrites of buffer objects via the `GL_QUERY_BUFFER` binding after the barrier will reflect data written by shaders prior to the barrier. Additionally, buffer object writes issued after the barrier will wait on the completion of all shader writes initiated prior to the barrier.\n\nIf *`barriers`* is `GL_ALL_BARRIER_BITS`, shader memory accesses will be synchronized relative to all the operations described above.\n\nImplementations may cache buffer object and texture image memory that could be written by shaders in multiple caches; for example, there may be separate caches for texture, vertex fetching, and one or more caches for shader memory accesses. Implementations are not required to keep these caches coherent with shader memory writes. Stores issued by one invocation may not be immediately observable by other pipeline stages or other shader invocations because the value stored may remain in a cache local to the processor executing the store, or because data overwritten by the store is still in a cache elsewhere in the system. When `glMemoryBarrier` is called, the GL flushes and/or invalidates any caches relevant to the operations specified by the *`barriers`* parameter to ensure consistent ordering of operations across the barrier.\n\nTo allow for independent shader invocations to communicate by reads and writes to a common memory address, image variables in the OpenGL Shading Language may be declared as \"coherent\". Buffer object or texture image memory accessed through such variables may be cached only if caches are automatically updated due to stores issued by any other shader invocation. If the same address is accessed using both coherent and non-coherent variables, the accesses using variables declared as coherent will observe the results stored using coherent variables in other invocations. Using variables declared as \"coherent\" guarantees only that the results of stores will be immediately visible to shader invocations using similarly-declared variables; calling `glMemoryBarrier` is required to ensure that the stores are visible to other operations.\n\nThe following guidelines may be helpful in choosing when to use coherent memory accesses and when to use barriers.\n\n- Data that are read-only or constant may be accessed without using coherent variables or calling `MemoryBarrier`(). Updates to the read-only data via API calls such as `glBufferSubData` will invalidate shader caches implicitly as required.\n\n- Data that are shared between shader invocations at a fine granularity (e.g., written by one invocation, consumed by another invocation) should use coherent variables to read and write the shared data.\n\n- Data written by one shader invocation and consumed by other shader invocations launched as a result of its execution (\"dependent invocations\") should use coherent variables in the producing shader invocation and call `memoryBarrier`() after the last write. The consuming shader invocation should also use coherent variables.\n\n- Data written to image variables in one rendering pass and read by the shader in a later pass need not use coherent variables or memoryBarrier(). Calling `glMemoryBarrier` with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in *`barriers`* between passes is necessary.\n\n- Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or index buffer pulling) in a later pass need not use coherent variables or `memoryBarrier`(). Calling `glMemoryBarrier` with the appropriate bits set in *`barriers`* between passes is necessary.\n\n## Description for `glMemoryBarrierByRegion`\n\n`glMemoryBarrierByRegion` behaves as described above for `glMemoryBarrier`, with two differences:\n\nFirst, it narrows the region under consideration so that only reads and writes of prior fragment shaders that are invoked for a smaller region of the framebuffer will be completed/reflected prior to subsequent reads and writes of following fragment shaders. The size of the region is implementation-dependent and may be as small as one framebuffer pixel.\n\nSecond, it only applies to memory transactions that may be read by or written by a fragment shader. Therefore, only the barrier bits\n\n- `GL_ATOMIC_COUNTER_BARRIER_BIT`\n\n- `GL_FRAMEBUFFER_BARRIER_BIT`\n\n- `GL_SHADER_IMAGE_ACCESS_BARRIER_BIT`\n\n- `GL_SHADER_STORAGE_BARRIER_BIT`\n\n- `GL_TEXTURE_FETCH_BARRIER_BIT`\n\n- `GL_UNIFORM_BARRIER_BIT`\n\nare supported.\n\nWhen *`barriers`* is `GL_ALL_BARRIER_BITS`, shader memory accesses will be synchronized relative to all these barrier bits, but not to other barrier bits specific to `glMemoryBarrier`. This implies that reads and writes for scatter/gather-like algorithms may or may not be completed/reflected after a `glMemoryBarrierByRegion` command. However, for uses such as deferred shading, where a linked list of visible surfaces with the head at a framebuffer address may be constructed, and the entirety of the list is only dependent on previous executions at that framebuffer address, `glMemoryBarrierByRegion` may be significantly more efficient than `glMemoryBarrier`.\n\n## Notes\n\n`GL_SHADER_STORAGE_BARRIER_BIT` is available only if the GL version is 4.3 or higher.\n\n`GL_QUERY_BUFFER_BARRIER_BIT` is available only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`barriers`* is not the special value `GL_ALL_BARRIER_BITS`, and has any bits set other than those described above for `glMemoryBarrier` or `glMemoryBarrierByRegion` respectively.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glMemoryBarrier`             |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glMemoryBarrierByRegion`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindImageTexture](glbindimagetexture.xhtml), [glBufferData](glbufferdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glMapBufferRange](glmapbufferrange.xhtml), [glFlushMappedBufferRange](glflushmappedbufferrange.xhtml), [memoryBarrier](memorybarrier.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMemoryBarrier.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMemoryBarrier.xhtml)"
- name: glMinSampleShading
  id: glminsampleshading.xhtml
  summary: value Specifies the rate at which samples are shaded within each covered pixel
  description: "## Name\n\nglMinSampleShading — specifies minimum rate at which sample shading takes place\n\n## C Specification\n\n`void `**`glMinSampleShading`**`(` GLfloat `value``)`;\n\n## Parameters\n\n *`value`*  \nSpecifies the rate at which samples are shaded within each covered pixel.\n\n## Description\n\n`glMinSampleShading` specifies the rate at which samples are shaded within a covered pixel. Sample-rate shading is enabled by calling [glEnable](glenable.xhtml) with the parameter `GL_SAMPLE_SHADING`. If `GL_MULTISAMPLE` or `GL_SAMPLE_SHADING` is disabled, sample shading has no effect. Otherwise, an implementation must provide at least as many unique color values for each covered fragment as specified by *`value`* times *`samples`* where *`samples`* is the value of `GL_SAMPLES` for the current framebuffer. At least 1 sample for each covered fragment is generated.\n\nA *`value`* of 1.0 indicates that each sample in the framebuffer should be independently shaded. A *`value`* of 0.0 effectively allows the GL to ignore sample rate shading. Any value between 0.0 and 1.0 allows the GL to shade only a subset of the total samples within each covered fragment. Which samples are shaded and the algorithm used to select that subset of the fragment's samples is implementation dependent.\n\n## Notes\n\nThe type of the *`value`* parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Errors\n\nNone.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MIN_SAMPLE_SHADING`.\n\n[glGet](glget.xhtml) with argument `GL_SAMPLES`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glMinSampleShading`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMinSampleShading.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMinSampleShading.xhtml)"
- name: glMultiDrawArrays
  id: glmultidrawarrays.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglMultiDrawArrays — render multiple sets of primitives from array data\n\n## C Specification\n\n`void `**`glMultiDrawArrays`**`(` GLenum `mode`, const GLint \\* `first`, const GLsizei \\* `count`, GLsizei `drawcount``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`first`*  \nPoints to an array of starting indices in the enabled arrays.\n\n *`count`*  \nPoints to an array of the number of indices to be rendered.\n\n *`drawcount`*  \nSpecifies the size of the first and count\n\n## Description\n\n`glMultiDrawArrays` specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to `glMultiDrawArrays`.\n\n`glMultiDrawArrays` behaves identically to [glDrawArrays](gldrawarrays.xhtml) except that *`drawcount`* separate ranges of elements are specified instead.\n\nWhen `glMultiDrawArrays` is called, it uses *`count`* sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element *`first`*. *`mode`* specifies what kind of primitives are constructed, and how the array elements construct those primitives.\n\nVertex attributes that are modified by `glMultiDrawArrays` have an unspecified value after `glMultiDrawArrays` returns. Attributes that aren't modified remain well defined.\n\n## Notes\n\n`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`drawcount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glMultiDrawArrays`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawArrays.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawArrays.xhtml)"
- name: glMultiDrawArraysIndirect
  id: glmultidrawarraysindirect.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglMultiDrawArraysIndirect — render multiple sets of primitives from array data, taking parameters from memory\n\n## C Specification\n\n`void `**`glMultiDrawArraysIndirect`**`(` GLenum `mode`, const void \\*`indirect`, GLsizei `drawcount`, GLsizei `stride``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.\n\n *`indirect`*  \nSpecifies the address of an array of structures containing the draw parameters.\n\n *`drawcount`*  \nSpecifies the number of elements in the array of draw parameter structures.\n\n *`stride`*  \nSpecifies the distance in basic machine units between elements of the draw parameter array.\n\n## Description\n\n`glMultiDrawArraysIndirect` specifies multiple geometric primitives with very few subroutine calls. `glMultiDrawArraysIndirect` behaves similarly to a multitude of calls to [glDrawArraysInstancedBaseInstance](gldrawarraysinstancedbaseinstance.xhtml), execept that the parameters to each call to [glDrawArraysInstancedBaseInstance](gldrawarraysinstancedbaseinstance.xhtml) are stored in an array in memory at the address given by *`indirect`*, separated by the stride, in basic machine units, specified by *`stride`*. If *`stride`* is zero, then the array is assumed to be tightly packed in memory.\n\nThe parameters addressed by *`indirect`* are packed into an array of structures, each element of which takes the form (in C):\n\n``` programlisting\n    typedef  struct {\n        uint  count;\n        uint  instanceCount;\n        uint  first;\n        uint  baseInstance;\n    } DrawArraysIndirectCommand;\n```\n\nA single call to `glMultiDrawArraysIndirect` is equivalent, assuming no errors are generated to:\n\n``` programlisting\n    GLsizei n;\n    for (n = 0; n < drawcount; n++) {\n        const DrawArraysIndirectCommand *cmd;\n        if (stride != 0) {\n            cmd = (const DrawArraysIndirectCommand  *)((uintptr)indirect + n * stride);\n        } else  {\n            cmd = (const DrawArraysIndirectCommand  *)indirect + n;\n        }\n\n        glDrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count, cmd->instanceCount, cmd->baseInstance);\n    }\n```\n\nIf a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to `glMultiDrawArraysIndirect`, *`indirect`* is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.\n\nIn contrast to [glDrawArraysInstancedBaseInstance](gldrawarraysinstancedbaseinstance.xhtml), the `first` member of the parameter structure is unsigned, and out-of-range indices do not generate an error.\n\nVertex attributes that are modified by `glMultiDrawArraysIndirect` have an unspecified value after `glMultiDrawArraysIndirect` returns. Attributes that aren't modified remain well defined.\n\n## Notes\n\nThe *`baseInstance`* member of the *`DrawArraysIndirectCommand`* structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.\n\n`glMultiDrawArraysIndirect` is available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`stride`* is not a multiple of four.\n\n`GL_INVALID_VALUE` is generated if *`drawcount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* is `GL_PATCHES` and no tessellation control shader is active.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glMultiDrawArraysIndirect` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawArraysIndirect](gldrawarraysindirect.xhtml), [glMultiDrawElementsIndirect](glmultidrawelementsindirect.xhtml)\n\n## Copyright\n\nCopyright © 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawArraysIndirect.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawArraysIndirect.xhtml)"
- name: glMultiDrawElements
  id: glmultidrawelements.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglMultiDrawElements — render multiple sets of primitives by specifying indices of array data elements\n\n## C Specification\n\n`void `**`glMultiDrawElements`**`(` GLenum `mode`, const GLsizei \\* `count`, GLenum `type`, const void \\* const \\* `indices`, GLsizei `drawcount``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`count`*  \nPoints to an array of the elements counts.\n\n *`type`*  \nSpecifies the type of the values in *`indices`*. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n *`drawcount`*  \nSpecifies the size of the *`count`* and *`indices`* arrays.\n\n## Description\n\n`glMultiDrawElements` specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to `glMultiDrawElements`.\n\n`glMultiDrawElements` is identical in operation to [glDrawElements](gldrawelements.xhtml) except that *`drawcount`* separate lists of elements are specified.\n\nVertex attributes that are modified by `glMultiDrawElements` have an unspecified value after `glMultiDrawElements` returns. Attributes that aren't modified maintain their previous values.\n\n## Notes\n\n`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`drawcount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glMultiDrawElements`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawElements.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawElements.xhtml)"
- name: glMultiDrawElementsBaseVertex
  id: glmultidrawelementsbasevertex.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglMultiDrawElementsBaseVertex — render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index\n\n## C Specification\n\n`void `**`glMultiDrawElementsBaseVertex`**`(` GLenum `mode`, const GLsizei \\*`count`, GLenum `type`, const void \\* const \\*`indices`, GLsizei `drawcount`, const GLint \\*`basevertex``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY` and `GL_PATCHES` are accepted.\n\n *`count`*  \nPoints to an array of the elements counts.\n\n *`type`*  \nSpecifies the type of the values in *`indices`*. Must be one of `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, or `GL_UNSIGNED_INT`.\n\n *`indices`*  \nSpecifies a pointer to the location where the indices are stored.\n\n *`drawcount`*  \nSpecifies the size of the *`count`*, *`indices`* and *`basevertex`* arrays.\n\n *`basevertex`*  \nSpecifies a pointer to the location where the base vertices are stored.\n\n## Description\n\n`glMultiDrawElementsBaseVertex` behaves identically to [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml), except that *`drawcount`* separate lists of elements are specifried instead.\n\nIt has the same effect as:\n\n``` programlisting\n    for (int i = 0; i < drawcount; i++)\n        if (count[i] > 0)\n            glDrawElementsBaseVertex(mode,\n                                     count[i],\n                                     type,\n                                     indices[i],\n                                     basevertex[i]);\n```\n\n## Notes\n\n`glMultiDrawElementsBaseVertex` is available only if the GL version is 3.1 or greater.\n\n`GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP_ADJACENCY` and `GL_TRIANGLES_ADJACENCY` are available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`drawcount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glMultiDrawElementsBaseVertex` |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glMultiDrawElements](glmultidrawelements.xhtml), [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml), [glDrawArrays](gldrawarrays.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2010 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawElementsBaseVertex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawElementsBaseVertex.xhtml)"
- name: glMultiDrawElementsIndirect
  id: glmultidrawelementsindirect.xhtml
  summary: mode Specifies what kind of primitives to render
  description: "## Name\n\nglMultiDrawElementsIndirect — render indexed primitives from array data, taking parameters from memory\n\n## C Specification\n\n`void `**`glMultiDrawElementsIndirect`**`(` GLenum `mode`, GLenum `type`, const void \\*`indirect`, GLsizei `drawcount`, GLsizei `stride``)`;\n\n## Parameters\n\n *`mode`*  \nSpecifies what kind of primitives to render. Symbolic constants `GL_POINTS`, `GL_LINE_STRIP`, `GL_LINE_LOOP`, `GL_LINES`, `GL_LINE_STRIP_ADJACENCY`, `GL_LINES_ADJACENCY`, `GL_TRIANGLE_STRIP`, `GL_TRIANGLE_FAN`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP_ADJACENCY`, `GL_TRIANGLES_ADJACENCY`, and `GL_PATCHES` are accepted.\n\n *`type`*  \nSpecifies the type of data in the buffer bound to the `GL_ELEMENT_ARRAY_BUFFER` binding.\n\n *`indirect`*  \nSpecifies the address of a structure containing an array of draw parameters.\n\n *`drawcount`*  \nSpecifies the number of elements in the array addressed by *`indirect`*.\n\n *`stride`*  \nSpecifies the distance in basic machine units between elements of the draw parameter array.\n\n## Description\n\n`glMultiDrawElementsIndirect` specifies multiple indexed geometric primitives with very few subroutine calls. `glMultiDrawElementsIndirect` behaves similarly to a multitude of calls to [glDrawElementsInstancedBaseVertexBaseInstance](gldrawelementsinstancedbasevertexbaseinstance.xhtml), execpt that the parameters to [glDrawElementsInstancedBaseVertexBaseInstance](gldrawelementsinstancedbasevertexbaseinstance.xhtml) are stored in an array in memory at the address given by *`indirect`*, separated by the stride, in basic machine units, specified by *`stride`*. If *`stride`* is zero, then the array is assumed to be tightly packed in memory.\n\nThe parameters addressed by *`indirect`* are packed into a structure that takes the form (in C):\n\n``` programlisting\n    typedef  struct {\n        uint  count;\n        uint  instanceCount;\n        uint  firstIndex;\n        int  baseVertex;\n        uint  baseInstance;\n    } DrawElementsIndirectCommand;\n```\n\nA single call to `glMultiDrawElementsIndirect` is equivalent, assuming no errors are generated to:\n\n``` programlisting\n    GLsizei n;\n    for (n = 0; n < drawcount; n++) {\n        const DrawElementsIndirectCommand *cmd;\n        if (stride != 0) {\n            cmd = (const DrawElementsIndirectCommand  *)((uintptr)indirect + n * stride);\n        } else {\n            cmd = (const DrawElementsIndirectCommand  *)indirect + n;\n        }\n\n        glDrawElementsInstancedBaseVertexBaseInstance(mode,\n                                                      cmd->count,\n                                                      type,\n                                                      cmd->firstIndex * size-of-type,\n                                                      cmd->instanceCount,\n                                                      cmd->baseVertex,\n                                                      cmd->baseInstance);\n    }\n```\n\nIf a buffer is bound to the `GL_DRAW_INDIRECT_BUFFER` binding at the time of a call to `glDrawElementsIndirect`, *`indirect`* is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory.\n\nNote that indices stored in client memory are not supported. If no buffer is bound to the `GL_ELEMENT_ARRAY_BUFFER` binding, an error will be generated.\n\nThe results of the operation are undefined if the `reservedMustBeZero` member of the parameter structure is non-zero. However, no error is generated in this case.\n\nVertex attributes that are modified by `glDrawElementsIndirect` have an unspecified value after `glDrawElementsIndirect` returns. Attributes that aren't modified remain well defined.\n\n## Notes\n\nThe *`baseInstance`* member of the *`DrawElementsIndirectCommand`* structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`stride`* is not a multiple of four.\n\n`GL_INVALID_VALUE` is generated if *`drawcount`* is negative.\n\n`GL_INVALID_OPERATION` is generated if no buffer is bound to the `GL_ELEMENT_ARRAY_BUFFER` binding, or if such a buffer's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to an enabled array or to the `GL_DRAW_INDIRECT_BUFFER` binding and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a geometry shader is active and *`mode`* is incompatible with the input primitive type of the geometry shader in the currently installed program object.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* is `GL_PATCHES` and no tessellation control shader is active.\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glMultiDrawElementsIndirect` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawArraysIndirect](gldrawarraysindirect.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawElementsIndirect](gldrawelementsindirect.xhtml), [glMultiDrawArraysIndirect](glmultidrawarraysindirect.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawElementsIndirect.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glMultiDrawElementsIndirect.xhtml)"
- name: glNamedBufferData
  id: glbufferdata.xhtml#glNamedBufferData
  summary: Specifies the name of the buffer object for glNamedBufferData function
  belongs_to: glBufferData
  description: "`void `**`glNamedBufferData`**`(` GLuint `buffer`, GLsizeiptr `size`, const void \\*`data`, GLenum `usage``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glBufferData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glNamedBufferData` function.\n\n*`size`*\n\nSpecifies the size in bytes of the buffer object's new data store.\n\n*`data`*\n\nSpecifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.\n\n*`usage`*\n\nSpecifies the expected usage pattern of the data store. The symbolic constant must be `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.\n\n## Description\n\n`glBufferData` and `glNamedBufferData` create a new data store for a buffer object. In case of `glBufferData`, the buffer object currently bound to *`target`* is used. For `glNamedBufferData`, a buffer object associated with ID specified by the caller in *`buffer`* will be used instead.\n\nWhile creating the new storage, any pre-existing data store is deleted. The new data store is created with the specified *`size`* in bytes and *`usage`*. If *`data`* is not `NULL`, the data store is initialized with data from this pointer. In its initial state, the new data store is not mapped, it has a `NULL` mapped pointer, and its mapped access is `GL_READ_WRITE`.\n\n*`usage`* is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. *`usage`* can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these:\n\nSTREAM\n\nThe data store contents will be modified once and used at most a few times.\n\nSTATIC\n\nThe data store contents will be modified once and used many times.\n\nDYNAMIC\n\nThe data store contents will be modified repeatedly and used many times.\n\nThe nature of access may be one of these:\n\nDRAW\n\nThe data store contents are modified by the application, and used as the source for GL drawing and image specification commands.\n\nREAD\n\nThe data store contents are modified by reading data from the GL, and used to return that data when queried by the application.\n\nCOPY\n\nThe data store contents are modified by reading data from the GL, and used as the source for GL drawing and image specification commands.\n\n## Notes\n\nIf *`data`* is `NULL`, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.\n\nClients must align data elements consistently with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising *N* bytes be a multiple of *N*.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glBufferData` if *`target`* is not one of the accepted buffer targets.\n\n`GL_INVALID_ENUM` is generated if *`usage`* is not `GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`.\n\n`GL_INVALID_VALUE` is generated if *`size`* is negative.\n\n`GL_INVALID_OPERATION` is generated by `glBufferData` if the reserved buffer object name 0 is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedBufferData` if buffer is not the name of an existing buffer object.\n\n`GL_INVALID_OPERATION` is generated if the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer object is `GL_TRUE`.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the specified *`size`*.\n\n## Associated Gets\n\n[ glGetBufferSubData ](glgetbuffersubdata.xhtml)\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_SIZE` or `GL_BUFFER_USAGE`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBufferData`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glNamedBufferData`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferData.xhtml)"
- name: glNamedBufferStorage
  id: glbufferstorage.xhtml#glNamedBufferStorage
  summary: Specifies the name of the buffer object for glNamedBufferStorage function
  belongs_to: glBufferStorage
  description: "`void `**`glNamedBufferStorage`**`(` GLuint `buffer`, GLsizeiptr `size`, const void \\*`data`, GLbitfield `flags``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glBufferStorage`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glNamedBufferStorage` function.\n\n*`size`*\n\nSpecifies the size in bytes of the buffer object's new data store.\n\n*`data`*\n\nSpecifies a pointer to data that will be copied into the data store for initialization, or `NULL` if no data is to be copied.\n\n*`flags`*\n\nSpecifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. `GL_DYNAMIC_STORAGE_BIT`, `GL_MAP_READ_BIT` `GL_MAP_WRITE_BIT`, `GL_MAP_PERSISTENT_BIT`, `GL_MAP_COHERENT_BIT`, and `GL_CLIENT_STORAGE_BIT`.\n\n## Description\n\n`glBufferStorage` and `glNamedBufferStorage` create a new immutable data store. For `glBufferStorage`, the buffer object currently bound to *`target`* will be initialized. For `glNamedBufferStorage`, *`buffer`* is the name of the buffer object that will be configured. The size of the data store is specified by *`size`*. If an initial data is available, its address may be supplied in *`data`*. Otherwise, to create an uninitialized data store, *`data`* should be `NULL`.\n\nThe *`flags`* parameters specifies the intended usage of the buffer's data store. It must be a bitwise combination of a subset of the following flags:\n\n`GL_DYNAMIC_STORAGE_BIT`\n\nThe contents of the data store may be updated after creation through calls to [glBufferSubData](glbuffersubdata.xhtml). If this bit is not set, the buffer content may not be directly updated by the client. The data argument may be used to specify the initial content of the buffer's data store regardless of the presence of the `GL_DYNAMIC_STORAGE_BIT`. Regardless of the presence of this bit, buffers may always be updated with server-side calls such as [glCopyBufferSubData](glcopybuffersubdata.xhtml) and [glClearBufferSubData](glclearbuffersubdata.xhtml).\n\n`GL_MAP_READ_BIT`\n\nThe data store may be mapped by the client for read access and a pointer in the client's address space obtained that may be read from.\n\n`GL_MAP_WRITE_BIT`\n\nThe data store may be mapped by the client for write access and a pointer in the client's address space obtained that may be written through.\n\n`GL_MAP_PERSISTENT_BIT`\n\nThe client may request that the server read from or write to the buffer while it is mapped. The client's pointer to the data store remains valid so long as the data store is mapped, even during execution of drawing or dispatch commands.\n\n`GL_MAP_COHERENT_BIT`\n\nShared access to buffers that are simultaneously mapped for client access and are used by the server will be coherent, so long as that mapping is performed using [glMapBufferRange](glmapbufferrange.xhtml). That is, data written to the store by either the client or server will be immediately visible to the other with no further action taken by the application. In particular,\n\n- If `GL_MAP_COHERENT_BIT` is not set and the client performs a write followed by a call to the [glMemoryBarrier](glmemorybarrier.xhtml) command with the `GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT` set, then in subsequent commands the server will see the writes.\n\n- If `GL_MAP_COHERENT_BIT` is set and the client performs a write, then in subsequent commands the server will see the writes.\n\n- If `GL_MAP_COHERENT_BIT` is not set and the server performs a write, the application must call [glMemoryBarrier](glmemorybarrier.xhtml) with the `GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT` set and then call [glFenceSync](glfencesync.xhtml) with `GL_SYNC_GPU_COMMANDS_COMPLETE` (or `glFinish`). Then the CPU will see the writes after the sync is complete.\n\n- If `GL_MAP_COHERENT_BIT` is set and the server does a write, the app must call `glFenceSync` with `GL_SYNC_GPU_COMMANDS_COMPLETE` (or [glFinish](glfinish.xhtml)). Then the CPU will see the writes after the sync is complete.\n\n`GL_CLIENT_STORAGE_BIT`\n\nWhen all other criteria for the buffer storage allocation are met, this bit may be used by an implementation to determine whether to use storage that is local to the server or to the client to serve as the backing store for the buffer.\n\nThe allowed combinations of flags are subject to certain restrictions. They are as follows:\n\n- If *`flags`* contains `GL_MAP_PERSISTENT_BIT`, it must also contain at least one of `GL_MAP_READ_BIT` or `GL_MAP_WRITE_BIT`.\n\n- If *`flags`* contains `GL_MAP_COHERENT_BIT`, it must also contain `GL_MAP_PERSISTENT_BIT`.\n\n## Notes\n\n`glBufferStorage` is available only if the GL version is 4.4 or greater.\n\n`glNamedBufferStorage` is available only if the GL version is 4.5 or greater.\n\nIf *`data`* is `NULL`, a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glBufferStorage` if *`target`* is not one of the accepted buffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glNamedBufferStorage` if buffer is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`size`* is less than or equal to zero.\n\n`GL_INVALID_OPERATION` is generated by `glBufferStorage` if the reserved buffer object name 0 is bound to *`target`*.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store with the properties requested in *`flags`*.\n\n`GL_INVALID_VALUE` is generated if *`flags`* has any bits set other than those defined above.\n\n`GL_INVALID_VALUE` error is generated if *`flags`* contains `GL_MAP_PERSISTENT_BIT` but does not contain at least one of `GL_MAP_READ_BIT` or `GL_MAP_WRITE_BIT`.\n\n`GL_INVALID_VALUE` is generated if *`flags`* contains `GL_MAP_COHERENT_BIT`, but does not also contain `GL_MAP_PERSISTENT_BIT`.\n\n`GL_INVALID_OPERATION` is generated by `glBufferStorage` if the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer bound to *`target`* is `GL_TRUE`.\n\n## Associated Gets\n\n[ glGetBufferSubData ](glgetbuffersubdata.xhtml)\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_SIZE` or `GL_BUFFER_USAGE`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBufferStorage`             |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |\n| `glNamedBufferStorage`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferSubData](glbuffersubdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferStorage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferStorage.xhtml)"
- name: glNamedBufferSubData
  id: glbuffersubdata.xhtml#glNamedBufferSubData
  summary: Specifies the name of the buffer object for glNamedBufferSubData
  belongs_to: glBufferSubData
  description: "`void `**`glNamedBufferSubData`**`(` GLuint `buffer`, GLintptr `offset`, GLsizeiptr `size`, const void \\*`data``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glBufferSubData`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glNamedBufferSubData`.\n\n*`offset`*\n\nSpecifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.\n\n*`size`*\n\nSpecifies the size in bytes of the data store region being replaced.\n\n*`data`*\n\nSpecifies a pointer to the new data that will be copied into the data store.\n\n## Description\n\n`glBufferSubData` and `glNamedBufferSubData` redefine some or all of the data store for the specified buffer object. Data starting at byte offset *`offset`* and extending for *`size`* bytes is copied to the data store from the memory pointed to by *`data`*. *`offset`* and *`size`* must define a range lying entirely within the buffer object's data store.\n\n## Notes\n\nWhen replacing the entire data store, consider using `glBufferSubData` rather than completely recreating the data store with `glBufferData`. This avoids the cost of reallocating the data store.\n\nConsider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering in the pipeline makes reference to data in the buffer object being updated by `glBufferSubData`, especially from the specific region being updated, that rendering must drain from the pipeline before the data store can be updated.\n\nClients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising $N$ bytes be a multiple of $N$.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is available only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glBufferSubData` if *`target`* is not one of the accepted buffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glBufferSubData` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedBufferSubData` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`size`* is negative, or if $offset + size$ is greater than the value of `GL_BUFFER_SIZE` for the specified buffer object.\n\n`GL_INVALID_OPERATION` is generated if any part of the specified range of the buffer object is mapped with [glMapBufferRange](glmapbufferrange.xhtml) or [glMapBuffer](glmapbuffer.xhtml), unless it was mapped with the `GL_MAP_PERSISTENT_BIT` bit set in the `glMapBufferRange` *`access`* flags.\n\n`GL_INVALID_OPERATION` is generated if the value of the `GL_BUFFER_IMMUTABLE_STORAGE` flag of the buffer object is `GL_TRUE` and the value of `GL_BUFFER_STORAGE_FLAGS` for the buffer object does not have the `GL_DYNAMIC_STORAGE_BIT` bit set.\n\n## Associated Gets\n\n[ glGetBufferSubData ](glgetbuffersubdata.xhtml)\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBufferSubData`             |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glNamedBufferSubData`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glMapBufferRange](glmapbufferrange.xhtml), [glUnmapBuffer](glunmapbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferSubData.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBufferSubData.xhtml)"
- name: glNamedFramebufferDrawBuffer
  id: gldrawbuffer.xhtml#glNamedFramebufferDrawBuffer
  summary: Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffer function
  belongs_to: glDrawBuffer
  description: "`void `**`glNamedFramebufferDrawBuffer`**`(` GLuint `framebuffer`, GLenum `buf``)`;\n\n## Parameters\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glNamedFramebufferDrawBuffer` function. Must be zero or the name of a framebuffer object.\n\n*`buf`*\n\nFor default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants `GL_NONE`, `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_FRONT_AND_BACK` are accepted. The initial value is `GL_FRONT` for single-buffered contexts, and `GL_BACK` for double-buffered contexts. For framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums are accepted, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`.\n\n## Description\n\nWhen colors are written to the frame buffer, they are written into the color buffers specified by `glDrawBuffer`. One of the following values can be used for default framebuffer:\n\n`GL_NONE`\n\nNo color buffers are written.\n\n`GL_FRONT_LEFT`\n\nOnly the front left color buffer is written.\n\n`GL_FRONT_RIGHT`\n\nOnly the front right color buffer is written.\n\n`GL_BACK_LEFT`\n\nOnly the back left color buffer is written.\n\n`GL_BACK_RIGHT`\n\nOnly the back right color buffer is written.\n\n`GL_FRONT`\n\nOnly the front left and front right color buffers are written. If there is no front right color buffer, only the front left color buffer is written.\n\n`GL_BACK`\n\nOnly the back left and back right color buffers are written. If there is no back right color buffer, only the back left color buffer is written.\n\n`GL_LEFT`\n\nOnly the front left and back left color buffers are written. If there is no back left color buffer, only the front left color buffer is written.\n\n`GL_RIGHT`\n\nOnly the front right and back right color buffers are written. If there is no back right color buffer, only the front right color buffer is written.\n\n`GL_FRONT_AND_BACK`\n\nAll the front and back color buffers (front left, front right, back left, back right) are written. If there are no back color buffers, only the front left and front right color buffers are written. If there are no right color buffers, only the front left and back left color buffers are written. If there are no right or back color buffers, only the front left color buffer is written.\n\nIf more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer.\n\nMonoscopic contexts include only *left* buffers, and stereoscopic contexts include both *left* and *right* buffers. Likewise, single-buffered contexts include only *front* buffers, and double-buffered contexts include both *front* and *back* buffers. The context is selected at GL initialization.\n\nFor framebuffer objects, `GL_COLOR_ATTACHMENT$m$` and `GL_NONE` enums are accepted, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`. glDrawBuffer will set the draw buffer for fragment colors other than zero to `GL_NONE`.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated by `glNamedFramebufferDrawBuffer` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`buf`* is not an accepted value.\n\n`GL_INVALID_OPERATION` is generated if the default framebuffer is affected and none of the buffers indicated by *`buf`* exists.\n\n`GL_INVALID_OPERATION` is generated if a framebuffer object is affected and *`buf`* is not equal to `GL_NONE` or `GL_COLOR_ATTACHMENT$m$`, where `$m$` is a value between 0 and `GL_MAX_COLOR_ATTACHMENTS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_DRAW_BUFFER`\n\n## Version Support\n\n|                                |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:-------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**   |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glDrawBuffer`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glNamedFramebufferDrawBuffer` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBlendFunc](glblendfunc.xhtml), [glColorMask](glcolormask.xhtml), [glDrawBuffers](gldrawbuffers.xhtml), [glLogicOp](gllogicop.xhtml), [glReadBuffer](glreadbuffer.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawBuffer.xhtml)"
- name: glNamedFramebufferDrawBuffers
  id: gldrawbuffers.xhtml#glNamedFramebufferDrawBuffers
  summary: Specifies the name of the framebuffer object for glNamedFramebufferDrawBuffers
  belongs_to: glDrawBuffers
  description: "`void `**`glNamedFramebufferDrawBuffers`**`(` GLuint `framebuffer`, GLsizei `n`, const GLenum \\*`bufs``)`;\n\n## Parameters\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glNamedFramebufferDrawBuffers`.\n\n*`n`*\n\nSpecifies the number of buffers in *`bufs`*.\n\n*`bufs`*\n\nPoints to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.\n\n## Description\n\n`glDrawBuffers` and `glNamedFramebufferDrawBuffers` define an array of buffers into which outputs from the fragment shader data will be written. If a fragment shader writes a value to one or more user defined output variables, then the value of each variable will be written into the buffer specified at a location within *`bufs`* corresponding to the location assigned to that user defined output. The draw buffer used for user defined outputs assigned to locations greater than or equal to *`n`* is implicitly set to `GL_NONE` and any data written to such an output is discarded.\n\nFor `glDrawBuffers`, the framebuffer object that is bound to the `GL_DRAW_FRAMEBUFFER` binding will be used. For `glNamedFramebufferDrawBuffers`, *`framebuffer`* is the name of the framebuffer object. If *`framebuffer`* is zero, then the default framebuffer is affected.\n\nThe symbolic constants contained in *`bufs`* may be any of the following:\n\n`GL_NONE`\n\nThe fragment shader output value is not written into any color buffer.\n\n`GL_FRONT_LEFT`\n\nThe fragment shader output value is written into the front left color buffer.\n\n`GL_FRONT_RIGHT`\n\nThe fragment shader output value is written into the front right color buffer.\n\n`GL_BACK_LEFT`\n\nThe fragment shader output value is written into the back left color buffer.\n\n`GL_BACK_RIGHT`\n\nThe fragment shader output value is written into the back right color buffer.\n\n`GL_COLOR_ATTACHMENT` *n*\n\nThe fragment shader output value is written into the *n*th color attachment of the current framebuffer. *n* may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS`.\n\nExcept for `GL_NONE`, the preceding symbolic constants may not appear more than once in *`bufs`*. The maximum number of draw buffers supported is implementation dependent and can be queried by calling [glGet](glget.xhtml) with the argument `GL_MAX_DRAW_BUFFERS`.\n\n## Notes\n\nThe symbolic constants `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and `GL_FRONT_AND_BACK` are not allowed in the *`bufs`* array since they may refer to multiple buffers.\n\nIf a fragment shader does not write to a user defined output variable, the values of the fragment colors following shader execution are undefined. For each fragment generated in this situation, a different value may be written into each of the buffers specified by *`bufs`*.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated by `glNamedFramebufferDrawBuffers` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if one of the values in *`bufs`* is not an accepted value.\n\n`GL_INVALID_ENUM` is generated if the API call refers to the default framebuffer and one or more of the values in *`bufs`* is one of the `GL_COLOR_ATTACHMENT`*n* tokens.\n\n`GL_INVALID_ENUM` is generated if the API call refers to a framebuffer object and one or more of the values in *`bufs`* is anything other than `GL_NONE` or one of the `GL_COLOR_ATTACHMENT`*n* tokens.\n\n`GL_INVALID_ENUM` is generated if *`n`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if a symbolic constant other than `GL_NONE` appears more than once in *`bufs`*.\n\n`GL_INVALID_OPERATION` is generated if any of the entries in *`bufs`* (other than `GL_NONE` ) indicates a color buffer that does not exist in the current GL context.\n\n`GL_INVALID_OPERATION` is generated if any value in *`bufs`* is `GL_BACK`, and *`n`* is not one.\n\n`GL_INVALID_VALUE` is generated if *`n`* is greater than `GL_MAX_DRAW_BUFFERS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_DRAW_BUFFERS`\n\n[glGet](glget.xhtml) with argument `GL_DRAW_BUFFER`*i* where *`i`* indicates the number of the draw buffer whose value is to be queried.\n\n## Version Support\n\n|                                 |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**    |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glDrawBuffers`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glNamedFramebufferDrawBuffers` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBlendFunc](glblendfunc.xhtml), [glColorMask](glcolormask.xhtml), [glDrawBuffers](gldrawbuffers.xhtml), [glLogicOp](gllogicop.xhtml), [glReadBuffer](glreadbuffer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawBuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glDrawBuffers.xhtml)"
- name: glNamedFramebufferParameteri
  id: glframebufferparameteri.xhtml#glNamedFramebufferParameteri
  summary: Specifies the target to which the framebuffer is bound for glFramebufferParameteri
  belongs_to: glFramebufferParameteri
  description: "`void `**`glNamedFramebufferParameteri`**`(` GLuint `framebuffer`, GLenum `pname`, GLint `param``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the framebuffer is bound for `glFramebufferParameteri`.\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glNamedFramebufferParameteri`.\n\n*`pname`*\n\nSpecifies the framebuffer parameter to be modified.\n\n*`param`*\n\nThe new value for the parameter named *`pname`*.\n\n## Description\n\n`glFramebufferParameteri` and `glNamedFramebufferParameteri` modify the value of the parameter named *`pname`* in the specified framebuffer object. There are no modifiable parameters of the default draw and read framebuffer, so they are not valid targets of these commands.\n\nFor `glFramebufferParameteri`, the framebuffer object is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glNamedFramebufferParameteri`, *`framebuffer`* is the name of the framebuffer object.\n\n*`pname`* specifies the parameter to be modified. The following values are accepted:\n\n`GL_FRAMEBUFFER_DEFAULT_WIDTH`\n\n*`param`* specifies the assumed width for a framebuffer object with no attachments. If a framebuffer has attachments then the width of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_WIDTH` is used for the framebuffer. *`param`* must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_WIDTH`.\n\n`GL_FRAMEBUFFER_DEFAULT_HEIGHT`\n\n*`param`* specifies the assumed height for a framebuffer object with no attachments. If a framebuffer has attachments then the height of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_HEIGHT` is used for the framebuffer. *`param`* must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_HEIGHT`.\n\n`GL_FRAMEBUFFER_DEFAULT_LAYERS`\n\n*`param`* specifies the assumed number of layers for a framebuffer object with no attachments. If a framebuffer has attachments then the layer count of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_LAYERS` is used for the framebuffer. *`param`* must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_LAYERS`.\n\n`GL_FRAMEBUFFER_DEFAULT_SAMPLES`\n\n*`param`* specifies the assumed number of samples in a framebuffer object with no attachments. If a framebuffer has attachments then the sample count of those attachments is used, otherwise the value of `GL_FRAMEBUFFER_DEFAULT_SAMPLES` is used for the framebuffer. *`param`* must be greater than or equal to zero and less than or equal to the value of `GL_MAX_FRAMEBUFFER_SAMPLE`.\n\n`GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS`\n\n*`param`* specifies whether the framebuffer should assume identical sample locations and the same number of samples for all texels in the virtual image. If *`param`* is zero, then the implementation may vary the position or the count of samples within the virtual image from pixel to pixel, otherwise it will use the same sample position and count for all pixels in the virtual image.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glFramebufferParameteri` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glFramebufferParameteri` if the default framebuffer is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferParameteri` if *`framebuffer`* is not the name of an existing framebuffer object.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_FRAMEBUFFER_DEFAULT_WIDTH` and *`param`* is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_WIDTH`.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_FRAMEBUFFER_DEFAULT_HEIGHT` and *`param`* is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_HEIGHT`.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_FRAMEBUFFER_DEFAULT_LAYERS` and *`param`* is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_LAYERS`.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_FRAMEBUFFER_DEFAULT_SAMPLES` and *`param`* is less than zero or greater than the value of `GL_MAX_FRAMEBUFFER_SAMPLES`.\n\n## Associated Gets\n\n`glGetFramebufferParameteriv`.\n\n## Version Support\n\n|                                |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:-------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**   |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glFramebufferParameteri`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glNamedFramebufferParameteri` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBindFramebuffer](glbindframebuffer.xhtml), [glCreateFramebuffers](glcreateframebuffers.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml), [glGenFramebuffers](glgenframebuffers.xhtml), [glGetFramebufferParameter](glgetframebufferparameter.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferParameteri.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferParameteri.xhtml)"
- name: glNamedFramebufferReadBuffer
  id: glreadbuffer.xhtml#glNamedFramebufferReadBuffer
  summary: Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function
  belongs_to: glReadBuffer
  description: "`void `**`glNamedFramebufferReadBuffer`**`(` GLuint `framebuffer`, GLenum `mode``)`;\n\n## Parameters\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glNamedFramebufferReadBuffer` function.\n\n*`mode`*\n\nSpecifies a color buffer. Accepted values are `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and the constants `GL_COLOR_ATTACHMENT`*i*.\n\n## Description\n\n`glReadBuffer` specifies a color buffer as the source for subsequent [glReadPixels](glreadpixels.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), and [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml) commands. *`mode`* accepts one of twelve or more predefined values. In a fully configured system, `GL_FRONT`, `GL_LEFT`, and `GL_FRONT_LEFT` all name the front left buffer, `GL_FRONT_RIGHT` and `GL_RIGHT` name the front right buffer, and `GL_BACK_LEFT` and `GL_BACK` name the back left buffer. Further more, the constants `GL_COLOR_ATTACHMENT`*i* may be used to indicate the *i*^(th) color attachment where *i* ranges from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one.\n\nNonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify a nonexistent buffer to `glReadBuffer`.\n\n*`mode`* is initially `GL_FRONT` in single-buffered configurations and `GL_BACK` in double-buffered configurations.\n\nFor `glReadBuffer`, the target framebuffer object is that bound to `GL_READ_FRAMEBUFFER`. For `glNamedFramebufferReadBuffer`, *`framebuffer`* must either be zero or the name of the target framebuffer object. If *`framebuffer`* is zero, then the default read framebuffer is affected.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of the twelve (or more) accepted values.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* specifies a buffer that does not exist.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferReadBuffer` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_READ_BUFFER`\n\n## Version Support\n\n|                                |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:-------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**   |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glNamedFramebufferReadBuffer` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glReadBuffer`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glDrawBuffer](gldrawbuffer.xhtml), [glReadPixels](glreadpixels.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glReadBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glReadBuffer.xhtml)"
- name: glNamedFramebufferRenderbuffer
  id: glframebufferrenderbuffer.xhtml#glNamedFramebufferRenderbuffer
  summary: Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer
  belongs_to: glFramebufferRenderbuffer
  description: "`void `**`glNamedFramebufferRenderbuffer`**`(` GLuint `framebuffer`, GLenum `attachment`, GLenum `renderbuffertarget`, GLuint `renderbuffer``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the framebuffer is bound for `glFramebufferRenderbuffer`.\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glNamedFramebufferRenderbuffer`.\n\n*`attachment`*\n\nSpecifies the attachment point of the framebuffer.\n\n*`renderbuffertarget`*\n\nSpecifies the renderbuffer target. Must be `GL_RENDERBUFFER`.\n\n*`renderbuffer`*\n\nSpecifies the name of an existing renderbuffer object of type *`renderbuffertarget`* to attach.\n\n## Description\n\n`glFramebufferRenderbuffer` and `glNamedFramebufferRenderbuffer` attaches a renderbuffer as one of the logical buffers of the specified framebuffer object. Renderbuffers cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands.\n\nFor `glFramebufferRenderbuffer`, the framebuffer object is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glNamedFramebufferRenderbuffer`, *`framebuffer`* is the name of the framebuffer object.\n\n*`renderbuffertarget`* must be `GL_RENDERBUFFER`.\n\n*`renderbuffer`* must be zero or the name of an existing renderbuffer object of type *`renderbuffertarget`*. If *`renderbuffer`* is not zero, then the specified renderbuffer will be used as the logical buffer identified by *`attachment`* of the specified framebuffer object. If *`renderbuffer`* is zero, then the value of *`renderbuffertarget`* is ignored.\n\n*`attachment`* specifies the logical attachment of the framebuffer and must be `GL_COLOR_ATTACHMENT`*i*, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. *i* in may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one. Setting *`attachment`* to the value `GL_DEPTH_STENCIL_ATTACHMENT` is a special case causing both the depth and stencil attachments of the specified framebuffer object to be set to *`renderbuffer`*, which should have the base internal format `GL_DEPTH_STENCIL`.\n\nThe value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE` for the specified attachment point is set to `GL_RENDERBUFFER` and the value of `GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME` is set to *`renderbuffer`*. All other state values of specified attachment point are set to their default values. No change is made to the state of the renderbuuffer object and any previous attachment to the *`attachment`* logical buffer of the specified framebuffer object is broken.\n\nIf *`renderbuffer`* is zero, these commands will detach the image, if any, identified by the specified attachment point of the specified framebuffer object. All state values of the attachment point are set to their default values.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glFramebufferRenderbuffer` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glFramebufferRenderbuffer` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferRenderbuffer` if *`framebuffer`* is not the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`attachment`* is not one of the accepted attachment points.\n\n`GL_INVALID_ENUM` is generated if *`renderbuffertarget`* is not `GL_RENDERBUFFER`.\n\n`GL_INVALID_OPERATION` is generated if *`renderbuffertarget`* is not zero or the name of an existing renderbuffer object of type `GL_RENDERBUFFER`.\n\n## Version Support\n\n|                                  |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:---------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**     |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glFramebufferRenderbuffer`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glNamedFramebufferRenderbuffer` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml), [glGenRenderbuffers](glgenrenderbuffers.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml), `glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferRenderbuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferRenderbuffer.xhtml)"
- name: glNamedFramebufferTexture
  id: glframebuffertexture.xhtml#glNamedFramebufferTexture
  summary: Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture
  belongs_to: glFramebufferTexture
  description: "`void `**`glNamedFramebufferTexture`**`(` GLuint `framebuffer`, GLenum `attachment`, GLuint `texture`, GLint `level``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the framebuffer is bound for all commands *except* `glNamedFramebufferTexture`.\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glNamedFramebufferTexture`.\n\n*`attachment`*\n\nSpecifies the attachment point of the framebuffer.\n\n*`textarget`*\n\nFor `glFramebufferTexture1D`, `glFramebufferTexture2D` and `glFramebufferTexture3D`, specifies what type of texture is expected in the *`texture`* parameter, or for cube map textures, which face is to be attached.\n\n*`texture`*\n\nSpecifies the name of an existing texture object to attach.\n\n*`level`*\n\nSpecifies the mipmap level of the texture object to attach.\n\n## Description\n\nThese commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands.\n\nFor all commands *except* `glNamedFramebufferTexture`, the framebuffer object is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glNamedFramebufferTexture`, *`framebuffer`* is the name of the framebuffer object.\n\n*`attachment`* specifies the logical attachment of the framebuffer and must be `GL_COLOR_ATTACHMENT`*i*, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. *i* in `GL_COLOR_ATTACHMENT`*i* may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one. Attaching a level of a texture to `GL_DEPTH_STENCIL_ATTACHMENT` is equivalent to attaching that level to both the `GL_DEPTH_ATTACHMENT` *and* the `GL_STENCIL_ATTACHMENT` attachment points simultaneously.\n\nFor `glFramebufferTexture1D`, `glFramebufferTexture2D` and `glFramebufferTexture3D`, *`textarget`* specifies what type of texture is named by *`texture`*, and for cube map textures, specifies the face that is to be attached. If *`texture`* is not zero, it must be the name of an existing texture object with effective target *`textarget`* unless it is a cube map texture, in which case *`textarget`* must be `GL_TEXTURE_CUBE_MAP_POSITIVE_X` `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.\n\nIf *`texture`* is non-zero, the specified *`level`* of the texture object named *`texture`* is attached to the framebuffer attachment point named by *`attachment`*. For `glFramebufferTexture1D`, `glFramebufferTexture2D`, and `glFramebufferTexture3D`, *`texture`* must be zero or the name of an existing texture with an effective target of *`textarget`*, or *`texture`* must be the name of an existing cube-map texture and *`textarget`* must be one of `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.\n\nIf *`textarget`* is `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_2D_MULTISAMPLE`, or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, then *`level`* must be zero.\n\nIf *`textarget`* is `GL_TEXTURE_3D`, then *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_3D_TEXTURE_SIZE`.\n\nIf *`textarget`* is one of `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, then *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_CUBE_MAP_TEXTURE_SIZE`.\n\nFor all other values of *`textarget`*, *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_TEXTURE_SIZE`.\n\n*`layer`* specifies the layer of a 2-dimensional image within a 3-dimensional texture.\n\nFor `glFramebufferTexture1D`, if *`texture`* is not zero, then *`textarget`* must be `GL_TEXTURE_1D`. For `glFramebufferTexture2D`, if *`texture`* is not zero, *`textarget`* must be one of `GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_2D_MULTISAMPLE`. For `glFramebufferTexture3D`, if *`texture`* is not zero, then *`textarget`* must be `GL_TEXTURE_3D`.\n\nFor `glFramebufferTexture` and `glNamedFramebufferTexture`, if *`texture`* is the name of a three-dimensional, cube map array, cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an array of images, and the framebuffer attachment is considered to be *layered*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by all commands accepting a *`target`* parameter if it is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by all commands accepting a *`target`* parameter if zero is bound to that target.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferTexture` if *`framebuffer`* is not the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`attachment`* is not one of the accepted attachment points.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero or the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero and *`level`* is not a supported texture level for *`texture`*.\n\n`GL_INVALID_VALUE` is generated by `glFramebufferTexture3D` if *`texture`* is not zero and *`layer`* is larger than the value of `GL_MAX_3D_TEXTURE_SIZE` minus one.\n\n`GL_INVALID_OPERATION` is generated by all commands accepting a *`textarget`* parameter if *`texture`* is not zero, and *`textarget`* and the effective target of *`texture`* are not compatible.\n\n`GL_INVALID_OPERATION` is generated by if *`texture`* is a buffer texture.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glFramebufferTexture`        |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glFramebufferTexture1D`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glFramebufferTexture2D`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glFramebufferTexture3D`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glNamedFramebufferTexture`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml), [glGenRenderbuffers](glgenrenderbuffers.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml), `glFramebufferTexture1D`, `glFramebufferTexture2D`, `glFramebufferTexture3D`\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferTexture.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferTexture.xhtml)"
- name: glNamedFramebufferTextureLayer
  id: glframebuffertexturelayer.xhtml#glNamedFramebufferTextureLayer
  summary: Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer
  belongs_to: glFramebufferTextureLayer
  description: "`void `**`glNamedFramebufferTextureLayer`**`(` GLuint `framebuffer`, GLenum `attachment`, GLuint `texture`, GLint `level`, GLint `layer``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the framebuffer is bound for `glFramebufferTextureLayer`.\n\n*`framebuffer`*\n\nSpecifies the name of the framebuffer object for `glNamedFramebufferTextureLayer`.\n\n*`attachment`*\n\nSpecifies the attachment point of the framebuffer.\n\n*`texture`*\n\nSpecifies the name of an existing texture object to attach.\n\n*`level`*\n\nSpecifies the mipmap level of the texture object to attach.\n\n*`layer`*\n\nSpecifies the layer of the texture object to attach.\n\n## Description\n\n`glFramebufferTextureLayer` and `glNamedFramebufferTextureLayer` attach a single layer of a three-dimensional or array texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands.\n\nFor `glFramebufferTextureLayer`, the framebuffer object is that bound to *`target`*, which must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER`, or `GL_FRAMEBUFFER`. `GL_FRAMEBUFFER` is equivalent to `GL_DRAW_FRAMEBUFFER`.\n\nFor `glNamedFramebufferTextureLayer`, *`framebuffer`* is the name of the framebuffer object.\n\n*`attachment`* specifies the logical attachment of the framebuffer and must be `GL_COLOR_ATTACHMENT`*i*, `GL_DEPTH_ATTACHMENT`, `GL_STENCIL_ATTACHMENT` or `GL_DEPTH_STENCIL_ATTACHMENT`. *i* in `GL_COLOR_ATTACHMENT`*i* may range from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one. Attaching a level of a texture to `GL_DEPTH_STENCIL_ATTACHMENT` is equivalent to attaching that level to both the `GL_DEPTH_ATTACHMENT` *and* the `GL_STENCIL_ATTACHMENT` attachment points simultaneously.\n\nIf *`texture`* is not zero, it must be the name of a three-dimensional, two-dimensional multisample array, one- or two-dimensional array, or cube map array texture.\n\nIf *`texture`* is a three-dimensional texture, then *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_3D_TEXTURE_SIZE`.\n\nIf *`texture`* is a two-dimensional array texture, then *`level`* must be greater than or equal to zero and less than or equal to $log_2$ of the value of `GL_MAX_TEXTURE_SIZE`.\n\nFor cube map textures, *`layer`* is translated into a cube map face according to $$ face = k \\bmod 6. $$ For cube map array textures, *`layer`* is translated into an array layer and face according to $$ layer = \\left\\lfloor { layer \\over 6 } \\right\\rfloor$$ and $$ face = k \\bmod 6. $$\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glFramebufferTexture` if *`target`* is not one of the accepted framebuffer targets.\n\n`GL_INVALID_OPERATION` is generated by `glFramebufferTexture` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferTexture` if *`framebuffer`* is not the name of an existing framebuffer object.\n\n`GL_INVALID_ENUM` is generated if *`attachment`* is not one of the accepted attachment points.\n\n`GL_INVALID_OPERATION` is generated if *`texture`* is not zero and is not the name of an existing three-dimensional, two-dimensional multisample array, one- or two-dimensional array, cube map, or cube map array texture.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero and *`level`* is not a supported texture level for *`texture`*, as described above.\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero and *`layer`* is larger than the value of `GL_MAX_3D_TEXTURE_SIZE` minus one (for three-dimensional texture objects), or larger than the value of `GL_MAX_ARRAY_TEXTURE_LAYERS` minus one (for array texture objects).\n\n`GL_INVALID_VALUE` is generated if *`texture`* is not zero and *`layer`* is negative.\n\n`GL_INVALID_OPERATION` is generated by if *`texture`* is a buffer texture.\n\n## Version Support\n\n|                                  |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:---------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**     |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glFramebufferTextureLayer`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glNamedFramebufferTextureLayer` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glGenFramebuffers](glgenframebuffers.xhtml), [glBindFramebuffer](glbindframebuffer.xhtml), [glGenRenderbuffers](glgenrenderbuffers.xhtml), [glFramebufferTexture](glframebuffertexture.xhtml),\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferTextureLayer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glFramebufferTextureLayer.xhtml)"
- name: glNamedRenderbufferStorage
  id: glrenderbufferstorage.xhtml#glNamedRenderbufferStorage
  summary: Specifies a binding target of the allocation for glRenderbufferStorage function
  belongs_to: glRenderbufferStorage
  description: "`void `**`glNamedRenderbufferStorage`**`(` GLuint `renderbuffer`, GLenum `internalformat`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies a binding target of the allocation for `glRenderbufferStorage` function. Must be `GL_RENDERBUFFER`.\n\n*`renderbuffer`*\n\nSpecifies the name of the renderbuffer object for `glNamedRenderbufferStorage` function.\n\n*`internalformat`*\n\nSpecifies the internal format to use for the renderbuffer object's image.\n\n*`width`*\n\nSpecifies the width of the renderbuffer, in pixels.\n\n*`height`*\n\nSpecifies the height of the renderbuffer, in pixels.\n\n## Description\n\n`glRenderbufferStorage` is equivalent to calling [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml) with the *`samples`* set to zero, and `glNamedRenderbufferStorage` is equivalent to calling `glNamedRenderbufferStorageMultisample` with the samples set to zero.\n\nFor `glRenderbufferStorage`, the target of the operation, specified by *`target`* must be `GL_RENDERBUFFER`. For `glNamedRenderbufferStorage`, *`renderbuffer`* must be a name of an existing renderbuffer object. *`internalformat`* specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. *`width`* and *`height`* are the dimensions, in pixels, of the renderbuffer. Both *`width`* and *`height`* must be less than or equal to the value of `GL_MAX_RENDERBUFFER_SIZE`.\n\nUpon success, `glRenderbufferStorage` and `glNamedRenderbufferStorage` delete any existing data store for the renderbuffer image and the contents of the data store after calling `glRenderbufferStorage` are undefined.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glRenderbufferStorage` if *`target`* is not `GL_RENDERBUFFER`.\n\n`GL_INVALID_OPERATION` is generated by glNamedRenderbufferStorage if *`renderbuffer`* is not the name of an existing renderbuffer object.\n\n`GL_INVALID_VALUE` is generated if either of *`width`* or *`height`* is negative, or greater than the value of `GL_MAX_RENDERBUFFER_SIZE`.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a color-renderable, depth-renderable, or stencil-renderable format.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store of the requested size.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glNamedRenderbufferStorage`  |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glRenderbufferStorage`       |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGenRenderbuffers](glgenrenderbuffers.xhtml), [glBindRenderbuffer](glbindrenderbuffer.xhtml), `glNamedRenderbufferStorageMultisample`, [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glDeleteRenderbuffers](gldeleterenderbuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glRenderbufferStorage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glRenderbufferStorage.xhtml)"
- name: glNamedRenderbufferStorageMultisample
  id: glrenderbufferstoragemultisample.xhtml#glNamedRenderbufferStorageMultisample
  summary: Specifies a binding target of the allocation for glRenderbufferStorageMultisample function
  belongs_to: glRenderbufferStorageMultisample
  description: "`void `**`glNamedRenderbufferStorageMultisample`**`(` GLuint `renderbuffer`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies a binding target of the allocation for `glRenderbufferStorageMultisample` function. Must be `GL_RENDERBUFFER`.\n\n*`renderbuffer`*\n\nSpecifies the name of the renderbuffer object for `glNamedRenderbufferStorageMultisample` function.\n\n*`samples`*\n\nSpecifies the number of samples to be used for the renderbuffer object's storage.\n\n*`internalformat`*\n\nSpecifies the internal format to use for the renderbuffer object's image.\n\n*`width`*\n\nSpecifies the width of the renderbuffer, in pixels.\n\n*`height`*\n\nSpecifies the height of the renderbuffer, in pixels.\n\n## Description\n\n`glRenderbufferStorageMultisample` and `glNamedRenderbufferStorageMultisample` establish the data storage, format, dimensions and number of samples of a renderbuffer object's image.\n\nFor `glRenderbufferStorageMultisample`, the target of the operation, specified by *`target`* must be `GL_RENDERBUFFER`. For `glNamedRenderbufferStorageMultisample`, *`renderbuffer`* must be an ID of an existing renderbuffer object. *`internalformat`* specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. *`width`* and *`height`* are the dimensions, in pixels, of the renderbuffer. Both *`width`* and *`height`* must be less than or equal to the value of `GL_MAX_RENDERBUFFER_SIZE`. *`samples`* specifies the number of samples to be used for the renderbuffer object's image, and must be less than or equal to the value of `GL_MAX_SAMPLES`. If *`internalformat`* is a signed or unsigned integer format then *`samples`* must be less than or equal to the value of `GL_MAX_INTEGER_SAMPLES`.\n\nUpon success, `glRenderbufferStorageMultisample` and `glNamedRenderbufferStorageMultisample` delete any existing data store for the renderbuffer image and the contents of the data store after calling either of the functions are undefined.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glRenderbufferStorageMultisample` function if *`target`* is not `GL_RENDERBUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glNamedRenderbufferStorageMultisample` function if *`renderbuffer`* is not the name of an existing renderbuffer object.\n\n`GL_INVALID_OPERATION` is generated if *`samples`* is greater than the maximum number of samples supported for *`internalformat`*.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a color-renderable, depth-renderable, or stencil-renderable format.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is a signed or unsigned integer format and *`samples`* is greater than the value of `GL_MAX_INTEGER_SAMPLES`\n\n`GL_INVALID_VALUE` is generated if either of *`width`* or *`height`* is negative, or greater than the value of `GL_MAX_RENDERBUFFER_SIZE`.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store of the requested size.\n\n## Version Support\n\n|                                         |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:----------------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**            |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glNamedRenderbufferStorageMultisample` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glRenderbufferStorageMultisample`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGenRenderbuffers](glgenrenderbuffers.xhtml), [glBindRenderbuffer](glbindrenderbuffer.xhtml), `glNamedRenderbufferStorage`, [glRenderbufferStorage](glrenderbufferstorage.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glDeleteRenderbuffers](gldeleterenderbuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glRenderbufferStorageMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glRenderbufferStorageMultisample.xhtml)"
- name: glObjectLabel
  id: globjectlabel.xhtml
  summary: identifier The namespace from which the name of the object is allocated
  description: "## Name\n\nglObjectLabel — label a named object identified within a namespace\n\n## C Specification\n\n`void `**`glObjectLabel`**`(` GLenum `identifier`, GLuint `name`, GLsizei `length`, const char \\* `label``)`;\n\n## Parameters\n\n *`identifier`*  \nThe namespace from which the name of the object is allocated.\n\n *`name`*  \nThe name of the object to label.\n\n *`length`*  \nThe length of the label to be used for the object.\n\n *`label`*  \nThe address of a string containing the label to assign to the object.\n\n## Description\n\n`glObjectLabel` labels the object identified by *`name`* within the namespace given by *`identifier`*. *`identifier`* must be one of `GL_BUFFER`, `GL_SHADER`, `GL_PROGRAM`, `GL_VERTEX_ARRAY`, `GL_QUERY`, `GL_PROGRAM_PIPELINE`, `GL_TRANSFORM_FEEDBACK`, `GL_SAMPLER`, `GL_TEXTURE`, `GL_RENDERBUFFER`, `GL_FRAMEBUFFER`, to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively.\n\n*`label`* is the address of a string that will be used to label an object. *`length`* contains the number of characters in *`label`*. If *`length`* is negative, it is implied that *`label`* contains a null-terminated string. If *`label`* is NULL, any debug label is effectively removed from the object.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`identifier`* is not one of the accepted object types.\n\n`GL_INVALID_OPERATION` is generated if *`name`* is not the name of an existing object of the type specified by *`identifier`*.\n\n`GL_INVALID_VALUE` is generated if the number of characters in *`label`*, excluding the null terminator when *`length`* is negative, is greater than the value of `GL_MAX_LABEL_LENGTH`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_LABEL_LENGTH`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glObjectLabel`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glPushDebugGroup](glpushdebuggroup.xhtml), [glPopDebugGroup](glpopdebuggroup.xhtml), [glObjectPtrLabel](globjectptrlabel.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glObjectLabel.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glObjectLabel.xhtml)"
- name: glObjectPtrLabel
  id: globjectptrlabel.xhtml
  summary: ptr A pointer identifying a sync object
  description: "## Name\n\nglObjectPtrLabel — label a sync object identified by a pointer\n\n## C Specification\n\n`void `**`glObjectPtrLabel`**`(` void \\* `ptr`, GLsizei `length`, const char \\* `label``)`;\n\n## Parameters\n\n *`ptr`*  \nA pointer identifying a sync object.\n\n *`length`*  \nThe length of the label to be used for the object.\n\n *`label`*  \nThe address of a string containing the label to assign to the object.\n\n## Description\n\n`glObjectPtrLabel` labels the sync object identified by *`ptr`*.\n\n*`label`* is the address of a string that will be used to label the object. *`length`* contains the number of characters in *`label`*. If *`length`* is negative, it is implied that *`label`* contains a null-terminated string. If *`label`* is NULL, any debug label is effectively removed from the object.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`ptr`* is not a valid sync object.\n\n`GL_INVALID_VALUE` is generated if the number of characters in *`label`*, excluding the null terminator when *`length`* is negative, is greater than the value of `GL_MAX_LABEL_LENGTH`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_LABEL_LENGTH`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glObjectPtrLabel`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glPushDebugGroup](glpushdebuggroup.xhtml), [glPopDebugGroup](glpopdebuggroup.xhtml), [glObjectLabel](globjectlabel.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glObjectPtrLabel.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glObjectPtrLabel.xhtml)"
- name: glPatchParameter
  id: glpatchparameter.xhtml
  summary: pname Specifies the name of the parameter to set
  description: "## Name\n\nglPatchParameter — specifies the parameters for patch primitives\n\n## C Specification\n\n`void `**`glPatchParameteri`**`(` GLenum `pname`, GLint `value``)`;\n\n`void `**`glPatchParameterfv`**`(` GLenum `pname`, const GLfloat \\*`values``)`;\n\n## Parameters\n\n *`pname`*  \nSpecifies the name of the parameter to set. The symbolc constants `GL_PATCH_VERTICES`, `GL_PATCH_DEFAULT_OUTER_LEVEL`, and `GL_PATCH_DEFAULT_INNER_LEVEL` are accepted.\n\n *`value`*  \nSpecifies the new value for the parameter given by *`pname`*.\n\n *`values`*  \nSpecifies the address of an array containing the new values for the parameter given by *`pname`*.\n\n## Description\n\n`glPatchParameter` specifies the parameters that will be used for patch primitives. *`pname`* specifies the parameter to modify and must be either `GL_PATCH_VERTICES`, `GL_PATCH_DEFAULT_OUTER_LEVEL` or `GL_PATCH_DEFAULT_INNER_LEVEL`. For `glPatchParameteri`, *`value`* specifies the new value for the parameter specified by *`pname`*. For `glPatchParameterfv`, *`values`* specifies the address of an array containing the new values for the parameter specified by *`pname`*.\n\nWhen *`pname`* is `GL_PATCH_VERTICES`, *`value`* specifies the number of vertices that will be used to make up a single patch primitive. Patch primitives are consumed by the tessellation control shader (if present) and subsequently used for tessellation. When primitives are specified using [glDrawArrays](gldrawarrays.xhtml) or a similar function, each patch will be made from *`parameter`* control points, each represented by a vertex taken from the enabeld vertex arrays. *`parameter`* must be greater than zero, and less than or equal to the value of `GL_MAX_PATCH_VERTICES`.\n\nWhen *`pname`* is `GL_PATCH_DEFAULT_OUTER_LEVEL` or `GL_PATCH_DEFAULT_INNER_LEVEL`, *`values`* contains the address of an array contiaining the default outer or inner tessellation levels, respectively, to be used when no tessellation control shader is present.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_PATCH_VERTICES` and *`value`* is less than or equal to zero, or greater than the value of `GL_MAX_PATCH_VERTICES`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPatchParameterfv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glPatchParameteri`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml),\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPatchParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPatchParameter.xhtml)"
- name: glPatchParameterfv
  id: glpatchparameter.xhtml#glPatchParameterfv
  summary: Specifies the name of the parameter to set
  belongs_to: glPatchParameter
  description: "`void `**`glPatchParameterfv`**`(` GLenum `pname`, const GLfloat \\*`values``)`;\n\n## Parameters\n\n*`pname`*\n\nSpecifies the name of the parameter to set. The symbolc constants `GL_PATCH_VERTICES`, `GL_PATCH_DEFAULT_OUTER_LEVEL`, and `GL_PATCH_DEFAULT_INNER_LEVEL` are accepted.\n\n*`value`*\n\nSpecifies the new value for the parameter given by *`pname`*.\n\n*`values`*\n\nSpecifies the address of an array containing the new values for the parameter given by *`pname`*.\n\n## Description\n\n`glPatchParameter` specifies the parameters that will be used for patch primitives. *`pname`* specifies the parameter to modify and must be either `GL_PATCH_VERTICES`, `GL_PATCH_DEFAULT_OUTER_LEVEL` or `GL_PATCH_DEFAULT_INNER_LEVEL`. For `glPatchParameteri`, *`value`* specifies the new value for the parameter specified by *`pname`*. For `glPatchParameterfv`, *`values`* specifies the address of an array containing the new values for the parameter specified by *`pname`*.\n\nWhen *`pname`* is `GL_PATCH_VERTICES`, *`value`* specifies the number of vertices that will be used to make up a single patch primitive. Patch primitives are consumed by the tessellation control shader (if present) and subsequently used for tessellation. When primitives are specified using [glDrawArrays](gldrawarrays.xhtml) or a similar function, each patch will be made from *`parameter`* control points, each represented by a vertex taken from the enabeld vertex arrays. *`parameter`* must be greater than zero, and less than or equal to the value of `GL_MAX_PATCH_VERTICES`.\n\nWhen *`pname`* is `GL_PATCH_DEFAULT_OUTER_LEVEL` or `GL_PATCH_DEFAULT_INNER_LEVEL`, *`values`* contains the address of an array contiaining the default outer or inner tessellation levels, respectively, to be used when no tessellation control shader is present.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_PATCH_VERTICES` and *`value`* is less than or equal to zero, or greater than the value of `GL_MAX_PATCH_VERTICES`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glPatchParameterfv`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glPatchParameteri`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawArraysInstanced](gldrawarraysinstanced.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml),\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPatchParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPatchParameter.xhtml)"
- name: glPatchParameteri
  id: glpatchparameter.xhtml#glPatchParameteri
  summary: null
  belongs_to: glPatchParameter
  description: '`void `**`glPatchParameteri`**`(` GLenum `pname`, GLint `value``)`;'
- name: glPauseTransformFeedback
  id: glpausetransformfeedback.xhtml
  summary: glPauseTransformFeedback pauses transform feedback operations on the currently active transform feedback object
  description: "## Name\n\nglPauseTransformFeedback — pause transform feedback operations\n\n## C Specification\n\n`void `**`glPauseTransformFeedback`**`(` void`)`;\n\n## Description\n\n`glPauseTransformFeedback` pauses transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if the currently bound transform feedback object is not active or is paused.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPauseTransformFeedback`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenTransformFeedbacks](glgentransformfeedbacks.xhtml), [glBindTransformFeedback](glbindtransformfeedback.xhtml), [glBeginTransformFeedback](glbegintransformfeedback.xhtml), [glResumeTransformFeedback](glresumetransformfeedback.xhtml), `glEndTransformFeedback`, [glDeleteTransformFeedbacks](gldeletetransformfeedbacks.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPauseTransformFeedback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPauseTransformFeedback.xhtml)"
- name: glPixelStore
  id: glpixelstore.xhtml
  summary: pname Specifies the symbolic name of the parameter to be set
  description: "## Name\n\nglPixelStore — set pixel storage modes\n\n## C Specification\n\n`void `**`glPixelStoref`**`(` GLenum `pname`, GLfloat `param``)`;\n\n`void `**`glPixelStorei`**`(` GLenum `pname`, GLint `param``)`;\n\n## Parameters\n\n *`pname`*  \nSpecifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: `GL_PACK_SWAP_BYTES`, `GL_PACK_LSB_FIRST`, `GL_PACK_ROW_LENGTH`, `GL_PACK_IMAGE_HEIGHT`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, `GL_PACK_SKIP_IMAGES`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data *from* memory: `GL_UNPACK_SWAP_BYTES`, `GL_UNPACK_LSB_FIRST`, `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`.\n\n *`param`*  \nSpecifies the value that *`pname`* is set to.\n\n## Description\n\n`glPixelStore` sets pixel storage modes that affect the operation of subsequent [glReadPixels](glreadpixels.xhtml) as well as the unpacking of texture patterns (see [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml) or [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml).\n\n*`pname`* is a symbolic constant indicating the parameter to be set, and *`param`* is the new value. Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows:\n\n `GL_PACK_SWAP_BYTES`  \nIf true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes *b*₀, *b*₁, *b*₂, *b*₃, it is stored in memory as *b*₃, *b*₂, *b*₁, *b*₀ if `GL_PACK_SWAP_BYTES` is true. `GL_PACK_SWAP_BYTES` has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a `GL_RGB` format pixel are always stored with red first, green second, and blue third, regardless of the value of `GL_PACK_SWAP_BYTES`.\n\n `GL_PACK_LSB_FIRST`  \nIf true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.\n\n `GL_PACK_ROW_LENGTH`  \nIf greater than 0, `GL_PACK_ROW_LENGTH` defines the number of pixels in a row. If the first pixel of a row is placed at location *p* in memory, then the location of the first pixel of the next row is obtained by skipping\n\n$\\mathit{k} = \\left\\\\ {\\begin{matrix}\n{\\mathit{n}\\mathit{l}} \\\\\n{\\frac{\\mathit{a}}{\\mathit{s}}\\left\\lceil \\frac{\\mathit{s}\\mathit{n}\\mathit{l}}{\\mathit{a}} \\right\\rceil}\n\\end{matrix}\\begin{matrix}\n{\\mathit{s}\\>=\\mathit{a}} \\\\\n{\\mathit{s} \\< \\mathit{a}}\n\\end{matrix}} \\right.$\n\ncomponents or indices, where *n* is the number of components or indices in a pixel, *l* is the number of pixels in a row (`GL_PACK_ROW_LENGTH` if it is greater than 0, the *w**i**d**t**h* argument to the pixel routine otherwise), *a* is the value of `GL_PACK_ALIGNMENT`, and *s* is the size, in bytes, of a single component (if *a* \\< *s*, then it is as if *a* = *s*). In the case of 1-bit values, the location of the next row is obtained by skipping\n\n$\\mathit{k} = {8\\mathit{a}\\left\\lceil \\frac{\\mathit{n}\\mathit{l}}{8\\mathit{a}} \\right\\rceil}$\n\ncomponents or indices.\n\nThe word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format `GL_RGB`, for example, has three components per pixel: first red, then green, and finally blue.\n\n `GL_PACK_IMAGE_HEIGHT`  \nIf greater than 0, `GL_PACK_IMAGE_HEIGHT` defines the number of pixels in an image three-dimensional texture volume, where \\`\\`image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location *p* in memory, then the location of the first pixel of the next row is obtained by skipping\n\n$\\mathit{k} = \\left\\\\ {\\begin{matrix}\n{\\mathit{n}\\mathit{l}\\mathit{h}} \\\\\n{\\frac{\\mathit{a}}{\\mathit{s}}\\left\\lceil \\frac{\\mathit{s}\\mathit{n}\\mathit{l}\\mathit{h}}{\\mathit{a}} \\right\\rceil}\n\\end{matrix}\\begin{matrix}\n{\\mathit{s}\\>=\\mathit{a}} \\\\\n{\\mathit{s} \\< \\mathit{a}}\n\\end{matrix}} \\right.$\n\ncomponents or indices, where *n* is the number of components or indices in a pixel, *l* is the number of pixels in a row (`GL_PACK_ROW_LENGTH` if it is greater than 0, the *w**i**d**t**h* argument to [glTexImage3D](glteximage3d.xhtml) otherwise), *h* is the number of rows in a pixel image (`GL_PACK_IMAGE_HEIGHT` if it is greater than 0, the *h**e**i**g**h**t* argument to the [glTexImage3D](glteximage3d.xhtml) routine otherwise), *a* is the value of `GL_PACK_ALIGNMENT`, and *s* is the size, in bytes, of a single component (if *a* \\< *s*, then it is as if *a* = *s*).\n\nThe word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format `GL_RGB`, for example, has three components per pixel: first red, then green, and finally blue.\n\n`GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, and `GL_PACK_SKIP_IMAGES`  \nThese values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to [glReadPixels](glreadpixels.xhtml). Setting `GL_PACK_SKIP_PIXELS` to *i* is equivalent to incrementing the pointer by *i**n* components or indices, where *n* is the number of components or indices in each pixel. Setting `GL_PACK_SKIP_ROWS` to *j* is equivalent to incrementing the pointer by *j**m* components or indices, where *m* is the number of components or indices per row, as just computed in the `GL_PACK_ROW_LENGTH` section. Setting `GL_PACK_SKIP_IMAGES` to *k* is equivalent to incrementing the pointer by *k**p*, where *p* is the number of components or indices per image, as computed in the `GL_PACK_IMAGE_HEIGHT` section.\n\n `GL_PACK_ALIGNMENT`  \nSpecifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).\n\nThe other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), and [glTexSubImage3D](gltexsubimage3d.xhtml)\n\nThey are as follows:\n\n `GL_UNPACK_SWAP_BYTES`  \nIf true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes *b*₀, *b*₁, *b*₂, *b*₃, it is taken from memory as *b*₃, *b*₂, *b*₁, *b*₀ if `GL_UNPACK_SWAP_BYTES` is true. `GL_UNPACK_SWAP_BYTES` has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a `GL_RGB` format pixel are always stored with red first, green second, and blue third, regardless of the value of `GL_UNPACK_SWAP_BYTES`.\n\n `GL_UNPACK_LSB_FIRST`  \nIf true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.\n\n `GL_UNPACK_ROW_LENGTH`  \nIf greater than 0, `GL_UNPACK_ROW_LENGTH` defines the number of pixels in a row. If the first pixel of a row is placed at location *p* in memory, then the location of the first pixel of the next row is obtained by skipping\n\n$\\mathit{k} = \\left\\\\ {\\begin{matrix}\n{\\mathit{n}\\mathit{l}} \\\\\n{\\frac{\\mathit{a}}{\\mathit{s}}\\left\\lceil \\frac{\\mathit{s}\\mathit{n}\\mathit{l}}{\\mathit{a}} \\right\\rceil}\n\\end{matrix}\\begin{matrix}\n{\\mathit{s}\\>=\\mathit{a}} \\\\\n{\\mathit{s} \\< \\mathit{a}}\n\\end{matrix}} \\right.$\n\ncomponents or indices, where *n* is the number of components or indices in a pixel, *l* is the number of pixels in a row (`GL_UNPACK_ROW_LENGTH` if it is greater than 0, the *w**i**d**t**h* argument to the pixel routine otherwise), *a* is the value of `GL_UNPACK_ALIGNMENT`, and *s* is the size, in bytes, of a single component (if *a* \\< *s*, then it is as if *a* = *s*). In the case of 1-bit values, the location of the next row is obtained by skipping\n\n$\\mathit{k} = {8\\mathit{a}\\left\\lceil \\frac{\\mathit{n}\\mathit{l}}{8\\mathit{a}} \\right\\rceil}$\n\ncomponents or indices.\n\nThe word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format `GL_RGB`, for example, has three components per pixel: first red, then green, and finally blue.\n\n `GL_UNPACK_IMAGE_HEIGHT`  \nIf greater than 0, `GL_UNPACK_IMAGE_HEIGHT` defines the number of pixels in an image of a three-dimensional texture volume. Where \\`\\`image'' is defined by all pixel sharing the same third dimension index. If the first pixel of a row is placed at location *p* in memory, then the location of the first pixel of the next row is obtained by skipping\n\n$\\mathit{k} = \\left\\\\ {\\begin{matrix}\n{\\mathit{n}\\mathit{l}\\mathit{h}} \\\\\n{\\frac{\\mathit{a}}{\\mathit{s}}\\left\\lceil \\frac{\\mathit{s}\\mathit{n}\\mathit{l}\\mathit{h}}{\\mathit{a}} \\right\\rceil}\n\\end{matrix}\\begin{matrix}\n{\\mathit{s}\\>=\\mathit{a}} \\\\\n{\\mathit{s} \\< \\mathit{a}}\n\\end{matrix}} \\right.$\n\ncomponents or indices, where *n* is the number of components or indices in a pixel, *l* is the number of pixels in a row (`GL_UNPACK_ROW_LENGTH` if it is greater than 0, the *w**i**d**t**h* argument to [glTexImage3D](glteximage3d.xhtml) otherwise), *h* is the number of rows in an image (`GL_UNPACK_IMAGE_HEIGHT` if it is greater than 0, the *h**e**i**g**h**t* argument to [glTexImage3D](glteximage3d.xhtml) otherwise), *a* is the value of `GL_UNPACK_ALIGNMENT`, and *s* is the size, in bytes, of a single component (if *a* \\< *s*, then it is as if *a* = *s*).\n\nThe word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format `GL_RGB`, for example, has three components per pixel: first red, then green, and finally blue.\n\n`GL_UNPACK_SKIP_PIXELS` and `GL_UNPACK_SKIP_ROWS`  \nThese values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated by incrementing the pointer passed to [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml) or [glTexSubImage2D](gltexsubimage2d.xhtml). Setting `GL_UNPACK_SKIP_PIXELS` to *i* is equivalent to incrementing the pointer by *i**n* components or indices, where *n* is the number of components or indices in each pixel. Setting `GL_UNPACK_SKIP_ROWS` to *j* is equivalent to incrementing the pointer by *j**k* components or indices, where *k* is the number of components or indices per row, as just computed in the `GL_UNPACK_ROW_LENGTH` section.\n\n `GL_UNPACK_ALIGNMENT`  \nSpecifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).\n\nThe following table gives the type, initial value, and range of valid values for each storage parameter that can be set with `glPixelStore`.\n\n|  ***`pname`***           |  **Type**  |  **Initial Value**  |  **Valid Range**  |\n|:-------------------------|:----------:|:-------------------:|:-----------------:|\n| `GL_PACK_SWAP_BYTES`     |  boolean   |        false        |   true or false   |\n| `GL_PACK_LSB_FIRST`      |  boolean   |        false        |   true or false   |\n| `GL_PACK_ROW_LENGTH`     |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_IMAGE_HEIGHT`   |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_SKIP_ROWS`      |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_SKIP_PIXELS`    |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_SKIP_IMAGES`    |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_ALIGNMENT`      |  integer   |          4          |   1, 2, 4, or 8   |\n| `GL_UNPACK_SWAP_BYTES`   |  boolean   |        false        |   true or false   |\n| `GL_UNPACK_LSB_FIRST`    |  boolean   |        false        |   true or false   |\n| `GL_UNPACK_ROW_LENGTH`   |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_IMAGE_HEIGHT` |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_SKIP_ROWS`    |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_SKIP_PIXELS`  |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_SKIP_IMAGES`  |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_ALIGNMENT`    |  integer   |          4          |   1, 2, 4, or 8   |\n\n`glPixelStoref` can be used to set any pixel store parameter. If the parameter type is boolean, then if *`param`* is 0, the parameter is false; otherwise it is set to true. If *`pname`* is an integer type parameter, *`param`* is rounded to the nearest integer.\n\nLikewise, `glPixelStorei` can also be used to set any of the pixel store parameters. Boolean parameters are set to false if *`param`* is 0 and true otherwise.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if a negative row length, pixel skip, or row skip value is specified, or if alignment is specified as other than 1, 2, 4, or 8.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_PACK_SWAP_BYTES`\n\n[glGet](glget.xhtml) with argument `GL_PACK_LSB_FIRST`\n\n[glGet](glget.xhtml) with argument `GL_PACK_ROW_LENGTH`\n\n[glGet](glget.xhtml) with argument `GL_PACK_IMAGE_HEIGHT`\n\n[glGet](glget.xhtml) with argument `GL_PACK_SKIP_ROWS`\n\n[glGet](glget.xhtml) with argument `GL_PACK_SKIP_PIXELS`\n\n[glGet](glget.xhtml) with argument `GL_PACK_SKIP_IMAGES`\n\n[glGet](glget.xhtml) with argument `GL_PACK_ALIGNMENT`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_SWAP_BYTES`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_LSB_FIRST`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_ROW_LENGTH`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_IMAGE_HEIGHT`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_SKIP_ROWS`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_SKIP_PIXELS`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_SKIP_IMAGES`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_ALIGNMENT`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPixelStoref`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glPixelStorei`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glReadPixels](glreadpixels.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml).\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPixelStore.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPixelStore.xhtml)"
- name: glPixelStoref
  id: glpixelstore.xhtml#glPixelStoref
  summary: null
  belongs_to: glPixelStore
  description: '`void `**`glPixelStoref`**`(` GLenum `pname`, GLfloat `param``)`;'
- name: glPixelStorei
  id: glpixelstore.xhtml#glPixelStorei
  summary: Specifies the symbolic name of the parameter to be set
  belongs_to: glPixelStore
  description: "`void `**`glPixelStorei`**`(` GLenum `pname`, GLint `param``)`;\n\n## Parameters\n\n*`pname`*\n\nSpecifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: `GL_PACK_SWAP_BYTES`, `GL_PACK_LSB_FIRST`, `GL_PACK_ROW_LENGTH`, `GL_PACK_IMAGE_HEIGHT`, `GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, `GL_PACK_SKIP_IMAGES`, and `GL_PACK_ALIGNMENT`. Six more affect the unpacking of pixel data *from* memory: `GL_UNPACK_SWAP_BYTES`, `GL_UNPACK_LSB_FIRST`, `GL_UNPACK_ROW_LENGTH`, `GL_UNPACK_IMAGE_HEIGHT`, `GL_UNPACK_SKIP_PIXELS`, `GL_UNPACK_SKIP_ROWS`, `GL_UNPACK_SKIP_IMAGES`, and `GL_UNPACK_ALIGNMENT`.\n\n*`param`*\n\nSpecifies the value that *`pname`* is set to.\n\n## Description\n\n`glPixelStore` sets pixel storage modes that affect the operation of subsequent [glReadPixels](glreadpixels.xhtml) as well as the unpacking of texture patterns (see [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml) or [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml).\n\n*`pname`* is a symbolic constant indicating the parameter to be set, and *`param`* is the new value. Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows:\n\n`GL_PACK_SWAP_BYTES`\n\nIf true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes *b*₀, *b*₁, *b*₂, *b*₃, it is stored in memory as *b*₃, *b*₂, *b*₁, *b*₀ if `GL_PACK_SWAP_BYTES` is true. `GL_PACK_SWAP_BYTES` has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a `GL_RGB` format pixel are always stored with red first, green second, and blue third, regardless of the value of `GL_PACK_SWAP_BYTES`.\n\n`GL_PACK_LSB_FIRST`\n\nIf true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.\n\n`GL_PACK_ROW_LENGTH`\n\nIf greater than 0, `GL_PACK_ROW_LENGTH` defines the number of pixels in a row. If the first pixel of a row is placed at location *p* in memory, then the location of the first pixel of the next row is obtained by skipping\n\n$\\mathit{k} = \\left\\\\ {\\begin{matrix}\n{\\mathit{n}\\mathit{l}} \\\\\n{\\frac{\\mathit{a}}{\\mathit{s}}\\left\\lceil \\frac{\\mathit{s}\\mathit{n}\\mathit{l}}{\\mathit{a}} \\right\\rceil}\n\\end{matrix}\\begin{matrix}\n{\\mathit{s}\\>=\\mathit{a}} \\\\\n{\\mathit{s} \\< \\mathit{a}}\n\\end{matrix}} \\right.$\n\ncomponents or indices, where *n* is the number of components or indices in a pixel, *l* is the number of pixels in a row (`GL_PACK_ROW_LENGTH` if it is greater than 0, the *w**i**d**t**h* argument to the pixel routine otherwise), *a* is the value of `GL_PACK_ALIGNMENT`, and *s* is the size, in bytes, of a single component (if *a* \\< *s*, then it is as if *a* = *s*). In the case of 1-bit values, the location of the next row is obtained by skipping\n\n$\\mathit{k} = {8\\mathit{a}\\left\\lceil \\frac{\\mathit{n}\\mathit{l}}{8\\mathit{a}} \\right\\rceil}$\n\ncomponents or indices.\n\nThe word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format `GL_RGB`, for example, has three components per pixel: first red, then green, and finally blue.\n\n`GL_PACK_IMAGE_HEIGHT`\n\nIf greater than 0, `GL_PACK_IMAGE_HEIGHT` defines the number of pixels in an image three-dimensional texture volume, where \\`\\`image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location *p* in memory, then the location of the first pixel of the next row is obtained by skipping\n\n$\\mathit{k} = \\left\\\\ {\\begin{matrix}\n{\\mathit{n}\\mathit{l}\\mathit{h}} \\\\\n{\\frac{\\mathit{a}}{\\mathit{s}}\\left\\lceil \\frac{\\mathit{s}\\mathit{n}\\mathit{l}\\mathit{h}}{\\mathit{a}} \\right\\rceil}\n\\end{matrix}\\begin{matrix}\n{\\mathit{s}\\>=\\mathit{a}} \\\\\n{\\mathit{s} \\< \\mathit{a}}\n\\end{matrix}} \\right.$\n\ncomponents or indices, where *n* is the number of components or indices in a pixel, *l* is the number of pixels in a row (`GL_PACK_ROW_LENGTH` if it is greater than 0, the *w**i**d**t**h* argument to [glTexImage3D](glteximage3d.xhtml) otherwise), *h* is the number of rows in a pixel image (`GL_PACK_IMAGE_HEIGHT` if it is greater than 0, the *h**e**i**g**h**t* argument to the [glTexImage3D](glteximage3d.xhtml) routine otherwise), *a* is the value of `GL_PACK_ALIGNMENT`, and *s* is the size, in bytes, of a single component (if *a* \\< *s*, then it is as if *a* = *s*).\n\nThe word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format `GL_RGB`, for example, has three components per pixel: first red, then green, and finally blue.\n\n`GL_PACK_SKIP_PIXELS`, `GL_PACK_SKIP_ROWS`, and `GL_PACK_SKIP_IMAGES`\n\nThese values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to [glReadPixels](glreadpixels.xhtml). Setting `GL_PACK_SKIP_PIXELS` to *i* is equivalent to incrementing the pointer by *i**n* components or indices, where *n* is the number of components or indices in each pixel. Setting `GL_PACK_SKIP_ROWS` to *j* is equivalent to incrementing the pointer by *j**m* components or indices, where *m* is the number of components or indices per row, as just computed in the `GL_PACK_ROW_LENGTH` section. Setting `GL_PACK_SKIP_IMAGES` to *k* is equivalent to incrementing the pointer by *k**p*, where *p* is the number of components or indices per image, as computed in the `GL_PACK_IMAGE_HEIGHT` section.\n\n`GL_PACK_ALIGNMENT`\n\nSpecifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).\n\nThe other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), and [glTexSubImage3D](gltexsubimage3d.xhtml)\n\nThey are as follows:\n\n`GL_UNPACK_SWAP_BYTES`\n\nIf true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes *b*₀, *b*₁, *b*₂, *b*₃, it is taken from memory as *b*₃, *b*₂, *b*₁, *b*₀ if `GL_UNPACK_SWAP_BYTES` is true. `GL_UNPACK_SWAP_BYTES` has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a `GL_RGB` format pixel are always stored with red first, green second, and blue third, regardless of the value of `GL_UNPACK_SWAP_BYTES`.\n\n`GL_UNPACK_LSB_FIRST`\n\nIf true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.\n\n`GL_UNPACK_ROW_LENGTH`\n\nIf greater than 0, `GL_UNPACK_ROW_LENGTH` defines the number of pixels in a row. If the first pixel of a row is placed at location *p* in memory, then the location of the first pixel of the next row is obtained by skipping\n\n$\\mathit{k} = \\left\\\\ {\\begin{matrix}\n{\\mathit{n}\\mathit{l}} \\\\\n{\\frac{\\mathit{a}}{\\mathit{s}}\\left\\lceil \\frac{\\mathit{s}\\mathit{n}\\mathit{l}}{\\mathit{a}} \\right\\rceil}\n\\end{matrix}\\begin{matrix}\n{\\mathit{s}\\>=\\mathit{a}} \\\\\n{\\mathit{s} \\< \\mathit{a}}\n\\end{matrix}} \\right.$\n\ncomponents or indices, where *n* is the number of components or indices in a pixel, *l* is the number of pixels in a row (`GL_UNPACK_ROW_LENGTH` if it is greater than 0, the *w**i**d**t**h* argument to the pixel routine otherwise), *a* is the value of `GL_UNPACK_ALIGNMENT`, and *s* is the size, in bytes, of a single component (if *a* \\< *s*, then it is as if *a* = *s*). In the case of 1-bit values, the location of the next row is obtained by skipping\n\n$\\mathit{k} = {8\\mathit{a}\\left\\lceil \\frac{\\mathit{n}\\mathit{l}}{8\\mathit{a}} \\right\\rceil}$\n\ncomponents or indices.\n\nThe word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format `GL_RGB`, for example, has three components per pixel: first red, then green, and finally blue.\n\n`GL_UNPACK_IMAGE_HEIGHT`\n\nIf greater than 0, `GL_UNPACK_IMAGE_HEIGHT` defines the number of pixels in an image of a three-dimensional texture volume. Where \\`\\`image'' is defined by all pixel sharing the same third dimension index. If the first pixel of a row is placed at location *p* in memory, then the location of the first pixel of the next row is obtained by skipping\n\n$\\mathit{k} = \\left\\\\ {\\begin{matrix}\n{\\mathit{n}\\mathit{l}\\mathit{h}} \\\\\n{\\frac{\\mathit{a}}{\\mathit{s}}\\left\\lceil \\frac{\\mathit{s}\\mathit{n}\\mathit{l}\\mathit{h}}{\\mathit{a}} \\right\\rceil}\n\\end{matrix}\\begin{matrix}\n{\\mathit{s}\\>=\\mathit{a}} \\\\\n{\\mathit{s} \\< \\mathit{a}}\n\\end{matrix}} \\right.$\n\ncomponents or indices, where *n* is the number of components or indices in a pixel, *l* is the number of pixels in a row (`GL_UNPACK_ROW_LENGTH` if it is greater than 0, the *w**i**d**t**h* argument to [glTexImage3D](glteximage3d.xhtml) otherwise), *h* is the number of rows in an image (`GL_UNPACK_IMAGE_HEIGHT` if it is greater than 0, the *h**e**i**g**h**t* argument to [glTexImage3D](glteximage3d.xhtml) otherwise), *a* is the value of `GL_UNPACK_ALIGNMENT`, and *s* is the size, in bytes, of a single component (if *a* \\< *s*, then it is as if *a* = *s*).\n\nThe word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format `GL_RGB`, for example, has three components per pixel: first red, then green, and finally blue.\n\n`GL_UNPACK_SKIP_PIXELS` and `GL_UNPACK_SKIP_ROWS`\n\nThese values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated by incrementing the pointer passed to [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml) or [glTexSubImage2D](gltexsubimage2d.xhtml). Setting `GL_UNPACK_SKIP_PIXELS` to *i* is equivalent to incrementing the pointer by *i**n* components or indices, where *n* is the number of components or indices in each pixel. Setting `GL_UNPACK_SKIP_ROWS` to *j* is equivalent to incrementing the pointer by *j**k* components or indices, where *k* is the number of components or indices per row, as just computed in the `GL_UNPACK_ROW_LENGTH` section.\n\n`GL_UNPACK_ALIGNMENT`\n\nSpecifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).\n\nThe following table gives the type, initial value, and range of valid values for each storage parameter that can be set with `glPixelStore`.\n\n|  ***`pname`***           |  **Type**  |  **Initial Value**  |  **Valid Range**  |\n|:-------------------------|:----------:|:-------------------:|:-----------------:|\n| `GL_PACK_SWAP_BYTES`     |  boolean   |        false        |   true or false   |\n| `GL_PACK_LSB_FIRST`      |  boolean   |        false        |   true or false   |\n| `GL_PACK_ROW_LENGTH`     |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_IMAGE_HEIGHT`   |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_SKIP_ROWS`      |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_SKIP_PIXELS`    |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_SKIP_IMAGES`    |  integer   |          0          |      \\[0, ∞)      |\n| `GL_PACK_ALIGNMENT`      |  integer   |          4          |   1, 2, 4, or 8   |\n| `GL_UNPACK_SWAP_BYTES`   |  boolean   |        false        |   true or false   |\n| `GL_UNPACK_LSB_FIRST`    |  boolean   |        false        |   true or false   |\n| `GL_UNPACK_ROW_LENGTH`   |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_IMAGE_HEIGHT` |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_SKIP_ROWS`    |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_SKIP_PIXELS`  |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_SKIP_IMAGES`  |  integer   |          0          |      \\[0, ∞)      |\n| `GL_UNPACK_ALIGNMENT`    |  integer   |          4          |   1, 2, 4, or 8   |\n\n`glPixelStoref` can be used to set any pixel store parameter. If the parameter type is boolean, then if *`param`* is 0, the parameter is false; otherwise it is set to true. If *`pname`* is an integer type parameter, *`param`* is rounded to the nearest integer.\n\nLikewise, `glPixelStorei` can also be used to set any of the pixel store parameters. Boolean parameters are set to false if *`param`* is 0 and true otherwise.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if a negative row length, pixel skip, or row skip value is specified, or if alignment is specified as other than 1, 2, 4, or 8.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_PACK_SWAP_BYTES`\n\n[glGet](glget.xhtml) with argument `GL_PACK_LSB_FIRST`\n\n[glGet](glget.xhtml) with argument `GL_PACK_ROW_LENGTH`\n\n[glGet](glget.xhtml) with argument `GL_PACK_IMAGE_HEIGHT`\n\n[glGet](glget.xhtml) with argument `GL_PACK_SKIP_ROWS`\n\n[glGet](glget.xhtml) with argument `GL_PACK_SKIP_PIXELS`\n\n[glGet](glget.xhtml) with argument `GL_PACK_SKIP_IMAGES`\n\n[glGet](glget.xhtml) with argument `GL_PACK_ALIGNMENT`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_SWAP_BYTES`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_LSB_FIRST`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_ROW_LENGTH`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_IMAGE_HEIGHT`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_SKIP_ROWS`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_SKIP_PIXELS`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_SKIP_IMAGES`\n\n[glGet](glget.xhtml) with argument `GL_UNPACK_ALIGNMENT`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glPixelStoref`               |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glPixelStorei`               |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glReadPixels](glreadpixels.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml).\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPixelStore.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPixelStore.xhtml)"
- name: glPointParameter
  id: glpointparameter.xhtml
  summary: pname Specifies a single-valued point parameter
  description: "## Name\n\nglPointParameter — specify point parameters\n\n## C Specification\n\n`void `**`glPointParameterf`**`(` GLenum `pname`, GLfloat `param``)`;\n\n`void `**`glPointParameteri`**`(` GLenum `pname`, GLint `param``)`;\n\n`void `**`glPointParameterfv`**`(` GLenum `pname`, const GLfloat \\* `params``)`;\n\n`void `**`glPointParameteriv`**`(` GLenum `pname`, const GLint \\* `params``)`;\n\n## Parameters\n\n *`pname`*  \nSpecifies a single-valued point parameter. `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted.\n\n *`param`*  \nFor `glPointParameterf` and `glPointParameteri`, specifies the value that *`pname`* will be set to.\n\n *`params`*  \nFor `glPointParameterfv` and `glPointParameteriv`, specifies a pointer to an array where the value or values to be assigned to *`pname`* are stored.\n\n## Description\n\nThe following values are accepted for *`pname`*:\n\n `GL_POINT_FADE_THRESHOLD_SIZE`  \n*`params`* is a single floating-point value that specifies the threshold value to which point sizes are clamped if they exceed the specified value. The default value is 1.0.\n\n `GL_POINT_SPRITE_COORD_ORIGIN`  \n*`params`* is a single enum specifying the point sprite texture coordinate origin, either `GL_LOWER_LEFT` or `GL_UPPER_LEFT`. The default value is `GL_UPPER_LEFT`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if the value specified for `GL_POINT_FADE_THRESHOLD_SIZE` is less than zero.\n\n`GL_INVALID_ENUM` is generated If the value specified for `GL_POINT_SPRITE_COORD_ORIGIN` is not `GL_LOWER_LEFT` or `GL_UPPER_LEFT`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_POINT_FADE_THRESHOLD_SIZE`\n\n[glGet](glget.xhtml) with argument `GL_POINT_SPRITE_COORD_ORIGIN`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPointParameterf`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glPointParameterfv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glPointParameteri`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glPointParameteriv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glPointSize](glpointsize.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPointParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPointParameter.xhtml)"
- name: glPointParameterf
  id: glpointparameter.xhtml#glPointParameterf
  summary: null
  belongs_to: glPointParameter
  description: '`void `**`glPointParameterf`**`(` GLenum `pname`, GLfloat `param``)`;'
- name: glPointParameterfv
  id: glpointparameter.xhtml#glPointParameterfv
  summary: null
  belongs_to: glPointParameter
  description: '`void `**`glPointParameterfv`**`(` GLenum `pname`, const GLfloat \* `params``)`;'
- name: glPointParameteri
  id: glpointparameter.xhtml#glPointParameteri
  summary: null
  belongs_to: glPointParameter
  description: '`void `**`glPointParameteri`**`(` GLenum `pname`, GLint `param``)`;'
- name: glPointParameteriv
  id: glpointparameter.xhtml#glPointParameteriv
  summary: Specifies a single-valued point parameter
  belongs_to: glPointParameter
  description: "`void `**`glPointParameteriv`**`(` GLenum `pname`, const GLint \\* `params``)`;\n\n## Parameters\n\n*`pname`*\n\nSpecifies a single-valued point parameter. `GL_POINT_FADE_THRESHOLD_SIZE`, and `GL_POINT_SPRITE_COORD_ORIGIN` are accepted.\n\n*`param`*\n\nFor `glPointParameterf` and `glPointParameteri`, specifies the value that *`pname`* will be set to.\n\n*`params`*\n\nFor `glPointParameterfv` and `glPointParameteriv`, specifies a pointer to an array where the value or values to be assigned to *`pname`* are stored.\n\n## Description\n\nThe following values are accepted for *`pname`*:\n\n`GL_POINT_FADE_THRESHOLD_SIZE`\n\n*`params`* is a single floating-point value that specifies the threshold value to which point sizes are clamped if they exceed the specified value. The default value is 1.0.\n\n`GL_POINT_SPRITE_COORD_ORIGIN`\n\n*`params`* is a single enum specifying the point sprite texture coordinate origin, either `GL_LOWER_LEFT` or `GL_UPPER_LEFT`. The default value is `GL_UPPER_LEFT`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if the value specified for `GL_POINT_FADE_THRESHOLD_SIZE` is less than zero.\n\n`GL_INVALID_ENUM` is generated If the value specified for `GL_POINT_SPRITE_COORD_ORIGIN` is not `GL_LOWER_LEFT` or `GL_UPPER_LEFT`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_POINT_FADE_THRESHOLD_SIZE`\n\n[glGet](glget.xhtml) with argument `GL_POINT_SPRITE_COORD_ORIGIN`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glPointParameterf`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glPointParameterfv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glPointParameteri`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glPointParameteriv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[ glPointSize ](glpointsize.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPointParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPointParameter.xhtml)"
- name: glPointSize
  id: glpointsize.xhtml
  summary: size Specifies the diameter of rasterized points
  description: "## Name\n\nglPointSize — specify the diameter of rasterized points\n\n## C Specification\n\n`void `**`glPointSize`**`(` GLfloat `size``)`;\n\n## Parameters\n\n *`size`*  \nSpecifies the diameter of rasterized points. The initial value is 1.\n\n## Description\n\n`glPointSize` specifies the rasterized diameter of points. If point size mode is disabled (see [glEnable](glenable.xhtml) with parameter `GL_PROGRAM_POINT_SIZE`), this value will be used to rasterize points. Otherwise, the value written to the shading language built-in variable `gl_PointSize` will be used.\n\n## Notes\n\nThe point size specified by `glPointSize` is always returned when `GL_POINT_SIZE` is queried. Clamping and rounding for points have no effect on the specified value.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`size`* is less than or equal to 0.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_POINT_SIZE_RANGE`\n\n[glGet](glget.xhtml) with argument `GL_POINT_SIZE_GRANULARITY`\n\n[glGet](glget.xhtml) with argument `GL_POINT_SIZE`\n\n[glGet](glget.xhtml) with argument `GL_POINT_FADE_THRESHOLD_SIZE`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_PROGRAM_POINT_SIZE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPointSize`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glEnable](glenable.xhtml), [glPointParameter](glpointparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPointSize.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPointSize.xhtml)"
- name: glPolygonMode
  id: glpolygonmode.xhtml
  summary: face Specifies the polygons that mode applies to
  description: "## Name\n\nglPolygonMode — select a polygon rasterization mode\n\n## C Specification\n\n`void `**`glPolygonMode`**`(` GLenum `face`, GLenum `mode``)`;\n\n## Parameters\n\n *`face`*  \nSpecifies the polygons that *`mode`* applies to. Must be `GL_FRONT_AND_BACK` for front- and back-facing polygons.\n\n *`mode`*  \nSpecifies how polygons will be rasterized. Accepted values are `GL_POINT`, `GL_LINE`, and `GL_FILL`. The initial value is `GL_FILL` for both front- and back-facing polygons.\n\n## Description\n\n`glPolygonMode` controls the interpretation of polygons for rasterization. *`face`* describes which polygons *`mode`* applies to: both front and back-facing polygons (`GL_FRONT_AND_BACK`). The polygon mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied.\n\nThree modes are defined and can be specified in *`mode`*:\n\n `GL_POINT`  \nPolygon vertices that are marked as the start of a boundary edge are drawn as points. Point attributes such as `GL_POINT_SIZE` and `GL_POINT_SMOOTH` control the rasterization of the points. Polygon rasterization attributes other than `GL_POLYGON_MODE` have no effect.\n\n `GL_LINE`  \nBoundary edges of the polygon are drawn as line segments. Line attributes such as `GL_LINE_WIDTH` and `GL_LINE_SMOOTH` control the rasterization of the lines. Polygon rasterization attributes other than `GL_POLYGON_MODE` have no effect.\n\n `GL_FILL`  \nThe interior of the polygon is filled. Polygon attributes such as `GL_POLYGON_SMOOTH` control the rasterization of the polygon.\n\n## Examples\n\nTo draw a surface with outlined polygons, call\n\n``` programlisting\nglPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n            \n```\n\n## Notes\n\nVertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated internally by the GL when it decomposes triangle stips and fans.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if either *`face`* or *`mode`* is not an accepted value.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_POLYGON_MODE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPolygonMode`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glLineWidth](gllinewidth.xhtml), [glPointSize](glpointsize.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPolygonMode.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPolygonMode.xhtml)"
- name: glPolygonOffset
  id: glpolygonoffset.xhtml
  summary: factor Specifies a scale factor that is used to create a variable depth offset for each polygon
  description: "## Name\n\nglPolygonOffset — set the scale and units used to calculate depth values\n\n## C Specification\n\n`void `**`glPolygonOffset`**`(` GLfloat `factor`, GLfloat `units``)`;\n\n## Parameters\n\n *`factor`*  \nSpecifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.\n\n *`units`*  \nIs multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.\n\n## Description\n\nWhen `GL_POLYGON_OFFSET_FILL`, `GL_POLYGON_OFFSET_LINE`, or `GL_POLYGON_OFFSET_POINT` is enabled, each fragment's *depth* value will be offset after it is interpolated from the *depth* values of the appropriate vertices. The value of the offset is *f**a**c**t**o**r* × *D**Z* + *r* × *u**n**i**t**s*, where *D**Z* is a measurement of the change in depth relative to the screen area of the polygon, and *r* is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added before the depth test is performed and before the value is written into the depth buffer.\n\n`glPolygonOffset` is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges.\n\n## Associated Gets\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_POLYGON_OFFSET_FILL`, `GL_POLYGON_OFFSET_LINE`, or `GL_POLYGON_OFFSET_POINT`.\n\n[glGet](glget.xhtml) with argument `GL_POLYGON_OFFSET_FACTOR` or `GL_POLYGON_OFFSET_UNITS`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPolygonOffset`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDepthFunc](gldepthfunc.xhtml), [glEnable](glenable.xhtml), [glGet](glget.xhtml), [glIsEnabled](glisenabled.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPolygonOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPolygonOffset.xhtml)"
- name: glPopDebugGroup
  id: glpopdebuggroup.xhtml
  summary: glPopDebugGroup pops the active debug group
  description: "## Name\n\nglPopDebugGroup — pop the active debug group\n\n## C Specification\n\n`void `**`glPopDebugGroup`**`(` void`)`;\n\n## Description\n\n`glPopDebugGroup` pops the active debug group. After popping a debug group, the GL will also generate a debug output message describing its cause based on the *`message`* string, the source *`source`*, and an ID *`id`* submitted to the corresponding [glPushDebugGroup](glpushdebuggroup.xhtml) command. `GL_DEBUG_TYPE_PUSH_GROUP` and `GL_DEBUG_TYPE_POP_GROUP` share a single namespace for message *`id`*. *`severity`* has the value `GL_DEBUG_SEVERITY_NOTIFICATION`. The *`type`* has the value `GL_DEBUG_TYPE_POP_GROUP`. Popping a debug group restores the debug output volume control of the parent debug group.\n\n## Errors\n\n`GL_STACK_UNDERFLOW` is generated if an attempt is made to pop the default debug group from the stack.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_DEBUG_MESSAGE_LENGTH`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPopDebugGroup`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glPushDebugGroup](glpushdebuggroup.xhtml), [glObjectLabel](globjectlabel.xhtml), [glObjectPtrLabel](globjectptrlabel.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPopDebugGroup.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPopDebugGroup.xhtml)"
- name: glPrimitiveRestartIndex
  id: glprimitiverestartindex.xhtml
  summary: index Specifies the value to be interpreted as the primitive restart index
  description: "## Name\n\nglPrimitiveRestartIndex — specify the primitive restart index\n\n## C Specification\n\n`void `**`glPrimitiveRestartIndex`**`(` GLuint `index``)`;\n\n## Parameters\n\n *`index`*  \nSpecifies the value to be interpreted as the primitive restart index.\n\n## Description\n\n`glPrimitiveRestartIndex` specifies a vertex array element that is treated specially when primitive restarting is enabled. This is known as the primitive restart index.\n\nWhen one of the `Draw*` commands transfers a set of generic attribute array elements to the GL, if the index within the vertex arrays corresponding to that set is equal to the primitive restart index, then the GL does not process those elements as a vertex. Instead, it is as if the drawing command ended with the immediately preceding transfer, and another drawing command is immediately started with the same parameters, but only transferring the immediately following element through the end of the originally specified elements.\n\nWhen either [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml), [glDrawElementsInstancedBaseVertex](gldrawelementsinstancedbasevertex.xhtml) or [glMultiDrawElementsBaseVertex](glmultidrawelementsbasevertex.xhtml) is used, the primitive restart comparison occurs before the basevertex offset is added to the array index.\n\n## Notes\n\n`glPrimitiveRestartIndex` is available only if the GL version is 3.1 or greater.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPrimitiveRestartIndex`   |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDrawArrays](gldrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawElementsBaseVertex](gldrawelementsbasevertex.xhtml), [glDrawElementsInstancedBaseVertex](gldrawelementsinstancedbasevertex.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPrimitiveRestartIndex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPrimitiveRestartIndex.xhtml)"
- name: glProgramBinary
  id: glprogrambinary.xhtml
  summary: program Specifies the name of a program object into which to load a program binary
  description: "## Name\n\nglProgramBinary — load a program object with a program binary\n\n## C Specification\n\n`void `**`glProgramBinary`**`(` GLuint `program`, GLenum `binaryFormat`, const void \\*`binary`, GLsizei `length``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of a program object into which to load a program binary.\n\n *`binaryFormat`*  \nSpecifies the format of the binary data in binary.\n\n *`binary`*  \nSpecifies the address an array containing the binary to be loaded into *`program`*.\n\n *`length`*  \nSpecifies the number of bytes contained in *`binary`*.\n\n## Description\n\n`glProgramBinary` loads a program object with a program binary previously returned from [glGetProgramBinary](glgetprogrambinary.xhtml). *`binaryFormat`* and *`binary`* must be those returned by a previous call to [glGetProgramBinary](glgetprogrambinary.xhtml), and *`length`* must be the length returned by [glGetProgramBinary](glgetprogrambinary.xhtml), or by [glGetProgram](glgetprogram.xhtml) when called with *`pname`* set to `GL_PROGRAM_BINARY_LENGTH`. If these conditions are not met, loading the program binary will fail and *`program`*'s `GL_LINK_STATUS` will be set to `GL_FALSE`.\n\nA program object's program binary is replaced by calls to [glLinkProgram](gllinkprogram.xhtml) or `glProgramBinary`. When linking success or failure is concerned, `glProgramBinary` can be considered to perform an implicit linking operation. [glLinkProgram](gllinkprogram.xhtml) and `glProgramBinary` both set the program object's `GL_LINK_STATUS` to `GL_TRUE` or `GL_FALSE`.\n\nA successful call to `glProgramBinary` will reset all uniform variables to their initial values. The initial value is either the value of the variable's initializer as specified in the original shader source, or zero if no initializer was present. Additionally, all vertex shader input and fragment shader output assignments that were in effect when the program was linked before saving are restored with `glProgramBinary` is called.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of an existing program object.\n\n`GL_INVALID_ENUM` is generated if *`binaryFormat`* is not a value recognized by the implementation.\n\n## Notes\n\nA program binary may fail to load if the implementation determines that there has been a change in hardware or software configuration from when the program binary was produced such as having been compiled with an incompatible or outdated version of the compiler.\n\n## Associated Gets\n\n[glGetProgram](glgetprogram.xhtml) with argument `GL_PROGRAM_BINARY_LENGTH`\n\n[glGet](glget.xhtml) with argument `GL_NUM_PROGRAM_BINARY_FORMATS`\n\n[glGet](glget.xhtml) with argument `GL_PROGRAM_BINARY_FORMATS`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glProgramBinary`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetProgramBinary](glgetprogrambinary.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramBinary.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramBinary.xhtml)"
- name: glProgramParameter
  id: glprogramparameter.xhtml
  summary: program Specifies the name of a program object whose parameter to modify
  description: "## Name\n\nglProgramParameter — specify a parameter for a program object\n\n## C Specification\n\n`void `**`glProgramParameteri`**`(` GLuint `program`, GLenum `pname`, GLint `value``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the name of a program object whose parameter to modify.\n\n *`pname`*  \nSpecifies the name of the parameter to modify.\n\n *`value`*  \nSpecifies the new value of the parameter specified by *`pname`* for *`program`*.\n\n## Description\n\n`glProgramParameter` specifies a new value for the parameter nameed by *`pname`* for the program object *`program`*.\n\nIf *`pname`* is `GL_PROGRAM_BINARY_RETRIEVABLE_HINT`, *`value`* should be `GL_FALSE` or `GL_TRUE` to indicate to the implementation the intention of the application to retrieve the program's binary representation with [glGetProgramBinary](glgetprogrambinary.xhtml). The implementation may use this information to store information that may be useful for a future query of the program's binary. It is recommended to set `GL_PROGRAM_BINARY_RETRIEVABLE_HINT` for the program to `GL_TRUE` before calling [glLinkProgram](gllinkprogram.xhtml), and using the program at run-time if the binary is to be retrieved later.\n\nIf *`pname`* is `GL_PROGRAM_SEPARABLE`, *`value`* must be `GL_TRUE` or `GL_FALSE` and indicates whether *`program`* can be bound to individual pipeline stages via [glUseProgramStages](gluseprogramstages.xhtml). A program's `GL_PROGRAM_SEPARABLE` parameter must be set to `GL_TRUE` *before* [glLinkProgram](gllinkprogram.xhtml) is called in order for it to be usable with a program pipeline object. The initial state of `GL_PROGRAM_SEPARABLE` is `GL_FALSE`.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of an existing program object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`value`* is not a valid value for the parameter named by *`pname`*.\n\n## Associated Gets\n\n[glGetProgram](glgetprogram.xhtml).\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glProgramParameteri`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetProgramBinary](glgetprogrambinary.xhtml), [glProgramBinary](glprogrambinary.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramParameter.xhtml)"
- name: glProgramParameteri
  id: glprogramparameter.xhtml#glProgramParameteri
  summary: Specifies the name of a program object whose parameter to modify
  belongs_to: glProgramParameter
  description: "`void `**`glProgramParameteri`**`(` GLuint `program`, GLenum `pname`, GLint `value``)`;\n\n## Parameters\n\n*`program`*\n\nSpecifies the name of a program object whose parameter to modify.\n\n*`pname`*\n\nSpecifies the name of the parameter to modify.\n\n*`value`*\n\nSpecifies the new value of the parameter specified by *`pname`* for *`program`*.\n\n## Description\n\n`glProgramParameter` specifies a new value for the parameter nameed by *`pname`* for the program object *`program`*.\n\nIf *`pname`* is `GL_PROGRAM_BINARY_RETRIEVABLE_HINT`, *`value`* should be `GL_FALSE` or `GL_TRUE` to indicate to the implementation the intention of the application to retrieve the program's binary representation with [glGetProgramBinary](glgetprogrambinary.xhtml). The implementation may use this information to store information that may be useful for a future query of the program's binary. It is recommended to set `GL_PROGRAM_BINARY_RETRIEVABLE_HINT` for the program to `GL_TRUE` before calling [glLinkProgram](gllinkprogram.xhtml), and using the program at run-time if the binary is to be retrieved later.\n\nIf *`pname`* is `GL_PROGRAM_SEPARABLE`, *`value`* must be `GL_TRUE` or `GL_FALSE` and indicates whether *`program`* can be bound to individual pipeline stages via [glUseProgramStages](gluseprogramstages.xhtml). A program's `GL_PROGRAM_SEPARABLE` parameter must be set to `GL_TRUE` *before* [glLinkProgram](gllinkprogram.xhtml) is called in order for it to be usable with a program pipeline object. The initial state of `GL_PROGRAM_SEPARABLE` is `GL_FALSE`.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not the name of an existing program object.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`value`* is not a valid value for the parameter named by *`pname`*.\n\n## Associated Gets\n\n[glGetProgram](glgetprogram.xhtml).\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glProgramParameteri`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetProgramBinary](glgetprogrambinary.xhtml), [glProgramBinary](glprogrambinary.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramParameter.xhtml)"
- name: glProgramUniform
  id: glprogramuniform.xhtml
  summary: program Specifies the handle of the program containing the uniform variable to be modified
  description: "## Name\n\nglProgramUniform — Specify the value of a uniform variable for a specified program object\n\n## C Specification\n\n`void `**`glProgramUniform1f`**`(` GLuint `program`, GLint `location`, GLfloat `v0``)`;\n\n`void `**`glProgramUniform2f`**`(` GLuint `program`, GLint `location`, GLfloat `v0`, GLfloat `v1``)`;\n\n`void `**`glProgramUniform3f`**`(` GLuint `program`, GLint `location`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2``)`;\n\n`void `**`glProgramUniform4f`**`(` GLuint `program`, GLint `location`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2`, GLfloat `v3``)`;\n\n`void `**`glProgramUniform1i`**`(` GLuint `program`, GLint `location`, GLint `v0``)`;\n\n`void `**`glProgramUniform2i`**`(` GLuint `program`, GLint `location`, GLint `v0`, GLint `v1``)`;\n\n`void `**`glProgramUniform3i`**`(` GLuint `program`, GLint `location`, GLint `v0`, GLint `v1`, GLint `v2``)`;\n\n`void `**`glProgramUniform4i`**`(` GLuint `program`, GLint `location`, GLint `v0`, GLint `v1`, GLint `v2`, GLint `v3``)`;\n\n`void `**`glProgramUniform1ui`**`(` GLuint `program`, GLint `location`, GLuint `v0``)`;\n\n`void `**`glProgramUniform2ui`**`(` GLuint `program`, GLint `location`, GLuint `v0`, GLuint `v1``)`;\n\n`void `**`glProgramUniform3ui`**`(` GLuint `program`, GLint `location`, GLuint `v0`, GLuint `v1`, GLuint `v2``)`;\n\n`void `**`glProgramUniform4ui`**`(` GLuint `program`, GLint `location`, GLuint `v0`, GLuint `v1`, GLuint `v2`, GLuint `v3``)`;\n\n`void `**`glProgramUniform1fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniform2fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniform3fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniform4fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniform1iv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLint \\*`value``)`;\n\n`void `**`glProgramUniform2iv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLint \\*`value``)`;\n\n`void `**`glProgramUniform3iv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLint \\*`value``)`;\n\n`void `**`glProgramUniform4iv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLint \\*`value``)`;\n\n`void `**`glProgramUniform1uiv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLuint \\*`value``)`;\n\n`void `**`glProgramUniform2uiv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLuint \\*`value``)`;\n\n`void `**`glProgramUniform3uiv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLuint \\*`value``)`;\n\n`void `**`glProgramUniform4uiv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLuint \\*`value``)`;\n\n`void `**`glProgramUniformMatrix2fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniformMatrix3fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniformMatrix4fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniformMatrix2x3fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniformMatrix3x2fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniformMatrix2x4fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniformMatrix4x2fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniformMatrix3x4fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glProgramUniformMatrix4x3fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the handle of the program containing the uniform variable to be modified.\n\n *`location`*  \nSpecifies the location of the uniform variable to be modified.\n\n *`count`*  \nFor the vector commands (`glProgramUniform*v`), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.\n\nFor the matrix commands (`glProgramUniformMatrix*`), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.\n\n *`transpose`*  \nFor the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.\n\n *`v0`*, *`v1`*, *`v2`*, *`v3`*  \nFor the scalar commands, specifies the new values to be used for the specified uniform variable.\n\n *`value`*  \nFor the vector and matrix commands, specifies a pointer to an array of *`count`* values that will be used to update the specified uniform variable.\n\n## Description\n\n`glProgramUniform` modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by *`location`*, which should be a value returned by [glGetUniformLocation](glgetuniformlocation.xhtml). `glProgramUniform` operates on the program object specified by *`program`*.\n\nThe commands `glProgramUniform{1|2|3|4}{f|i|ui}` are used to change the value of the uniform variable specified by *`location`* using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., `1` for `float`, `int`, `unsigned int`, `bool`; `2` for `vec2`, `ivec2`, `uvec2`, `bvec2`, etc.). The suffix `f` indicates that floating-point values are being passed; the suffix `i` indicates that integer values are being passed; the suffix `ui` indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The `i` variants of this function should be used to provide values for uniform variables defined as `int`, `ivec2`, `ivec3`, `ivec4`, or arrays of these. The `ui` variants of this function should be used to provide values for uniform variables defined as `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or arrays of these. The `f` variants should be used to provide values for uniform variables of type `float`, `vec2`, `vec3`, `vec4`, or arrays of these. Either the `i`, `ui` or `f` variants may be used to provide values for uniform variables of type `bool`, `bvec2`, `bvec3`, `bvec4`, or arrays of these. The uniform variable will be set to `false` if the input value is 0 or 0.0f, and it will be set to `true` otherwise.\n\nAll active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to `glProgramUniform` until the next successful link operation occurs on the program object, when they are once again initialized to 0.\n\nThe commands `glProgramUniform{1|2|3|4}{f|i|ui}v` can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading *n* elements starting at an arbitrary position *m* in a uniform variable array, elements *m* + *n* - 1 in the array will be replaced with the new values. If *`m`* + *`n`* - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in *`value`*, and it should match the number of components in the data type of the specified uniform variable (e.g., `1` for `float`, `int`, `bool`; `2` for `vec2`, `ivec2`, `bvec2`, etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for `glProgramUniform{1|2|3|4}{f|i|ui}`.\n\nFor uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., `glProgramUniform3f` or `glProgramUniform3fv` can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by *`count`*\n\nThe commands `glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv` are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number `2` indicates a 2 × 2 matrix (i.e., 4 values), the number `3` indicates a 3 × 3 matrix (i.e., 9 values), and the number `4` indicates a 4 × 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows. For example, `2x4` indicates a 2 × 4 matrix with 2 columns and 4 rows (i.e., 8 values). If *`transpose`* is `GL_FALSE`, each matrix is assumed to be supplied in column major order. If *`transpose`* is `GL_TRUE`, each matrix is assumed to be supplied in row major order. The *`count`* argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.\n\n## Notes\n\n`glProgramUniform1i` and `glProgramUniform1iv` are the only two functions that may be used to load uniform variables defined as sampler types. Loading samplers with any other function will result in a `GL_INVALID_OPERATION` error.\n\nIf *`count`* is greater than 1 and the indicated uniform variable is not an array, a `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain unchanged.\n\nOther than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match the type and size specified in the name of the command used to load its value, a `GL_INVALID_OPERATION` error will be generated and the specified uniform variable will remain unchanged.\n\nIf *`location`* is a value other than -1 and it does not represent a valid uniform variable location in within *`program`*, an error will be generated, and no changes will be made to the uniform variable storage of *`program`*. If *`location`* is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* does not refer to a program object owned by the GL.\n\n`GL_INVALID_OPERATION` is generated if the size of the uniform variable declared in the shader does not match the size indicated by the `glProgramUniform` command.\n\n`GL_INVALID_OPERATION` is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type `float`, `vec2`, `vec3`, `vec4`, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type `int`, `ivec2`, `ivec3`, `ivec4`, `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if one of the signed integer variants of this function is used to load a uniform variable of type `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type `int`, `ivec2`, `ivec3`, `ivec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if *`location`* is an invalid uniform location for *`program`* and *`location`* is not equal to -1.\n\n`GL_INVALID_VALUE` is generated if *`count`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if *`count`* is greater than 1 and the indicated uniform variable is not an array variable.\n\n`GL_INVALID_OPERATION` is generated if a sampler is loaded using a command other than `glProgramUniform1i` and `glProgramUniform1iv`.\n\n## Associated Gets\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with the handle of a program object and the index of an active uniform variable\n\n[glGetUniform](glgetuniform.xhtml) with the handle of a program object and the location of a uniform variable\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with the handle of a program object and the name of a uniform variable\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glProgramUniform1f`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform1fv`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform1i`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform1iv`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform1ui`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform1uiv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform2f`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform2fv`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform2i`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform2iv`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform2ui`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform2uiv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform3f`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform3fv`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform3i`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform3iv`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform3ui`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform3uiv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform4f`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform4fv`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform4i`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform4iv`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform4ui`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniform4uiv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniformMatrix2fv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniformMatrix2x3fv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniformMatrix2x4fv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniformMatrix3fv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniformMatrix3x2fv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniformMatrix3x4fv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniformMatrix4fv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniformMatrix4x2fv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glProgramUniformMatrix4x3fv` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glLinkProgram](gllinkprogram.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramUniform.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramUniform.xhtml)"
- name: glProgramUniform1f
  id: glprogramuniform.xhtml#glProgramUniform1f
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform1f`**`(` GLuint `program`, GLint `location`, GLfloat `v0``)`;'
- name: glProgramUniform1fv
  id: glprogramuniform.xhtml#glProgramUniform1fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform1fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLfloat \*`value``)`;'
- name: glProgramUniform1i
  id: glprogramuniform.xhtml#glProgramUniform1i
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform1i`**`(` GLuint `program`, GLint `location`, GLint `v0``)`;'
- name: glProgramUniform1iv
  id: glprogramuniform.xhtml#glProgramUniform1iv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform1iv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLint \*`value``)`;'
- name: glProgramUniform1ui
  id: glprogramuniform.xhtml#glProgramUniform1ui
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform1ui`**`(` GLuint `program`, GLint `location`, GLuint `v0``)`;'
- name: glProgramUniform1uiv
  id: glprogramuniform.xhtml#glProgramUniform1uiv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform1uiv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLuint \*`value``)`;'
- name: glProgramUniform2f
  id: glprogramuniform.xhtml#glProgramUniform2f
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform2f`**`(` GLuint `program`, GLint `location`, GLfloat `v0`, GLfloat `v1``)`;'
- name: glProgramUniform2fv
  id: glprogramuniform.xhtml#glProgramUniform2fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform2fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLfloat \*`value``)`;'
- name: glProgramUniform2i
  id: glprogramuniform.xhtml#glProgramUniform2i
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform2i`**`(` GLuint `program`, GLint `location`, GLint `v0`, GLint `v1``)`;'
- name: glProgramUniform2iv
  id: glprogramuniform.xhtml#glProgramUniform2iv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform2iv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLint \*`value``)`;'
- name: glProgramUniform2ui
  id: glprogramuniform.xhtml#glProgramUniform2ui
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform2ui`**`(` GLuint `program`, GLint `location`, GLuint `v0`, GLuint `v1``)`;'
- name: glProgramUniform2uiv
  id: glprogramuniform.xhtml#glProgramUniform2uiv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform2uiv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLuint \*`value``)`;'
- name: glProgramUniform3f
  id: glprogramuniform.xhtml#glProgramUniform3f
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform3f`**`(` GLuint `program`, GLint `location`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2``)`;'
- name: glProgramUniform3fv
  id: glprogramuniform.xhtml#glProgramUniform3fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform3fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLfloat \*`value``)`;'
- name: glProgramUniform3i
  id: glprogramuniform.xhtml#glProgramUniform3i
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform3i`**`(` GLuint `program`, GLint `location`, GLint `v0`, GLint `v1`, GLint `v2``)`;'
- name: glProgramUniform3iv
  id: glprogramuniform.xhtml#glProgramUniform3iv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform3iv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLint \*`value``)`;'
- name: glProgramUniform3ui
  id: glprogramuniform.xhtml#glProgramUniform3ui
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform3ui`**`(` GLuint `program`, GLint `location`, GLuint `v0`, GLuint `v1`, GLuint `v2``)`;'
- name: glProgramUniform3uiv
  id: glprogramuniform.xhtml#glProgramUniform3uiv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform3uiv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLuint \*`value``)`;'
- name: glProgramUniform4f
  id: glprogramuniform.xhtml#glProgramUniform4f
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform4f`**`(` GLuint `program`, GLint `location`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2`, GLfloat `v3``)`;'
- name: glProgramUniform4fv
  id: glprogramuniform.xhtml#glProgramUniform4fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform4fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLfloat \*`value``)`;'
- name: glProgramUniform4i
  id: glprogramuniform.xhtml#glProgramUniform4i
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform4i`**`(` GLuint `program`, GLint `location`, GLint `v0`, GLint `v1`, GLint `v2`, GLint `v3``)`;'
- name: glProgramUniform4iv
  id: glprogramuniform.xhtml#glProgramUniform4iv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform4iv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLint \*`value``)`;'
- name: glProgramUniform4ui
  id: glprogramuniform.xhtml#glProgramUniform4ui
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform4ui`**`(` GLuint `program`, GLint `location`, GLuint `v0`, GLuint `v1`, GLuint `v2`, GLuint `v3``)`;'
- name: glProgramUniform4uiv
  id: glprogramuniform.xhtml#glProgramUniform4uiv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniform4uiv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, const GLuint \*`value``)`;'
- name: glProgramUniformMatrix2fv
  id: glprogramuniform.xhtml#glProgramUniformMatrix2fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniformMatrix2fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glProgramUniformMatrix2x3fv
  id: glprogramuniform.xhtml#glProgramUniformMatrix2x3fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniformMatrix2x3fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glProgramUniformMatrix2x4fv
  id: glprogramuniform.xhtml#glProgramUniformMatrix2x4fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniformMatrix2x4fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glProgramUniformMatrix3fv
  id: glprogramuniform.xhtml#glProgramUniformMatrix3fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniformMatrix3fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glProgramUniformMatrix3x2fv
  id: glprogramuniform.xhtml#glProgramUniformMatrix3x2fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniformMatrix3x2fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glProgramUniformMatrix3x4fv
  id: glprogramuniform.xhtml#glProgramUniformMatrix3x4fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniformMatrix3x4fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glProgramUniformMatrix4fv
  id: glprogramuniform.xhtml#glProgramUniformMatrix4fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniformMatrix4fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glProgramUniformMatrix4x2fv
  id: glprogramuniform.xhtml#glProgramUniformMatrix4x2fv
  summary: null
  belongs_to: glProgramUniform
  description: '`void `**`glProgramUniformMatrix4x2fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glProgramUniformMatrix4x3fv
  id: glprogramuniform.xhtml#glProgramUniformMatrix4x3fv
  summary: Specifies the handle of the program containing the uniform variable to be modified
  belongs_to: glProgramUniform
  description: "`void `**`glProgramUniformMatrix4x3fv`**`(` GLuint `program`, GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n## Parameters\n\n*`program`*\n\nSpecifies the handle of the program containing the uniform variable to be modified.\n\n*`location`*\n\nSpecifies the location of the uniform variable to be modified.\n\n*`count`*\n\nFor the vector commands (`glProgramUniform*v`), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.\n\nFor the matrix commands (`glProgramUniformMatrix*`), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.\n\n*`transpose`*\n\nFor the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.\n\n*`v0`*, *`v1`*, *`v2`*, *`v3`*\n\nFor the scalar commands, specifies the new values to be used for the specified uniform variable.\n\n*`value`*\n\nFor the vector and matrix commands, specifies a pointer to an array of *`count`* values that will be used to update the specified uniform variable.\n\n## Description\n\n`glProgramUniform` modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by *`location`*, which should be a value returned by [glGetUniformLocation](glgetuniformlocation.xhtml). `glProgramUniform` operates on the program object specified by *`program`*.\n\nThe commands `glProgramUniform{1|2|3|4}{f|i|ui}` are used to change the value of the uniform variable specified by *`location`* using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., `1` for `float`, `int`, `unsigned int`, `bool`; `2` for `vec2`, `ivec2`, `uvec2`, `bvec2`, etc.). The suffix `f` indicates that floating-point values are being passed; the suffix `i` indicates that integer values are being passed; the suffix `ui` indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The `i` variants of this function should be used to provide values for uniform variables defined as `int`, `ivec2`, `ivec3`, `ivec4`, or arrays of these. The `ui` variants of this function should be used to provide values for uniform variables defined as `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or arrays of these. The `f` variants should be used to provide values for uniform variables of type `float`, `vec2`, `vec3`, `vec4`, or arrays of these. Either the `i`, `ui` or `f` variants may be used to provide values for uniform variables of type `bool`, `bvec2`, `bvec3`, `bvec4`, or arrays of these. The uniform variable will be set to `false` if the input value is 0 or 0.0f, and it will be set to `true` otherwise.\n\nAll active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to `glProgramUniform` until the next successful link operation occurs on the program object, when they are once again initialized to 0.\n\nThe commands `glProgramUniform{1|2|3|4}{f|i|ui}v` can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading *n* elements starting at an arbitrary position *m* in a uniform variable array, elements *m* + *n* - 1 in the array will be replaced with the new values. If *`m`* + *`n`* - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in *`value`*, and it should match the number of components in the data type of the specified uniform variable (e.g., `1` for `float`, `int`, `bool`; `2` for `vec2`, `ivec2`, `bvec2`, etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for `glProgramUniform{1|2|3|4}{f|i|ui}`.\n\nFor uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., `glProgramUniform3f` or `glProgramUniform3fv` can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by *`count`*\n\nThe commands `glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv` are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number `2` indicates a 2 × 2 matrix (i.e., 4 values), the number `3` indicates a 3 × 3 matrix (i.e., 9 values), and the number `4` indicates a 4 × 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows. For example, `2x4` indicates a 2 × 4 matrix with 2 columns and 4 rows (i.e., 8 values). If *`transpose`* is `GL_FALSE`, each matrix is assumed to be supplied in column major order. If *`transpose`* is `GL_TRUE`, each matrix is assumed to be supplied in row major order. The *`count`* argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.\n\n## Notes\n\n`glProgramUniform1i` and `glProgramUniform1iv` are the only two functions that may be used to load uniform variables defined as sampler types. Loading samplers with any other function will result in a `GL_INVALID_OPERATION` error.\n\nIf *`count`* is greater than 1 and the indicated uniform variable is not an array, a `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain unchanged.\n\nOther than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match the type and size specified in the name of the command used to load its value, a `GL_INVALID_OPERATION` error will be generated and the specified uniform variable will remain unchanged.\n\nIf *`location`* is a value other than -1 and it does not represent a valid uniform variable location in within *`program`*, an error will be generated, and no changes will be made to the uniform variable storage of *`program`*. If *`location`* is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`program`* does not refer to a program object owned by the GL.\n\n`GL_INVALID_OPERATION` is generated if the size of the uniform variable declared in the shader does not match the size indicated by the `glProgramUniform` command.\n\n`GL_INVALID_OPERATION` is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type `float`, `vec2`, `vec3`, `vec4`, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type `int`, `ivec2`, `ivec3`, `ivec4`, `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if one of the signed integer variants of this function is used to load a uniform variable of type `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type `int`, `ivec2`, `ivec3`, `ivec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if *`location`* is an invalid uniform location for *`program`* and *`location`* is not equal to -1.\n\n`GL_INVALID_VALUE` is generated if *`count`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if *`count`* is greater than 1 and the indicated uniform variable is not an array variable.\n\n`GL_INVALID_OPERATION` is generated if a sampler is loaded using a command other than `glProgramUniform1i` and `glProgramUniform1iv`.\n\n## Associated Gets\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with the handle of a program object and the index of an active uniform variable\n\n[glGetUniform](glgetuniform.xhtml) with the handle of a program object and the location of a uniform variable\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with the handle of a program object and the name of a uniform variable\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glProgramUniform1f`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform1fv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform1i`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform1iv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform1ui`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform1uiv`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform2f`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform2fv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform2i`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform2iv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform2ui`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform2uiv`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform3f`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform3fv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform3i`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform3iv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform3ui`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform3uiv`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform4f`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform4fv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform4i`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform4iv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform4ui`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniform4uiv`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniformMatrix2fv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniformMatrix2x3fv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniformMatrix2x4fv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniformMatrix3fv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniformMatrix3x2fv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniformMatrix3x4fv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniformMatrix4fv`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniformMatrix4x2fv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glProgramUniformMatrix4x3fv` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glLinkProgram](gllinkprogram.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramUniform.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glProgramUniform.xhtml)"
- name: glProvokingVertex
  id: glprovokingvertex.xhtml
  summary: provokeMode Specifies the vertex to be used as the source of data for flat shaded varyings
  description: "## Name\n\nglProvokingVertex — specifiy the vertex to be used as the source of data for flat shaded varyings\n\n## C Specification\n\n`void `**`glProvokingVertex`**`(` GLenum `provokeMode``)`;\n\n## Parameters\n\n *`provokeMode`*  \nSpecifies the vertex to be used as the source of data for flat shaded varyings.\n\n## Description\n\n*Flatshading* a vertex shader varying output means to assign all vetices of the primitive the same value for that output. The vertex from which these values is derived is known as the *provoking vertex* and `glProvokingVertex` specifies which vertex is to be used as the source of data for flat shaded varyings.\n\n*`provokeMode`* must be either `GL_FIRST_VERTEX_CONVENTION` or `GL_LAST_VERTEX_CONVENTION`, and controls the selection of the vertex whose values are assigned to flatshaded varying outputs. The interpretation of these values for the supported primitive types is:\n\n[TABLE]\n\nIf a vertex or geometry shader is active, user-defined varying outputs may be flatshaded by using the `flat` qualifier when declaring the output.\n\n## Notes\n\n`glProvokingVertex` is available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`provokeMode`* is not an accepted value.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glProvokingVertex`         |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glProvokingVertex.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glProvokingVertex.xhtml)"
- name: glPushDebugGroup
  id: glpushdebuggroup.xhtml
  summary: source The source of the debug message
  description: "## Name\n\nglPushDebugGroup — push a named debug group into the command stream\n\n## C Specification\n\n`void `**`glPushDebugGroup`**`(` GLenum `source`, GLuint `id`, GLsizei `length`, const char \\* `message``)`;\n\n## Parameters\n\n *`source`*  \nThe source of the debug message.\n\n *`id`*  \nThe identifier of the message.\n\n *`length`*  \nThe length of the message to be sent to the debug output stream.\n\n *`message`*  \nThe a string containing the message to be sent to the debug output stream.\n\n## Description\n\n`glPushDebugGroup` pushes a debug group described by the string *`message`* into the command stream. The value of *`id`* specifies the ID of messages generated. The parameter *`length`* contains the number of characters in *`message`*. If *`length`* is negative, it is implied that *`message`* contains a null terminated string. The message has the specified *`source`* and *`id`*, the *`type`* `GL_DEBUG_TYPE_PUSH_GROUP`, and *`severity`* `GL_DEBUG_SEVERITY_NOTIFICATION`. The GL will put a new debug group on top of the debug group stack which inherits the control of the volume of debug output of the debug group previously residing on the top of the debug group stack. Because debug groups are strictly hierarchical, any additional control of the debug output volume will only apply within the active debug group and the debug groups pushed on top of the active debug group.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if the value of *`source`* is neither `GL_DEBUG_SOURCE_APPLICATION` nor `GL_DEBUG_SOURCE_THIRD_PARTY`.\n\n`GL_INVALID_VALUE` is generated if *`length`* is negative and the number of characters in *`message`*, excluding the null-terminator, is not less than the value of `GL_MAX_DEBUG_MESSAGE_LENGTH`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_DEBUG_MESSAGE_LENGTH`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glPushDebugGroup`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glPopDebugGroup](glpopdebuggroup.xhtml), [glObjectLabel](globjectlabel.xhtml), [glObjectPtrLabel](globjectptrlabel.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glPushDebugGroup.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glPushDebugGroup.xhtml)"
- name: glQueryCounter
  id: glquerycounter.xhtml
  summary: glQueryCounter — record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed
  description: "## Name\n\nglQueryCounter — record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.\n\n## C Specification\n\n`void `**`glQueryCounter`**`(` GLuint `id`, GLenum `target``)`;\n\n## Parameters\n\n *`id`*  \nSpecify the name of a query object into which to record the GL time.\n\n *`target`*  \nSpecify the counter to query. *`target`* must be `GL_TIMESTAMP`.\n\n## Description\n\n`glQueryCounter` causes the GL to record the current time into the query object named *`id`*. *`target`* must be `GL_TIMESTAMP`. The time is recorded after all previous commands on the GL client and server state and the framebuffer have been fully realized. When the time is recorded, the query result for that object is marked available. `glQueryCounter` timer queries can be used within a [glBeginQuery](glbeginquery.xhtml) / `glEndQuery` block where the target is `GL_TIME_ELAPSED` and it does not affect the result of that query object.\n\n## Notes\n\n`glQueryCounter` is available only if the GL version is 3.3 or higher.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`id`* is the name of a query object that is already in use within a [glBeginQuery](glbeginquery.xhtml) / `glEndQuery` block.\n\n`GL_INVALID_VALUE` is generated if *`id`* is not the name of a query object returned from a previous call to [glGenQueries](glgenqueries.xhtml).\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_TIMESTAMP`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glQueryCounter`            |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenQueries](glgenqueries.xhtml), [glBeginQuery](glbeginquery.xhtml), `glEndQuery`, [glDeleteQueries](gldeletequeries.xhtml), [glGetQueryObject](glgetqueryobject.xhtml), [glGetQueryiv](glgetqueryiv.xhtml), [glGet](glget.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glQueryCounter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glQueryCounter.xhtml)"
- name: glReadBuffer
  id: glreadbuffer.xhtml
  summary: framebuffer Specifies the name of the framebuffer object for glNamedFramebufferReadBuffer function
  description: "## Name\n\nglReadBuffer, glNamedFramebufferReadBuffer — select a color buffer source for pixels\n\n## C Specification\n\n`void `**`glReadBuffer`**`(` GLenum `mode``)`;\n\n`void `**`glNamedFramebufferReadBuffer`**`(` GLuint `framebuffer`, GLenum `mode``)`;\n\n## Parameters\n\n *`framebuffer`*  \nSpecifies the name of the framebuffer object for `glNamedFramebufferReadBuffer` function.\n\n *`mode`*  \nSpecifies a color buffer. Accepted values are `GL_FRONT_LEFT`, `GL_FRONT_RIGHT`, `GL_BACK_LEFT`, `GL_BACK_RIGHT`, `GL_FRONT`, `GL_BACK`, `GL_LEFT`, `GL_RIGHT`, and the constants `GL_COLOR_ATTACHMENT`*i*.\n\n## Description\n\n`glReadBuffer` specifies a color buffer as the source for subsequent [glReadPixels](glreadpixels.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), and [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml) commands. *`mode`* accepts one of twelve or more predefined values. In a fully configured system, `GL_FRONT`, `GL_LEFT`, and `GL_FRONT_LEFT` all name the front left buffer, `GL_FRONT_RIGHT` and `GL_RIGHT` name the front right buffer, and `GL_BACK_LEFT` and `GL_BACK` name the back left buffer. Further more, the constants `GL_COLOR_ATTACHMENT`*i* may be used to indicate the *i*^(th) color attachment where *i* ranges from zero to the value of `GL_MAX_COLOR_ATTACHMENTS` minus one.\n\nNonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify a nonexistent buffer to `glReadBuffer`.\n\n*`mode`* is initially `GL_FRONT` in single-buffered configurations and `GL_BACK` in double-buffered configurations.\n\nFor `glReadBuffer`, the target framebuffer object is that bound to `GL_READ_FRAMEBUFFER`. For `glNamedFramebufferReadBuffer`, *`framebuffer`* must either be zero or the name of the target framebuffer object. If *`framebuffer`* is zero, then the default read framebuffer is affected.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`mode`* is not one of the twelve (or more) accepted values.\n\n`GL_INVALID_OPERATION` is generated if *`mode`* specifies a buffer that does not exist.\n\n`GL_INVALID_OPERATION` is generated by `glNamedFramebufferReadBuffer` if *`framebuffer`* is not zero or the name of an existing framebuffer object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_READ_BUFFER`\n\n## Version Support\n\n|                                | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**    |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glNamedFramebufferReadBuffer` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glReadBuffer`                 |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glDrawBuffer](gldrawbuffer.xhtml), [glReadPixels](glreadpixels.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glReadBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glReadBuffer.xhtml)"
- name: glReadnPixels
  id: glreadpixels.xhtml#glReadnPixels
  summary: Specify the window coordinates of the first pixel that is read from the frame buffer
  belongs_to: glReadPixels
  description: "`void `**`glReadnPixels`**`(` GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height`, GLenum `format`, GLenum `type`, GLsizei `bufSize`, void \\*`data``)`;\n\n## Parameters\n\n*`x`*, *`y`*\n\nSpecify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.\n\n*`width`*, *`height`*\n\nSpecify the dimensions of the pixel rectangle. *`width`* and *`height`* of one correspond to a single pixel.\n\n*`format`*\n\nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, and `GL_BGRA`.\n\n*`type`*\n\nSpecifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.\n\n*`bufSize`*\n\nSpecifies the size of the buffer *`data`* for `glReadnPixels` function.\n\n*`data`*\n\nReturns the pixel data.\n\n## Description\n\n`glReadPixels` and `glReadnPixels` return pixel data from the frame buffer, starting with the pixel whose lower left corner is at location (*`x`*, *`y`*), into client memory starting at location *`data`*. Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with [glPixelStore](glpixelstore.xhtml). This reference page describes the effects on `glReadPixels` and `glReadnPixels` of most, but not all of the parameters specified by these three commands.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a block of pixels is requested, *`data`* is treated as a byte offset into the buffer object's data store rather than a pointer to client memory.\n\n`glReadPixels` and `glReadnPixels` return values from each pixel with lower left corner at (*x* + *i*, *y* + *j*) for 0 \\<  = *i* \\< *w**i**d**t**h* and 0 \\<  = *j* \\< *h**e**i**g**h**t*. This pixel is said to be the *i*th pixel in the *j*th row. Pixels are returned in row order from the lowest to the highest row, left to right in each row.\n\n*`format`* specifies the format for the returned pixel values; accepted values are:\n\n`GL_STENCIL_INDEX`\n\nStencil values are read from the stencil buffer.\n\n`GL_DEPTH_COMPONENT`\n\nDepth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth value maps to 0 and the maximum value maps to 1. Each component is clamped to the range \\[0, 1\\].\n\n`GL_DEPTH_STENCIL`\n\nValues are taken from both the depth and stencil buffers. The *`type`* parameter must be `GL_UNSIGNED_INT_24_8` or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.\n\n`GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`\n\nColor values are taken from the color buffer.\n\nFinally, the indices or components are converted to the proper format, as specified by *`type`*. If *`format`* is `GL_STENCIL_INDEX` and *`type`* is not `GL_FLOAT`, each index is masked with the mask value given in the following table. If *`type`* is `GL_FLOAT`, then each integer index is converted to single-precision floating-point format.\n\nIf *`format`* is `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, or `GL_BGRA` and *`type`* is not `GL_FLOAT`, each component is multiplied by the multiplier shown in the following table. If type is `GL_FLOAT`, then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by the GL).\n\n| *`type`*                            |  **Index Mask**  |                **Component Conversion**               |\n|:------------------------------------|:----------------:|:-----------------------------------------------------:|\n| `GL_UNSIGNED_BYTE`                  |      2⁸ − 1      |                      (2⁸ − 1)*c*                      |\n| `GL_BYTE`                           |      2⁷ − 1      | $\\frac{\\left( {2^{8} - 1} \\right)\\mathit{c} - 1}{2}$  |\n| `GL_UNSIGNED_SHORT`                 |     2¹⁶ − 1      |                     (2¹⁶ − 1)*c*                      |\n| `GL_SHORT`                          |     2¹⁵ − 1      | $\\frac{\\left( {2^{16} - 1} \\right)\\mathit{c} - 1}{2}$ |\n| `GL_UNSIGNED_INT`                   |     2³² − 1      |                     (2³² − 1)*c*                      |\n| `GL_INT`                            |     2³¹ − 1      | $\\frac{\\left( {2^{32} - 1} \\right)\\mathit{c} - 1}{2}$ |\n| `GL_HALF_FLOAT`                     |       none       |                          *c*                          |\n| `GL_FLOAT`                          |       none       |                          *c*                          |\n| `GL_UNSIGNED_BYTE_3_3_2`            |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_BYTE_2_3_3_REV`        |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_5_6_5`           |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_5_6_5_REV`       |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_4_4_4_4`         |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_4_4_4_4_REV`     |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_5_5_5_1`         |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_1_5_5_5_REV`     |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_8_8_8_8`           |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_8_8_8_8_REV`       |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_10_10_10_2`        |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_2_10_10_10_REV`    |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_24_8`              |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_10F_11F_11F_REV`   |        --        |                        Special                        |\n| `GL_UNSIGNED_INT_5_9_9_9_REV`       |        --        |                        Special                        |\n| `GL_FLOAT_32_UNSIGNED_INT_24_8_REV` |       none       |                   *c* (Depth Only)                    |\n\nReturn values are placed in memory as follows. If *`format`* is `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_RED`, `GL_GREEN`, or `GL_BLUE`, a single value is returned and the data for the *i*th pixel in the *j*th row is placed in location (*j*)*w**i**d**t**h* + *i*. `GL_RGB` and `GL_BGR` return three values, `GL_RGBA` and `GL_BGRA` return four values for each pixel, with all values corresponding to a single pixel occupying contiguous space in *`data`*. Storage parameters set by [glPixelStore](glpixelstore.xhtml), such as `GL_PACK_LSB_FIRST` and `GL_PACK_SWAP_BYTES`, affect the way that data is written into memory. See [glPixelStore](glpixelstore.xhtml) for a description.\n\n`glReadnPixels` function will only handle the call if *`bufSize`* is at least of the size required to store the requested data. Otherwise, it will generate a `GL_INVALID_OPERATION` error.\n\n## Notes\n\nValues for pixels that lie outside the window connected to the current GL context are undefined.\n\nIf an error is generated, no change is made to the contents of *`data`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`format`* or *`type`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if either *`width`* or *`height`* is negative.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and there is no stencil buffer.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_DEPTH_COMPONENT` and there is no depth buffer.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_DEPTH_STENCIL` and there is no depth buffer or if there is no stencil buffer.\n\n`GL_INVALID_ENUM` is generated if *`format`* is `GL_DEPTH_STENCIL` and *`type`* is not `GL_UNSIGNED_INT_24_8` or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and *`data`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n`GL_INVALID_OPERATION` is generated if `GL_READ_FRAMEBUFFER_BINDING` is non-zero, the read framebuffer is complete, and the value of `GL_SAMPLE_BUFFERS` for the read framebuffer is greater than zero.\n\n`GL_INVALID_OPERATION` is generated by `glReadnPixels` if the buffer size required to store the requested data is greater than *`bufSize`*.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_PACK_BUFFER_BINDING`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glReadPixels`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glReadnPixels`               |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glPixelStore](glpixelstore.xhtml), [glReadBuffer](glreadbuffer.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glReadPixels.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glReadPixels.xhtml)"
- name: glReadPixels
  id: glreadpixels.xhtml
  summary: x, y Specify the window coordinates of the first pixel that is read from the frame buffer
  description: "## Name\n\nglReadPixels, glReadnPixels — read a block of pixels from the frame buffer\n\n## C Specification\n\n`void `**`glReadPixels`**`(` GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height`, GLenum `format`, GLenum `type`, void \\* `data``)`;\n\n`void `**`glReadnPixels`**`(` GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height`, GLenum `format`, GLenum `type`, GLsizei `bufSize`, void \\*`data``)`;\n\n## Parameters\n\n*`x`*,   *`y`*  \nSpecify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.\n\n*`width`*,   *`height`*  \nSpecify the dimensions of the pixel rectangle. *`width`* and *`height`* of one correspond to a single pixel.\n\n *`format`*  \nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`, `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, and `GL_BGRA`.\n\n *`type`*  \nSpecifies the data type of the pixel data. Must be one of `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_24_8`, `GL_UNSIGNED_INT_10F_11F_11F_REV`, `GL_UNSIGNED_INT_5_9_9_9_REV`, or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.\n\n *`bufSize`*  \nSpecifies the size of the buffer *`data`* for `glReadnPixels` function.\n\n *`data`*  \nReturns the pixel data.\n\n## Description\n\n`glReadPixels` and `glReadnPixels` return pixel data from the frame buffer, starting with the pixel whose lower left corner is at location (*`x`*, *`y`*), into client memory starting at location *`data`*. Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with [glPixelStore](glpixelstore.xhtml). This reference page describes the effects on `glReadPixels` and `glReadnPixels` of most, but not all of the parameters specified by these three commands.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_PACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a block of pixels is requested, *`data`* is treated as a byte offset into the buffer object's data store rather than a pointer to client memory.\n\n`glReadPixels` and `glReadnPixels` return values from each pixel with lower left corner at (*x* + *i*, *y* + *j*) for 0 \\<  = *i* \\< *w**i**d**t**h* and 0 \\<  = *j* \\< *h**e**i**g**h**t*. This pixel is said to be the *i*th pixel in the *j*th row. Pixels are returned in row order from the lowest to the highest row, left to right in each row.\n\n*`format`* specifies the format for the returned pixel values; accepted values are:\n\n `GL_STENCIL_INDEX`  \nStencil values are read from the stencil buffer.\n\n `GL_DEPTH_COMPONENT`  \nDepth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth value maps to 0 and the maximum value maps to 1. Each component is clamped to the range \\[0, 1\\].\n\n `GL_DEPTH_STENCIL`  \nValues are taken from both the depth and stencil buffers. The *`type`* parameter must be `GL_UNSIGNED_INT_24_8` or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.\n\n`GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`  \nColor values are taken from the color buffer.\n\nFinally, the indices or components are converted to the proper format, as specified by *`type`*. If *`format`* is `GL_STENCIL_INDEX` and *`type`* is not `GL_FLOAT`, each index is masked with the mask value given in the following table. If *`type`* is `GL_FLOAT`, then each integer index is converted to single-precision floating-point format.\n\nIf *`format`* is `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, or `GL_BGRA` and *`type`* is not `GL_FLOAT`, each component is multiplied by the multiplier shown in the following table. If type is `GL_FLOAT`, then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by the GL).\n\n| *`type`*                            |  **Index Mask**  |                **Component Conversion**               |\n|:------------------------------------|:----------------:|:-----------------------------------------------------:|\n| `GL_UNSIGNED_BYTE`                  |      2⁸ − 1      |                      (2⁸ − 1)*c*                      |\n| `GL_BYTE`                           |      2⁷ − 1      | $\\frac{\\left( {2^{8} - 1} \\right)\\mathit{c} - 1}{2}$  |\n| `GL_UNSIGNED_SHORT`                 |     2¹⁶ − 1      |                     (2¹⁶ − 1)*c*                      |\n| `GL_SHORT`                          |     2¹⁵ − 1      | $\\frac{\\left( {2^{16} - 1} \\right)\\mathit{c} - 1}{2}$ |\n| `GL_UNSIGNED_INT`                   |     2³² − 1      |                     (2³² − 1)*c*                      |\n| `GL_INT`                            |     2³¹ − 1      | $\\frac{\\left( {2^{32} - 1} \\right)\\mathit{c} - 1}{2}$ |\n| `GL_HALF_FLOAT`                     |       none       |                          *c*                          |\n| `GL_FLOAT`                          |       none       |                          *c*                          |\n| `GL_UNSIGNED_BYTE_3_3_2`            |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_BYTE_2_3_3_REV`        |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_5_6_5`           |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_5_6_5_REV`       |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_4_4_4_4`         |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_4_4_4_4_REV`     |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_5_5_5_1`         |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_SHORT_1_5_5_5_REV`     |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_8_8_8_8`           |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_8_8_8_8_REV`       |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_10_10_10_2`        |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_2_10_10_10_REV`    |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_24_8`              |   2^(*N*) − 1    |                   (2^(*N*) − 1)*c*                    |\n| `GL_UNSIGNED_INT_10F_11F_11F_REV`   |        --        |                        Special                        |\n| `GL_UNSIGNED_INT_5_9_9_9_REV`       |        --        |                        Special                        |\n| `GL_FLOAT_32_UNSIGNED_INT_24_8_REV` |       none       |                   *c* (Depth Only)                    |\n\nReturn values are placed in memory as follows. If *`format`* is `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_RED`, `GL_GREEN`, or `GL_BLUE`, a single value is returned and the data for the *i*th pixel in the *j*th row is placed in location (*j*)*w**i**d**t**h* + *i*. `GL_RGB` and `GL_BGR` return three values, `GL_RGBA` and `GL_BGRA` return four values for each pixel, with all values corresponding to a single pixel occupying contiguous space in *`data`*. Storage parameters set by [glPixelStore](glpixelstore.xhtml), such as `GL_PACK_LSB_FIRST` and `GL_PACK_SWAP_BYTES`, affect the way that data is written into memory. See [glPixelStore](glpixelstore.xhtml) for a description.\n\n`glReadnPixels` function will only handle the call if *`bufSize`* is at least of the size required to store the requested data. Otherwise, it will generate a `GL_INVALID_OPERATION` error.\n\n## Notes\n\nValues for pixels that lie outside the window connected to the current GL context are undefined.\n\nIf an error is generated, no change is made to the contents of *`data`*.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`format`* or *`type`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if either *`width`* or *`height`* is negative.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and there is no stencil buffer.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_DEPTH_COMPONENT` and there is no depth buffer.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_DEPTH_STENCIL` and there is no depth buffer or if there is no stencil buffer.\n\n`GL_INVALID_ENUM` is generated if *`format`* is `GL_DEPTH_STENCIL` and *`type`* is not `GL_UNSIGNED_INT_24_8` or `GL_FLOAT_32_UNSIGNED_INT_24_8_REV`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_PACK_BUFFER` target and *`data`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n`GL_INVALID_OPERATION` is generated if `GL_READ_FRAMEBUFFER_BINDING` is non-zero, the read framebuffer is complete, and the value of `GL_SAMPLE_BUFFERS` for the read framebuffer is greater than zero.\n\n`GL_INVALID_OPERATION` is generated by `glReadnPixels` if the buffer size required to store the requested data is greater than *`bufSize`*.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_PACK_BUFFER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glReadPixels`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glReadnPixels`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glPixelStore](glpixelstore.xhtml), [glReadBuffer](glreadbuffer.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glReadPixels.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glReadPixels.xhtml)"
- name: glReleaseShaderCompiler
  id: glreleaseshadercompiler.xhtml
  summary: glReleaseShaderCompiler provides a hint to the implementation that it may free internal resources associated with its shader compiler
  description: "## Name\n\nglReleaseShaderCompiler — release resources consumed by the implementation's shader compiler\n\n## C Specification\n\n`void `**`glReleaseShaderCompiler`**`(` void`)`;\n\n## Description\n\n`glReleaseShaderCompiler` provides a hint to the implementation that it may free internal resources associated with its shader compiler. [glCompileShader](glcompileshader.xhtml) may subsequently be called and the implementation may at that time reallocate resources previously freed by the call to `glReleaseShaderCompiler`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glReleaseShaderCompiler`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCompileShader](glcompileshader.xhtml), [glLinkProgram](gllinkprogram.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glReleaseShaderCompiler.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glReleaseShaderCompiler.xhtml)"
- name: glRenderbufferStorage
  id: glrenderbufferstorage.xhtml
  summary: target Specifies a binding target of the allocation for glRenderbufferStorage function
  description: "## Name\n\nglRenderbufferStorage, glNamedRenderbufferStorage — establish data storage, format and dimensions of a renderbuffer object's image\n\n## C Specification\n\n`void `**`glRenderbufferStorage`**`(` GLenum `target`, GLenum `internalformat`, GLsizei `width`, GLsizei `height``)`;\n\n`void `**`glNamedRenderbufferStorage`**`(` GLuint `renderbuffer`, GLenum `internalformat`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies a binding target of the allocation for `glRenderbufferStorage` function. Must be `GL_RENDERBUFFER`.\n\n *`renderbuffer`*  \nSpecifies the name of the renderbuffer object for `glNamedRenderbufferStorage` function.\n\n *`internalformat`*  \nSpecifies the internal format to use for the renderbuffer object's image.\n\n *`width`*  \nSpecifies the width of the renderbuffer, in pixels.\n\n *`height`*  \nSpecifies the height of the renderbuffer, in pixels.\n\n## Description\n\n`glRenderbufferStorage` is equivalent to calling [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml) with the *`samples`* set to zero, and `glNamedRenderbufferStorage` is equivalent to calling `glNamedRenderbufferStorageMultisample` with the samples set to zero.\n\nFor `glRenderbufferStorage`, the target of the operation, specified by *`target`* must be `GL_RENDERBUFFER`. For `glNamedRenderbufferStorage`, *`renderbuffer`* must be a name of an existing renderbuffer object. *`internalformat`* specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. *`width`* and *`height`* are the dimensions, in pixels, of the renderbuffer. Both *`width`* and *`height`* must be less than or equal to the value of `GL_MAX_RENDERBUFFER_SIZE`.\n\nUpon success, `glRenderbufferStorage` and `glNamedRenderbufferStorage` delete any existing data store for the renderbuffer image and the contents of the data store after calling `glRenderbufferStorage` are undefined.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glRenderbufferStorage` if *`target`* is not `GL_RENDERBUFFER`.\n\n`GL_INVALID_OPERATION` is generated by glNamedRenderbufferStorage if *`renderbuffer`* is not the name of an existing renderbuffer object.\n\n`GL_INVALID_VALUE` is generated if either of *`width`* or *`height`* is negative, or greater than the value of `GL_MAX_RENDERBUFFER_SIZE`.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a color-renderable, depth-renderable, or stencil-renderable format.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store of the requested size.\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glNamedRenderbufferStorage` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glRenderbufferStorage`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenRenderbuffers](glgenrenderbuffers.xhtml), [glBindRenderbuffer](glbindrenderbuffer.xhtml), `glNamedRenderbufferStorageMultisample`, [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glDeleteRenderbuffers](gldeleterenderbuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glRenderbufferStorage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glRenderbufferStorage.xhtml)"
- name: glRenderbufferStorageMultisample
  id: glrenderbufferstoragemultisample.xhtml
  summary: target Specifies a binding target of the allocation for glRenderbufferStorageMultisample function
  description: "## Name\n\nglRenderbufferStorageMultisample, glNamedRenderbufferStorageMultisample — establish data storage, format, dimensions and sample count of a renderbuffer object's image\n\n## C Specification\n\n`void `**`glRenderbufferStorageMultisample`**`(` GLenum `target`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height``)`;\n\n`void `**`glNamedRenderbufferStorageMultisample`**`(` GLuint `renderbuffer`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies a binding target of the allocation for `glRenderbufferStorageMultisample` function. Must be `GL_RENDERBUFFER`.\n\n *`renderbuffer`*  \nSpecifies the name of the renderbuffer object for `glNamedRenderbufferStorageMultisample` function.\n\n *`samples`*  \nSpecifies the number of samples to be used for the renderbuffer object's storage.\n\n *`internalformat`*  \nSpecifies the internal format to use for the renderbuffer object's image.\n\n *`width`*  \nSpecifies the width of the renderbuffer, in pixels.\n\n *`height`*  \nSpecifies the height of the renderbuffer, in pixels.\n\n## Description\n\n`glRenderbufferStorageMultisample` and `glNamedRenderbufferStorageMultisample` establish the data storage, format, dimensions and number of samples of a renderbuffer object's image.\n\nFor `glRenderbufferStorageMultisample`, the target of the operation, specified by *`target`* must be `GL_RENDERBUFFER`. For `glNamedRenderbufferStorageMultisample`, *`renderbuffer`* must be an ID of an existing renderbuffer object. *`internalformat`* specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. *`width`* and *`height`* are the dimensions, in pixels, of the renderbuffer. Both *`width`* and *`height`* must be less than or equal to the value of `GL_MAX_RENDERBUFFER_SIZE`. *`samples`* specifies the number of samples to be used for the renderbuffer object's image, and must be less than or equal to the value of `GL_MAX_SAMPLES`. If *`internalformat`* is a signed or unsigned integer format then *`samples`* must be less than or equal to the value of `GL_MAX_INTEGER_SAMPLES`.\n\nUpon success, `glRenderbufferStorageMultisample` and `glNamedRenderbufferStorageMultisample` delete any existing data store for the renderbuffer image and the contents of the data store after calling either of the functions are undefined.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glRenderbufferStorageMultisample` function if *`target`* is not `GL_RENDERBUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glNamedRenderbufferStorageMultisample` function if *`renderbuffer`* is not the name of an existing renderbuffer object.\n\n`GL_INVALID_OPERATION` is generated if *`samples`* is greater than the maximum number of samples supported for *`internalformat`*.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a color-renderable, depth-renderable, or stencil-renderable format.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is a signed or unsigned integer format and *`samples`* is greater than the value of `GL_MAX_INTEGER_SAMPLES`\n\n`GL_INVALID_VALUE` is generated if either of *`width`* or *`height`* is negative, or greater than the value of `GL_MAX_RENDERBUFFER_SIZE`.\n\n`GL_OUT_OF_MEMORY` is generated if the GL is unable to create a data store of the requested size.\n\n## Version Support\n\n|                                         | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**             |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glNamedRenderbufferStorageMultisample` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glRenderbufferStorageMultisample`      |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenRenderbuffers](glgenrenderbuffers.xhtml), [glBindRenderbuffer](glbindrenderbuffer.xhtml), `glNamedRenderbufferStorage`, [glRenderbufferStorage](glrenderbufferstorage.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glDeleteRenderbuffers](gldeleterenderbuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glRenderbufferStorageMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glRenderbufferStorageMultisample.xhtml)"
- name: glResumeTransformFeedback
  id: glresumetransformfeedback.xhtml
  summary: glResumeTransformFeedback resumes transform feedback operations on the currently active transform feedback object
  description: "## Name\n\nglResumeTransformFeedback — resume transform feedback operations\n\n## C Specification\n\n`void `**`glResumeTransformFeedback`**`(` void`)`;\n\n## Description\n\n`glResumeTransformFeedback` resumes transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if the currently bound transform feedback object is not active or is not paused.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glResumeTransformFeedback` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenTransformFeedbacks](glgentransformfeedbacks.xhtml), [glBindTransformFeedback](glbindtransformfeedback.xhtml), [glBeginTransformFeedback](glbegintransformfeedback.xhtml), [glPauseTransformFeedback](glpausetransformfeedback.xhtml), `glEndTransformFeedback`, [glDeleteTransformFeedbacks](gldeletetransformfeedbacks.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glResumeTransformFeedback.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glResumeTransformFeedback.xhtml)"
- name: glSampleCoverage
  id: glsamplecoverage.xhtml
  summary: value Specify a single floating-point sample coverage value
  description: "## Name\n\nglSampleCoverage — specify multisample coverage parameters\n\n## C Specification\n\n`void `**`glSampleCoverage`**`(` GLfloat `value`, GLboolean `invert``)`;\n\n## Parameters\n\n *`value`*  \nSpecify a single floating-point sample coverage value. The value is clamped to the range \\[0, 1\\]. The initial value is 1.0.\n\n *`invert`*  \nSpecify a single boolean value representing if the coverage masks should be inverted. `GL_TRUE` and `GL_FALSE` are accepted. The initial value is `GL_FALSE`.\n\n## Description\n\nMultisampling samples a pixel multiple times at various implementation-dependent subpixel locations to generate antialiasing effects. Multisampling transparently antialiases points, lines, polygons, and images if it is enabled.\n\n*`value`* is used in constructing a temporary mask used in determining which samples will be used in resolving the final fragment color. This mask is bitwise-anded with the coverage mask generated from the multisampling computation. If the *`invert`* flag is set, the temporary mask is inverted (all bits flipped) and then the bitwise-and is computed.\n\nIf an implementation does not have any multisample buffers available, or multisampling is disabled, rasterization occurs with only a single sample computing a pixel's final RGB color.\n\nProvided an implementation supports multisample buffers, and multisampling is enabled, then a pixel's final color is generated by combining several samples per pixel. Each sample contains color, depth, and stencil information, allowing those operations to be performed on each sample.\n\n## Notes\n\nThe type of the *`value`* parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the [removedTypes](removedtypes.xhtml) page.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_SAMPLE_COVERAGE_VALUE`\n\n[glGet](glget.xhtml) with argument `GL_SAMPLE_COVERAGE_INVERT`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_MULTISAMPLE`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_SAMPLE_ALPHA_TO_COVERAGE`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_SAMPLE_ALPHA_TO_ONE`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_SAMPLE_COVERAGE`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glSampleCoverage`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glEnable](glenable.xhtml), [removedTypes](removedtypes.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glSampleCoverage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glSampleCoverage.xhtml)"
- name: glSampleMaski
  id: glsamplemaski.xhtml
  summary: maskNumber Specifies which 32-bit sub-word of the sample mask to update
  description: "## Name\n\nglSampleMaski — set the value of a sub-word of the sample mask\n\n## C Specification\n\n`void `**`glSampleMaski`**`(` GLuint `maskNumber`, GLbitfield `mask``)`;\n\n## Parameters\n\n *`maskNumber`*  \nSpecifies which 32-bit sub-word of the sample mask to update.\n\n *`mask`*  \nSpecifies the new value of the mask sub-word.\n\n## Description\n\n`glSampleMaski` sets one 32-bit sub-word of the multi-word sample mask, `GL_SAMPLE_MASK_VALUE`.\n\n*`maskIndex`* specifies which 32-bit sub-word of the sample mask to update, and *`mask`* specifies the new value to use for that sub-word. *`maskIndex`* must be less than the value of `GL_MAX_SAMPLE_MASK_WORDS`. Bit *B* of mask word *M* corresponds to sample 32 x *M* + *B*.\n\n## Notes\n\n`glSampleMaski` is available only if the GL version is 3.2 or greater, or if the `ARB_texture_multisample` extension is supported.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`maskIndex`* is greater than or equal to the value of `GL_MAX_SAMPLE_MASK_WORDS`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glSampleMaski`             |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenRenderbuffers](glgenrenderbuffers.xhtml), [glBindRenderbuffer](glbindrenderbuffer.xhtml), [glRenderbufferStorageMultisample](glrenderbufferstoragemultisample.xhtml), [glFramebufferRenderbuffer](glframebufferrenderbuffer.xhtml), [glDeleteRenderbuffers](gldeleterenderbuffers.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glSampleMaski.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glSampleMaski.xhtml)"
- name: glSamplerParameter
  id: glsamplerparameter.xhtml
  summary: sampler Specifies the sampler object whose parameter to modify
  description: "## Name\n\nglSamplerParameter — set sampler parameters\n\n## C Specification\n\n`void `**`glSamplerParameterf`**`(` GLuint `sampler`, GLenum `pname`, GLfloat `param``)`;\n\n`void `**`glSamplerParameteri`**`(` GLuint `sampler`, GLenum `pname`, GLint `param``)`;\n\n`void `**`glSamplerParameterfv`**`(` GLuint `sampler`, GLenum `pname`, const GLfloat \\* `params``)`;\n\n`void `**`glSamplerParameteriv`**`(` GLuint `sampler`, GLenum `pname`, const GLint \\* `params``)`;\n\n`void `**`glSamplerParameterIiv`**`(` GLuint `sampler`, GLenum `pname`, const GLint \\*`params``)`;\n\n`void `**`glSamplerParameterIuiv`**`(` GLuint `sampler`, GLenum `pname`, const GLuint \\*`params``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler object whose parameter to modify.\n\n *`pname`*  \nSpecifies the symbolic name of a sampler parameter. *`pname`* can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS` `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`.\n\n *`param`*  \nFor the scalar commands, specifies the value of *`pname`*.\n\n *`params`*  \nFor the vector commands (`glSamplerParameter*v`), specifies a pointer to an array where the value or values of *`pname`* are stored.\n\n## Description\n\n`glSamplerParameter` assigns the value or values in *`params`* to the sampler parameter specified as *`pname`*. *`sampler`* specifies the sampler object to be modified, and must be the name of a sampler object previously returned from a call to [glGenSamplers](glgensamplers.xhtml). The following symbols are accepted in *`pname`*:\n\n `GL_TEXTURE_MIN_FILTER`  \nThe texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps.\n\nA mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2^(*n*) × 2^(*m*), there are *max* (*n*, *m*) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2^(*n*) × 2^(*m*). Each subsequent mipmap has dimensions 2^(*k* − 1) × 2^(*l* − 1), where 2^(*k*) × 2^(*l*) are the dimensions of the previous mipmap, until either *k* = 0 or *l* = 0. At that point, subsequent mipmaps have dimension 1 × 2^(*l* − 1) or 2^(*k* − 1) × 1 until the final mipmap, which has dimension 1 × 1. To define the mipmaps, call [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), or [glCopyTexImage2D](glcopyteximage2d.xhtml) with the *level* argument indicating the order of the mipmaps. Level 0 is the original texture; level *max* (*n*, *m*) is the final 1 × 1 mipmap.\n\n*`params`* supplies a function for minifying the texture as one of the following:\n\n `GL_NEAREST`  \nReturns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.\n\n `GL_LINEAR`  \nReturns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`, and on the exact mapping.\n\n `GL_NEAREST_MIPMAP_NEAREST`  \nChooses the mipmap that most closely matches the size of the pixel being textured and uses the `GL_NEAREST` criterion (the texture element nearest to the center of the pixel) to produce a texture value.\n\n `GL_LINEAR_MIPMAP_NEAREST`  \nChooses the mipmap that most closely matches the size of the pixel being textured and uses the `GL_LINEAR` criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value.\n\n `GL_NEAREST_MIPMAP_LINEAR`  \nChooses the two mipmaps that most closely match the size of the pixel being textured and uses the `GL_NEAREST` criterion (the texture element nearest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.\n\n `GL_LINEAR_MIPMAP_LINEAR`  \nChooses the two mipmaps that most closely match the size of the pixel being textured and uses the `GL_LINEAR` criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.\n\nAs more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the `GL_NEAREST` and `GL_LINEAR` minification functions can be faster than the other four, they sample only one or four texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of `GL_TEXTURE_MIN_FILTER` is `GL_NEAREST_MIPMAP_LINEAR`.\n\n `GL_TEXTURE_MAG_FILTER`  \nThe texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either `GL_NEAREST` or `GL_LINEAR` (see below). `GL_NEAREST` is generally faster than `GL_LINEAR`, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of `GL_TEXTURE_MAG_FILTER` is `GL_LINEAR`.\n\n `GL_NEAREST`  \nReturns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.\n\n `GL_LINEAR`  \nReturns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`, and on the exact mapping.\n\n `GL_TEXTURE_MIN_LOD`  \nSets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.\n\n `GL_TEXTURE_MAX_LOD`  \nSets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.\n\n `GL_TEXTURE_WRAP_S`  \nSets the wrap parameter for texture coordinate *s* to either `GL_CLAMP_TO_EDGE`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. `GL_CLAMP_TO_BORDER` causes the *s* coordinate to be clamped to the range $\\left\\lbrack {\\frac{-1}{2\\mathit{N}},{1 + \\frac{1}{2\\mathit{N}}}} \\right\\rbrack$, where *N* is the size of the texture in the direction of clamping.`GL_CLAMP_TO_EDGE` causes *s* coordinates to be clamped to the range $\\left\\lbrack {\\frac{1}{2\\mathit{N}},{1 - \\frac{1}{2\\mathit{N}}}} \\right\\rbrack$, where *N* is the size of the texture in the direction of clamping. `GL_REPEAT` causes the integer part of the *s* coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. `GL_MIRRORED_REPEAT` causes the *s* coordinate to be set to the fractional part of the texture coordinate if the integer part of *s* is even; if the integer part of *s* is odd, then the *s* texture coordinate is set to 1 − *f**r**a**c*(*s*), where *f**r**a**c*(*s*) represents the fractional part of *s*. `GL_MIRROR_CLAMP_TO_EDGE` causes the *s* coordinate to be repeated as for `GL_MIRRORED_REPEAT` for one repetition of the texture, at which point the coordinate to be clamped as in `GL_CLAMP_TO_EDGE`. Initially, `GL_TEXTURE_WRAP_S` is set to `GL_REPEAT`.\n\n `GL_TEXTURE_WRAP_T`  \nSets the wrap parameter for texture coordinate *t* to either `GL_CLAMP_TO_EDGE`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. See the discussion under `GL_TEXTURE_WRAP_S`. Initially, `GL_TEXTURE_WRAP_T` is set to `GL_REPEAT`.\n\n `GL_TEXTURE_WRAP_R`  \nSets the wrap parameter for texture coordinate *r* to either `GL_CLAMP_TO_EDGE`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. See the discussion under `GL_TEXTURE_WRAP_S`. Initially, `GL_TEXTURE_WRAP_R` is set to `GL_REPEAT`.\n\n `GL_TEXTURE_BORDER_COLOR`  \nThe data in *`params`* specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of `GL_TEXTURE_BORDER_COLOR` are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of `GL_TEXTURE_BORDER_COLOR` is interpreted as a depth value. The initial value is (0.0, 0.0, 0.0, 0.0).\n\n `GL_TEXTURE_COMPARE_MODE`  \nSpecifies the texture comparison mode for currently bound textures. That is, a texture whose internal format is `GL_DEPTH_COMPONENT_*`; see [glTexImage2D](glteximage2d.xhtml)) Permissible values are:\n\n `GL_COMPARE_REF_TO_TEXTURE`  \nSpecifies that the interpolated and clamped *r* texture coordinate should be compared to the value in the currently bound texture. See the discussion of `GL_TEXTURE_COMPARE_FUNC` for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.\n\n `GL_NONE`  \nSpecifies that the red channel should be assigned the appropriate value from the currently bound texture.\n\n `GL_TEXTURE_COMPARE_FUNC`  \nSpecifies the comparison operator used when `GL_TEXTURE_COMPARE_MODE` is set to `GL_COMPARE_REF_TO_TEXTURE`. Permissible values are:\n\n|  **Texture Comparison Function**  |  **Computed result**                          |\n|:----------------------------------|:----------------------------------------------|\n| `GL_LEQUAL`                       | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r}\\<=\\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\> \\mathit{D}\\_{\\mathit{t}}}       \n                                     \\end{matrix}} \\right.$                         |\n| `GL_GEQUAL`                       | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r}\\>=\\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\< \\mathit{D}\\_{\\mathit{t}}}       \n                                     \\end{matrix}} \\right.$                         |\n| `GL_LESS`                         | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\< \\mathit{D}\\_{\\mathit{t}}} \\\\    \n                                     {\\mathit{r}\\>=\\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_GREATER`                      | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\> \\mathit{D}\\_{\\mathit{t}}} \\\\    \n                                     {\\mathit{r}\\<=\\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_EQUAL`                        | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} = \\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\neq \\mathit{D}\\_{\\mathit{t}}}     \n                                     \\end{matrix}} \\right.$                         |\n| `GL_NOTEQUAL`                     | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\neq \\mathit{D}\\_{\\mathit{t}}} \\\\  \n                                     {\\mathit{r} = \\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_ALWAYS`                       | *r**e**s**u**l**t* = 1.0                      |\n| `GL_NEVER`                        | *r**e**s**u**l**t* = 0.0                      |\n\nwhere *r* is the current interpolated texture coordinate, and *D*_(*t*) is the texture value sampled from the currently bound texture. *r**e**s**u**l**t* is assigned to *R*_(*t*).\n\n## Notes\n\n`glSamplerParameter` is available only if the GL version is 3.3 or higher.\n\nIf a sampler object is bound to a texture unit and that unit is used to sample from a texture, the parameters in the sampler are used to sample from the texture, rather than the equivalent parameters in the texture object bound to that unit. This introduces the possibility of sampling from the same texture object with different sets of sampler state, which may lead to a condition where a texture is *incomplete* with respect to one sampler object and not with respect to another. Thus, completeness can be considered a function of a sampler object and a texture object bound to a single texture unit, rather than a property of the texture object itself.\n\n`GL_MIRROR_CLAMP_TO_EDGE` is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`sampler`* is not the name of a sampler object previously returned from a call to [glGenSamplers](glgensamplers.xhtml).\n\n`GL_INVALID_ENUM` is generated if *`params`* should have a defined constant value (based on the value of *`pname`*) and does not.\n\n## Associated Gets\n\n[glGetSamplerParameter](glgetsamplerparameter.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glSamplerParameterIiv`     |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glSamplerParameterIuiv`    |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glSamplerParameterf`       |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glSamplerParameterfv`      |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glSamplerParameteri`       |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glSamplerParameteriv`      |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenSamplers](glgensamplers.xhtml), [glBindSampler](glbindsampler.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml), [glIsSampler](glissampler.xhtml), [glBindTexture](glbindtexture.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glSamplerParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glSamplerParameter.xhtml)"
- name: glSamplerParameterf
  id: glsamplerparameter.xhtml#glSamplerParameterf
  summary: null
  belongs_to: glSamplerParameter
  description: '`void `**`glSamplerParameterf`**`(` GLuint `sampler`, GLenum `pname`, GLfloat `param``)`;'
- name: glSamplerParameterfv
  id: glsamplerparameter.xhtml#glSamplerParameterfv
  summary: null
  belongs_to: glSamplerParameter
  description: '`void `**`glSamplerParameterfv`**`(` GLuint `sampler`, GLenum `pname`, const GLfloat \* `params``)`;'
- name: glSamplerParameteri
  id: glsamplerparameter.xhtml#glSamplerParameteri
  summary: null
  belongs_to: glSamplerParameter
  description: '`void `**`glSamplerParameteri`**`(` GLuint `sampler`, GLenum `pname`, GLint `param``)`;'
- name: glSamplerParameterIiv
  id: glsamplerparameter.xhtml#glSamplerParameterIiv
  summary: null
  belongs_to: glSamplerParameter
  description: '`void `**`glSamplerParameterIiv`**`(` GLuint `sampler`, GLenum `pname`, const GLint \*`params``)`;'
- name: glSamplerParameterIuiv
  id: glsamplerparameter.xhtml#glSamplerParameterIuiv
  summary: Specifies the sampler object whose parameter to modify
  belongs_to: glSamplerParameter
  description: "`void `**`glSamplerParameterIuiv`**`(` GLuint `sampler`, GLenum `pname`, const GLuint \\*`params``)`;\n\n## Parameters\n\n*`sampler`*\n\nSpecifies the sampler object whose parameter to modify.\n\n*`pname`*\n\nSpecifies the symbolic name of a sampler parameter. *`pname`* can be one of the following: `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, `GL_TEXTURE_WRAP_R`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_BORDER_COLOR`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_LOD_BIAS` `GL_TEXTURE_COMPARE_MODE`, or `GL_TEXTURE_COMPARE_FUNC`.\n\n*`param`*\n\nFor the scalar commands, specifies the value of *`pname`*.\n\n*`params`*\n\nFor the vector commands (`glSamplerParameter*v`), specifies a pointer to an array where the value or values of *`pname`* are stored.\n\n## Description\n\n`glSamplerParameter` assigns the value or values in *`params`* to the sampler parameter specified as *`pname`*. *`sampler`* specifies the sampler object to be modified, and must be the name of a sampler object previously returned from a call to [glGenSamplers](glgensamplers.xhtml). The following symbols are accepted in *`pname`*:\n\n`GL_TEXTURE_MIN_FILTER`\n\nThe texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps.\n\nA mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2^(*n*) × 2^(*m*), there are *max* (*n*, *m*) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2^(*n*) × 2^(*m*). Each subsequent mipmap has dimensions 2^(*k* − 1) × 2^(*l* − 1), where 2^(*k*) × 2^(*l*) are the dimensions of the previous mipmap, until either *k* = 0 or *l* = 0. At that point, subsequent mipmaps have dimension 1 × 2^(*l* − 1) or 2^(*k* − 1) × 1 until the final mipmap, which has dimension 1 × 1. To define the mipmaps, call [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), or [glCopyTexImage2D](glcopyteximage2d.xhtml) with the *level* argument indicating the order of the mipmaps. Level 0 is the original texture; level *max* (*n*, *m*) is the final 1 × 1 mipmap.\n\n*`params`* supplies a function for minifying the texture as one of the following:\n\n`GL_NEAREST`\n\nReturns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.\n\n`GL_LINEAR`\n\nReturns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`, and on the exact mapping.\n\n`GL_NEAREST_MIPMAP_NEAREST`\n\nChooses the mipmap that most closely matches the size of the pixel being textured and uses the `GL_NEAREST` criterion (the texture element nearest to the center of the pixel) to produce a texture value.\n\n`GL_LINEAR_MIPMAP_NEAREST`\n\nChooses the mipmap that most closely matches the size of the pixel being textured and uses the `GL_LINEAR` criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value.\n\n`GL_NEAREST_MIPMAP_LINEAR`\n\nChooses the two mipmaps that most closely match the size of the pixel being textured and uses the `GL_NEAREST` criterion (the texture element nearest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.\n\n`GL_LINEAR_MIPMAP_LINEAR`\n\nChooses the two mipmaps that most closely match the size of the pixel being textured and uses the `GL_LINEAR` criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.\n\nAs more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the `GL_NEAREST` and `GL_LINEAR` minification functions can be faster than the other four, they sample only one or four texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of `GL_TEXTURE_MIN_FILTER` is `GL_NEAREST_MIPMAP_LINEAR`.\n\n`GL_TEXTURE_MAG_FILTER`\n\nThe texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either `GL_NEAREST` or `GL_LINEAR` (see below). `GL_NEAREST` is generally faster than `GL_LINEAR`, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of `GL_TEXTURE_MAG_FILTER` is `GL_LINEAR`.\n\n`GL_NEAREST`\n\nReturns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.\n\n`GL_LINEAR`\n\nReturns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`, and on the exact mapping.\n\n`GL_TEXTURE_MIN_LOD`\n\nSets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.\n\n`GL_TEXTURE_MAX_LOD`\n\nSets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.\n\n`GL_TEXTURE_WRAP_S`\n\nSets the wrap parameter for texture coordinate *s* to either `GL_CLAMP_TO_EDGE`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. `GL_CLAMP_TO_BORDER` causes the *s* coordinate to be clamped to the range $\\left\\lbrack {\\frac{-1}{2\\mathit{N}},{1 + \\frac{1}{2\\mathit{N}}}} \\right\\rbrack$, where *N* is the size of the texture in the direction of clamping.`GL_CLAMP_TO_EDGE` causes *s* coordinates to be clamped to the range $\\left\\lbrack {\\frac{1}{2\\mathit{N}},{1 - \\frac{1}{2\\mathit{N}}}} \\right\\rbrack$, where *N* is the size of the texture in the direction of clamping. `GL_REPEAT` causes the integer part of the *s* coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. `GL_MIRRORED_REPEAT` causes the *s* coordinate to be set to the fractional part of the texture coordinate if the integer part of *s* is even; if the integer part of *s* is odd, then the *s* texture coordinate is set to 1 − *f**r**a**c*(*s*), where *f**r**a**c*(*s*) represents the fractional part of *s*. `GL_MIRROR_CLAMP_TO_EDGE` causes the *s* coordinate to be repeated as for `GL_MIRRORED_REPEAT` for one repetition of the texture, at which point the coordinate to be clamped as in `GL_CLAMP_TO_EDGE`. Initially, `GL_TEXTURE_WRAP_S` is set to `GL_REPEAT`.\n\n`GL_TEXTURE_WRAP_T`\n\nSets the wrap parameter for texture coordinate *t* to either `GL_CLAMP_TO_EDGE`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. See the discussion under `GL_TEXTURE_WRAP_S`. Initially, `GL_TEXTURE_WRAP_T` is set to `GL_REPEAT`.\n\n`GL_TEXTURE_WRAP_R`\n\nSets the wrap parameter for texture coordinate *r* to either `GL_CLAMP_TO_EDGE`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. See the discussion under `GL_TEXTURE_WRAP_S`. Initially, `GL_TEXTURE_WRAP_R` is set to `GL_REPEAT`.\n\n`GL_TEXTURE_BORDER_COLOR`\n\nThe data in *`params`* specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of `GL_TEXTURE_BORDER_COLOR` are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of `GL_TEXTURE_BORDER_COLOR` is interpreted as a depth value. The initial value is (0.0, 0.0, 0.0, 0.0).\n\n`GL_TEXTURE_COMPARE_MODE`\n\nSpecifies the texture comparison mode for currently bound textures. That is, a texture whose internal format is `GL_DEPTH_COMPONENT_*`; see [glTexImage2D](glteximage2d.xhtml)) Permissible values are:\n\n`GL_COMPARE_REF_TO_TEXTURE`\n\nSpecifies that the interpolated and clamped *r* texture coordinate should be compared to the value in the currently bound texture. See the discussion of `GL_TEXTURE_COMPARE_FUNC` for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.\n\n`GL_NONE`\n\nSpecifies that the red channel should be assigned the appropriate value from the currently bound texture.\n\n`GL_TEXTURE_COMPARE_FUNC`\n\nSpecifies the comparison operator used when `GL_TEXTURE_COMPARE_MODE` is set to `GL_COMPARE_REF_TO_TEXTURE`. Permissible values are:\n\n|  **Texture Comparison Function**  |  **Computed result**                          |\n|:----------------------------------|:----------------------------------------------|\n| `GL_LEQUAL`                       | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r}\\<=\\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\> \\mathit{D}\\_{\\mathit{t}}}       \n                                     \\end{matrix}} \\right.$                         |\n| `GL_GEQUAL`                       | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r}\\>=\\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\< \\mathit{D}\\_{\\mathit{t}}}       \n                                     \\end{matrix}} \\right.$                         |\n| `GL_LESS`                         | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\< \\mathit{D}\\_{\\mathit{t}}} \\\\    \n                                     {\\mathit{r}\\>=\\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_GREATER`                      | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\> \\mathit{D}\\_{\\mathit{t}}} \\\\    \n                                     {\\mathit{r}\\<=\\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_EQUAL`                        | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} = \\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\neq \\mathit{D}\\_{\\mathit{t}}}     \n                                     \\end{matrix}} \\right.$                         |\n| `GL_NOTEQUAL`                     | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\neq \\mathit{D}\\_{\\mathit{t}}} \\\\  \n                                     {\\mathit{r} = \\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_ALWAYS`                       | *r**e**s**u**l**t* = 1.0                      |\n| `GL_NEVER`                        | *r**e**s**u**l**t* = 0.0                      |\n\nwhere *r* is the current interpolated texture coordinate, and *D*_(*t*) is the texture value sampled from the currently bound texture. *r**e**s**u**l**t* is assigned to *R*_(*t*).\n\n## Notes\n\n`glSamplerParameter` is available only if the GL version is 3.3 or higher.\n\nIf a sampler object is bound to a texture unit and that unit is used to sample from a texture, the parameters in the sampler are used to sample from the texture, rather than the equivalent parameters in the texture object bound to that unit. This introduces the possibility of sampling from the same texture object with different sets of sampler state, which may lead to a condition where a texture is *incomplete* with respect to one sampler object and not with respect to another. Thus, completeness can be considered a function of a sampler object and a texture object bound to a single texture unit, rather than a property of the texture object itself.\n\n`GL_MIRROR_CLAMP_TO_EDGE` is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`sampler`* is not the name of a sampler object previously returned from a call to [glGenSamplers](glgensamplers.xhtml).\n\n`GL_INVALID_ENUM` is generated if *`params`* should have a defined constant value (based on the value of *`pname`*) and does not.\n\n## Associated Gets\n\n[ glGetSamplerParameter ](glgetsamplerparameter.xhtml)\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glSamplerParameterIiv`       |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glSamplerParameterIuiv`      |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glSamplerParameterf`         |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glSamplerParameterfv`        |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glSamplerParameteri`         |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glSamplerParameteriv`        |          \\-          |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGenSamplers](glgensamplers.xhtml), [glBindSampler](glbindsampler.xhtml), [glDeleteSamplers](gldeletesamplers.xhtml), [glIsSampler](glissampler.xhtml), [glBindTexture](glbindtexture.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glSamplerParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glSamplerParameter.xhtml)"
- name: glSamplerParameteriv
  id: glsamplerparameter.xhtml#glSamplerParameteriv
  summary: null
  belongs_to: glSamplerParameter
  description: '`void `**`glSamplerParameteriv`**`(` GLuint `sampler`, GLenum `pname`, const GLint \* `params``)`;'
- name: glScissor
  id: glscissor.xhtml
  summary: x, y Specify the lower left corner of the scissor box
  description: "## Name\n\nglScissor — define the scissor box\n\n## C Specification\n\n`void `**`glScissor`**`(` GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n*`x`*,   *`y`*  \nSpecify the lower left corner of the scissor box. Initially (0, 0).\n\n*`width`*,   *`height`*  \nSpecify the width and height of the scissor box. When a GL context is first attached to a window, *`width`* and *`height`* are set to the dimensions of that window.\n\n## Description\n\n`glScissor` defines a rectangle, called the scissor box, in window coordinates. The first two arguments, *`x`* and *`y`*, specify the lower left corner of the box. *`width`* and *`height`* specify the width and height of the box.\n\nTo enable and disable the scissor test, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_SCISSOR_TEST`. The test is initially disabled. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. `glScissor(0,0,1,1)` allows modification of only the lower left pixel in the window, and `glScissor(0,0,0,0)` doesn't allow modification of any pixels in the window.\n\nWhen the scissor test is disabled, it is as though the scissor box includes the entire window.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if either *`width`* or *`height`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_SCISSOR_BOX`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_SCISSOR_TEST`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glScissor`                 |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glEnable](glenable.xhtml), [glViewport](glviewport.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glScissor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glScissor.xhtml)"
- name: glScissorArray
  id: glscissorarray.xhtml
  summary: first Specifies the index of the first viewport whose scissor box to modify
  description: "## Name\n\nglScissorArray — define the scissor box for multiple viewports\n\n## C Specification\n\n`void `**`glScissorArrayv`**`(` GLuint `first`, GLsizei `count`, const GLint \\*`v``)`;\n\n## Parameters\n\n *`first`*  \nSpecifies the index of the first viewport whose scissor box to modify.\n\n *`count`*  \nSpecifies the number of scissor boxes to modify.\n\n *`v`*  \nSpecifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.\n\n## Description\n\n`glScissorArrayv` defines rectangles, called scissor boxes, in window coordinates for each viewport. *`first`* specifies the index of the first scissor box to modify and *`count`* specifies the number of scissor boxes to modify. *`first`* must be less than the value of `GL_MAX_VIEWPORTS`, and *`first`* + *`count`* must be less than or equal to the value of `GL_MAX_VIEWPORTS`. *`v`* specifies the address of an array containing integers specifying the lower left corner of the scissor boxes, and the width and height of the scissor boxes, in that order.\n\nTo enable and disable the scissor test, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_SCISSOR_TEST`. The test is initially disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. `glScissor(0,0,1,1)` allows modification of only the lower left pixel in the window, and `glScissor(0,0,0,0)` doesn't allow modification of any pixels in the window.\n\nWhen the scissor test is disabled, it is as though the scissor box includes the entire window.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`first`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if *`first`* + *`count`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if any width or height specified in the array *`v`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_SCISSOR_BOX`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_SCISSOR_TEST`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glScissorArrayv`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glEnable](glenable.xhtml), [glViewport](glviewport.xhtml), [glViewportIndexed](glviewportindexed.xhtml), [glViewportArray](glviewportarray.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glScissorArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glScissorArray.xhtml)"
- name: glScissorArrayv
  id: glscissorarray.xhtml#glScissorArrayv
  summary: Specifies the index of the first viewport whose scissor box to modify
  belongs_to: glScissorArray
  description: "`void `**`glScissorArrayv`**`(` GLuint `first`, GLsizei `count`, const GLint \\*`v``)`;\n\n## Parameters\n\n*`first`*\n\nSpecifies the index of the first viewport whose scissor box to modify.\n\n*`count`*\n\nSpecifies the number of scissor boxes to modify.\n\n*`v`*\n\nSpecifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.\n\n## Description\n\n`glScissorArrayv` defines rectangles, called scissor boxes, in window coordinates for each viewport. *`first`* specifies the index of the first scissor box to modify and *`count`* specifies the number of scissor boxes to modify. *`first`* must be less than the value of `GL_MAX_VIEWPORTS`, and *`first`* + *`count`* must be less than or equal to the value of `GL_MAX_VIEWPORTS`. *`v`* specifies the address of an array containing integers specifying the lower left corner of the scissor boxes, and the width and height of the scissor boxes, in that order.\n\nTo enable and disable the scissor test, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_SCISSOR_TEST`. The test is initially disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. `glScissor(0,0,1,1)` allows modification of only the lower left pixel in the window, and `glScissor(0,0,0,0)` doesn't allow modification of any pixels in the window.\n\nWhen the scissor test is disabled, it is as though the scissor box includes the entire window.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`first`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if *`first`* + *`count`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if any width or height specified in the array *`v`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_SCISSOR_BOX`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_SCISSOR_TEST`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glScissorArrayv`             |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glEnable](glenable.xhtml), [glViewport](glviewport.xhtml), [glViewportIndexed](glviewportindexed.xhtml), [glViewportArray](glviewportarray.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glScissorArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glScissorArray.xhtml)"
- name: glScissorIndexed
  id: glscissorindexed.xhtml
  summary: index Specifies the index of the viewport whose scissor box to modify
  description: "## Name\n\nglScissorIndexed — define the scissor box for a specific viewport\n\n## C Specification\n\n`void `**`glScissorIndexed`**`(` GLuint `index`, GLint `left`, GLint `bottom`, GLsizei `width`, GLsizei `height``)`;\n\n`void `**`glScissorIndexedv`**`(` GLuint `index`, const GLint \\*`v``)`;\n\n## Parameters\n\n *`index`*  \nSpecifies the index of the viewport whose scissor box to modify.\n\n*`left`*,   *`bottom`*  \nSpecify the coordinate of the bottom left corner of the scissor box, in pixels.\n\n*`width`*,   *`height`*  \nSpecify ths dimensions of the scissor box, in pixels.\n\n *`v`*  \nFor `glScissorIndexedv`, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.\n\n## Description\n\n`glScissorIndexed` defines the scissor box for a specified viewport. *`index`* specifies the index of scissor box to modify. *`index`* must be less than the value of `GL_MAX_VIEWPORTS`. For `glScissorIndexed`, *`left`*, *`bottom`*, *`width`* and *`height`* specify the left, bottom, width and height of the scissor box, in pixels, respectively. For `glScissorIndexedv`, *`v`* specifies the address of an array containing integers specifying the lower left corner of the scissor box, and the width and height of the scissor box, in that order.\n\nTo enable and disable the scissor test, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_SCISSOR_TEST`. The test is initially disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. `glScissor(0,0,1,1)` allows modification of only the lower left pixel in the window, and `glScissor(0,0,0,0)` doesn't allow modification of any pixels in the window.\n\nWhen the scissor test is disabled, it is as though the scissor box includes the entire window.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if any width or height specified in the array *`v`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_SCISSOR_BOX`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_SCISSOR_TEST`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glScissorIndexed`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glScissorIndexedv`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glEnable](glenable.xhtml), [glScissor](glscissor.xhtml), [glScissorArray](glscissorarray.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glScissorIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glScissorIndexed.xhtml)"
- name: glScissorIndexedv
  id: glscissorindexed.xhtml#glScissorIndexedv
  summary: Specifies the index of the viewport whose scissor box to modify
  belongs_to: glScissorIndexed
  description: "`void `**`glScissorIndexedv`**`(` GLuint `index`, const GLint \\*`v``)`;\n\n## Parameters\n\n*`index`*\n\nSpecifies the index of the viewport whose scissor box to modify.\n\n*`left`*, *`bottom`*\n\nSpecify the coordinate of the bottom left corner of the scissor box, in pixels.\n\n*`width`*, *`height`*\n\nSpecify ths dimensions of the scissor box, in pixels.\n\n*`v`*\n\nFor `glScissorIndexedv`, specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.\n\n## Description\n\n`glScissorIndexed` defines the scissor box for a specified viewport. *`index`* specifies the index of scissor box to modify. *`index`* must be less than the value of `GL_MAX_VIEWPORTS`. For `glScissorIndexed`, *`left`*, *`bottom`*, *`width`* and *`height`* specify the left, bottom, width and height of the scissor box, in pixels, respectively. For `glScissorIndexedv`, *`v`* specifies the address of an array containing integers specifying the lower left corner of the scissor box, and the width and height of the scissor box, in that order.\n\nTo enable and disable the scissor test, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_SCISSOR_TEST`. The test is initially disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. `glScissor(0,0,1,1)` allows modification of only the lower left pixel in the window, and `glScissor(0,0,0,0)` doesn't allow modification of any pixels in the window.\n\nWhen the scissor test is disabled, it is as though the scissor box includes the entire window.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if any width or height specified in the array *`v`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_SCISSOR_BOX`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_SCISSOR_TEST`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glScissorIndexed`            |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glScissorIndexedv`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glEnable](glenable.xhtml), [glScissor](glscissor.xhtml), [glScissorArray](glscissorarray.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glScissorIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glScissorIndexed.xhtml)"
- name: glShaderBinary
  id: glshaderbinary.xhtml
  summary: count Specifies the number of shader object handles contained in shaders
  description: "## Name\n\nglShaderBinary — load pre-compiled shader binaries\n\n## C Specification\n\n`void `**`glShaderBinary`**`(` GLsizei `count`, const GLuint \\*`shaders`, GLenum `binaryFormat`, const void \\*`binary`, GLsizei `length``)`;\n\n## Parameters\n\n *`count`*  \nSpecifies the number of shader object handles contained in *`shaders`*.\n\n *`shaders`*  \nSpecifies the address of an array of shader handles into which to load pre-compiled shader binaries.\n\n *`binaryFormat`*  \nSpecifies the format of the shader binaries contained in *`binary`*.\n\n *`binary`*  \nSpecifies the address of an array of bytes containing pre-compiled binary shader code.\n\n *`length`*  \nSpecifies the length of the array whose address is given in *`binary`*.\n\n## Description\n\n`glShaderBinary` loads pre-compiled shader binary code into the *`count`* shader objects whose handles are given in *`shaders`*. *`binary`* points to *`length`* bytes of binary shader code stored in client memory. *`binaryFormat`* specifies the format of the pre-compiled code.\n\nThe binary image contained in *`binary`* will be decoded according to the extension specification defining the specified *`binaryFormat`* token. OpenGL does not define any specific binary formats, but it does provide a mechanism to obtain token vaues for such formats provided by such extensions.\n\nDepending on the types of the shader objects in *`shaders`*, `glShaderBinary` will individually load binary vertex or fragment shaders, or load an executable binary that contains an optimized pair of vertex and fragment shaders stored in the same binary.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if more than one of the handles in *`shaders`* refers to the same shader object.\n\n`GL_INVALID_ENUM` is generated if *`binaryFormat`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if the data pointed to by *`binary`* does not match the format specified by *`binaryFormat`*.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with parameter `GL_NUM_SHADER_BINARY_FORMATS`.\n\n[glGet](glget.xhtml) with parameter `GL_SHADER_BINARY_FORMATS`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glShaderBinary`            |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetProgramBinary](glgetprogrambinary.xhtml), [glProgramBinary](glprogrambinary.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glShaderBinary.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glShaderBinary.xhtml)"
- name: glShaderSource
  id: glshadersource.xhtml
  summary: shader Specifies the handle of the shader object whose source code is to be replaced
  description: "## Name\n\nglShaderSource — Replaces the source code in a shader object\n\n## C Specification\n\n`void `**`glShaderSource`**`(` GLuint `shader`, GLsizei `count`, const GLchar \\*\\*`string`, const GLint \\*`length``)`;\n\n## Parameters\n\n *`shader`*  \nSpecifies the handle of the shader object whose source code is to be replaced.\n\n *`count`*  \nSpecifies the number of elements in the *`string`* and *`length`* arrays.\n\n *`string`*  \nSpecifies an array of pointers to strings containing the source code to be loaded into the shader.\n\n *`length`*  \nSpecifies an array of string lengths.\n\n## Description\n\n`glShaderSource` sets the source code in *`shader`* to the source code in the array of strings specified by *`string`*. Any source code previously stored in the shader object is completely replaced. The number of strings in the array is specified by *`count`*. If *`length`* is `NULL`, each string is assumed to be null terminated. If *`length`* is a value other than `NULL`, it points to an array containing a string length for each of the corresponding elements of *`string`*. Each element in the *`length`* array may contain the length of the corresponding string (the null character is not counted as part of the string length) or a value less than 0 to indicate that the string is null terminated. The source code strings are not scanned or parsed at this time; they are simply copied into the specified shader object.\n\n## Notes\n\nOpenGL copies the shader source code strings when `glShaderSource` is called, so an application may free its copy of the source code strings immediately after the function returns.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`shader`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`shader`* is not a shader object.\n\n`GL_INVALID_VALUE` is generated if *`count`* is less than 0.\n\n## Associated Gets\n\n[glGetShader](glgetshader.xhtml) with arguments *`shader`* and `GL_SHADER_SOURCE_LENGTH`\n\n[glGetShaderSource](glgetshadersource.xhtml) with argument *`shader`*\n\n[ glIsShader ](glisshader.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glShaderSource`            |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glCompileShader](glcompileshader.xhtml), [glCreateShader](glcreateshader.xhtml), [glDeleteShader](gldeleteshader.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glShaderSource.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glShaderSource.xhtml)"
- name: glShaderStorageBlockBinding
  id: glshaderstorageblockbinding.xhtml
  summary: program The name of the program containing the block whose binding to change
  description: "## Name\n\nglShaderStorageBlockBinding — change an active shader storage block binding\n\n## C Specification\n\n`void `**`glShaderStorageBlockBinding`**`(` GLuint `program`, GLuint `storageBlockIndex`, GLuint `storageBlockBinding``)`;\n\n## Parameters\n\n *`program`*  \nThe name of the program containing the block whose binding to change.\n\n *`storageBlockIndex`*  \nThe index storage block within the program.\n\n *`storageBlockBinding`*  \nThe index storage block binding to associate with the specified storage block.\n\n## Description\n\n`glShaderStorageBlockBinding`, changes the active shader storage block with an assigned index of *`storageBlockIndex`* in program object *`program`*. *`storageBlockIndex`* must be an active shader storage block index in *`program`*. *`storageBlockBinding`* must be less than the value of `GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`. If successful, `glShaderStorageBlockBinding` specifies that *`program`* will use the data store of the buffer object bound to the binding point *`storageBlockBinding`* to read and write the values of the buffer variables in the shader storage block identified by *`storageBlockIndex`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of either a program or shader object.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is the name of a shader object.\n\n`GL_INVALID_VALUE` is generated if *`storageBlockIndex`* is not an active shader storage block index in *`program`*, or if *`storageBlockBinding`* is greater than or equal to the value of `MAX_SHADER_STORAGE_BUFFER_BINDINGS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with arguments `GL_SHADER_STORAGE_BUFFER_BINDING`, `GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`, `GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS`, `GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS`, `GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS`, `GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS`, `GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS`, `GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS` or `GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS`, `GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`, or `GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES`.\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glShaderStorageBlockBinding` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glShaderStorageBlockBinding.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glShaderStorageBlockBinding.xhtml)"
- name: glStencilFunc
  id: glstencilfunc.xhtml
  summary: func Specifies the test function
  description: "## Name\n\nglStencilFunc — set front and back function and reference value for stencil testing\n\n## C Specification\n\n`void `**`glStencilFunc`**`(` GLenum `func`, GLint `ref`, GLuint `mask``)`;\n\n## Parameters\n\n *`func`*  \nSpecifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`.\n\n *`ref`*  \nSpecifies the reference value for the stencil test. *`ref`* is clamped to the range \\[0, 2^(*n*) − 1\\], where *n* is the number of bitplanes in the stencil buffer. The initial value is 0.\n\n *`mask`*  \nSpecifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.\n\n## Description\n\nStenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first drawn into using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.\n\nThe stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_STENCIL_TEST`. To specify actions based on the outcome of the stencil test, call [glStencilOp](glstencilop.xhtml) or [glStencilOpSeparate](glstencilopseparate.xhtml).\n\nThere can be two separate sets of *`func`*, *`ref`*, and *`mask`* parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. [glStencilFunc](glstencilfunc.xhtml) sets both front and back stencil state to the same values. Use [glStencilFuncSeparate](glstencilfuncseparate.xhtml) to set front and back stencil state to different values.\n\n*`func`* is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. *`ref`* is an integer reference value that is used in the stencil comparison. It is clamped to the range \\[0, 2^(*n*) − 1\\], where *n* is the number of bitplanes in the stencil buffer. *`mask`* is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.\n\nIf *stencil* represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by *`func`*. Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see [glStencilOp](glstencilop.xhtml)). All tests treat *stencil* values as unsigned integers in the range \\[0, 2^(*n*) − 1\\], where *n* is the number of bitplanes in the stencil buffer.\n\nThe following values are accepted by *`func`*:\n\n `GL_NEVER`  \nAlways fails.\n\n `GL_LESS`  \nPasses if ( *`ref`* & *`mask`* ) \\< ( *stencil* & *`mask`* ).\n\n `GL_LEQUAL`  \nPasses if ( *`ref`* & *`mask`* ) \\<= ( *stencil* & *`mask`* ).\n\n `GL_GREATER`  \nPasses if ( *`ref`* & *`mask`* ) \\> ( *stencil* & *`mask`* ).\n\n `GL_GEQUAL`  \nPasses if ( *`ref`* & *`mask`* ) \\>= ( *stencil* & *`mask`* ).\n\n `GL_EQUAL`  \nPasses if ( *`ref`* & *`mask`* ) = ( *stencil* & *`mask`* ).\n\n `GL_NOTEQUAL`  \nPasses if ( *`ref`* & *`mask`* ) != ( *stencil* & *`mask`* ).\n\n `GL_ALWAYS`  \nAlways passes.\n\n## Notes\n\nInitially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.\n\n[glStencilFunc](glstencilfunc.xhtml) is the same as calling [glStencilFuncSeparate](glstencilfuncseparate.xhtml) with *`face`* set to `GL_FRONT_AND_BACK`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`func`* is not one of the eight accepted values.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_STENCIL_FUNC`, `GL_STENCIL_VALUE_MASK`, `GL_STENCIL_REF`, `GL_STENCIL_BACK_FUNC`, `GL_STENCIL_BACK_VALUE_MASK`, `GL_STENCIL_BACK_REF`, or `GL_STENCIL_BITS`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_STENCIL_TEST`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glStencilFunc`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBlendFunc](glblendfunc.xhtml), [glDepthFunc](gldepthfunc.xhtml), [glEnable](glenable.xhtml), [glLogicOp](gllogicop.xhtml), [glStencilFuncSeparate](glstencilfuncseparate.xhtml), [glStencilMask](glstencilmask.xhtml), [glStencilMaskSeparate](glstencilmaskseparate.xhtml), [glStencilOp](glstencilop.xhtml), [glStencilOpSeparate](glstencilopseparate.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilFunc.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilFunc.xhtml)"
- name: glStencilFuncSeparate
  id: glstencilfuncseparate.xhtml
  summary: face Specifies whether front and/or back stencil state is updated
  description: "## Name\n\nglStencilFuncSeparate — set front and/or back function and reference value for stencil testing\n\n## C Specification\n\n`void `**`glStencilFuncSeparate`**`(` GLenum `face`, GLenum `func`, GLint `ref`, GLuint `mask``)`;\n\n## Parameters\n\n *`face`*  \nSpecifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`.\n\n *`func`*  \nSpecifies the test function. Eight symbolic constants are valid: `GL_NEVER`, `GL_LESS`, `GL_LEQUAL`, `GL_GREATER`, `GL_GEQUAL`, `GL_EQUAL`, `GL_NOTEQUAL`, and `GL_ALWAYS`. The initial value is `GL_ALWAYS`.\n\n *`ref`*  \nSpecifies the reference value for the stencil test. *`ref`* is clamped to the range \\[0, 2^(*n*) − 1\\], where *n* is the number of bitplanes in the stencil buffer. The initial value is 0.\n\n *`mask`*  \nSpecifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.\n\n## Description\n\nStenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.\n\nThe stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_STENCIL_TEST`. To specify actions based on the outcome of the stencil test, call [glStencilOp](glstencilop.xhtml) or [glStencilOpSeparate](glstencilopseparate.xhtml).\n\nThere can be two separate sets of *`func`*, *`ref`*, and *`mask`* parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. [glStencilFunc](glstencilfunc.xhtml) sets both front and back stencil state to the same values, as if [glStencilFuncSeparate](glstencilfuncseparate.xhtml) were called with *`face`* set to `GL_FRONT_AND_BACK`.\n\n*`func`* is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. *`ref`* is an integer reference value that is used in the stencil comparison. It is clamped to the range \\[0, 2^(*n*) − 1\\], where *n* is the number of bitplanes in the stencil buffer. *`mask`* is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.\n\nIf *stencil* represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by *`func`*. Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see [glStencilOp](glstencilop.xhtml)). All tests treat *stencil* values as unsigned integers in the range \\[0, 2^(*n*) − 1\\], where *n* is the number of bitplanes in the stencil buffer.\n\nThe following values are accepted by *`func`*:\n\n `GL_NEVER`  \nAlways fails.\n\n `GL_LESS`  \nPasses if ( *`ref`* & *`mask`* ) \\< ( *stencil* & *`mask`* ).\n\n `GL_LEQUAL`  \nPasses if ( *`ref`* & *`mask`* ) \\<= ( *stencil* & *`mask`* ).\n\n `GL_GREATER`  \nPasses if ( *`ref`* & *`mask`* ) \\> ( *stencil* & *`mask`* ).\n\n `GL_GEQUAL`  \nPasses if ( *`ref`* & *`mask`* ) \\>= ( *stencil* & *`mask`* ).\n\n `GL_EQUAL`  \nPasses if ( *`ref`* & *`mask`* ) = ( *stencil* & *`mask`* ).\n\n `GL_NOTEQUAL`  \nPasses if ( *`ref`* & *`mask`* ) != ( *stencil* & *`mask`* ).\n\n `GL_ALWAYS`  \nAlways passes.\n\n## Notes\n\nInitially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`func`* is not one of the eight accepted values.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_STENCIL_FUNC`, `GL_STENCIL_VALUE_MASK`, `GL_STENCIL_REF`, `GL_STENCIL_BACK_FUNC`, `GL_STENCIL_BACK_VALUE_MASK`, `GL_STENCIL_BACK_REF`, or `GL_STENCIL_BITS`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_STENCIL_TEST`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glStencilFuncSeparate`     |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBlendFunc](glblendfunc.xhtml), [glDepthFunc](gldepthfunc.xhtml), [glEnable](glenable.xhtml), [glLogicOp](gllogicop.xhtml), [glStencilFunc](glstencilfunc.xhtml), [glStencilMask](glstencilmask.xhtml), [glStencilMaskSeparate](glstencilmaskseparate.xhtml), [glStencilOp](glstencilop.xhtml), [glStencilOpSeparate](glstencilopseparate.xhtml)\n\n## Copyright\n\nCopyright © 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilFuncSeparate.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilFuncSeparate.xhtml)"
- name: glStencilMask
  id: glstencilmask.xhtml
  summary: mask Specifies a bit mask to enable and disable writing of individual bits in the stencil planes
  description: "## Name\n\nglStencilMask — control the front and back writing of individual bits in the stencil planes\n\n## C Specification\n\n`void `**`glStencilMask`**`(` GLuint `mask``)`;\n\n## Parameters\n\n *`mask`*  \nSpecifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.\n\n## Description\n\n`glStencilMask` controls the writing of individual bits in the stencil planes. The least significant *n* bits of *`mask`*, where *n* is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing.\n\nThere can be two separate *`mask`* writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. [glStencilMask](glstencilmask.xhtml) sets both front and back stencil writemasks to the same values. Use [glStencilMaskSeparate](glstencilmaskseparate.xhtml) to set front and back stencil writemasks to different values.\n\n## Notes\n\n[glStencilMask](glstencilmask.xhtml) is the same as calling [glStencilMaskSeparate](glstencilmaskseparate.xhtml) with *`face`* set to `GL_FRONT_AND_BACK`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_STENCIL_WRITEMASK`, `GL_STENCIL_BACK_WRITEMASK`, or `GL_STENCIL_BITS`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glStencilMask`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glColorMask](glcolormask.xhtml), [glDepthMask](gldepthmask.xhtml), [glStencilFunc](glstencilfunc.xhtml), [glStencilFuncSeparate](glstencilfuncseparate.xhtml), [glStencilMaskSeparate](glstencilmaskseparate.xhtml), [glStencilOp](glstencilop.xhtml), [glStencilOpSeparate](glstencilopseparate.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilMask.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilMask.xhtml)"
- name: glStencilMaskSeparate
  id: glstencilmaskseparate.xhtml
  summary: face Specifies whether the front and/or back stencil writemask is updated
  description: "## Name\n\nglStencilMaskSeparate — control the front and/or back writing of individual bits in the stencil planes\n\n## C Specification\n\n`void `**`glStencilMaskSeparate`**`(` GLenum `face`, GLuint `mask``)`;\n\n## Parameters\n\n *`face`*  \nSpecifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`.\n\n *`mask`*  \nSpecifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.\n\n## Description\n\n`glStencilMaskSeparate` controls the writing of individual bits in the stencil planes. The least significant *n* bits of *`mask`*, where *n* is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing.\n\nThere can be two separate *`mask`* writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. [glStencilMask](glstencilmask.xhtml) sets both front and back stencil writemasks to the same values, as if [glStencilMaskSeparate](glstencilmaskseparate.xhtml) were called with *`face`* set to `GL_FRONT_AND_BACK`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`face`* is not one of the accepted tokens.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_STENCIL_WRITEMASK`, `GL_STENCIL_BACK_WRITEMASK`, or `GL_STENCIL_BITS`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glStencilMaskSeparate`     |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glColorMask](glcolormask.xhtml), [glDepthMask](gldepthmask.xhtml), [glStencilFunc](glstencilfunc.xhtml), [glStencilFuncSeparate](glstencilfuncseparate.xhtml), [glStencilMask](glstencilmask.xhtml), [glStencilOp](glstencilop.xhtml), [glStencilOpSeparate](glstencilopseparate.xhtml)\n\n## Copyright\n\nCopyright © 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilMaskSeparate.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilMaskSeparate.xhtml)"
- name: glStencilOp
  id: glstencilop.xhtml
  summary: sfail Specifies the action to take when the stencil test fails
  description: "## Name\n\nglStencilOp — set front and back stencil test actions\n\n## C Specification\n\n`void `**`glStencilOp`**`(` GLenum `sfail`, GLenum `dpfail`, GLenum `dppass``)`;\n\n## Parameters\n\n *`sfail`*  \nSpecifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`.\n\n *`dpfail`*  \nSpecifies the stencil action when the stencil test passes, but the depth test fails. *`dpfail`* accepts the same symbolic constants as *`sfail`*. The initial value is `GL_KEEP`.\n\n *`dppass`*  \nSpecifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. *`dppass`* accepts the same symbolic constants as *`sfail`*. The initial value is `GL_KEEP`.\n\n## Description\n\nStenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.\n\nThe stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_STENCIL_TEST`; to control it, call [glStencilFunc](glstencilfunc.xhtml) or [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\nThere can be two separate sets of *`sfail`*, *`dpfail`*, and *`dppass`* parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. [glStencilOp](glstencilop.xhtml) sets both front and back stencil state to the same values. Use [glStencilOpSeparate](glstencilopseparate.xhtml) to set front and back stencil state to different values.\n\n`glStencilOp` takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and *`sfail`* specifies what happens to the stencil buffer contents. The following eight actions are possible.\n\n `GL_KEEP`  \nKeeps the current value.\n\n `GL_ZERO`  \nSets the stencil buffer value to 0.\n\n `GL_REPLACE`  \nSets the stencil buffer value to *ref*, as specified by [glStencilFunc](glstencilfunc.xhtml).\n\n `GL_INCR`  \nIncrements the current stencil buffer value. Clamps to the maximum representable unsigned value.\n\n `GL_INCR_WRAP`  \nIncrements the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.\n\n `GL_DECR`  \nDecrements the current stencil buffer value. Clamps to 0.\n\n `GL_DECR_WRAP`  \nDecrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.\n\n `GL_INVERT`  \nBitwise inverts the current stencil buffer value.\n\nStencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2^(*n*) − 1, where *n* is the value returned by querying `GL_STENCIL_BITS`.\n\nThe other two arguments to `glStencilOp` specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed (*`dppass`*) or fail (*`dpfail`*) (see [glDepthFunc](gldepthfunc.xhtml)). The actions are specified using the same eight symbolic constants as *`sfail`*. Note that *`dpfail`* is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, *`sfail`* and *`dppass`* specify stencil action when the stencil test fails and passes, respectively.\n\n## Notes\n\nInitially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil tests always pass, regardless of any call to `glStencilOp`.\n\n[glStencilOp](glstencilop.xhtml) is the same as calling [glStencilOpSeparate](glstencilopseparate.xhtml) with *`face`* set to `GL_FRONT_AND_BACK`.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`sfail`*, *`dpfail`*, or *`dppass`* is any value other than the defined constant values.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_STENCIL_FAIL`, `GL_STENCIL_PASS_DEPTH_PASS`, `GL_STENCIL_PASS_DEPTH_FAIL`, `GL_STENCIL_BACK_FAIL`, `GL_STENCIL_BACK_PASS_DEPTH_PASS`, `GL_STENCIL_BACK_PASS_DEPTH_FAIL`, or `GL_STENCIL_BITS`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_STENCIL_TEST`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glStencilOp`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBlendFunc](glblendfunc.xhtml), [glDepthFunc](gldepthfunc.xhtml), [glEnable](glenable.xhtml), [glLogicOp](gllogicop.xhtml), [glStencilFunc](glstencilfunc.xhtml), [glStencilFuncSeparate](glstencilfuncseparate.xhtml), [glStencilMask](glstencilmask.xhtml), [glStencilMaskSeparate](glstencilmaskseparate.xhtml), [glStencilOpSeparate](glstencilopseparate.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilOp.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilOp.xhtml)"
- name: glStencilOpSeparate
  id: glstencilopseparate.xhtml
  summary: face Specifies whether front and/or back stencil state is updated
  description: "## Name\n\nglStencilOpSeparate — set front and/or back stencil test actions\n\n## C Specification\n\n`void `**`glStencilOpSeparate`**`(` GLenum `face`, GLenum `sfail`, GLenum `dpfail`, GLenum `dppass``)`;\n\n## Parameters\n\n *`face`*  \nSpecifies whether front and/or back stencil state is updated. Three symbolic constants are valid: `GL_FRONT`, `GL_BACK`, and `GL_FRONT_AND_BACK`.\n\n *`sfail`*  \nSpecifies the action to take when the stencil test fails. Eight symbolic constants are accepted: `GL_KEEP`, `GL_ZERO`, `GL_REPLACE`, `GL_INCR`, `GL_INCR_WRAP`, `GL_DECR`, `GL_DECR_WRAP`, and `GL_INVERT`. The initial value is `GL_KEEP`.\n\n *`dpfail`*  \nSpecifies the stencil action when the stencil test passes, but the depth test fails. *`dpfail`* accepts the same symbolic constants as *`sfail`*. The initial value is `GL_KEEP`.\n\n *`dppass`*  \nSpecifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. *`dppass`* accepts the same symbolic constants as *`sfail`*. The initial value is `GL_KEEP`.\n\n## Description\n\nStenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.\n\nThe stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_STENCIL_TEST`; to control it, call [glStencilFunc](glstencilfunc.xhtml) or [glStencilFuncSeparate](glstencilfuncseparate.xhtml).\n\nThere can be two separate sets of *`sfail`*, *`dpfail`*, and *`dppass`* parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. [glStencilOp](glstencilop.xhtml) sets both front and back stencil state to the same values, as if [glStencilOpSeparate](glstencilopseparate.xhtml) were called with *`face`* set to `GL_FRONT_AND_BACK`.\n\n`glStencilOpSeparate` takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and *`sfail`* specifies what happens to the stencil buffer contents. The following eight actions are possible.\n\n `GL_KEEP`  \nKeeps the current value.\n\n `GL_ZERO`  \nSets the stencil buffer value to 0.\n\n `GL_REPLACE`  \nSets the stencil buffer value to *ref*, as specified by [glStencilFunc](glstencilfunc.xhtml).\n\n `GL_INCR`  \nIncrements the current stencil buffer value. Clamps to the maximum representable unsigned value.\n\n `GL_INCR_WRAP`  \nIncrements the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.\n\n `GL_DECR`  \nDecrements the current stencil buffer value. Clamps to 0.\n\n `GL_DECR_WRAP`  \nDecrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.\n\n `GL_INVERT`  \nBitwise inverts the current stencil buffer value.\n\nStencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2^(*n*) − 1, where *n* is the value returned by querying `GL_STENCIL_BITS`.\n\nThe other two arguments to `glStencilOpSeparate` specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed (*`dppass`*) or fail (*`dpfail`*) (see [glDepthFunc](gldepthfunc.xhtml)). The actions are specified using the same eight symbolic constants as *`sfail`*. Note that *`dpfail`* is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, *`sfail`* and *`dppass`* specify stencil action when the stencil test fails and passes, respectively.\n\n## Notes\n\nInitially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`face`* is any value other than `GL_FRONT`, `GL_BACK`, or `GL_FRONT_AND_BACK`.\n\n`GL_INVALID_ENUM` is generated if *`sfail`*, *`dpfail`*, or *`dppass`* is any value other than the eight defined constant values.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_STENCIL_FAIL`, `GL_STENCIL_PASS_DEPTH_PASS`, `GL_STENCIL_PASS_DEPTH_FAIL`, `GL_STENCIL_BACK_FAIL`, `GL_STENCIL_BACK_PASS_DEPTH_PASS`, `GL_STENCIL_BACK_PASS_DEPTH_FAIL`, or `GL_STENCIL_BITS`\n\n[glIsEnabled](glisenabled.xhtml) with argument `GL_STENCIL_TEST`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glStencilOpSeparate`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBlendFunc](glblendfunc.xhtml), [glDepthFunc](gldepthfunc.xhtml), [glEnable](glenable.xhtml), [glLogicOp](gllogicop.xhtml), [glStencilFunc](glstencilfunc.xhtml), [glStencilFuncSeparate](glstencilfuncseparate.xhtml), [glStencilMask](glstencilmask.xhtml), [glStencilMaskSeparate](glstencilmaskseparate.xhtml), [glStencilOp](glstencilop.xhtml)\n\n## Copyright\n\nCopyright © 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilOpSeparate.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glStencilOpSeparate.xhtml)"
- name: glTexBuffer
  id: gltexbuffer.xhtml
  summary: target Specifies the target to which the texture is bound for glTexBuffer
  description: "## Name\n\nglTexBuffer, glTextureBuffer — attach a buffer object's data store to a buffer texture object\n\n## C Specification\n\n`void `**`glTexBuffer`**`(` GLenum `target`, GLenum `internalformat`, GLuint `buffer``)`;\n\n`void `**`glTextureBuffer`**`(` GLuint `texture`, GLenum `internalformat`, GLuint `buffer``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glTexBuffer`. Must be `GL_TEXTURE_BUFFER`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureBuffer`.\n\n *`internalformat`*  \nSpecifies the internal format of the data in the store belonging to *`buffer`*.\n\n *`buffer`*  \nSpecifies the name of the buffer object whose storage to attach to the active buffer texture.\n\n## Description\n\n`glTexBuffer` and `glTextureBuffer` attaches the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found in the buffer object. The texture object must be a buffer texture.\n\nIf *`buffer`* is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If *`buffer`* is non-zero, it must be the name of an existing buffer object.\n\n*`internalformat`* specifies the storage format, and must be one of the following sized internal formats:\n\n|                             |                 |                  |            |  **Component**  |     |     |     |\n|:----------------------------|:----------------|:-----------------|:-----------|:---------------:|:---:|:---:|:---:|\n|  **Sized Internal Format**  |  **Base Type**  |  **Components**  |  **Norm**  |        0        |  1  |  2  |  3  |\n| `GL_R8`                     | ubyte           | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16`                    | ushort          | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16F`                   | half            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32F`                   | float           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8I`                    | byte            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16I`                   | short           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32I`                   | int             | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8UI`                   | ubyte           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16UI`                  | ushort          | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32UI`                  | uint            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_RG8`                    | ubyte           | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16`                   | ushort          | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16F`                  | half            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32F`                  | float           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8I`                   | byte            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16I`                  | short           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32I`                  | int             | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8UI`                  | ubyte           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16UI`                 | ushort          | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32UI`                 | uint            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RGB32F`                 | float           | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32I`                 | int             | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32UI`                | uint            | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGBA8`                  | uint            | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16`                 | short           | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16F`                | half            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32F`                | float           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8I`                 | byte            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16I`                | short           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32I`                | int             | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8UI`                | ubyte           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16UI`               | ushort          | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32UI`               | uint            | 4                | NO         |        R        |  G  |  B  |  A  |\n\nWhen a buffer object is attached to a buffer texture, the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \\left\\lfloor { size \\over { components \\times sizeof(base\\\\type) } } \\right\\rfloor $$ where $size$ is the size of the buffer object in basic machine units (the value of `GL_BUFFER_SIZE` for *`buffer`*), and $components$ and $base\\\\type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit `GL_MAX_TEXTURE_BUFFER_SIZE`. When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glTexBuffer` if *`target`* is not `GL_TEXTURE_BUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glTextureBuffer` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated by `glTextureBuffer` if the effective target of *`texture`* is not `GL_TEXTURE_BUFFER`.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the sized internal formats described above.\n\n`GL_INVALID_OPERATION` is generated if *`buffer`* is not zero and is not the name of an existing buffer object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_TEXTURE_BUFFER_SIZE`\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_BINDING_BUFFER`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_BUFFER_DATA_STORE_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexBuffer`               |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTextureBuffer`           |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glGenTextures](glgentextures.xhtml), [glBindTexture](glbindtexture.xhtml), [glDeleteTextures](gldeletetextures.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexBuffer.xhtml)"
- name: glTexBufferRange
  id: gltexbufferrange.xhtml
  summary: target Specifies the target to which the texture object is bound for glTexBufferRange
  description: "## Name\n\nglTexBufferRange, glTextureBufferRange — attach a range of a buffer object's data store to a buffer texture object\n\n## C Specification\n\n`void `**`glTexBufferRange`**`(` GLenum `target`, GLenum `internalformat`, GLuint `buffer`, GLintptr `offset`, GLsizeiptr `size``)`;\n\n`void `**`glTextureBufferRange`**`(` GLuint `texture`, GLenum `internalformat`, GLuint `buffer`, GLintptr `offset`, GLsizei `size``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glTexBufferRange`. Must be `GL_TEXTURE_BUFFER`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureBufferRange`.\n\n *`internalformat`*  \nSpecifies the internal format of the data in the store belonging to *`buffer`*.\n\n *`buffer`*  \nSpecifies the name of the buffer object whose storage to attach to the active buffer texture.\n\n *`offset`*  \nSpecifies the offset of the start of the range of the buffer's data store to attach.\n\n *`size`*  \nSpecifies the size of the range of the buffer's data store to attach.\n\n## Description\n\n`glTexBufferRange` and `glTextureBufferRange` attach a range of the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found in the buffer object. The texture object must be a buffer texture.\n\nIf *`buffer`* is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If *`buffer`* is non-zero, it must be the name of an existing buffer object.\n\nThe start and size of the range are specified by *`offset`* and *`size`* respectively, both measured in basic machine units. *`offset`* must be greater than or equal to zero, *`size`* must be greater than zero, and the sum of *`offset`* and *`size`* must not exceed the value of `GL_BUFFER_SIZE` for *`buffer`*. Furthermore, *`offset`* must be an integer multiple of the value of `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`.\n\n*`internalformat`* specifies the storage format, and must be one of the following sized internal formats:\n\n|                             |                 |                  |            |  **Component**  |     |     |     |\n|:----------------------------|:----------------|:-----------------|:-----------|:---------------:|:---:|:---:|:---:|\n|  **Sized Internal Format**  |  **Base Type**  |  **Components**  |  **Norm**  |        0        |  1  |  2  |  3  |\n| `GL_R8`                     | ubyte           | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16`                    | ushort          | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16F`                   | half            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32F`                   | float           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8I`                    | byte            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16I`                   | short           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32I`                   | int             | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8UI`                   | ubyte           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16UI`                  | ushort          | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32UI`                  | uint            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_RG8`                    | ubyte           | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16`                   | ushort          | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16F`                  | half            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32F`                  | float           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8I`                   | byte            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16I`                  | short           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32I`                  | int             | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8UI`                  | ubyte           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16UI`                 | ushort          | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32UI`                 | uint            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RGB32F`                 | float           | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32I`                 | int             | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32UI`                | uint            | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGBA8`                  | uint            | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16`                 | short           | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16F`                | half            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32F`                | float           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8I`                 | byte            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16I`                | short           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32I`                | int             | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8UI`                | ubyte           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16UI`               | ushort          | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32UI`               | uint            | 4                | NO         |        R        |  G  |  B  |  A  |\n\nWhen a range of a buffer object is attached to a buffer texture, the specified range of the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \\left\\lfloor { size \\over { components \\times sizeof(base\\\\type) } } \\right\\rfloor $$ where $components$ and $base\\\\type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit `GL_MAX_TEXTURE_BUFFER_SIZE`. When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glTexBufferRange` if *`target`* is not `GL_TEXTURE_BUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glTextureBufferRange` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated by `glTextureBufferRange` if the effective target of *`texture`* is not `GL_TEXTURE_BUFFER`.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the sized internal formats described above.\n\n`GL_INVALID_OPERATION` is generated if *`buffer`* is not zero and is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* is negative, if *`size`* is less than or equal to zero, or if *`offset`* + *`size`* is greater than the value of `GL_BUFFER_SIZE` for *`buffer`*.\n\n`GL_INVALID_VALUE` is generated if *`offset`* is not an integer multiple of the value of `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_BUFFER_OFFSET` or `GL_TEXTURE_BUFFER_SIZE`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexBufferRange`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glTextureBufferRange`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glTexBuffer](gltexbuffer.xhtml).\n\n## Copyright\n\nCopyright © 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexBufferRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexBufferRange.xhtml)"
- name: glTexImage1D
  id: glteximage1d.xhtml
  summary: target Specifies the target texture
  description: "## Name\n\nglTexImage1D — specify a one-dimensional texture image\n\n## C Specification\n\n`void `**`glTexImage1D`**`(` GLenum `target`, GLint `level`, GLint `internalformat`, GLsizei `width`, GLint `border`, GLenum `format`, GLenum `type`, const void \\* `data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target texture. Must be `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`internalformat`*  \nSpecifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.\n\n *`width`*  \nSpecifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1.\n\n *`border`*  \nThis value must be 0.\n\n *`format`*  \nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`.\n\n *`type`*  \nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n *`data`*  \nSpecifies a pointer to the image data in memory.\n\n## Description\n\nTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable one-dimensional texturing, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_TEXTURE_1D`.\n\nTexture images are defined with `glTexImage1D`. The arguments describe the parameters of the texture image, such as width, width of the border, level-of-detail number (see [glTexParameter](gltexparameter.xhtml)), and the internal resolution and format used to store the image. The last three arguments describe how the image is represented in memory.\n\nIf *`target`* is `GL_PROXY_TEXTURE_1D`, no data is read from *`data`*, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see [glGetError](glgeterror.xhtml)). To query for an entire mipmap array, use an image array level greater than or equal to 1.\n\nIf *`target`* is `GL_TEXTURE_1D`, data is read from *`data`* as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on *`type`*. These values are grouped into sets of one, two, three, or four values, depending on *`format`*, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by `GL_UNPACK_LSB_FIRST` (see [glPixelStore](glpixelstore.xhtml)).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\nThe first element corresponds to the left end of the texture array. Subsequent elements progress left-to-right through the remaining texels in the texture array. The final element corresponds to the right end of the texture array.\n\n*`format`* determines the composition of each element in *`data`*. It can assume one of these symbolic values:\n\n `GL_RED`  \nEach element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is clamped to the range \\[0,1\\].\n\n `GL_RG`  \nEach element is a single red/green double The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is clamped to the range \\[0,1\\].\n\n`GL_RGB`,   `GL_BGR`  \nEach element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped to the range \\[0,1\\].\n\n`GL_RGBA`,   `GL_BGRA`  \nEach element contains all four components. Each component clamped to the range \\[0,1\\].\n\n `GL_DEPTH_COMPONENT`  \nEach element is a single depth value. The GL converts it to floating point and clamps to the range \\[0,1\\].\n\nIf an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with *`internalformat`*. The GL will choose an internal representation that closely approximates that requested by *`internalformat`*, but it may not match exactly. (The representations specified by `GL_RED`, `GL_RG`, `GL_RGB` and `GL_RGBA` must match exactly.)\n\n*`internalformat`* may be one of the base internal formats shown in Table 1, below\n\nTable 1. Base Internal Formats\n\n| **Base Internal Format** | **RGBA, Depth and Stencil Values** | **Internal Components** |\n|:-------------------------|:-----------------------------------|:------------------------|\n| `GL_DEPTH_COMPONENT`     | Depth                              | D                       |\n| `GL_DEPTH_STENCIL`       | Depth, Stencil                     | D, S                    |\n| `GL_RED`                 | Red                                | R                       |\n| `GL_RG`                  | Red, Green                         | R, G                    |\n| `GL_RGB`                 | Red, Green, Blue                   | R, G, B                 |\n| `GL_RGBA`                | Red, Green, Blue, Alpha            | R, G, B, A              |\n\n  \n\n*`internalformat`* may also be one of the sized internal formats shown in Table 2, below\n\nTable 2. Sized Internal Formats\n\n| **Sized Internal Format** | **Base Internal Format** | **Red Bits** | **Green Bits** | **Blue Bits** | **Alpha Bits** | **Shared Bits** |\n|:--------------------------|:-------------------------|:------------:|:--------------:|:-------------:|:--------------:|:---------------:|\n| `GL_R8`                   | `GL_RED`                 |      8       |                |               |                |                 |\n| `GL_R8_SNORM`             | `GL_RED`                 |      s8      |                |               |                |                 |\n| `GL_R16`                  | `GL_RED`                 |      16      |                |               |                |                 |\n| `GL_R16_SNORM`            | `GL_RED`                 |     s16      |                |               |                |                 |\n| `GL_RG8`                  | `GL_RG`                  |      8       |       8        |               |                |                 |\n| `GL_RG8_SNORM`            | `GL_RG`                  |      s8      |       s8       |               |                |                 |\n| `GL_RG16`                 | `GL_RG`                  |      16      |       16       |               |                |                 |\n| `GL_RG16_SNORM`           | `GL_RG`                  |     s16      |      s16       |               |                |                 |\n| `GL_R3_G3_B2`             | `GL_RGB`                 |      3       |       3        |       2       |                |                 |\n| `GL_RGB4`                 | `GL_RGB`                 |      4       |       4        |       4       |                |                 |\n| `GL_RGB5`                 | `GL_RGB`                 |      5       |       5        |       5       |                |                 |\n| `GL_RGB8`                 | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_RGB8_SNORM`           | `GL_RGB`                 |      s8      |       s8       |      s8       |                |                 |\n| `GL_RGB10`                | `GL_RGB`                 |      10      |       10       |      10       |                |                 |\n| `GL_RGB12`                | `GL_RGB`                 |      12      |       12       |      12       |                |                 |\n| `GL_RGB16_SNORM`          | `GL_RGB`                 |      16      |       16       |      16       |                |                 |\n| `GL_RGBA2`                | `GL_RGB`                 |      2       |       2        |       2       |       2        |                 |\n| `GL_RGBA4`                | `GL_RGB`                 |      4       |       4        |       4       |       4        |                 |\n| `GL_RGB5_A1`              | `GL_RGBA`                |      5       |       5        |       5       |       1        |                 |\n| `GL_RGBA8`                | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_RGBA8_SNORM`          | `GL_RGBA`                |      s8      |       s8       |      s8       |       s8       |                 |\n| `GL_RGB10_A2`             | `GL_RGBA`                |      10      |       10       |      10       |       2        |                 |\n| `GL_RGB10_A2UI`           | `GL_RGBA`                |     ui10     |      ui10      |     ui10      |      ui2       |                 |\n| `GL_RGBA12`               | `GL_RGBA`                |      12      |       12       |      12       |       12       |                 |\n| `GL_RGBA16`               | `GL_RGBA`                |      16      |       16       |      16       |       16       |                 |\n| `GL_SRGB8`                | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_SRGB8_ALPHA8`         | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_R16F`                 | `GL_RED`                 |     f16      |                |               |                |                 |\n| `GL_RG16F`                | `GL_RG`                  |     f16      |      f16       |               |                |                 |\n| `GL_RGB16F`               | `GL_RGB`                 |     f16      |      f16       |      f16      |                |                 |\n| `GL_RGBA16F`              | `GL_RGBA`                |     f16      |      f16       |      f16      |      f16       |                 |\n| `GL_R32F`                 | `GL_RED`                 |     f32      |                |               |                |                 |\n| `GL_RG32F`                | `GL_RG`                  |     f32      |      f32       |               |                |                 |\n| `GL_RGB32F`               | `GL_RGB`                 |     f32      |      f32       |      f32      |                |                 |\n| `GL_RGBA32F`              | `GL_RGBA`                |     f32      |      f32       |      f32      |      f32       |                 |\n| `GL_R11F_G11F_B10F`       | `GL_RGB`                 |     f11      |      f11       |      f10      |                |                 |\n| `GL_RGB9_E5`              | `GL_RGB`                 |      9       |       9        |       9       |                |        5        |\n| `GL_R8I`                  | `GL_RED`                 |      i8      |                |               |                |                 |\n| `GL_R8UI`                 | `GL_RED`                 |     ui8      |                |               |                |                 |\n| `GL_R16I`                 | `GL_RED`                 |     i16      |                |               |                |                 |\n| `GL_R16UI`                | `GL_RED`                 |     ui16     |                |               |                |                 |\n| `GL_R32I`                 | `GL_RED`                 |     i32      |                |               |                |                 |\n| `GL_R32UI`                | `GL_RED`                 |     ui32     |                |               |                |                 |\n| `GL_RG8I`                 | `GL_RG`                  |      i8      |       i8       |               |                |                 |\n| `GL_RG8UI`                | `GL_RG`                  |     ui8      |      ui8       |               |                |                 |\n| `GL_RG16I`                | `GL_RG`                  |     i16      |      i16       |               |                |                 |\n| `GL_RG16UI`               | `GL_RG`                  |     ui16     |      ui16      |               |                |                 |\n| `GL_RG32I`                | `GL_RG`                  |     i32      |      i32       |               |                |                 |\n| `GL_RG32UI`               | `GL_RG`                  |     ui32     |      ui32      |               |                |                 |\n| `GL_RGB8I`                | `GL_RGB`                 |      i8      |       i8       |      i8       |                |                 |\n| `GL_RGB8UI`               | `GL_RGB`                 |     ui8      |      ui8       |      ui8      |                |                 |\n| `GL_RGB16I`               | `GL_RGB`                 |     i16      |      i16       |      i16      |                |                 |\n| `GL_RGB16UI`              | `GL_RGB`                 |     ui16     |      ui16      |     ui16      |                |                 |\n| `GL_RGB32I`               | `GL_RGB`                 |     i32      |      i32       |      i32      |                |                 |\n| `GL_RGB32UI`              | `GL_RGB`                 |     ui32     |      ui32      |     ui32      |                |                 |\n| `GL_RGBA8I`               | `GL_RGBA`                |      i8      |       i8       |      i8       |       i8       |                 |\n| `GL_RGBA8UI`              | `GL_RGBA`                |     ui8      |      ui8       |      ui8      |      ui8       |                 |\n| `GL_RGBA16I`              | `GL_RGBA`                |     i16      |      i16       |      i16      |      i16       |                 |\n| `GL_RGBA16UI`             | `GL_RGBA`                |     ui16     |      ui16      |     ui16      |      ui16      |                 |\n| `GL_RGBA32I`              | `GL_RGBA`                |     i32      |      i32       |      i32      |      i32       |                 |\n| `GL_RGBA32UI`             | `GL_RGBA`                |     ui32     |      ui32      |     ui32      |      ui32      |                 |\n\n  \n\nFinally, *`internalformat`* may also be one of the generic or compressed texture formats shown in Table 3 below\n\nTable 3. Compressed Internal Formats\n\n| **Compressed Internal Format**          | **Base Internal Format** | **Type** |\n|:----------------------------------------|:-------------------------|:---------|\n| `GL_COMPRESSED_RED`                     | `GL_RED`                 | Generic  |\n| `GL_COMPRESSED_RG`                      | `GL_RG`                  | Generic  |\n| `GL_COMPRESSED_RGB`                     | `GL_RGB`                 | Generic  |\n| `GL_COMPRESSED_RGBA`                    | `GL_RGBA`                | Generic  |\n| `GL_COMPRESSED_SRGB`                    | `GL_RGB`                 | Generic  |\n| `GL_COMPRESSED_SRGB_ALPHA`              | `GL_RGBA`                | Generic  |\n| `GL_COMPRESSED_RED_RGTC1`               | `GL_RED`                 | Specific |\n| `GL_COMPRESSED_SIGNED_RED_RGTC1`        | `GL_RED`                 | Specific |\n| `GL_COMPRESSED_RG_RGTC2`                | `GL_RG`                  | Specific |\n| `GL_COMPRESSED_SIGNED_RG_RGTC2`         | `GL_RG`                  | Specific |\n| `GL_COMPRESSED_RGBA_BPTC_UNORM`         | `GL_RGBA`                | Specific |\n| `GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`   | `GL_RGBA`                | Specific |\n| `GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`   | `GL_RGB`                 | Specific |\n| `GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT` | `GL_RGB`                 | Specific |\n\n  \n\nIf the *`internalformat`* parameter is one of the generic compressed formats, `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, or `GL_COMPRESSED_RGBA`, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.\n\nIf the *`internalformat`* parameter is `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`or `GL_SRGB8_ALPHA8`, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component *c*_(*s*) to a linear component *c*_(*l*) is:\n\n$\\mathit{c}\\_{\\mathit{l}} = \\begin{cases}\n\\frac{\\mathit{c}\\_{\\mathit{s}}}{12.92} & {{\\mspace{41mu}\\operatorname{if}\\mspace{41mu}}\\mathit{c}\\_{\\mathit{s}} \\leq 0.04045} \\\\\n\\left( \\frac{c\\_{s} + 0.055}{1.055} \\right)^{2.4} & {{\\mspace{41mu}\\operatorname{if}\\mspace{41mu}}\\mathit{c}\\_{\\mathit{s}} \\> 0.04045}\n\\end{cases}$\n\nAssume *c*_(*s*) is the sRGB component in the range \\[0,1\\].\n\nUse the `GL_PROXY_TEXTURE_1D` target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call [glGetTexLevelParameter](glgettexlevelparameter.xhtml). If the texture cannot be accommodated, texture state is set to 0.\n\nA one-component texture image uses only the red component of the RGBA color from *`data`*. A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.\n\nImage-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See [glTexParameter](gltexparameter.xhtml) for details on texture comparison.\n\n## Notes\n\n[glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n*`data`* may be a null pointer. In this case texture memory is allocated to accommodate a texture of width *`width`*. You can then download subtextures to initialize the texture memory. The image is undefined if the program tries to apply an uninitialized portion of the texture image to a primitive.\n\n`glTexImage1D` specifies the one-dimensional texture for the current texture unit, specified with [glActiveTexture](glactivetexture.xhtml).\n\n`GL_STENCIL_INDEX` may be used for *`format`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.\n\n`GL_INVALID_ENUM` is generated if *`format`* is not an accepted format constant. Format constants other than `GL_STENCIL_INDEX` are accepted.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not a type constant.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂(*max* ), where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`internalformat`* is not one of the accepted resolution and format symbolic constants.\n\n`GL_INVALID_VALUE` is generated if *`width`* is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`border`* is not 0.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_DEPTH_COMPONENT` and *`internalformat`* is not `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32`.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32`, and *`format`* is not `GL_DEPTH_COMPONENT`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and *`data`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexImage1D`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `GL_HALF_FLOAT`             |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glGetCompressedTexImage](glgetcompressedteximage.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage1D.xhtml)"
- name: glTexImage2D
  id: glteximage2d.xhtml
  summary: target Specifies the target texture
  description: "## Name\n\nglTexImage2D — specify a two-dimensional texture image\n\n## C Specification\n\n`void `**`glTexImage2D`**`(` GLenum `target`, GLint `level`, GLint `internalformat`, GLsizei `width`, GLsizei `height`, GLint `border`, GLenum `format`, GLenum `type`, const void \\* `data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target texture. Must be `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_PROXY_TEXTURE_CUBE_MAP`.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image. If *`target`* is `GL_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_RECTANGLE`, *`level`* must be 0.\n\n *`internalformat`*  \nSpecifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.\n\n *`width`*  \nSpecifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.\n\n *`height`*  \nSpecifies the height of the texture image, or the number of layers in a texture array, in the case of the `GL_TEXTURE_1D_ARRAY` and `GL_PROXY_TEXTURE_1D_ARRAY` targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.\n\n *`border`*  \nThis value must be 0.\n\n *`format`*  \nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`.\n\n *`type`*  \nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n *`data`*  \nSpecifies a pointer to the image data in memory.\n\n## Description\n\nTexturing allows elements of an image array to be read by shaders.\n\nTo define texture images, call `glTexImage2D`. The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see [glTexParameter](gltexparameter.xhtml)), and number of color components provided. The last three arguments describe how the image is represented in memory.\n\nIf *`target`* is `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_CUBE_MAP`, or `GL_PROXY_TEXTURE_RECTANGLE`, no data is read from *`data`*, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see [glGetError](glgeterror.xhtml)). To query for an entire mipmap array, use an image array level greater than or equal to 1.\n\nIf *`target`* is `GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE` or one of the `GL_TEXTURE_CUBE_MAP` targets, data is read from *`data`* as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on *`type`*. These values are grouped into sets of one, two, three, or four values, depending on *`format`*, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by `GL_UNPACK_LSB_FIRST` (see [glPixelStore](glpixelstore.xhtml)).\n\nIf *`target`* is `GL_TEXTURE_1D_ARRAY`, data is interpreted as an array of one-dimensional images.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\nThe first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.\n\n*`format`* determines the composition of each element in *`data`*. It can assume one of these symbolic values:\n\n `GL_RED`  \nEach element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is clamped to the range \\[0,1\\].\n\n `GL_RG`  \nEach element is a red/green double. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is clamped to the range \\[0,1\\].\n\n`GL_RGB`,   `GL_BGR`  \nEach element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped to the range \\[0,1\\].\n\n`GL_RGBA`,   `GL_BGRA`  \nEach element contains all four components. Each component is clamped to the range \\[0,1\\].\n\n `GL_DEPTH_COMPONENT`  \nEach element is a single depth value. The GL converts it to floating point and clamps to the range \\[0,1\\].\n\n `GL_DEPTH_STENCIL`  \nEach element is a pair of depth and stencil values. The depth component of the pair is interpreted as in `GL_DEPTH_COMPONENT`. The stencil component is interpreted based on specified the depth + stencil internal format.\n\nIf an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with *`internalformat`*. The GL will choose an internal representation that closely approximates that requested by *`internalformat`*, but it may not match exactly. (The representations specified by `GL_RED`, `GL_RG`, `GL_RGB`, and `GL_RGBA` must match exactly.)\n\n*`internalformat`* may be one of the base internal formats shown in Table 1, below\n\nTable 1. Base Internal Formats\n\n| **Base Internal Format** | **RGBA, Depth and Stencil Values** | **Internal Components** |\n|:-------------------------|:-----------------------------------|:------------------------|\n| `GL_DEPTH_COMPONENT`     | Depth                              | D                       |\n| `GL_DEPTH_STENCIL`       | Depth, Stencil                     | D, S                    |\n| `GL_RED`                 | Red                                | R                       |\n| `GL_RG`                  | Red, Green                         | R, G                    |\n| `GL_RGB`                 | Red, Green, Blue                   | R, G, B                 |\n| `GL_RGBA`                | Red, Green, Blue, Alpha            | R, G, B, A              |\n\n  \n\n*`internalformat`* may also be one of the sized internal formats shown in Table 2, below\n\nTable 2. Sized Internal Formats\n\n| **Sized Internal Format** | **Base Internal Format** | **Red Bits** | **Green Bits** | **Blue Bits** | **Alpha Bits** | **Shared Bits** |\n|:--------------------------|:-------------------------|:------------:|:--------------:|:-------------:|:--------------:|:---------------:|\n| `GL_R8`                   | `GL_RED`                 |      8       |                |               |                |                 |\n| `GL_R8_SNORM`             | `GL_RED`                 |      s8      |                |               |                |                 |\n| `GL_R16`                  | `GL_RED`                 |      16      |                |               |                |                 |\n| `GL_R16_SNORM`            | `GL_RED`                 |     s16      |                |               |                |                 |\n| `GL_RG8`                  | `GL_RG`                  |      8       |       8        |               |                |                 |\n| `GL_RG8_SNORM`            | `GL_RG`                  |      s8      |       s8       |               |                |                 |\n| `GL_RG16`                 | `GL_RG`                  |      16      |       16       |               |                |                 |\n| `GL_RG16_SNORM`           | `GL_RG`                  |     s16      |      s16       |               |                |                 |\n| `GL_R3_G3_B2`             | `GL_RGB`                 |      3       |       3        |       2       |                |                 |\n| `GL_RGB4`                 | `GL_RGB`                 |      4       |       4        |       4       |                |                 |\n| `GL_RGB5`                 | `GL_RGB`                 |      5       |       5        |       5       |                |                 |\n| `GL_RGB8`                 | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_RGB8_SNORM`           | `GL_RGB`                 |      s8      |       s8       |      s8       |                |                 |\n| `GL_RGB10`                | `GL_RGB`                 |      10      |       10       |      10       |                |                 |\n| `GL_RGB12`                | `GL_RGB`                 |      12      |       12       |      12       |                |                 |\n| `GL_RGB16_SNORM`          | `GL_RGB`                 |      16      |       16       |      16       |                |                 |\n| `GL_RGBA2`                | `GL_RGB`                 |      2       |       2        |       2       |       2        |                 |\n| `GL_RGBA4`                | `GL_RGB`                 |      4       |       4        |       4       |       4        |                 |\n| `GL_RGB5_A1`              | `GL_RGBA`                |      5       |       5        |       5       |       1        |                 |\n| `GL_RGBA8`                | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_RGBA8_SNORM`          | `GL_RGBA`                |      s8      |       s8       |      s8       |       s8       |                 |\n| `GL_RGB10_A2`             | `GL_RGBA`                |      10      |       10       |      10       |       2        |                 |\n| `GL_RGB10_A2UI`           | `GL_RGBA`                |     ui10     |      ui10      |     ui10      |      ui2       |                 |\n| `GL_RGBA12`               | `GL_RGBA`                |      12      |       12       |      12       |       12       |                 |\n| `GL_RGBA16`               | `GL_RGBA`                |      16      |       16       |      16       |       16       |                 |\n| `GL_SRGB8`                | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_SRGB8_ALPHA8`         | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_R16F`                 | `GL_RED`                 |     f16      |                |               |                |                 |\n| `GL_RG16F`                | `GL_RG`                  |     f16      |      f16       |               |                |                 |\n| `GL_RGB16F`               | `GL_RGB`                 |     f16      |      f16       |      f16      |                |                 |\n| `GL_RGBA16F`              | `GL_RGBA`                |     f16      |      f16       |      f16      |      f16       |                 |\n| `GL_R32F`                 | `GL_RED`                 |     f32      |                |               |                |                 |\n| `GL_RG32F`                | `GL_RG`                  |     f32      |      f32       |               |                |                 |\n| `GL_RGB32F`               | `GL_RGB`                 |     f32      |      f32       |      f32      |                |                 |\n| `GL_RGBA32F`              | `GL_RGBA`                |     f32      |      f32       |      f32      |      f32       |                 |\n| `GL_R11F_G11F_B10F`       | `GL_RGB`                 |     f11      |      f11       |      f10      |                |                 |\n| `GL_RGB9_E5`              | `GL_RGB`                 |      9       |       9        |       9       |                |        5        |\n| `GL_R8I`                  | `GL_RED`                 |      i8      |                |               |                |                 |\n| `GL_R8UI`                 | `GL_RED`                 |     ui8      |                |               |                |                 |\n| `GL_R16I`                 | `GL_RED`                 |     i16      |                |               |                |                 |\n| `GL_R16UI`                | `GL_RED`                 |     ui16     |                |               |                |                 |\n| `GL_R32I`                 | `GL_RED`                 |     i32      |                |               |                |                 |\n| `GL_R32UI`                | `GL_RED`                 |     ui32     |                |               |                |                 |\n| `GL_RG8I`                 | `GL_RG`                  |      i8      |       i8       |               |                |                 |\n| `GL_RG8UI`                | `GL_RG`                  |     ui8      |      ui8       |               |                |                 |\n| `GL_RG16I`                | `GL_RG`                  |     i16      |      i16       |               |                |                 |\n| `GL_RG16UI`               | `GL_RG`                  |     ui16     |      ui16      |               |                |                 |\n| `GL_RG32I`                | `GL_RG`                  |     i32      |      i32       |               |                |                 |\n| `GL_RG32UI`               | `GL_RG`                  |     ui32     |      ui32      |               |                |                 |\n| `GL_RGB8I`                | `GL_RGB`                 |      i8      |       i8       |      i8       |                |                 |\n| `GL_RGB8UI`               | `GL_RGB`                 |     ui8      |      ui8       |      ui8      |                |                 |\n| `GL_RGB16I`               | `GL_RGB`                 |     i16      |      i16       |      i16      |                |                 |\n| `GL_RGB16UI`              | `GL_RGB`                 |     ui16     |      ui16      |     ui16      |                |                 |\n| `GL_RGB32I`               | `GL_RGB`                 |     i32      |      i32       |      i32      |                |                 |\n| `GL_RGB32UI`              | `GL_RGB`                 |     ui32     |      ui32      |     ui32      |                |                 |\n| `GL_RGBA8I`               | `GL_RGBA`                |      i8      |       i8       |      i8       |       i8       |                 |\n| `GL_RGBA8UI`              | `GL_RGBA`                |     ui8      |      ui8       |      ui8      |      ui8       |                 |\n| `GL_RGBA16I`              | `GL_RGBA`                |     i16      |      i16       |      i16      |      i16       |                 |\n| `GL_RGBA16UI`             | `GL_RGBA`                |     ui16     |      ui16      |     ui16      |      ui16      |                 |\n| `GL_RGBA32I`              | `GL_RGBA`                |     i32      |      i32       |      i32      |      i32       |                 |\n| `GL_RGBA32UI`             | `GL_RGBA`                |     ui32     |      ui32      |     ui32      |      ui32      |                 |\n\n  \n\nFinally, *`internalformat`* may also be one of the generic or compressed texture formats shown in Table 3 below\n\nTable 3. Compressed Internal Formats\n\n| **Compressed Internal Format**          | **Base Internal Format** | **Type** |\n|:----------------------------------------|:-------------------------|:---------|\n| `GL_COMPRESSED_RED`                     | `GL_RED`                 | Generic  |\n| `GL_COMPRESSED_RG`                      | `GL_RG`                  | Generic  |\n| `GL_COMPRESSED_RGB`                     | `GL_RGB`                 | Generic  |\n| `GL_COMPRESSED_RGBA`                    | `GL_RGBA`                | Generic  |\n| `GL_COMPRESSED_SRGB`                    | `GL_RGB`                 | Generic  |\n| `GL_COMPRESSED_SRGB_ALPHA`              | `GL_RGBA`                | Generic  |\n| `GL_COMPRESSED_RED_RGTC1`               | `GL_RED`                 | Specific |\n| `GL_COMPRESSED_SIGNED_RED_RGTC1`        | `GL_RED`                 | Specific |\n| `GL_COMPRESSED_RG_RGTC2`                | `GL_RG`                  | Specific |\n| `GL_COMPRESSED_SIGNED_RG_RGTC2`         | `GL_RG`                  | Specific |\n| `GL_COMPRESSED_RGBA_BPTC_UNORM`         | `GL_RGBA`                | Specific |\n| `GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`   | `GL_RGBA`                | Specific |\n| `GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`   | `GL_RGB`                 | Specific |\n| `GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT` | `GL_RGB`                 | Specific |\n\n  \n\nIf the *`internalformat`* parameter is one of the generic compressed formats, `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, or `GL_COMPRESSED_RGBA`, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.\n\nIf the *`internalformat`* parameter is `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component *c*_(*s*) to a linear component *c*_(*l*) is:\n\n$\\mathit{c}\\_{\\mathit{l}} = \\begin{cases}\n\\frac{\\mathit{c}\\_{\\mathit{s}}}{12.92} & {{\\mspace{41mu}\\operatorname{if}\\mspace{41mu}}\\mathit{c}\\_{\\mathit{s}} \\leq 0.04045} \\\\\n\\left( \\frac{c\\_{s} + 0.055}{1.055} \\right)^{2.4} & {{\\mspace{41mu}\\operatorname{if}\\mspace{41mu}}\\mathit{c}\\_{\\mathit{s}} \\> 0.04045}\n\\end{cases}$\n\nAssume *c*_(*s*) is the sRGB component in the range \\[0,1\\].\n\nUse the `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, or `GL_PROXY_TEXTURE_CUBE_MAP` target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call [glGetTexLevelParameter](glgettexlevelparameter.xhtml). If the texture cannot be accommodated, texture state is set to 0.\n\nA one-component texture image uses only the red component of the RGBA color extracted from *`data`*. A two-component image uses the R and G values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.\n\nImage-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See [glTexParameter](gltexparameter.xhtml) for details on texture comparison.\n\n## Notes\n\nThe [glPixelStore](glpixelstore.xhtml) mode affects texture images.\n\n*`data`* may be a null pointer. In this case, texture memory is allocated to accommodate a texture of width *`width`* and height *`height`*. You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive.\n\n`glTexImage2D` specifies the two-dimensional texture for the current texture unit, specified with [glActiveTexture](glactivetexture.xhtml).\n\n`GL_STENCIL_INDEX` may be used for *`format`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, or `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`.\n\n`GL_INVALID_ENUM` is generated if *`target`* is one of the six cube map 2D image targets and the width and height parameters are not equal.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not a type constant.\n\n`GL_INVALID_VALUE` is generated if *`width`* is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`target`* is not `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and *`height`* is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`target`* is `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and *`height`* is less than 0 or greater than `GL_MAX_ARRAY_TEXTURE_LAYERS`.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂(*max* ), where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`internalformat`* is not one of the accepted resolution and format symbolic constants.\n\n`GL_INVALID_VALUE` is generated if *`width`* or *`height`* is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`border`* is not 0.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, or `GL_UNSIGNED_INT_10F_11F_11F_REV`, and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, `GL_UNSIGNED_INT_2_10_10_10_REV`, or `GL_UNSIGNED_INT_5_9_9_9_REV`, and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is not `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, or `GL_PROXY_TEXTURE_RECTANGLE`, and *`internalformat`* is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32F`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_DEPTH_COMPONENT` and *`internalformat`* is not `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32F`.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32F`, and *`format`* is not `GL_DEPTH_COMPONENT`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and *`data`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n`GL_INVALID_VALUE` is generated if *`target`* is `GL_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_RECTANGLE` and *`level`* is not 0.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexImage2D`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `GL_HALF_FLOAT`             |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage2D.xhtml)"
- name: glTexImage2DMultisample
  id: glteximage2dmultisample.xhtml
  summary: target Specifies the target of the operation
  description: "## Name\n\nglTexImage2DMultisample — establish the data storage, format, dimensions, and number of samples of a multisample texture's image\n\n## C Specification\n\n`void `**`glTexImage2DMultisample`**`(` GLenum `target`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLboolean `fixedsamplelocations``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target of the operation. *`target`* must be `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`.\n\n *`samples`*  \nThe number of samples in the multisample texture's image.\n\n *`internalformat`*  \nThe internal format to be used to store the multisample texture's image. *`internalformat`* must specify a color-renderable, depth-renderable, or stencil-renderable format.\n\n *`width`*  \nThe width of the multisample texture's image, in texels.\n\n *`height`*  \nThe height of the multisample texture's image, in texels.\n\n *`fixedsamplelocations`*  \nSpecifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\n## Description\n\n`glTexImage2DMultisample` establishes the data storage, format, dimensions and number of samples of a multisample texture's image.\n\n*`target`* must be `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`. *`width`* and *`height`* are the dimensions in texels of the texture, and must be in the range zero to the value of `GL_MAX_TEXTURE_SIZE` minus one. *`samples`* specifies the number of samples in the image and must be in the range zero to the value of `GL_MAX_SAMPLES` minus one.\n\n*`internalformat`* must be a color-renderable, depth-renderable, or stencil-renderable format.\n\nIf *`fixedsamplelocations`* is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\nWhen a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.\n\n## Notes\n\n`glTexImage2DMultisample` is available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is a depth- or stencil-renderable format and *`samples`* is greater than the value of `GL_MAX_DEPTH_TEXTURE_SAMPLES`.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is a color-renderable format and *`samples`* is greater than the value of `GL_MAX_COLOR_TEXTURE_SAMPLES`.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is a signed or unsigned integer format and *`samples`* is greater than the value of `GL_MAX_INTEGER_SAMPLES`.\n\n`GL_INVALID_VALUE` is generated if either *`width`* or *`height`* negative or is greater than `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`samples`* is zero.\n\n`GL_INVALID_OPERATION` is generated if *`samples`* is greater than the maximum number of samples supported for this *`target`* and *`internalformat`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexImage2DMultisample`   |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glTexImage3D](glteximage3d.xhtml), [glTexImage2DMultisample](glteximage2dmultisample.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage2DMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage2DMultisample.xhtml)"
- name: glTexImage3D
  id: glteximage3d.xhtml
  summary: target Specifies the target texture
  description: "## Name\n\nglTexImage3D — specify a three-dimensional texture image\n\n## C Specification\n\n`void `**`glTexImage3D`**`(` GLenum `target`, GLint `level`, GLint `internalformat`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLint `border`, GLenum `format`, GLenum `type`, const void \\* `data``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target texture. Must be one of `GL_TEXTURE_3D`, `GL_PROXY_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_2D_ARRAY`.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*^(*t**h*) mipmap reduction image.\n\n *`internalformat`*  \nSpecifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.\n\n *`width`*  \nSpecifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.\n\n *`height`*  \nSpecifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.\n\n *`depth`*  \nSpecifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.\n\n *`border`*  \nThis value must be 0.\n\n *`format`*  \nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_RED_INTEGER`, `GL_RG_INTEGER`, `GL_RGB_INTEGER`, `GL_BGR_INTEGER`, `GL_RGBA_INTEGER`, `GL_BGRA_INTEGER`, `GL_STENCIL_INDEX`, `GL_DEPTH_COMPONENT`, `GL_DEPTH_STENCIL`.\n\n *`type`*  \nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n *`data`*  \nSpecifies a pointer to the image data in memory.\n\n## Description\n\nTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable three-dimensional texturing, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_TEXTURE_3D`.\n\nTo define texture images, call `glTexImage3D`. The arguments describe the parameters of the texture image, such as height, width, depth, width of the border, level-of-detail number (see [glTexParameter](gltexparameter.xhtml)), and number of color components provided. The last three arguments describe how the image is represented in memory.\n\nIf *`target`* is `GL_PROXY_TEXTURE_3D`, no data is read from *`data`*, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see [glGetError](glgeterror.xhtml)). To query for an entire mipmap array, use an image array level greater than or equal to 1.\n\nIf *`target`* is `GL_TEXTURE_3D`, data is read from *`data`* as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on *`type`*. These values are grouped into sets of one, two, three, or four values, depending on *`format`*, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by `GL_UNPACK_LSB_FIRST` (see [glPixelStore](glpixelstore.xhtml)).\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`data`* is treated as a byte offset into the buffer object's data store.\n\nThe first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.\n\n*`format`* determines the composition of each element in *`data`*. It can assume one of these symbolic values:\n\n `GL_RED`  \nEach element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is clamped to the range \\[0,1\\].\n\n `GL_RG`  \nEach element is a red and green pair. The GL converts each to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is clamped to the range \\[0,1\\].\n\n`GL_RGB`,   `GL_BGR`  \nEach element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped to the range \\[0,1\\].\n\n`GL_RGBA`,   `GL_BGRA`  \nEach element contains all four components. Each component is clamped to the range \\[0,1\\].\n\nIf an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with *`internalformat`*. The GL will choose an internal representation that closely approximates that requested by *`internalformat`*, but it may not match exactly. (The representations specified by `GL_RED`, `GL_RG`, `GL_RGB`, and `GL_RGBA` must match exactly.)\n\n*`internalformat`* may be one of the base internal formats shown in Table 1, below\n\nTable 1. Base Internal Formats\n\n| **Base Internal Format** | **RGBA, Depth and Stencil Values** | **Internal Components** |\n|:-------------------------|:-----------------------------------|:------------------------|\n| `GL_DEPTH_COMPONENT`     | Depth                              | D                       |\n| `GL_DEPTH_STENCIL`       | Depth, Stencil                     | D, S                    |\n| `GL_RED`                 | Red                                | R                       |\n| `GL_RG`                  | Red, Green                         | R, G                    |\n| `GL_RGB`                 | Red, Green, Blue                   | R, G, B                 |\n| `GL_RGBA`                | Red, Green, Blue, Alpha            | R, G, B, A              |\n\n  \n\n*`internalformat`* may also be one of the sized internal formats shown in Table 2, below\n\nTable 2. Sized Internal Formats\n\n| **Sized Internal Format** | **Base Internal Format** | **Red Bits** | **Green Bits** | **Blue Bits** | **Alpha Bits** | **Shared Bits** |\n|:--------------------------|:-------------------------|:------------:|:--------------:|:-------------:|:--------------:|:---------------:|\n| `GL_R8`                   | `GL_RED`                 |      8       |                |               |                |                 |\n| `GL_R8_SNORM`             | `GL_RED`                 |      s8      |                |               |                |                 |\n| `GL_R16`                  | `GL_RED`                 |      16      |                |               |                |                 |\n| `GL_R16_SNORM`            | `GL_RED`                 |     s16      |                |               |                |                 |\n| `GL_RG8`                  | `GL_RG`                  |      8       |       8        |               |                |                 |\n| `GL_RG8_SNORM`            | `GL_RG`                  |      s8      |       s8       |               |                |                 |\n| `GL_RG16`                 | `GL_RG`                  |      16      |       16       |               |                |                 |\n| `GL_RG16_SNORM`           | `GL_RG`                  |     s16      |      s16       |               |                |                 |\n| `GL_R3_G3_B2`             | `GL_RGB`                 |      3       |       3        |       2       |                |                 |\n| `GL_RGB4`                 | `GL_RGB`                 |      4       |       4        |       4       |                |                 |\n| `GL_RGB5`                 | `GL_RGB`                 |      5       |       5        |       5       |                |                 |\n| `GL_RGB8`                 | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_RGB8_SNORM`           | `GL_RGB`                 |      s8      |       s8       |      s8       |                |                 |\n| `GL_RGB10`                | `GL_RGB`                 |      10      |       10       |      10       |                |                 |\n| `GL_RGB12`                | `GL_RGB`                 |      12      |       12       |      12       |                |                 |\n| `GL_RGB16_SNORM`          | `GL_RGB`                 |      16      |       16       |      16       |                |                 |\n| `GL_RGBA2`                | `GL_RGB`                 |      2       |       2        |       2       |       2        |                 |\n| `GL_RGBA4`                | `GL_RGB`                 |      4       |       4        |       4       |       4        |                 |\n| `GL_RGB5_A1`              | `GL_RGBA`                |      5       |       5        |       5       |       1        |                 |\n| `GL_RGBA8`                | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_RGBA8_SNORM`          | `GL_RGBA`                |      s8      |       s8       |      s8       |       s8       |                 |\n| `GL_RGB10_A2`             | `GL_RGBA`                |      10      |       10       |      10       |       2        |                 |\n| `GL_RGB10_A2UI`           | `GL_RGBA`                |     ui10     |      ui10      |     ui10      |      ui2       |                 |\n| `GL_RGBA12`               | `GL_RGBA`                |      12      |       12       |      12       |       12       |                 |\n| `GL_RGBA16`               | `GL_RGBA`                |      16      |       16       |      16       |       16       |                 |\n| `GL_SRGB8`                | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_SRGB8_ALPHA8`         | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_R16F`                 | `GL_RED`                 |     f16      |                |               |                |                 |\n| `GL_RG16F`                | `GL_RG`                  |     f16      |      f16       |               |                |                 |\n| `GL_RGB16F`               | `GL_RGB`                 |     f16      |      f16       |      f16      |                |                 |\n| `GL_RGBA16F`              | `GL_RGBA`                |     f16      |      f16       |      f16      |      f16       |                 |\n| `GL_R32F`                 | `GL_RED`                 |     f32      |                |               |                |                 |\n| `GL_RG32F`                | `GL_RG`                  |     f32      |      f32       |               |                |                 |\n| `GL_RGB32F`               | `GL_RGB`                 |     f32      |      f32       |      f32      |                |                 |\n| `GL_RGBA32F`              | `GL_RGBA`                |     f32      |      f32       |      f32      |      f32       |                 |\n| `GL_R11F_G11F_B10F`       | `GL_RGB`                 |     f11      |      f11       |      f10      |                |                 |\n| `GL_RGB9_E5`              | `GL_RGB`                 |      9       |       9        |       9       |                |        5        |\n| `GL_R8I`                  | `GL_RED`                 |      i8      |                |               |                |                 |\n| `GL_R8UI`                 | `GL_RED`                 |     ui8      |                |               |                |                 |\n| `GL_R16I`                 | `GL_RED`                 |     i16      |                |               |                |                 |\n| `GL_R16UI`                | `GL_RED`                 |     ui16     |                |               |                |                 |\n| `GL_R32I`                 | `GL_RED`                 |     i32      |                |               |                |                 |\n| `GL_R32UI`                | `GL_RED`                 |     ui32     |                |               |                |                 |\n| `GL_RG8I`                 | `GL_RG`                  |      i8      |       i8       |               |                |                 |\n| `GL_RG8UI`                | `GL_RG`                  |     ui8      |      ui8       |               |                |                 |\n| `GL_RG16I`                | `GL_RG`                  |     i16      |      i16       |               |                |                 |\n| `GL_RG16UI`               | `GL_RG`                  |     ui16     |      ui16      |               |                |                 |\n| `GL_RG32I`                | `GL_RG`                  |     i32      |      i32       |               |                |                 |\n| `GL_RG32UI`               | `GL_RG`                  |     ui32     |      ui32      |               |                |                 |\n| `GL_RGB8I`                | `GL_RGB`                 |      i8      |       i8       |      i8       |                |                 |\n| `GL_RGB8UI`               | `GL_RGB`                 |     ui8      |      ui8       |      ui8      |                |                 |\n| `GL_RGB16I`               | `GL_RGB`                 |     i16      |      i16       |      i16      |                |                 |\n| `GL_RGB16UI`              | `GL_RGB`                 |     ui16     |      ui16      |     ui16      |                |                 |\n| `GL_RGB32I`               | `GL_RGB`                 |     i32      |      i32       |      i32      |                |                 |\n| `GL_RGB32UI`              | `GL_RGB`                 |     ui32     |      ui32      |     ui32      |                |                 |\n| `GL_RGBA8I`               | `GL_RGBA`                |      i8      |       i8       |      i8       |       i8       |                 |\n| `GL_RGBA8UI`              | `GL_RGBA`                |     ui8      |      ui8       |      ui8      |      ui8       |                 |\n| `GL_RGBA16I`              | `GL_RGBA`                |     i16      |      i16       |      i16      |      i16       |                 |\n| `GL_RGBA16UI`             | `GL_RGBA`                |     ui16     |      ui16      |     ui16      |      ui16      |                 |\n| `GL_RGBA32I`              | `GL_RGBA`                |     i32      |      i32       |      i32      |      i32       |                 |\n| `GL_RGBA32UI`             | `GL_RGBA`                |     ui32     |      ui32      |     ui32      |      ui32      |                 |\n\n  \n\nFinally, *`internalformat`* may also be one of the generic or compressed texture formats shown in Table 3 below\n\nTable 3. Compressed Internal Formats\n\n| **Compressed Internal Format**          | **Base Internal Format** | **Type** |\n|:----------------------------------------|:-------------------------|:---------|\n| `GL_COMPRESSED_RED`                     | `GL_RED`                 | Generic  |\n| `GL_COMPRESSED_RG`                      | `GL_RG`                  | Generic  |\n| `GL_COMPRESSED_RGB`                     | `GL_RGB`                 | Generic  |\n| `GL_COMPRESSED_RGBA`                    | `GL_RGBA`                | Generic  |\n| `GL_COMPRESSED_SRGB`                    | `GL_RGB`                 | Generic  |\n| `GL_COMPRESSED_SRGB_ALPHA`              | `GL_RGBA`                | Generic  |\n| `GL_COMPRESSED_RED_RGTC1`               | `GL_RED`                 | Specific |\n| `GL_COMPRESSED_SIGNED_RED_RGTC1`        | `GL_RED`                 | Specific |\n| `GL_COMPRESSED_RG_RGTC2`                | `GL_RG`                  | Specific |\n| `GL_COMPRESSED_SIGNED_RG_RGTC2`         | `GL_RG`                  | Specific |\n| `GL_COMPRESSED_RGBA_BPTC_UNORM`         | `GL_RGBA`                | Specific |\n| `GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`   | `GL_RGBA`                | Specific |\n| `GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`   | `GL_RGB`                 | Specific |\n| `GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT` | `GL_RGB`                 | Specific |\n\n  \n\nIf the *`internalformat`* parameter is one of the generic compressed formats, `GL_COMPRESSED_RED`, `GL_COMPRESSED_RG`, `GL_COMPRESSED_RGB`, or `GL_COMPRESSED_RGBA`, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.\n\nIf the *`internalformat`* parameter is `GL_SRGB`, `GL_SRGB8`, `GL_SRGB_ALPHA`, or `GL_SRGB8_ALPHA8`, the texture is treated as if the red, green, blue, or luminance components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component *c*_(*s*) to a linear component *c*_(*l*) is:\n\n$\\mathit{c}\\_{\\mathit{l}} = \\begin{cases}\n\\frac{\\mathit{c}\\_{\\mathit{s}}}{12.92} & {{\\mspace{41mu}\\operatorname{if}\\mspace{41mu}}\\mathit{c}\\_{\\mathit{s}} \\leq 0.04045} \\\\\n\\left( \\frac{c\\_{s} + 0.055}{1.055} \\right)^{2.4} & {{\\mspace{41mu}\\operatorname{if}\\mspace{41mu}}\\mathit{c}\\_{\\mathit{s}} \\> 0.04045}\n\\end{cases}$\n\nAssume *c*_(*s*) is the sRGB component in the range \\[0,1\\].\n\nUse the `GL_PROXY_TEXTURE_3D` target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call [glGetTexLevelParameter](glgettexlevelparameter.xhtml). If the texture cannot be accommodated, texture state is set to 0.\n\nA one-component texture image uses only the red component of the RGBA color extracted from *`data`*. A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.\n\n## Notes\n\nThe [glPixelStore](glpixelstore.xhtml) mode affects texture images.\n\n*`data`* may be a null pointer. In this case texture memory is allocated to accommodate a texture of width *`width`*, height *`height`*, and depth *`depth`*. You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive.\n\n`glTexImage3D` specifies the three-dimensional texture for the current texture unit, specified with [glActiveTexture](glactivetexture.xhtml).\n\n`GL_STENCIL_INDEX` may be used for *`format`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* is not `GL_TEXTURE_3D` or `GL_PROXY_TEXTURE_3D`.\n\n`GL_INVALID_ENUM` is generated if *`format`* is not an accepted format constant. Format constants other than `GL_STENCIL_INDEX` and `GL_DEPTH_COMPONENT` are accepted.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not a type constant.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂(*max* ), where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`internalformat`* is not one of the accepted resolution and format symbolic constants.\n\n`GL_INVALID_VALUE` is generated if *`width`*, *`height`*, or *`depth`* is less than 0 or greater than `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`border`* is not 0.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* or *`internalformat`* is `GL_DEPTH_COMPONENT`, `GL_DEPTH_COMPONENT16`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT32`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and *`data`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexImage3D`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `GL_HALF_FLOAT`             |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCompressedTexImage1D](glcompressedteximage1d.xhtml), [glCompressedTexImage2D](glcompressedteximage2d.xhtml), [glCompressedTexImage3D](glcompressedteximage3d.xhtml), [glCompressedTexSubImage1D](glcompressedtexsubimage1d.xhtml), [glCompressedTexSubImage2D](glcompressedtexsubimage2d.xhtml), [glCompressedTexSubImage3D](glcompressedtexsubimage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glGetCompressedTexImage](glgetcompressedteximage.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage3D.xhtml)"
- name: glTexImage3DMultisample
  id: glteximage3dmultisample.xhtml
  summary: target Specifies the target of the operation
  description: "## Name\n\nglTexImage3DMultisample — establish the data storage, format, dimensions, and number of samples of a multisample texture's image\n\n## C Specification\n\n`void `**`glTexImage3DMultisample`**`(` GLenum `target`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLboolean `fixedsamplelocations``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target of the operation. *`target`* must be `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n *`samples`*  \nThe number of samples in the multisample texture's image.\n\n *`internalformat`*  \nThe internal format to be used to store the multisample texture's image. *`internalformat`* must specify a color-renderable, depth-renderable, or stencil-renderable format.\n\n *`width`*  \nThe width of the multisample texture's image, in texels.\n\n *`height`*  \nThe height of the multisample texture's image, in texels.\n\n *`fixedsamplelocations`*  \nSpecifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\n## Description\n\n`glTexImage3DMultisample` establishes the data storage, format, dimensions and number of samples of a multisample texture's image.\n\n*`target`* must be `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`. *`width`* and *`height`*are the dimensions in texels of the texture, and must be in the range zero to the value of `GL_MAX_TEXTURE_SIZE` minus one. *`depth`* is the number of array slices in the array texture's image. *`samples`* specifies the number of samples in the image and must be in the range zero to the value of `GL_MAX_SAMPLES` minus one.\n\n*`internalformat`* must be a color-renderable, depth-renderable, or stencil-renderable format.\n\nIf *`fixedsamplelocations`* is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\nWhen a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.\n\n## Notes\n\n`glTexImage2DMultisample` is available only if the GL version is 3.2 or greater.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is a depth- or stencil-renderable format and *`samples`* is greater than the value of `GL_MAX_DEPTH_TEXTURE_SAMPLES`.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is a color-renderable format and *`samples`* is greater than the value of `GL_MAX_COLOR_TEXTURE_SAMPLES`.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is a signed or unsigned integer format and *`samples`* is greater than the value of `GL_MAX_INTEGER_SAMPLES`.\n\n`GL_INVALID_VALUE` is generated if either *`width`* or *`height`* negative or is greater than `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`depth`* is negative or is greater than `GL_MAX_ARRAY_TEXTURE_LAYERS`.\n\n`GL_INVALID_VALUE` is generated if *`samples`* is zero.\n\n`GL_INVALID_OPERATION` is generated if *`samples`* is greater than the maximum number of samples supported for this *`target`* and *`internalformat`*.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexImage3DMultisample`   |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glTexImage3D](glteximage3d.xhtml), [glTexImage2DMultisample](glteximage2dmultisample.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage3DMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexImage3DMultisample.xhtml)"
- name: glTexParameter
  id: gltexparameter.xhtml
  summary: target Specifies the target to which the texture is bound for glTexParameter functions
  description: "## Name\n\nglTexParameter, glTextureParameter — set texture parameters\n\n## C Specification\n\n`void `**`glTexParameterf`**`(` GLenum `target`, GLenum `pname`, GLfloat `param``)`;\n\n`void `**`glTexParameteri`**`(` GLenum `target`, GLenum `pname`, GLint `param``)`;\n\n`void `**`glTextureParameterf`**`(` GLuint `texture`, GLenum `pname`, GLfloat `param``)`;\n\n`void `**`glTextureParameteri`**`(` GLuint `texture`, GLenum `pname`, GLint `param``)`;\n\n`void `**`glTexParameterfv`**`(` GLenum `target`, GLenum `pname`, const GLfloat \\* `params``)`;\n\n`void `**`glTexParameteriv`**`(` GLenum `target`, GLenum `pname`, const GLint \\* `params``)`;\n\n`void `**`glTexParameterIiv`**`(` GLenum `target`, GLenum `pname`, const GLint \\* `params``)`;\n\n`void `**`glTexParameterIuiv`**`(` GLenum `target`, GLenum `pname`, const GLuint \\* `params``)`;\n\n`void `**`glTextureParameterfv`**`(` GLuint `texture`, GLenum `pname`, const GLfloat \\*`params``)`;\n\n`void `**`glTextureParameteriv`**`(` GLuint `texture`, GLenum `pname`, const GLint \\*`params``)`;\n\n`void `**`glTextureParameterIiv`**`(` GLuint `texture`, GLenum `pname`, const GLint \\*`params``)`;\n\n`void `**`glTextureParameterIuiv`**`(` GLuint `texture`, GLenum `pname`, const GLuint \\*`params``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glTexParameter` functions. Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_TEXTURE_RECTANGLE`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureParameter` functions.\n\n *`pname`*  \nSpecifies the symbolic name of a single-valued texture parameter. *`pname`* can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.\n\nFor the vector commands (`glTexParameter*v`), *`pname`* can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.\n\n *`param`*  \nFor the scalar commands, specifies the value of *`pname`*.\n\n *`params`*  \nFor the vector commands, specifies a pointer to an array where the value or values of *`pname`* are stored.\n\n## Description\n\n`glTexParameter` and `glTextureParameter` assign the value or values in *`params`* to the texture parameter specified as *`pname`*. For `glTexParameter`, *`target`* defines the target texture, either `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_TEXTURE_RECTANGLE`. The following symbols are accepted in *`pname`*:\n\n `GL_DEPTH_STENCIL_TEXTURE_MODE`  \nSpecifies the mode used to read from depth-stencil format textures. *`params`* must be one of `GL_DEPTH_COMPONENT` or `GL_STENCIL_INDEX`. If the depth stencil mode is `GL_DEPTH_COMPONENT`, then reads from depth-stencil format textures will return the depth component of the texel in *R*_(*t*) and the stencil component will be discarded. If the depth stencil mode is `GL_STENCIL_INDEX` then the stencil component is returned in *R*_(*t*) and the depth component is discarded. The initial value is `GL_DEPTH_COMPONENT`.\n\n `GL_TEXTURE_BASE_LEVEL`  \nSpecifies the index of the lowest defined mipmap level. This is an integer value. The initial value is 0.\n\n `GL_TEXTURE_BORDER_COLOR`  \nThe data in *`params`* specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of `GL_TEXTURE_BORDER_COLOR` are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of `GL_TEXTURE_BORDER_COLOR` is interpreted as a depth value. The initial value is (0.0, 0.0, 0.0, 0.0).\n\nIf the values for `GL_TEXTURE_BORDER_COLOR` are specified with `glTexParameterIiv` or `glTexParameterIuiv`, the values are stored unmodified with an internal data type of integer. If specified with `glTexParameteriv`, they are converted to floating point with the following equation: $\\mathit{f} = \\frac{2\\mathit{c} + 1}{2^{\\mathit{b}} - 1}$. If specified with `glTexParameterfv`, they are stored unmodified as floating-point values.\n\n `GL_TEXTURE_COMPARE_FUNC`  \nSpecifies the comparison operator used when `GL_TEXTURE_COMPARE_MODE` is set to `GL_COMPARE_REF_TO_TEXTURE`. Permissible values are:\n\n|  **Texture Comparison Function**  |  **Computed result**                          |\n|:----------------------------------|:----------------------------------------------|\n| `GL_LEQUAL`                       | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r}\\<=\\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\> \\mathit{D}\\_{\\mathit{t}}}       \n                                     \\end{matrix}} \\right.$                         |\n| `GL_GEQUAL`                       | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r}\\>=\\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\< \\mathit{D}\\_{\\mathit{t}}}       \n                                     \\end{matrix}} \\right.$                         |\n| `GL_LESS`                         | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\< \\mathit{D}\\_{\\mathit{t}}} \\\\    \n                                     {\\mathit{r}\\>=\\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_GREATER`                      | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\> \\mathit{D}\\_{\\mathit{t}}} \\\\    \n                                     {\\mathit{r}\\<=\\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_EQUAL`                        | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} = \\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\neq \\mathit{D}\\_{\\mathit{t}}}     \n                                     \\end{matrix}} \\right.$                         |\n| `GL_NOTEQUAL`                     | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\neq \\mathit{D}\\_{\\mathit{t}}} \\\\  \n                                     {\\mathit{r} = \\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_ALWAYS`                       | *r**e**s**u**l**t* = 1.0                      |\n| `GL_NEVER`                        | *r**e**s**u**l**t* = 0.0                      |\n\nwhere *r* is the current interpolated texture coordinate, and *D*_(*t*) is the depth texture value sampled from the currently bound depth texture. *r**e**s**u**l**t* is assigned to the red channel.\n\n `GL_TEXTURE_COMPARE_MODE`  \nSpecifies the texture comparison mode for currently bound depth textures. That is, a texture whose internal format is `GL_DEPTH_COMPONENT_*`; see [glTexImage2D](glteximage2d.xhtml)) Permissible values are:\n\n `GL_COMPARE_REF_TO_TEXTURE`  \nSpecifies that the interpolated and clamped *r* texture coordinate should be compared to the value in the currently bound depth texture. See the discussion of `GL_TEXTURE_COMPARE_FUNC` for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.\n\n `GL_NONE`  \nSpecifies that the red channel should be assigned the appropriate value from the currently bound depth texture.\n\n `GL_TEXTURE_LOD_BIAS`  \n*`params`* specifies a fixed bias value that is to be added to the level-of-detail parameter for the texture before texture sampling. The specified value is added to the shader-supplied bias value (if any) and subsequently clamped into the implementation-defined range \\[−*b**i**a**s*_(*max* ), *b**i**a**s*_(*max* )\\], where *b**i**a**s*_(*max* ) is the value of the implementation defined constant `GL_MAX_TEXTURE_LOD_BIAS`. The initial value is 0.0.\n\n `GL_TEXTURE_MIN_FILTER`  \nThe texture minifying function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be minified. There are six defined minifying functions. Two of them use either the nearest texture elements or a weighted average of multiple texture elements to compute the texture value. The other four use mipmaps.\n\nA mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2^(*n*) × 2^(*m*), there are *max* (*n*, *m*) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2^(*n*) × 2^(*m*). Each subsequent mipmap has dimensions 2^(*k* − 1) × 2^(*l* − 1), where 2^(*k*) × 2^(*l*) are the dimensions of the previous mipmap, until either *k* = 0 or *l* = 0. At that point, subsequent mipmaps have dimension 1 × 2^(*l* − 1) or 2^(*k* − 1) × 1 until the final mipmap, which has dimension 1 × 1. To define the mipmaps, call [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), or [glCopyTexImage2D](glcopyteximage2d.xhtml) with the *level* argument indicating the order of the mipmaps. Level 0 is the original texture; level *max* (*n*, *m*) is the final 1 × 1 mipmap.\n\n*`params`* supplies a function for minifying the texture as one of the following:\n\n `GL_NEAREST`  \nReturns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.\n\n `GL_LINEAR`  \nReturns the weighted average of the four texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`, and on the exact mapping.\n\n `GL_NEAREST_MIPMAP_NEAREST`  \nChooses the mipmap that most closely matches the size of the pixel being textured and uses the `GL_NEAREST` criterion (the texture element closest to the specified texture coordinates) to produce a texture value.\n\n `GL_LINEAR_MIPMAP_NEAREST`  \nChooses the mipmap that most closely matches the size of the pixel being textured and uses the `GL_LINEAR` criterion (a weighted average of the four texture elements that are closest to the specified texture coordinates) to produce a texture value.\n\n `GL_NEAREST_MIPMAP_LINEAR`  \nChooses the two mipmaps that most closely match the size of the pixel being textured and uses the `GL_NEAREST` criterion (the texture element closest to the specified texture coordinates ) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.\n\n `GL_LINEAR_MIPMAP_LINEAR`  \nChooses the two mipmaps that most closely match the size of the pixel being textured and uses the `GL_LINEAR` criterion (a weighted average of the texture elements that are closest to the specified texture coordinates) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.\n\nAs more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the `GL_NEAREST` and `GL_LINEAR` minification functions can be faster than the other four, they sample only one or multiple texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of `GL_TEXTURE_MIN_FILTER` is `GL_NEAREST_MIPMAP_LINEAR`.\n\n `GL_TEXTURE_MAG_FILTER`  \nThe texture magnification function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be magified. It sets the texture magnification function to either `GL_NEAREST` or `GL_LINEAR` (see below). `GL_NEAREST` is generally faster than `GL_LINEAR`, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of `GL_TEXTURE_MAG_FILTER` is `GL_LINEAR`.\n\n `GL_NEAREST`  \nReturns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.\n\n `GL_LINEAR`  \nReturns the weighted average of the texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`, and on the exact mapping.\n\n `GL_TEXTURE_MIN_LOD`  \nSets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.\n\n `GL_TEXTURE_MAX_LOD`  \nSets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.\n\n `GL_TEXTURE_MAX_LEVEL`  \nSets the index of the highest defined mipmap level. This is an integer value. The initial value is 1000.\n\n `GL_TEXTURE_SWIZZLE_R`  \nSets the swizzle that will be applied to the *r* component of a texel before it is returned to the shader. Valid values for *`param`* are `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_ZERO` and `GL_ONE`. If `GL_TEXTURE_SWIZZLE_R` is `GL_RED`, the value for *r* will be taken from the first channel of the fetched texel. If `GL_TEXTURE_SWIZZLE_R` is `GL_GREEN`, the value for *r* will be taken from the second channel of the fetched texel. If `GL_TEXTURE_SWIZZLE_R` is `GL_BLUE`, the value for *r* will be taken from the third channel of the fetched texel. If `GL_TEXTURE_SWIZZLE_R` is `GL_ALPHA`, the value for *r* will be taken from the fourth channel of the fetched texel. If `GL_TEXTURE_SWIZZLE_R` is `GL_ZERO`, the value for *r* will be subtituted with 0.0. If `GL_TEXTURE_SWIZZLE_R` is `GL_ONE`, the value for *r* will be subtituted with 1.0. The initial value is `GL_RED`.\n\n `GL_TEXTURE_SWIZZLE_G`  \nSets the swizzle that will be applied to the *g* component of a texel before it is returned to the shader. Valid values for *`param`* and their effects are similar to those of `GL_TEXTURE_SWIZZLE_R`. The initial value is `GL_GREEN`.\n\n `GL_TEXTURE_SWIZZLE_B`  \nSets the swizzle that will be applied to the *b* component of a texel before it is returned to the shader. Valid values for *`param`* and their effects are similar to those of `GL_TEXTURE_SWIZZLE_R`. The initial value is `GL_BLUE`.\n\n `GL_TEXTURE_SWIZZLE_A`  \nSets the swizzle that will be applied to the *a* component of a texel before it is returned to the shader. Valid values for *`param`* and their effects are similar to those of `GL_TEXTURE_SWIZZLE_R`. The initial value is `GL_ALPHA`.\n\n `GL_TEXTURE_SWIZZLE_RGBA`  \nSets the swizzles that will be applied to the *r*, *g*, *b*, and *a* components of a texel before they are returned to the shader. Valid values for *`params`* and their effects are similar to those of `GL_TEXTURE_SWIZZLE_R`, except that all channels are specified simultaneously. Setting the value of `GL_TEXTURE_SWIZZLE_RGBA` is equivalent (assuming no errors are generated) to setting the parameters of each of `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, and `GL_TEXTURE_SWIZZLE_A` successively.\n\n `GL_TEXTURE_WRAP_S`  \nSets the wrap parameter for texture coordinate *s* to either `GL_CLAMP_TO_EDGE`, `GL_CLAMP_TO_BORDER`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. `GL_CLAMP_TO_EDGE` causes *s* coordinates to be clamped to the range $\\left\\lbrack {\\frac{1}{2\\mathit{N}},{1 - \\frac{1}{2\\mathit{N}}}} \\right\\rbrack$, where *N* is the size of the texture in the direction of clamping. `GL_CLAMP_TO_BORDER` evaluates *s* coordinates in a similar manner to `GL_CLAMP_TO_EDGE`. However, in cases where clamping would have occurred in `GL_CLAMP_TO_EDGE` mode, the fetched texel data is substituted with the values specified by `GL_TEXTURE_BORDER_COLOR`. `GL_REPEAT` causes the integer part of the *s* coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. `GL_MIRRORED_REPEAT` causes the *s* coordinate to be set to the fractional part of the texture coordinate if the integer part of *s* is even; if the integer part of *s* is odd, then the *s* texture coordinate is set to 1 − *f**r**a**c*(*s*), where *f**r**a**c*(*s*) represents the fractional part of *s*. `GL_MIRROR_CLAMP_TO_EDGE` causes the *s* coordinate to be repeated as for `GL_MIRRORED_REPEAT` for one repetition of the texture, at which point the coordinate to be clamped as in `GL_CLAMP_TO_EDGE`. Initially, `GL_TEXTURE_WRAP_S` is set to `GL_REPEAT`.\n\n `GL_TEXTURE_WRAP_T`  \nSets the wrap parameter for texture coordinate *t* to either `GL_CLAMP_TO_EDGE`, `GL_CLAMP_TO_BORDER`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. See the discussion under `GL_TEXTURE_WRAP_S`. Initially, `GL_TEXTURE_WRAP_T` is set to `GL_REPEAT`.\n\n `GL_TEXTURE_WRAP_R`  \nSets the wrap parameter for texture coordinate *r* to either `GL_CLAMP_TO_EDGE`, `GL_CLAMP_TO_BORDER`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. See the discussion under `GL_TEXTURE_WRAP_S`. Initially, `GL_TEXTURE_WRAP_R` is set to `GL_REPEAT`.\n\n## Notes\n\nSuppose that a program attempts to sample from a texture and has set `GL_TEXTURE_MIN_FILTER` to one of the functions that requires a mipmap. If either the dimensions of the texture images currently defined (with previous calls to [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), or [glCopyTexImage2D](glcopyteximage2d.xhtml)) do not follow the proper sequence for mipmaps (described above), or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then the texture is considered *incomplete*.\n\nLinear filtering accesses the four nearest texture elements only in 2D textures. In 1D textures, linear filtering accesses the two nearest texture elements. In 3D textures, linear filtering accesses the eight nearest texture elements.\n\n`glTexParameter` specifies the texture parameters for the active texture unit, specified by calling [glActiveTexture](glactivetexture.xhtml). `glTextureParameter` specifies the texture parameters for the texture object with ID *`texture`*.\n\n`GL_DEPTH_STENCIL_TEXTURE_MODE` is available only if the GL version is 4.3 or greater.\n\n`GL_MIRROR_CLAMP_TO_EDGE` is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glTexParameter` if *`target`* is not one of the accepted defined values.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted defined values.\n\n`GL_INVALID_ENUM` is generated if *`params`* should have a defined constant value (based on the value of *`pname`*) and does not.\n\n`GL_INVALID_ENUM` is generated if `glTexParameter{if}` or `glTextureParameter{if}` is called for a non-scalar parameter (pname `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`).\n\n`GL_INVALID_ENUM` is generated if the effective target is either `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, and *`pname`* is any of the sampler states.\n\n`GL_INVALID_ENUM` is generated if the effective target is `GL_TEXTURE_RECTANGLE` and either of pnames `GL_TEXTURE_WRAP_S` or `GL_TEXTURE_WRAP_T` is set to either `GL_MIRROR_CLAMP_TO_EDGE`, `GL_MIRRORED_REPEAT` or `GL_REPEAT`.\n\n`GL_INVALID_ENUM` is generated if the effective target is `GL_TEXTURE_RECTANGLE` and pname `GL_TEXTURE_MIN_FILTER` is set to a value other than `GL_NEAREST` or `GL_LINEAR` (no mipmap filtering is permitted).\n\n`GL_INVALID_OPERATION` is generated if the effective target is either `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, and pname `GL_TEXTURE_BASE_LEVEL` is set to a value other than zero.\n\n`GL_INVALID_OPERATION` is generated by `glTextureParameter` if texture is not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated if the effective target is `GL_TEXTURE_RECTANGLE` and pname `GL_TEXTURE_BASE_LEVEL` is set to any value other than zero.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_TEXTURE_BASE_LEVEL` or `GL_TEXTURE_MAX_LEVEL`, and *`param`* or *`params`* is negative.\n\n## Associated Gets\n\n[ glGetTexParameter ](glgettexparameter.xhtml)\n\n`glGetTextureParameter`\n\n[ glGetTexLevelParameter ](glgettexlevelparameter.xhtml)\n\n`glGetTextureLevelParameter`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexParameterIiv`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTexParameterIuiv`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTexParameterf`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTexParameterfv`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTexParameteri`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTexParameteriv`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTextureParameterIiv`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glTextureParameterIuiv`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glTextureParameterf`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glTextureParameterfv`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glTextureParameteri`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glTextureParameteriv`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glBindTexture](glbindtexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glSamplerParameter](glsamplerparameter.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexParameter.xhtml)"
- name: glTexParameterf
  id: gltexparameter.xhtml#glTexParameterf
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTexParameterf`**`(` GLenum `target`, GLenum `pname`, GLfloat `param``)`;'
- name: glTexParameterfv
  id: gltexparameter.xhtml#glTexParameterfv
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTexParameterfv`**`(` GLenum `target`, GLenum `pname`, const GLfloat \* `params``)`;'
- name: glTexParameteri
  id: gltexparameter.xhtml#glTexParameteri
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTexParameteri`**`(` GLenum `target`, GLenum `pname`, GLint `param``)`;'
- name: glTexParameterIiv
  id: gltexparameter.xhtml#glTexParameterIiv
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTexParameterIiv`**`(` GLenum `target`, GLenum `pname`, const GLint \* `params``)`;'
- name: glTexParameterIuiv
  id: gltexparameter.xhtml#glTexParameterIuiv
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTexParameterIuiv`**`(` GLenum `target`, GLenum `pname`, const GLuint \* `params``)`;'
- name: glTexParameteriv
  id: gltexparameter.xhtml#glTexParameteriv
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTexParameteriv`**`(` GLenum `target`, GLenum `pname`, const GLint \* `params``)`;'
- name: glTexStorage1D
  id: gltexstorage1d.xhtml
  summary: target Specifies the target to which the texture object is bound for glTexStorage1D
  description: "## Name\n\nglTexStorage1D, glTextureStorage1D — simultaneously specify storage for all levels of a one-dimensional texture\n\n## C Specification\n\n`void `**`glTexStorage1D`**`(` GLenum `target`, GLsizei `levels`, GLenum `internalformat`, GLsizei `width``)`;\n\n`void `**`glTextureStorage1D`**`(` GLuint `texture`, GLsizei `levels`, GLenum `internalformat`, GLsizei `width``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glTexStorage1D`. Must be one of `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureStorage1D`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n *`levels`*  \nSpecify the number of texture levels.\n\n *`internalformat`*  \nSpecifies the sized internal format to be used to store texture image data.\n\n *`width`*  \nSpecifies the width of the texture, in texels.\n\n## Description\n\n`glTexStorage1D` and `glTextureStorage1D` specify the storage requirements for all levels of a one-dimensional texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\nCalling `glTexStorage1D` is equivalent, assuming no errors are generated, to executing the following pseudo-code:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage1D(target, i, internalformat, width, 0, format, type, NULL);\n        width = max(1, (width / 2));\n    }\n```\n\nCalling `glTextureStorage1D` is equivalent to the above pseudo-code, where *`target`* is the effective target of *`texture`* and it is as if *`texture`* were bound to *`target`* for the purposes of `glTexImage1D`.\n\nSince no texture data is actually provided, the values used in the pseudo-code for *`format`* and *`type`* are irrelevant and may be considered to be any values that are legal for the chosen *`internalformat`* enumerant. *`internalformat`* must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats, `GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format, `GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`. The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling [glGetTexParameter](glgettexparameter.xhtml) with *`pname`* set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as [glTexImage1D](glteximage1d.xhtml) or another call to `glTexStorage1D`) will result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter the dimensions or format of the object.\n\nTable 1. Sized Internal Formats\n\n| **Sized Internal Format** | **Base Internal Format** | **Red Bits** | **Green Bits** | **Blue Bits** | **Alpha Bits** | **Shared Bits** |\n|:--------------------------|:-------------------------|:------------:|:--------------:|:-------------:|:--------------:|:---------------:|\n| `GL_R8`                   | `GL_RED`                 |      8       |                |               |                |                 |\n| `GL_R8_SNORM`             | `GL_RED`                 |      s8      |                |               |                |                 |\n| `GL_R16`                  | `GL_RED`                 |      16      |                |               |                |                 |\n| `GL_R16_SNORM`            | `GL_RED`                 |     s16      |                |               |                |                 |\n| `GL_RG8`                  | `GL_RG`                  |      8       |       8        |               |                |                 |\n| `GL_RG8_SNORM`            | `GL_RG`                  |      s8      |       s8       |               |                |                 |\n| `GL_RG16`                 | `GL_RG`                  |      16      |       16       |               |                |                 |\n| `GL_RG16_SNORM`           | `GL_RG`                  |     s16      |      s16       |               |                |                 |\n| `GL_R3_G3_B2`             | `GL_RGB`                 |      3       |       3        |       2       |                |                 |\n| `GL_RGB4`                 | `GL_RGB`                 |      4       |       4        |       4       |                |                 |\n| `GL_RGB5`                 | `GL_RGB`                 |      5       |       5        |       5       |                |                 |\n| `GL_RGB8`                 | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_RGB8_SNORM`           | `GL_RGB`                 |      s8      |       s8       |      s8       |                |                 |\n| `GL_RGB10`                | `GL_RGB`                 |      10      |       10       |      10       |                |                 |\n| `GL_RGB12`                | `GL_RGB`                 |      12      |       12       |      12       |                |                 |\n| `GL_RGB16_SNORM`          | `GL_RGB`                 |      16      |       16       |      16       |                |                 |\n| `GL_RGBA2`                | `GL_RGB`                 |      2       |       2        |       2       |       2        |                 |\n| `GL_RGBA4`                | `GL_RGB`                 |      4       |       4        |       4       |       4        |                 |\n| `GL_RGB5_A1`              | `GL_RGBA`                |      5       |       5        |       5       |       1        |                 |\n| `GL_RGBA8`                | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_RGBA8_SNORM`          | `GL_RGBA`                |      s8      |       s8       |      s8       |       s8       |                 |\n| `GL_RGB10_A2`             | `GL_RGBA`                |      10      |       10       |      10       |       2        |                 |\n| `GL_RGB10_A2UI`           | `GL_RGBA`                |     ui10     |      ui10      |     ui10      |      ui2       |                 |\n| `GL_RGBA12`               | `GL_RGBA`                |      12      |       12       |      12       |       12       |                 |\n| `GL_RGBA16`               | `GL_RGBA`                |      16      |       16       |      16       |       16       |                 |\n| `GL_SRGB8`                | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_SRGB8_ALPHA8`         | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_R16F`                 | `GL_RED`                 |     f16      |                |               |                |                 |\n| `GL_RG16F`                | `GL_RG`                  |     f16      |      f16       |               |                |                 |\n| `GL_RGB16F`               | `GL_RGB`                 |     f16      |      f16       |      f16      |                |                 |\n| `GL_RGBA16F`              | `GL_RGBA`                |     f16      |      f16       |      f16      |      f16       |                 |\n| `GL_R32F`                 | `GL_RED`                 |     f32      |                |               |                |                 |\n| `GL_RG32F`                | `GL_RG`                  |     f32      |      f32       |               |                |                 |\n| `GL_RGB32F`               | `GL_RGB`                 |     f32      |      f32       |      f32      |                |                 |\n| `GL_RGBA32F`              | `GL_RGBA`                |     f32      |      f32       |      f32      |      f32       |                 |\n| `GL_R11F_G11F_B10F`       | `GL_RGB`                 |     f11      |      f11       |      f10      |                |                 |\n| `GL_RGB9_E5`              | `GL_RGB`                 |      9       |       9        |       9       |                |        5        |\n| `GL_R8I`                  | `GL_RED`                 |      i8      |                |               |                |                 |\n| `GL_R8UI`                 | `GL_RED`                 |     ui8      |                |               |                |                 |\n| `GL_R16I`                 | `GL_RED`                 |     i16      |                |               |                |                 |\n| `GL_R16UI`                | `GL_RED`                 |     ui16     |                |               |                |                 |\n| `GL_R32I`                 | `GL_RED`                 |     i32      |                |               |                |                 |\n| `GL_R32UI`                | `GL_RED`                 |     ui32     |                |               |                |                 |\n| `GL_RG8I`                 | `GL_RG`                  |      i8      |       i8       |               |                |                 |\n| `GL_RG8UI`                | `GL_RG`                  |     ui8      |      ui8       |               |                |                 |\n| `GL_RG16I`                | `GL_RG`                  |     i16      |      i16       |               |                |                 |\n| `GL_RG16UI`               | `GL_RG`                  |     ui16     |      ui16      |               |                |                 |\n| `GL_RG32I`                | `GL_RG`                  |     i32      |      i32       |               |                |                 |\n| `GL_RG32UI`               | `GL_RG`                  |     ui32     |      ui32      |               |                |                 |\n| `GL_RGB8I`                | `GL_RGB`                 |      i8      |       i8       |      i8       |                |                 |\n| `GL_RGB8UI`               | `GL_RGB`                 |     ui8      |      ui8       |      ui8      |                |                 |\n| `GL_RGB16I`               | `GL_RGB`                 |     i16      |      i16       |      i16      |                |                 |\n| `GL_RGB16UI`              | `GL_RGB`                 |     ui16     |      ui16      |     ui16      |                |                 |\n| `GL_RGB32I`               | `GL_RGB`                 |     i32      |      i32       |      i32      |                |                 |\n| `GL_RGB32UI`              | `GL_RGB`                 |     ui32     |      ui32      |     ui32      |                |                 |\n| `GL_RGBA8I`               | `GL_RGBA`                |      i8      |       i8       |      i8       |       i8       |                 |\n| `GL_RGBA8UI`              | `GL_RGBA`                |     ui8      |      ui8       |      ui8      |      ui8       |                 |\n| `GL_RGBA16I`              | `GL_RGBA`                |     i16      |      i16       |      i16      |      i16       |                 |\n| `GL_RGBA16UI`             | `GL_RGBA`                |     ui16     |      ui16      |     ui16      |      ui16      |                 |\n| `GL_RGBA32I`              | `GL_RGBA`                |     i32      |      i32       |      i32      |      i32       |                 |\n| `GL_RGBA32UI`             | `GL_RGBA`                |     ui32     |      ui32      |     ui32      |      ui32      |                 |\n\n  \n\n## Notes\n\n`GL_STENCIL_INDEX8` is accepted for *`internalformat`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage1D` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage1D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid sized internal format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`* or *`levels`* are less than 1.\n\n`GL_INVALID_OPERATION` is generated if *`levels`* is greater than ⌊log₂(*w**i**d**t**h*)⌋ + 1.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexStorage1D`            |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTextureStorage1D`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glTexImage1D](glteximage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml).\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage1D.xhtml)"
- name: glTexStorage2D
  id: gltexstorage2d.xhtml
  summary: target Specifies the target to which the texture object is bound for glTexStorage2D
  description: "## Name\n\nglTexStorage2D, glTextureStorage2D — simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture\n\n## C Specification\n\n`void `**`glTexStorage2D`**`(` GLenum `target`, GLsizei `levels`, GLenum `internalformat`, GLsizei `width`, GLsizei `height``)`;\n\n`void `**`glTextureStorage2D`**`(` GLuint `texture`, GLsizei `levels`, GLenum `internalformat`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glTexStorage2D`. Must be one of `GL_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, or `GL_PROXY_TEXTURE_CUBE_MAP`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureStorage2D`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n *`levels`*  \nSpecify the number of texture levels.\n\n *`internalformat`*  \nSpecifies the sized internal format to be used to store texture image data.\n\n *`width`*  \nSpecifies the width of the texture, in texels.\n\n *`height`*  \nSpecifies the height of the texture, in texels.\n\n## Description\n\n`glTexStorage2D` and `glTextureStorage2D` specify the storage requirements for all levels of a two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\nThe behavior of `glTexStorage2D` depends on the *`target`* parameter. When *`target`* is `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_CUBE_MAP`, calling `glTexStorage2D` is equivalent, assuming no errors are generated, to executing the following pseudo-code:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);\n        width = max(1, (width / 2));\n        height = max(1, (height / 2));\n    }\n```\n\nWhen *`target`* is `GL_TEXTURE_CUBE_MAP`, `glTexStorage2D` is equivalent to:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        for (face in (+X, -X, +Y, -Y, +Z, -Z)) {\n            glTexImage2D(face, i, internalformat, width, height, 0, format, type, NULL);\n        }\n        width = max(1, (width / 2));\n        height = max(1, (height / 2));\n    }\n```\n\nWhen *`target`* is `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY`, `glTexStorage2D` is equivalent to:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);\n        width = max(1, (width / 2));\n    }\n```\n\nCalling `glTextureStorage2D` is equivalent to the above pseudo-code, where *`target`* is the effective target of *`texture`* and it is as if *`texture`* were bound to *`target`* for the purposes of `glTexImage2D`.\n\nSince no texture data is actually provided, the values used in the pseudo-code for *`format`* and *`type`* are irrelevant and may be considered to be any values that are legal for the chosen *`internalformat`* enumerant. *`internalformat`* must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats, `GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format, `GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`. The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling [glGetTexParameter](glgettexparameter.xhtml) with *`pname`* set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as [glTexImage2D](glteximage2d.xhtml) or another call to `glTexStorage2D`) will result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter the dimensions or format of the object.\n\nTable 1. Sized Internal Formats\n\n| **Sized Internal Format** | **Base Internal Format** | **Red Bits** | **Green Bits** | **Blue Bits** | **Alpha Bits** | **Shared Bits** |\n|:--------------------------|:-------------------------|:------------:|:--------------:|:-------------:|:--------------:|:---------------:|\n| `GL_R8`                   | `GL_RED`                 |      8       |                |               |                |                 |\n| `GL_R8_SNORM`             | `GL_RED`                 |      s8      |                |               |                |                 |\n| `GL_R16`                  | `GL_RED`                 |      16      |                |               |                |                 |\n| `GL_R16_SNORM`            | `GL_RED`                 |     s16      |                |               |                |                 |\n| `GL_RG8`                  | `GL_RG`                  |      8       |       8        |               |                |                 |\n| `GL_RG8_SNORM`            | `GL_RG`                  |      s8      |       s8       |               |                |                 |\n| `GL_RG16`                 | `GL_RG`                  |      16      |       16       |               |                |                 |\n| `GL_RG16_SNORM`           | `GL_RG`                  |     s16      |      s16       |               |                |                 |\n| `GL_R3_G3_B2`             | `GL_RGB`                 |      3       |       3        |       2       |                |                 |\n| `GL_RGB4`                 | `GL_RGB`                 |      4       |       4        |       4       |                |                 |\n| `GL_RGB5`                 | `GL_RGB`                 |      5       |       5        |       5       |                |                 |\n| `GL_RGB8`                 | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_RGB8_SNORM`           | `GL_RGB`                 |      s8      |       s8       |      s8       |                |                 |\n| `GL_RGB10`                | `GL_RGB`                 |      10      |       10       |      10       |                |                 |\n| `GL_RGB12`                | `GL_RGB`                 |      12      |       12       |      12       |                |                 |\n| `GL_RGB16_SNORM`          | `GL_RGB`                 |      16      |       16       |      16       |                |                 |\n| `GL_RGBA2`                | `GL_RGB`                 |      2       |       2        |       2       |       2        |                 |\n| `GL_RGBA4`                | `GL_RGB`                 |      4       |       4        |       4       |       4        |                 |\n| `GL_RGB5_A1`              | `GL_RGBA`                |      5       |       5        |       5       |       1        |                 |\n| `GL_RGBA8`                | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_RGBA8_SNORM`          | `GL_RGBA`                |      s8      |       s8       |      s8       |       s8       |                 |\n| `GL_RGB10_A2`             | `GL_RGBA`                |      10      |       10       |      10       |       2        |                 |\n| `GL_RGB10_A2UI`           | `GL_RGBA`                |     ui10     |      ui10      |     ui10      |      ui2       |                 |\n| `GL_RGBA12`               | `GL_RGBA`                |      12      |       12       |      12       |       12       |                 |\n| `GL_RGBA16`               | `GL_RGBA`                |      16      |       16       |      16       |       16       |                 |\n| `GL_SRGB8`                | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_SRGB8_ALPHA8`         | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_R16F`                 | `GL_RED`                 |     f16      |                |               |                |                 |\n| `GL_RG16F`                | `GL_RG`                  |     f16      |      f16       |               |                |                 |\n| `GL_RGB16F`               | `GL_RGB`                 |     f16      |      f16       |      f16      |                |                 |\n| `GL_RGBA16F`              | `GL_RGBA`                |     f16      |      f16       |      f16      |      f16       |                 |\n| `GL_R32F`                 | `GL_RED`                 |     f32      |                |               |                |                 |\n| `GL_RG32F`                | `GL_RG`                  |     f32      |      f32       |               |                |                 |\n| `GL_RGB32F`               | `GL_RGB`                 |     f32      |      f32       |      f32      |                |                 |\n| `GL_RGBA32F`              | `GL_RGBA`                |     f32      |      f32       |      f32      |      f32       |                 |\n| `GL_R11F_G11F_B10F`       | `GL_RGB`                 |     f11      |      f11       |      f10      |                |                 |\n| `GL_RGB9_E5`              | `GL_RGB`                 |      9       |       9        |       9       |                |        5        |\n| `GL_R8I`                  | `GL_RED`                 |      i8      |                |               |                |                 |\n| `GL_R8UI`                 | `GL_RED`                 |     ui8      |                |               |                |                 |\n| `GL_R16I`                 | `GL_RED`                 |     i16      |                |               |                |                 |\n| `GL_R16UI`                | `GL_RED`                 |     ui16     |                |               |                |                 |\n| `GL_R32I`                 | `GL_RED`                 |     i32      |                |               |                |                 |\n| `GL_R32UI`                | `GL_RED`                 |     ui32     |                |               |                |                 |\n| `GL_RG8I`                 | `GL_RG`                  |      i8      |       i8       |               |                |                 |\n| `GL_RG8UI`                | `GL_RG`                  |     ui8      |      ui8       |               |                |                 |\n| `GL_RG16I`                | `GL_RG`                  |     i16      |      i16       |               |                |                 |\n| `GL_RG16UI`               | `GL_RG`                  |     ui16     |      ui16      |               |                |                 |\n| `GL_RG32I`                | `GL_RG`                  |     i32      |      i32       |               |                |                 |\n| `GL_RG32UI`               | `GL_RG`                  |     ui32     |      ui32      |               |                |                 |\n| `GL_RGB8I`                | `GL_RGB`                 |      i8      |       i8       |      i8       |                |                 |\n| `GL_RGB8UI`               | `GL_RGB`                 |     ui8      |      ui8       |      ui8      |                |                 |\n| `GL_RGB16I`               | `GL_RGB`                 |     i16      |      i16       |      i16      |                |                 |\n| `GL_RGB16UI`              | `GL_RGB`                 |     ui16     |      ui16      |     ui16      |                |                 |\n| `GL_RGB32I`               | `GL_RGB`                 |     i32      |      i32       |      i32      |                |                 |\n| `GL_RGB32UI`              | `GL_RGB`                 |     ui32     |      ui32      |     ui32      |                |                 |\n| `GL_RGBA8I`               | `GL_RGBA`                |      i8      |       i8       |      i8       |       i8       |                 |\n| `GL_RGBA8UI`              | `GL_RGBA`                |     ui8      |      ui8       |      ui8      |      ui8       |                 |\n| `GL_RGBA16I`              | `GL_RGBA`                |     i16      |      i16       |      i16      |      i16       |                 |\n| `GL_RGBA16UI`             | `GL_RGBA`                |     ui16     |      ui16      |     ui16      |      ui16      |                 |\n| `GL_RGBA32I`              | `GL_RGBA`                |     i32      |      i32       |      i32      |      i32       |                 |\n| `GL_RGBA32UI`             | `GL_RGBA`                |     ui32     |      ui32      |     ui32      |      ui32      |                 |\n\n  \n\n## Notes\n\n`GL_STENCIL_INDEX8` is accepted for *`internalformat`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage2D` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage2D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid sized internal format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`*, *`height`* or *`levels`* are less than 1.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and *`levels`* is greater than ⌊log₂(*w**i**d**t**h*)⌋ + 1.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is not `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and *`levels`* is greater than ⌊log₂(max (*w**i**d**t**h*, *h**e**i**g**h**t*))⌋ + 1.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexStorage2D`            |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTextureStorage2D`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glTexImage2D](glteximage2d.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml).\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage2D.xhtml)"
- name: glTexStorage2DMultisample
  id: gltexstorage2dmultisample.xhtml
  summary: target Specifies the target to which the texture object is bound for glTexStorage2DMultisample
  description: "## Name\n\nglTexStorage2DMultisample, glTextureStorage2DMultisample — specify storage for a two-dimensional multisample texture\n\n## C Specification\n\n`void `**`glTexStorage2DMultisample`**`(` GLenum `target`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLboolean `fixedsamplelocations``)`;\n\n`void `**`glTextureStorage2DMultisample`**`(` GLuint `texture`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLboolean `fixedsamplelocations``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glTexStorage2DMultisample`. Must be one of `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureStorage2DMultisample`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n *`samples`*  \nSpecify the number of samples in the texture.\n\n *`internalformat`*  \nSpecifies the sized internal format to be used to store texture image data.\n\n *`width`*  \nSpecifies the width of the texture, in texels.\n\n *`height`*  \nSpecifies the height of the texture, in texels.\n\n *`fixedsamplelocations`*  \nSpecifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\n## Description\n\n`glTexStorage2DMultisample` and `glTextureStorage2DMultisample` specify the storage requirements for a two-dimensional multisample texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\n*`samples`* specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of `GL_MAX_SAMPLES`. *`internalformat`* must be a color-renderable, depth-renderable, or stencil-renderable format. *`width`* and *`height`* specify the width and height, respectively, of the texture. If *`fixedsamplelocations`* is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\nTable 1. Sized Internal Formats\n\n| **Sized Internal Format** | **Base Internal Format** | **Red Bits** | **Green Bits** | **Blue Bits** | **Alpha Bits** | **Shared Bits** |\n|:--------------------------|:-------------------------|:------------:|:--------------:|:-------------:|:--------------:|:---------------:|\n| `GL_R8`                   | `GL_RED`                 |      8       |                |               |                |                 |\n| `GL_R8_SNORM`             | `GL_RED`                 |      s8      |                |               |                |                 |\n| `GL_R16`                  | `GL_RED`                 |      16      |                |               |                |                 |\n| `GL_R16_SNORM`            | `GL_RED`                 |     s16      |                |               |                |                 |\n| `GL_RG8`                  | `GL_RG`                  |      8       |       8        |               |                |                 |\n| `GL_RG8_SNORM`            | `GL_RG`                  |      s8      |       s8       |               |                |                 |\n| `GL_RG16`                 | `GL_RG`                  |      16      |       16       |               |                |                 |\n| `GL_RG16_SNORM`           | `GL_RG`                  |     s16      |      s16       |               |                |                 |\n| `GL_R3_G3_B2`             | `GL_RGB`                 |      3       |       3        |       2       |                |                 |\n| `GL_RGB4`                 | `GL_RGB`                 |      4       |       4        |       4       |                |                 |\n| `GL_RGB5`                 | `GL_RGB`                 |      5       |       5        |       5       |                |                 |\n| `GL_RGB8`                 | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_RGB8_SNORM`           | `GL_RGB`                 |      s8      |       s8       |      s8       |                |                 |\n| `GL_RGB10`                | `GL_RGB`                 |      10      |       10       |      10       |                |                 |\n| `GL_RGB12`                | `GL_RGB`                 |      12      |       12       |      12       |                |                 |\n| `GL_RGB16_SNORM`          | `GL_RGB`                 |      16      |       16       |      16       |                |                 |\n| `GL_RGBA2`                | `GL_RGB`                 |      2       |       2        |       2       |       2        |                 |\n| `GL_RGBA4`                | `GL_RGB`                 |      4       |       4        |       4       |       4        |                 |\n| `GL_RGB5_A1`              | `GL_RGBA`                |      5       |       5        |       5       |       1        |                 |\n| `GL_RGBA8`                | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_RGBA8_SNORM`          | `GL_RGBA`                |      s8      |       s8       |      s8       |       s8       |                 |\n| `GL_RGB10_A2`             | `GL_RGBA`                |      10      |       10       |      10       |       2        |                 |\n| `GL_RGB10_A2UI`           | `GL_RGBA`                |     ui10     |      ui10      |     ui10      |      ui2       |                 |\n| `GL_RGBA12`               | `GL_RGBA`                |      12      |       12       |      12       |       12       |                 |\n| `GL_RGBA16`               | `GL_RGBA`                |      16      |       16       |      16       |       16       |                 |\n| `GL_SRGB8`                | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_SRGB8_ALPHA8`         | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_R16F`                 | `GL_RED`                 |     f16      |                |               |                |                 |\n| `GL_RG16F`                | `GL_RG`                  |     f16      |      f16       |               |                |                 |\n| `GL_RGB16F`               | `GL_RGB`                 |     f16      |      f16       |      f16      |                |                 |\n| `GL_RGBA16F`              | `GL_RGBA`                |     f16      |      f16       |      f16      |      f16       |                 |\n| `GL_R32F`                 | `GL_RED`                 |     f32      |                |               |                |                 |\n| `GL_RG32F`                | `GL_RG`                  |     f32      |      f32       |               |                |                 |\n| `GL_RGB32F`               | `GL_RGB`                 |     f32      |      f32       |      f32      |                |                 |\n| `GL_RGBA32F`              | `GL_RGBA`                |     f32      |      f32       |      f32      |      f32       |                 |\n| `GL_R11F_G11F_B10F`       | `GL_RGB`                 |     f11      |      f11       |      f10      |                |                 |\n| `GL_RGB9_E5`              | `GL_RGB`                 |      9       |       9        |       9       |                |        5        |\n| `GL_R8I`                  | `GL_RED`                 |      i8      |                |               |                |                 |\n| `GL_R8UI`                 | `GL_RED`                 |     ui8      |                |               |                |                 |\n| `GL_R16I`                 | `GL_RED`                 |     i16      |                |               |                |                 |\n| `GL_R16UI`                | `GL_RED`                 |     ui16     |                |               |                |                 |\n| `GL_R32I`                 | `GL_RED`                 |     i32      |                |               |                |                 |\n| `GL_R32UI`                | `GL_RED`                 |     ui32     |                |               |                |                 |\n| `GL_RG8I`                 | `GL_RG`                  |      i8      |       i8       |               |                |                 |\n| `GL_RG8UI`                | `GL_RG`                  |     ui8      |      ui8       |               |                |                 |\n| `GL_RG16I`                | `GL_RG`                  |     i16      |      i16       |               |                |                 |\n| `GL_RG16UI`               | `GL_RG`                  |     ui16     |      ui16      |               |                |                 |\n| `GL_RG32I`                | `GL_RG`                  |     i32      |      i32       |               |                |                 |\n| `GL_RG32UI`               | `GL_RG`                  |     ui32     |      ui32      |               |                |                 |\n| `GL_RGB8I`                | `GL_RGB`                 |      i8      |       i8       |      i8       |                |                 |\n| `GL_RGB8UI`               | `GL_RGB`                 |     ui8      |      ui8       |      ui8      |                |                 |\n| `GL_RGB16I`               | `GL_RGB`                 |     i16      |      i16       |      i16      |                |                 |\n| `GL_RGB16UI`              | `GL_RGB`                 |     ui16     |      ui16      |     ui16      |                |                 |\n| `GL_RGB32I`               | `GL_RGB`                 |     i32      |      i32       |      i32      |                |                 |\n| `GL_RGB32UI`              | `GL_RGB`                 |     ui32     |      ui32      |     ui32      |                |                 |\n| `GL_RGBA8I`               | `GL_RGBA`                |      i8      |       i8       |      i8       |       i8       |                 |\n| `GL_RGBA8UI`              | `GL_RGBA`                |     ui8      |      ui8       |      ui8      |      ui8       |                 |\n| `GL_RGBA16I`              | `GL_RGBA`                |     i16      |      i16       |      i16      |      i16       |                 |\n| `GL_RGBA16UI`             | `GL_RGBA`                |     ui16     |      ui16      |     ui16      |      ui16      |                 |\n| `GL_RGBA32I`              | `GL_RGBA`                |     i32      |      i32       |      i32      |      i32       |                 |\n| `GL_RGBA32UI`             | `GL_RGBA`                |     ui32     |      ui32      |     ui32      |      ui32      |                 |\n\n  \n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage2DMultisample` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage2DMultisample` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid color-renderable, depth-renderable or stencil-renderable format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`* or *`height`* are less than 1 or greater than the value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`levels`* is less than 1.\n\n`GL_INVALID_VALUE` is generated if *`samples`* is zero.\n\n`GL_INVALID_OPERATION` is generated if *`samples`* is greater than the maximum number of samples supported for this *`target`* and *`internalformat`*.\n\n`GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for the texture bound to *`target`* is not `GL_FALSE`.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexStorage2DMultisample`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glTextureStorage2DMultisample` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glTexImage2D](glteximage2d.xhtml), [glTexImage2DMultisample](glteximage2dmultisample.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage2DMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage2DMultisample.xhtml)"
- name: glTexStorage3D
  id: gltexstorage3d.xhtml
  summary: target Specifies the target to which the texture object is bound for glTexStorage3D
  description: "## Name\n\nglTexStorage3D, glTextureStorage3D — simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture\n\n## C Specification\n\n`void `**`glTexStorage3D`**`(` GLenum `target`, GLsizei `levels`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLsizei `depth``)`;\n\n`void `**`glTextureStorage3D`**`(` GLuint `texture`, GLsizei `levels`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLsizei `depth``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glTexStorage3D`. Must be one of `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_PROXY_TEXTURE_3D`, `GL_PROXY_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureStorage3D`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n *`levels`*  \nSpecify the number of texture levels.\n\n *`internalformat`*  \nSpecifies the sized internal format to be used to store texture image data.\n\n *`width`*  \nSpecifies the width of the texture, in texels.\n\n *`height`*  \nSpecifies the height of the texture, in texels.\n\n *`depth`*  \nSpecifies the depth of the texture, in texels.\n\n## Description\n\n`glTexStorage3D` and `glTextureStorage3D` specify the storage requirements for all levels of a three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\nThe behavior of `glTexStorage3D` depends on the *`target`* parameter. When *`target`* is `GL_TEXTURE_3D`, or `GL_PROXY_TEXTURE_3D`, calling `glTexStorage3D` is equivalent, assuming no errors are generated, to executing the following pseudo-code:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);\n        width = max(1, (width / 2));\n        height = max(1, (height / 2));\n        depth = max(1, (depth / 2));\n    }\n```\n\nWhen *`target`* is `GL_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`, `glTexStorage3D` is equivalent to:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);\n        width = max(1, (width / 2));\n        height = max(1, (height / 2));\n    }\n```\n\nCalling `glTextureStorage3D` is equivalent to the above pseudo-code, where *`target`* is the effective target of *`texture`* and it is as if *`texture`* were bound to *`target`* for the purposes of `glTexImage3D`.\n\nSince no texture data is actually provided, the values used in the pseudo-code for *`format`* and *`type`* are irrelevant and may be considered to be any values that are legal for the chosen *`internalformat`* enumerant. *`internalformat`* must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats, `GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format, `GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`. The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling [glGetTexParameter](glgettexparameter.xhtml) with *`pname`* set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as [glTexImage3D](glteximage3d.xhtml) or another call to `glTexStorage3D`) will result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter the dimensions or format of the object.\n\nTable 1. Sized Internal Formats\n\n| **Sized Internal Format** | **Base Internal Format** | **Red Bits** | **Green Bits** | **Blue Bits** | **Alpha Bits** | **Shared Bits** |\n|:--------------------------|:-------------------------|:------------:|:--------------:|:-------------:|:--------------:|:---------------:|\n| `GL_R8`                   | `GL_RED`                 |      8       |                |               |                |                 |\n| `GL_R8_SNORM`             | `GL_RED`                 |      s8      |                |               |                |                 |\n| `GL_R16`                  | `GL_RED`                 |      16      |                |               |                |                 |\n| `GL_R16_SNORM`            | `GL_RED`                 |     s16      |                |               |                |                 |\n| `GL_RG8`                  | `GL_RG`                  |      8       |       8        |               |                |                 |\n| `GL_RG8_SNORM`            | `GL_RG`                  |      s8      |       s8       |               |                |                 |\n| `GL_RG16`                 | `GL_RG`                  |      16      |       16       |               |                |                 |\n| `GL_RG16_SNORM`           | `GL_RG`                  |     s16      |      s16       |               |                |                 |\n| `GL_R3_G3_B2`             | `GL_RGB`                 |      3       |       3        |       2       |                |                 |\n| `GL_RGB4`                 | `GL_RGB`                 |      4       |       4        |       4       |                |                 |\n| `GL_RGB5`                 | `GL_RGB`                 |      5       |       5        |       5       |                |                 |\n| `GL_RGB8`                 | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_RGB8_SNORM`           | `GL_RGB`                 |      s8      |       s8       |      s8       |                |                 |\n| `GL_RGB10`                | `GL_RGB`                 |      10      |       10       |      10       |                |                 |\n| `GL_RGB12`                | `GL_RGB`                 |      12      |       12       |      12       |                |                 |\n| `GL_RGB16_SNORM`          | `GL_RGB`                 |      16      |       16       |      16       |                |                 |\n| `GL_RGBA2`                | `GL_RGB`                 |      2       |       2        |       2       |       2        |                 |\n| `GL_RGBA4`                | `GL_RGB`                 |      4       |       4        |       4       |       4        |                 |\n| `GL_RGB5_A1`              | `GL_RGBA`                |      5       |       5        |       5       |       1        |                 |\n| `GL_RGBA8`                | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_RGBA8_SNORM`          | `GL_RGBA`                |      s8      |       s8       |      s8       |       s8       |                 |\n| `GL_RGB10_A2`             | `GL_RGBA`                |      10      |       10       |      10       |       2        |                 |\n| `GL_RGB10_A2UI`           | `GL_RGBA`                |     ui10     |      ui10      |     ui10      |      ui2       |                 |\n| `GL_RGBA12`               | `GL_RGBA`                |      12      |       12       |      12       |       12       |                 |\n| `GL_RGBA16`               | `GL_RGBA`                |      16      |       16       |      16       |       16       |                 |\n| `GL_SRGB8`                | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_SRGB8_ALPHA8`         | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_R16F`                 | `GL_RED`                 |     f16      |                |               |                |                 |\n| `GL_RG16F`                | `GL_RG`                  |     f16      |      f16       |               |                |                 |\n| `GL_RGB16F`               | `GL_RGB`                 |     f16      |      f16       |      f16      |                |                 |\n| `GL_RGBA16F`              | `GL_RGBA`                |     f16      |      f16       |      f16      |      f16       |                 |\n| `GL_R32F`                 | `GL_RED`                 |     f32      |                |               |                |                 |\n| `GL_RG32F`                | `GL_RG`                  |     f32      |      f32       |               |                |                 |\n| `GL_RGB32F`               | `GL_RGB`                 |     f32      |      f32       |      f32      |                |                 |\n| `GL_RGBA32F`              | `GL_RGBA`                |     f32      |      f32       |      f32      |      f32       |                 |\n| `GL_R11F_G11F_B10F`       | `GL_RGB`                 |     f11      |      f11       |      f10      |                |                 |\n| `GL_RGB9_E5`              | `GL_RGB`                 |      9       |       9        |       9       |                |        5        |\n| `GL_R8I`                  | `GL_RED`                 |      i8      |                |               |                |                 |\n| `GL_R8UI`                 | `GL_RED`                 |     ui8      |                |               |                |                 |\n| `GL_R16I`                 | `GL_RED`                 |     i16      |                |               |                |                 |\n| `GL_R16UI`                | `GL_RED`                 |     ui16     |                |               |                |                 |\n| `GL_R32I`                 | `GL_RED`                 |     i32      |                |               |                |                 |\n| `GL_R32UI`                | `GL_RED`                 |     ui32     |                |               |                |                 |\n| `GL_RG8I`                 | `GL_RG`                  |      i8      |       i8       |               |                |                 |\n| `GL_RG8UI`                | `GL_RG`                  |     ui8      |      ui8       |               |                |                 |\n| `GL_RG16I`                | `GL_RG`                  |     i16      |      i16       |               |                |                 |\n| `GL_RG16UI`               | `GL_RG`                  |     ui16     |      ui16      |               |                |                 |\n| `GL_RG32I`                | `GL_RG`                  |     i32      |      i32       |               |                |                 |\n| `GL_RG32UI`               | `GL_RG`                  |     ui32     |      ui32      |               |                |                 |\n| `GL_RGB8I`                | `GL_RGB`                 |      i8      |       i8       |      i8       |                |                 |\n| `GL_RGB8UI`               | `GL_RGB`                 |     ui8      |      ui8       |      ui8      |                |                 |\n| `GL_RGB16I`               | `GL_RGB`                 |     i16      |      i16       |      i16      |                |                 |\n| `GL_RGB16UI`              | `GL_RGB`                 |     ui16     |      ui16      |     ui16      |                |                 |\n| `GL_RGB32I`               | `GL_RGB`                 |     i32      |      i32       |      i32      |                |                 |\n| `GL_RGB32UI`              | `GL_RGB`                 |     ui32     |      ui32      |     ui32      |                |                 |\n| `GL_RGBA8I`               | `GL_RGBA`                |      i8      |       i8       |      i8       |       i8       |                 |\n| `GL_RGBA8UI`              | `GL_RGBA`                |     ui8      |      ui8       |      ui8      |      ui8       |                 |\n| `GL_RGBA16I`              | `GL_RGBA`                |     i16      |      i16       |      i16      |      i16       |                 |\n| `GL_RGBA16UI`             | `GL_RGBA`                |     ui16     |      ui16      |     ui16      |      ui16      |                 |\n| `GL_RGBA32I`              | `GL_RGBA`                |     i32      |      i32       |      i32      |      i32       |                 |\n| `GL_RGBA32UI`             | `GL_RGBA`                |     ui32     |      ui32      |     ui32      |      ui32      |                 |\n\n  \n\n## Notes\n\n`GL_STENCIL_INDEX8` is accepted for *`internalformat`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage3D` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage3D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid sized internal format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`*, *`height`*, *`depth`* or *`levels`* are less than 1.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is `GL_TEXTURE_3D` or `GL_PROXY_TEXTURE_3D` and *`levels`* is greater than ⌊log₂(max (*w**i**d**t**h*, *h**e**i**g**h**t*, *d**e**p**t**h*))⌋ + 1.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is `GL_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_2D_ARRAY`, `GL_TEXURE_CUBE_MAP_ARRAY`, or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY` and *`levels`* is greater than ⌊log₂(max (*w**i**d**t**h*, *h**e**i**g**h**t*))⌋ + 1.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexStorage3D`            |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTextureStorage3D`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glTexImage3D](glteximage3d.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml).\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage3D.xhtml)"
- name: glTexStorage3DMultisample
  id: gltexstorage3dmultisample.xhtml
  summary: target Specifies the target to which the texture object is bound for glTexStorage3DMultisample
  description: "## Name\n\nglTexStorage3DMultisample, glTextureStorage3DMultisample — specify storage for a two-dimensional multisample array texture\n\n## C Specification\n\n`void `**`glTexStorage3DMultisample`**`(` GLenum `target`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLboolean `fixedsamplelocations``)`;\n\n`void `**`glTextureStorage3DMultisample`**`(` GLuint `texture`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLboolean `fixedsamplelocations``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture object is bound for `glTexStorage3DMultisample`. Must be one of `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureStorage3DMultisample`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n *`samples`*  \nSpecify the number of samples in the texture.\n\n *`internalformat`*  \nSpecifies the sized internal format to be used to store texture image data.\n\n *`width`*  \nSpecifies the width of the texture, in texels.\n\n *`height`*  \nSpecifies the height of the texture, in texels.\n\n *`depth`*  \nSpecifies the depth of the texture, in layers.\n\n *`fixedsamplelocations`*  \nSpecifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\n## Description\n\n`glTexStorage3DMultisample` and `glTextureStorage3DMultisample` specify the storage requirements for a two-dimensional multisample array texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\n*`samples`* specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of `GL_MAX_SAMPLES`. *`internalformat`* must be a color-renderable, depth-renderable, or stencil-renderable format. *`width`* and *`height`* specify the width and height, respectively, of the texture and *`depth`* specifies the depth (or the number of layers) of the texture. If *`fixedsamplelocations`* is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\nTable 1. Sized Internal Formats\n\n| **Sized Internal Format** | **Base Internal Format** | **Red Bits** | **Green Bits** | **Blue Bits** | **Alpha Bits** | **Shared Bits** |\n|:--------------------------|:-------------------------|:------------:|:--------------:|:-------------:|:--------------:|:---------------:|\n| `GL_R8`                   | `GL_RED`                 |      8       |                |               |                |                 |\n| `GL_R8_SNORM`             | `GL_RED`                 |      s8      |                |               |                |                 |\n| `GL_R16`                  | `GL_RED`                 |      16      |                |               |                |                 |\n| `GL_R16_SNORM`            | `GL_RED`                 |     s16      |                |               |                |                 |\n| `GL_RG8`                  | `GL_RG`                  |      8       |       8        |               |                |                 |\n| `GL_RG8_SNORM`            | `GL_RG`                  |      s8      |       s8       |               |                |                 |\n| `GL_RG16`                 | `GL_RG`                  |      16      |       16       |               |                |                 |\n| `GL_RG16_SNORM`           | `GL_RG`                  |     s16      |      s16       |               |                |                 |\n| `GL_R3_G3_B2`             | `GL_RGB`                 |      3       |       3        |       2       |                |                 |\n| `GL_RGB4`                 | `GL_RGB`                 |      4       |       4        |       4       |                |                 |\n| `GL_RGB5`                 | `GL_RGB`                 |      5       |       5        |       5       |                |                 |\n| `GL_RGB8`                 | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_RGB8_SNORM`           | `GL_RGB`                 |      s8      |       s8       |      s8       |                |                 |\n| `GL_RGB10`                | `GL_RGB`                 |      10      |       10       |      10       |                |                 |\n| `GL_RGB12`                | `GL_RGB`                 |      12      |       12       |      12       |                |                 |\n| `GL_RGB16_SNORM`          | `GL_RGB`                 |      16      |       16       |      16       |                |                 |\n| `GL_RGBA2`                | `GL_RGB`                 |      2       |       2        |       2       |       2        |                 |\n| `GL_RGBA4`                | `GL_RGB`                 |      4       |       4        |       4       |       4        |                 |\n| `GL_RGB5_A1`              | `GL_RGBA`                |      5       |       5        |       5       |       1        |                 |\n| `GL_RGBA8`                | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_RGBA8_SNORM`          | `GL_RGBA`                |      s8      |       s8       |      s8       |       s8       |                 |\n| `GL_RGB10_A2`             | `GL_RGBA`                |      10      |       10       |      10       |       2        |                 |\n| `GL_RGB10_A2UI`           | `GL_RGBA`                |     ui10     |      ui10      |     ui10      |      ui2       |                 |\n| `GL_RGBA12`               | `GL_RGBA`                |      12      |       12       |      12       |       12       |                 |\n| `GL_RGBA16`               | `GL_RGBA`                |      16      |       16       |      16       |       16       |                 |\n| `GL_SRGB8`                | `GL_RGB`                 |      8       |       8        |       8       |                |                 |\n| `GL_SRGB8_ALPHA8`         | `GL_RGBA`                |      8       |       8        |       8       |       8        |                 |\n| `GL_R16F`                 | `GL_RED`                 |     f16      |                |               |                |                 |\n| `GL_RG16F`                | `GL_RG`                  |     f16      |      f16       |               |                |                 |\n| `GL_RGB16F`               | `GL_RGB`                 |     f16      |      f16       |      f16      |                |                 |\n| `GL_RGBA16F`              | `GL_RGBA`                |     f16      |      f16       |      f16      |      f16       |                 |\n| `GL_R32F`                 | `GL_RED`                 |     f32      |                |               |                |                 |\n| `GL_RG32F`                | `GL_RG`                  |     f32      |      f32       |               |                |                 |\n| `GL_RGB32F`               | `GL_RGB`                 |     f32      |      f32       |      f32      |                |                 |\n| `GL_RGBA32F`              | `GL_RGBA`                |     f32      |      f32       |      f32      |      f32       |                 |\n| `GL_R11F_G11F_B10F`       | `GL_RGB`                 |     f11      |      f11       |      f10      |                |                 |\n| `GL_RGB9_E5`              | `GL_RGB`                 |      9       |       9        |       9       |                |        5        |\n| `GL_R8I`                  | `GL_RED`                 |      i8      |                |               |                |                 |\n| `GL_R8UI`                 | `GL_RED`                 |     ui8      |                |               |                |                 |\n| `GL_R16I`                 | `GL_RED`                 |     i16      |                |               |                |                 |\n| `GL_R16UI`                | `GL_RED`                 |     ui16     |                |               |                |                 |\n| `GL_R32I`                 | `GL_RED`                 |     i32      |                |               |                |                 |\n| `GL_R32UI`                | `GL_RED`                 |     ui32     |                |               |                |                 |\n| `GL_RG8I`                 | `GL_RG`                  |      i8      |       i8       |               |                |                 |\n| `GL_RG8UI`                | `GL_RG`                  |     ui8      |      ui8       |               |                |                 |\n| `GL_RG16I`                | `GL_RG`                  |     i16      |      i16       |               |                |                 |\n| `GL_RG16UI`               | `GL_RG`                  |     ui16     |      ui16      |               |                |                 |\n| `GL_RG32I`                | `GL_RG`                  |     i32      |      i32       |               |                |                 |\n| `GL_RG32UI`               | `GL_RG`                  |     ui32     |      ui32      |               |                |                 |\n| `GL_RGB8I`                | `GL_RGB`                 |      i8      |       i8       |      i8       |                |                 |\n| `GL_RGB8UI`               | `GL_RGB`                 |     ui8      |      ui8       |      ui8      |                |                 |\n| `GL_RGB16I`               | `GL_RGB`                 |     i16      |      i16       |      i16      |                |                 |\n| `GL_RGB16UI`              | `GL_RGB`                 |     ui16     |      ui16      |     ui16      |                |                 |\n| `GL_RGB32I`               | `GL_RGB`                 |     i32      |      i32       |      i32      |                |                 |\n| `GL_RGB32UI`              | `GL_RGB`                 |     ui32     |      ui32      |     ui32      |                |                 |\n| `GL_RGBA8I`               | `GL_RGBA`                |      i8      |       i8       |      i8       |       i8       |                 |\n| `GL_RGBA8UI`              | `GL_RGBA`                |     ui8      |      ui8       |      ui8      |      ui8       |                 |\n| `GL_RGBA16I`              | `GL_RGBA`                |     i16      |      i16       |      i16      |      i16       |                 |\n| `GL_RGBA16UI`             | `GL_RGBA`                |     ui16     |      ui16      |     ui16      |      ui16      |                 |\n| `GL_RGBA32I`              | `GL_RGBA`                |     i32      |      i32       |      i32      |      i32       |                 |\n| `GL_RGBA32UI`             | `GL_RGBA`                |     ui32     |      ui32      |     ui32      |      ui32      |                 |\n\n  \n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage3DMultisample` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage3DMultisample` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid color-renderable, depth-renderable or stencil-renderable format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`* or *`height`* are less than 1 or greater than the value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`depth`* is less than 1 or greater than the value of `GL_MAX_ARRAY_TEXTURE_LAYERS`.\n\n`GL_INVALID_VALUE` is generated if *`levels`* is less than 1.\n\n`GL_INVALID_VALUE` is generated if *`samples`* is zero.\n\n`GL_INVALID_OPERATION` is generated if *`samples`* is greater than the maximum number of samples supported for this *`target`* and *`internalformat`*.\n\n`GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for the texture bound to *`target`* is not `GL_FALSE`.\n\n## Associated Gets\n\n`glGetInteger` with arguments `GL_MAX_TEXTURE_SIZE`, `GL_MAX_ARRAY_TEXTURE_LEVELS`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_NUM_LAYERS`, or `GL_TEXTURE_IMMUTABLE_LEVELS`.\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexStorage3DMultisample`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glTextureStorage3DMultisample` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glTexImage3D](glteximage3d.xhtml), [glTexImage3DMultisample](glteximage3dmultisample.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2DMultisample](gltexstorage2dmultisample.xhtml), [glTexStorage3D](gltexstorage3d.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage3DMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage3DMultisample.xhtml)"
- name: glTexSubImage1D
  id: gltexsubimage1d.xhtml
  summary: target Specifies the target to which the texture is bound for glTexSubImage1D
  description: "## Name\n\nglTexSubImage1D, glTextureSubImage1D — specify a one-dimensional texture subimage\n\n## C Specification\n\n`void `**`glTexSubImage1D`**`(` GLenum `target`, GLint `level`, GLint `xoffset`, GLsizei `width`, GLenum `format`, GLenum `type`, const void \\* `pixels``)`;\n\n`void `**`glTextureSubImage1D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLsizei `width`, GLenum `format`, GLenum `type`, const void \\*`pixels``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glTexSubImage1D`. Must be `GL_TEXTURE_1D`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureSubImage1D`. The effective target of *`texture`* must be one of the valid *`target`* values above.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n *`format`*  \nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`.\n\n *`type`*  \nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n *`pixels`*  \nSpecifies a pointer to the image data in memory.\n\n## Description\n\nTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable or disable one-dimensional texturing, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_TEXTURE_1D`.\n\n`glTexSubImage1D` and `glTextureSubImage1D` redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by *`pixels`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\n## Notes\n\n[glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n`glTexSubImage1D` and `glTextureSubImage1D` specify a one-dimensional subtexture for the current texture unit, specified with [glActiveTexture](glactivetexture.xhtml).\n\n`GL_STENCIL_INDEX` is accepted for *`format`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the allowable values.\n\n`GL_INVALID_OPERATION` is generated by `glTextureSubImage1D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`format`* is not an accepted format constant.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not a type constant.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂ *max*, where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< −*b*, or if (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> (*w* − *b*), where *w* is the `GL_TEXTURE_WIDTH`, and *b* is the width of the `GL_TEXTURE_BORDER` of the texture image being modified. Note that *w* includes twice the border width.\n\n`GL_INVALID_VALUE` is generated if *`width`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage1D](glteximage1d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and *`pixels`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexSubImage1D`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTextureSubImage1D`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage1D.xhtml)"
- name: glTexSubImage2D
  id: gltexsubimage2d.xhtml
  summary: target Specifies the target to which the texture is bound for glTexSubImage2D
  description: "## Name\n\nglTexSubImage2D, glTextureSubImage2D — specify a two-dimensional texture subimage\n\n## C Specification\n\n`void `**`glTexSubImage2D`**`(` GLenum `target`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLsizei `width`, GLsizei `height`, GLenum `format`, GLenum `type`, const void \\* `pixels``)`;\n\n`void `**`glTextureSubImage2D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLsizei `width`, GLsizei `height`, GLenum `format`, GLenum `type`, const void \\*`pixels``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glTexSubImage2D`. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_1D_ARRAY`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureSubImage2D`. The effective target of *`texture`* must be one of the valid *`target`* values above.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`yoffset`*  \nSpecifies a texel offset in the y direction within the texture array.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n *`height`*  \nSpecifies the height of the texture subimage.\n\n *`format`*  \nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`.\n\n *`type`*  \nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n *`pixels`*  \nSpecifies a pointer to the image data in memory.\n\n## Description\n\nTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.\n\n`glTexSubImage2D` and `glTextureSubImage2D` redefine a contiguous subregion of an existing two-dimensional or one-dimensional array texture image. The texels referenced by *`pixels`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive, and y indices *`yoffset`* and *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\n## Notes\n\n[glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n`glTexSubImage2D` and `glTextureSubImage3D` specify a two-dimensional subtexture for the current texture unit, specified with [glActiveTexture](glactivetexture.xhtml).\n\n`GL_STENCIL_INDEX` is accepted for *`format`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_1D_ARRAY`.\n\n`GL_INVALID_OPERATION` is generated by `glTextureSubImage2D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`format`* is not an accepted format constant.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not a type constant.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂ *max*, where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< −*b*, (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> (*w* − *b*), *y**o**f**f**s**e**t* \\< −*b*, or (*y**o**f**f**s**e**t* + *h**e**i**g**h**t*) \\> (*h* − *b*), where *w* is the `GL_TEXTURE_WIDTH`, *h* is the `GL_TEXTURE_HEIGHT`, and *b* is the border width of the texture image being modified. Note that *w* and *h* include twice the border width.\n\n`GL_INVALID_VALUE` is generated if *`width`* or *`height`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage2D](glteximage2d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and *`pixels`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexSubImage2D`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTextureSubImage2D`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage2D.xhtml)"
- name: glTexSubImage3D
  id: gltexsubimage3d.xhtml
  summary: target Specifies the target to which the texture is bound for glTexSubImage3D
  description: "## Name\n\nglTexSubImage3D, glTextureSubImage3D — specify a three-dimensional texture subimage\n\n## C Specification\n\n`void `**`glTexSubImage3D`**`(` GLenum `target`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLenum `format`, GLenum `type`, const void \\* `pixels``)`;\n\n`void `**`glTextureSubImage3D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLenum `format`, GLenum `type`, const void \\*`pixels``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the texture is bound for `glTexSubImage3D`. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`.\n\n *`texture`*  \nSpecifies the texture object name for `glTextureSubImage3D`. The effective target of *`texture`* must be one of the valid *`target`* values above.\n\n *`level`*  \nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n *`xoffset`*  \nSpecifies a texel offset in the x direction within the texture array.\n\n *`yoffset`*  \nSpecifies a texel offset in the y direction within the texture array.\n\n *`zoffset`*  \nSpecifies a texel offset in the z direction within the texture array.\n\n *`width`*  \nSpecifies the width of the texture subimage.\n\n *`height`*  \nSpecifies the height of the texture subimage.\n\n *`depth`*  \nSpecifies the depth of the texture subimage.\n\n *`format`*  \nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`.\n\n *`type`*  \nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n *`pixels`*  \nSpecifies a pointer to the image data in memory.\n\n## Description\n\nTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.\n\n`glTexSubImage3D` and `glTextureSubImage3D` redefine a contiguous subregion of an existing three-dimensional or two-dimensioanl array texture image. The texels referenced by *`pixels`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive, y indices *`yoffset`* and *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive, and z indices *`zoffset`* and *z**o**f**f**s**e**t* + *d**e**p**t**h* − 1, inclusive. For three-dimensional textures, the z index refers to the third dimension. For two-dimensional array textures, the z index refers to the slice index. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width, height, or depth but such a specification has no effect.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\n## Notes\n\nThe [glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n`glTexSubImage3D` and `glTextureSubImage3D` specify a three-dimensional or two-dimensional array subtexture for the current texture unit, specified with [glActiveTexture](glactivetexture.xhtml).\n\n`GL_STENCIL_INDEX` is accepted for *`format`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n`GL_INVALID_OPERATION` is generated by `glTextureSubImage3D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`format`* is not an accepted format constant.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not a type constant.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂ *max*, where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< −*b*, (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> (*w* − *b*), *y**o**f**f**s**e**t* \\< −*b*, or (*y**o**f**f**s**e**t* + *h**e**i**g**h**t*) \\> (*h* − *b*), or *z**o**f**f**s**e**t* \\< −*b*, or (*z**o**f**f**s**e**t* + *d**e**p**t**h*) \\> (*d* − *b*), where *w* is the `GL_TEXTURE_WIDTH`, *h* is the `GL_TEXTURE_HEIGHT`, *d* is the `GL_TEXTURE_DEPTH` and *b* is the border width of the texture image being modified. Note that *w*, *h*, and *d* include twice the border width.\n\n`GL_INVALID_VALUE` is generated if *`width`*, *`height`*, or *`depth`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage3D](glteximage3d.xhtml) or [glTexStorage3D](gltexstorage3d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and *`pixels`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n## Associated Gets\n\n[glGetTexImage](glgetteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTexSubImage3D`           |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glTextureSubImage3D`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage3D.xhtml)"
- name: glTextureBarrier
  id: gltexturebarrier.xhtml
  summary: The values of rendered fragments are undefined when a shader stage fetches texels and the same texels are written via fragment shader outputs, even if the reads and writes are not in the same drawing command
  description: "## Name\n\nglTextureBarrier — controls the ordering of reads and writes to rendered fragments across drawing commands\n\n## C Specification\n\n`void `**`glTextureBarrier`**`(` `void``)`;\n\n## Description\n\nThe values of rendered fragments are undefined when a shader stage fetches texels and the same texels are written via fragment shader outputs, even if the reads and writes are not in the same drawing command. To safely read the result of a written texel via a texel fetch in a subsequent drawing command, call `glTextureBarrier` between the two drawing commands to guarantee that writes have completed and caches have been invalidated before subsequent drawing commands are executed.\n\n## Notes\n\nThe situation described above is referred to as a *rendering feedback loop* and is discussed in more detail in section 9.3 of the OpenGL 4.5 Specification.\n\n## Errors\n\nNone.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTextureBarrier`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glMemoryBarrier](glmemorybarrier.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTextureBarrier.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTextureBarrier.xhtml)"
- name: glTextureBuffer
  id: gltexbuffer.xhtml#glTextureBuffer
  summary: Specifies the target to which the texture is bound for glTexBuffer
  belongs_to: glTexBuffer
  description: "`void `**`glTextureBuffer`**`(` GLuint `texture`, GLenum `internalformat`, GLuint `buffer``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glTexBuffer`. Must be `GL_TEXTURE_BUFFER`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureBuffer`.\n\n*`internalformat`*\n\nSpecifies the internal format of the data in the store belonging to *`buffer`*.\n\n*`buffer`*\n\nSpecifies the name of the buffer object whose storage to attach to the active buffer texture.\n\n## Description\n\n`glTexBuffer` and `glTextureBuffer` attaches the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found in the buffer object. The texture object must be a buffer texture.\n\nIf *`buffer`* is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If *`buffer`* is non-zero, it must be the name of an existing buffer object.\n\n*`internalformat`* specifies the storage format, and must be one of the following sized internal formats:\n\n|                             |                 |                  |            |  **Component**  |     |     |     |\n|:----------------------------|:----------------|:-----------------|:-----------|:---------------:|:---:|:---:|:---:|\n|  **Sized Internal Format**  |  **Base Type**  |  **Components**  |  **Norm**  |        0        |  1  |  2  |  3  |\n| `GL_R8`                     | ubyte           | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16`                    | ushort          | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16F`                   | half            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32F`                   | float           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8I`                    | byte            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16I`                   | short           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32I`                   | int             | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8UI`                   | ubyte           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16UI`                  | ushort          | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32UI`                  | uint            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_RG8`                    | ubyte           | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16`                   | ushort          | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16F`                  | half            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32F`                  | float           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8I`                   | byte            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16I`                  | short           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32I`                  | int             | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8UI`                  | ubyte           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16UI`                 | ushort          | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32UI`                 | uint            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RGB32F`                 | float           | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32I`                 | int             | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32UI`                | uint            | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGBA8`                  | uint            | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16`                 | short           | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16F`                | half            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32F`                | float           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8I`                 | byte            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16I`                | short           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32I`                | int             | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8UI`                | ubyte           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16UI`               | ushort          | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32UI`               | uint            | 4                | NO         |        R        |  G  |  B  |  A  |\n\nWhen a buffer object is attached to a buffer texture, the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \\left\\lfloor { size \\over { components \\times sizeof(base\\\\type) } } \\right\\rfloor $$ where $size$ is the size of the buffer object in basic machine units (the value of `GL_BUFFER_SIZE` for *`buffer`*), and $components$ and $base\\\\type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit `GL_MAX_TEXTURE_BUFFER_SIZE`. When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glTexBuffer` if *`target`* is not `GL_TEXTURE_BUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glTextureBuffer` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated by `glTextureBuffer` if the effective target of *`texture`* is not `GL_TEXTURE_BUFFER`.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the sized internal formats described above.\n\n`GL_INVALID_OPERATION` is generated if *`buffer`* is not zero and is not the name of an existing buffer object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_TEXTURE_BUFFER_SIZE`\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_BINDING_BUFFER`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with argument `GL_TEXTURE_BUFFER_DATA_STORE_BINDING`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexBuffer`                 |          \\-          |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTextureBuffer`             |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glBufferData](glbufferdata.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glGenTextures](glgentextures.xhtml), [glBindTexture](glbindtexture.xhtml), [glDeleteTextures](gldeletetextures.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexBuffer.xhtml)"
- name: glTextureBufferRange
  id: gltexbufferrange.xhtml#glTextureBufferRange
  summary: Specifies the target to which the texture object is bound for glTexBufferRange
  belongs_to: glTexBufferRange
  description: "`void `**`glTextureBufferRange`**`(` GLuint `texture`, GLenum `internalformat`, GLuint `buffer`, GLintptr `offset`, GLsizei `size``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glTexBufferRange`. Must be `GL_TEXTURE_BUFFER`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureBufferRange`.\n\n*`internalformat`*\n\nSpecifies the internal format of the data in the store belonging to *`buffer`*.\n\n*`buffer`*\n\nSpecifies the name of the buffer object whose storage to attach to the active buffer texture.\n\n*`offset`*\n\nSpecifies the offset of the start of the range of the buffer's data store to attach.\n\n*`size`*\n\nSpecifies the size of the range of the buffer's data store to attach.\n\n## Description\n\n`glTexBufferRange` and `glTextureBufferRange` attach a range of the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found in the buffer object. The texture object must be a buffer texture.\n\nIf *`buffer`* is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If *`buffer`* is non-zero, it must be the name of an existing buffer object.\n\nThe start and size of the range are specified by *`offset`* and *`size`* respectively, both measured in basic machine units. *`offset`* must be greater than or equal to zero, *`size`* must be greater than zero, and the sum of *`offset`* and *`size`* must not exceed the value of `GL_BUFFER_SIZE` for *`buffer`*. Furthermore, *`offset`* must be an integer multiple of the value of `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`.\n\n*`internalformat`* specifies the storage format, and must be one of the following sized internal formats:\n\n|                             |                 |                  |            |  **Component**  |     |     |     |\n|:----------------------------|:----------------|:-----------------|:-----------|:---------------:|:---:|:---:|:---:|\n|  **Sized Internal Format**  |  **Base Type**  |  **Components**  |  **Norm**  |        0        |  1  |  2  |  3  |\n| `GL_R8`                     | ubyte           | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16`                    | ushort          | 1                | YES        |        R        |  0  |  0  |  1  |\n| `GL_R16F`                   | half            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32F`                   | float           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8I`                    | byte            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16I`                   | short           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32I`                   | int             | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R8UI`                   | ubyte           | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R16UI`                  | ushort          | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_R32UI`                  | uint            | 1                | NO         |        R        |  0  |  0  |  1  |\n| `GL_RG8`                    | ubyte           | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16`                   | ushort          | 2                | YES        |        R        |  G  |  0  |  1  |\n| `GL_RG16F`                  | half            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32F`                  | float           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8I`                   | byte            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16I`                  | short           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32I`                  | int             | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG8UI`                  | ubyte           | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG16UI`                 | ushort          | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RG32UI`                 | uint            | 2                | NO         |        R        |  G  |  0  |  1  |\n| `GL_RGB32F`                 | float           | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32I`                 | int             | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGB32UI`                | uint            | 3                | NO         |        R        |  G  |  B  |  1  |\n| `GL_RGBA8`                  | uint            | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16`                 | short           | 4                | YES        |        R        |  G  |  B  |  A  |\n| `GL_RGBA16F`                | half            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32F`                | float           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8I`                 | byte            | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16I`                | short           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32I`                | int             | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA8UI`                | ubyte           | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA16UI`               | ushort          | 4                | NO         |        R        |  G  |  B  |  A  |\n| `GL_RGBA32UI`               | uint            | 4                | NO         |        R        |  G  |  B  |  A  |\n\nWhen a range of a buffer object is attached to a buffer texture, the specified range of the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \\left\\lfloor { size \\over { components \\times sizeof(base\\\\type) } } \\right\\rfloor $$ where $components$ and $base\\\\type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit `GL_MAX_TEXTURE_BUFFER_SIZE`. When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glTexBufferRange` if *`target`* is not `GL_TEXTURE_BUFFER`.\n\n`GL_INVALID_OPERATION` is generated by `glTextureBufferRange` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated by `glTextureBufferRange` if the effective target of *`texture`* is not `GL_TEXTURE_BUFFER`.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not one of the sized internal formats described above.\n\n`GL_INVALID_OPERATION` is generated if *`buffer`* is not zero and is not the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`offset`* is negative, if *`size`* is less than or equal to zero, or if *`offset`* + *`size`* is greater than the value of `GL_BUFFER_SIZE` for *`buffer`*.\n\n`GL_INVALID_VALUE` is generated if *`offset`* is not an integer multiple of the value of `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT`\n\n[glGetTexLevelParameter](glgettexlevelparameter.xhtml) with arguments `GL_TEXTURE_BUFFER_OFFSET` or `GL_TEXTURE_BUFFER_SIZE`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexBufferRange`            |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glTextureBufferRange`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glTexBuffer](gltexbuffer.xhtml).\n\n## Copyright\n\nCopyright © 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexBufferRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexBufferRange.xhtml)"
- name: glTextureParameterf
  id: gltexparameter.xhtml#glTextureParameterf
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTextureParameterf`**`(` GLuint `texture`, GLenum `pname`, GLfloat `param``)`;'
- name: glTextureParameterfv
  id: gltexparameter.xhtml#glTextureParameterfv
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTextureParameterfv`**`(` GLuint `texture`, GLenum `pname`, const GLfloat \*`params``)`;'
- name: glTextureParameteri
  id: gltexparameter.xhtml#glTextureParameteri
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTextureParameteri`**`(` GLuint `texture`, GLenum `pname`, GLint `param``)`;'
- name: glTextureParameterIiv
  id: gltexparameter.xhtml#glTextureParameterIiv
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTextureParameterIiv`**`(` GLuint `texture`, GLenum `pname`, const GLint \*`params``)`;'
- name: glTextureParameterIuiv
  id: gltexparameter.xhtml#glTextureParameterIuiv
  summary: Specifies the target to which the texture is bound for glTexParameter functions
  belongs_to: glTexParameter
  description: "`void `**`glTextureParameterIuiv`**`(` GLuint `texture`, GLenum `pname`, const GLuint \\*`params``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glTexParameter` functions. Must be one of `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_TEXTURE_RECTANGLE`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureParameter` functions.\n\n*`pname`*\n\nSpecifies the symbolic name of a single-valued texture parameter. *`pname`* can be one of the following: `GL_DEPTH_STENCIL_TEXTURE_MODE`, `GL_TEXTURE_BASE_LEVEL`, `GL_TEXTURE_COMPARE_FUNC`, `GL_TEXTURE_COMPARE_MODE`, `GL_TEXTURE_LOD_BIAS`, `GL_TEXTURE_MIN_FILTER`, `GL_TEXTURE_MAG_FILTER`, `GL_TEXTURE_MIN_LOD`, `GL_TEXTURE_MAX_LOD`, `GL_TEXTURE_MAX_LEVEL`, `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, `GL_TEXTURE_SWIZZLE_A`, `GL_TEXTURE_WRAP_S`, `GL_TEXTURE_WRAP_T`, or `GL_TEXTURE_WRAP_R`.\n\nFor the vector commands (`glTexParameter*v`), *`pname`* can also be one of `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`.\n\n*`param`*\n\nFor the scalar commands, specifies the value of *`pname`*.\n\n*`params`*\n\nFor the vector commands, specifies a pointer to an array where the value or values of *`pname`* are stored.\n\n## Description\n\n`glTexParameter` and `glTextureParameter` assign the value or values in *`params`* to the texture parameter specified as *`pname`*. For `glTexParameter`, *`target`* defines the target texture, either `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, `GL_TEXTURE_3D`, `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_TEXTURE_RECTANGLE`. The following symbols are accepted in *`pname`*:\n\n`GL_DEPTH_STENCIL_TEXTURE_MODE`\n\nSpecifies the mode used to read from depth-stencil format textures. *`params`* must be one of `GL_DEPTH_COMPONENT` or `GL_STENCIL_INDEX`. If the depth stencil mode is `GL_DEPTH_COMPONENT`, then reads from depth-stencil format textures will return the depth component of the texel in *R*_(*t*) and the stencil component will be discarded. If the depth stencil mode is `GL_STENCIL_INDEX` then the stencil component is returned in *R*_(*t*) and the depth component is discarded. The initial value is `GL_DEPTH_COMPONENT`.\n\n`GL_TEXTURE_BASE_LEVEL`\n\nSpecifies the index of the lowest defined mipmap level. This is an integer value. The initial value is 0.\n\n`GL_TEXTURE_BORDER_COLOR`\n\nThe data in *`params`* specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of `GL_TEXTURE_BORDER_COLOR` are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of `GL_TEXTURE_BORDER_COLOR` is interpreted as a depth value. The initial value is (0.0, 0.0, 0.0, 0.0).\n\nIf the values for `GL_TEXTURE_BORDER_COLOR` are specified with `glTexParameterIiv` or `glTexParameterIuiv`, the values are stored unmodified with an internal data type of integer. If specified with `glTexParameteriv`, they are converted to floating point with the following equation: $\\mathit{f} = \\frac{2\\mathit{c} + 1}{2^{\\mathit{b}} - 1}$. If specified with `glTexParameterfv`, they are stored unmodified as floating-point values.\n\n`GL_TEXTURE_COMPARE_FUNC`\n\nSpecifies the comparison operator used when `GL_TEXTURE_COMPARE_MODE` is set to `GL_COMPARE_REF_TO_TEXTURE`. Permissible values are:\n\n|  **Texture Comparison Function**  |  **Computed result**                          |\n|:----------------------------------|:----------------------------------------------|\n| `GL_LEQUAL`                       | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r}\\<=\\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\> \\mathit{D}\\_{\\mathit{t}}}       \n                                     \\end{matrix}} \\right.$                         |\n| `GL_GEQUAL`                       | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r}\\>=\\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\< \\mathit{D}\\_{\\mathit{t}}}       \n                                     \\end{matrix}} \\right.$                         |\n| `GL_LESS`                         | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\< \\mathit{D}\\_{\\mathit{t}}} \\\\    \n                                     {\\mathit{r}\\>=\\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_GREATER`                      | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\> \\mathit{D}\\_{\\mathit{t}}} \\\\    \n                                     {\\mathit{r}\\<=\\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_EQUAL`                        | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} = \\mathit{D}\\_{\\mathit{t}}} \\\\     \n                                     {\\mathit{r} \\neq \\mathit{D}\\_{\\mathit{t}}}     \n                                     \\end{matrix}} \\right.$                         |\n| `GL_NOTEQUAL`                     | $\\mathit{result} = \\left\\\\ {\\begin{matrix}    \n                                     1.0 \\\\                                         \n                                     0.0                                            \n                                     \\end{matrix}\\begin{matrix}                     \n                                     {\\mathit{r} \\neq \\mathit{D}\\_{\\mathit{t}}} \\\\  \n                                     {\\mathit{r} = \\mathit{D}\\_{\\mathit{t}}}        \n                                     \\end{matrix}} \\right.$                         |\n| `GL_ALWAYS`                       | *r**e**s**u**l**t* = 1.0                      |\n| `GL_NEVER`                        | *r**e**s**u**l**t* = 0.0                      |\n\nwhere *r* is the current interpolated texture coordinate, and *D*_(*t*) is the depth texture value sampled from the currently bound depth texture. *r**e**s**u**l**t* is assigned to the red channel.\n\n`GL_TEXTURE_COMPARE_MODE`\n\nSpecifies the texture comparison mode for currently bound depth textures. That is, a texture whose internal format is `GL_DEPTH_COMPONENT_*`; see [glTexImage2D](glteximage2d.xhtml)) Permissible values are:\n\n`GL_COMPARE_REF_TO_TEXTURE`\n\nSpecifies that the interpolated and clamped *r* texture coordinate should be compared to the value in the currently bound depth texture. See the discussion of `GL_TEXTURE_COMPARE_FUNC` for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.\n\n`GL_NONE`\n\nSpecifies that the red channel should be assigned the appropriate value from the currently bound depth texture.\n\n`GL_TEXTURE_LOD_BIAS`\n\n*`params`* specifies a fixed bias value that is to be added to the level-of-detail parameter for the texture before texture sampling. The specified value is added to the shader-supplied bias value (if any) and subsequently clamped into the implementation-defined range \\[−*b**i**a**s*_(*max* ), *b**i**a**s*_(*max* )\\], where *b**i**a**s*_(*max* ) is the value of the implementation defined constant `GL_MAX_TEXTURE_LOD_BIAS`. The initial value is 0.0.\n\n`GL_TEXTURE_MIN_FILTER`\n\nThe texture minifying function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be minified. There are six defined minifying functions. Two of them use either the nearest texture elements or a weighted average of multiple texture elements to compute the texture value. The other four use mipmaps.\n\nA mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2^(*n*) × 2^(*m*), there are *max* (*n*, *m*) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2^(*n*) × 2^(*m*). Each subsequent mipmap has dimensions 2^(*k* − 1) × 2^(*l* − 1), where 2^(*k*) × 2^(*l*) are the dimensions of the previous mipmap, until either *k* = 0 or *l* = 0. At that point, subsequent mipmaps have dimension 1 × 2^(*l* − 1) or 2^(*k* − 1) × 1 until the final mipmap, which has dimension 1 × 1. To define the mipmaps, call [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), or [glCopyTexImage2D](glcopyteximage2d.xhtml) with the *level* argument indicating the order of the mipmaps. Level 0 is the original texture; level *max* (*n*, *m*) is the final 1 × 1 mipmap.\n\n*`params`* supplies a function for minifying the texture as one of the following:\n\n`GL_NEAREST`\n\nReturns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.\n\n`GL_LINEAR`\n\nReturns the weighted average of the four texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`, and on the exact mapping.\n\n`GL_NEAREST_MIPMAP_NEAREST`\n\nChooses the mipmap that most closely matches the size of the pixel being textured and uses the `GL_NEAREST` criterion (the texture element closest to the specified texture coordinates) to produce a texture value.\n\n`GL_LINEAR_MIPMAP_NEAREST`\n\nChooses the mipmap that most closely matches the size of the pixel being textured and uses the `GL_LINEAR` criterion (a weighted average of the four texture elements that are closest to the specified texture coordinates) to produce a texture value.\n\n`GL_NEAREST_MIPMAP_LINEAR`\n\nChooses the two mipmaps that most closely match the size of the pixel being textured and uses the `GL_NEAREST` criterion (the texture element closest to the specified texture coordinates ) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.\n\n`GL_LINEAR_MIPMAP_LINEAR`\n\nChooses the two mipmaps that most closely match the size of the pixel being textured and uses the `GL_LINEAR` criterion (a weighted average of the texture elements that are closest to the specified texture coordinates) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.\n\nAs more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the `GL_NEAREST` and `GL_LINEAR` minification functions can be faster than the other four, they sample only one or multiple texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of `GL_TEXTURE_MIN_FILTER` is `GL_NEAREST_MIPMAP_LINEAR`.\n\n`GL_TEXTURE_MAG_FILTER`\n\nThe texture magnification function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be magified. It sets the texture magnification function to either `GL_NEAREST` or `GL_LINEAR` (see below). `GL_NEAREST` is generally faster than `GL_LINEAR`, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of `GL_TEXTURE_MAG_FILTER` is `GL_LINEAR`.\n\n`GL_NEAREST`\n\nReturns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.\n\n`GL_LINEAR`\n\nReturns the weighted average of the texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`, and on the exact mapping.\n\n`GL_TEXTURE_MIN_LOD`\n\nSets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.\n\n`GL_TEXTURE_MAX_LOD`\n\nSets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.\n\n`GL_TEXTURE_MAX_LEVEL`\n\nSets the index of the highest defined mipmap level. This is an integer value. The initial value is 1000.\n\n`GL_TEXTURE_SWIZZLE_R`\n\nSets the swizzle that will be applied to the *r* component of a texel before it is returned to the shader. Valid values for *`param`* are `GL_RED`, `GL_GREEN`, `GL_BLUE`, `GL_ALPHA`, `GL_ZERO` and `GL_ONE`. If `GL_TEXTURE_SWIZZLE_R` is `GL_RED`, the value for *r* will be taken from the first channel of the fetched texel. If `GL_TEXTURE_SWIZZLE_R` is `GL_GREEN`, the value for *r* will be taken from the second channel of the fetched texel. If `GL_TEXTURE_SWIZZLE_R` is `GL_BLUE`, the value for *r* will be taken from the third channel of the fetched texel. If `GL_TEXTURE_SWIZZLE_R` is `GL_ALPHA`, the value for *r* will be taken from the fourth channel of the fetched texel. If `GL_TEXTURE_SWIZZLE_R` is `GL_ZERO`, the value for *r* will be subtituted with 0.0. If `GL_TEXTURE_SWIZZLE_R` is `GL_ONE`, the value for *r* will be subtituted with 1.0. The initial value is `GL_RED`.\n\n`GL_TEXTURE_SWIZZLE_G`\n\nSets the swizzle that will be applied to the *g* component of a texel before it is returned to the shader. Valid values for *`param`* and their effects are similar to those of `GL_TEXTURE_SWIZZLE_R`. The initial value is `GL_GREEN`.\n\n`GL_TEXTURE_SWIZZLE_B`\n\nSets the swizzle that will be applied to the *b* component of a texel before it is returned to the shader. Valid values for *`param`* and their effects are similar to those of `GL_TEXTURE_SWIZZLE_R`. The initial value is `GL_BLUE`.\n\n`GL_TEXTURE_SWIZZLE_A`\n\nSets the swizzle that will be applied to the *a* component of a texel before it is returned to the shader. Valid values for *`param`* and their effects are similar to those of `GL_TEXTURE_SWIZZLE_R`. The initial value is `GL_ALPHA`.\n\n`GL_TEXTURE_SWIZZLE_RGBA`\n\nSets the swizzles that will be applied to the *r*, *g*, *b*, and *a* components of a texel before they are returned to the shader. Valid values for *`params`* and their effects are similar to those of `GL_TEXTURE_SWIZZLE_R`, except that all channels are specified simultaneously. Setting the value of `GL_TEXTURE_SWIZZLE_RGBA` is equivalent (assuming no errors are generated) to setting the parameters of each of `GL_TEXTURE_SWIZZLE_R`, `GL_TEXTURE_SWIZZLE_G`, `GL_TEXTURE_SWIZZLE_B`, and `GL_TEXTURE_SWIZZLE_A` successively.\n\n`GL_TEXTURE_WRAP_S`\n\nSets the wrap parameter for texture coordinate *s* to either `GL_CLAMP_TO_EDGE`, `GL_CLAMP_TO_BORDER`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. `GL_CLAMP_TO_EDGE` causes *s* coordinates to be clamped to the range $\\left\\lbrack {\\frac{1}{2\\mathit{N}},{1 - \\frac{1}{2\\mathit{N}}}} \\right\\rbrack$, where *N* is the size of the texture in the direction of clamping. `GL_CLAMP_TO_BORDER` evaluates *s* coordinates in a similar manner to `GL_CLAMP_TO_EDGE`. However, in cases where clamping would have occurred in `GL_CLAMP_TO_EDGE` mode, the fetched texel data is substituted with the values specified by `GL_TEXTURE_BORDER_COLOR`. `GL_REPEAT` causes the integer part of the *s* coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. `GL_MIRRORED_REPEAT` causes the *s* coordinate to be set to the fractional part of the texture coordinate if the integer part of *s* is even; if the integer part of *s* is odd, then the *s* texture coordinate is set to 1 − *f**r**a**c*(*s*), where *f**r**a**c*(*s*) represents the fractional part of *s*. `GL_MIRROR_CLAMP_TO_EDGE` causes the *s* coordinate to be repeated as for `GL_MIRRORED_REPEAT` for one repetition of the texture, at which point the coordinate to be clamped as in `GL_CLAMP_TO_EDGE`. Initially, `GL_TEXTURE_WRAP_S` is set to `GL_REPEAT`.\n\n`GL_TEXTURE_WRAP_T`\n\nSets the wrap parameter for texture coordinate *t* to either `GL_CLAMP_TO_EDGE`, `GL_CLAMP_TO_BORDER`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. See the discussion under `GL_TEXTURE_WRAP_S`. Initially, `GL_TEXTURE_WRAP_T` is set to `GL_REPEAT`.\n\n`GL_TEXTURE_WRAP_R`\n\nSets the wrap parameter for texture coordinate *r* to either `GL_CLAMP_TO_EDGE`, `GL_CLAMP_TO_BORDER`, `GL_MIRRORED_REPEAT`, `GL_REPEAT`, or `GL_MIRROR_CLAMP_TO_EDGE`. See the discussion under `GL_TEXTURE_WRAP_S`. Initially, `GL_TEXTURE_WRAP_R` is set to `GL_REPEAT`.\n\n## Notes\n\nSuppose that a program attempts to sample from a texture and has set `GL_TEXTURE_MIN_FILTER` to one of the functions that requires a mipmap. If either the dimensions of the texture images currently defined (with previous calls to [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), or [glCopyTexImage2D](glcopyteximage2d.xhtml)) do not follow the proper sequence for mipmaps (described above), or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then the texture is considered *incomplete*.\n\nLinear filtering accesses the four nearest texture elements only in 2D textures. In 1D textures, linear filtering accesses the two nearest texture elements. In 3D textures, linear filtering accesses the eight nearest texture elements.\n\n`glTexParameter` specifies the texture parameters for the active texture unit, specified by calling [glActiveTexture](glactivetexture.xhtml). `glTextureParameter` specifies the texture parameters for the texture object with ID *`texture`*.\n\n`GL_DEPTH_STENCIL_TEXTURE_MODE` is available only if the GL version is 4.3 or greater.\n\n`GL_MIRROR_CLAMP_TO_EDGE` is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glTexParameter` if *`target`* is not one of the accepted defined values.\n\n`GL_INVALID_ENUM` is generated if *`pname`* is not one of the accepted defined values.\n\n`GL_INVALID_ENUM` is generated if *`params`* should have a defined constant value (based on the value of *`pname`*) and does not.\n\n`GL_INVALID_ENUM` is generated if `glTexParameter{if}` or `glTextureParameter{if}` is called for a non-scalar parameter (pname `GL_TEXTURE_BORDER_COLOR` or `GL_TEXTURE_SWIZZLE_RGBA`).\n\n`GL_INVALID_ENUM` is generated if the effective target is either `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, and *`pname`* is any of the sampler states.\n\n`GL_INVALID_ENUM` is generated if the effective target is `GL_TEXTURE_RECTANGLE` and either of pnames `GL_TEXTURE_WRAP_S` or `GL_TEXTURE_WRAP_T` is set to either `GL_MIRROR_CLAMP_TO_EDGE`, `GL_MIRRORED_REPEAT` or `GL_REPEAT`.\n\n`GL_INVALID_ENUM` is generated if the effective target is `GL_TEXTURE_RECTANGLE` and pname `GL_TEXTURE_MIN_FILTER` is set to a value other than `GL_NEAREST` or `GL_LINEAR` (no mipmap filtering is permitted).\n\n`GL_INVALID_OPERATION` is generated if the effective target is either `GL_TEXTURE_2D_MULTISAMPLE` or `GL_TEXTURE_2D_MULTISAMPLE_ARRAY`, and pname `GL_TEXTURE_BASE_LEVEL` is set to a value other than zero.\n\n`GL_INVALID_OPERATION` is generated by `glTextureParameter` if texture is not the name of an existing texture object.\n\n`GL_INVALID_OPERATION` is generated if the effective target is `GL_TEXTURE_RECTANGLE` and pname `GL_TEXTURE_BASE_LEVEL` is set to any value other than zero.\n\n`GL_INVALID_VALUE` is generated if *`pname`* is `GL_TEXTURE_BASE_LEVEL` or `GL_TEXTURE_MAX_LEVEL`, and *`param`* or *`params`* is negative.\n\n## Associated Gets\n\n[ glGetTexParameter ](glgettexparameter.xhtml)\n\n`glGetTextureParameter`\n\n[ glGetTexLevelParameter ](glgettexlevelparameter.xhtml)\n\n`glGetTextureLevelParameter`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexParameterIiv`           |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTexParameterIuiv`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTexParameterf`             |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTexParameterfv`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTexParameteri`             |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTexParameteriv`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTextureParameterIiv`       |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glTextureParameterIuiv`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glTextureParameterf`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glTextureParameterfv`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glTextureParameteri`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glTextureParameteriv`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glBindTexture](glbindtexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glSamplerParameter](glsamplerparameter.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexParameter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexParameter.xhtml)"
- name: glTextureParameteriv
  id: gltexparameter.xhtml#glTextureParameteriv
  summary: null
  belongs_to: glTexParameter
  description: '`void `**`glTextureParameteriv`**`(` GLuint `texture`, GLenum `pname`, const GLint \*`params``)`;'
- name: glTextureStorage1D
  id: gltexstorage1d.xhtml#glTextureStorage1D
  summary: Specifies the target to which the texture object is bound for glTexStorage1D
  belongs_to: glTexStorage1D
  description: "`void `**`glTextureStorage1D`**`(` GLuint `texture`, GLsizei `levels`, GLenum `internalformat`, GLsizei `width``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glTexStorage1D`. Must be one of `GL_TEXTURE_1D` or `GL_PROXY_TEXTURE_1D`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureStorage1D`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n*`levels`*\n\nSpecify the number of texture levels.\n\n*`internalformat`*\n\nSpecifies the sized internal format to be used to store texture image data.\n\n*`width`*\n\nSpecifies the width of the texture, in texels.\n\n## Description\n\n`glTexStorage1D` and `glTextureStorage1D` specify the storage requirements for all levels of a one-dimensional texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\nCalling `glTexStorage1D` is equivalent, assuming no errors are generated, to executing the following pseudo-code:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage1D(target, i, internalformat, width, 0, format, type, NULL);\n        width = max(1, (width / 2));\n    }\n```\n\nCalling `glTextureStorage1D` is equivalent to the above pseudo-code, where *`target`* is the effective target of *`texture`* and it is as if *`texture`* were bound to *`target`* for the purposes of `glTexImage1D`.\n\nSince no texture data is actually provided, the values used in the pseudo-code for *`format`* and *`type`* are irrelevant and may be considered to be any values that are legal for the chosen *`internalformat`* enumerant. *`internalformat`* must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats, `GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format, `GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`. The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling [glGetTexParameter](glgettexparameter.xhtml) with *`pname`* set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as [glTexImage1D](glteximage1d.xhtml) or another call to `glTexStorage1D`) will result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter the dimensions or format of the object.\n\nTable 1. Sized Internal Formats\n\n|  **Sized Internal Format**  |  **Base Internal Format**  |  **Red Bits**  |  **Green Bits**  |  **Blue Bits**  |  **Alpha Bits**  |  **Shared Bits**  |\n|:----------------------------|:---------------------------|:--------------:|:----------------:|:---------------:|:----------------:|:-----------------:|\n| `GL_R8`                     | `GL_RED`                   |       8        |                  |                 |                  |                   |\n| `GL_R8_SNORM`               | `GL_RED`                   |       s8       |                  |                 |                  |                   |\n| `GL_R16`                    | `GL_RED`                   |       16       |                  |                 |                  |                   |\n| `GL_R16_SNORM`              | `GL_RED`                   |      s16       |                  |                 |                  |                   |\n| `GL_RG8`                    | `GL_RG`                    |       8        |        8         |                 |                  |                   |\n| `GL_RG8_SNORM`              | `GL_RG`                    |       s8       |        s8        |                 |                  |                   |\n| `GL_RG16`                   | `GL_RG`                    |       16       |        16        |                 |                  |                   |\n| `GL_RG16_SNORM`             | `GL_RG`                    |      s16       |       s16        |                 |                  |                   |\n| `GL_R3_G3_B2`               | `GL_RGB`                   |       3        |        3         |        2        |                  |                   |\n| `GL_RGB4`                   | `GL_RGB`                   |       4        |        4         |        4        |                  |                   |\n| `GL_RGB5`                   | `GL_RGB`                   |       5        |        5         |        5        |                  |                   |\n| `GL_RGB8`                   | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_RGB8_SNORM`             | `GL_RGB`                   |       s8       |        s8        |       s8        |                  |                   |\n| `GL_RGB10`                  | `GL_RGB`                   |       10       |        10        |       10        |                  |                   |\n| `GL_RGB12`                  | `GL_RGB`                   |       12       |        12        |       12        |                  |                   |\n| `GL_RGB16_SNORM`            | `GL_RGB`                   |       16       |        16        |       16        |                  |                   |\n| `GL_RGBA2`                  | `GL_RGB`                   |       2        |        2         |        2        |        2         |                   |\n| `GL_RGBA4`                  | `GL_RGB`                   |       4        |        4         |        4        |        4         |                   |\n| `GL_RGB5_A1`                | `GL_RGBA`                  |       5        |        5         |        5        |        1         |                   |\n| `GL_RGBA8`                  | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_RGBA8_SNORM`            | `GL_RGBA`                  |       s8       |        s8        |       s8        |        s8        |                   |\n| `GL_RGB10_A2`               | `GL_RGBA`                  |       10       |        10        |       10        |        2         |                   |\n| `GL_RGB10_A2UI`             | `GL_RGBA`                  |      ui10      |       ui10       |      ui10       |       ui2        |                   |\n| `GL_RGBA12`                 | `GL_RGBA`                  |       12       |        12        |       12        |        12        |                   |\n| `GL_RGBA16`                 | `GL_RGBA`                  |       16       |        16        |       16        |        16        |                   |\n| `GL_SRGB8`                  | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_SRGB8_ALPHA8`           | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_R16F`                   | `GL_RED`                   |      f16       |                  |                 |                  |                   |\n| `GL_RG16F`                  | `GL_RG`                    |      f16       |       f16        |                 |                  |                   |\n| `GL_RGB16F`                 | `GL_RGB`                   |      f16       |       f16        |       f16       |                  |                   |\n| `GL_RGBA16F`                | `GL_RGBA`                  |      f16       |       f16        |       f16       |       f16        |                   |\n| `GL_R32F`                   | `GL_RED`                   |      f32       |                  |                 |                  |                   |\n| `GL_RG32F`                  | `GL_RG`                    |      f32       |       f32        |                 |                  |                   |\n| `GL_RGB32F`                 | `GL_RGB`                   |      f32       |       f32        |       f32       |                  |                   |\n| `GL_RGBA32F`                | `GL_RGBA`                  |      f32       |       f32        |       f32       |       f32        |                   |\n| `GL_R11F_G11F_B10F`         | `GL_RGB`                   |      f11       |       f11        |       f10       |                  |                   |\n| `GL_RGB9_E5`                | `GL_RGB`                   |       9        |        9         |        9        |                  |         5         |\n| `GL_R8I`                    | `GL_RED`                   |       i8       |                  |                 |                  |                   |\n| `GL_R8UI`                   | `GL_RED`                   |      ui8       |                  |                 |                  |                   |\n| `GL_R16I`                   | `GL_RED`                   |      i16       |                  |                 |                  |                   |\n| `GL_R16UI`                  | `GL_RED`                   |      ui16      |                  |                 |                  |                   |\n| `GL_R32I`                   | `GL_RED`                   |      i32       |                  |                 |                  |                   |\n| `GL_R32UI`                  | `GL_RED`                   |      ui32      |                  |                 |                  |                   |\n| `GL_RG8I`                   | `GL_RG`                    |       i8       |        i8        |                 |                  |                   |\n| `GL_RG8UI`                  | `GL_RG`                    |      ui8       |       ui8        |                 |                  |                   |\n| `GL_RG16I`                  | `GL_RG`                    |      i16       |       i16        |                 |                  |                   |\n| `GL_RG16UI`                 | `GL_RG`                    |      ui16      |       ui16       |                 |                  |                   |\n| `GL_RG32I`                  | `GL_RG`                    |      i32       |       i32        |                 |                  |                   |\n| `GL_RG32UI`                 | `GL_RG`                    |      ui32      |       ui32       |                 |                  |                   |\n| `GL_RGB8I`                  | `GL_RGB`                   |       i8       |        i8        |       i8        |                  |                   |\n| `GL_RGB8UI`                 | `GL_RGB`                   |      ui8       |       ui8        |       ui8       |                  |                   |\n| `GL_RGB16I`                 | `GL_RGB`                   |      i16       |       i16        |       i16       |                  |                   |\n| `GL_RGB16UI`                | `GL_RGB`                   |      ui16      |       ui16       |      ui16       |                  |                   |\n| `GL_RGB32I`                 | `GL_RGB`                   |      i32       |       i32        |       i32       |                  |                   |\n| `GL_RGB32UI`                | `GL_RGB`                   |      ui32      |       ui32       |      ui32       |                  |                   |\n| `GL_RGBA8I`                 | `GL_RGBA`                  |       i8       |        i8        |       i8        |        i8        |                   |\n| `GL_RGBA8UI`                | `GL_RGBA`                  |      ui8       |       ui8        |       ui8       |       ui8        |                   |\n| `GL_RGBA16I`                | `GL_RGBA`                  |      i16       |       i16        |       i16       |       i16        |                   |\n| `GL_RGBA16UI`               | `GL_RGBA`                  |      ui16      |       ui16       |      ui16       |       ui16       |                   |\n| `GL_RGBA32I`                | `GL_RGBA`                  |      i32       |       i32        |       i32       |       i32        |                   |\n| `GL_RGBA32UI`               | `GL_RGBA`                  |      ui32      |       ui32       |      ui32       |       ui32       |                   |\n\n  \n\n## Notes\n\n`GL_STENCIL_INDEX8` is accepted for *`internalformat`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage1D` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage1D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid sized internal format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`* or *`levels`* are less than 1.\n\n`GL_INVALID_OPERATION` is generated if *`levels`* is greater than ⌊log₂(*w**i**d**t**h*)⌋ + 1.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexStorage1D`              |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTextureStorage1D`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glTexImage1D](glteximage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml).\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage1D.xhtml)"
- name: glTextureStorage2D
  id: gltexstorage2d.xhtml#glTextureStorage2D
  summary: Specifies the target to which the texture object is bound for glTexStorage2D
  belongs_to: glTexStorage2D
  description: "`void `**`glTextureStorage2D`**`(` GLuint `texture`, GLsizei `levels`, GLenum `internalformat`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glTexStorage2D`. Must be one of `GL_TEXTURE_2D`, `GL_TEXTURE_1D_ARRAY`, `GL_TEXTURE_RECTANGLE`, `GL_TEXTURE_CUBE_MAP`, `GL_PROXY_TEXTURE_2D`, `GL_PROXY_TEXTURE_1D_ARRAY`, `GL_PROXY_TEXTURE_RECTANGLE`, or `GL_PROXY_TEXTURE_CUBE_MAP`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureStorage2D`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n*`levels`*\n\nSpecify the number of texture levels.\n\n*`internalformat`*\n\nSpecifies the sized internal format to be used to store texture image data.\n\n*`width`*\n\nSpecifies the width of the texture, in texels.\n\n*`height`*\n\nSpecifies the height of the texture, in texels.\n\n## Description\n\n`glTexStorage2D` and `glTextureStorage2D` specify the storage requirements for all levels of a two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\nThe behavior of `glTexStorage2D` depends on the *`target`* parameter. When *`target`* is `GL_TEXTURE_2D`, `GL_PROXY_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE`, `GL_PROXY_TEXTURE_RECTANGLE` or `GL_PROXY_TEXTURE_CUBE_MAP`, calling `glTexStorage2D` is equivalent, assuming no errors are generated, to executing the following pseudo-code:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);\n        width = max(1, (width / 2));\n        height = max(1, (height / 2));\n    }\n```\n\nWhen *`target`* is `GL_TEXTURE_CUBE_MAP`, `glTexStorage2D` is equivalent to:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        for (face in (+X, -X, +Y, -Y, +Z, -Z)) {\n            glTexImage2D(face, i, internalformat, width, height, 0, format, type, NULL);\n        }\n        width = max(1, (width / 2));\n        height = max(1, (height / 2));\n    }\n```\n\nWhen *`target`* is `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY`, `glTexStorage2D` is equivalent to:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);\n        width = max(1, (width / 2));\n    }\n```\n\nCalling `glTextureStorage2D` is equivalent to the above pseudo-code, where *`target`* is the effective target of *`texture`* and it is as if *`texture`* were bound to *`target`* for the purposes of `glTexImage2D`.\n\nSince no texture data is actually provided, the values used in the pseudo-code for *`format`* and *`type`* are irrelevant and may be considered to be any values that are legal for the chosen *`internalformat`* enumerant. *`internalformat`* must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats, `GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format, `GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`. The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling [glGetTexParameter](glgettexparameter.xhtml) with *`pname`* set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as [glTexImage2D](glteximage2d.xhtml) or another call to `glTexStorage2D`) will result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter the dimensions or format of the object.\n\nTable 1. Sized Internal Formats\n\n|  **Sized Internal Format**  |  **Base Internal Format**  |  **Red Bits**  |  **Green Bits**  |  **Blue Bits**  |  **Alpha Bits**  |  **Shared Bits**  |\n|:----------------------------|:---------------------------|:--------------:|:----------------:|:---------------:|:----------------:|:-----------------:|\n| `GL_R8`                     | `GL_RED`                   |       8        |                  |                 |                  |                   |\n| `GL_R8_SNORM`               | `GL_RED`                   |       s8       |                  |                 |                  |                   |\n| `GL_R16`                    | `GL_RED`                   |       16       |                  |                 |                  |                   |\n| `GL_R16_SNORM`              | `GL_RED`                   |      s16       |                  |                 |                  |                   |\n| `GL_RG8`                    | `GL_RG`                    |       8        |        8         |                 |                  |                   |\n| `GL_RG8_SNORM`              | `GL_RG`                    |       s8       |        s8        |                 |                  |                   |\n| `GL_RG16`                   | `GL_RG`                    |       16       |        16        |                 |                  |                   |\n| `GL_RG16_SNORM`             | `GL_RG`                    |      s16       |       s16        |                 |                  |                   |\n| `GL_R3_G3_B2`               | `GL_RGB`                   |       3        |        3         |        2        |                  |                   |\n| `GL_RGB4`                   | `GL_RGB`                   |       4        |        4         |        4        |                  |                   |\n| `GL_RGB5`                   | `GL_RGB`                   |       5        |        5         |        5        |                  |                   |\n| `GL_RGB8`                   | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_RGB8_SNORM`             | `GL_RGB`                   |       s8       |        s8        |       s8        |                  |                   |\n| `GL_RGB10`                  | `GL_RGB`                   |       10       |        10        |       10        |                  |                   |\n| `GL_RGB12`                  | `GL_RGB`                   |       12       |        12        |       12        |                  |                   |\n| `GL_RGB16_SNORM`            | `GL_RGB`                   |       16       |        16        |       16        |                  |                   |\n| `GL_RGBA2`                  | `GL_RGB`                   |       2        |        2         |        2        |        2         |                   |\n| `GL_RGBA4`                  | `GL_RGB`                   |       4        |        4         |        4        |        4         |                   |\n| `GL_RGB5_A1`                | `GL_RGBA`                  |       5        |        5         |        5        |        1         |                   |\n| `GL_RGBA8`                  | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_RGBA8_SNORM`            | `GL_RGBA`                  |       s8       |        s8        |       s8        |        s8        |                   |\n| `GL_RGB10_A2`               | `GL_RGBA`                  |       10       |        10        |       10        |        2         |                   |\n| `GL_RGB10_A2UI`             | `GL_RGBA`                  |      ui10      |       ui10       |      ui10       |       ui2        |                   |\n| `GL_RGBA12`                 | `GL_RGBA`                  |       12       |        12        |       12        |        12        |                   |\n| `GL_RGBA16`                 | `GL_RGBA`                  |       16       |        16        |       16        |        16        |                   |\n| `GL_SRGB8`                  | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_SRGB8_ALPHA8`           | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_R16F`                   | `GL_RED`                   |      f16       |                  |                 |                  |                   |\n| `GL_RG16F`                  | `GL_RG`                    |      f16       |       f16        |                 |                  |                   |\n| `GL_RGB16F`                 | `GL_RGB`                   |      f16       |       f16        |       f16       |                  |                   |\n| `GL_RGBA16F`                | `GL_RGBA`                  |      f16       |       f16        |       f16       |       f16        |                   |\n| `GL_R32F`                   | `GL_RED`                   |      f32       |                  |                 |                  |                   |\n| `GL_RG32F`                  | `GL_RG`                    |      f32       |       f32        |                 |                  |                   |\n| `GL_RGB32F`                 | `GL_RGB`                   |      f32       |       f32        |       f32       |                  |                   |\n| `GL_RGBA32F`                | `GL_RGBA`                  |      f32       |       f32        |       f32       |       f32        |                   |\n| `GL_R11F_G11F_B10F`         | `GL_RGB`                   |      f11       |       f11        |       f10       |                  |                   |\n| `GL_RGB9_E5`                | `GL_RGB`                   |       9        |        9         |        9        |                  |         5         |\n| `GL_R8I`                    | `GL_RED`                   |       i8       |                  |                 |                  |                   |\n| `GL_R8UI`                   | `GL_RED`                   |      ui8       |                  |                 |                  |                   |\n| `GL_R16I`                   | `GL_RED`                   |      i16       |                  |                 |                  |                   |\n| `GL_R16UI`                  | `GL_RED`                   |      ui16      |                  |                 |                  |                   |\n| `GL_R32I`                   | `GL_RED`                   |      i32       |                  |                 |                  |                   |\n| `GL_R32UI`                  | `GL_RED`                   |      ui32      |                  |                 |                  |                   |\n| `GL_RG8I`                   | `GL_RG`                    |       i8       |        i8        |                 |                  |                   |\n| `GL_RG8UI`                  | `GL_RG`                    |      ui8       |       ui8        |                 |                  |                   |\n| `GL_RG16I`                  | `GL_RG`                    |      i16       |       i16        |                 |                  |                   |\n| `GL_RG16UI`                 | `GL_RG`                    |      ui16      |       ui16       |                 |                  |                   |\n| `GL_RG32I`                  | `GL_RG`                    |      i32       |       i32        |                 |                  |                   |\n| `GL_RG32UI`                 | `GL_RG`                    |      ui32      |       ui32       |                 |                  |                   |\n| `GL_RGB8I`                  | `GL_RGB`                   |       i8       |        i8        |       i8        |                  |                   |\n| `GL_RGB8UI`                 | `GL_RGB`                   |      ui8       |       ui8        |       ui8       |                  |                   |\n| `GL_RGB16I`                 | `GL_RGB`                   |      i16       |       i16        |       i16       |                  |                   |\n| `GL_RGB16UI`                | `GL_RGB`                   |      ui16      |       ui16       |      ui16       |                  |                   |\n| `GL_RGB32I`                 | `GL_RGB`                   |      i32       |       i32        |       i32       |                  |                   |\n| `GL_RGB32UI`                | `GL_RGB`                   |      ui32      |       ui32       |      ui32       |                  |                   |\n| `GL_RGBA8I`                 | `GL_RGBA`                  |       i8       |        i8        |       i8        |        i8        |                   |\n| `GL_RGBA8UI`                | `GL_RGBA`                  |      ui8       |       ui8        |       ui8       |       ui8        |                   |\n| `GL_RGBA16I`                | `GL_RGBA`                  |      i16       |       i16        |       i16       |       i16        |                   |\n| `GL_RGBA16UI`               | `GL_RGBA`                  |      ui16      |       ui16       |      ui16       |       ui16       |                   |\n| `GL_RGBA32I`                | `GL_RGBA`                  |      i32       |       i32        |       i32       |       i32        |                   |\n| `GL_RGBA32UI`               | `GL_RGBA`                  |      ui32      |       ui32       |      ui32       |       ui32       |                   |\n\n  \n\n## Notes\n\n`GL_STENCIL_INDEX8` is accepted for *`internalformat`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage2D` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage2D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid sized internal format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`*, *`height`* or *`levels`* are less than 1.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and *`levels`* is greater than ⌊log₂(*w**i**d**t**h*)⌋ + 1.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is not `GL_TEXTURE_1D_ARRAY` or `GL_PROXY_TEXTURE_1D_ARRAY` and *`levels`* is greater than ⌊log₂(max (*w**i**d**t**h*, *h**e**i**g**h**t*))⌋ + 1.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexStorage2D`              |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTextureStorage2D`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glTexImage2D](glteximage2d.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml).\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage2D.xhtml)"
- name: glTextureStorage2DMultisample
  id: gltexstorage2dmultisample.xhtml#glTextureStorage2DMultisample
  summary: Specifies the target to which the texture object is bound for glTexStorage2DMultisample
  belongs_to: glTexStorage2DMultisample
  description: "`void `**`glTextureStorage2DMultisample`**`(` GLuint `texture`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLboolean `fixedsamplelocations``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glTexStorage2DMultisample`. Must be one of `GL_TEXTURE_2D_MULTISAMPLE` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureStorage2DMultisample`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n*`samples`*\n\nSpecify the number of samples in the texture.\n\n*`internalformat`*\n\nSpecifies the sized internal format to be used to store texture image data.\n\n*`width`*\n\nSpecifies the width of the texture, in texels.\n\n*`height`*\n\nSpecifies the height of the texture, in texels.\n\n*`fixedsamplelocations`*\n\nSpecifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\n## Description\n\n`glTexStorage2DMultisample` and `glTextureStorage2DMultisample` specify the storage requirements for a two-dimensional multisample texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\n*`samples`* specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of `GL_MAX_SAMPLES`. *`internalformat`* must be a color-renderable, depth-renderable, or stencil-renderable format. *`width`* and *`height`* specify the width and height, respectively, of the texture. If *`fixedsamplelocations`* is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\nTable 1. Sized Internal Formats\n\n|  **Sized Internal Format**  |  **Base Internal Format**  |  **Red Bits**  |  **Green Bits**  |  **Blue Bits**  |  **Alpha Bits**  |  **Shared Bits**  |\n|:----------------------------|:---------------------------|:--------------:|:----------------:|:---------------:|:----------------:|:-----------------:|\n| `GL_R8`                     | `GL_RED`                   |       8        |                  |                 |                  |                   |\n| `GL_R8_SNORM`               | `GL_RED`                   |       s8       |                  |                 |                  |                   |\n| `GL_R16`                    | `GL_RED`                   |       16       |                  |                 |                  |                   |\n| `GL_R16_SNORM`              | `GL_RED`                   |      s16       |                  |                 |                  |                   |\n| `GL_RG8`                    | `GL_RG`                    |       8        |        8         |                 |                  |                   |\n| `GL_RG8_SNORM`              | `GL_RG`                    |       s8       |        s8        |                 |                  |                   |\n| `GL_RG16`                   | `GL_RG`                    |       16       |        16        |                 |                  |                   |\n| `GL_RG16_SNORM`             | `GL_RG`                    |      s16       |       s16        |                 |                  |                   |\n| `GL_R3_G3_B2`               | `GL_RGB`                   |       3        |        3         |        2        |                  |                   |\n| `GL_RGB4`                   | `GL_RGB`                   |       4        |        4         |        4        |                  |                   |\n| `GL_RGB5`                   | `GL_RGB`                   |       5        |        5         |        5        |                  |                   |\n| `GL_RGB8`                   | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_RGB8_SNORM`             | `GL_RGB`                   |       s8       |        s8        |       s8        |                  |                   |\n| `GL_RGB10`                  | `GL_RGB`                   |       10       |        10        |       10        |                  |                   |\n| `GL_RGB12`                  | `GL_RGB`                   |       12       |        12        |       12        |                  |                   |\n| `GL_RGB16_SNORM`            | `GL_RGB`                   |       16       |        16        |       16        |                  |                   |\n| `GL_RGBA2`                  | `GL_RGB`                   |       2        |        2         |        2        |        2         |                   |\n| `GL_RGBA4`                  | `GL_RGB`                   |       4        |        4         |        4        |        4         |                   |\n| `GL_RGB5_A1`                | `GL_RGBA`                  |       5        |        5         |        5        |        1         |                   |\n| `GL_RGBA8`                  | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_RGBA8_SNORM`            | `GL_RGBA`                  |       s8       |        s8        |       s8        |        s8        |                   |\n| `GL_RGB10_A2`               | `GL_RGBA`                  |       10       |        10        |       10        |        2         |                   |\n| `GL_RGB10_A2UI`             | `GL_RGBA`                  |      ui10      |       ui10       |      ui10       |       ui2        |                   |\n| `GL_RGBA12`                 | `GL_RGBA`                  |       12       |        12        |       12        |        12        |                   |\n| `GL_RGBA16`                 | `GL_RGBA`                  |       16       |        16        |       16        |        16        |                   |\n| `GL_SRGB8`                  | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_SRGB8_ALPHA8`           | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_R16F`                   | `GL_RED`                   |      f16       |                  |                 |                  |                   |\n| `GL_RG16F`                  | `GL_RG`                    |      f16       |       f16        |                 |                  |                   |\n| `GL_RGB16F`                 | `GL_RGB`                   |      f16       |       f16        |       f16       |                  |                   |\n| `GL_RGBA16F`                | `GL_RGBA`                  |      f16       |       f16        |       f16       |       f16        |                   |\n| `GL_R32F`                   | `GL_RED`                   |      f32       |                  |                 |                  |                   |\n| `GL_RG32F`                  | `GL_RG`                    |      f32       |       f32        |                 |                  |                   |\n| `GL_RGB32F`                 | `GL_RGB`                   |      f32       |       f32        |       f32       |                  |                   |\n| `GL_RGBA32F`                | `GL_RGBA`                  |      f32       |       f32        |       f32       |       f32        |                   |\n| `GL_R11F_G11F_B10F`         | `GL_RGB`                   |      f11       |       f11        |       f10       |                  |                   |\n| `GL_RGB9_E5`                | `GL_RGB`                   |       9        |        9         |        9        |                  |         5         |\n| `GL_R8I`                    | `GL_RED`                   |       i8       |                  |                 |                  |                   |\n| `GL_R8UI`                   | `GL_RED`                   |      ui8       |                  |                 |                  |                   |\n| `GL_R16I`                   | `GL_RED`                   |      i16       |                  |                 |                  |                   |\n| `GL_R16UI`                  | `GL_RED`                   |      ui16      |                  |                 |                  |                   |\n| `GL_R32I`                   | `GL_RED`                   |      i32       |                  |                 |                  |                   |\n| `GL_R32UI`                  | `GL_RED`                   |      ui32      |                  |                 |                  |                   |\n| `GL_RG8I`                   | `GL_RG`                    |       i8       |        i8        |                 |                  |                   |\n| `GL_RG8UI`                  | `GL_RG`                    |      ui8       |       ui8        |                 |                  |                   |\n| `GL_RG16I`                  | `GL_RG`                    |      i16       |       i16        |                 |                  |                   |\n| `GL_RG16UI`                 | `GL_RG`                    |      ui16      |       ui16       |                 |                  |                   |\n| `GL_RG32I`                  | `GL_RG`                    |      i32       |       i32        |                 |                  |                   |\n| `GL_RG32UI`                 | `GL_RG`                    |      ui32      |       ui32       |                 |                  |                   |\n| `GL_RGB8I`                  | `GL_RGB`                   |       i8       |        i8        |       i8        |                  |                   |\n| `GL_RGB8UI`                 | `GL_RGB`                   |      ui8       |       ui8        |       ui8       |                  |                   |\n| `GL_RGB16I`                 | `GL_RGB`                   |      i16       |       i16        |       i16       |                  |                   |\n| `GL_RGB16UI`                | `GL_RGB`                   |      ui16      |       ui16       |      ui16       |                  |                   |\n| `GL_RGB32I`                 | `GL_RGB`                   |      i32       |       i32        |       i32       |                  |                   |\n| `GL_RGB32UI`                | `GL_RGB`                   |      ui32      |       ui32       |      ui32       |                  |                   |\n| `GL_RGBA8I`                 | `GL_RGBA`                  |       i8       |        i8        |       i8        |        i8        |                   |\n| `GL_RGBA8UI`                | `GL_RGBA`                  |      ui8       |       ui8        |       ui8       |       ui8        |                   |\n| `GL_RGBA16I`                | `GL_RGBA`                  |      i16       |       i16        |       i16       |       i16        |                   |\n| `GL_RGBA16UI`               | `GL_RGBA`                  |      ui16      |       ui16       |      ui16       |       ui16       |                   |\n| `GL_RGBA32I`                | `GL_RGBA`                  |      i32       |       i32        |       i32       |       i32        |                   |\n| `GL_RGBA32UI`               | `GL_RGBA`                  |      ui32      |       ui32       |      ui32       |       ui32       |                   |\n\n  \n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage2DMultisample` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage2DMultisample` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid color-renderable, depth-renderable or stencil-renderable format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`* or *`height`* are less than 1 or greater than the value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`levels`* is less than 1.\n\n`GL_INVALID_VALUE` is generated if *`samples`* is zero.\n\n`GL_INVALID_OPERATION` is generated if *`samples`* is greater than the maximum number of samples supported for this *`target`* and *`internalformat`*.\n\n`GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for the texture bound to *`target`* is not `GL_FALSE`.\n\n## Version Support\n\n|                                 |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**    |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexStorage2DMultisample`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glTextureStorage2DMultisample` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glTexImage2D](glteximage2d.xhtml), [glTexImage2DMultisample](glteximage2dmultisample.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage2DMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage2DMultisample.xhtml)"
- name: glTextureStorage3D
  id: gltexstorage3d.xhtml#glTextureStorage3D
  summary: Specifies the target to which the texture object is bound for glTexStorage3D
  belongs_to: glTexStorage3D
  description: "`void `**`glTextureStorage3D`**`(` GLuint `texture`, GLsizei `levels`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLsizei `depth``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glTexStorage3D`. Must be one of `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, `GL_PROXY_TEXTURE_3D`, `GL_PROXY_TEXTURE_2D_ARRAY` or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureStorage3D`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n*`levels`*\n\nSpecify the number of texture levels.\n\n*`internalformat`*\n\nSpecifies the sized internal format to be used to store texture image data.\n\n*`width`*\n\nSpecifies the width of the texture, in texels.\n\n*`height`*\n\nSpecifies the height of the texture, in texels.\n\n*`depth`*\n\nSpecifies the depth of the texture, in texels.\n\n## Description\n\n`glTexStorage3D` and `glTextureStorage3D` specify the storage requirements for all levels of a three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\nThe behavior of `glTexStorage3D` depends on the *`target`* parameter. When *`target`* is `GL_TEXTURE_3D`, or `GL_PROXY_TEXTURE_3D`, calling `glTexStorage3D` is equivalent, assuming no errors are generated, to executing the following pseudo-code:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);\n        width = max(1, (width / 2));\n        height = max(1, (height / 2));\n        depth = max(1, (depth / 2));\n    }\n```\n\nWhen *`target`* is `GL_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY`, or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY`, `glTexStorage3D` is equivalent to:\n\n``` programlisting\n    for (i = 0; i < levels; i++) {\n        glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);\n        width = max(1, (width / 2));\n        height = max(1, (height / 2));\n    }\n```\n\nCalling `glTextureStorage3D` is equivalent to the above pseudo-code, where *`target`* is the effective target of *`texture`* and it is as if *`texture`* were bound to *`target`* for the purposes of `glTexImage3D`.\n\nSince no texture data is actually provided, the values used in the pseudo-code for *`format`* and *`type`* are irrelevant and may be considered to be any values that are legal for the chosen *`internalformat`* enumerant. *`internalformat`* must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats `GL_DEPTH_COMPONENT32F`, `GL_DEPTH_COMPONENT24`, or `GL_DEPTH_COMPONENT16`, one of the combined depth-stencil formats, `GL_DEPTH32F_STENCIL8`, or `GL_DEPTH24_STENCIL8`, or the stencil-only format, `GL_STENCIL_INDEX8`. Upon success, the value of `GL_TEXTURE_IMMUTABLE_FORMAT` becomes `GL_TRUE`. The value of `GL_TEXTURE_IMMUTABLE_FORMAT` may be discovered by calling [glGetTexParameter](glgettexparameter.xhtml) with *`pname`* set to `GL_TEXTURE_IMMUTABLE_FORMAT`. No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as [glTexImage3D](glteximage3d.xhtml) or another call to `glTexStorage3D`) will result in the generation of a `GL_INVALID_OPERATION` error, even if it would not, in fact, alter the dimensions or format of the object.\n\nTable 1. Sized Internal Formats\n\n|  **Sized Internal Format**  |  **Base Internal Format**  |  **Red Bits**  |  **Green Bits**  |  **Blue Bits**  |  **Alpha Bits**  |  **Shared Bits**  |\n|:----------------------------|:---------------------------|:--------------:|:----------------:|:---------------:|:----------------:|:-----------------:|\n| `GL_R8`                     | `GL_RED`                   |       8        |                  |                 |                  |                   |\n| `GL_R8_SNORM`               | `GL_RED`                   |       s8       |                  |                 |                  |                   |\n| `GL_R16`                    | `GL_RED`                   |       16       |                  |                 |                  |                   |\n| `GL_R16_SNORM`              | `GL_RED`                   |      s16       |                  |                 |                  |                   |\n| `GL_RG8`                    | `GL_RG`                    |       8        |        8         |                 |                  |                   |\n| `GL_RG8_SNORM`              | `GL_RG`                    |       s8       |        s8        |                 |                  |                   |\n| `GL_RG16`                   | `GL_RG`                    |       16       |        16        |                 |                  |                   |\n| `GL_RG16_SNORM`             | `GL_RG`                    |      s16       |       s16        |                 |                  |                   |\n| `GL_R3_G3_B2`               | `GL_RGB`                   |       3        |        3         |        2        |                  |                   |\n| `GL_RGB4`                   | `GL_RGB`                   |       4        |        4         |        4        |                  |                   |\n| `GL_RGB5`                   | `GL_RGB`                   |       5        |        5         |        5        |                  |                   |\n| `GL_RGB8`                   | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_RGB8_SNORM`             | `GL_RGB`                   |       s8       |        s8        |       s8        |                  |                   |\n| `GL_RGB10`                  | `GL_RGB`                   |       10       |        10        |       10        |                  |                   |\n| `GL_RGB12`                  | `GL_RGB`                   |       12       |        12        |       12        |                  |                   |\n| `GL_RGB16_SNORM`            | `GL_RGB`                   |       16       |        16        |       16        |                  |                   |\n| `GL_RGBA2`                  | `GL_RGB`                   |       2        |        2         |        2        |        2         |                   |\n| `GL_RGBA4`                  | `GL_RGB`                   |       4        |        4         |        4        |        4         |                   |\n| `GL_RGB5_A1`                | `GL_RGBA`                  |       5        |        5         |        5        |        1         |                   |\n| `GL_RGBA8`                  | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_RGBA8_SNORM`            | `GL_RGBA`                  |       s8       |        s8        |       s8        |        s8        |                   |\n| `GL_RGB10_A2`               | `GL_RGBA`                  |       10       |        10        |       10        |        2         |                   |\n| `GL_RGB10_A2UI`             | `GL_RGBA`                  |      ui10      |       ui10       |      ui10       |       ui2        |                   |\n| `GL_RGBA12`                 | `GL_RGBA`                  |       12       |        12        |       12        |        12        |                   |\n| `GL_RGBA16`                 | `GL_RGBA`                  |       16       |        16        |       16        |        16        |                   |\n| `GL_SRGB8`                  | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_SRGB8_ALPHA8`           | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_R16F`                   | `GL_RED`                   |      f16       |                  |                 |                  |                   |\n| `GL_RG16F`                  | `GL_RG`                    |      f16       |       f16        |                 |                  |                   |\n| `GL_RGB16F`                 | `GL_RGB`                   |      f16       |       f16        |       f16       |                  |                   |\n| `GL_RGBA16F`                | `GL_RGBA`                  |      f16       |       f16        |       f16       |       f16        |                   |\n| `GL_R32F`                   | `GL_RED`                   |      f32       |                  |                 |                  |                   |\n| `GL_RG32F`                  | `GL_RG`                    |      f32       |       f32        |                 |                  |                   |\n| `GL_RGB32F`                 | `GL_RGB`                   |      f32       |       f32        |       f32       |                  |                   |\n| `GL_RGBA32F`                | `GL_RGBA`                  |      f32       |       f32        |       f32       |       f32        |                   |\n| `GL_R11F_G11F_B10F`         | `GL_RGB`                   |      f11       |       f11        |       f10       |                  |                   |\n| `GL_RGB9_E5`                | `GL_RGB`                   |       9        |        9         |        9        |                  |         5         |\n| `GL_R8I`                    | `GL_RED`                   |       i8       |                  |                 |                  |                   |\n| `GL_R8UI`                   | `GL_RED`                   |      ui8       |                  |                 |                  |                   |\n| `GL_R16I`                   | `GL_RED`                   |      i16       |                  |                 |                  |                   |\n| `GL_R16UI`                  | `GL_RED`                   |      ui16      |                  |                 |                  |                   |\n| `GL_R32I`                   | `GL_RED`                   |      i32       |                  |                 |                  |                   |\n| `GL_R32UI`                  | `GL_RED`                   |      ui32      |                  |                 |                  |                   |\n| `GL_RG8I`                   | `GL_RG`                    |       i8       |        i8        |                 |                  |                   |\n| `GL_RG8UI`                  | `GL_RG`                    |      ui8       |       ui8        |                 |                  |                   |\n| `GL_RG16I`                  | `GL_RG`                    |      i16       |       i16        |                 |                  |                   |\n| `GL_RG16UI`                 | `GL_RG`                    |      ui16      |       ui16       |                 |                  |                   |\n| `GL_RG32I`                  | `GL_RG`                    |      i32       |       i32        |                 |                  |                   |\n| `GL_RG32UI`                 | `GL_RG`                    |      ui32      |       ui32       |                 |                  |                   |\n| `GL_RGB8I`                  | `GL_RGB`                   |       i8       |        i8        |       i8        |                  |                   |\n| `GL_RGB8UI`                 | `GL_RGB`                   |      ui8       |       ui8        |       ui8       |                  |                   |\n| `GL_RGB16I`                 | `GL_RGB`                   |      i16       |       i16        |       i16       |                  |                   |\n| `GL_RGB16UI`                | `GL_RGB`                   |      ui16      |       ui16       |      ui16       |                  |                   |\n| `GL_RGB32I`                 | `GL_RGB`                   |      i32       |       i32        |       i32       |                  |                   |\n| `GL_RGB32UI`                | `GL_RGB`                   |      ui32      |       ui32       |      ui32       |                  |                   |\n| `GL_RGBA8I`                 | `GL_RGBA`                  |       i8       |        i8        |       i8        |        i8        |                   |\n| `GL_RGBA8UI`                | `GL_RGBA`                  |      ui8       |       ui8        |       ui8       |       ui8        |                   |\n| `GL_RGBA16I`                | `GL_RGBA`                  |      i16       |       i16        |       i16       |       i16        |                   |\n| `GL_RGBA16UI`               | `GL_RGBA`                  |      ui16      |       ui16       |      ui16       |       ui16       |                   |\n| `GL_RGBA32I`                | `GL_RGBA`                  |      i32       |       i32        |       i32       |       i32        |                   |\n| `GL_RGBA32UI`               | `GL_RGBA`                  |      ui32      |       ui32       |      ui32       |       ui32       |                   |\n\n  \n\n## Notes\n\n`GL_STENCIL_INDEX8` is accepted for *`internalformat`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage3D` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage3D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid sized internal format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`*, *`height`*, *`depth`* or *`levels`* are less than 1.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is `GL_TEXTURE_3D` or `GL_PROXY_TEXTURE_3D` and *`levels`* is greater than ⌊log₂(max (*w**i**d**t**h*, *h**e**i**g**h**t*, *d**e**p**t**h*))⌋ + 1.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is `GL_TEXTURE_2D_ARRAY`, `GL_PROXY_TEXTURE_2D_ARRAY`, `GL_TEXURE_CUBE_MAP_ARRAY`, or `GL_PROXY_TEXTURE_CUBE_MAP_ARRAY` and *`levels`* is greater than ⌊log₂(max (*w**i**d**t**h*, *h**e**i**g**h**t*))⌋ + 1.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexStorage3D`              |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTextureStorage3D`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glTexImage3D](glteximage3d.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml).\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage3D.xhtml)"
- name: glTextureStorage3DMultisample
  id: gltexstorage3dmultisample.xhtml#glTextureStorage3DMultisample
  summary: Specifies the target to which the texture object is bound for glTexStorage3DMultisample
  belongs_to: glTexStorage3DMultisample
  description: "`void `**`glTextureStorage3DMultisample`**`(` GLuint `texture`, GLsizei `samples`, GLenum `internalformat`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLboolean `fixedsamplelocations``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture object is bound for `glTexStorage3DMultisample`. Must be one of `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` or `GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureStorage3DMultisample`. The effective target of *`texture`* must be one of the valid non-proxy *`target`* values above.\n\n*`samples`*\n\nSpecify the number of samples in the texture.\n\n*`internalformat`*\n\nSpecifies the sized internal format to be used to store texture image data.\n\n*`width`*\n\nSpecifies the width of the texture, in texels.\n\n*`height`*\n\nSpecifies the height of the texture, in texels.\n\n*`depth`*\n\nSpecifies the depth of the texture, in layers.\n\n*`fixedsamplelocations`*\n\nSpecifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\n## Description\n\n`glTexStorage3DMultisample` and `glTextureStorage3DMultisample` specify the storage requirements for a two-dimensional multisample array texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an *immutable-format* texture.\n\n*`samples`* specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of `GL_MAX_SAMPLES`. *`internalformat`* must be a color-renderable, depth-renderable, or stencil-renderable format. *`width`* and *`height`* specify the width and height, respectively, of the texture and *`depth`* specifies the depth (or the number of layers) of the texture. If *`fixedsamplelocations`* is `GL_TRUE`, the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.\n\nTable 1. Sized Internal Formats\n\n|  **Sized Internal Format**  |  **Base Internal Format**  |  **Red Bits**  |  **Green Bits**  |  **Blue Bits**  |  **Alpha Bits**  |  **Shared Bits**  |\n|:----------------------------|:---------------------------|:--------------:|:----------------:|:---------------:|:----------------:|:-----------------:|\n| `GL_R8`                     | `GL_RED`                   |       8        |                  |                 |                  |                   |\n| `GL_R8_SNORM`               | `GL_RED`                   |       s8       |                  |                 |                  |                   |\n| `GL_R16`                    | `GL_RED`                   |       16       |                  |                 |                  |                   |\n| `GL_R16_SNORM`              | `GL_RED`                   |      s16       |                  |                 |                  |                   |\n| `GL_RG8`                    | `GL_RG`                    |       8        |        8         |                 |                  |                   |\n| `GL_RG8_SNORM`              | `GL_RG`                    |       s8       |        s8        |                 |                  |                   |\n| `GL_RG16`                   | `GL_RG`                    |       16       |        16        |                 |                  |                   |\n| `GL_RG16_SNORM`             | `GL_RG`                    |      s16       |       s16        |                 |                  |                   |\n| `GL_R3_G3_B2`               | `GL_RGB`                   |       3        |        3         |        2        |                  |                   |\n| `GL_RGB4`                   | `GL_RGB`                   |       4        |        4         |        4        |                  |                   |\n| `GL_RGB5`                   | `GL_RGB`                   |       5        |        5         |        5        |                  |                   |\n| `GL_RGB8`                   | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_RGB8_SNORM`             | `GL_RGB`                   |       s8       |        s8        |       s8        |                  |                   |\n| `GL_RGB10`                  | `GL_RGB`                   |       10       |        10        |       10        |                  |                   |\n| `GL_RGB12`                  | `GL_RGB`                   |       12       |        12        |       12        |                  |                   |\n| `GL_RGB16_SNORM`            | `GL_RGB`                   |       16       |        16        |       16        |                  |                   |\n| `GL_RGBA2`                  | `GL_RGB`                   |       2        |        2         |        2        |        2         |                   |\n| `GL_RGBA4`                  | `GL_RGB`                   |       4        |        4         |        4        |        4         |                   |\n| `GL_RGB5_A1`                | `GL_RGBA`                  |       5        |        5         |        5        |        1         |                   |\n| `GL_RGBA8`                  | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_RGBA8_SNORM`            | `GL_RGBA`                  |       s8       |        s8        |       s8        |        s8        |                   |\n| `GL_RGB10_A2`               | `GL_RGBA`                  |       10       |        10        |       10        |        2         |                   |\n| `GL_RGB10_A2UI`             | `GL_RGBA`                  |      ui10      |       ui10       |      ui10       |       ui2        |                   |\n| `GL_RGBA12`                 | `GL_RGBA`                  |       12       |        12        |       12        |        12        |                   |\n| `GL_RGBA16`                 | `GL_RGBA`                  |       16       |        16        |       16        |        16        |                   |\n| `GL_SRGB8`                  | `GL_RGB`                   |       8        |        8         |        8        |                  |                   |\n| `GL_SRGB8_ALPHA8`           | `GL_RGBA`                  |       8        |        8         |        8        |        8         |                   |\n| `GL_R16F`                   | `GL_RED`                   |      f16       |                  |                 |                  |                   |\n| `GL_RG16F`                  | `GL_RG`                    |      f16       |       f16        |                 |                  |                   |\n| `GL_RGB16F`                 | `GL_RGB`                   |      f16       |       f16        |       f16       |                  |                   |\n| `GL_RGBA16F`                | `GL_RGBA`                  |      f16       |       f16        |       f16       |       f16        |                   |\n| `GL_R32F`                   | `GL_RED`                   |      f32       |                  |                 |                  |                   |\n| `GL_RG32F`                  | `GL_RG`                    |      f32       |       f32        |                 |                  |                   |\n| `GL_RGB32F`                 | `GL_RGB`                   |      f32       |       f32        |       f32       |                  |                   |\n| `GL_RGBA32F`                | `GL_RGBA`                  |      f32       |       f32        |       f32       |       f32        |                   |\n| `GL_R11F_G11F_B10F`         | `GL_RGB`                   |      f11       |       f11        |       f10       |                  |                   |\n| `GL_RGB9_E5`                | `GL_RGB`                   |       9        |        9         |        9        |                  |         5         |\n| `GL_R8I`                    | `GL_RED`                   |       i8       |                  |                 |                  |                   |\n| `GL_R8UI`                   | `GL_RED`                   |      ui8       |                  |                 |                  |                   |\n| `GL_R16I`                   | `GL_RED`                   |      i16       |                  |                 |                  |                   |\n| `GL_R16UI`                  | `GL_RED`                   |      ui16      |                  |                 |                  |                   |\n| `GL_R32I`                   | `GL_RED`                   |      i32       |                  |                 |                  |                   |\n| `GL_R32UI`                  | `GL_RED`                   |      ui32      |                  |                 |                  |                   |\n| `GL_RG8I`                   | `GL_RG`                    |       i8       |        i8        |                 |                  |                   |\n| `GL_RG8UI`                  | `GL_RG`                    |      ui8       |       ui8        |                 |                  |                   |\n| `GL_RG16I`                  | `GL_RG`                    |      i16       |       i16        |                 |                  |                   |\n| `GL_RG16UI`                 | `GL_RG`                    |      ui16      |       ui16       |                 |                  |                   |\n| `GL_RG32I`                  | `GL_RG`                    |      i32       |       i32        |                 |                  |                   |\n| `GL_RG32UI`                 | `GL_RG`                    |      ui32      |       ui32       |                 |                  |                   |\n| `GL_RGB8I`                  | `GL_RGB`                   |       i8       |        i8        |       i8        |                  |                   |\n| `GL_RGB8UI`                 | `GL_RGB`                   |      ui8       |       ui8        |       ui8       |                  |                   |\n| `GL_RGB16I`                 | `GL_RGB`                   |      i16       |       i16        |       i16       |                  |                   |\n| `GL_RGB16UI`                | `GL_RGB`                   |      ui16      |       ui16       |      ui16       |                  |                   |\n| `GL_RGB32I`                 | `GL_RGB`                   |      i32       |       i32        |       i32       |                  |                   |\n| `GL_RGB32UI`                | `GL_RGB`                   |      ui32      |       ui32       |      ui32       |                  |                   |\n| `GL_RGBA8I`                 | `GL_RGBA`                  |       i8       |        i8        |       i8        |        i8        |                   |\n| `GL_RGBA8UI`                | `GL_RGBA`                  |      ui8       |       ui8        |       ui8       |       ui8        |                   |\n| `GL_RGBA16I`                | `GL_RGBA`                  |      i16       |       i16        |       i16       |       i16        |                   |\n| `GL_RGBA16UI`               | `GL_RGBA`                  |      ui16      |       ui16       |      ui16       |       ui16       |                   |\n| `GL_RGBA32I`                | `GL_RGBA`                  |      i32       |       i32        |       i32       |       i32        |                   |\n| `GL_RGBA32UI`               | `GL_RGBA`                  |      ui32      |       ui32       |      ui32       |       ui32       |                   |\n\n  \n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glTexStorage3DMultisample` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glTextureStorage3DMultisample` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`internalformat`* is not a valid color-renderable, depth-renderable or stencil-renderable format.\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the accepted targets described above.\n\n`GL_INVALID_VALUE` is generated if *`width`* or *`height`* are less than 1 or greater than the value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *`depth`* is less than 1 or greater than the value of `GL_MAX_ARRAY_TEXTURE_LAYERS`.\n\n`GL_INVALID_VALUE` is generated if *`levels`* is less than 1.\n\n`GL_INVALID_VALUE` is generated if *`samples`* is zero.\n\n`GL_INVALID_OPERATION` is generated if *`samples`* is greater than the maximum number of samples supported for this *`target`* and *`internalformat`*.\n\n`GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for the texture bound to *`target`* is not `GL_FALSE`.\n\n## Associated Gets\n\n`glGetInteger` with arguments `GL_MAX_TEXTURE_SIZE`, `GL_MAX_ARRAY_TEXTURE_LEVELS`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_NUM_LAYERS`, or `GL_TEXTURE_IMMUTABLE_LEVELS`.\n\n## Version Support\n\n|                                 |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:--------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**    |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexStorage3DMultisample`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glTextureStorage3DMultisample` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glTexImage3D](glteximage3d.xhtml), [glTexImage3DMultisample](glteximage3dmultisample.xhtml), [glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2DMultisample](gltexstorage2dmultisample.xhtml), [glTexStorage3D](gltexstorage3d.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage3DMultisample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexStorage3DMultisample.xhtml)"
- name: glTextureSubImage1D
  id: gltexsubimage1d.xhtml#glTextureSubImage1D
  summary: Specifies the target to which the texture is bound for glTexSubImage1D
  belongs_to: glTexSubImage1D
  description: "`void `**`glTextureSubImage1D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLsizei `width`, GLenum `format`, GLenum `type`, const void \\*`pixels``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glTexSubImage1D`. Must be `GL_TEXTURE_1D`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureSubImage1D`. The effective target of *`texture`* must be one of the valid *`target`* values above.\n\n*`level`*\n\nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`xoffset`*\n\nSpecifies a texel offset in the x direction within the texture array.\n\n*`width`*\n\nSpecifies the width of the texture subimage.\n\n*`format`*\n\nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`.\n\n*`type`*\n\nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n*`pixels`*\n\nSpecifies a pointer to the image data in memory.\n\n## Description\n\nTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable or disable one-dimensional texturing, call [glEnable](glenable.xhtml) and `glDisable` with argument `GL_TEXTURE_1D`.\n\n`glTexSubImage1D` and `glTextureSubImage1D` redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by *`pixels`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\n## Notes\n\n[glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n`glTexSubImage1D` and `glTextureSubImage1D` specify a one-dimensional subtexture for the current texture unit, specified with [glActiveTexture](glactivetexture.xhtml).\n\n`GL_STENCIL_INDEX` is accepted for *`format`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not one of the allowable values.\n\n`GL_INVALID_OPERATION` is generated by `glTextureSubImage1D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`format`* is not an accepted format constant.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not a type constant.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂ *max*, where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< −*b*, or if (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> (*w* − *b*), where *w* is the `GL_TEXTURE_WIDTH`, and *b* is the width of the `GL_TEXTURE_BORDER` of the texture image being modified. Note that *w* includes twice the border width.\n\n`GL_INVALID_VALUE` is generated if *`width`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage1D](glteximage1d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and *`pixels`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n## Associated Gets\n\n[ glGetTexImage ](glgetteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexSubImage1D`             |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTextureSubImage1D`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexParameter](gltexparameter.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage1D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage1D.xhtml)"
- name: glTextureSubImage2D
  id: gltexsubimage2d.xhtml#glTextureSubImage2D
  summary: Specifies the target to which the texture is bound for glTexSubImage2D
  belongs_to: glTexSubImage2D
  description: "`void `**`glTextureSubImage2D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLsizei `width`, GLsizei `height`, GLenum `format`, GLenum `type`, const void \\*`pixels``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glTexSubImage2D`. Must be `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_1D_ARRAY`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureSubImage2D`. The effective target of *`texture`* must be one of the valid *`target`* values above.\n\n*`level`*\n\nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`xoffset`*\n\nSpecifies a texel offset in the x direction within the texture array.\n\n*`yoffset`*\n\nSpecifies a texel offset in the y direction within the texture array.\n\n*`width`*\n\nSpecifies the width of the texture subimage.\n\n*`height`*\n\nSpecifies the height of the texture subimage.\n\n*`format`*\n\nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_BGRA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`.\n\n*`type`*\n\nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n*`pixels`*\n\nSpecifies a pointer to the image data in memory.\n\n## Description\n\nTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.\n\n`glTexSubImage2D` and `glTextureSubImage2D` redefine a contiguous subregion of an existing two-dimensional or one-dimensional array texture image. The texels referenced by *`pixels`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive, and y indices *`yoffset`* and *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\n## Notes\n\n[glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n`glTexSubImage2D` and `glTextureSubImage3D` specify a two-dimensional subtexture for the current texture unit, specified with [glActiveTexture](glactivetexture.xhtml).\n\n`GL_STENCIL_INDEX` is accepted for *`format`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not `GL_TEXTURE_2D`, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_X`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Y`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`, `GL_TEXTURE_CUBE_MAP_POSITIVE_Z`, `GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`, or `GL_TEXTURE_1D_ARRAY`.\n\n`GL_INVALID_OPERATION` is generated by `glTextureSubImage2D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`format`* is not an accepted format constant.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not a type constant.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂ *max*, where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< −*b*, (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> (*w* − *b*), *y**o**f**f**s**e**t* \\< −*b*, or (*y**o**f**f**s**e**t* + *h**e**i**g**h**t*) \\> (*h* − *b*), where *w* is the `GL_TEXTURE_WIDTH`, *h* is the `GL_TEXTURE_HEIGHT`, and *b* is the border width of the texture image being modified. Note that *w* and *h* include twice the border width.\n\n`GL_INVALID_VALUE` is generated if *`width`* or *`height`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage2D](glteximage2d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and *`pixels`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n## Associated Gets\n\n[ glGetTexImage ](glgetteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexSubImage2D`             |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTextureSubImage2D`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage3D](gltexsubimage3d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage2D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage2D.xhtml)"
- name: glTextureSubImage3D
  id: gltexsubimage3d.xhtml#glTextureSubImage3D
  summary: Specifies the target to which the texture is bound for glTexSubImage3D
  belongs_to: glTexSubImage3D
  description: "`void `**`glTextureSubImage3D`**`(` GLuint `texture`, GLint `level`, GLint `xoffset`, GLint `yoffset`, GLint `zoffset`, GLsizei `width`, GLsizei `height`, GLsizei `depth`, GLenum `format`, GLenum `type`, const void \\*`pixels``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the texture is bound for `glTexSubImage3D`. Must be `GL_TEXTURE_3D` or `GL_TEXTURE_2D_ARRAY`.\n\n*`texture`*\n\nSpecifies the texture object name for `glTextureSubImage3D`. The effective target of *`texture`* must be one of the valid *`target`* values above.\n\n*`level`*\n\nSpecifies the level-of-detail number. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.\n\n*`xoffset`*\n\nSpecifies a texel offset in the x direction within the texture array.\n\n*`yoffset`*\n\nSpecifies a texel offset in the y direction within the texture array.\n\n*`zoffset`*\n\nSpecifies a texel offset in the z direction within the texture array.\n\n*`width`*\n\nSpecifies the width of the texture subimage.\n\n*`height`*\n\nSpecifies the height of the texture subimage.\n\n*`depth`*\n\nSpecifies the depth of the texture subimage.\n\n*`format`*\n\nSpecifies the format of the pixel data. The following symbolic values are accepted: `GL_RED`, `GL_RG`, `GL_RGB`, `GL_BGR`, `GL_RGBA`, `GL_DEPTH_COMPONENT`, and `GL_STENCIL_INDEX`.\n\n*`type`*\n\nSpecifies the data type of the pixel data. The following symbolic values are accepted: `GL_UNSIGNED_BYTE`, `GL_BYTE`, `GL_UNSIGNED_SHORT`, `GL_SHORT`, `GL_UNSIGNED_INT`, `GL_INT`, `GL_FLOAT`, `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, `GL_UNSIGNED_SHORT_5_6_5_REV`, `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, and `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n*`pixels`*\n\nSpecifies a pointer to the image data in memory.\n\n## Description\n\nTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.\n\n`glTexSubImage3D` and `glTextureSubImage3D` redefine a contiguous subregion of an existing three-dimensional or two-dimensioanl array texture image. The texels referenced by *`pixels`* replace the portion of the existing texture array with x indices *`xoffset`* and *x**o**f**f**s**e**t* + *w**i**d**t**h* − 1, inclusive, y indices *`yoffset`* and *y**o**f**f**s**e**t* + *h**e**i**g**h**t* − 1, inclusive, and z indices *`zoffset`* and *z**o**f**f**s**e**t* + *d**e**p**t**h* − 1, inclusive. For three-dimensional textures, the z index refers to the third dimension. For two-dimensional array textures, the z index refers to the slice index. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width, height, or depth but such a specification has no effect.\n\nIf a non-zero named buffer object is bound to the `GL_PIXEL_UNPACK_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)) while a texture image is specified, *`pixels`* is treated as a byte offset into the buffer object's data store.\n\n## Notes\n\nThe [glPixelStore](glpixelstore.xhtml) modes affect texture images.\n\n`glTexSubImage3D` and `glTextureSubImage3D` specify a three-dimensional or two-dimensional array subtexture for the current texture unit, specified with [glActiveTexture](glactivetexture.xhtml).\n\n`GL_STENCIL_INDEX` is accepted for *`format`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated if *`target`* or the effective target of *`texture`* is not `GL_TEXTURE_3D`, `GL_TEXTURE_2D_ARRAY` or `GL_TEXTURE_CUBE_MAP_ARRAY`.\n\n`GL_INVALID_OPERATION` is generated by `glTextureSubImage3D` if *`texture`* is not the name of an existing texture object.\n\n`GL_INVALID_ENUM` is generated if *`format`* is not an accepted format constant.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not a type constant.\n\n`GL_INVALID_VALUE` is generated if *`level`* is less than 0.\n\n`GL_INVALID_VALUE` may be generated if *`level`* is greater than *log* ₂ *max*, where *max* is the returned value of `GL_MAX_TEXTURE_SIZE`.\n\n`GL_INVALID_VALUE` is generated if *x**o**f**f**s**e**t* \\< −*b*, (*x**o**f**f**s**e**t* + *w**i**d**t**h*) \\> (*w* − *b*), *y**o**f**f**s**e**t* \\< −*b*, or (*y**o**f**f**s**e**t* + *h**e**i**g**h**t*) \\> (*h* − *b*), or *z**o**f**f**s**e**t* \\< −*b*, or (*z**o**f**f**s**e**t* + *d**e**p**t**h*) \\> (*d* − *b*), where *w* is the `GL_TEXTURE_WIDTH`, *h* is the `GL_TEXTURE_HEIGHT`, *d* is the `GL_TEXTURE_DEPTH` and *b* is the border width of the texture image being modified. Note that *w*, *h*, and *d* include twice the border width.\n\n`GL_INVALID_VALUE` is generated if *`width`*, *`height`*, or *`depth`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if the texture array has not been defined by a previous [glTexImage3D](glteximage3d.xhtml) or [glTexStorage3D](gltexstorage3d.xhtml) operation.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_BYTE_3_3_2`, `GL_UNSIGNED_BYTE_2_3_3_REV`, `GL_UNSIGNED_SHORT_5_6_5`, or `GL_UNSIGNED_SHORT_5_6_5_REV` and *`format`* is not `GL_RGB`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is one of `GL_UNSIGNED_SHORT_4_4_4_4`, `GL_UNSIGNED_SHORT_4_4_4_4_REV`, `GL_UNSIGNED_SHORT_5_5_5_1`, `GL_UNSIGNED_SHORT_1_5_5_5_REV`, `GL_UNSIGNED_INT_8_8_8_8`, `GL_UNSIGNED_INT_8_8_8_8_REV`, `GL_UNSIGNED_INT_10_10_10_2`, or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`format`* is neither `GL_RGBA` nor `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`format`* is `GL_STENCIL_INDEX` and the base internal format is not `GL_STENCIL_INDEX`.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the buffer object's data store is currently mapped.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size.\n\n`GL_INVALID_OPERATION` is generated if a non-zero buffer object name is bound to the `GL_PIXEL_UNPACK_BUFFER` target and *`pixels`* is not evenly divisible into the number of bytes needed to store in memory a datum indicated by *`type`*.\n\n## Associated Gets\n\n[ glGetTexImage ](glgetteximage.xhtml)\n\n[glGet](glget.xhtml) with argument `GL_PIXEL_UNPACK_BUFFER_BINDING`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glTexSubImage3D`             |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glTextureSubImage3D`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glActiveTexture](glactivetexture.xhtml), [glCopyTexImage1D](glcopyteximage1d.xhtml), [glCopyTexImage2D](glcopyteximage2d.xhtml), [glCopyTexSubImage1D](glcopytexsubimage1d.xhtml), [glCopyTexSubImage2D](glcopytexsubimage2d.xhtml), [glCopyTexSubImage3D](glcopytexsubimage3d.xhtml), [glPixelStore](glpixelstore.xhtml), [glTexImage1D](glteximage1d.xhtml), [glTexImage2D](glteximage2d.xhtml), [glTexImage3D](glteximage3d.xhtml), [glTexSubImage1D](gltexsubimage1d.xhtml), [glTexSubImage2D](gltexsubimage2d.xhtml), [glTexParameter](gltexparameter.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage3D.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTexSubImage3D.xhtml)"
- name: glTextureView
  id: gltextureview.xhtml
  summary: texture Specifies the texture object to be initialized as a view
  description: "## Name\n\nglTextureView — initialize a texture as a data alias of another texture's data store\n\n## C Specification\n\n`void `**`glTextureView`**`(` GLuint `texture`, GLenum `target`, GLuint `origtexture`, GLenum `internalformat`, GLuint `minlevel`, GLuint `numlevels`, GLuint `minlayer`, GLuint `numlayers``)`;\n\n## Parameters\n\n *`texture`*  \nSpecifies the texture object to be initialized as a view.\n\n *`target`*  \nSpecifies the target to be used for the newly initialized texture.\n\n *`origtexture`*  \nSpecifies the name of a texture object of which to make a view.\n\n *`internalformat`*  \nSpecifies the internal format for the newly created view.\n\n *`minlevel`*  \nSpecifies lowest level of detail of the view.\n\n *`numlevels`*  \nSpecifies the number of levels of detail to include in the view.\n\n *`minlayer`*  \nSpecifies the index of the first layer to include in the view.\n\n *`numlayers`*  \nSpecifies the number of layers to include in the view.\n\n## Description\n\n`glTextureView` initializes a texture object as an alias, or view of another texture object, sharing some or all of the parent texture's data store with the initialized texture. *`texture`* specifies a name previously reserved by a successful call to [glGenTextures](glgentextures.xhtml) but that has not yet been bound or given a target. *`target`* specifies the target for the newly initialized texture and must be compatible with the target of the parent texture, given in *`origtexture`* as specified in the following table:\n\n| Original Target                   | Compatible New Targets                                                                     |\n|:----------------------------------|:-------------------------------------------------------------------------------------------|\n| `GL_TEXTURE_1D`                   | `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`                                                     |\n| `GL_TEXTURE_2D`                   | `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`                                                     |\n| `GL_TEXTURE_3D`                   | `GL_TEXTURE_3D`                                                                            |\n| `GL_TEXTURE_CUBE_MAP`             | `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY` |\n| `GL_TEXTURE_RECTANGLE`            | `GL_TEXTURE_RECTANGLE`                                                                     |\n| `GL_TEXTURE_BUFFER`               |  *none*                                                                                    |\n| `GL_TEXTURE_1D_ARRAY`             | `GL_TEXTURE_1D`, `GL_TEXTURE_1D_ARRAY`                                                     |\n| `GL_TEXTURE_2D_ARRAY`             | `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`                                                     |\n| `GL_TEXTURE_CUBE_MAP_ARRAY`       | `GL_TEXTURE_CUBE_MAP`, `GL_TEXTURE_2D`, `GL_TEXTURE_2D_ARRAY`, `GL_TEXTURE_CUBE_MAP_ARRAY` |\n| `GL_TEXTURE_2D_MULTISAMPLE`       | `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_MULTISAMPLE_ARRAY`                                |\n| `GL_TEXTURE_2D_MULTISAMPLE_ARRAY` | `GL_TEXTURE_2D_MULTISAMPLE`, `GL_TEXTURE_MULTISAMPLE_ARRAY`                                |\n\nThe value of `GL_TEXTURE_IMMUTABLE_FORMAT` for *`origtexture`* must be `GL_TRUE`. After initialization, *`texture`* inherits the data store of the parent texture, *`origtexture`* and is usable as a normal texture object with target *`target`*. Data in the shared store is reinterpreted with the new internal format specified by *`internalformat`*. *`internalformat`* must be compatible with the internal format of the parent texture as specified in the following table:\n\n| Class           | Internal Formats                                                                                                                                                                                                                                 |\n|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 128-bit         | `GL_RGBA32F`, `GL_RGBA32UI`, `GL_RGBA32I`                                                                                                                                                                                                        |\n| 96-bit          | `GL_RGB32F`, `GL_RGB32UI`, `GL_RGB32I`                                                                                                                                                                                                           |\n| 64-bit          | `GL_RGBA16F`, `GL_RG32F`, `GL_RGBA16UI`, `GL_RG32UI`, `GL_RGBA16I`, `GL_RG32I`, `GL_RGBA16`, `GL_RGBA16_SNORM`                                                                                                                                   |\n| 48-bit          | `GL_RGB16`, `GL_RGB16_SNORM`, `GL_RGB16F`, `GL_RGB16UI`, `GL_RGB16I`                                                                                                                                                                             |\n| 32-bit          | `GL_RG16F`, `GL_R11F_G11F_B10F`, `GL_R32F`, `GL_RGB10_A2UI`, `GL_RGBA8UI`, `GL_RG16UI`, `GL_R32UI`, `GL_RGBA8I`, `GL_RG16I`, `GL_R32I`, `GL_RGB10_A2`, `GL_RGBA8`, `GL_RG16`, `GL_RGBA8_SNORM`, `GL_RG16_SNORM`, `GL_SRGB8_ALPHA8`, `GL_RGB9_E5` |\n| 24-bit          | `GL_RGB8`, `GL_RGB8_SNORM`, `GL_SRGB8`, `GL_RGB8UI`, `GL_RGB8I`                                                                                                                                                                                  |\n| 16-bit          | `GL_R16F`, `GL_RG8UI`, `GL_R16UI`, `GL_RG8I`, `GL_R16I`, `GL_RG8`, `GL_R16`, `GL_RG8_SNORM`, `GL_R16_SNORM`                                                                                                                                      |\n| 8-bit           | `GL_R8UI`, `GL_R8I`, `GL_R8`, `GL_R8_SNORM`                                                                                                                                                                                                      |\n| `GL_RGTC1_RED`  | `GL_COMPRESSED_RED_RGTC1`, `GL_COMPRESSED_SIGNED_RED_RGTC1`                                                                                                                                                                                      |\n| `GL_RGTC2_RG`   | `GL_COMPRESSED_RG_RGTC2`, `GL_COMPRESSED_SIGNED_RG_RGTC2`                                                                                                                                                                                        |\n| `GL_BPTC_UNORM` | `GL_COMPRESSED_RGBA_BPTC_UNORM`, `GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM`                                                                                                                                                                           |\n| `GL_BPTC_FLOAT` | `GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT`, `GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT`                                                                                                                                                                   |\n\nIf the original texture is an array or has multiple mipmap levels, the parameters *`minlayer`*, *`numlayers`*, *`minlevel`*, and *`numlevels`* control which of those slices and levels are considered part of the texture. The *`minlevel`* and *`minlayer`* parameters are relative to the view of the original texture. If *`numlayers`* or *`numlevels`* extend beyond the original texture, they are clamped to the max extent of the original texture.\n\nIf the new texture's target is `GL_TEXTURE_CUBE_MAP`, the clamped *`numlayers`* must be equal to 6. If the new texture's target is `GL_TEXTURE_CUBE_MAP_ARRAY`, then *`numlayers`* counts layer-faces rather than layers, and the clamped *`numlayers`* must be a multiple of 6. If the new texture's target is `GL_TEXTURE_CUBE_MAP` or `GL_TEXTURE_CUBE_MAP_ARRAY`, the width and height of the original texture's levels must be equal.\n\nWhen the original texture's target is `GL_TEXTURE_CUBE_MAP`, the layer parameters are interpreted in the same order as if it were a `GL_TEXTURE_CUBE_MAP_ARRAY` with 6 layer-faces.\n\nIf *`target`* is `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_RECTANGLE`, or `GL_TEXTURE_2D_MULTISAMPLE`, *`numlayers`* must equal 1.\n\nThe dimensions of the original texture must be less than or equal to the maximum supported dimensions of the new target. For example, if the original texture has a `GL_TEXTURE_2D_ARRAY` target and its width is greater than `GL_MAX_CUBE_MAP_TEXTURE_SIZE`, an error will be generated if `glTextureView` is called to create a `GL_TEXTURE_CUBE_MAP` view.\n\nTexture commands that take a *`level`* or *`layer`* parameter, such as [glTexSubImage2D](gltexsubimage2d.xhtml), interpret that parameter to be relative to the view of the texture. i.e. the mipmap level of the data store that would be updated via [glTexSubImage2D](gltexsubimage2d.xhtml) would be the sum of *`level`* and the value of `GL_TEXTURE_VIEW_MIN_LEVEL`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`minlayer`* or *`minlevel`* are larger than the greatest layer or level of *`origtexture`*.\n\n`GL_INVALID_OPERATION` is generated if *`target`* is not compatible with the target of *`origtexture`*.\n\n`GL_INVALID_OPERATION` is generated if the dimensions of *`origtexture`* are greater than the maximum supported dimensions for *`target`*.\n\n`GL_INVALID_OPERATION` is generated if *`internalformat`* is not compatible with the internal format of *`origtexture`*.\n\n`GL_INVALID_OPERATION` is generated if *`texture`* has already been bound or otherwise given a target.\n\n`GL_INVALID_OPERATION` is generated if the value of `GL_TEXTURE_IMMUTABLE_FORMAT` for *`origtexture`* is not `GL_TRUE`.\n\n`GL_INVALID_OPERATION` is generated if *`origtexture`* is not the name of an existing texture object.\n\n`GL_INVALID_VALUE` is generaged if *`target`* is `GL_TEXTURE_CUBE_MAP` and *`numlayers`* is not 6, or if *`target`* is `GL_TEXTURE_CUBE_MAP_ARRAY` and *`numlayers`* is not an integer multiple of 6.\n\n`GL_INVALID_VALUE` is generated if *`target`* is `GL_TEXTURE_1D`, `GL_TEXTURE_2D`, `GL_TEXTURE_3D`, `GL_TEXTURE_RECTANGLE`, or `GL_TEXTURE_2D_MULTISAMPLE` and *`numlayers`* does not equal 1.\n\n`GL_INVALID_VALUE` is generated if *`texture`* zero or is not the name of a texture previously returned from a successful call to [glGenTextures](glgentextures.xhtml).\n\n## Associated Gets\n\n[glTexParameter](gltexparameter.xhtml) with arguments `GL_TEXTURE_VIEW_MIN_LEVEL`, `GL_TEXTURE_VIEW_NUM_LEVELS`, `GL_TEXTURE_VIEW_MIN_LAYER`, `GL_TEXTURE_VIEW_NUM_LAYERS`, or `GL_TEXTURE_IMMUTABLE_LEVELS`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTextureView`             |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glTexStorage1D](gltexstorage1d.xhtml), [glTexStorage2D](gltexstorage2d.xhtml), [glTexStorage3D](gltexstorage3d.xhtml), [glGetTexParameter](glgettexparameter.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTextureView.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTextureView.xhtml)"
- name: glTransformFeedbackBufferBase
  id: gltransformfeedbackbufferbase.xhtml
  summary: xfb Name of the transform feedback buffer object
  description: "## Name\n\nglTransformFeedbackBufferBase — bind a buffer object to a transform feedback buffer object\n\n## C Specification\n\n`void `**`glTransformFeedbackBufferBase`**`(` GLuint `xfb`, GLuint `index`, GLuint `buffer``)`;\n\n## Parameters\n\n *`xfb`*  \nName of the transform feedback buffer object.\n\n *`index`*  \nIndex of the binding point within *`xfb`*.\n\n *`buffer`*  \nName of the buffer object to bind to the specified binding point.\n\n## Description\n\n`glTransformFeedbackBufferBase` binds the buffer object *`buffer`* to the binding point at index *`index`* of the transform feedback object *`xfb`*.\n\n## Notes\n\nCalling `glTransformFeedbackBufferBase` is equivalent to calling [glTransformFeedbackBufferRange](gltransformfeedbackbufferrange.xhtml) with *`offset`* zero and *`size`* equal to the size of *`buffer`*.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`xfb`* is not the name of an existing transform feedback object.\n\n`GL_INVALID_VALUE` is generated if in *`buffer`* is not zero or the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the number of transform feedback buffer binding points (the value of `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`).\n\n## Version Support\n\n|                                 | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:--------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**     |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTransformFeedbackBufferBase` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBufferRange](glbindbufferrange.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glTransformFeedbackBufferRange](gltransformfeedbackbufferrange.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTransformFeedbackBufferBase.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTransformFeedbackBufferBase.xhtml)"
- name: glTransformFeedbackBufferRange
  id: gltransformfeedbackbufferrange.xhtml
  summary: xfb Name of the transform feedback buffer object
  description: "## Name\n\nglTransformFeedbackBufferRange — bind a range within a buffer object to a transform feedback buffer object\n\n## C Specification\n\n`void `**`glTransformFeedbackBufferRange`**`(` GLuint `xfb`, GLuint `index`, GLuint `buffer`, GLintptr `offset`, GLsizei `size``)`;\n\n## Parameters\n\n *`xfb`*  \nName of the transform feedback buffer object.\n\n *`index`*  \nIndex of the binding point within *`xfb`*.\n\n *`buffer`*  \nName of the buffer object to bind to the specified binding point.\n\n *`offset`*  \nThe starting offset in basic machine units into the buffer object.\n\n *`size`*  \nThe amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target.\n\n## Description\n\n`glTransformFeedbackBufferRange` binds a range of the buffer object *`buffer`* represented by *`offset`* and *`size`* to the binding point at index *`index`* of the transform feedback object *`xfb`*.\n\n*`offset`* specifies the offset in basic machine units into the buffer object *`buffer`* and *`size`* specifies the amount of data that can be read from the buffer object while used as an indexed target.\n\n## Notes\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`xfb`* is not the name of an existing transform feedback object.\n\n`GL_INVALID_VALUE` is generated if in *`buffer`* is not zero or the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the number of transform feedback buffer binding points (the value of `GL_TRANSFORM_FEEDBACK_BUFFER_BINDING`).\n\n`GL_INVALID_VALUE` is generated if *`offset`* is negative.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is non-zero and either *`size`* is less than or equal to zero, or *`offset`* + *`size`* is greater than the value of `GL_BUFFER_SIZE` for *`buffer`*.\n\n## Version Support\n\n|                                  | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:---------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**      |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTransformFeedbackBufferRange` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBindBufferRange](glbindbufferrange.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glTransformFeedbackBufferBase](gltransformfeedbackbufferbase.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTransformFeedbackBufferRange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTransformFeedbackBufferRange.xhtml)"
- name: glTransformFeedbackVaryings
  id: gltransformfeedbackvaryings.xhtml
  summary: program The name of the target program object
  description: "## Name\n\nglTransformFeedbackVaryings — specify values to record in transform feedback buffers\n\n## C Specification\n\n`void `**`glTransformFeedbackVaryings`**`(` GLuint `program`, GLsizei `count`, const char \\*\\*`varyings`, GLenum `bufferMode``)`;\n\n## Parameters\n\n *`program`*  \nThe name of the target program object.\n\n *`count`*  \nThe number of varying variables used for transform feedback.\n\n *`varyings`*  \nAn array of *`count`* zero-terminated strings specifying the names of the varying variables to use for transform feedback.\n\n *`bufferMode`*  \nIdentifies the mode used to capture the varying variables when transform feedback is active. *`bufferMode`* must be `GL_INTERLEAVED_ATTRIBS` or `GL_SEPARATE_ATTRIBS`.\n\n## Description\n\nThe names of the vertex or geometry shader outputs to be recorded in transform feedback mode are specified using `glTransformFeedbackVaryings`. When a geometry shader is active, transform feedback records the values of selected geometry shader output variables from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are recorded.\n\nThe state set by `glTranformFeedbackVaryings` is stored and takes effect next time [glLinkProgram](gllinkprogram.xhtml) is called on *`program`*. When [glLinkProgram](gllinkprogram.xhtml) is called, *`program`* is linked so that the values of the specified varying variables for the vertices of each primitive generated by the GL are written to a single buffer object if *`bufferMode`* is `GL_INTERLEAVED_ATTRIBS` or multiple buffer objects if *`bufferMode`* is `GL_SEPARATE_ATTRIBS`.\n\n`glTransformFeedbackVaryings` can also special identifiers if *`bufferMode`* is `GL_INTERLEAVED_ATTRIBS`:\n\ngl_NextBuffer  \nSubsequent variables in *`varyings`* will be assigned to the next buffer binding point.\n\ngl_SkipComponents#  \nWhere \\# may be 1, 2, 3, or 4. The variable is treated as having this number of components, but the contents of the memory are preserved under feedback operations.\n\nIn addition to the errors generated by `glTransformFeedbackVaryings`, the program *`program`* will fail to link if:\n\n- The count specified by `glTransformFeedbackVaryings` is non-zero, but the program object has no vertex or geometry shader.\n\n- Any variable name specified in the *`varyings`* array is not declared as an output in the vertex shader (or the geometry shader, if active), or is not one of the special identifiers listed above.\n\n- Special identifiers appear in a *`varyings`* array where *`bufferMode`* is not `GL_INTERLEAVED_ATTRIBS`.\n\n- Any two entries in the *`varyings`* array, which are not one of the special varyings above, specify the same varying variable.\n\n- Discounting any special identifiers, the total number of components to capture in any varying variable in *`varyings`* is greater than the constant `GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS` and the buffer mode is `GL_SEPARATE_ATTRIBS`.\n\n- The total number of components to capture is greater than the constant `GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS` and the buffer mode is `GL_INTERLEAVED_ATTRIBS`.\n\n## Notes\n\n`glGetTransformFeedbackVarying` is available only if the GL version is 3.0 or greater.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of a program object.\n\n`GL_INVALID_VALUE` is generated if *`bufferMode`* is `GL_SEPARATE_ATTRIBS` and *`count`* is greater than the implementation-dependent limit `GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS`.\n\n## Associated Gets\n\n[glGetTransformFeedbackVarying](glgettransformfeedbackvarying.xhtml)\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glTransformFeedbackVaryings` |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBeginTransformFeedback](glbegintransformfeedback.xhtml), `glEndTransformFeedback`, [glGetTransformFeedbackVarying](glgettransformfeedbackvarying.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glTransformFeedbackVaryings.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glTransformFeedbackVaryings.xhtml)"
- name: glUniform
  id: gluniform.xhtml
  summary: location Specifies the location of the uniform variable to be modified
  description: "## Name\n\nglUniform — Specify the value of a uniform variable for the current program object\n\n## C Specification\n\n`void `**`glUniform1f`**`(` GLint `location`, GLfloat `v0``)`;\n\n`void `**`glUniform2f`**`(` GLint `location`, GLfloat `v0`, GLfloat `v1``)`;\n\n`void `**`glUniform3f`**`(` GLint `location`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2``)`;\n\n`void `**`glUniform4f`**`(` GLint `location`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2`, GLfloat `v3``)`;\n\n`void `**`glUniform1i`**`(` GLint `location`, GLint `v0``)`;\n\n`void `**`glUniform2i`**`(` GLint `location`, GLint `v0`, GLint `v1``)`;\n\n`void `**`glUniform3i`**`(` GLint `location`, GLint `v0`, GLint `v1`, GLint `v2``)`;\n\n`void `**`glUniform4i`**`(` GLint `location`, GLint `v0`, GLint `v1`, GLint `v2`, GLint `v3``)`;\n\n`void `**`glUniform1ui`**`(` GLint `location`, GLuint `v0``)`;\n\n`void `**`glUniform2ui`**`(` GLint `location`, GLuint `v0`, GLuint `v1``)`;\n\n`void `**`glUniform3ui`**`(` GLint `location`, GLuint `v0`, GLuint `v1`, GLuint `v2``)`;\n\n`void `**`glUniform4ui`**`(` GLint `location`, GLuint `v0`, GLuint `v1`, GLuint `v2`, GLuint `v3``)`;\n\n`void `**`glUniform1fv`**`(` GLint `location`, GLsizei `count`, const GLfloat \\*`value``)`;\n\n`void `**`glUniform2fv`**`(` GLint `location`, GLsizei `count`, const GLfloat \\*`value``)`;\n\n`void `**`glUniform3fv`**`(` GLint `location`, GLsizei `count`, const GLfloat \\*`value``)`;\n\n`void `**`glUniform4fv`**`(` GLint `location`, GLsizei `count`, const GLfloat \\*`value``)`;\n\n`void `**`glUniform1iv`**`(` GLint `location`, GLsizei `count`, const GLint \\*`value``)`;\n\n`void `**`glUniform2iv`**`(` GLint `location`, GLsizei `count`, const GLint \\*`value``)`;\n\n`void `**`glUniform3iv`**`(` GLint `location`, GLsizei `count`, const GLint \\*`value``)`;\n\n`void `**`glUniform4iv`**`(` GLint `location`, GLsizei `count`, const GLint \\*`value``)`;\n\n`void `**`glUniform1uiv`**`(` GLint `location`, GLsizei `count`, const GLuint \\*`value``)`;\n\n`void `**`glUniform2uiv`**`(` GLint `location`, GLsizei `count`, const GLuint \\*`value``)`;\n\n`void `**`glUniform3uiv`**`(` GLint `location`, GLsizei `count`, const GLuint \\*`value``)`;\n\n`void `**`glUniform4uiv`**`(` GLint `location`, GLsizei `count`, const GLuint \\*`value``)`;\n\n`void `**`glUniformMatrix2fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glUniformMatrix3fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glUniformMatrix4fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glUniformMatrix2x3fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glUniformMatrix3x2fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glUniformMatrix2x4fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glUniformMatrix4x2fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glUniformMatrix3x4fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n`void `**`glUniformMatrix4x3fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n## Parameters\n\n *`location`*  \nSpecifies the location of the uniform variable to be modified.\n\n *`count`*  \nFor the vector (`glUniform*v`) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.\n\nFor the matrix (`glUniformMatrix*`) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.\n\n *`transpose`*  \nFor the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.\n\n *`v0`*, *`v1`*, *`v2`*, *`v3`*  \nFor the scalar commands, specifies the new values to be used for the specified uniform variable.\n\n *`value`*  \nFor the vector and matrix commands, specifies a pointer to an array of *`count`* values that will be used to update the specified uniform variable.\n\n## Description\n\n`glUniform` modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by *`location`*, which should be a value returned by [glGetUniformLocation](glgetuniformlocation.xhtml). `glUniform` operates on the program object that was made part of current state by calling [glUseProgram](gluseprogram.xhtml).\n\nThe commands `glUniform{1|2|3|4}{f|i|ui}` are used to change the value of the uniform variable specified by *`location`* using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., `1` for `float`, `int`, `unsigned int`, `bool`; `2` for `vec2`, `ivec2`, `uvec2`, `bvec2`, etc.). The suffix `f` indicates that floating-point values are being passed; the suffix `i` indicates that integer values are being passed; the suffix `ui` indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The `i` variants of this function should be used to provide values for uniform variables defined as `int`, `ivec2`, `ivec3`, `ivec4`, or arrays of these. The `ui` variants of this function should be used to provide values for uniform variables defined as `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or arrays of these. The `f` variants should be used to provide values for uniform variables of type `float`, `vec2`, `vec3`, `vec4`, or arrays of these. Either the `i`, `ui` or `f` variants may be used to provide values for uniform variables of type `bool`, `bvec2`, `bvec3`, `bvec4`, or arrays of these. The uniform variable will be set to `false` if the input value is 0 or 0.0f, and it will be set to `true` otherwise.\n\nAll active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to `glUniform ` until the next successful link operation occurs on the program object, when they are once again initialized to 0.\n\nThe commands `glUniform{1|2|3|4}{f|i|ui}v` can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading *n* elements starting at an arbitrary position *m* in a uniform variable array, elements *m* + *n* - 1 in the array will be replaced with the new values. If *`m`* + *`n`* - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in *`value`*, and it should match the number of components in the data type of the specified uniform variable (e.g., `1` for float, int, bool; `2` for vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for `glUniform{1|2|3|4}{f|i|ui}`.\n\nFor uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., `glUniform3f` or `glUniform3fv` can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by *`count`*\n\nThe commands `glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv` are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number `2` indicates a 2 × 2 matrix (i.e., 4 values), the number `3` indicates a 3 × 3 matrix (i.e., 9 values), and the number `4` indicates a 4 × 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows. For example, `2x4` indicates a 2 × 4 matrix with 2 columns and 4 rows (i.e., 8 values). If *`transpose`* is `GL_FALSE`, each matrix is assumed to be supplied in column major order. If *`transpose`* is `GL_TRUE`, each matrix is assumed to be supplied in row major order. The *`count`* argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.\n\n## Notes\n\n`glUniform1i` and `glUniform1iv` are the only two functions that may be used to load uniform variables defined as sampler types. Loading samplers with any other function will result in a `GL_INVALID_OPERATION` error.\n\nIf *`count`* is greater than 1 and the indicated uniform variable is not an array, a `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain unchanged.\n\nOther than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match the type and size specified in the name of the command used to load its value, a `GL_INVALID_OPERATION` error will be generated and the specified uniform variable will remain unchanged.\n\nIf *`location`* is a value other than -1 and it does not represent a valid uniform variable location in the current program object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object. If *`location`* is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if there is no current program object.\n\n`GL_INVALID_OPERATION` is generated if the size of the uniform variable declared in the shader does not match the size indicated by the `glUniform` command.\n\n`GL_INVALID_OPERATION` is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type `float`, `vec2`, `vec3`, `vec4`, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type `int`, `ivec2`, `ivec3`, `ivec4`, `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if one of the signed integer variants of this function is used to load a uniform variable of type `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type `int`, `ivec2`, `ivec3`, `ivec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if *`location`* is an invalid uniform location for the current program object and *`location`* is not equal to -1.\n\n`GL_INVALID_VALUE` is generated if *`count`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if *`count`* is greater than 1 and the indicated uniform variable is not an array variable.\n\n`GL_INVALID_OPERATION` is generated if a sampler is loaded using a command other than `glUniform1i` and `glUniform1iv`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with the argument `GL_CURRENT_PROGRAM`\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with the handle of a program object and the index of an active uniform variable\n\n[glGetUniform](glgetuniform.xhtml) with the handle of a program object and the location of a uniform variable\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with the handle of a program object and the name of a uniform variable\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glUniform1f`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform1fv`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform1i`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform1iv`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform1ui`              |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform1uiv`             |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform2f`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform2fv`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform2i`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform2iv`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform2ui`              |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform2uiv`             |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform3f`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform3fv`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform3i`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform3iv`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform3ui`              |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform3uiv`             |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform4f`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform4fv`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform4i`               |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform4iv`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform4ui`              |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniform4uiv`             |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniformMatrix2fv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniformMatrix2x3fv`      |         \\-         |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniformMatrix2x4fv`      |         \\-         |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniformMatrix3fv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniformMatrix3x2fv`      |         \\-         |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniformMatrix3x4fv`      |         \\-         |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniformMatrix4fv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniformMatrix4x2fv`      |         \\-         |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUniformMatrix4x3fv`      |         \\-         |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glLinkProgram](gllinkprogram.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glUniform.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glUniform.xhtml)"
- name: glUniform1f
  id: gluniform.xhtml#glUniform1f
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform1f`**`(` GLint `location`, GLfloat `v0``)`;'
- name: glUniform1fv
  id: gluniform.xhtml#glUniform1fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform1fv`**`(` GLint `location`, GLsizei `count`, const GLfloat \*`value``)`;'
- name: glUniform1i
  id: gluniform.xhtml#glUniform1i
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform1i`**`(` GLint `location`, GLint `v0``)`;'
- name: glUniform1iv
  id: gluniform.xhtml#glUniform1iv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform1iv`**`(` GLint `location`, GLsizei `count`, const GLint \*`value``)`;'
- name: glUniform1ui
  id: gluniform.xhtml#glUniform1ui
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform1ui`**`(` GLint `location`, GLuint `v0``)`;'
- name: glUniform1uiv
  id: gluniform.xhtml#glUniform1uiv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform1uiv`**`(` GLint `location`, GLsizei `count`, const GLuint \*`value``)`;'
- name: glUniform2f
  id: gluniform.xhtml#glUniform2f
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform2f`**`(` GLint `location`, GLfloat `v0`, GLfloat `v1``)`;'
- name: glUniform2fv
  id: gluniform.xhtml#glUniform2fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform2fv`**`(` GLint `location`, GLsizei `count`, const GLfloat \*`value``)`;'
- name: glUniform2i
  id: gluniform.xhtml#glUniform2i
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform2i`**`(` GLint `location`, GLint `v0`, GLint `v1``)`;'
- name: glUniform2iv
  id: gluniform.xhtml#glUniform2iv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform2iv`**`(` GLint `location`, GLsizei `count`, const GLint \*`value``)`;'
- name: glUniform2ui
  id: gluniform.xhtml#glUniform2ui
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform2ui`**`(` GLint `location`, GLuint `v0`, GLuint `v1``)`;'
- name: glUniform2uiv
  id: gluniform.xhtml#glUniform2uiv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform2uiv`**`(` GLint `location`, GLsizei `count`, const GLuint \*`value``)`;'
- name: glUniform3f
  id: gluniform.xhtml#glUniform3f
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform3f`**`(` GLint `location`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2``)`;'
- name: glUniform3fv
  id: gluniform.xhtml#glUniform3fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform3fv`**`(` GLint `location`, GLsizei `count`, const GLfloat \*`value``)`;'
- name: glUniform3i
  id: gluniform.xhtml#glUniform3i
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform3i`**`(` GLint `location`, GLint `v0`, GLint `v1`, GLint `v2``)`;'
- name: glUniform3iv
  id: gluniform.xhtml#glUniform3iv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform3iv`**`(` GLint `location`, GLsizei `count`, const GLint \*`value``)`;'
- name: glUniform3ui
  id: gluniform.xhtml#glUniform3ui
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform3ui`**`(` GLint `location`, GLuint `v0`, GLuint `v1`, GLuint `v2``)`;'
- name: glUniform3uiv
  id: gluniform.xhtml#glUniform3uiv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform3uiv`**`(` GLint `location`, GLsizei `count`, const GLuint \*`value``)`;'
- name: glUniform4f
  id: gluniform.xhtml#glUniform4f
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform4f`**`(` GLint `location`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2`, GLfloat `v3``)`;'
- name: glUniform4fv
  id: gluniform.xhtml#glUniform4fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform4fv`**`(` GLint `location`, GLsizei `count`, const GLfloat \*`value``)`;'
- name: glUniform4i
  id: gluniform.xhtml#glUniform4i
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform4i`**`(` GLint `location`, GLint `v0`, GLint `v1`, GLint `v2`, GLint `v3``)`;'
- name: glUniform4iv
  id: gluniform.xhtml#glUniform4iv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform4iv`**`(` GLint `location`, GLsizei `count`, const GLint \*`value``)`;'
- name: glUniform4ui
  id: gluniform.xhtml#glUniform4ui
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform4ui`**`(` GLint `location`, GLuint `v0`, GLuint `v1`, GLuint `v2`, GLuint `v3``)`;'
- name: glUniform4uiv
  id: gluniform.xhtml#glUniform4uiv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniform4uiv`**`(` GLint `location`, GLsizei `count`, const GLuint \*`value``)`;'
- name: glUniformBlockBinding
  id: gluniformblockbinding.xhtml
  summary: program The name of a program object containing the active uniform block whose binding to assign
  description: "## Name\n\nglUniformBlockBinding — assign a binding point to an active uniform block\n\n## C Specification\n\n`void `**`glUniformBlockBinding`**`(` GLuint `program`, GLuint `uniformBlockIndex`, GLuint `uniformBlockBinding``)`;\n\n## Parameters\n\n *`program`*  \nThe name of a program object containing the active uniform block whose binding to assign.\n\n *`uniformBlockIndex`*  \nThe index of the active uniform block within *`program`* whose binding to assign.\n\n *`uniformBlockBinding`*  \nSpecifies the binding point to which to bind the uniform block with index *`uniformBlockIndex`* within *`program`*.\n\n## Description\n\nBinding points for active uniform blocks are assigned using `glUniformBlockBinding`. Each of a program's active uniform blocks has a corresponding uniform buffer binding point. *`program`* is the name of a program object for which the command [glLinkProgram](gllinkprogram.xhtml) has been issued in the past.\n\nIf successful, `glUniformBlockBinding` specifies that *`program`* will use the data store of the buffer object bound to the binding point *`uniformBlockBinding`* to extract the values of the uniforms in the uniform block identified by *`uniformBlockIndex`*.\n\nWhen a program object is linked or re-linked, the uniform buffer object binding point assigned to each of its active uniform blocks is reset to zero.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`uniformBlockIndex`* is not an active uniform block index of *`program`*.\n\n`GL_INVALID_VALUE` is generated if *`uniformBlockBinding`* is greater than or equal to the value of `GL_MAX_UNIFORM_BUFFER_BINDINGS`.\n\n`GL_INVALID_VALUE` is generated if *`program`* is not the name of a program object generated by the GL.\n\n## Notes\n\n`glUniformBlockBinding` is available only if the GL version is 3.1 or greater.\n\n## Associated Gets\n\n[glGetActiveUniformBlock](glgetactiveuniformblock.xhtml) with argument `GL_UNIFORM_BLOCK_BINDING`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glUniformBlockBinding`     |         \\-         |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glLinkProgram](gllinkprogram.xhtml), [glBindBufferBase](glbindbufferbase.xhtml), [glBindBufferRange](glbindbufferrange.xhtml), [glGetActiveUniformBlock](glgetactiveuniformblock.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glUniformBlockBinding.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glUniformBlockBinding.xhtml)"
- name: glUniformMatrix2fv
  id: gluniform.xhtml#glUniformMatrix2fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniformMatrix2fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glUniformMatrix2x3fv
  id: gluniform.xhtml#glUniformMatrix2x3fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniformMatrix2x3fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glUniformMatrix2x4fv
  id: gluniform.xhtml#glUniformMatrix2x4fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniformMatrix2x4fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glUniformMatrix3fv
  id: gluniform.xhtml#glUniformMatrix3fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniformMatrix3fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glUniformMatrix3x2fv
  id: gluniform.xhtml#glUniformMatrix3x2fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniformMatrix3x2fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glUniformMatrix3x4fv
  id: gluniform.xhtml#glUniformMatrix3x4fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniformMatrix3x4fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glUniformMatrix4fv
  id: gluniform.xhtml#glUniformMatrix4fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniformMatrix4fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glUniformMatrix4x2fv
  id: gluniform.xhtml#glUniformMatrix4x2fv
  summary: null
  belongs_to: glUniform
  description: '`void `**`glUniformMatrix4x2fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \*`value``)`;'
- name: glUniformMatrix4x3fv
  id: gluniform.xhtml#glUniformMatrix4x3fv
  summary: Specifies the location of the uniform variable to be modified
  belongs_to: glUniform
  description: "`void `**`glUniformMatrix4x3fv`**`(` GLint `location`, GLsizei `count`, GLboolean `transpose`, const GLfloat \\*`value``)`;\n\n## Parameters\n\n*`location`*\n\nSpecifies the location of the uniform variable to be modified.\n\n*`count`*\n\nFor the vector (`glUniform*v`) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array.\n\nFor the matrix (`glUniformMatrix*`) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.\n\n*`transpose`*\n\nFor the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.\n\n*`v0`*, *`v1`*, *`v2`*, *`v3`*\n\nFor the scalar commands, specifies the new values to be used for the specified uniform variable.\n\n*`value`*\n\nFor the vector and matrix commands, specifies a pointer to an array of *`count`* values that will be used to update the specified uniform variable.\n\n## Description\n\n`glUniform` modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by *`location`*, which should be a value returned by [glGetUniformLocation](glgetuniformlocation.xhtml). `glUniform` operates on the program object that was made part of current state by calling [glUseProgram](gluseprogram.xhtml).\n\nThe commands `glUniform{1|2|3|4}{f|i|ui}` are used to change the value of the uniform variable specified by *`location`* using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., `1` for `float`, `int`, `unsigned int`, `bool`; `2` for `vec2`, `ivec2`, `uvec2`, `bvec2`, etc.). The suffix `f` indicates that floating-point values are being passed; the suffix `i` indicates that integer values are being passed; the suffix `ui` indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The `i` variants of this function should be used to provide values for uniform variables defined as `int`, `ivec2`, `ivec3`, `ivec4`, or arrays of these. The `ui` variants of this function should be used to provide values for uniform variables defined as `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or arrays of these. The `f` variants should be used to provide values for uniform variables of type `float`, `vec2`, `vec3`, `vec4`, or arrays of these. Either the `i`, `ui` or `f` variants may be used to provide values for uniform variables of type `bool`, `bvec2`, `bvec3`, `bvec4`, or arrays of these. The uniform variable will be set to `false` if the input value is 0 or 0.0f, and it will be set to `true` otherwise.\n\nAll active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to `glUniform ` until the next successful link operation occurs on the program object, when they are once again initialized to 0.\n\nThe commands `glUniform{1|2|3|4}{f|i|ui}v` can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading *n* elements starting at an arbitrary position *m* in a uniform variable array, elements *m* + *n* - 1 in the array will be replaced with the new values. If *`m`* + *`n`* - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in *`value`*, and it should match the number of components in the data type of the specified uniform variable (e.g., `1` for float, int, bool; `2` for vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for `glUniform{1|2|3|4}{f|i|ui}`.\n\nFor uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., `glUniform3f` or `glUniform3fv` can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by *`count`*\n\nThe commands `glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv` are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number `2` indicates a 2 × 2 matrix (i.e., 4 values), the number `3` indicates a 3 × 3 matrix (i.e., 9 values), and the number `4` indicates a 4 × 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows. For example, `2x4` indicates a 2 × 4 matrix with 2 columns and 4 rows (i.e., 8 values). If *`transpose`* is `GL_FALSE`, each matrix is assumed to be supplied in column major order. If *`transpose`* is `GL_TRUE`, each matrix is assumed to be supplied in row major order. The *`count`* argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.\n\n## Notes\n\n`glUniform1i` and `glUniform1iv` are the only two functions that may be used to load uniform variables defined as sampler types. Loading samplers with any other function will result in a `GL_INVALID_OPERATION` error.\n\nIf *`count`* is greater than 1 and the indicated uniform variable is not an array, a `GL_INVALID_OPERATION` error is generated and the specified uniform variable will remain unchanged.\n\nOther than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match the type and size specified in the name of the command used to load its value, a `GL_INVALID_OPERATION` error will be generated and the specified uniform variable will remain unchanged.\n\nIf *`location`* is a value other than -1 and it does not represent a valid uniform variable location in the current program object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object. If *`location`* is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if there is no current program object.\n\n`GL_INVALID_OPERATION` is generated if the size of the uniform variable declared in the shader does not match the size indicated by the `glUniform` command.\n\n`GL_INVALID_OPERATION` is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type `float`, `vec2`, `vec3`, `vec4`, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type `int`, `ivec2`, `ivec3`, `ivec4`, `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if one of the signed integer variants of this function is used to load a uniform variable of type `unsigned int`, `uvec2`, `uvec3`, `uvec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type `int`, `ivec2`, `ivec3`, `ivec4`, or an array of these.\n\n`GL_INVALID_OPERATION` is generated if *`location`* is an invalid uniform location for the current program object and *`location`* is not equal to -1.\n\n`GL_INVALID_VALUE` is generated if *`count`* is less than 0.\n\n`GL_INVALID_OPERATION` is generated if *`count`* is greater than 1 and the indicated uniform variable is not an array variable.\n\n`GL_INVALID_OPERATION` is generated if a sampler is loaded using a command other than `glUniform1i` and `glUniform1iv`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with the argument `GL_CURRENT_PROGRAM`\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with the handle of a program object and the index of an active uniform variable\n\n[glGetUniform](glgetuniform.xhtml) with the handle of a program object and the location of a uniform variable\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with the handle of a program object and the name of a uniform variable\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glUniform1f`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform1fv`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform1i`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform1iv`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform1ui`                |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform1uiv`               |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform2f`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform2fv`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform2i`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform2iv`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform2ui`                |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform2uiv`               |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform3f`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform3fv`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform3i`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform3iv`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform3ui`                |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform3uiv`               |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform4f`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform4fv`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform4i`                 |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform4iv`                |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform4ui`                |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniform4uiv`               |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniformMatrix2fv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniformMatrix2x3fv`        |          \\-          |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniformMatrix2x4fv`        |          \\-          |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniformMatrix3fv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniformMatrix3x2fv`        |          \\-          |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniformMatrix3x4fv`        |          \\-          |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniformMatrix4fv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniformMatrix4x2fv`        |          \\-          |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUniformMatrix4x3fv`        |          \\-          |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glLinkProgram](gllinkprogram.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glUniform.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glUniform.xhtml)"
- name: glUniformSubroutines
  id: gluniformsubroutines.xhtml
  summary: shadertype Specifies the shader stage from which to query for subroutine uniform index
  description: "## Name\n\nglUniformSubroutines — load active subroutine uniforms\n\n## C Specification\n\n`void `**`glUniformSubroutinesuiv`**`(` GLenum `shadertype`, GLsizei `count`, const GLuint \\*`indices``)`;\n\n## Parameters\n\n *`shadertype`*  \nSpecifies the shader stage from which to query for subroutine uniform index. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n *`count`*  \nSpecifies the number of uniform indices stored in *`indices`*.\n\n *`indices`*  \nSpecifies the address of an array holding the indices to load into the shader subroutine variables.\n\n## Description\n\n`glUniformSubroutines` loads all active subroutine uniforms for shader stage *`shadertype`* of the current program with subroutine indices from *`indices`*, storing *`indices[i]`* into the uniform at location *`i`*. *`count`* must be equal to the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the program currently in use at shader stage *`shadertype`*. Furthermore, all values in *`indices`* must be less than the value of `GL_ACTIVE_SUBROUTINES` for the shader stage.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if no program object is current.\n\n`GL_INVALID_VALUE` is generated if *`count`* is not equal to the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the shader stage *`shadertype`* of the current program.\n\n`GL_INVALID_VALUE` is generated if any value in *`indices`* is geater than or equal to the value of `GL_ACTIVE_SUBROUTINES` for the shader stage *`shadertype`* of the current program.\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* is not one of the accepted values.\n\n## Associated Gets\n\n[glGetProgramStage](glgetprogramstage.xhtml) with argument `GL_ACTIVE_SUBROUTINES`\n\n[glGetProgramStage](glgetprogramstage.xhtml) with argument `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glUniformSubroutinesuiv`   |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetActiveSubroutineUniform](glgetactivesubroutineuniform.xhtml), [glGetActiveSubroutineUniformName](glgetactivesubroutineuniformname.xhtml), [glGetProgramStage](glgetprogramstage.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glUniformSubroutines.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glUniformSubroutines.xhtml)"
- name: glUniformSubroutinesuiv
  id: gluniformsubroutines.xhtml#glUniformSubroutinesuiv
  summary: Specifies the shader stage from which to query for subroutine uniform index
  belongs_to: glUniformSubroutines
  description: "`void `**`glUniformSubroutinesuiv`**`(` GLenum `shadertype`, GLsizei `count`, const GLuint \\*`indices``)`;\n\n## Parameters\n\n*`shadertype`*\n\nSpecifies the shader stage from which to query for subroutine uniform index. *`shadertype`* must be one of `GL_VERTEX_SHADER`, `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_GEOMETRY_SHADER` or `GL_FRAGMENT_SHADER`.\n\n*`count`*\n\nSpecifies the number of uniform indices stored in *`indices`*.\n\n*`indices`*\n\nSpecifies the address of an array holding the indices to load into the shader subroutine variables.\n\n## Description\n\n`glUniformSubroutines` loads all active subroutine uniforms for shader stage *`shadertype`* of the current program with subroutine indices from *`indices`*, storing *`indices[i]`* into the uniform at location *`i`*. *`count`* must be equal to the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the program currently in use at shader stage *`shadertype`*. Furthermore, all values in *`indices`* must be less than the value of `GL_ACTIVE_SUBROUTINES` for the shader stage.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if no program object is current.\n\n`GL_INVALID_VALUE` is generated if *`count`* is not equal to the value of `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS` for the shader stage *`shadertype`* of the current program.\n\n`GL_INVALID_VALUE` is generated if any value in *`indices`* is geater than or equal to the value of `GL_ACTIVE_SUBROUTINES` for the shader stage *`shadertype`* of the current program.\n\n`GL_INVALID_ENUM` is generated if *`shadertype`* is not one of the accepted values.\n\n## Associated Gets\n\n[glGetProgramStage](glgetprogramstage.xhtml) with argument `GL_ACTIVE_SUBROUTINES`\n\n[glGetProgramStage](glgetprogramstage.xhtml) with argument `GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glUniformSubroutinesuiv`     |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glGetProgram](glgetprogram.xhtml), [glGetActiveSubroutineUniform](glgetactivesubroutineuniform.xhtml), [glGetActiveSubroutineUniformName](glgetactivesubroutineuniformname.xhtml), [glGetProgramStage](glgetprogramstage.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glUniformSubroutines.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glUniformSubroutines.xhtml)"
- name: glUnmapBuffer
  id: glunmapbuffer.xhtml
  summary: buffer Specifies the name of the buffer object for glUnmapNamedBuffer
  description: "## Name\n\nglUnmapBuffer, glUnmapNamedBuffer — release the mapping of a buffer object's data store into the client's address space\n\n## C Specification\n\n`GLboolean `**`glUnmapBuffer`**`(` GLenum `target``)`;\n\n`GLboolean `**`glUnmapNamedBuffer`**`(` GLuint `buffer``)`;\n\n## Parameters\n\n *`target`*  \nSpecifies the target to which the buffer object is bound for `glUnmapBuffer`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n *`buffer`*  \nSpecifies the name of the buffer object for `glUnmapNamedBuffer`.\n\n## Description\n\n`glUnmapBuffer` and `glUnmapNamedBuffer` unmap (release) any mapping of a specified buffer object into the client's address space (see [glMapBufferRange](glmapbufferrange.xhtml) and [glMapBuffer](glmapbuffer.xhtml)).\n\nIf a mapping is not unmapped before the corresponding buffer object's data store is used by the GL, an error will be generated by any GL command that attempts to dereference the buffer object's data store, unless the buffer was successfully mapped with `GL_MAP_PERSISTENT_BIT` (see [glMapBufferRange](glmapbufferrange.xhtml)). When a data store is unmapped, the mapped pointer becomes invalid.\n\n`glUnmapBuffer` returns `GL_TRUE` unless the data store contents have become corrupt during the time the data store was mapped. This can occur for system-specific reasons that affect the availability of graphics memory, such as screen mode changes. In such situations, `GL_FALSE` is returned and the data store contents are undefined. An application must detect this rare condition and reinitialize the data store.\n\nA buffer object's mapped data store is automatically unmapped when the buffer object is deleted or its data store is recreated with [glBufferData](glbufferdata.xhtml)).\n\n## Notes\n\nIf an error is generated, `glUnmapBuffer` returns `GL_FALSE`.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glUnmapBuffer` if *`target`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glUnmapBuffer` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glUnmapNamedBuffer` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_OPERATION` is generated if the buffer object is not in a mapped state.\n\n## Associated Gets\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_MAPPED`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glUnmapBuffer`             |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glUnmapNamedBuffer`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glBufferData](glbufferdata.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glMapBufferRange](glmapbufferrange.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glUnmapBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glUnmapBuffer.xhtml)"
- name: glUnmapNamedBuffer
  id: glunmapbuffer.xhtml#glUnmapNamedBuffer
  summary: Specifies the name of the buffer object for glUnmapNamedBuffer
  belongs_to: glUnmapBuffer
  description: "`GLboolean `**`glUnmapNamedBuffer`**`(` GLuint `buffer``)`;\n\n## Parameters\n\n*`target`*\n\nSpecifies the target to which the buffer object is bound for `glUnmapBuffer`, which must be one of the buffer binding targets in the following table:\n\n|  **Buffer Binding Target**     |  **Purpose**                       |\n|:-------------------------------|:-----------------------------------|\n| `GL_ARRAY_BUFFER`              | Vertex attributes                  |\n| `GL_ATOMIC_COUNTER_BUFFER`     | Atomic counter storage             |\n| `GL_COPY_READ_BUFFER`          | Buffer copy source                 |\n| `GL_COPY_WRITE_BUFFER`         | Buffer copy destination            |\n| `GL_DISPATCH_INDIRECT_BUFFER`  | Indirect compute dispatch commands |\n| `GL_DRAW_INDIRECT_BUFFER`      | Indirect command arguments         |\n| `GL_ELEMENT_ARRAY_BUFFER`      | Vertex array indices               |\n| `GL_PIXEL_PACK_BUFFER`         | Pixel read target                  |\n| `GL_PIXEL_UNPACK_BUFFER`       | Texture data source                |\n| `GL_QUERY_BUFFER`              | Query result buffer                |\n| `GL_SHADER_STORAGE_BUFFER`     | Read-write storage for shaders     |\n| `GL_TEXTURE_BUFFER`            | Texture data buffer                |\n| `GL_TRANSFORM_FEEDBACK_BUFFER` | Transform feedback buffer          |\n| `GL_UNIFORM_BUFFER`            | Uniform block storage              |\n\n*`buffer`*\n\nSpecifies the name of the buffer object for `glUnmapNamedBuffer`.\n\n## Description\n\n`glUnmapBuffer` and `glUnmapNamedBuffer` unmap (release) any mapping of a specified buffer object into the client's address space (see [glMapBufferRange](glmapbufferrange.xhtml) and [glMapBuffer](glmapbuffer.xhtml)).\n\nIf a mapping is not unmapped before the corresponding buffer object's data store is used by the GL, an error will be generated by any GL command that attempts to dereference the buffer object's data store, unless the buffer was successfully mapped with `GL_MAP_PERSISTENT_BIT` (see [glMapBufferRange](glmapbufferrange.xhtml)). When a data store is unmapped, the mapped pointer becomes invalid.\n\n`glUnmapBuffer` returns `GL_TRUE` unless the data store contents have become corrupt during the time the data store was mapped. This can occur for system-specific reasons that affect the availability of graphics memory, such as screen mode changes. In such situations, `GL_FALSE` is returned and the data store contents are undefined. An application must detect this rare condition and reinitialize the data store.\n\nA buffer object's mapped data store is automatically unmapped when the buffer object is deleted or its data store is recreated with [glBufferData](glbufferdata.xhtml)).\n\n## Notes\n\nIf an error is generated, `glUnmapBuffer` returns `GL_FALSE`.\n\nThe `GL_ATOMIC_COUNTER_BUFFER` target is accepted only if the GL version is 4.2 or greater.\n\nThe `GL_DISPATCH_INDIRECT_BUFFER` and `GL_SHADER_STORAGE_BUFFER` targets are available only if the GL version is 4.3 or greater.\n\nThe `GL_QUERY_BUFFER` target is available only if the GL version is 4.4 or greater.\n\n## Errors\n\n`GL_INVALID_ENUM` is generated by `glUnmapBuffer` if *`target`* is not one of the buffer binding targets listed above.\n\n`GL_INVALID_OPERATION` is generated by `glUnmapBuffer` if zero is bound to *`target`*.\n\n`GL_INVALID_OPERATION` is generated by `glUnmapNamedBuffer` if *`buffer`* is not the name of an existing buffer object.\n\n`GL_INVALID_OPERATION` is generated if the buffer object is not in a mapped state.\n\n## Associated Gets\n\n[glGetBufferParameter](glgetbufferparameter.xhtml) with argument `GL_BUFFER_MAPPED`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glUnmapBuffer`               |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glUnmapNamedBuffer`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glBufferData](glbufferdata.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml), [glMapBuffer](glmapbuffer.xhtml), [glMapBufferRange](glmapbufferrange.xhtml)\n\n## Copyright\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2005 Addison-Wesley. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glUnmapBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glUnmapBuffer.xhtml)"
- name: glUseProgram
  id: gluseprogram.xhtml
  summary: program Specifies the handle of the program object whose executables are to be used as part of current rendering state
  description: "## Name\n\nglUseProgram — Installs a program object as part of current rendering state\n\n## C Specification\n\n`void `**`glUseProgram`**`(` GLuint `program``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the handle of the program object whose executables are to be used as part of current rendering state.\n\n## Description\n\n`glUseProgram` installs the program object specified by *`program`* as part of current rendering state. One or more executables are created in a program object by successfully attaching shader objects to it with [glAttachShader](glattachshader.xhtml), successfully compiling the shader objects with [glCompileShader](glcompileshader.xhtml), and successfully linking the program object with [glLinkProgram](gllinkprogram.xhtml).\n\nA program object will contain an executable that will run on the vertex processor if it contains one or more shader objects of type `GL_VERTEX_SHADER` that have been successfully compiled and linked. A program object will contain an executable that will run on the geometry processor if it contains one or more shader objects of type `GL_GEOMETRY_SHADER` that have been successfully compiled and linked. Similarly, a program object will contain an executable that will run on the fragment processor if it contains one or more shader objects of type `GL_FRAGMENT_SHADER` that have been successfully compiled and linked.\n\nWhile a program object is in use, applications are free to modify attached shader objects, compile attached shader objects, attach additional shader objects, and detach or delete shader objects. None of these operations will affect the executables that are part of the current state. However, relinking the program object that is currently in use will install the program object as part of the current rendering state if the link operation was successful (see [glLinkProgram](gllinkprogram.xhtml) ). If the program object currently in use is relinked unsuccessfully, its link status will be set to `GL_FALSE`, but the executables and associated state will remain part of the current state until a subsequent call to `glUseProgram` removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked.\n\nIf *`program`* is zero, then the current rendering state refers to an *invalid* program object and the results of shader execution are undefined. However, this is not an error.\n\nIf *`program`* does not contain shader objects of type `GL_FRAGMENT_SHADER`, an executable will be installed on the vertex, and possibly geometry processors, but the results of fragment shader execution will be undefined.\n\n## Notes\n\nLike buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.\n\nApplications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is neither 0 nor a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n`GL_INVALID_OPERATION` is generated if *`program`* could not be made part of current state.\n\n`GL_INVALID_OPERATION` is generated if transform feedback mode is active.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with the argument `GL_CURRENT_PROGRAM`\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with a valid program object and the index of an active attribute variable\n\n[glGetActiveUniform](glgetactiveuniform.xhtml) with a valid program object and the index of an active uniform variable\n\n[glGetAttachedShaders](glgetattachedshaders.xhtml) with a valid program object\n\n[glGetAttribLocation](glgetattriblocation.xhtml) with a valid program object and the name of an attribute variable\n\n[glGetProgram](glgetprogram.xhtml) with a valid program object and the parameter to be queried\n\n[glGetProgramInfoLog](glgetprograminfolog.xhtml) with a valid program object\n\n[glGetUniform](glgetuniform.xhtml) with a valid program object and the location of a uniform variable\n\n[glGetUniformLocation](glgetuniformlocation.xhtml) with a valid program object and the name of a uniform variable\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glUseProgram`              |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glAttachShader](glattachshader.xhtml), [glBindAttribLocation](glbindattriblocation.xhtml), [glCompileShader](glcompileshader.xhtml), [glCreateProgram](glcreateprogram.xhtml), [glDeleteProgram](gldeleteprogram.xhtml), [glDetachShader](gldetachshader.xhtml), [glLinkProgram](gllinkprogram.xhtml), [glUniform](gluniform.xhtml), [glValidateProgram](glvalidateprogram.xhtml), [glVertexAttrib](glvertexattrib.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glUseProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glUseProgram.xhtml)"
- name: glUseProgramStages
  id: gluseprogramstages.xhtml
  summary: pipeline Specifies the program pipeline object to which to bind stages from program
  description: "## Name\n\nglUseProgramStages — bind stages of a program object to a program pipeline\n\n## C Specification\n\n`void `**`glUseProgramStages`**`(` GLuint `pipeline`, GLbitfield `stages`, GLuint `program``)`;\n\n## Parameters\n\n *`pipeline`*  \nSpecifies the program pipeline object to which to bind stages from *`program`*.\n\n *`stages`*  \nSpecifies a set of program stages to bind to the program pipeline object.\n\n *`program`*  \nSpecifies the program object containing the shader executables to use in *`pipeline`*.\n\n## Description\n\n`glUseProgramStages` binds executables from a program object associated with a specified set of shader stages to the program pipeline object given by *`pipeline`*. *`pipeline`* specifies the program pipeline object to which to bind the executables. *`stages`* contains a logical combination of bits indicating the shader stages to use within *`program`* with the program pipeline object *`pipeline`*. *`stages`* must be a logical combination of `GL_VERTEX_SHADER_BIT`, `GL_TESS_CONTROL_SHADER_BIT`, `GL_TESS_EVALUATION_SHADER_BIT`, `GL_GEOMETRY_SHADER_BIT`, `GL_FRAGMENT_SHADER_BIT` and `GL_COMPUTE_SHADER_BIT`. Additionally, the special value `GL_ALL_SHADER_BITS` may be specified to indicate that all executables contained in *`program`* should be installed in *`pipeline`*.\n\nIf *`program`* refers to a program object with a valid shader attached for an indicated shader stage, `glUseProgramStages` installs the executable code for that stage in the indicated program pipeline object *`pipeline`*. If *`program`* is zero, or refers to a program object with no valid shader executable for a given stage, it is as if the pipeline object has no programmable stage configured for the indicated shader stages. If *`stages`* contains bits other than those listed above, and is not equal to `GL_ALL_SHADER_BITS`, an error is generated.\n\n## Notes\n\nThe `GL_COMPUTE_SHADER_BIT` bit is available only if the GL version is 4.3 or greater.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`shaders`* contains set bits that are not recognized, and is not the reserved value `GL_ALL_SHADER_BITS`.\n\n`GL_INVALID_OPERATION` is generated if *`program`* refers to a program object that was not linked with its `GL_PROGRAM_SEPARABLE` status set.\n\n`GL_INVALID_OPERATION` is generated if *`program`* refers to a program object that has not been successfully linked.\n\n`GL_INVALID_OPERATION` is generated if *`pipeline`* is not a name previously returned from a call to [glGenProgramPipelines](glgenprogrampipelines.xhtml) or if such a name has been deleted by a call to [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml).\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glUseProgramStages`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenProgramPipelines](glgenprogrampipelines.xhtml), [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml), [glIsProgramPipeline](glisprogrampipeline.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glUseProgramStages.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glUseProgramStages.xhtml)"
- name: glValidateProgram
  id: glvalidateprogram.xhtml
  summary: program Specifies the handle of the program object to be validated
  description: "## Name\n\nglValidateProgram — Validates a program object\n\n## C Specification\n\n`void `**`glValidateProgram`**`(` GLuint `program``)`;\n\n## Parameters\n\n *`program`*  \nSpecifies the handle of the program object to be validated.\n\n## Description\n\n`glValidateProgram` checks to see whether the executables contained in *`program`* can execute given the current OpenGL state. The information generated by the validation process will be stored in *`program`*'s information log. The validation information may consist of an empty string, or it may be a string containing information about how the current program object interacts with the rest of current OpenGL state. This provides a way for OpenGL implementers to convey more information about why the current program is inefficient, suboptimal, failing to execute, and so on.\n\nThe status of the validation operation will be stored as part of the program object's state. This value will be set to `GL_TRUE` if the validation succeeded, and `GL_FALSE` otherwise. It can be queried by calling [glGetProgram](glgetprogram.xhtml) with arguments *`program`* and `GL_VALIDATE_STATUS`. If validation is successful, *`program`* is guaranteed to execute given the current state. Otherwise, *`program`* is guaranteed to not execute.\n\nThis function is typically useful only during application development. The informational string stored in the information log is completely implementation dependent; therefore, an application should not expect different OpenGL implementations to produce identical information strings.\n\n## Notes\n\nThis function mimics the validation operation that OpenGL implementations must perform when rendering commands are issued while programmable shaders are part of current state. The error `GL_INVALID_OPERATION` will be generated by any command that triggers the rendering of geometry if:\n\n- any two active samplers in the current program object are of different types, but refer to the same texture image unit,\n\n- the number of active samplers in the program exceeds the maximum number of texture image units allowed.\n\nIt may be difficult or cause a performance degradation for applications to catch these errors when rendering commands are issued. Therefore, applications are advised to make calls to `glValidateProgram` to detect these issues during application development.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`program`* is not a value generated by OpenGL.\n\n`GL_INVALID_OPERATION` is generated if *`program`* is not a program object.\n\n## Associated Gets\n\n[glGetProgram](glgetprogram.xhtml) with arguments *`program`* and `GL_VALIDATE_STATUS`\n\n[glGetProgramInfoLog](glgetprograminfolog.xhtml) with argument *`program`*\n\n[ glIsProgram ](glisprogram.xhtml)\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glValidateProgram`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glLinkProgram](gllinkprogram.xhtml), [glUseProgram](gluseprogram.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glValidateProgram.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glValidateProgram.xhtml)"
- name: glValidateProgramPipeline
  id: glvalidateprogrampipeline.xhtml
  summary: pipeline Specifies the name of a program pipeline object to validate
  description: "## Name\n\nglValidateProgramPipeline — validate a program pipeline object against current GL state\n\n## C Specification\n\n`void `**`glValidateProgramPipeline`**`(` GLuint `pipeline``)`;\n\n## Parameters\n\n *`pipeline`*  \nSpecifies the name of a program pipeline object to validate.\n\n## Description\n\n`glValidateProgramPipeline` instructs the implementation to validate the shader executables contained in *`pipeline`* against the current GL state. The implementation may use this as an opportunity to perform any internal shader modifications that may be required to ensure correct operation of the installed shaders given the current GL state.\n\nAfter a program pipeline has been validated, its validation status is set to `GL_TRUE`. The validation status of a program pipeline object may be queried by calling [glGetProgramPipeline](glgetprogrampipeline.xhtml) with parameter `GL_VALIDATE_STATUS`.\n\nIf *`pipeline`* is a name previously returned from a call to [glGenProgramPipelines](glgenprogrampipelines.xhtml) but that has not yet been bound by a call to [glBindProgramPipeline](glbindprogrampipeline.xhtml), a new program pipeline object is created with name *`pipeline`* and the default state vector.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated if *`pipeline`* is not a name previously returned from a call to [glGenProgramPipelines](glgenprogrampipelines.xhtml) or if such a name has been deleted by a call to [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml).\n\n## Associated Gets\n\n[glGetProgramPipeline](glgetprogrampipeline.xhtml) with parameter `GL_VALIDATE_STATUS`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glValidateProgramPipeline` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glGenProgramPipelines](glgenprogrampipelines.xhtml), [glBindProgramPipeline](glbindprogrampipeline.xhtml), [glDeleteProgramPipelines](gldeleteprogrampipelines.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glValidateProgramPipeline.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glValidateProgramPipeline.xhtml)"
- name: glVertexArrayAttribBinding
  id: glvertexattribbinding.xhtml#glVertexArrayAttribBinding
  summary: Specifies the name of the vertex array object for glVertexArrayAttribBinding
  belongs_to: glVertexAttribBinding
  description: "`void `**`glVertexArrayAttribBinding`**`(` GLuint `vaobj`, GLuint `attribindex`, GLuint `bindingindex``)`;\n\n## Parameters\n\n*`vaobj`*\n\nSpecifies the name of the vertex array object for `glVertexArrayAttribBinding`.\n\n*`attribindex`*\n\nThe index of the attribute to associate with a vertex buffer binding.\n\n*`bindingindex`*\n\nThe index of the vertex buffer binding with which to associate the generic vertex attribute.\n\n## Description\n\n`glVertexAttribBinding` and `glVertexArrayAttribBinding` establishes an association between the generic vertex attribute of a vertex array object whose index is given by *`attribindex`*, and a vertex buffer binding whose index is given by *`bindingindex`*. For `glVertexAttribBinding`, the vertex array object affected is that currently bound. For `glVertexArrayAttribBinding`, *`vaobj`* is the name of the vertex array object.\n\n*`attribindex`* must be less than the value of `GL_MAX_VERTEX_ATTRIBS` and *`bindingindex`* must be less than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glVertexAttribBinding` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayAttribBinding` if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_VALUE` is generated if *`attribindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_VALUE` is generated if *`bindingindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with arguments `GL_MAX_VERTEX_ATTRIB_BINDINGS`, `GL_VERTEX_BINDING_DIVISOR`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glVertexArrayAttribBinding`  |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glVertexAttribBinding`       |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBindVertexBuffer](glbindvertexbuffer.xhtml), [glVertexAttribFormat](glvertexattribformat.xhtml), [glVertexBindingDivisor](glvertexbindingdivisor.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribBinding.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribBinding.xhtml)"
- name: glVertexArrayAttribFormat
  id: glvertexattribformat.xhtml#glVertexArrayAttribFormat
  summary: null
  belongs_to: glVertexAttribFormat
  description: '`void `**`glVertexArrayAttribFormat`**`(` GLuint `vaobj`, GLuint `attribindex`, GLint `size`, GLenum `type`, GLboolean `normalized`, GLuint `relativeoffset``)`;'
- name: glVertexArrayAttribIFormat
  id: glvertexattribformat.xhtml#glVertexArrayAttribIFormat
  summary: null
  belongs_to: glVertexAttribFormat
  description: '`void `**`glVertexArrayAttribIFormat`**`(` GLuint `vaobj`, GLuint `attribindex`, GLint `size`, GLenum `type`, GLuint `relativeoffset``)`;'
- name: glVertexArrayAttribLFormat
  id: glvertexattribformat.xhtml#glVertexArrayAttribLFormat
  summary: Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions
  belongs_to: glVertexAttribFormat
  description: "`void `**`glVertexArrayAttribLFormat`**`(` GLuint `vaobj`, GLuint `attribindex`, GLint `size`, GLenum `type`, GLuint `relativeoffset``)`;\n\n## Parameters\n\n*`vaobj`*\n\nSpecifies the name of the vertex array object for `glVertexArrayAttrib{I, L}Format` functions.\n\n*`attribindex`*\n\nThe generic vertex attribute array being described.\n\n*`size`*\n\nThe number of values per vertex that are stored in the array.\n\n*`type`*\n\nThe type of the data stored in the array.\n\n*`normalized`*\n\nSpecifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if *`type`* is `GL_FIXED`.\n\n*`relativeoffset`*\n\nThe distance between elements within the buffer.\n\n## Description\n\n`glVertexAttribFormat`, `glVertexAttribIFormat` and `glVertexAttribLFormat`, as well as `glVertexArrayAttribFormat`, `glVertexArrayAttribIFormat` and `glVertexArrayAttribLFormat` specify the organization of data in vertex arrays. The first three calls operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID *`vaobj`*. *`attribindex`* specifies the index of the generic vertex attribute array whose data layout is being described, and must be less than the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n*`size`* determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3, 4, or `GL_BGRA`. *`type`* indicates the type of the data. If *`type`* is one of `GL_BYTE`, `GL_SHORT`, `GL_INT`, `GL_FIXED`, `GL_FLOAT`, `GL_HALF_FLOAT`, and `GL_DOUBLE` indicate types `GLbyte`, `GLshort`, `GLint`, `GLfixed`, `GLfloat`, `GLhalf`, and `GLdouble`, respectively; the values `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, and `GL_UNSIGNED_INT` indicate types `GLubyte`, `GLushort`, and `GLuint`, respectively; the values `GL_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_2_10_10_10_REV` indicating respectively four signed or unsigned elements packed into a single `GLuint`; and the value `GL_UNSIGNED_INT_10F_11F_11F_REV` indicating three floating point values packed into a single `GLuint`.\n\n`glVertexAttribLFormat` and `glVertexArrayAttribLFormat` is used to specify layout for data associated with a generic attribute variable declared as 64-bit double precision components. For `glVertexAttribLFormat` and `glVertexArrayAttribLFormat`, *`type`* must be `GL_DOUBLE`. In contrast to `glVertexAttribFormat` or `glVertexArrayAttribFormat`, which will cause data declared as `GL_DOUBLE` to be converted to 32-bit representation, `glVertexAttribLFormat` and `glVertexArrayAttribLFormat` cause such data to be left in its natural, 64-bit representation.\n\nFor `glVertexAttribFormat` and `glVertexArrayAttribFormat`, if *`normalized`* is `GL_TRUE`, then integer data is normalized to the range \\[-1, 1\\] or \\[0, 1\\] if it is signed or unsigned, respectively. If *`normalized`* is `GL_FALSE` then integer data is directly converted to floating point.\n\n*`relativeoffset`* is the offset, measured in basic machine units of the first element relative to the start of the vertex buffer binding this attribute fetches from.\n\n`glVertexAttribFormat` and `glVertexArrayAttribFormat` should be used to describe vertex attribute layout for floating-point vertex attributes, `glVertexAttribIFormat` and `glVertexArrayAttribIFormat` should be used to describe vertex attribute layout for integer vertex attribute, and `glVertexAttribLFormat` and `glVertexArrayAttribLFormat` should be used to describe the layout for 64-bit vertex attributes. Data for an array specified by `glVertexAttribIFormat` and `glVertexArrayAttribIFormat` will always be left as integer values; such data are referred to as pure integers.\n\n## Notes\n\n`GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for *`type`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`attribindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_VALUE` is generated if *`size`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`relativeoffset`* is greater than the value of `GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET`.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not one of the accepted tokens.\n\n`GL_INVALID_ENUM` is generated by `glVertexAttribIFormat`, `glVertexAttribLFormat`, `glVertexArrayAttribIFormat` and `glVertexArrayAttribLFormat` if *`type`* is `GL_UNSIGNED_INT_10F_11F_11F_REV`.\n\n`GL_INVALID_OPERATION` is generated by `glVertexAttribFormat`, `glVertexAttribIFormat` and `glVertexAttribLFormat` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayAttribFormat`, `glVertexArrayAttribIFormat` and `glVertexArrayAttribLFormat` if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_OPERATION` is generated under any of the following conditions:\n\n- *`size`* is `GL_BGRA` and *`type`* is not `GL_UNSIGNED_BYTE`, `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n- *`type`* is `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, and *`size`* is neither 4 nor `GL_BGRA`.\n\n- *`type`* is `GL_UNSIGNED_INT_10F_11F_11F_REV` and *`size`* is not 3.\n\n- *`size`* is `GL_BGRA` and *`normalized`* is `GL_FALSE`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with arguments `GL_MAX_VERTEX_ATTRIB_BINDINGS`, or `GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET`.\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with argument `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glVertexArrayAttribFormat`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glVertexArrayAttribIFormat`  |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glVertexArrayAttribLFormat`  |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glVertexAttribFormat`        |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribIFormat`       |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribLFormat`       |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBindVertexBuffer](glbindvertexbuffer.xhtml), [glVertexAttribBinding](glvertexattribbinding.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml), [glVertexBindingDivisor](glvertexbindingdivisor.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribFormat.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribFormat.xhtml)"
- name: glVertexArrayBindingDivisor
  id: glvertexbindingdivisor.xhtml#glVertexArrayBindingDivisor
  summary: Specifies the name of the vertex array object for glVertexArrayBindingDivisor function
  belongs_to: glVertexBindingDivisor
  description: "`void `**`glVertexArrayBindingDivisor`**`(` GLuint `vaobj`, GLuint `bindingindex`, GLuint `divisor``)`;\n\n## Parameters\n\n*`vaobj`*\n\nSpecifies the name of the vertex array object for `glVertexArrayBindingDivisor` function.\n\n*`bindingindex`*\n\nThe index of the binding whose divisor to modify.\n\n*`divisor`*\n\nThe new value for the instance step rate to apply.\n\n## Description\n\n`glVertexBindingDivisor` and `glVertexArrayBindingDivisor` modify the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw command. If *`divisor`* is zero, the attributes using the buffer bound to *`bindingindex`* advance once per vertex. If *`divisor`* is non-zero, the attributes advance once per *`divisor`* instances of the set(s) of vertices being rendered. An attribute is referred to as *instanced* if the corresponding *`divisor`* value is non-zero.\n\n`glVertexBindingDivisor` uses currently bound vertex array object , whereas `glVertexArrayBindingDivisor` updates state of the vertex array object with ID *`vaobj`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`bindingindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n`GL_INVALID_OPERATION` by `glVertexBindingDivisor` is generated if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayBindingDivisor` if *`vaobj`* is not the name of an existing vertex array object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with arguments `GL_MAX_VERTEX_ATTRIB_BINDINGS`, `GL_VERTEX_BINDING_DIVISOR`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glVertexArrayBindingDivisor` |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n| `glVertexBindingDivisor`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBindVertexBuffer](glbindvertexbuffer.xhtml), [glVertexAttribBinding](glvertexattribbinding.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml), [glVertexBindingDivisor](glvertexbindingdivisor.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexBindingDivisor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexBindingDivisor.xhtml)"
- name: glVertexArrayElementBuffer
  id: glvertexarrayelementbuffer.xhtml
  summary: vaobj Specifies the name of the vertex array object
  description: "## Name\n\nglVertexArrayElementBuffer — configures element array buffer binding of a vertex array object\n\n## C Specification\n\n`void `**`glVertexArrayElementBuffer`**`(` GLuint `vaobj`, GLuint `buffer``)`;\n\n## Parameters\n\n *`vaobj`*  \nSpecifies the name of the vertex array object.\n\n *`buffer`*  \nSpecifies the name of the buffer object to use for the element array buffer binding.\n\n## Description\n\n`glVertexArrayElementBuffer` binds a buffer object with id *`buffer`* to the element array buffer bind point of a vertex array object with id *`vaobj`*. If *`buffer`* is zero, any existing element array buffer binding to *`vaobj`* is removed.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_ELEMENT_ARRAY_BUFFER_BINDING`.\n\n[glGetVertexArrayiv](glgetvertexarrayiv.xhtml) with argument `GL_ELEMENT_ARRAY_BUFFER_BINDING`.\n\n## Errors\n\n`GL_INVALID_OPERATION` error is generated if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_OPERATION` error is generated if *`buffer`* is not zero or the name of an existing buffer object.\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glVertexArrayElementBuffer` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n\n## See Also\n\n[glGet](glget.xhtml), [glGetVertexArrayiv](glgetvertexarrayiv.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexArrayElementBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexArrayElementBuffer.xhtml)"
- name: glVertexArrayVertexBuffer
  id: glbindvertexbuffer.xhtml#glVertexArrayVertexBuffer
  summary: Specifies the name of the vertex array object to be used by glVertexArrayVertexBuffer function
  belongs_to: glBindVertexBuffer
  description: "`void `**`glVertexArrayVertexBuffer`**`(` GLuint `vaobj`, GLuint `bindingindex`, GLuint `buffer`, GLintptr `offset`, GLsizei `stride``)`;\n\n## Parameters\n\n*`vaobj`*\n\nSpecifies the name of the vertex array object to be used by `glVertexArrayVertexBuffer` function.\n\n*`bindingindex`*\n\nThe index of the vertex buffer binding point to which to bind the buffer.\n\n*`buffer`*\n\nThe name of a buffer to bind to the vertex buffer binding point.\n\n*`offset`*\n\nThe offset of the first element of the buffer.\n\n*`stride`*\n\nThe distance between elements within the buffer.\n\n## Description\n\n`glBindVertexBuffer` and `glVertexArrayVertexBuffer` bind the buffer named *`buffer`* to the vertex buffer binding point whose index is given by *`bindingindex`*. `glBindVertexBuffer` modifies the binding of the currently bound vertex array object, whereas `glVertexArrayVertexBuffer` allows the caller to specify ID of the vertex array object with an argument named *`vaobj`*, for which the binding should be modified. *`offset`* and *`stride`* specify the offset of the first element within the buffer and the distance between elements within the buffer, respectively, and are both measured in basic machine units. *`bindingindex`* must be less than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`. *`offset`* and *`stride`* must be greater than or equal to zero. If *`buffer`* is zero, then any buffer currently bound to the specified binding point is unbound.\n\nIf *`buffer`* is not the name of an existing buffer object, the GL first creates a new state vector, initialized with a zero-sized memory buffer and comprising all the state and with the same initial values as in case of `glBindBuffer`. *`buffer`* is then attached to the specified *`bindingindex`* of the vertex array object.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glBindVertexBuffer` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayVertexBuffer` if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_VALUE` is generated if *`bindingindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n`GL_INVALID_VALUE` is generated if *`offset`* or *`stride`* is less than zero, or if stride is greater than the value of `GL_MAX_VERTEX_ATTRIB_STRIDE`.\n\n`GL_INVALID_VALUE` is generated if *`buffer`* is not zero or the name of an existing buffer object (as returned by `glGenBuffers` or `glCreateBuffers`).\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBindVertexBuffer`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |\n| `glVertexArrayVertexBuffer`   |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glVertexAttribBinding](glvertexattribbinding.xhtml), [glVertexAttribFormat](glvertexattribformat.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml), [glVertexBindingDivisor](glvertexbindingdivisor.xhtml).\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexBuffer.xhtml)"
- name: glVertexArrayVertexBuffers
  id: glbindvertexbuffers.xhtml#glVertexArrayVertexBuffers
  summary: Specifies the name of the vertex array object for glVertexArrayVertexBuffers
  belongs_to: glBindVertexBuffers
  description: "`void `**`glVertexArrayVertexBuffers`**`(` GLuint `vaobj`, GLuint `first`, GLsizei `count`, const GLuint \\*`buffers`, const GLintptr \\*`offsets`, const GLsizei \\*`strides``)`;\n\n## Parameters\n\n*`vaobj`*\n\nSpecifies the name of the vertex array object for `glVertexArrayVertexBuffers`.\n\n*`first`*\n\nSpecifies the first vertex buffer binding point to which a buffer object is to be bound.\n\n*`count`*\n\nSpecifies the number of buffers to bind.\n\n*`buffers`*\n\nSpecifies the address of an array of names of existing buffer objects.\n\n*`offsets`*\n\nSpecifies the address of an array of offsets to associate with the binding points.\n\n*`strides`*\n\nSpecifies the address of an array of strides to associate with the binding points.\n\n## Description\n\n`glBindVertexBuffers` and `glVertexArrayVertexBuffers` bind storage from an array of existing buffer objects to a specified number of consecutive vertex buffer binding points units in a vertex array object. For `glBindVertexBuffers`, the vertex array object is the currently bound vertex array object. For `glVertexArrayVertexBuffers`, *`vaobj`* is the name of the vertex array object.\n\n*`count`* existing buffer objects are bound to vertex buffer binding points numbered $first$ through $first + count - 1$. If *`buffers`* is not NULL, it specifies an array of *`count`* values, each of which must be zero or the name of an existing buffer object. *`offsets`* and *`strides`* specify arrays of *`count`* values indicating the offset of the first element and stride between elements in each buffer, respectively. If *`buffers`* is NULL, each affected vertex buffer binding point from $first$ through $first + count - 1$ will be reset to have no bound buffer object. In this case, the offsets and strides associated with the binding points are set to default values, ignoring *`offsets`* and *`strides`*.\n\n`glBindVertexBuffers` is equivalent (assuming no errors are generated) to:\n\n``` programlisting\n    for (i = 0; i < count; i++) {\n        if (buffers == NULL) {\n            glBindVertexBuffer(first + i, 0, 0, 16);\n        } else {\n            glBindVertexBuffer(first + i, buffers[i], offsets[i], strides[i]);\n        }\n    }\n```\n\nexcept that buffers will not be created if they do not exist.\n\n`glVertexArrayVertexBuffers` is equivalent to the pseudocode above, but replacing `glBindVertexBuffers`(args) with `glVertexArrayVertexBuffers`(vaobj, args).\n\nThe values specified in *`buffers`*, *`offsets`*, and *`strides`* will be checked separately for each vertex buffer binding point. When a value for a specific vertex buffer binding point is invalid, the state for that binding point will be unchanged and an error will be generated. However, state for other vertex buffer binding points will still be changed if their corresponding values are valid.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glBindVertexBuffers` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayVertexBuffers` if *`vaobj`* is not the name of the vertex array object.\n\n`GL_INVALID_OPERATION` is generated if $first + count$ is greater than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n`GL_INVALID_OPERATION` is generated if any value in `buffers` is not zero or the name of an existing buffer object.\n\n`GL_INVALID_VALUE` is generated if any value in *`offsets`* or *`strides`* is negative, or if a value is *`stride`* is greater than the value of `GL_MAX_VERTEX_ATTRIB_STRIDE`.\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glBindVertexBuffers`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |\n| `glVertexArrayVertexBuffers`  |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |\n\n## See Also\n\n[glGenBuffers](glgenbuffers.xhtml), [glBindBuffer](glbindbuffer.xhtml), [glDeleteBuffers](gldeletebuffers.xhtml)[glDeleteTextures](gldeletetextures.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexBuffers.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glBindVertexBuffers.xhtml)"
- name: glVertexAttrib
  id: glvertexattrib.xhtml
  summary: index Specifies the index of the generic vertex attribute to be modified
  description: "## Name\n\nglVertexAttrib — Specifies the value of a generic vertex attribute\n\n## C Specification\n\n`void `**`glVertexAttrib1f`**`(` GLuint `index`, GLfloat `v0``)`;\n\n`void `**`glVertexAttrib1s`**`(` GLuint `index`, GLshort `v0``)`;\n\n`void `**`glVertexAttrib1d`**`(` GLuint `index`, GLdouble `v0``)`;\n\n`void `**`glVertexAttribI1i`**`(` GLuint `index`, GLint `v0``)`;\n\n`void `**`glVertexAttribI1ui`**`(` GLuint `index`, GLuint `v0``)`;\n\n`void `**`glVertexAttrib2f`**`(` GLuint `index`, GLfloat `v0`, GLfloat `v1``)`;\n\n`void `**`glVertexAttrib2s`**`(` GLuint `index`, GLshort `v0`, GLshort `v1``)`;\n\n`void `**`glVertexAttrib2d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1``)`;\n\n`void `**`glVertexAttribI2i`**`(` GLuint `index`, GLint `v0`, GLint `v1``)`;\n\n`void `**`glVertexAttribI2ui`**`(` GLuint `index`, GLuint `v0`, GLuint `v1``)`;\n\n`void `**`glVertexAttrib3f`**`(` GLuint `index`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2``)`;\n\n`void `**`glVertexAttrib3s`**`(` GLuint `index`, GLshort `v0`, GLshort `v1`, GLshort `v2``)`;\n\n`void `**`glVertexAttrib3d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1`, GLdouble `v2``)`;\n\n`void `**`glVertexAttribI3i`**`(` GLuint `index`, GLint `v0`, GLint `v1`, GLint `v2``)`;\n\n`void `**`glVertexAttribI3ui`**`(` GLuint `index`, GLuint `v0`, GLuint `v1`, GLuint `v2``)`;\n\n`void `**`glVertexAttrib4f`**`(` GLuint `index`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2`, GLfloat `v3``)`;\n\n`void `**`glVertexAttrib4s`**`(` GLuint `index`, GLshort `v0`, GLshort `v1`, GLshort `v2`, GLshort `v3``)`;\n\n`void `**`glVertexAttrib4d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1`, GLdouble `v2`, GLdouble `v3``)`;\n\n`void `**`glVertexAttrib4Nub`**`(` GLuint `index`, GLubyte `v0`, GLubyte `v1`, GLubyte `v2`, GLubyte `v3``)`;\n\n`void `**`glVertexAttribI4i`**`(` GLuint `index`, GLint `v0`, GLint `v1`, GLint `v2`, GLint `v3``)`;\n\n`void `**`glVertexAttribI4ui`**`(` GLuint `index`, GLuint `v0`, GLuint `v1`, GLuint `v2`, GLuint `v3``)`;\n\n`void `**`glVertexAttribL1d`**`(` GLuint `index`, GLdouble `v0``)`;\n\n`void `**`glVertexAttribL2d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1``)`;\n\n`void `**`glVertexAttribL3d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1`, GLdouble `v2``)`;\n\n`void `**`glVertexAttribL4d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1`, GLdouble `v2`, GLdouble `v3``)`;\n\n`void `**`glVertexAttrib1fv`**`(` GLuint `index`, const GLfloat \\*`v``)`;\n\n`void `**`glVertexAttrib1sv`**`(` GLuint `index`, const GLshort \\*`v``)`;\n\n`void `**`glVertexAttrib1dv`**`(` GLuint `index`, const GLdouble \\*`v``)`;\n\n`void `**`glVertexAttribI1iv`**`(` GLuint `index`, const GLint \\*`v``)`;\n\n`void `**`glVertexAttribI1uiv`**`(` GLuint `index`, const GLuint \\*`v``)`;\n\n`void `**`glVertexAttrib2fv`**`(` GLuint `index`, const GLfloat \\*`v``)`;\n\n`void `**`glVertexAttrib2sv`**`(` GLuint `index`, const GLshort \\*`v``)`;\n\n`void `**`glVertexAttrib2dv`**`(` GLuint `index`, const GLdouble \\*`v``)`;\n\n`void `**`glVertexAttribI2iv`**`(` GLuint `index`, const GLint \\*`v``)`;\n\n`void `**`glVertexAttribI2uiv`**`(` GLuint `index`, const GLuint \\*`v``)`;\n\n`void `**`glVertexAttrib3fv`**`(` GLuint `index`, const GLfloat \\*`v``)`;\n\n`void `**`glVertexAttrib3sv`**`(` GLuint `index`, const GLshort \\*`v``)`;\n\n`void `**`glVertexAttrib3dv`**`(` GLuint `index`, const GLdouble \\*`v``)`;\n\n`void `**`glVertexAttribI3iv`**`(` GLuint `index`, const GLint \\*`v``)`;\n\n`void `**`glVertexAttribI3uiv`**`(` GLuint `index`, const GLuint \\*`v``)`;\n\n`void `**`glVertexAttrib4fv`**`(` GLuint `index`, const GLfloat \\*`v``)`;\n\n`void `**`glVertexAttrib4sv`**`(` GLuint `index`, const GLshort \\*`v``)`;\n\n`void `**`glVertexAttrib4dv`**`(` GLuint `index`, const GLdouble \\*`v``)`;\n\n`void `**`glVertexAttrib4iv`**`(` GLuint `index`, const GLint \\*`v``)`;\n\n`void `**`glVertexAttrib4bv`**`(` GLuint `index`, const GLbyte \\*`v``)`;\n\n`void `**`glVertexAttrib4ubv`**`(` GLuint `index`, const GLubyte \\*`v``)`;\n\n`void `**`glVertexAttrib4usv`**`(` GLuint `index`, const GLushort \\*`v``)`;\n\n`void `**`glVertexAttrib4uiv`**`(` GLuint `index`, const GLuint \\*`v``)`;\n\n`void `**`glVertexAttrib4Nbv`**`(` GLuint `index`, const GLbyte \\*`v``)`;\n\n`void `**`glVertexAttrib4Nsv`**`(` GLuint `index`, const GLshort \\*`v``)`;\n\n`void `**`glVertexAttrib4Niv`**`(` GLuint `index`, const GLint \\*`v``)`;\n\n`void `**`glVertexAttrib4Nubv`**`(` GLuint `index`, const GLubyte \\*`v``)`;\n\n`void `**`glVertexAttrib4Nusv`**`(` GLuint `index`, const GLushort \\*`v``)`;\n\n`void `**`glVertexAttrib4Nuiv`**`(` GLuint `index`, const GLuint \\*`v``)`;\n\n`void `**`glVertexAttribI4bv`**`(` GLuint `index`, const GLbyte \\*`v``)`;\n\n`void `**`glVertexAttribI4ubv`**`(` GLuint `index`, const GLubyte \\*`v``)`;\n\n`void `**`glVertexAttribI4sv`**`(` GLuint `index`, const GLshort \\*`v``)`;\n\n`void `**`glVertexAttribI4usv`**`(` GLuint `index`, const GLushort \\*`v``)`;\n\n`void `**`glVertexAttribI4iv`**`(` GLuint `index`, const GLint \\*`v``)`;\n\n`void `**`glVertexAttribI4uiv`**`(` GLuint `index`, const GLuint \\*`v``)`;\n\n`void `**`glVertexAttribL1dv`**`(` GLuint `index`, const GLdouble \\*`v``)`;\n\n`void `**`glVertexAttribL2dv`**`(` GLuint `index`, const GLdouble \\*`v``)`;\n\n`void `**`glVertexAttribL3dv`**`(` GLuint `index`, const GLdouble \\*`v``)`;\n\n`void `**`glVertexAttribL4dv`**`(` GLuint `index`, const GLdouble \\*`v``)`;\n\n`void `**`glVertexAttribP1ui`**`(` GLuint `index`, GLenum `type`, GLboolean `normalized`, GLuint `value``)`;\n\n`void `**`glVertexAttribP2ui`**`(` GLuint `index`, GLenum `type`, GLboolean `normalized`, GLuint `value``)`;\n\n`void `**`glVertexAttribP3ui`**`(` GLuint `index`, GLenum `type`, GLboolean `normalized`, GLuint `value``)`;\n\n`void `**`glVertexAttribP4ui`**`(` GLuint `index`, GLenum `type`, GLboolean `normalized`, GLuint `value``)`;\n\n## Parameters\n\n *`index`*  \nSpecifies the index of the generic vertex attribute to be modified.\n\n *`v0`*, *`v1`*, *`v2`*, *`v3`*  \nFor the scalar commands, specifies the new values to be used for the specified vertex attribute.\n\n *`v`*  \nFor the vector commands (`glVertexAttrib*v`), specifies a pointer to an array of values to be used for the generic vertex attribute.\n\n *`type`*  \nFor the packed commands (`glVertexAttribP*`), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data.\n\n *`normalized`*  \nFor the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If *`type`* indicates a floating-pont format, then *`normalized`* value must be `GL_FALSE`.\n\n *`value`*  \nFor the packed commands, specifies the new packed value to be used for the specified vertex attribute.\n\n## Description\n\nThe `glVertexAttrib` family of entry points allows an application to pass generic vertex attributes in numbered locations.\n\nGeneric attributes are defined as four-component values that are organized into an array. The first entry of this array is numbered 0, and the size of the array is specified by the implementation-dependent constant `GL_MAX_VERTEX_ATTRIBS`. Individual elements of this array can be modified with a `glVertexAttrib` call that specifies the index of the element to be modified and a value for that element.\n\nThese commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified by *`index`*. A `1` in the name of the command indicates that only one value is passed, and it will be used to modify the first component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component will be set to 1. Similarly, a `2` in the name of the command indicates that values are provided for the first two components, the third component will be set to 0, and the fourth component will be set to 1. A `3` in the name of the command indicates that values are provided for the first three components and the fourth component will be set to 1, whereas a `4` in the name indicates that values are provided for all four components.\n\nThe letters `s`, `f`, `i`, `d`, `ub`, `us`, and `ui` indicate whether the arguments are of type short, float, int, double, unsigned byte, unsigned short, or unsigned int. When `v` is appended to the name, the commands can take a pointer to an array of such values.\n\nAdditional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:\n\nThe commands containing `N` indicate that the arguments will be passed as fixed-point values that are scaled to a normalized range according to the component conversion rules defined by the OpenGL specification. Signed values are understood to represent fixed-point values in the range \\[-1,1\\], and unsigned values are understood to represent fixed-point values in the range \\[0,1\\].\n\nThe commands containing `I` indicate that the arguments are extended to full signed or unsigned integers.\n\nThe commands containing `P` indicate that the arguments are stored as packed components within a larger natural type.\n\nThe commands containing `L` indicate that the arguments are full 64-bit quantities and should be passed directly to shader inputs declared as 64-bit double precision types.\n\nOpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may be loaded using the `glVertexAttrib` entry points. Matrices must be loaded into successive generic attribute slots in column major order, with one column of the matrix in each generic attribute slot.\n\nA user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling [glBindAttribLocation](glbindattriblocation.xhtml). This allows an application to use more descriptive variable names in a vertex shader. A subsequent change to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable in the vertex shader.\n\nThe binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different program object is used.\n\nAn application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable. These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing, the vertex shader will repeatedly use the current value for the generic vertex attribute.\n\n## Notes\n\nGeneric vertex attributes can be updated at any time.\n\nIt is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location. OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.\n\nThere is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes with standard attributes.\n\n`glVertexAttribL` versions are available only if the GL version is 4.1 or higher.\n\n`GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for *`type`* by `glVertexAttribP*` only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_ENUM` is generated if `glVertexAttribP*` is used with a *`type`* other than `GL_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_2_10_10_10_REV`, or `GL_UNSIGNED_INT_10F_11F_11F_REV`.\n\n`GL_INVALID_ENUM` is generated if `glVertexAttribL` is used with a *`type`* other than `GL_DOUBLE`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with the argument `GL_CURRENT_PROGRAM`\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with argument *`program`* and the index of an active attribute variable\n\n[glGetAttribLocation](glgetattriblocation.xhtml) with argument *`program`* and an attribute variable name\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments `GL_CURRENT_VERTEX_ATTRIB` and *`index`*\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glVertexAttrib1d`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib1dv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib1f`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib1fv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib1s`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib1sv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib2d`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib2dv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib2f`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib2fv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib2s`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib2sv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib3d`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib3dv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib3f`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib3fv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib3s`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib3sv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4Nbv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4Niv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4Nsv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4Nub`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4Nubv`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4Nuiv`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4Nusv`       |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4bv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4d`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4dv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4f`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4fv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4iv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4s`          |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4sv`         |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4ubv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4uiv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttrib4usv`        |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI1i`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI1iv`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI1ui`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI1uiv`       |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI2i`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI2iv`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI2ui`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI2uiv`       |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI3i`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI3iv`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI3ui`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI3uiv`       |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI4bv`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI4i`         |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI4iv`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI4sv`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI4ubv`       |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI4ui`        |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI4uiv`       |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribI4usv`       |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribL1d`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribL1dv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribL2d`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribL2dv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribL3d`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribL3dv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribL4d`         |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribL4dv`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribP1ui`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribP2ui`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribP3ui`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribP4ui`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttrib.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttrib.xhtml)"
- name: glVertexAttrib1d
  id: glvertexattrib.xhtml#glVertexAttrib1d
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib1d`**`(` GLuint `index`, GLdouble `v0``)`;'
- name: glVertexAttrib1dv
  id: glvertexattrib.xhtml#glVertexAttrib1dv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib1dv`**`(` GLuint `index`, const GLdouble \*`v``)`;'
- name: glVertexAttrib1f
  id: glvertexattrib.xhtml#glVertexAttrib1f
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib1f`**`(` GLuint `index`, GLfloat `v0``)`;'
- name: glVertexAttrib1fv
  id: glvertexattrib.xhtml#glVertexAttrib1fv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib1fv`**`(` GLuint `index`, const GLfloat \*`v``)`;'
- name: glVertexAttrib1s
  id: glvertexattrib.xhtml#glVertexAttrib1s
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib1s`**`(` GLuint `index`, GLshort `v0``)`;'
- name: glVertexAttrib1sv
  id: glvertexattrib.xhtml#glVertexAttrib1sv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib1sv`**`(` GLuint `index`, const GLshort \*`v``)`;'
- name: glVertexAttrib2d
  id: glvertexattrib.xhtml#glVertexAttrib2d
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib2d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1``)`;'
- name: glVertexAttrib2dv
  id: glvertexattrib.xhtml#glVertexAttrib2dv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib2dv`**`(` GLuint `index`, const GLdouble \*`v``)`;'
- name: glVertexAttrib2f
  id: glvertexattrib.xhtml#glVertexAttrib2f
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib2f`**`(` GLuint `index`, GLfloat `v0`, GLfloat `v1``)`;'
- name: glVertexAttrib2fv
  id: glvertexattrib.xhtml#glVertexAttrib2fv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib2fv`**`(` GLuint `index`, const GLfloat \*`v``)`;'
- name: glVertexAttrib2s
  id: glvertexattrib.xhtml#glVertexAttrib2s
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib2s`**`(` GLuint `index`, GLshort `v0`, GLshort `v1``)`;'
- name: glVertexAttrib2sv
  id: glvertexattrib.xhtml#glVertexAttrib2sv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib2sv`**`(` GLuint `index`, const GLshort \*`v``)`;'
- name: glVertexAttrib3d
  id: glvertexattrib.xhtml#glVertexAttrib3d
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib3d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1`, GLdouble `v2``)`;'
- name: glVertexAttrib3dv
  id: glvertexattrib.xhtml#glVertexAttrib3dv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib3dv`**`(` GLuint `index`, const GLdouble \*`v``)`;'
- name: glVertexAttrib3f
  id: glvertexattrib.xhtml#glVertexAttrib3f
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib3f`**`(` GLuint `index`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2``)`;'
- name: glVertexAttrib3fv
  id: glvertexattrib.xhtml#glVertexAttrib3fv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib3fv`**`(` GLuint `index`, const GLfloat \*`v``)`;'
- name: glVertexAttrib3s
  id: glvertexattrib.xhtml#glVertexAttrib3s
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib3s`**`(` GLuint `index`, GLshort `v0`, GLshort `v1`, GLshort `v2``)`;'
- name: glVertexAttrib3sv
  id: glvertexattrib.xhtml#glVertexAttrib3sv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib3sv`**`(` GLuint `index`, const GLshort \*`v``)`;'
- name: glVertexAttrib4bv
  id: glvertexattrib.xhtml#glVertexAttrib4bv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4bv`**`(` GLuint `index`, const GLbyte \*`v``)`;'
- name: glVertexAttrib4d
  id: glvertexattrib.xhtml#glVertexAttrib4d
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1`, GLdouble `v2`, GLdouble `v3``)`;'
- name: glVertexAttrib4dv
  id: glvertexattrib.xhtml#glVertexAttrib4dv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4dv`**`(` GLuint `index`, const GLdouble \*`v``)`;'
- name: glVertexAttrib4f
  id: glvertexattrib.xhtml#glVertexAttrib4f
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4f`**`(` GLuint `index`, GLfloat `v0`, GLfloat `v1`, GLfloat `v2`, GLfloat `v3``)`;'
- name: glVertexAttrib4fv
  id: glvertexattrib.xhtml#glVertexAttrib4fv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4fv`**`(` GLuint `index`, const GLfloat \*`v``)`;'
- name: glVertexAttrib4iv
  id: glvertexattrib.xhtml#glVertexAttrib4iv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4iv`**`(` GLuint `index`, const GLint \*`v``)`;'
- name: glVertexAttrib4Nbv
  id: glvertexattrib.xhtml#glVertexAttrib4Nbv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4Nbv`**`(` GLuint `index`, const GLbyte \*`v``)`;'
- name: glVertexAttrib4Niv
  id: glvertexattrib.xhtml#glVertexAttrib4Niv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4Niv`**`(` GLuint `index`, const GLint \*`v``)`;'
- name: glVertexAttrib4Nsv
  id: glvertexattrib.xhtml#glVertexAttrib4Nsv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4Nsv`**`(` GLuint `index`, const GLshort \*`v``)`;'
- name: glVertexAttrib4Nub
  id: glvertexattrib.xhtml#glVertexAttrib4Nub
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4Nub`**`(` GLuint `index`, GLubyte `v0`, GLubyte `v1`, GLubyte `v2`, GLubyte `v3``)`;'
- name: glVertexAttrib4Nubv
  id: glvertexattrib.xhtml#glVertexAttrib4Nubv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4Nubv`**`(` GLuint `index`, const GLubyte \*`v``)`;'
- name: glVertexAttrib4Nuiv
  id: glvertexattrib.xhtml#glVertexAttrib4Nuiv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4Nuiv`**`(` GLuint `index`, const GLuint \*`v``)`;'
- name: glVertexAttrib4Nusv
  id: glvertexattrib.xhtml#glVertexAttrib4Nusv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4Nusv`**`(` GLuint `index`, const GLushort \*`v``)`;'
- name: glVertexAttrib4s
  id: glvertexattrib.xhtml#glVertexAttrib4s
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4s`**`(` GLuint `index`, GLshort `v0`, GLshort `v1`, GLshort `v2`, GLshort `v3``)`;'
- name: glVertexAttrib4sv
  id: glvertexattrib.xhtml#glVertexAttrib4sv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4sv`**`(` GLuint `index`, const GLshort \*`v``)`;'
- name: glVertexAttrib4ubv
  id: glvertexattrib.xhtml#glVertexAttrib4ubv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4ubv`**`(` GLuint `index`, const GLubyte \*`v``)`;'
- name: glVertexAttrib4uiv
  id: glvertexattrib.xhtml#glVertexAttrib4uiv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4uiv`**`(` GLuint `index`, const GLuint \*`v``)`;'
- name: glVertexAttrib4usv
  id: glvertexattrib.xhtml#glVertexAttrib4usv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttrib4usv`**`(` GLuint `index`, const GLushort \*`v``)`;'
- name: glVertexAttribBinding
  id: glvertexattribbinding.xhtml
  summary: vaobj Specifies the name of the vertex array object for glVertexArrayAttribBinding
  description: "## Name\n\nglVertexAttribBinding — associate a vertex attribute and a vertex buffer binding for a vertex array object\n\n## C Specification\n\n`void `**`glVertexAttribBinding`**`(` GLuint `attribindex`, GLuint `bindingindex``)`;\n\n`void `**`glVertexArrayAttribBinding`**`(` GLuint `vaobj`, GLuint `attribindex`, GLuint `bindingindex``)`;\n\n## Parameters\n\n *`vaobj`*  \nSpecifies the name of the vertex array object for `glVertexArrayAttribBinding`.\n\n *`attribindex`*  \nThe index of the attribute to associate with a vertex buffer binding.\n\n *`bindingindex`*  \nThe index of the vertex buffer binding with which to associate the generic vertex attribute.\n\n## Description\n\n`glVertexAttribBinding` and `glVertexArrayAttribBinding` establishes an association between the generic vertex attribute of a vertex array object whose index is given by *`attribindex`*, and a vertex buffer binding whose index is given by *`bindingindex`*. For `glVertexAttribBinding`, the vertex array object affected is that currently bound. For `glVertexArrayAttribBinding`, *`vaobj`* is the name of the vertex array object.\n\n*`attribindex`* must be less than the value of `GL_MAX_VERTEX_ATTRIBS` and *`bindingindex`* must be less than the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n## Errors\n\n`GL_INVALID_OPERATION` is generated by `glVertexAttribBinding` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayAttribBinding` if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_VALUE` is generated if *`attribindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_VALUE` is generated if *`bindingindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with arguments `GL_MAX_VERTEX_ATTRIB_BINDINGS`, `GL_VERTEX_BINDING_DIVISOR`.\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glVertexArrayAttribBinding` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glVertexAttribBinding`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindVertexBuffer](glbindvertexbuffer.xhtml), [glVertexAttribFormat](glvertexattribformat.xhtml), [glVertexBindingDivisor](glvertexbindingdivisor.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribBinding.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribBinding.xhtml)"
- name: glVertexAttribDivisor
  id: glvertexattribdivisor.xhtml
  summary: index Specify the index of the generic vertex attribute
  description: "## Name\n\nglVertexAttribDivisor — modify the rate at which generic vertex attributes advance during instanced rendering\n\n## C Specification\n\n`void `**`glVertexAttribDivisor`**`(` GLuint `index`, GLuint `divisor``)`;\n\n## Parameters\n\n *`index`*  \nSpecify the index of the generic vertex attribute.\n\n *`divisor`*  \nSpecify the number of instances that will pass between updates of the generic attribute at slot *`index`*.\n\n## Description\n\n`glVertexAttribDivisor` modifies the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw call. If *`divisor`* is zero, the attribute at slot *`index`* advances once per vertex. If *`divisor`* is non-zero, the attribute advances once per *`divisor`* instances of the set(s) of vertices being rendered. An attribute is referred to as instanced if its `GL_VERTEX_ATTRIB_ARRAY_DIVISOR` value is non-zero.\n\n*`index`* must be less than the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n## Notes\n\n`glVertexAttribDivisor` is available only if the GL version is 3.3 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glVertexAttribDivisor`     |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glVertexAttribPointer](glvertexattribpointer.xhtml), [glEnableVertexAttribArray](glenablevertexattribarray.xhtml), `glDisableVertexAttribArray`\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribDivisor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribDivisor.xhtml)"
- name: glVertexAttribFormat
  id: glvertexattribformat.xhtml
  summary: vaobj Specifies the name of the vertex array object for glVertexArrayAttrib{I, L}Format functions
  description: "## Name\n\nglVertexAttribFormat, glVertexArrayAttribFormat — specify the organization of vertex arrays\n\n## C Specification\n\n`void `**`glVertexAttribFormat`**`(` GLuint `attribindex`, GLint `size`, GLenum `type`, GLboolean `normalized`, GLuint `relativeoffset``)`;\n\n`void `**`glVertexAttribIFormat`**`(` GLuint `attribindex`, GLint `size`, GLenum `type`, GLuint `relativeoffset``)`;\n\n`void `**`glVertexAttribLFormat`**`(` GLuint `attribindex`, GLint `size`, GLenum `type`, GLuint `relativeoffset``)`;\n\n`void `**`glVertexArrayAttribFormat`**`(` GLuint `vaobj`, GLuint `attribindex`, GLint `size`, GLenum `type`, GLboolean `normalized`, GLuint `relativeoffset``)`;\n\n`void `**`glVertexArrayAttribIFormat`**`(` GLuint `vaobj`, GLuint `attribindex`, GLint `size`, GLenum `type`, GLuint `relativeoffset``)`;\n\n`void `**`glVertexArrayAttribLFormat`**`(` GLuint `vaobj`, GLuint `attribindex`, GLint `size`, GLenum `type`, GLuint `relativeoffset``)`;\n\n## Parameters\n\n *`vaobj`*  \nSpecifies the name of the vertex array object for `glVertexArrayAttrib{I, L}Format` functions.\n\n *`attribindex`*  \nThe generic vertex attribute array being described.\n\n *`size`*  \nThe number of values per vertex that are stored in the array.\n\n *`type`*  \nThe type of the data stored in the array.\n\n *`normalized`*  \nSpecifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed. This parameter is ignored if *`type`* is `GL_FIXED`.\n\n *`relativeoffset`*  \nThe distance between elements within the buffer.\n\n## Description\n\n`glVertexAttribFormat`, `glVertexAttribIFormat` and `glVertexAttribLFormat`, as well as `glVertexArrayAttribFormat`, `glVertexArrayAttribIFormat` and `glVertexArrayAttribLFormat` specify the organization of data in vertex arrays. The first three calls operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID *`vaobj`*. *`attribindex`* specifies the index of the generic vertex attribute array whose data layout is being described, and must be less than the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n*`size`* determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3, 4, or `GL_BGRA`. *`type`* indicates the type of the data. If *`type`* is one of `GL_BYTE`, `GL_SHORT`, `GL_INT`, `GL_FIXED`, `GL_FLOAT`, `GL_HALF_FLOAT`, and `GL_DOUBLE` indicate types `GLbyte`, `GLshort`, `GLint`, `GLfixed`, `GLfloat`, `GLhalf`, and `GLdouble`, respectively; the values `GL_UNSIGNED_BYTE`, `GL_UNSIGNED_SHORT`, and `GL_UNSIGNED_INT` indicate types `GLubyte`, `GLushort`, and `GLuint`, respectively; the values `GL_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_2_10_10_10_REV` indicating respectively four signed or unsigned elements packed into a single `GLuint`; and the value `GL_UNSIGNED_INT_10F_11F_11F_REV` indicating three floating point values packed into a single `GLuint`.\n\n`glVertexAttribLFormat` and `glVertexArrayAttribLFormat` is used to specify layout for data associated with a generic attribute variable declared as 64-bit double precision components. For `glVertexAttribLFormat` and `glVertexArrayAttribLFormat`, *`type`* must be `GL_DOUBLE`. In contrast to `glVertexAttribFormat` or `glVertexArrayAttribFormat`, which will cause data declared as `GL_DOUBLE` to be converted to 32-bit representation, `glVertexAttribLFormat` and `glVertexArrayAttribLFormat` cause such data to be left in its natural, 64-bit representation.\n\nFor `glVertexAttribFormat` and `glVertexArrayAttribFormat`, if *`normalized`* is `GL_TRUE`, then integer data is normalized to the range \\[-1, 1\\] or \\[0, 1\\] if it is signed or unsigned, respectively. If *`normalized`* is `GL_FALSE` then integer data is directly converted to floating point.\n\n*`relativeoffset`* is the offset, measured in basic machine units of the first element relative to the start of the vertex buffer binding this attribute fetches from.\n\n`glVertexAttribFormat` and `glVertexArrayAttribFormat` should be used to describe vertex attribute layout for floating-point vertex attributes, `glVertexAttribIFormat` and `glVertexArrayAttribIFormat` should be used to describe vertex attribute layout for integer vertex attribute, and `glVertexAttribLFormat` and `glVertexArrayAttribLFormat` should be used to describe the layout for 64-bit vertex attributes. Data for an array specified by `glVertexAttribIFormat` and `glVertexArrayAttribIFormat` will always be left as integer values; such data are referred to as pure integers.\n\n## Notes\n\n`GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for *`type`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`attribindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_VALUE` is generated if *`size`* is not one of the accepted values.\n\n`GL_INVALID_VALUE` is generated if *`relativeoffset`* is greater than the value of `GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET`.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not one of the accepted tokens.\n\n`GL_INVALID_ENUM` is generated by `glVertexAttribIFormat`, `glVertexAttribLFormat`, `glVertexArrayAttribIFormat` and `glVertexArrayAttribLFormat` if *`type`* is `GL_UNSIGNED_INT_10F_11F_11F_REV`.\n\n`GL_INVALID_OPERATION` is generated by `glVertexAttribFormat`, `glVertexAttribIFormat` and `glVertexAttribLFormat` if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayAttribFormat`, `glVertexArrayAttribIFormat` and `glVertexArrayAttribLFormat` if *`vaobj`* is not the name of an existing vertex array object.\n\n`GL_INVALID_OPERATION` is generated under any of the following conditions:\n\n- *`size`* is `GL_BGRA` and *`type`* is not `GL_UNSIGNED_BYTE`, `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n- *`type`* is `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, and *`size`* is neither 4 nor `GL_BGRA`.\n\n- *`type`* is `GL_UNSIGNED_INT_10F_11F_11F_REV` and *`size`* is not 3.\n\n- *`size`* is `GL_BGRA` and *`normalized`* is `GL_FALSE`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with arguments `GL_MAX_VERTEX_ATTRIB_BINDINGS`, or `GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET`.\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with argument `GL_VERTEX_ATTRIB_RELATIVE_OFFSET`.\n\n## Version Support\n\n|                              | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:-----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**  |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glVertexArrayAttribFormat`  |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glVertexArrayAttribIFormat` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glVertexArrayAttribLFormat` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glVertexAttribFormat`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribIFormat`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribLFormat`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindVertexBuffer](glbindvertexbuffer.xhtml), [glVertexAttribBinding](glvertexattribbinding.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml), [glVertexBindingDivisor](glvertexbindingdivisor.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribFormat.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribFormat.xhtml)"
- name: glVertexAttribI1i
  id: glvertexattrib.xhtml#glVertexAttribI1i
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI1i`**`(` GLuint `index`, GLint `v0``)`;'
- name: glVertexAttribI1iv
  id: glvertexattrib.xhtml#glVertexAttribI1iv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI1iv`**`(` GLuint `index`, const GLint \*`v``)`;'
- name: glVertexAttribI1ui
  id: glvertexattrib.xhtml#glVertexAttribI1ui
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI1ui`**`(` GLuint `index`, GLuint `v0``)`;'
- name: glVertexAttribI1uiv
  id: glvertexattrib.xhtml#glVertexAttribI1uiv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI1uiv`**`(` GLuint `index`, const GLuint \*`v``)`;'
- name: glVertexAttribI2i
  id: glvertexattrib.xhtml#glVertexAttribI2i
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI2i`**`(` GLuint `index`, GLint `v0`, GLint `v1``)`;'
- name: glVertexAttribI2iv
  id: glvertexattrib.xhtml#glVertexAttribI2iv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI2iv`**`(` GLuint `index`, const GLint \*`v``)`;'
- name: glVertexAttribI2ui
  id: glvertexattrib.xhtml#glVertexAttribI2ui
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI2ui`**`(` GLuint `index`, GLuint `v0`, GLuint `v1``)`;'
- name: glVertexAttribI2uiv
  id: glvertexattrib.xhtml#glVertexAttribI2uiv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI2uiv`**`(` GLuint `index`, const GLuint \*`v``)`;'
- name: glVertexAttribI3i
  id: glvertexattrib.xhtml#glVertexAttribI3i
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI3i`**`(` GLuint `index`, GLint `v0`, GLint `v1`, GLint `v2``)`;'
- name: glVertexAttribI3iv
  id: glvertexattrib.xhtml#glVertexAttribI3iv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI3iv`**`(` GLuint `index`, const GLint \*`v``)`;'
- name: glVertexAttribI3ui
  id: glvertexattrib.xhtml#glVertexAttribI3ui
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI3ui`**`(` GLuint `index`, GLuint `v0`, GLuint `v1`, GLuint `v2``)`;'
- name: glVertexAttribI3uiv
  id: glvertexattrib.xhtml#glVertexAttribI3uiv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI3uiv`**`(` GLuint `index`, const GLuint \*`v``)`;'
- name: glVertexAttribI4bv
  id: glvertexattrib.xhtml#glVertexAttribI4bv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI4bv`**`(` GLuint `index`, const GLbyte \*`v``)`;'
- name: glVertexAttribI4i
  id: glvertexattrib.xhtml#glVertexAttribI4i
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI4i`**`(` GLuint `index`, GLint `v0`, GLint `v1`, GLint `v2`, GLint `v3``)`;'
- name: glVertexAttribI4iv
  id: glvertexattrib.xhtml#glVertexAttribI4iv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI4iv`**`(` GLuint `index`, const GLint \*`v``)`;'
- name: glVertexAttribI4sv
  id: glvertexattrib.xhtml#glVertexAttribI4sv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI4sv`**`(` GLuint `index`, const GLshort \*`v``)`;'
- name: glVertexAttribI4ubv
  id: glvertexattrib.xhtml#glVertexAttribI4ubv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI4ubv`**`(` GLuint `index`, const GLubyte \*`v``)`;'
- name: glVertexAttribI4ui
  id: glvertexattrib.xhtml#glVertexAttribI4ui
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI4ui`**`(` GLuint `index`, GLuint `v0`, GLuint `v1`, GLuint `v2`, GLuint `v3``)`;'
- name: glVertexAttribI4uiv
  id: glvertexattrib.xhtml#glVertexAttribI4uiv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI4uiv`**`(` GLuint `index`, const GLuint \*`v``)`;'
- name: glVertexAttribI4usv
  id: glvertexattrib.xhtml#glVertexAttribI4usv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribI4usv`**`(` GLuint `index`, const GLushort \*`v``)`;'
- name: glVertexAttribIFormat
  id: glvertexattribformat.xhtml#glVertexAttribIFormat
  summary: null
  belongs_to: glVertexAttribFormat
  description: '`void `**`glVertexAttribIFormat`**`(` GLuint `attribindex`, GLint `size`, GLenum `type`, GLuint `relativeoffset``)`;'
- name: glVertexAttribIPointer
  id: glvertexattribpointer.xhtml#glVertexAttribIPointer
  summary: null
  belongs_to: glVertexAttribPointer
  description: '`void `**`glVertexAttribIPointer`**`(` GLuint `index`, GLint `size`, GLenum `type`, GLsizei `stride`, const void \* `pointer``)`;'
- name: glVertexAttribL1d
  id: glvertexattrib.xhtml#glVertexAttribL1d
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribL1d`**`(` GLuint `index`, GLdouble `v0``)`;'
- name: glVertexAttribL1dv
  id: glvertexattrib.xhtml#glVertexAttribL1dv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribL1dv`**`(` GLuint `index`, const GLdouble \*`v``)`;'
- name: glVertexAttribL2d
  id: glvertexattrib.xhtml#glVertexAttribL2d
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribL2d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1``)`;'
- name: glVertexAttribL2dv
  id: glvertexattrib.xhtml#glVertexAttribL2dv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribL2dv`**`(` GLuint `index`, const GLdouble \*`v``)`;'
- name: glVertexAttribL3d
  id: glvertexattrib.xhtml#glVertexAttribL3d
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribL3d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1`, GLdouble `v2``)`;'
- name: glVertexAttribL3dv
  id: glvertexattrib.xhtml#glVertexAttribL3dv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribL3dv`**`(` GLuint `index`, const GLdouble \*`v``)`;'
- name: glVertexAttribL4d
  id: glvertexattrib.xhtml#glVertexAttribL4d
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribL4d`**`(` GLuint `index`, GLdouble `v0`, GLdouble `v1`, GLdouble `v2`, GLdouble `v3``)`;'
- name: glVertexAttribL4dv
  id: glvertexattrib.xhtml#glVertexAttribL4dv
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribL4dv`**`(` GLuint `index`, const GLdouble \*`v``)`;'
- name: glVertexAttribLFormat
  id: glvertexattribformat.xhtml#glVertexAttribLFormat
  summary: null
  belongs_to: glVertexAttribFormat
  description: '`void `**`glVertexAttribLFormat`**`(` GLuint `attribindex`, GLint `size`, GLenum `type`, GLuint `relativeoffset``)`;'
- name: glVertexAttribLPointer
  id: glvertexattribpointer.xhtml#glVertexAttribLPointer
  summary: Specifies the index of the generic vertex attribute to be modified
  belongs_to: glVertexAttribPointer
  description: "`void `**`glVertexAttribLPointer`**`(` GLuint `index`, GLint `size`, GLenum `type`, GLsizei `stride`, const void \\* `pointer``)`;\n\n## Parameters\n\n*`index`*\n\nSpecifies the index of the generic vertex attribute to be modified.\n\n*`size`*\n\nSpecifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant `GL_BGRA` is accepted by `glVertexAttribPointer`. The initial value is 4.\n\n*`type`*\n\nSpecifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by `glVertexAttribPointer` and `glVertexAttribIPointer`. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_DOUBLE`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_10F_11F_11F_REV` are accepted by `glVertexAttribPointer`. `GL_DOUBLE` is also accepted by `glVertexAttribLPointer` and is the only token accepted by the *`type`* parameter for that function. The initial value is `GL_FLOAT`.\n\n*`normalized`*\n\nFor `glVertexAttribPointer`, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed.\n\n*`stride`*\n\nSpecifies the byte offset between consecutive generic vertex attributes. If *`stride`* is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.\n\n*`pointer`*\n\nSpecifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the `GL_ARRAY_BUFFER` target. The initial value is 0.\n\n## Description\n\n`glVertexAttribPointer`, `glVertexAttribIPointer` and `glVertexAttribLPointer` specify the location and data format of the array of generic vertex attributes at index *`index`* to use when rendering. *`size`* specifies the number of components per attribute and must be 1, 2, 3, 4, or `GL_BGRA`. *`type`* specifies the data type of each component, and *`stride`* specifies the byte stride from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.\n\nFor `glVertexAttribPointer`, if *`normalized`* is set to `GL_TRUE`, it indicates that values stored in an integer format are to be mapped to the range \\[-1,1\\] (for signed values) or \\[0,1\\] (for unsigned values) when they are accessed and converted to floating point. Otherwise, values will be converted to floats directly without normalization.\n\nFor `glVertexAttribIPointer`, only the integer types `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT` are accepted. Values are always left as integer values.\n\n`glVertexAttribLPointer` specifies state for a generic vertex attribute array associated with a shader attribute variable declared with 64-bit double precision components. *`type`* must be `GL_DOUBLE`. *`index`*, *`size`*, and *`stride`* behave as described for `glVertexAttribPointer` and `glVertexAttribIPointer`.\n\nIf *`pointer`* is not `NULL`, a non-zero named buffer object must be bound to the `GL_ARRAY_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)), otherwise an error is generated. *`pointer`* is treated as a byte offset into the buffer object's data store. The buffer object binding (`GL_ARRAY_BUFFER_BINDING`) is saved as generic vertex attribute array state (`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`) for index *`index`*.\n\nWhen a generic vertex attribute array is specified, *`size`*, *`type`*, *`normalized`*, *`stride`*, and *`pointer`* are saved as vertex array state, in addition to the current vertex array buffer object binding.\n\nTo enable and disable a generic vertex attribute array, call [glEnableVertexAttribArray](glenablevertexattribarray.xhtml) and `glDisableVertexAttribArray` with *`index`*. If enabled, the generic vertex attribute array is used when [glDrawArrays](gldrawarrays.xhtml), [glMultiDrawArrays](glmultidrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glMultiDrawElements](glmultidrawelements.xhtml), or [glDrawRangeElements](gldrawrangeelements.xhtml) is called.\n\n## Notes\n\nEach generic vertex attribute array is initially disabled and isn't accessed when [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawArrays](gldrawarrays.xhtml), [glMultiDrawArrays](glmultidrawarrays.xhtml), or [glMultiDrawElements](glmultidrawelements.xhtml) is called.\n\n`GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for *`type`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_VALUE` is generated if *`size`* is not 1, 2, 3, 4 or (for `glVertexAttribPointer`), `GL_BGRA`.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`stride`* is negative.\n\n`GL_INVALID_OPERATION` is generated if *`size`* is `GL_BGRA` and *`type`* is not `GL_UNSIGNED_BYTE`, `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`size`* is not 4 or `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is `GL_UNSIGNED_INT_10F_11F_11F_REV` and *`size`* is not 3.\n\n`GL_INVALID_OPERATION` is generated by `glVertexAttribPointer` if *`size`* is `GL_BGRA` and *`normalized`* is `GL_FALSE`.\n\n`GL_INVALID_OPERATION` is generated if zero is bound to the `GL_ARRAY_BUFFER` buffer object binding point and the *`pointer`* argument is not `NULL`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIBS`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_ENABLED`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_SIZE`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_TYPE`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_STRIDE`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_ARRAY_BUFFER_BINDING`\n\n[glGetVertexAttribPointerv](glgetvertexattribpointerv.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_POINTER`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glVertexAttribIPointer`      |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribLPointer`      |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribPointer`       |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glBindBuffer](glbindbuffer.xhtml), `glDisableVertexAttribArray`, [glDrawArrays](gldrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glEnableVertexAttribArray](glenablevertexattribarray.xhtml), [glMultiDrawArrays](glmultidrawarrays.xhtml), [glMultiDrawElements](glmultidrawelements.xhtml), [glVertexAttrib](glvertexattrib.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribPointer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribPointer.xhtml)"
- name: glVertexAttribP1ui
  id: glvertexattrib.xhtml#glVertexAttribP1ui
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribP1ui`**`(` GLuint `index`, GLenum `type`, GLboolean `normalized`, GLuint `value``)`;'
- name: glVertexAttribP2ui
  id: glvertexattrib.xhtml#glVertexAttribP2ui
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribP2ui`**`(` GLuint `index`, GLenum `type`, GLboolean `normalized`, GLuint `value``)`;'
- name: glVertexAttribP3ui
  id: glvertexattrib.xhtml#glVertexAttribP3ui
  summary: null
  belongs_to: glVertexAttrib
  description: '`void `**`glVertexAttribP3ui`**`(` GLuint `index`, GLenum `type`, GLboolean `normalized`, GLuint `value``)`;'
- name: glVertexAttribP4ui
  id: glvertexattrib.xhtml#glVertexAttribP4ui
  summary: Specifies the index of the generic vertex attribute to be modified
  belongs_to: glVertexAttrib
  description: "`void `**`glVertexAttribP4ui`**`(` GLuint `index`, GLenum `type`, GLboolean `normalized`, GLuint `value``)`;\n\n## Parameters\n\n*`index`*\n\nSpecifies the index of the generic vertex attribute to be modified.\n\n*`v0`*, *`v1`*, *`v2`*, *`v3`*\n\nFor the scalar commands, specifies the new values to be used for the specified vertex attribute.\n\n*`v`*\n\nFor the vector commands (`glVertexAttrib*v`), specifies a pointer to an array of values to be used for the generic vertex attribute.\n\n*`type`*\n\nFor the packed commands (`glVertexAttribP*`), specified the type of packing used on the data. This parameter must be `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`, to specify signed or unsigned data, respectively, or `GL_UNSIGNED_INT_10F_11F_11F_REV` to specify floating point data.\n\n*`normalized`*\n\nFor the packed commands, if `GL_TRUE`, then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If *`type`* indicates a floating-pont format, then *`normalized`* value must be `GL_FALSE`.\n\n*`value`*\n\nFor the packed commands, specifies the new packed value to be used for the specified vertex attribute.\n\n## Description\n\nThe `glVertexAttrib` family of entry points allows an application to pass generic vertex attributes in numbered locations.\n\nGeneric attributes are defined as four-component values that are organized into an array. The first entry of this array is numbered 0, and the size of the array is specified by the implementation-dependent constant `GL_MAX_VERTEX_ATTRIBS`. Individual elements of this array can be modified with a `glVertexAttrib` call that specifies the index of the element to be modified and a value for that element.\n\nThese commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified by *`index`*. A `1` in the name of the command indicates that only one value is passed, and it will be used to modify the first component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component will be set to 1. Similarly, a `2` in the name of the command indicates that values are provided for the first two components, the third component will be set to 0, and the fourth component will be set to 1. A `3` in the name of the command indicates that values are provided for the first three components and the fourth component will be set to 1, whereas a `4` in the name indicates that values are provided for all four components.\n\nThe letters `s`, `f`, `i`, `d`, `ub`, `us`, and `ui` indicate whether the arguments are of type short, float, int, double, unsigned byte, unsigned short, or unsigned int. When `v` is appended to the name, the commands can take a pointer to an array of such values.\n\nAdditional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function:\n\nThe commands containing `N` indicate that the arguments will be passed as fixed-point values that are scaled to a normalized range according to the component conversion rules defined by the OpenGL specification. Signed values are understood to represent fixed-point values in the range \\[-1,1\\], and unsigned values are understood to represent fixed-point values in the range \\[0,1\\].\n\nThe commands containing `I` indicate that the arguments are extended to full signed or unsigned integers.\n\nThe commands containing `P` indicate that the arguments are stored as packed components within a larger natural type.\n\nThe commands containing `L` indicate that the arguments are full 64-bit quantities and should be passed directly to shader inputs declared as 64-bit double precision types.\n\nOpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may be loaded using the `glVertexAttrib` entry points. Matrices must be loaded into successive generic attribute slots in column major order, with one column of the matrix in each generic attribute slot.\n\nA user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling [glBindAttribLocation](glbindattriblocation.xhtml). This allows an application to use more descriptive variable names in a vertex shader. A subsequent change to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable in the vertex shader.\n\nThe binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different program object is used.\n\nAn application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable. These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing, the vertex shader will repeatedly use the current value for the generic vertex attribute.\n\n## Notes\n\nGeneric vertex attributes can be updated at any time.\n\nIt is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location. OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing.\n\nThere is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes with standard attributes.\n\n`glVertexAttribL` versions are available only if the GL version is 4.1 or higher.\n\n`GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for *`type`* by `glVertexAttribP*` only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_ENUM` is generated if `glVertexAttribP*` is used with a *`type`* other than `GL_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_2_10_10_10_REV`, or `GL_UNSIGNED_INT_10F_11F_11F_REV`.\n\n`GL_INVALID_ENUM` is generated if `glVertexAttribL` is used with a *`type`* other than `GL_DOUBLE`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with the argument `GL_CURRENT_PROGRAM`\n\n[glGetActiveAttrib](glgetactiveattrib.xhtml) with argument *`program`* and the index of an active attribute variable\n\n[glGetAttribLocation](glgetattriblocation.xhtml) with argument *`program`* and an attribute variable name\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments `GL_CURRENT_VERTEX_ATTRIB` and *`index`*\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glVertexAttrib1d`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib1dv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib1f`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib1fv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib1s`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib1sv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib2d`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib2dv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib2f`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib2fv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib2s`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib2sv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib3d`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib3dv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib3f`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib3fv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib3s`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib3sv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4Nbv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4Niv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4Nsv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4Nub`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4Nubv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4Nuiv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4Nusv`         |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4bv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4d`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4dv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4f`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4fv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4iv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4s`            |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4sv`           |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4ubv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4uiv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttrib4usv`          |          ✔           |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI1i`           |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI1iv`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI1ui`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI1uiv`         |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI2i`           |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI2iv`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI2ui`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI2uiv`         |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI3i`           |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI3iv`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI3ui`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI3uiv`         |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI4bv`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI4i`           |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI4iv`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI4sv`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI4ubv`         |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI4ui`          |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI4uiv`         |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribI4usv`         |          \\-          |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribL1d`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribL1dv`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribL2d`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribL2dv`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribL3d`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribL3dv`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribL4d`           |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribL4dv`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribP1ui`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribP2ui`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribP3ui`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glVertexAttribP4ui`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttrib.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttrib.xhtml)"
- name: glVertexAttribPointer
  id: glvertexattribpointer.xhtml
  summary: index Specifies the index of the generic vertex attribute to be modified
  description: "## Name\n\nglVertexAttribPointer — define an array of generic vertex attribute data\n\n## C Specification\n\n`void `**`glVertexAttribPointer`**`(` GLuint `index`, GLint `size`, GLenum `type`, GLboolean `normalized`, GLsizei `stride`, const void \\* `pointer``)`;\n\n`void `**`glVertexAttribIPointer`**`(` GLuint `index`, GLint `size`, GLenum `type`, GLsizei `stride`, const void \\* `pointer``)`;\n\n`void `**`glVertexAttribLPointer`**`(` GLuint `index`, GLint `size`, GLenum `type`, GLsizei `stride`, const void \\* `pointer``)`;\n\n## Parameters\n\n *`index`*  \nSpecifies the index of the generic vertex attribute to be modified.\n\n *`size`*  \nSpecifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant `GL_BGRA` is accepted by `glVertexAttribPointer`. The initial value is 4.\n\n *`type`*  \nSpecifies the data type of each component in the array. The symbolic constants `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, and `GL_UNSIGNED_INT` are accepted by `glVertexAttribPointer` and `glVertexAttribIPointer`. Additionally `GL_HALF_FLOAT`, `GL_FLOAT`, `GL_DOUBLE`, `GL_FIXED`, `GL_INT_2_10_10_10_REV`, `GL_UNSIGNED_INT_2_10_10_10_REV` and `GL_UNSIGNED_INT_10F_11F_11F_REV` are accepted by `glVertexAttribPointer`. `GL_DOUBLE` is also accepted by `glVertexAttribLPointer` and is the only token accepted by the *`type`* parameter for that function. The initial value is `GL_FLOAT`.\n\n *`normalized`*  \nFor `glVertexAttribPointer`, specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed.\n\n *`stride`*  \nSpecifies the byte offset between consecutive generic vertex attributes. If *`stride`* is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.\n\n *`pointer`*  \nSpecifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the `GL_ARRAY_BUFFER` target. The initial value is 0.\n\n## Description\n\n`glVertexAttribPointer`, `glVertexAttribIPointer` and `glVertexAttribLPointer` specify the location and data format of the array of generic vertex attributes at index *`index`* to use when rendering. *`size`* specifies the number of components per attribute and must be 1, 2, 3, 4, or `GL_BGRA`. *`type`* specifies the data type of each component, and *`stride`* specifies the byte stride from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.\n\nFor `glVertexAttribPointer`, if *`normalized`* is set to `GL_TRUE`, it indicates that values stored in an integer format are to be mapped to the range \\[-1,1\\] (for signed values) or \\[0,1\\] (for unsigned values) when they are accessed and converted to floating point. Otherwise, values will be converted to floats directly without normalization.\n\nFor `glVertexAttribIPointer`, only the integer types `GL_BYTE`, `GL_UNSIGNED_BYTE`, `GL_SHORT`, `GL_UNSIGNED_SHORT`, `GL_INT`, `GL_UNSIGNED_INT` are accepted. Values are always left as integer values.\n\n`glVertexAttribLPointer` specifies state for a generic vertex attribute array associated with a shader attribute variable declared with 64-bit double precision components. *`type`* must be `GL_DOUBLE`. *`index`*, *`size`*, and *`stride`* behave as described for `glVertexAttribPointer` and `glVertexAttribIPointer`.\n\nIf *`pointer`* is not `NULL`, a non-zero named buffer object must be bound to the `GL_ARRAY_BUFFER` target (see [glBindBuffer](glbindbuffer.xhtml)), otherwise an error is generated. *`pointer`* is treated as a byte offset into the buffer object's data store. The buffer object binding (`GL_ARRAY_BUFFER_BINDING`) is saved as generic vertex attribute array state (`GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`) for index *`index`*.\n\nWhen a generic vertex attribute array is specified, *`size`*, *`type`*, *`normalized`*, *`stride`*, and *`pointer`* are saved as vertex array state, in addition to the current vertex array buffer object binding.\n\nTo enable and disable a generic vertex attribute array, call [glEnableVertexAttribArray](glenablevertexattribarray.xhtml) and `glDisableVertexAttribArray` with *`index`*. If enabled, the generic vertex attribute array is used when [glDrawArrays](gldrawarrays.xhtml), [glMultiDrawArrays](glmultidrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glMultiDrawElements](glmultidrawelements.xhtml), or [glDrawRangeElements](gldrawrangeelements.xhtml) is called.\n\n## Notes\n\nEach generic vertex attribute array is initially disabled and isn't accessed when [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glDrawArrays](gldrawarrays.xhtml), [glMultiDrawArrays](glmultidrawarrays.xhtml), or [glMultiDrawElements](glmultidrawelements.xhtml) is called.\n\n`GL_UNSIGNED_INT_10F_11F_11F_REV` is accepted for *`type`* only if the GL version is 4.4 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to `GL_MAX_VERTEX_ATTRIBS`.\n\n`GL_INVALID_VALUE` is generated if *`size`* is not 1, 2, 3, 4 or (for `glVertexAttribPointer`), `GL_BGRA`.\n\n`GL_INVALID_ENUM` is generated if *`type`* is not an accepted value.\n\n`GL_INVALID_VALUE` is generated if *`stride`* is negative.\n\n`GL_INVALID_OPERATION` is generated if *`size`* is `GL_BGRA` and *`type`* is not `GL_UNSIGNED_BYTE`, `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is `GL_INT_2_10_10_10_REV` or `GL_UNSIGNED_INT_2_10_10_10_REV` and *`size`* is not 4 or `GL_BGRA`.\n\n`GL_INVALID_OPERATION` is generated if *`type`* is `GL_UNSIGNED_INT_10F_11F_11F_REV` and *`size`* is not 3.\n\n`GL_INVALID_OPERATION` is generated by `glVertexAttribPointer` if *`size`* is `GL_BGRA` and *`normalized`* is `GL_FALSE`.\n\n`GL_INVALID_OPERATION` is generated if zero is bound to the `GL_ARRAY_BUFFER` buffer object binding point and the *`pointer`* argument is not `NULL`.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_MAX_VERTEX_ATTRIBS`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_ENABLED`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_SIZE`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_TYPE`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_NORMALIZED`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_STRIDE`\n\n[glGetVertexAttrib](glgetvertexattrib.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING`\n\n[glGet](glget.xhtml) with argument `GL_ARRAY_BUFFER_BINDING`\n\n[glGetVertexAttribPointerv](glgetvertexattribpointerv.xhtml) with arguments *`index`* and `GL_VERTEX_ATTRIB_ARRAY_POINTER`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glVertexAttribIPointer`    |         \\-         |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribLPointer`    |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glVertexAttribPointer`     |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindAttribLocation](glbindattriblocation.xhtml), [glBindBuffer](glbindbuffer.xhtml), `glDisableVertexAttribArray`, [glDrawArrays](gldrawarrays.xhtml), [glDrawElements](gldrawelements.xhtml), [glDrawRangeElements](gldrawrangeelements.xhtml), [glEnableVertexAttribArray](glenablevertexattribarray.xhtml), [glMultiDrawArrays](glmultidrawarrays.xhtml), [glMultiDrawElements](glmultidrawelements.xhtml), [glVertexAttrib](glvertexattrib.xhtml)\n\n## Copyright\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2003-2005 3Dlabs Inc. Ltd. Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribPointer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexAttribPointer.xhtml)"
- name: glVertexBindingDivisor
  id: glvertexbindingdivisor.xhtml
  summary: vaobj Specifies the name of the vertex array object for glVertexArrayBindingDivisor function
  description: "## Name\n\nglVertexBindingDivisor, glVertexArrayBindingDivisor — modify the rate at which generic vertex attributes advance\n\n## C Specification\n\n`void `**`glVertexBindingDivisor`**`(` GLuint `bindingindex`, GLuint `divisor``)`;\n\n`void `**`glVertexArrayBindingDivisor`**`(` GLuint `vaobj`, GLuint `bindingindex`, GLuint `divisor``)`;\n\n## Parameters\n\n *`vaobj`*  \nSpecifies the name of the vertex array object for `glVertexArrayBindingDivisor` function.\n\n *`bindingindex`*  \nThe index of the binding whose divisor to modify.\n\n *`divisor`*  \nThe new value for the instance step rate to apply.\n\n## Description\n\n`glVertexBindingDivisor` and `glVertexArrayBindingDivisor` modify the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw command. If *`divisor`* is zero, the attributes using the buffer bound to *`bindingindex`* advance once per vertex. If *`divisor`* is non-zero, the attributes advance once per *`divisor`* instances of the set(s) of vertices being rendered. An attribute is referred to as *instanced* if the corresponding *`divisor`* value is non-zero.\n\n`glVertexBindingDivisor` uses currently bound vertex array object , whereas `glVertexArrayBindingDivisor` updates state of the vertex array object with ID *`vaobj`*.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`bindingindex`* is greater than or equal to the value of `GL_MAX_VERTEX_ATTRIB_BINDINGS`.\n\n`GL_INVALID_OPERATION` by `glVertexBindingDivisor` is generated if no vertex array object is bound.\n\n`GL_INVALID_OPERATION` is generated by `glVertexArrayBindingDivisor` if *`vaobj`* is not the name of an existing vertex array object.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with arguments `GL_MAX_VERTEX_ATTRIB_BINDINGS`, `GL_VERTEX_BINDING_DIVISOR`.\n\n## Version Support\n\n|                               | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:------------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name**   |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glVertexArrayBindingDivisor` |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |\n| `glVertexBindingDivisor`      |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glBindVertexBuffer](glbindvertexbuffer.xhtml), [glVertexAttribBinding](glvertexattribbinding.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml), [glVertexBindingDivisor](glvertexbindingdivisor.xhtml), [glVertexAttribPointer](glvertexattribpointer.xhtml).\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexBindingDivisor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glVertexBindingDivisor.xhtml)"
- name: glViewport
  id: glviewport.xhtml
  summary: x, y Specify the lower left corner of the viewport rectangle, in pixels
  description: "## Name\n\nglViewport — set the viewport\n\n## C Specification\n\n`void `**`glViewport`**`(` GLint `x`, GLint `y`, GLsizei `width`, GLsizei `height``)`;\n\n## Parameters\n\n*`x`*,   *`y`*  \nSpecify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).\n\n*`width`*,   *`height`*  \nSpecify the width and height of the viewport. When a GL context is first attached to a window, *`width`* and *`height`* are set to the dimensions of that window.\n\n## Description\n\n`glViewport` specifies the affine transformation of *x* and *y* from normalized device coordinates to window coordinates. Let (*x*_(*n**d*), *y*_(*n**d*)) be normalized device coordinates. Then the window coordinates (*x*_(*w*), *y*_(*w*)) are computed as follows:\n\n$\\mathit{x}\\_{\\mathit{w}} = {\\left( {\\mathit{x}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{width}}{2} \\right) + \\mathit{x}}$\n\n$\\mathit{y}\\_{\\mathit{w}} = {\\left( {\\mathit{y}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{height}}{2} \\right) + \\mathit{y}}$\n\nViewport width and height are silently clamped to a range that depends on the implementation. To query this range, call [glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if either *`width`* or *`height`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT`\n\n[glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glViewport`                |         ✔          |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDepthRange](gldepthrange.xhtml)\n\n## Copyright\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see [https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt](https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt).\n\nCopyright © 1991-2006 Silicon Graphics, Inc. Copyright © 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see https://khronos.org/registry/OpenGL-Refpages/LICENSES/LicenseRef-FreeB.txt.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glViewport.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glViewport.xhtml)"
- name: glViewportArray
  id: glviewportarray.xhtml
  summary: first Specify the first viewport to set
  description: "## Name\n\nglViewportArray — set multiple viewports\n\n## C Specification\n\n`void `**`glViewportArrayv`**`(` GLuint `first`, GLsizei `count`, const GLfloat \\*`v``)`;\n\n## Parameters\n\n *`first`*  \nSpecify the first viewport to set.\n\n *`count`*  \nSpecify the number of viewports to set.\n\n *`v`*  \nSpecify the address of an array containing the viewport parameters.\n\n## Description\n\n`glViewportArrayv` specifies the parameters for multiple viewports simulataneously. *`first`* specifies the index of the first viewport to modify and *`count`* specifies the number of viewports to modify. *`first`* must be less than the value of `GL_MAX_VIEWPORTS`, and *`first`* + *`count`* must be less than or equal to the value of `GL_MAX_VIEWPORTS`. Viewports whose indices lie outside the range \\[*`first`*, *`first`* + *`count`*) are not modified. *`v`* contains the address of an array of floating point values specifying the left (*x*), bottom (*y*), width (*w*), and height (*h*) of each viewport, in that order. *x* and *y* give the location of the viewport's lower left corner, and *w* and *h* give the width and height of the viewport, respectively. The viewport specifies the affine transformation of *x* and *y* from normalized device coordinates to window coordinates. Let (*x*_(*n**d*), *y*_(*n**d*)) be normalized device coordinates. Then the window coordinates (*x*_(*w*), *y*_(*w*)) are computed as follows:\n\n$\\mathit{x}\\_{\\mathit{w}} = {\\left( {\\mathit{x}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{width}}{2} \\right) + \\mathit{x}}$\n\n$\\mathit{y}\\_{\\mathit{w}} = {\\left( {\\mathit{y}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{height}}{2} \\right) + \\mathit{y}}$\n\nThe location of the viewport's bottom left corner, given by (*x*, *y*) is clamped to be within the implementaiton-dependent viewport bounds range. The viewport bounds range \\[*min* , *max* \\] can be determined by calling [glGet](glget.xhtml) with argument `GL_VIEWPORT_BOUNDS_RANGE`. Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call [glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`.\n\nThe precision with which the GL interprets the floating point viewport bounds is implementation-dependent and may be determined by querying the impementation-defined constant `GL_VIEWPORT_SUBPIXEL_BITS`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`first`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if *`first`* + *`count`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if either *`width`* or *`height`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT`\n\n[glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT_BOUNDS_RANGE`\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT_SUBPIXEL_BITS`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glViewportArrayv`          |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDepthRange](gldepthrange.xhtml), [glViewport](glviewport.xhtml), [glViewportIndexed](glviewportindexed.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glViewportArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glViewportArray.xhtml)"
- name: glViewportArrayv
  id: glviewportarray.xhtml#glViewportArrayv
  summary: Specify the first viewport to set
  belongs_to: glViewportArray
  description: "`void `**`glViewportArrayv`**`(` GLuint `first`, GLsizei `count`, const GLfloat \\*`v``)`;\n\n## Parameters\n\n*`first`*\n\nSpecify the first viewport to set.\n\n*`count`*\n\nSpecify the number of viewports to set.\n\n*`v`*\n\nSpecify the address of an array containing the viewport parameters.\n\n## Description\n\n`glViewportArrayv` specifies the parameters for multiple viewports simulataneously. *`first`* specifies the index of the first viewport to modify and *`count`* specifies the number of viewports to modify. *`first`* must be less than the value of `GL_MAX_VIEWPORTS`, and *`first`* + *`count`* must be less than or equal to the value of `GL_MAX_VIEWPORTS`. Viewports whose indices lie outside the range \\[*`first`*, *`first`* + *`count`*) are not modified. *`v`* contains the address of an array of floating point values specifying the left (*x*), bottom (*y*), width (*w*), and height (*h*) of each viewport, in that order. *x* and *y* give the location of the viewport's lower left corner, and *w* and *h* give the width and height of the viewport, respectively. The viewport specifies the affine transformation of *x* and *y* from normalized device coordinates to window coordinates. Let (*x*_(*n**d*), *y*_(*n**d*)) be normalized device coordinates. Then the window coordinates (*x*_(*w*), *y*_(*w*)) are computed as follows:\n\n$\\mathit{x}\\_{\\mathit{w}} = {\\left( {\\mathit{x}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{width}}{2} \\right) + \\mathit{x}}$\n\n$\\mathit{y}\\_{\\mathit{w}} = {\\left( {\\mathit{y}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{height}}{2} \\right) + \\mathit{y}}$\n\nThe location of the viewport's bottom left corner, given by (*x*, *y*) is clamped to be within the implementaiton-dependent viewport bounds range. The viewport bounds range \\[*min* , *max* \\] can be determined by calling [glGet](glget.xhtml) with argument `GL_VIEWPORT_BOUNDS_RANGE`. Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call [glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`.\n\nThe precision with which the GL interprets the floating point viewport bounds is implementation-dependent and may be determined by querying the impementation-defined constant `GL_VIEWPORT_SUBPIXEL_BITS`.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`first`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if *`first`* + *`count`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if either *`width`* or *`height`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT`\n\n[glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT_BOUNDS_RANGE`\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT_SUBPIXEL_BITS`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glViewportArrayv`            |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glDepthRange](gldepthrange.xhtml), [glViewport](glviewport.xhtml), [glViewportIndexed](glviewportindexed.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glViewportArray.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glViewportArray.xhtml)"
- name: glViewportIndexed
  id: glviewportindexed.xhtml
  summary: index Specify the first viewport to set
  description: "## Name\n\nglViewportIndexed — set a specified viewport\n\n## C Specification\n\n`void `**`glViewportIndexedf`**`(` GLuint `index`, GLfloat `x`, GLfloat `y`, GLfloat `w`, GLfloat `h``)`;\n\n`void `**`glViewportIndexedfv`**`(` GLuint `index`, const GLfloat \\*`v``)`;\n\n## Parameters\n\n *`index`*  \nSpecify the first viewport to set.\n\n*`x`*,   *`y`*  \nFor `glViewportIndexedf`, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).\n\n*`w`*,   *`h`*  \nFor `glViewportIndexedf`, specifies the width and height of the viewport. When a GL context is first attached to a window, *`w`* and *`h`* are set to the dimensions of that window.\n\n *`v`*  \nFor `glViewportIndexedfv`, specifies the address of an array containing the viewport parameters.\n\n## Description\n\n`glViewportIndexedf` and `glViewportIndexedfv` specify the parameters for a single viewport. *`index`* specifies the index of the viewport to modify. *`index`* must be less than the value of `GL_MAX_VIEWPORTS`. For `glViewportIndexedf`, *`x`*, *`y`*, *`w`*, and *`h`* specify the left, bottom, width and height of the viewport in pixels, respectively. For `glViewportIndexedfv`, *`v`* contains the address of an array of floating point values specifying the left (*x*), bottom (*y*), width (*w*), and height (*h*) of each viewport, in that order. *x* and *y* give the location of the viewport's lower left corner, and *w* and *h* give the width and height of the viewport, respectively. The viewport specifies the affine transformation of *x* and *y* from normalized device coordinates to window coordinates. Let (*x*_(*n**d*), *y*_(*n**d*)) be normalized device coordinates. Then the window coordinates (*x*_(*w*), *y*_(*w*)) are computed as follows:\n\n$\\mathit{x}\\_{\\mathit{w}} = {\\left( {\\mathit{x}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{width}}{2} \\right) + \\mathit{x}}$\n\n$\\mathit{y}\\_{\\mathit{w}} = {\\left( {\\mathit{y}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{height}}{2} \\right) + \\mathit{y}}$\n\nThe location of the viewport's bottom left corner, given by (*x*, *y*) is clamped to be within the implementaiton-dependent viewport bounds range. The viewport bounds range \\[*min* , *max* \\] can be determined by calling [glGet](glget.xhtml) with argument `GL_VIEWPORT_BOUNDS_RANGE`. Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call [glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`.\n\nThe precision with which the GL interprets the floating point viewport bounds is implementation-dependent and may be determined by querying the impementation-defined constant `GL_VIEWPORT_SUBPIXEL_BITS`.\n\nCalling `glViewportIndexedfv` is equivalent to calling [glViewportArray](glviewportarray.xhtml) with *`first`* set to *`index`*, *`count`* set to 1 and *`v`* passsed directly. `glViewportIndexedf` is equivalent to:\n\n``` programlisting\n    void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {\n        const float v[4]  = { x, y, w, h };\n        glViewportArrayv(index, 1, v);\n    }\n```\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if either *`w`* or *`h`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT`\n\n[glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT_BOUNDS_RANGE`\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT_SUBPIXEL_BITS`\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glViewportIndexedf`        |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n| `glViewportIndexedfv`       |         \\-         |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glDepthRange](gldepthrange.xhtml), [glViewport](glviewport.xhtml), [glViewportArray](glviewportarray.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glViewportIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glViewportIndexed.xhtml)"
- name: glViewportIndexedf
  id: glviewportindexed.xhtml#glViewportIndexedf
  summary: null
  belongs_to: glViewportIndexed
  description: '`void `**`glViewportIndexedf`**`(` GLuint `index`, GLfloat `x`, GLfloat `y`, GLfloat `w`, GLfloat `h``)`;'
- name: glViewportIndexedfv
  id: glviewportindexed.xhtml#glViewportIndexedfv
  summary: Specify the first viewport to set
  belongs_to: glViewportIndexed
  description: "`void `**`glViewportIndexedfv`**`(` GLuint `index`, const GLfloat \\*`v``)`;\n\n## Parameters\n\n*`index`*\n\nSpecify the first viewport to set.\n\n*`x`*, *`y`*\n\nFor `glViewportIndexedf`, specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).\n\n*`w`*, *`h`*\n\nFor `glViewportIndexedf`, specifies the width and height of the viewport. When a GL context is first attached to a window, *`w`* and *`h`* are set to the dimensions of that window.\n\n*`v`*\n\nFor `glViewportIndexedfv`, specifies the address of an array containing the viewport parameters.\n\n## Description\n\n`glViewportIndexedf` and `glViewportIndexedfv` specify the parameters for a single viewport. *`index`* specifies the index of the viewport to modify. *`index`* must be less than the value of `GL_MAX_VIEWPORTS`. For `glViewportIndexedf`, *`x`*, *`y`*, *`w`*, and *`h`* specify the left, bottom, width and height of the viewport in pixels, respectively. For `glViewportIndexedfv`, *`v`* contains the address of an array of floating point values specifying the left (*x*), bottom (*y*), width (*w*), and height (*h*) of each viewport, in that order. *x* and *y* give the location of the viewport's lower left corner, and *w* and *h* give the width and height of the viewport, respectively. The viewport specifies the affine transformation of *x* and *y* from normalized device coordinates to window coordinates. Let (*x*_(*n**d*), *y*_(*n**d*)) be normalized device coordinates. Then the window coordinates (*x*_(*w*), *y*_(*w*)) are computed as follows:\n\n$\\mathit{x}\\_{\\mathit{w}} = {\\left( {\\mathit{x}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{width}}{2} \\right) + \\mathit{x}}$\n\n$\\mathit{y}\\_{\\mathit{w}} = {\\left( {\\mathit{y}\\_{\\mathit{nd}} + 1} \\right)\\left( \\frac{\\mathit{height}}{2} \\right) + \\mathit{y}}$\n\nThe location of the viewport's bottom left corner, given by (*x*, *y*) is clamped to be within the implementaiton-dependent viewport bounds range. The viewport bounds range \\[*min* , *max* \\] can be determined by calling [glGet](glget.xhtml) with argument `GL_VIEWPORT_BOUNDS_RANGE`. Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call [glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`.\n\nThe precision with which the GL interprets the floating point viewport bounds is implementation-dependent and may be determined by querying the impementation-defined constant `GL_VIEWPORT_SUBPIXEL_BITS`.\n\nCalling `glViewportIndexedfv` is equivalent to calling [glViewportArray](glviewportarray.xhtml) with *`first`* set to *`index`*, *`count`* set to 1 and *`v`* passsed directly. `glViewportIndexedf` is equivalent to:\n\n``` programlisting\n    void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {\n        const float v[4]  = { x, y, w, h };\n        glViewportArrayv(index, 1, v);\n    }\n```\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`index`* is greater than or equal to the value of `GL_MAX_VIEWPORTS`.\n\n`GL_INVALID_VALUE` is generated if either *`w`* or *`h`* is negative.\n\n## Associated Gets\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT`\n\n[glGet](glget.xhtml) with argument `GL_MAX_VIEWPORT_DIMS`\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT_BOUNDS_RANGE`\n\n[glGet](glget.xhtml) with argument `GL_VIEWPORT_SUBPIXEL_BITS`\n\n## Version Support\n\n|                               |  **OpenGL Version**  |           |           |           |           |           |           |           |           |           |           |           |\n|:------------------------------|:--------------------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|:---------:|\n|  **Function / Feature Name**  |        **2.0**       |  **2.1**  |  **3.0**  |  **3.1**  |  **3.2**  |  **3.3**  |  **4.0**  |  **4.1**  |  **4.2**  |  **4.3**  |  **4.4**  |  **4.5**  |\n| `glViewportIndexedf`          |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n| `glViewportIndexedfv`         |          \\-          |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |    \\-     |     ✔     |     ✔     |     ✔     |     ✔     |     ✔     |\n\n## See Also\n\n[glDepthRange](gldepthrange.xhtml), [glViewport](glviewport.xhtml), [glViewportArray](glviewportarray.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glViewportIndexed.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glViewportIndexed.xhtml)"
- name: glWaitSync
  id: glwaitsync.xhtml
  summary: sync Specifies the sync object whose status to wait on
  description: "## Name\n\nglWaitSync — instruct the GL server to block until the specified sync object becomes signaled\n\n## C Specification\n\n`void `**`glWaitSync`**`(` GLsync `sync`, GLbitfield `flags`, GLuint64 `timeout``)`;\n\n## Parameters\n\n *`sync`*  \nSpecifies the sync object whose status to wait on.\n\n *`flags`*  \nA bitfield controlling the command flushing behavior. *`flags`* may be zero.\n\n *`timeout`*  \nSpecifies the timeout that the server should wait before continuing. *`timeout`* must be `GL_TIMEOUT_IGNORED`.\n\n## Description\n\n`glWaitSync` causes the GL server to block and wait until *`sync`* becomes signaled. *`sync`* is the name of an existing sync object upon which to wait. *`flags`* and *`timeout`* are currently not used and must be set to zero and the special value `GL_TIMEOUT_IGNORED`, respectively[^(\\[1\\])](#ftn.id-1.6.2.7). `glWaitSync` will always wait no longer than an implementation-dependent timeout. The duration of this timeout in nanoseconds may be queried by calling [glGet](glget.xhtml) with the parameter `GL_MAX_SERVER_WAIT_TIMEOUT`. There is currently no way to determine whether `glWaitSync` unblocked because the timeout expired or because the sync object being waited on was signaled.\n\nIf an error occurs, `glWaitSync` does not cause the GL server to block.\n\n## Notes\n\n`glWaitSync` is available only if the GL version is 3.2 or higher.\n\n## Errors\n\n`GL_INVALID_VALUE` is generated if *`sync`* is not the name of a sync object.\n\n`GL_INVALID_VALUE` is generated if *`flags`* is not zero.\n\n`GL_INVALID_VALUE` is generated if *`timeout`* is not `GL_TIMEOUT_IGNORED`.\n\n## Version Support\n\n|                             | **OpenGL Version** |         |         |         |         |         |         |         |         |         |         |         |\n|:----------------------------|:------------------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|\n| **Function / Feature Name** |      **2.0**       | **2.1** | **3.0** | **3.1** | **3.2** | **3.3** | **4.0** | **4.1** | **4.2** | **4.3** | **4.4** | **4.5** |\n| `glWaitSync`                |         \\-         |   \\-    |   \\-    |   \\-    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |    ✔    |\n\n## See Also\n\n[glFenceSync](glfencesync.xhtml), [glClientWaitSync](glclientwaitsync.xhtml)\n\n## Copyright\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\n  \n\n------------------------------------------------------------------------\n\n[^(\\[1\\])](#id-1.6.2.7) *`flags`* and *`timeout`* are placeholders for anticipated future extensions of sync object capabilities. They must have these reserved values in order that existing code calling `glWaitSync` operate properly in the presence of such extensions.\n\nCopyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/glWaitSync.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/glWaitSync.xhtml)"
- name: greaterThan
  id: greaterthan.xhtml
  summary: x Specifies the first vector to be used in the comparison operation
  description: "## Name\n\ngreaterThan — perform a component-wise greater-than comparison of two vectors\n\n## Declaration\n\n`bvec `**`greaterThan`**`(` vec `x`, vec `y``)`;\n\n`bvec `**`greaterThan`**`(` ivec `x`, ivec `y``)`;\n\n`bvec `**`greaterThan`**`(` uvec `x`, uvec `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first vector to be used in the comparison operation.\n\n *`y`*  \nSpecifies the second vector to be used in the comparison operation.\n\n## Description\n\n`greaterThan` returns a boolean vector in which each element *i* is computed as *`x`*\\[*i*\\] \\> *`y`*\\[*i*\\].\n\n## Version Support\n\n|                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| greaterThan (vec)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| greaterThan (ivec) |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| greaterThan (uvec) |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[lessThan](lessthan.xhtml), [lessThanEqual](lessthanequal.xhtml), [greaterThanEqual](greaterthanequal.xhtml), [equal](equal.xhtml), [notEqual](notequal.xhtml), [any](any.xhtml), [all](all.xhtml), [not](not.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/greaterThan.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/greaterThan.xhtml)"
- name: greaterThanEqual
  id: greaterthanequal.xhtml
  summary: x Specifies the first vector to be used in the comparison operation
  description: "## Name\n\ngreaterThanEqual — perform a component-wise greater-than-or-equal comparison of two vectors\n\n## Declaration\n\n`bvec `**`greaterThanEqual`**`(` vec `x`, vec `y``)`;\n\n`bvec `**`greaterThanEqual`**`(` ivec `x`, ivec `y``)`;\n\n`bvec `**`greaterThanEqual`**`(` uvec `x`, uvec `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first vector to be used in the comparison operation.\n\n *`y`*  \nSpecifies the second vector to be used in the comparison operation.\n\n## Description\n\n`greaterThanEqual` returns a boolean vector in which each element *i* is computed as *`x`*\\[*i*\\] ≥ *`y`*\\[*i*\\].\n\n## Version Support\n\n|                         | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**       |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| greaterThanEqual (vec)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| greaterThanEqual (ivec) |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| greaterThanEqual (uvec) |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[lessThan](lessthan.xhtml), [lessThanEqual](lessthanequal.xhtml), [greaterThan](greaterthan.xhtml), [equal](equal.xhtml), [notEqual](notequal.xhtml), [any](any.xhtml), [all](all.xhtml), [not](not.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/greaterThanEqual.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/greaterThanEqual.xhtml)"
- name: groupMemoryBarrier
  id: groupmemorybarrier.xhtml
  summary: groupMemoryBarrier waits on the completion of all memory accesses performed by an invocation of a compute shader relative to the same access performed by other invocations in the same work group and then returns with no other effect
  description: "## Name\n\ngroupMemoryBarrier — controls the ordering of memory transaction issued shader invocation relative to a work group\n\n## Declaration\n\n`void `**`groupMemoryBarrier`**`(` void`)`;\n\n## Description\n\n`groupMemoryBarrier` waits on the completion of all memory accesses performed by an invocation of a compute shader relative to the same access performed by other invocations in the same work group and then returns with no other effect.\n\n## Version Support\n\n|                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| groupMemoryBarrier |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[memoryBarrier](memorybarrier.xhtml), [memoryBarrierImage](memorybarrierimage.xhtml), [memoryBarrierBuffer](memorybarrierbuffer.xhtml), [memoryBarrierShared](memorybarriershared.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/groupMemoryBarrier.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/groupMemoryBarrier.xhtml)"
- name: imageAtomicAdd
  id: imageatomicadd.xhtml
  summary: image Specify the image unit into which to add data
  description: "## Name\n\nimageAtomicAdd — atomically add a value to an existing value in memory and return the original value\n\n## Declaration\n\n`uint `**`imageAtomicAdd`**`(` gimage1D `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gimage2D `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gimage3D `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gimage2DRect `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gimageCube `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gbufferImage `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gimage1DArray `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gimage2DArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gimageCubeArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, uint `data``)`;\n\n`uint `**`imageAtomicAdd`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, uint `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimage1D `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimage2D `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimage3D `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimage2DRect `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimageCube `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gbufferImage `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimage1DArray `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimage2DArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimageCubeArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, int `data``)`;\n\n`int `**`imageAtomicAdd`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, int `data``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit into which to add *`data`*.\n\n *`P`*  \nSpecify the coordinate at which to add the data.\n\n *`sample`*  \nWhen present, specifies the sample within the image to add into.\n\n *`data`*  \nSpecifies the data to add into the image.\n\n## Description\n\n`imageAtomicAdd` atomically computes a new value by adding the value of *`data`* to the contents of the texel at coordinate *`P`* and *`sample`* in the image bound to uint *`image`*, stores that value into the image and returns the original value.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageAtomicAdd    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicExchange](imageatomicexchange.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicAdd.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicAdd.xhtml)"
- name: imageAtomicAnd
  id: imageatomicand.xhtml
  summary: image Specify the image unit into which to store data
  description: "## Name\n\nimageAtomicAnd — atomically compute the logical AND of a value with an existing value in memory, store that value and return the original value\n\n## Declaration\n\n`uint `**`imageAtomicAnd`**`(` gimage1D `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gimage2D `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gimage3D `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gimage2DRect `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gimageCube `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gbufferImage `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gimage1DArray `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gimage2DArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gimageCubeArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, uint `data``)`;\n\n`uint `**`imageAtomicAnd`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, uint `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimage1D `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimage2D `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimage3D `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimage2DRect `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimageCube `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gbufferImage `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimage1DArray `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimage2DArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimageCubeArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, int `data``)`;\n\n`int `**`imageAtomicAnd`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, int `data``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit into which to store *`data`*.\n\n *`P`*  \nSpecify the coordinate at which to store the data.\n\n *`sample`*  \nWhen present, specifies the sample within the image to store into.\n\n *`data`*  \nSpecifies the data to logically AND into the image.\n\n## Description\n\n`imageAtomicAnd` atomically computes a new value by logically ANDing the value of *`data`* to the contents of the texel at coordinate *`P`* and *`sample`* in the image bound to uint *`image`*, stores that value into the image and returns the original value.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageAtomicAnd    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicExchange](imageatomicexchange.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicAnd.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicAnd.xhtml)"
- name: imageAtomicCompSwap
  id: imageatomiccompswap.xhtml
  summary: image Specify the image unit into which to compare and conditionally store data
  description: "## Name\n\nimageAtomicCompSwap — atomically compares supplied data with that in memory and conditionally stores it to memory\n\n## Declaration\n\n`uint `**`imageAtomicCompSwap`**`(` gimage1D `image`, int `P`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gimage2D `image`, ivec2 `P`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gimage3D `image`, ivec3 `P`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gimage2DRect `image`, ivec2 `P`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gimageCube `image`, ivec3 `P`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gbufferImage `image`, int `P`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gimage1DArray `image`, ivec2 `P`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gimage2DArray `image`, ivec3 `P`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gimageCubeArray `image`, ivec3 `P`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, uint `compare`, uint `data``)`;\n\n`uint `**`imageAtomicCompSwap`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, uint `compare`, uint `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimage1D `image`, int `P`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimage2D `image`, ivec2 `P`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimage3D `image`, ivec3 `P`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimage2DRect `image`, ivec2 `P`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimageCube `image`, ivec3 `P`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gbufferImage `image`, int `P`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimage1DArray `image`, ivec2 `P`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimage2DArray `image`, ivec3 `P`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimageCubeArray `image`, ivec3 `P`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, int `compare`, int `data``)`;\n\n`int `**`imageAtomicCompSwap`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, int `compare`, int `data``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit into which to compare and conditionally store *`data`*.\n\n *`P`*  \nSpecify the coordinate at which to compare and conditionally store the data.\n\n *`sample`*  \nWhen present, specifies the sample within the image to compare and conditionally store into.\n\n *`compare`*  \nSpecifies the value to compare with the content of the image.\n\n *`data`*  \nSpecifies the value to store in the image if *`compare`* is equal to the existing image content.\n\n## Description\n\n`imageAtomicCompSwap` atomically compares the value of *`compare`* with that of the texel at coordinate *`P`* and *`sample`* (for multisampled forms) in the image bound to uint *`image`*. If the values are equal, *`data`* is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation.\n\n## Version Support\n\n|                     | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**   |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageAtomicCompSwap |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicCompSwap.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicCompSwap.xhtml)"
- name: imageAtomicExchange
  id: imageatomicexchange.xhtml
  summary: image Specify the image unit into which to store data
  description: "## Name\n\nimageAtomicExchange — atomically store supplied data into memory and return the original value from memory\n\n## Declaration\n\n`uint `**`imageAtomicExchange`**`(` gimage1D `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gimage2D `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gimage3D `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gimage2DRect `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gimageCube `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gbufferImage `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gimage1DArray `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gimage2DArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gimageCubeArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, uint `data``)`;\n\n`uint `**`imageAtomicExchange`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, uint `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage1D `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2D `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage3D `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2DRect `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimageCube `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gbufferImage `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage1DArray `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2DArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimageCubeArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, int `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage1D `image`, int `P`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2D `image`, ivec2 `P`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage3D `image`, ivec3 `P`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2DRect `image`, ivec2 `P`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimageCube `image`, ivec3 `P`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gbufferImage `image`, int `P`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage1DArray `image`, ivec2 `P`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2DArray `image`, ivec3 `P`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimageCubeArray `image`, ivec3 `P`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, float `data``)`;\n\n`int `**`imageAtomicExchange`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, float `data``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit into which to store *`data`*.\n\n *`P`*  \nSpecify the coordinate at which to store the data.\n\n *`sample`*  \nWhen present, specifies the sample within the image to store into.\n\n *`data`*  \nSpecifies the data to exchange with that stored in the image.\n\n## Description\n\n`imageAtomicExchange` atomically stores the value of *`data`* into the texel at coordinate *`P`* and *`sample`* in the image bound to unit *`image`*, and returns the original value of the texel.\n\n## Version Support\n\n|                                             | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                           |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageAtomicExchange (uint and int *`data`*) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n| imageAtomicExchange (float *`data`*)        |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicExchange.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicExchange.xhtml)"
- name: imageAtomicMax
  id: imageatomicmax.xhtml
  summary: image Specify the image unit into which to store data
  description: "## Name\n\nimageAtomicMax — atomically compute the maximum of a value with an existing value in memory, store that value and return the original value\n\n## Declaration\n\n`uint `**`imageAtomicMax`**`(` gimage1D `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gimage2D `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gimage3D `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gimage2DRect `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gimageCube `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gbufferImage `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gimage1DArray `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gimage2DArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gimageCubeArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, uint `data``)`;\n\n`uint `**`imageAtomicMax`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, uint `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimage1D `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimage2D `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimage3D `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimage2DRect `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimageCube `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gbufferImage `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimage1DArray `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimage2DArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimageCubeArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, int `data``)`;\n\n`int `**`imageAtomicMax`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, int `data``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit into which to store *`data`*.\n\n *`P`*  \nSpecify the coordinate at which to store the data.\n\n *`sample`*  \nWhen present, specifies the sample within the image to store into.\n\n *`data`*  \nSpecifies the data of which to take the maximum with that stored in the image.\n\n## Description\n\n`imageAtomicMax` atomically computes a new value by finding the maximum of the value of *`data`* and the contents of the texel at coordinate *`P`* and *`sample`* in the image bound to uint *`image`*, stores that value into the image and returns the original value.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageAtomicMax    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicExchange](imageatomicexchange.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2022 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2022 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicMax.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicMax.xhtml)"
- name: imageAtomicMin
  id: imageatomicmin.xhtml
  summary: image Specify the image unit into which to store data
  description: "## Name\n\nimageAtomicMin — atomically compute the minimum of a value with an existing value in memory, store that value and return the original value\n\n## Declaration\n\n`uint `**`imageAtomicMin`**`(` gimage1D `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gimage2D `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gimage3D `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gimage2DRect `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gimageCube `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gbufferImage `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gimage1DArray `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gimage2DArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gimageCubeArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, uint `data``)`;\n\n`uint `**`imageAtomicMin`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, uint `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimage1D `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimage2D `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimage3D `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimage2DRect `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimageCube `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gbufferImage `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimage1DArray `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimage2DArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimageCubeArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, int `data``)`;\n\n`int `**`imageAtomicMin`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, int `data``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit into which to store *`data`*.\n\n *`P`*  \nSpecify the coordinate at which to store the data.\n\n *`sample`*  \nWhen present, specifies the sample within the image to store into.\n\n *`data`*  \nSpecifies the data of which to take the minimum with that stored in the image.\n\n## Description\n\n`imageAtomicMin` atomically computes a new value by finding the minimum of the value of *`data`* and the contents of the texel at coordinate *`P`* and *`sample`* in the image bound to uint *`image`*, stores that value into the image and returns the original value.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageAtomicMin    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicExchange](imageatomicexchange.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicMin.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicMin.xhtml)"
- name: imageAtomicOr
  id: imageatomicor.xhtml
  summary: image Specify the image unit into which to store data
  description: "## Name\n\nimageAtomicOr — atomically compute the logical OR of a value with an existing value in memory, store that value and return the original value\n\n## Declaration\n\n`uint `**`imageAtomicOr`**`(` gimage1D `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gimage2D `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gimage3D `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gimage2DRect `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gimageCube `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gbufferImage `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gimage1DArray `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gimage2DArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gimageCubeArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, uint `data``)`;\n\n`uint `**`imageAtomicOr`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, uint `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimage1D `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimage2D `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimage3D `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimage2DRect `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimageCube `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gbufferImage `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimage1DArray `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimage2DArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimageCubeArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, int `data``)`;\n\n`int `**`imageAtomicOr`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, int `data``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit into which to store *`data`*.\n\n *`P`*  \nSpecify the coordinate at which to store the data.\n\n *`sample`*  \nWhen present, specifies the sample within the image to store into.\n\n *`data`*  \nSpecifies the data to logically OR into the image.\n\n## Description\n\n`imageAtomicOr` atomically computes a new value by logically ORing the value of *`data`* to the contents of the texel at coordinate *`P`* and *`sample`* in the image bound to uint *`image`*, stores that value into the image and returns the original value.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageAtomicOr     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicExchange](imageatomicexchange.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicOr.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicOr.xhtml)"
- name: imageAtomicXor
  id: imageatomicxor.xhtml
  summary: image Specify the image unit into which to store data
  description: "## Name\n\nimageAtomicXor — atomically compute the logical exclusive OR of a value with an existing value in memory, store that value and return the original value\n\n## Declaration\n\n`uint `**`imageAtomicXor`**`(` gimage1D `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gimage2D `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gimage3D `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gimage2DRect `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gimageCube `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gbufferImage `image`, int `P`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gimage1DArray `image`, ivec2 `P`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gimage2DArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gimageCubeArray `image`, ivec3 `P`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, uint `data``)`;\n\n`uint `**`imageAtomicXor`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, uint `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimage1D `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimage2D `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimage3D `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimage2DRect `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimageCube `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gbufferImage `image`, int `P`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimage1DArray `image`, ivec2 `P`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimage2DArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimageCubeArray `image`, ivec3 `P`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, int `data``)`;\n\n`int `**`imageAtomicXor`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, int `data``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit into which to store *`data`*.\n\n *`P`*  \nSpecify the coordinate at which to store the data.\n\n *`sample`*  \nWhen present, specifies the sample within the image to store into.\n\n *`data`*  \nSpecifies the data to logically XOR into the image.\n\n## Description\n\n`imageAtomicXor` atomically computes a new value by logically XORing the value of *`data`* to the contents of the texel at coordinate *`P`* and *`sample`* in the image bound to uint *`image`*, stores that value into the image and returns the original value.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageAtomicXor    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicExchange](imageatomicexchange.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicXor.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageAtomicXor.xhtml)"
- name: imageLoad
  id: imageload.xhtml
  summary: image Specify the image unit from which to load a texel
  description: "## Name\n\nimageLoad — load a single texel from an image\n\n## Declaration\n\n`gvec4 `**`imageLoad`**`(` gimage1D `image`, int `P``)`;\n\n`gvec4 `**`imageLoad`**`(` gimage2D `image`, ivec2 `P``)`;\n\n`gvec4 `**`imageLoad`**`(` gimage3D `image`, ivec3 `P``)`;\n\n`gvec4 `**`imageLoad`**`(` gimage2DRect `image`, ivec2 `P``)`;\n\n`gvec4 `**`imageLoad`**`(` gimageCube `image`, ivec3 `P``)`;\n\n`gvec4 `**`imageLoad`**`(` gimageBuffer `image`, int `P``)`;\n\n`gvec4 `**`imageLoad`**`(` gimage1DArray `image`, ivec2 `P``)`;\n\n`gvec4 `**`imageLoad`**`(` gimage2DArray `image`, ivec3 `P``)`;\n\n`gvec4 `**`imageLoad`**`(` gimageCubeArray `image`, ivec3 `P``)`;\n\n`gvec4 `**`imageLoad`**`(` gimage2DMS `image`, ivec2 `P`, int `sample``)`;\n\n`gvec4 `**`imageLoad`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit from which to load a texel.\n\n *`P`*  \nSpecify the coordinate from which to load the texel.\n\n *`sample`*  \nWhen present, specifies the sample within the image to load\n\n## Description\n\n`imageLoad` loads the texel at the coordinate *`P`* from the image unit *`image`*. For multi-sample loads, the sample number is given by *`sample`*. When *`image`*, *`P`*, *`sample`* identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageLoad         |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageStore](imagestore.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicExchange](imageatomicexchange.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageLoad.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageLoad.xhtml)"
- name: imageSamples
  id: imagesamples.xhtml
  summary: image Specifies the image to which the texture is bound
  description: "## Name\n\nimageSamples — return the number of samples of an image\n\n## Declaration\n\n`int `**`imageSamples`**`(` gimage2DMS `image``)`;\n\n`int `**`imageSamples`**`(` gimage2DMSArray `image``)`;\n\n## Parameters\n\n *`image`*  \nSpecifies the image to which the texture is bound.\n\n## Description\n\n`imageSamples` returns the number of samples per texel of the image bound to *`image`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageSamples      |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [textureSamples](texturesamples.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageSamples.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageSamples.xhtml)"
- name: imageSize
  id: imagesize.xhtml
  summary: image Specifies the image to which the texture whose dimensions to retrieve is bound
  description: "## Name\n\nimageSize — retrieve the dimensions of an image\n\n## Declaration\n\n`int `**`imageSize`**`(` gimage1D `image``)`;\n\n`ivec2 `**`imageSize`**`(` gimage2D `image``)`;\n\n`ivec3 `**`imageSize`**`(` gimage3D `image``)`;\n\n`ivec2 `**`imageSize`**`(` gimageCube `image``)`;\n\n`ivec3 `**`imageSize`**`(` gimageCubeArray `image``)`;\n\n`ivec2 `**`imageSize`**`(` gimageRect `image``)`;\n\n`ivec2 `**`imageSize`**`(` gimage1DArray `image``)`;\n\n`ivec3 `**`imageSize`**`(` gimage2DArray `image``)`;\n\n`int `**`imageSize`**`(` gimageBuffer `image``)`;\n\n`ivec2 `**`imageSize`**`(` gimage2DMS `image``)`;\n\n`ivec3 `**`imageSize`**`(` gimage2DMSArray `image``)`;\n\n## Parameters\n\n *`image`*  \nSpecifies the image to which the texture whose dimensions to retrieve is bound.\n\n## Description\n\n`imageSize` returns the dimensions of the image bound to *`image`*. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageSize         |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[textureSize](texturesize.xhtml), [imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageSize.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageSize.xhtml)"
- name: imageStore
  id: imagestore.xhtml
  summary: image Specify the image unit into which to store a texel
  description: "## Name\n\nimageStore — write a single texel into an image\n\n## Declaration\n\n`void `**`imageStore`**`(` gimage1D `image`, int `P`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gimage2D `image`, ivec2 `P`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gimage3D `image`, ivec3 `P`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gimage2DRect `image`, ivec2 `P`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gimageCube `image`, ivec3 `P`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gbufferImage `image`, int `P`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gimage1DArray `image`, ivec2 `P`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gimage2DArray `image`, ivec3 `P`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gimageCubeArray `image`, ivec3 `P`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gimage2DMS `image`, ivec2 `P`, int `sample`, gvec4 `data``)`;\n\n`void `**`imageStore`**`(` gimage2DMSArray `image`, ivec3 `P`, int `sample`, gvec4 `data``)`;\n\n## Parameters\n\n *`image`*  \nSpecify the image unit into which to store a texel.\n\n *`P`*  \nSpecify the coordinate at which to store the texel.\n\n *`sample`*  \nWhen present, specifies the sample within the image to store into.\n\n *`data`*  \nSpecifies the data to store into the image.\n\n## Description\n\n`imageStore` stores *`data`* into the texel at the coordinate *`P`* from the image specified by *`image`*. For multi-sample stores, the sample number is given by *`sample`*. When *`image`*, *`P`*, and *`sample`* identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| imageStore        |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicExchange](imageatomicexchange.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/imageStore.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/imageStore.xhtml)"
- name: imulExtended
  id: umulextended.xhtml#imulExtended
  summary: Specifies the first multiplicand
  belongs_to: umulExtended
  description: "`void `**`imulExtended`**`(` genIType `x`, genIType `y`, out genIType `msb`, out genIType `lsb``)`;\n\n## Parameters\n\n*`x`*\n\nSpecifies the first multiplicand.\n\n*`y`*\n\nSpecifies the second multiplicand.\n\n*`msb`*\n\nSpecifies the variable to receive the most significant word of the product.\n\n*`lsb`*\n\nSpecifies the variable to receive the least significant word of the product.\n\n## Description\n\n`umulExtended` and `imulExtended` perform multiplication of the two 32-bit integer quantities *`x`* and *`y`*, producing a 64-bit integer result. The 32 least significant bits of this product are returned in *`lsb`* and the 32 most significant bits are returned in *`msb`*. `umulExtended` and `imulExtended` perform unsigned and signed multiplication, respectively.\n\n## Version Support\n\n|                     |  **OpenGL Shading Language Version**  |            |            |            |            |            |            |            |            |            |            |            |\n|:--------------------|:-------------------------------------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|\n|  **Function Name**  |                **1.10**               |  **1.20**  |  **1.30**  |  **1.40**  |  **1.50**  |  **3.30**  |  **4.00**  |  **4.10**  |  **4.20**  |  **4.30**  |  **4.40**  |  **4.50**  |\n| umulExtended        |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n\n## See Also\n\n[ uaddCarry ](uaddcarry.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/umulExtended.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/umulExtended.xhtml)"
- name: intBitsToFloat
  id: intbitstofloat.xhtml
  summary: x Specifies the bit encoding to return as a floating point value
  description: "## Name\n\nintBitsToFloat, uintBitsToFloat — produce a floating point using an encoding supplied as an integer\n\n## Declaration\n\n`genType `**`intBitsToFloat`**`(` genIType `x``)`;\n\n`genType `**`uintBitsToFloat`**`(` genUType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the bit encoding to return as a floating point value.\n\n## Description\n\n`intBitsToFloat` and `uintBitsToFloat` return the encoding passed in parameter *`x`* as a floating-point value. If the encoding of a NaN is passed in *`x`*, it will not signal and the resulting value will be undefined. If the encoding of a floating point infinity is passed in parameter *`x`*, the resulting floating-point value is the corresponding (positive or negative) floating point infinity.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| intBitsToFloat    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[floatBitsToInt](floatbitstoint.xhtml), `floatBitsToUint`, [isnan](isnan.xhtml), [isinf](isinf.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/intBitsToFloat.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/intBitsToFloat.xhtml)"
- name: interpolateAtCentroid
  id: interpolateatcentroid.xhtml
  summary: interpolant Specifies the interpolant to be sampled at the pixel centroid
  description: "## Name\n\ninterpolateAtCentroid — sample a varying at the centroid of a pixel\n\n## Declaration\n\n`float `**`interpolateAtCentroid`**`(` float `interpolant``)`;\n\n`vec2 `**`interpolateAtCentroid`**`(` vec2 `interpolant``)`;\n\n`vec3 `**`interpolateAtCentroid`**`(` vec3 `interpolant``)`;\n\n`vec4 `**`interpolateAtCentroid`**`(` vec4 `interpolant``)`;\n\n## Parameters\n\n *`interpolant`*  \nSpecifies the interpolant to be sampled at the pixel centroid.\n\n## Description\n\n`interpolateAtCentroid` returns the value of the input varying *`interpolant`* sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the value assigned to the input variable if declared with the `centroid` qualifier.\n\n## Version Support\n\n|                       | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:----------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**     |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| interpolateAtCentroid |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[interpolateAtSample](interpolateatsample.xhtml), [interpolateAtOffset](interpolateatoffset.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/interpolateAtCentroid.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/interpolateAtCentroid.xhtml)"
- name: interpolateAtOffset
  id: interpolateatoffset.xhtml
  summary: interpolant Specifies the interpolant to be sampled at the specified offset
  description: "## Name\n\ninterpolateAtOffset — sample a varying at specified offset from the center of a pixel\n\n## Declaration\n\n`float `**`interpolateAtOffset`**`(` float `interpolant`, vec2 `offset``)`;\n\n`vec2 `**`interpolateAtOffset`**`(` vec2 `interpolant`, vec2 `offset``)`;\n\n`vec3 `**`interpolateAtOffset`**`(` vec3 `interpolant`, vec2 `offset``)`;\n\n`vec4 `**`interpolateAtOffset`**`(` vec4 `interpolant`, vec2 `offset``)`;\n\n## Parameters\n\n *`interpolant`*  \nSpecifies the interpolant to be sampled at the specified offset.\n\n *`offset`*  \nSpecifies the offset from the center of the pixel at which to sample *`interpolant`*.\n\n## Description\n\n`interpolateAtOffset` returns the value of the input varying *`interpolant`* sampled at an offset from the center of the pixel specified by *`offset`*. The two floating-point components of *`offset`* give the offset in pixels in the *x* and *y* directions from the center of the pixel, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation-dependent.\n\n## Version Support\n\n|                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| interpolateAtoOffset |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[interpolateAtCentroid](interpolateatcentroid.xhtml), [interpolateAtSample](interpolateatsample.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/interpolateAtOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/interpolateAtOffset.xhtml)"
- name: interpolateAtSample
  id: interpolateatsample.xhtml
  summary: interpolant Specifies the interpolant to be sampled at the location of sample sample
  description: "## Name\n\ninterpolateAtSample — sample a varying at the location of a specified sample\n\n## Declaration\n\n`float `**`interpolateAtSample`**`(` float `interpolant`, int `sample``)`;\n\n`vec2 `**`interpolateAtSample`**`(` vec2 `interpolant`, int `sample``)`;\n\n`vec3 `**`interpolateAtSample`**`(` vec3 `interpolant`, int `sample``)`;\n\n`vec4 `**`interpolateAtSample`**`(` vec4 `interpolant`, int `sample``)`;\n\n## Parameters\n\n *`interpolant`*  \nSpecifies the interpolant to be sampled at the location of sample *`sample`*.\n\n *`sample`*  \nSpecifies the index of the sample whose location will be used to sample *`interpolant`*.\n\n## Description\n\n`interpolateAtSample` returns the value of the input varying *`interpolant`* sampled at the location of sample number *`sample`*. If multisample buffers are not available, the input varying will be evaluated at the center of the pixel. If sample *`sample`* does not exist, the position used to interpolate the input varying is undefined.\n\n## Version Support\n\n|                     | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**   |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| interpolateAtSample |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[interpolateAtCentroid](interpolateatcentroid.xhtml), [interpolateAtOffset](interpolateatoffset.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/interpolateAtSample.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/interpolateAtSample.xhtml)"
- name: inverse
  id: inverse.xhtml
  summary: m Specifies the matrix of which to take the inverse
  description: "## Name\n\ninverse — calculate the inverse of a matrix\n\n## Declaration\n\n`mat2 `**`inverse`**`(` mat2 `m``)`;\n\n`mat3 `**`inverse`**`(` mat3 `m``)`;\n\n`mat4 `**`inverse`**`(` mat4 `m``)`;\n\n`dmat2 `**`inverse`**`(` dmat2 `m``)`;\n\n`dmat3 `**`inverse`**`(` dmat3 `m``)`;\n\n`dmat4 `**`inverse`**`(` dmat4 `m``)`;\n\n## Parameters\n\n *`m`*  \nSpecifies the matrix of which to take the inverse.\n\n## Description\n\n`inverse` returns the inverse of the matrix *`m`*. The values in the returned matrix are undefined if *`m`* is singular or poorly-conditioned (nearly singular).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| inverse (float)   |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| inverse (double)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[transpose](transpose.xhtml), [determinant](determinant.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/inverse.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/inverse.xhtml)"
- name: inversesqrt
  id: inversesqrt.xhtml
  summary: x Specify the value of which to take the inverse of the square root
  description: "## Name\n\ninversesqrt — return the inverse of the square root of the parameter\n\n## Declaration\n\n`genType `**`inversesqrt`**`(` genType `x``)`;\n\n`genDType `**`inversesqrt`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value of which to take the inverse of the square root.\n\n## Description\n\n`inversesqrt` returns the inverse of the square root of $x$; i.e. the value $1 \\over { \\sqrt x }$. The result is undefined if $x \\leq 0$.\n\n## Version Support\n\n|                        | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-----------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**      |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| inversesqrt (genType)  |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| inversesqrt (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[pow](pow.xhtml), [sqrt](sqrt.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/inversesqrt.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/inversesqrt.xhtml)"
- name: isinf
  id: isinf.xhtml
  summary: x Specifies the value to test for infinity
  description: "## Name\n\nisinf — determine whether the parameter is positive or negative infinity\n\n## Declaration\n\n`genBType `**`isinf`**`(` genType `x``)`;\n\n`genBType `**`isinf`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the value to test for infinity.\n\n## Description\n\nFor each element *i* of the result, `isinf` returns `true` if *`x`*\\[*i*\\] is positive or negative floating point infinity and false otherwise.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| isinf (genType)   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| isinf (genDType)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[isnan](isnan.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/isinf.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/isinf.xhtml)"
- name: isnan
  id: isnan.xhtml
  summary: x Specifies the value to test for NaN
  description: "## Name\n\nisnan — determine whether the parameter is a number\n\n## Declaration\n\n`genBType `**`isnan`**`(` genType `x``)`;\n\n`genBType `**`isnan`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the value to test for NaN.\n\n## Description\n\nFor each element *i* of the result, `isnan` returns `true` if *`x`*\\[*i*\\] is positive or negative floating point NaN (Not a Number) and false otherwise.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| isnan (genType)   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| isnan (genDType)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[isinf](isinf.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/isnan.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/isnan.xhtml)"
- name: ldexp
  id: ldexp.xhtml
  summary: x Specifies the value to be used as a source of significand
  description: "## Name\n\nldexp — assemble a floating point number from a value and exponent\n\n## Declaration\n\n`genType `**`ldexp`**`(` genType `x`, genIType `exp``)`;\n\n`genDType `**`ldexp`**`(` genDType `x`, genIType `exp``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the value to be used as a source of significand.\n\n *`out exp`*  \nSpecifies the value to be used as a source of exponent.\n\n## Description\n\n`ldexp` builds a floating point number from *`x`* and the corresponding integral exponent of two in *`exp`*, returning:\n\n*s**i**g**n**i**f**i**c**a**n**d* ⋅ 2^(*e**x**p**o**n**e**n**t*)\n\nIf this product is too large to be represented in the floating point type, the result is undefined.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| ldexp (genType)   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| ldexp (genDType)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[frexp](frexp.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/ldexp.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/ldexp.xhtml)"
- name: length
  id: length.xhtml
  summary: x Specifies a vector of which to calculate the length
  description: "## Name\n\nlength — calculate the length of a vector\n\n## Declaration\n\n`float `**`length`**`(` genType `x``)`;\n\n`double `**`length`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies a vector of which to calculate the length.\n\n## Description\n\n`length` returns the length of the vector, i.e. $\\sqrt { { x\\[0\\] }^2 + { x\\[1\\] }^2 + \\dots }$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| length (genType)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| length (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[distance](distance.xhtml), [normalize](normalize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/length.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/length.xhtml)"
- name: lessThan
  id: lessthan.xhtml
  summary: x Specifies the first vector to be used in the comparison operation
  description: "## Name\n\nlessThan — perform a component-wise less-than comparison of two vectors\n\n## Declaration\n\n`bvec `**`lessThan`**`(` vec `x`, vec `y``)`;\n\n`bvec `**`lessThan`**`(` ivec `x`, ivec `y``)`;\n\n`bvec `**`lessThan`**`(` uvec `x`, uvec `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first vector to be used in the comparison operation.\n\n *`y`*  \nSpecifies the second vector to be used in the comparison operation.\n\n## Description\n\n`lessThan` returns a boolean vector in which each element *i* is computed as *`x`*\\[*i*\\] \\< *`y`*\\[*i*\\].\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| lessThan (vec)    |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| lessThan (ivec)   |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| lessThan (uvec)   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[lessThanEqual](lessthanequal.xhtml), [greaterThan](greaterthan.xhtml), [greaterThanEqual](greaterthanequal.xhtml), [equal](equal.xhtml), [notEqual](notequal.xhtml), [any](any.xhtml), [all](all.xhtml), [not](not.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/lessThan.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/lessThan.xhtml)"
- name: lessThanEqual
  id: lessthanequal.xhtml
  summary: x Specifies the first vector to be used in the comparison operation
  description: "## Name\n\nlessThanEqual — perform a component-wise less-than-or-equal comparison of two vectors\n\n## Declaration\n\n`bvec `**`lessThanEqual`**`(` vec `x`, vec `y``)`;\n\n`bvec `**`lessThanEqual`**`(` ivec `x`, ivec `y``)`;\n\n`bvec `**`lessThanEqual`**`(` uvec `x`, uvec `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first vector to be used in the comparison operation.\n\n *`y`*  \nSpecifies the second vector to be used in the comparison operation.\n\n## Description\n\n`lessThanEqual` returns a boolean vector in which each element *i* is computed as *`x`*\\[*i*\\] ≤ *`y`*\\[*i*\\].\n\n## Version Support\n\n|                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| lessThanEqual (vec)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| lessThanEqual (ivec) |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| lessThanEqual (uvec) |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[lessThan](lessthan.xhtml), [greaterThan](greaterthan.xhtml), [greaterThanEqual](greaterthanequal.xhtml), [equal](equal.xhtml), [notEqual](notequal.xhtml), [any](any.xhtml), [all](all.xhtml), [not](not.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/lessThanEqual.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/lessThanEqual.xhtml)"
- name: log
  id: log.xhtml
  summary: x Specify the value of which to take the natural logarithm
  description: "## Name\n\nlog — return the natural logarithm of the parameter\n\n## Declaration\n\n`genType `**`log`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value of which to take the natural logarithm.\n\n## Description\n\n`log` returns the natural logarithm of $x$, i.e. the value $y$ which satisfies $x = e^y$. The result is undefined if $x \\leq 0$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| log (genType)     |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [sinh](sinh.xhtml), [cosh](cosh.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/log.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/log.xhtml)"
- name: log2
  id: log2.xhtml
  summary: x Specify the value of which to take the base 2 logarithm
  description: "## Name\n\nlog2 — return the base 2 logarithm of the parameter\n\n## Declaration\n\n`genType `**`log2`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value of which to take the base 2 logarithm.\n\n## Description\n\n`log2` returns the base 2 logarithm of $x$, i.e. the value $y$ which satisfies $x = 2^y$. The result is undefined if $x \\leq 0$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| log2              |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[exp](exp.xhtml), [log](log.xhtml), [exp2](exp2.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/log2.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/log2.xhtml)"
- name: matrixCompMult
  id: matrixcompmult.xhtml
  summary: x Specifies the first matrix multiplicand
  description: "## Name\n\nmatrixCompMult — perform a component-wise multiplication of two matrices\n\n## Declaration\n\n`mat `**`matrixCompMult`**`(` mat `x`, mat `y``)`;\n\n`dmat `**`matrixCompMult`**`(` dmat `x`, dmat `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first matrix multiplicand.\n\n *`y`*  \nSpecifies the second matrix multiplicand.\n\n## Description\n\n`matrixCompMult` performs a component-wise multiplication of two matrices, yielding a result matrix where each component, `result[i][j]` is computed as the scalar product of *`x`*`[i][j]` and *`y`*`[i][j]`.\n\n## Version Support\n\n|                           | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**         |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| matrixCompMult (genType)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| matrixCompMult (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[dot](dot.xhtml), [reflect](reflect.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/matrixCompMult.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/matrixCompMult.xhtml)"
- name: max
  id: max.xhtml
  summary: x Specify the first value to compare
  description: "## Name\n\nmax — return the greater of two values\n\n## Declaration\n\n`genType `**`max`**`(` genType `x`, genType `y``)`;\n\n`genType `**`max`**`(` genType `x`, float `y``)`;\n\n`genDType `**`max`**`(` genDType `x`, genDType `y``)`;\n\n`genDType `**`max`**`(` genDType `x`, double `y``)`;\n\n`genIType `**`max`**`(` genIType `x`, genIType `y``)`;\n\n`genIType `**`max`**`(` genIType `x`, int `y``)`;\n\n`genUType `**`max`**`(` genUType `x`, genUType `y``)`;\n\n`genUType `**`max`**`(` genUType `x`, uint `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the first value to compare.\n\n *`y`*  \nSpecify the second value to compare.\n\n## Description\n\n`max` returns the maximum of the two parameters. It returns *`y`* if *`y`* is greater than *`x`*, otherwise it returns *`x`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| max (genType)     |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| max (genIType)    |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| max (genUType)    |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| max (genDType)    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[min](min.xhtml), [abs](abs.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/max.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/max.xhtml)"
- name: memoryBarrier
  id: memorybarrier.xhtml
  summary: memoryBarrier waits on the completion of all memory accesses resulting from the use of image variables or atomic counters and then returns with no other effect
  description: "## Name\n\nmemoryBarrier — controls the ordering of memory transactions issued by a single shader invocation\n\n## Declaration\n\n`void `**`memoryBarrier`**`(` void`)`;\n\n## Description\n\n`memoryBarrier` waits on the completion of all memory accesses resulting from the use of image variables or atomic counters and then returns with no other effect. When this function returns, the results of any memory stores performed using coherent variables performed prior to the call will be visible to any future coherent memory access to the same addresses from other shader invocations. In particular, the values written this way in one shader stage are guaranteed to be visible to coherent memory accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| memoryBarrier     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[imageLoad](imageload.xhtml), [imageStore](imagestore.xhtml), [imageAtomicAdd](imageatomicadd.xhtml), [imageAtomicMin](imageatomicmin.xhtml), [imageAtomicMax](imageatomicmax.xhtml), [imageAtomicXor](imageatomicxor.xhtml), [imageAtomicOr](imageatomicor.xhtml), [imageAtomicAnd](imageatomicand.xhtml), [imageAtomicExchange](imageatomicexchange.xhtml), [imageAtomicCompSwap](imageatomiccompswap.xhtml), [groupMemoryBarrier](groupmemorybarrier.xhtml), [memoryBarrierImage](memorybarrierimage.xhtml), [memoryBarrierBuffer](memorybarrierbuffer.xhtml), [memoryBarrierShared](memorybarriershared.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrier.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrier.xhtml)"
- name: memoryBarrierAtomicCounter
  id: memorybarrieratomiccounter.xhtml
  summary: memoryBarrierAtomicCounter waits on the completion of all accesses resulting from the use of atomic counters and then returns with no other effect
  description: "## Name\n\nmemoryBarrierAtomicCounter — controls the ordering of operations on atomic counters issued by a single shader invocation\n\n## Declaration\n\n`void `**`memoryBarrierAtomicCounter`**`(` void`)`;\n\n## Description\n\n`memoryBarrierAtomicCounter` waits on the completion of all accesses resulting from the use of atomic counters and then returns with no other effect. When this function returns, the results of any modifications to the value of atomic counters will be visible to any access to the same counter from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).\n\n## Version Support\n\n|                            | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**          |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| memoryBarrierAtomicCounter |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[memoryBarrier](memorybarrier.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrierAtomicCounter.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrierAtomicCounter.xhtml)"
- name: memoryBarrierBuffer
  id: memorybarrierbuffer.xhtml
  summary: memoryBarrierBuffer waits on the completion of all memory accesses resulting from the use of buffer variables and then returns with no other effect
  description: "## Name\n\nmemoryBarrierBuffer — controls the ordering of operations on buffer variables issued by a single shader invocation\n\n## Declaration\n\n`void `**`memoryBarrierBuffer`**`(` void`)`;\n\n## Description\n\n`memoryBarrierBuffer` waits on the completion of all memory accesses resulting from the use of buffer variables and then returns with no other effect. When this function returns, the results of any modifications to the content of buffer variables will be visible to any access to the same buffer from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).\n\n## Version Support\n\n|                     | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**   |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| memoryBarrierBuffer |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[memoryBarrier](memorybarrier.xhtml), [memoryBarrierImage](memorybarrierimage.xhtml), [memoryBarrierShared](memorybarriershared.xhtml), [groupMemoryBarrier](groupmemorybarrier.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrierBuffer.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrierBuffer.xhtml)"
- name: memoryBarrierImage
  id: memorybarrierimage.xhtml
  summary: memoryBarrierImage waits on the completion of all memory accesses resulting from the use of image variables and then returns with no other effect
  description: "## Name\n\nmemoryBarrierImage — controls the ordering of operations on image variables issued by a single shader invocation\n\n## Declaration\n\n`void `**`memoryBarrierImage`**`(` void`)`;\n\n## Description\n\n`memoryBarrierImage` waits on the completion of all memory accesses resulting from the use of image variables and then returns with no other effect. When this function returns, the results of any modifications to the content of image variables will be visible to any access to the same buffer from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).\n\n## Version Support\n\n|                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| memoryBarrierImage |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[memoryBarrier](memorybarrier.xhtml), [memoryBarrierShared](memorybarriershared.xhtml), [memoryBarrierBuffer](memorybarrierbuffer.xhtml), [groupMemoryBarrier](groupmemorybarrier.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrierImage.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrierImage.xhtml)"
- name: memoryBarrierShared
  id: memorybarriershared.xhtml
  summary: memoryBarrierShared waits on the completion of all memory accesses resulting from the use of shared variables and then returns with no other effect
  description: "## Name\n\nmemoryBarrierShared — controls the ordering of operations on shared variables issued by a single shader invocation\n\n## Declaration\n\n`void `**`memoryBarrierShared`**`(` void`)`;\n\n## Description\n\n`memoryBarrierShared` waits on the completion of all memory accesses resulting from the use of shared variables and then returns with no other effect. When this function returns, the results of any modifications to the content of shared variables will be visible to any access to the same buffer from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).\n\n`memoryBarrierShared` is available only in the compute language.\n\n## Version Support\n\n|                     | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**   |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| memoryBarrierShared |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[memoryBarrier](memorybarrier.xhtml), [memoryBarrierImage](memorybarrierimage.xhtml), [memoryBarrierBuffer](memorybarrierbuffer.xhtml), [groupMemoryBarrier](groupmemorybarrier.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrierShared.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/memoryBarrierShared.xhtml)"
- name: min
  id: min.xhtml
  summary: x Specify the first value to compare
  description: "## Name\n\nmin — return the lesser of two values\n\n## Declaration\n\n`genType `**`min`**`(` genType `x`, genType `y``)`;\n\n`genType `**`min`**`(` genType `x`, float `y``)`;\n\n`genDType `**`min`**`(` genDType `x`, genDType `y``)`;\n\n`genDType `**`min`**`(` genDType `x`, double `y``)`;\n\n`genIType `**`min`**`(` genIType `x`, genIType `y``)`;\n\n`genIType `**`min`**`(` genIType `x`, int `y``)`;\n\n`genUType `**`min`**`(` genUType `x`, genUType `y``)`;\n\n`genUType `**`min`**`(` genUType `x`, uint `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the first value to compare.\n\n *`y`*  \nSpecify the second value to compare.\n\n## Description\n\n`min` returns the minimum of the two parameters. It returns *`y`* if *`y`* is less than *`x`*, otherwise it returns *`x`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| min (genType)     |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| min (genIType)    |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| min (genUType)    |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| min (genDType)    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[max](max.xhtml), [abs](abs.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/min.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/min.xhtml)"
- name: mix
  id: mix.xhtml
  summary: x Specify the start of the range in which to interpolate
  description: "## Name\n\nmix — linearly interpolate between two values\n\n## Declaration\n\n`genType `**`mix`**`(` genType `x`, genType `y`, genType `a``)`;\n\n`genType `**`mix`**`(` genType `x`, genType `y`, float `a``)`;\n\n`genDType `**`mix`**`(` genDType `x`, genDType `y`, genDType `a``)`;\n\n`genDType `**`mix`**`(` genDType `x`, genDType `y`, double `a``)`;\n\n`genType `**`mix`**`(` genType `x`, genType `y`, genBType `a``)`;\n\n`genDType `**`mix`**`(` genDType `x`, genDType `y`, genBType `a``)`;\n\n`genIType `**`mix`**`(` genIType `x`, genIType `y`, genBType `a``)`;\n\n`genUType `**`mix`**`(` genUType `x`, genUType `y`, genBType `a``)`;\n\n`genBType `**`mix`**`(` genBType `x`, genBType `y`, genBType `a``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the start of the range in which to interpolate.\n\n *`y`*  \nSpecify the end of the range in which to interpolate.\n\n *`a`*  \nSpecify the value to use to interpolate between *`x`* and *`y`*.\n\n## Description\n\n`mix` performs a linear interpolation between *`x`* and *`y`* using *`a`* to weight between them. The return value is computed as $x \\times (1 - a) + y \\times a$.\n\nThe variants of `mix` where *`a`* is `genBType` select which vector each returned component comes from. For a component of *`a`* that is false, the corresponding component of *`x`* is returned. For a component of *`a`* that is true, the corresponding component of *`y`* is returned. Components of *`x`* and *`y`* that are not selected are allowed to be invalid floating-point values and will have no effect on the results.\n\n## Version Support\n\n|                                             | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                           |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| mix(genType)                                |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| mix(genDType)                               |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| mix(genIType), mix(genUType), mix(genBType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |\n\n## See Also\n\n[min](min.xhtml), [max](max.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/mix.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/mix.xhtml)"
- name: mod
  id: mod.xhtml
  summary: x Specify the value to evaluate
  description: "## Name\n\nmod — compute value of one parameter modulo another\n\n## Declaration\n\n`genType `**`mod`**`(` genType `x`, float `y``)`;\n\n`genType `**`mod`**`(` genType `x`, genType `y``)`;\n\n`genDType `**`mod`**`(` genDType `x`, double `y``)`;\n\n`genDType `**`mod`**`(` genDType `x`, genDType `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to evaluate.\n\n## Description\n\n`mod` returns the value of *`x`* modulo *`y`*. This is computed as *`x`* - *`y`* \\* [floor](floor.xhtml)(*`x`*/*`y`*).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| mod (genType)     |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| mod (genDType)    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[modf](modf.xhtml), [floor](floor.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/mod.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/mod.xhtml)"
- name: modf
  id: modf.xhtml
  summary: x Specify the value to separate
  description: "## Name\n\nmodf — separate a value into its integer and fractional components\n\n## Declaration\n\n`genType `**`modf`**`(` genType `x`, out genType `i``)`;\n\n`genDType `**`modf`**`(` genDType `x`, out genDType `i``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to separate.\n\n *`out i`*  \nA variable that receives the integer part of the argument.\n\n## Description\n\n`modf` separates a floating point value *`x`* into its integer and fractional parts. The fractional part of the number is returned from the function and the integer part (as a floating point quantity) is returned in the output parameter *`i`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| modf (genType)    |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| modf (genDType)   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[fract](fract.xhtml), [floor](floor.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/modf.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/modf.xhtml)"
- name: noise
  id: noise.xhtml
  summary: x Specifies the value to be used to seed the noise function
  description: "## Name\n\nnoise — generate values with a pseudo-random noise function\n\n## Declaration\n\n`float `**`noise1`**`(` genType `x``)`;\n\n`vec2 `**`noise2`**`(` genType `x``)`;\n\n`vec3 `**`noise3`**`(` genType `x``)`;\n\n`vec4 `**`noise4`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the value to be used to seed the noise function.\n\n## Description\n\n`noise1`, `noise2`, `noise3` and `noise4` return noise values (vector or scalar) based on the input value *`x`*. The noise function is a stochastic function that can be used to increase visual complexity. Values returned by the noise functions give the appearance of randomness, but are not truly random. They are defined to have the following characteristics:\n\n- The return value(s) are always in the range \\[-1.0,1.0\\], and cover at least the range \\[-0.6, 0.6\\], with a Gaussian-like distribution.\n\n- The return value(s) have an overall average of 0.0.\n\n- They are repeatable, in that a particular input value will always produce the same return value.\n\n- They are statistically invariant under rotation (i.e., no matter how the domain is rotated, it has the same statistical character).\n\n- They have a statistical invariance under translation (i.e., no matter how the domain is translated, it has the same statistical character).\n\n- They typically give different results under translation.\n\n- The spatial frequency is narrowly concentrated, centered somewhere between 0.5 to 1.0.\n\n- They are C1 continuous everywhere (i.e., the first derivative is continuous).\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| noise1            |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| noise2            |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| noise3            |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| noise4            |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/noise.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/noise.xhtml)"
- name: noise1
  id: noise.xhtml#noise1
  summary: null
  belongs_to: noise
  description: '`float `**`noise1`**`(` genType `x``)`;'
- name: noise2
  id: noise.xhtml#noise2
  summary: null
  belongs_to: noise
  description: '`vec2 `**`noise2`**`(` genType `x``)`;'
- name: noise3
  id: noise.xhtml#noise3
  summary: null
  belongs_to: noise
  description: '`vec3 `**`noise3`**`(` genType `x``)`;'
- name: noise4
  id: noise.xhtml#noise4
  summary: Specifies the value to be used to seed the noise function
  belongs_to: noise
  description: "`vec4 `**`noise4`**`(` genType `x``)`;\n\n## Parameters\n\n*`x`*\n\nSpecifies the value to be used to seed the noise function.\n\n## Description\n\n`noise1`, `noise2`, `noise3` and `noise4` return noise values (vector or scalar) based on the input value *`x`*. The noise function is a stochastic function that can be used to increase visual complexity. Values returned by the noise functions give the appearance of randomness, but are not truly random. They are defined to have the following characteristics:\n\n- The return value(s) are always in the range \\[-1.0,1.0\\], and cover at least the range \\[-0.6, 0.6\\], with a Gaussian-like distribution.\n\n- The return value(s) have an overall average of 0.0.\n\n- They are repeatable, in that a particular input value will always produce the same return value.\n\n- They are statistically invariant under rotation (i.e., no matter how the domain is rotated, it has the same statistical character).\n\n- They have a statistical invariance under translation (i.e., no matter how the domain is translated, it has the same statistical character).\n\n- They typically give different results under translation.\n\n- The spatial frequency is narrowly concentrated, centered somewhere between 0.5 to 1.0.\n\n- They are C1 continuous everywhere (i.e., the first derivative is continuous).\n\n## Version Support\n\n|                     |  **OpenGL Shading Language Version**  |            |            |            |            |            |            |            |            |            |            |            |\n|:--------------------|:-------------------------------------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|\n|  **Function Name**  |                **1.10**               |  **1.20**  |  **1.30**  |  **1.40**  |  **1.50**  |  **3.30**  |  **4.00**  |  **4.10**  |  **4.20**  |  **4.30**  |  **4.40**  |  **4.50**  |\n| noise1              |                   ✔                   |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| noise2              |                   ✔                   |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| noise3              |                   ✔                   |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| noise4              |                   ✔                   |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/noise.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/noise.xhtml)"
- name: normalize
  id: normalize.xhtml
  summary: v Specifies the vector to normalize
  description: "## Name\n\nnormalize — calculates the unit vector in the same direction as the original vector\n\n## Declaration\n\n`genType `**`normalize`**`(` genType `v``)`;\n\n`genDType `**`normalize`**`(` genDType `v``)`;\n\n## Parameters\n\n *`v`*  \nSpecifies the vector to normalize.\n\n## Description\n\n`normalize` returns a vector with the same direction as its parameter, *`v`*, but with length 1.\n\n## Version Support\n\n|                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| normalize (genType)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| normalize (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[length](length.xhtml)\n\n## Copyright\n\nCopyright © 2011-2017 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2017 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/normalize.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/normalize.xhtml)"
- name: not
  id: not.xhtml
  summary: x Specifies the vector to be inverted
  description: "## Name\n\nnot — logically invert a boolean vector\n\n## Declaration\n\n`bvec `**`not`**`(` bvec `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the vector to be inverted.\n\n## Description\n\n`not` logically inverts the boolean vector *`x`*. It returns a new boolean vector for which each element *i* is computed as `!`*`x`*`[`*`i`*`]`.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| not               |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[any](any.xhtml), [all](all.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/not.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/not.xhtml)"
- name: notEqual
  id: notequal.xhtml
  summary: x Specifies the first vector to be used in the comparison operation
  description: "## Name\n\nnotEqual — perform a component-wise not-equal-to comparison of two vectors\n\n## Declaration\n\n`bvec `**`notEqual`**`(` vec `x`, vec `y``)`;\n\n`bvec `**`notEqual`**`(` ivec `x`, ivec `y``)`;\n\n`bvec `**`notEqual`**`(` uvec `x`, uvec `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first vector to be used in the comparison operation.\n\n *`y`*  \nSpecifies the second vector to be used in the comparison operation.\n\n## Description\n\n`notEqual` returns a boolean vector in which each element *i* is computed as *`x`*\\[*i*\\] != *`y`*\\[*i*\\].\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| notEqual (vec)    |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| notEqual (ivec)   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| notEqual (uvec)   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[lessThan](lessthan.xhtml), [lessThanEqual](lessthanequal.xhtml), [greaterThan](greaterthan.xhtml), [greaterThanEqual](greaterthanequal.xhtml), [equal](equal.xhtml), [any](any.xhtml), [all](all.xhtml), [not](not.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/notEqual.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/notEqual.xhtml)"
- name: outerProduct
  id: outerproduct.xhtml
  summary: c Specifies the parameter to be treated as a column vector
  description: "## Name\n\nouterProduct — calculate the outer product of a pair of vectors\n\n## Declaration\n\n`mat2 `**`outerProduct`**`(` vec2 `c`, vec2 `r``)`;\n\n`mat3 `**`outerProduct`**`(` vec3 `c`, vec3 `r``)`;\n\n`mat4 `**`outerProduct`**`(` vec4 `c`, vec4 `r``)`;\n\n`mat2x3 `**`outerProduct`**`(` vec3 `c`, vec2 `r``)`;\n\n`mat3x2 `**`outerProduct`**`(` vec2 `c`, vec3 `r``)`;\n\n`mat2x4 `**`outerProduct`**`(` vec4 `c`, vec2 `r``)`;\n\n`mat4x2 `**`outerProduct`**`(` vec2 `c`, vec4 `r``)`;\n\n`mat3x4 `**`outerProduct`**`(` vec4 `c`, vec3 `r``)`;\n\n`mat4x3 `**`outerProduct`**`(` vec3 `c`, vec4 `r``)`;\n\n`dmat2 `**`outerProduct`**`(` dvec2 `c`, dvec2 `r``)`;\n\n`dmat3 `**`outerProduct`**`(` dvec3 `c`, dvec3 `r``)`;\n\n`dmat4 `**`outerProduct`**`(` dvec4 `c`, dvec4 `r``)`;\n\n`dmat2x3 `**`outerProduct`**`(` dvec3 `c`, dvec2 `r``)`;\n\n`dmat3x2 `**`outerProduct`**`(` dvec2 `c`, dvec3 `r``)`;\n\n`dmat2x4 `**`outerProduct`**`(` dvec4 `c`, dvec2 `r``)`;\n\n`dmat4x2 `**`outerProduct`**`(` dvec2 `c`, dvec4 `r``)`;\n\n`dmat3x4 `**`outerProduct`**`(` dvec4 `c`, dvec3 `r``)`;\n\n`dmat4x3 `**`outerProduct`**`(` dvec3 `c`, dvec4 `r``)`;\n\n## Parameters\n\n *`c`*  \nSpecifies the parameter to be treated as a column vector.\n\n *`r`*  \nSpecifies the parameter to be treated as a row vector.\n\n## Description\n\n`outerProduct` treats the first parameter *`c`* as a column vector (matrix with one column) and the second parameter *`r`* as a row vector (matrix with one row) and does a linear algebraic matrix multiply *`c`* \\* *`r`*, yielding a matrix whose number of rows is the number of components in *`c`* and whose number of columns is the number of components in *`r`*.\n\n## Version Support\n\n|                       | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:----------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**     |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| outerProduct (float)  |                 \\-                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| outerProduct (double) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[dot](dot.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/outerProduct.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/outerProduct.xhtml)"
- name: packDouble2x32
  id: packdouble2x32.xhtml
  summary: v Specifies a vector of two unsigned integers to be packed into a single double-precision result
  description: "## Name\n\npackDouble2x32 — create a double-precision value from a pair of unsigned integers\n\n## Declaration\n\n`double `**`packDouble2x32`**`(` uvec2 `v``)`;\n\n## Parameters\n\n *`v`*  \nSpecifies a vector of two unsigned integers to be packed into a single double-precision result.\n\n## Description\n\n`packDouble2x32` packs the component of parameter *`v`* into a 64-bit value. If an IEEE-754 infinity or NaN is created, it will not signal and the resulting floating-point value is undefined. Otherwise, the bit-level representation of *`v`* is preserved. The first vector component (`v[0]`) specifies the 32 least significant bits of the result; the second component (`v[1]`) specifies the 32 most significant bits.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| packDouble2x32    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[unpackDouble2x32](unpackdouble2x32.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/packDouble2x32.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/packDouble2x32.xhtml)"
- name: packHalf2x16
  id: packhalf2x16.xhtml
  summary: v Specify a vector of two 32-bit floating point values that are to be converted to 16-bit representation and packed into the result
  description: "## Name\n\npackHalf2x16 — convert two 32-bit floating-point quantities to 16-bit quantities and pack them into a single 32-bit integer\n\n## Declaration\n\n`uint `**`packHalf2x16`**`(` vec2 `v``)`;\n\n## Parameters\n\n *`v`*  \nSpecify a vector of two 32-bit floating point values that are to be converted to 16-bit representation and packed into the result.\n\n## Description\n\n`packHalf2x16` returns an unsigned integer obtained by converting the components of a two-component floating-point vector to the 16-bit floating-point representation found in the OpenGL Specification, and then packing these two 16-bit integers into a 32-bit unsigned integer. The first vector component specifies the 16 least-significant bits of the result; the second component specifies the 16 most-significant bits.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| packHalf2x16      |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[packDouble2x32](packdouble2x32.xhtml), [unpackDouble2x32](unpackdouble2x32.xhtml), [unpackHalf2x16](unpackhalf2x16.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/packHalf2x16.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/packHalf2x16.xhtml)"
- name: packSnorm2x16
  id: packunorm.xhtml#packSnorm2x16
  summary: null
  belongs_to: packUnorm
  description: '`uint `**`packSnorm2x16`**`(` vec2 `v``)`;'
- name: packSnorm4x8
  id: packunorm.xhtml#packSnorm4x8
  summary: Specifies a vector of values to be packed into an unsigned integer
  belongs_to: packUnorm
  description: "`uint `**`packSnorm4x8`**`(` vec4 `v``)`;\n\n## Parameters\n\n*`v`*\n\nSpecifies a vector of values to be packed into an unsigned integer.\n\n## Description\n\n`packUnorm2x16`, `packSnorm2x16`, `packUnorm4x8` and `packSnorm4x8` convert each component of the normalized floating-ponit value *`v`* into 8- or 16-bit integer values and then packs the results into a 32-bit unsigned intgeter.\n\nThe conversion for component *`c`* of *`v`* to fixed-point is performed as follows:\n\n- `packUnorm2x16`: `round``(``clamp``(`*`c`*`, 0.0, 1.0) * 65535.0)`\n\n- `packSnorm2x16`: `round``(``clamp``(`*`c`*`, -1.0, 1.0) * 32767.0)`\n\n- `packUnorm4x8`: `round``(``clamp``(`*`c`*`, 0.0, 1.0) * 255.0)`\n\n- `packSnorm4x8`: `round``(``clamp``(`*`c`*`, -1.0, 1.0) * 127.0)`\n\nThe first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits.\n\n## Version Support\n\n|                     |  **OpenGL Shading Language Version**  |            |            |            |            |            |            |            |            |            |            |            |\n|:--------------------|:-------------------------------------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|\n|  **Function Name**  |                **1.10**               |  **1.20**  |  **1.30**  |  **1.40**  |  **1.50**  |  **3.30**  |  **4.00**  |  **4.10**  |  **4.20**  |  **4.30**  |  **4.40**  |  **4.50**  |\n| packUnorm2x16       |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| packSnorm2x16       |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |\n| packUnorm4x8        |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| packSnorm4x8        |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n\n## See Also\n\n`unpackUnorm2x16`, `unpackSnorm2x16`, `unpackUnorm4x8`, `unpackSnorm4x8`\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/packUnorm.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/packUnorm.xhtml)"
- name: packUnorm
  id: packunorm.xhtml
  summary: v Specifies a vector of values to be packed into an unsigned integer
  description: "## Name\n\npackUnorm — pack floating-point values into an unsigned integer\n\n## Declaration\n\n`uint `**`packUnorm2x16`**`(` vec2 `v``)`;\n\n`uint `**`packSnorm2x16`**`(` vec2 `v``)`;\n\n`uint `**`packUnorm4x8`**`(` vec4 `v``)`;\n\n`uint `**`packSnorm4x8`**`(` vec4 `v``)`;\n\n## Parameters\n\n *`v`*  \nSpecifies a vector of values to be packed into an unsigned integer.\n\n## Description\n\n`packUnorm2x16`, `packSnorm2x16`, `packUnorm4x8` and `packSnorm4x8` convert each component of the normalized floating-ponit value *`v`* into 8- or 16-bit integer values and then packs the results into a 32-bit unsigned intgeter.\n\nThe conversion for component *`c`* of *`v`* to fixed-point is performed as follows:\n\n- `packUnorm2x16`: `round``(``clamp``(`*`c`*`, 0.0, 1.0) * 65535.0)`\n\n- `packSnorm2x16`: `round``(``clamp``(`*`c`*`, -1.0, 1.0) * 32767.0)`\n\n- `packUnorm4x8`: `round``(``clamp``(`*`c`*`, 0.0, 1.0) * 255.0)`\n\n- `packSnorm4x8`: `round``(``clamp``(`*`c`*`, -1.0, 1.0) * 127.0)`\n\nThe first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| packUnorm2x16     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| packSnorm2x16     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n| packUnorm4x8      |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| packSnorm4x8      |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n`unpackUnorm2x16`, `unpackSnorm2x16`, `unpackUnorm4x8`, `unpackSnorm4x8`\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/packUnorm.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/packUnorm.xhtml)"
- name: packUnorm2x16
  id: packunorm.xhtml#packUnorm2x16
  summary: null
  belongs_to: packUnorm
  description: '`uint `**`packUnorm2x16`**`(` vec2 `v``)`;'
- name: packUnorm4x8
  id: packunorm.xhtml#packUnorm4x8
  summary: null
  belongs_to: packUnorm
  description: '`uint `**`packUnorm4x8`**`(` vec4 `v``)`;'
- name: pow
  id: pow.xhtml
  summary: x Specify the value to raise to the power y
  description: "## Name\n\npow — return the value of the first parameter raised to the power of the second\n\n## Declaration\n\n`genType `**`pow`**`(` genType `x`, genType `y``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to raise to the power *`y`*.\n\n *`y`*  \nSpecify the power to which to raise *`x`*.\n\n## Description\n\n`pow` returns the value of $x$ raised to the $y$ power, i.e. $x^y$. The result is undefined if $x \\< 0$ or if $x = 0$ and $y \\leq 0$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| pow               |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [sinh](sinh.xhtml), [cosh](cosh.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/pow.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/pow.xhtml)"
- name: radians
  id: radians.xhtml
  summary: degrees Specify the quantity, in degrees, to be converted to radians
  description: "## Name\n\nradians — convert a quantity in degrees to radians\n\n## Declaration\n\n`genType `**`radians`**`(` genType `degrees``)`;\n\n## Parameters\n\n *`degrees`*  \nSpecify the quantity, in degrees, to be converted to radians.\n\n## Description\n\n`radians` converts a quantity specified in degrees into radians. The return value is ${ \\pi \\times degrees } \\over 180$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| radians           |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[degrees](degrees.xhtml),\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/radians.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/radians.xhtml)"
- name: reflect
  id: reflect.xhtml
  summary: I Specifies the incident vector
  description: "## Name\n\nreflect — calculate the reflection direction for an incident vector\n\n## Declaration\n\n`genType `**`reflect`**`(` genType `I`, genType `N``)`;\n\n`genDType `**`reflect`**`(` genDType `I`, genDType `N``)`;\n\n## Parameters\n\n *`I`*  \nSpecifies the incident vector.\n\n *`N`*  \nSpecifies the normal vector.\n\n## Description\n\nFor a given incident vector *`I`* and surface normal *`N`* `reflect` returns the reflection direction calculated as *`I`*` - 2.0 * ``dot``(`*`N`*`, `*`I`*`) * `*`N`*.\n\n*`N`* should be normalized in order to achieve the desired result.\n\n## Version Support\n\n|                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| reflect (genType)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| reflect (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[dot](dot.xhtml), [refract](refract.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/reflect.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/reflect.xhtml)"
- name: refract
  id: refract.xhtml
  summary: I Specifies the incident vector
  description: "## Name\n\nrefract — calculate the refraction direction for an incident vector\n\n## Declaration\n\n`genType `**`refract`**`(` genType `I`, genType `N`, float `eta``)`;\n\n`genDType `**`refract`**`(` genDType `I`, genDType `N`, float `eta``)`;\n\n## Parameters\n\n *`I`*  \nSpecifies the incident vector.\n\n *`N`*  \nSpecifies the normal vector.\n\n *`eta`*  \nSpecifies the ratio of indices of refraction.\n\n## Description\n\nFor a given incident vector *`I`*, surface normal *`N`* and ratio of indices of refraction, *`eta`*, `refract` returns the refraction vector, *`R`*.\n\n*`R`* is calculated as:\n\n``` programlisting\n    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    if (k < 0.0)\n        R = genType(0.0);       // or genDType(0.0)\n    else\n        R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n```\n\nThe input parameters *`I`* and *`N`* should be normalized in order to achieve the desired result.\n\n## Version Support\n\n|                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| refract (genType)  |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| refract (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[dot](dot.xhtml), [reflect](reflect.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/refract.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/refract.xhtml)"
- name: removedTypes
  id: removedtypes.xhtml
  summary: In the May, 2012 update of the OpenGL 4.2 Specification, all APIs using the types GLclampf and GLclampd were modified to use GLfloat and GLdouble, respectively, instead
  description: "## Name\n\nremovedTypes — Describes types removed and replaced in the OpenGL API in OpenGL 4.2\n\n## Description\n\nIn the May, 2012 update of the OpenGL 4.2 Specification, all APIs using the types GLclampf and GLclampd were modified to use GLfloat and GLdouble, respectively, instead. Language was added to the Specification requiring that these parameters be clamped, when required, at use time rather than at specification time.\n\nThis change allows specifying parameters in ranges appropriate for non-fixed-point framebuffers (integer and floating-point formats). The change does not require any changes to user code calling these functions, because the actual underlying types are identical, the behavior is externally unchanged, and the header files continue to define the old types for compatibility with older code.\n\n## See Also\n\n[glBlendColor](glblendcolor.xhtml), [glClearColor](glclearcolor.xhtml), [glClearDepth](glcleardepth.xhtml), [glDepthRange](gldepthrange.xhtml), [glDepthRangeArray](gldepthrangearray.xhtml), [glDepthRangeIndexed](gldepthrangeindexed.xhtml), [glMinSampleShading](glminsampleshading.xhtml), [glSampleCoverage](glsamplecoverage.xhtml)\n\n## Copyright\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/removedTypes.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/removedTypes.xhtml)"
- name: round
  id: round.xhtml
  summary: x Specify the value to evaluate
  description: "## Name\n\nround — find the nearest integer to the parameter\n\n## Declaration\n\n`genType `**`round`**`(` genType `x``)`;\n\n`genDType `**`round`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to evaluate.\n\n## Description\n\n`round` returns a value equal to the nearest integer to *`x`*. The fraction 0.5 will round in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that `round`(*`x`*) returns the same value as [roundEven](roundeven.xhtml)(*`x`*) for all values of *`x`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| round (genType)   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| round (genDType)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[floor](floor.xhtml), [roundEven](roundeven.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/round.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/round.xhtml)"
- name: roundEven
  id: roundeven.xhtml
  summary: x Specify the value to evaluate
  description: "## Name\n\nroundEven — find the nearest even integer to the parameter\n\n## Declaration\n\n`genType `**`roundEven`**`(` genType `x``)`;\n\n`genDType `**`roundEven`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to evaluate.\n\n## Description\n\n`roundEven` returns a value equal to the nearest integer to *`x`*. The fractional part of 0.5 will round toward the nearest even integer. For example, both 3.5 and 4.5 will round to 4.0.\n\n## Version Support\n\n|                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| roundEven (genType)  |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| roundEven (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[floor](floor.xhtml), [round](round.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/roundEven.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/roundEven.xhtml)"
- name: sign
  id: sign.xhtml
  summary: x Specify the value from which to extract the sign
  description: "## Name\n\nsign — extract the sign of the parameter\n\n## Declaration\n\n`genType `**`sign`**`(` genType `x``)`;\n\n`genIType `**`sign`**`(` genIType `x``)`;\n\n`genDType `**`sign`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value from which to extract the sign.\n\n## Description\n\n`sign` returns -1.0 if *`x`* is less than 0.0, 0.0 if *`x`* is equal to 0.0, and +1.0 if *`x`* is greater than 0.0.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| sign (genType)    |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| sign (genIType)   |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| sign (genDType)   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[abs](abs.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/sign.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/sign.xhtml)"
- name: sin
  id: sin.xhtml
  summary: angle Specify the quantity, in radians, of which to return the sine
  description: "## Name\n\nsin — return the sine of the parameter\n\n## Declaration\n\n`genType `**`sin`**`(` genType `angle``)`;\n\n## Parameters\n\n *`angle`*  \nSpecify the quantity, in radians, of which to return the sine.\n\n## Description\n\n`sin` returns the trigonometric sine of *`angle`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| sin               |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[cos](cos.xhtml),\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/sin.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/sin.xhtml)"
- name: sinh
  id: sinh.xhtml
  summary: x Specify the value whose hyperbolic sine to return
  description: "## Name\n\nsinh — return the hyperbolic sine of the parameter\n\n## Declaration\n\n`genType `**`sinh`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value whose hyperbolic sine to return.\n\n## Description\n\n`sinh` returns the hyperbolic sine of *x*. The hyperbolic sine of *x* is computed as $\\frac{e^{x} - e^{- x}}{2}$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| sinh              |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [cosh](cosh.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/sinh.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/sinh.xhtml)"
- name: smoothstep
  id: smoothstep.xhtml
  summary: edge0 Specifies the value of the lower edge of the Hermite function
  description: "## Name\n\nsmoothstep — perform Hermite interpolation between two values\n\n## Declaration\n\n`genType `**`smoothstep`**`(` genType `edge0`, genType `edge1`, genType `x``)`;\n\n`genType `**`smoothstep`**`(` float `edge0`, float `edge1`, genType `x``)`;\n\n`genDType `**`smoothstep`**`(` genDType `edge0`, genDType `edge1`, genDType `x``)`;\n\n`genDType `**`smoothstep`**`(` double `edge0`, double `edge1`, genDType `x``)`;\n\n## Parameters\n\n *`edge0`*  \nSpecifies the value of the lower edge of the Hermite function.\n\n *`edge1`*  \nSpecifies the value of the upper edge of the Hermite function.\n\n *`x`*  \nSpecifies the source value for interpolation.\n\n## Description\n\n`smoothstep` performs smooth Hermite interpolation between 0 and 1 when *`edge0`* \\< *`x`* \\< *`edge1`*. This is useful in cases where a threshold function with a smooth transition is desired. `smoothstep` is equivalent to:\n\n``` programlisting\n    genType t;  /* Or genDType t; */\n    t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n```\n\nResults are undefined if *`edge0`* ≥ *`edge1`*.\n\n## Version Support\n\n|                       | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:----------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**     |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| smoothstep (genType)  |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| smoothstep (genDType) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[mix](mix.xhtml), [step](step.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/smoothstep.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/smoothstep.xhtml)"
- name: sqrt
  id: sqrt.xhtml
  summary: x Specify the value of which to take the square root
  description: "## Name\n\nsqrt — return the square root of the parameter\n\n## Declaration\n\n`genType `**`sqrt`**`(` genType `x``)`;\n\n`genDType `**`sqrt`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value of which to take the square root.\n\n## Description\n\n`sqrt` returns the square root of $x$, i.e. the value $\\sqrt { x }$. The result is undefined if $x \\< 0$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| sqrt (genType)    |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| sqrt (genDType)   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[pow](pow.xhtml), [inversesqrt](inversesqrt.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/sqrt.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/sqrt.xhtml)"
- name: start
  id: start
  summary: Use the index on the left to choose any OpenGL 4.5 reference page for viewing
  description: "# OpenGL® 4.5 Reference Pages\n\nUse the index on the left to choose any OpenGL 4.5 reference page for viewing. These pages include all of the important usage information for each command and function. This information includes a description of all parameters, return values, error conditions, related commands and functions, and version support.\n\nThere are two forms of the index which can be selected by clicking at the top of the navigation bar on the left side: a traditional flat index combining the API commands and GLSL functions, and an accordion-style index with separate sections for commands and functions. The flat index also includes per-letter section links.\n\n## Core Context Functionality\n\nThese man pages only document OpenGL 4.5 core context functionality. For compatibility context specific functionality, please refer to the [OpenGL 2.1 Reference Pages](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/) and/or the appropriate [extension specification](https://www.khronos.org/registry/OpenGL/index_gl.php) you are interested in using.\n\n## Browser Compatibility\n\nVery old browsers, such as IE8, may not work with parts of this site. Please use modern browsers supporting HTML5 (e.g. IE9 and later).\n\nThe ref pages are generated in HTML5 format with imbedded MathML, and rely on [MathJax](http://www.mathjax.org/) to render mathematical equations on browsers which do not natively support MathML. This should work on Chrome, Safari, and other browsers which don't support MathML natively.\n\n## Downloading Man Page Sources\n\nThe Docbook source for the reference pages is available from the [OpenGL-Refpages](https://github.com/KhronosGroup/OpenGL-Refpages) github repository.\n\n## Feedback\n\nIf you find any inaccuracies or typos in the reference pages, please file an issue (and, preferably, propose a pull request fixing the issue) in the [OpenGL-Refpages](https://github.com/KhronosGroup/OpenGL-Refpages) github repository.\n\n  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/start.html](https://registry.khronos.org/OpenGL-Refpages/gl4/start.html)"
- name: step
  id: step.xhtml
  summary: edge Specifies the location of the edge of the step function
  description: "## Name\n\nstep — generate a step function by comparing two values\n\n## Declaration\n\n`genType `**`step`**`(` genType `edge`, genType `x``)`;\n\n`genType `**`step`**`(` float `edge`, genType `x``)`;\n\n`genDType `**`step`**`(` genDType `edge`, genDType `x``)`;\n\n`genDType `**`step`**`(` double `edge`, genDType `x``)`;\n\n## Parameters\n\n *`edge`*  \nSpecifies the location of the edge of the step function.\n\n *`x`*  \nSpecify the value to be used to generate the step function.\n\n## Description\n\n`step` generates a step function by comparing *`x`* to *`edge`*.\n\nFor element *i* of the return value, 0.0 is returned if *`x`*\\[*i*\\] \\< *`edge`*\\[*i*\\], and 1.0 is returned otherwise.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| step (genType)    |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| step (genDType)   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[mix](mix.xhtml), [smoothstep](smoothstep.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/step.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/step.xhtml)"
- name: tan
  id: tan.xhtml
  summary: angle Specify the quantity, in radians, of which to return the tangent
  description: "## Name\n\ntan — return the tangent of the parameter\n\n## Declaration\n\n`genType `**`tan`**`(` genType `angle``)`;\n\n## Parameters\n\n *`angle`*  \nSpecify the quantity, in radians, of which to return the tangent.\n\n## Description\n\n`tan` returns the trigonometric tangent of *`angle`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| tan               |                  ✔                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [atan](atan.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/tan.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/tan.xhtml)"
- name: tanh
  id: tanh.xhtml
  summary: x Specify the value whose hyperbolic tangent to return
  description: "## Name\n\ntanh — return the hyperbolic tangent of the parameter\n\n## Declaration\n\n`genType `**`tanh`**`(` genType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value whose hyperbolic tangent to return.\n\n## Description\n\n`tanh` returns the hyperbolic tangent of *x*. The hyperbolic tangent of *x* is computed as $\\frac{\\mathit{\\sinh}(x)}{\\mathit{\\cosh}(x)}$.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| tanh              |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[sin](sin.xhtml), [cos](cos.xhtml), [sinh](sinh.xhtml), [cosh](cosh.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/tanh.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/tanh.xhtml)"
- name: texelFetch
  id: texelfetch.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntexelFetch — perform a lookup of a single texel within a texture\n\n## Declaration\n\n`gvec4 `**`texelFetch`**`(` gsampler1D `sampler`, int `P`, int `lod``)`;\n\n`gvec4 `**`texelFetch`**`(` gsampler2D `sampler`, ivec2 `P`, int `lod``)`;\n\n`gvec4 `**`texelFetch`**`(` gsampler3D `sampler`, ivec3 `P`, int `lod``)`;\n\n`gvec4 `**`texelFetch`**`(` gsampler2DRect `sampler`, ivec2 `P``)`;\n\n`gvec4 `**`texelFetch`**`(` gsampler1DArray `sampler`, ivec2 `P`, int `lod``)`;\n\n`gvec4 `**`texelFetch`**`(` gsampler2DArray `sampler`, ivec3 `P`, int `lod``)`;\n\n`gvec4 `**`texelFetch`**`(` gsamplerBuffer `sampler`, int `P``)`;\n\n`gvec4 `**`texelFetch`**`(` gsampler2DMS `sampler`, ivec2 `P`, int `sample``)`;\n\n`gvec4 `**`texelFetch`**`(` gsampler2DMSArray `sampler`, ivec3 `P`, int `sample``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`lod`*  \nIf present, specifies the level-of-detail within the texture from which the texel will be fetched.\n\n *`sample`*  \nFor multisampled fetches, specifies which sample within the texel from which will be returned.\n\n## Description\n\n`texelFetch` performs a lookup of a single texel from texture coordinate *`P`* in the texture bound to *`sampler`*. The array layer is specified in the last component of *`P`* for array forms. The *`lod`* parameter (if present) specifies the level-of-detail from which the texel will be fetched. The *`sample`* specifies which sample within the texel will be returned when reading from a multi-sample texure.\n\n## Version Support\n\n|                                              | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                            |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| texelFetch                                   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| texelFetch (gsampler2DRect, gsamplerBuffer)  |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| texelFetch (gsampler2DMS, gsampler2DMSArray) |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/texelFetch.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/texelFetch.xhtml)"
- name: texelFetchOffset
  id: texelfetchoffset.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntexelFetchOffset — perform a lookup of a single texel within a texture with an offset\n\n## Declaration\n\n`gvec4 `**`texelFetchOffset`**`(` gsampler1D `sampler`, int `P`, int `lod`, int `offset``)`;\n\n`gvec4 `**`texelFetchOffset`**`(` gsampler2D `sampler`, ivec2 `P`, int `lod`, ivec2 `offset``)`;\n\n`gvec4 `**`texelFetchOffset`**`(` gsampler3D `sampler`, ivec3 `P`, int `lod`, ivec3 `offset``)`;\n\n`gvec4 `**`texelFetchOffset`**`(` gsampler2DRect `sampler`, ivec2 `P`, ivec2 `offset``)`;\n\n`gvec4 `**`texelFetchOffset`**`(` gsampler1DArray `sampler`, ivec2 `P`, int `lod`, ivec2 `offset``)`;\n\n`gvec4 `**`texelFetchOffset`**`(` gsampler2DArray `sampler`, ivec3 `P`, int `lod`, ivec2 `offset``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`lod`*  \nIf present, specifies the level-of-detail within the texture from which the texel will be fetched.\n\n *`offset`*  \nSpecifies offset, in texels that will be applied to *`P`* before looking up the texel.\n\n## Description\n\n`texelFetchOffset` performs a lookup of a single texel from texture coordinate *`P`* in the texture bound to *`sampler`*. Before fetching the texel, the offset specified in *`offset`* is added to *`P`*. *`offset`* must be a constant expression. The array layer is specified in the last component of *`P`* for array forms. The *`lod`* parameter (if present) specifies the level-of-detail from which the texel will be fetched. The *`sample`* parameter specifies which sample within the texel will be returned when reading from a multi-sample texure.\n\n## Version Support\n\n|                                                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                                  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| texelFetchOffset                                   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| texelFetchOffset (gsampler2DRect)                  |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| texelFetchOffset (gsampler2DMS, gsampler2DMSArray) |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/texelFetchOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/texelFetchOffset.xhtml)"
- name: texture
  id: texture.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntexture — retrieves texels from a texture\n\n## Declaration\n\n`gvec4 `**`texture`**`(` gsampler1D `sampler`, float `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`texture`**`(` gsampler2D `sampler`, vec2 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`texture`**`(` gsampler3D `sampler`, vec3 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`texture`**`(` gsamplerCube `sampler`, vec3 `P`, \\[float `bias`\\]`)`;\n\n`float `**`texture`**`(` sampler1DShadow `sampler`, vec3 `P`, \\[float `bias`\\]`)`;\n\n`float `**`texture`**`(` sampler2DShadow `sampler`, vec3 `P`, \\[float `bias`\\]`)`;\n\n`float `**`texture`**`(` samplerCubeShadow `sampler`, vec4 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`texture`**`(` gsampler1DArray `sampler`, vec2 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`texture`**`(` gsampler2DArray `sampler`, vec3 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`texture`**`(` gsamplerCubeArray `sampler`, vec4 `P`, \\[float `bias`\\]`)`;\n\n`float `**`texture`**`(` sampler1DArrayShadow `sampler`, vec3 `P`, \\[float `bias`\\]`)`;\n\n`float `**`texture`**`(` sampler2DArrayShadow `sampler`, vec4 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`texture`**`(` gsampler2DRect `sampler`, vec2 `P``)`;\n\n`float `**`texture`**`(` sampler2DRectShadow `sampler`, vec3 `P``)`;\n\n`float `**`texture`**`(` samplerCubeArrayShadow `sampler`, vec4 `P`, float `compare``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`bias`*  \nSpecifies an optional bias to be applied during level-of-detail computation.\n\n *`compare`*  \nSpecifies the value to which the fetched texel will be compared when sampling from `samplerCubeArrayShadow`.\n\n## Description\n\n`texture` samples texels from the texture bound to *`sampler`* at texture coordinate *`P`*. An optional bias, specified in *`bias`* is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.\n\nFor *shadow* forms, when *`compare`* is present, it is used as *D*_(*s**u**b*) and the array layer is specified in *`P`*`.w`. When *`compare`* is not present, the last component of *`P`* is used as *D*_(*s**u**b*) and the array layer is specified in the second to last component of *`P`*. (The second component of *`P`* is unused for *1D* shadow lookups.)\n\nFor non-shadow variants, the array layer comes from the last component of *`P`*.\n\n## Version Support\n\n|                                           | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                         |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| texture                                   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| texture (gsampler2DRect{Shadow})          |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| texture (gsampler2DMS, gsampler2DMSArray) |                 \\-                  |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| texture (gsamplerCubeArray{Shadow})       |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/texture.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/texture.xhtml)"
- name: textureGather
  id: texturegather.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureGather — gathers four texels from a texture\n\n## Declaration\n\n`gvec4 `**`textureGather`**`(` gsampler2D `sampler`, vec2 `P`, \\[int `comp]``)`;\n\n`gvec4 `**`textureGather`**`(` gsampler2DArray `sampler`, vec3 `P`, \\[int `comp]``)`;\n\n`gvec4 `**`textureGather`**`(` gsamplerCube `sampler`, vec3 `P`, \\[int `comp]``)`;\n\n`gvec4 `**`textureGather`**`(` gsamplerCubeArray `sampler`, vec4 `P`, \\[int `comp]``)`;\n\n`gvec4 `**`textureGather`**`(` gsampler2DRect `sampler`, vec3 `P`, \\[int `comp]``)`;\n\n`vec4 `**`textureGather`**`(` sampler2DShadow `sampler`, vec2 `P`, float `refZ``)`;\n\n`vec4 `**`textureGather`**`(` sampler2DArrayShadow `sampler`, vec3 `P`, float `refZ``)`;\n\n`vec4 `**`textureGather`**`(` samplerCubeShadow `sampler`, vec3 `P`, float `refZ``)`;\n\n`vec4 `**`textureGather`**`(` samplerCubeArrayShadow `sampler`, vec4 `P`, float `refZ``)`;\n\n`vec4 `**`textureGather`**`(` sampler2DRectShadow `sampler`, vec2 `P`, float `refZ``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`comp`*  \nSpecifies the component of the source texture that will be used to generate the resulting vector.\n\n *`refZ`*  \nSpecifies the reference Z value used in the comparison for shadow forms.\n\n## Description\n\n`textureGather` returns the value:\n\n``` programlisting\n    vec4(Sample_i0_j1(P, base).comp,\n         Sample_i1_j1(P, base).comp,\n         Sample_i1_j0(P, base).comp,\n         Sample_i0_j0(P, base).comp);\n```\n\nIf specified, the value of *`comp`* must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If *`comp`* is not specified, it is treated as 0, selecting the x component of each texel to generate the result.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureGather     |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureGather.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureGather.xhtml)"
- name: textureGatherOffset
  id: texturegatheroffset.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureGatherOffset — gathers four texels from a texture with offset\n\n## Declaration\n\n`gvec4 `**`textureGatherOffset`**`(` gsampler2D `sampler`, vec2 `P`, ivec2 `offset`, \\[int `comp]``)`;\n\n`gvec4 `**`textureGatherOffset`**`(` gsampler2DArray `sampler`, vec3 `P`, ivec2 `offset`, \\[int `comp]``)`;\n\n`gvec4 `**`textureGatherOffset`**`(` gsampler2DRect `sampler`, vec3 `P`, ivec2 `offset`, \\[int `comp]``)`;\n\n`vec4 `**`textureGatherOffset`**`(` sampler2DShadow `sampler`, vec2 `P`, float `refZ`, ivec2 `offset``)`;\n\n`vec4 `**`textureGatherOffset`**`(` sampler2DArrayShadow `sampler`, vec3 `P`, float `refZ`, ivec2 `offset``)`;\n\n`vec4 `**`textureGatherOffset`**`(` sampler2DRectShadow `sampler`, vec2 `P`, float `refZ`, ivec2 `offset``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`comp`*  \nSpecifies the component of the source texture that will be used to generate the resulting vector.\n\n *`refZ`*  \nSpecifies the reference Z value used in the comparison for shadow forms.\n\n *`offset`*  \nSpecifies the offset from the specified texture coordinate *`P`* from which the texels will be gathered.\n\n## Description\n\n`textureGatherOffset` returns the value:\n\n``` programlisting\n    vec4(Sample_i0_j1(P + offset, base).comp,\n         Sample_i1_j1(P + offset, base).comp,\n         Sample_i1_j0(P + offset, base).comp,\n         Sample_i0_j0(P + offset, base).comp);\n```\n\nIt perfoms as [textureGather](texturegather.xhtml) but with *`offset`* applied as described in [textureOffset](textureoffset.xhtml), except that the implementation-dependent minimum and maximum offset values are given by `GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET` and `GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET`, respectively.\n\nIf specified, the value of *`comp`* must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If *`comp`* is not specified, it is treated as 0, selecting the x component of each texel to generate the result.\n\n## Version Support\n\n|                     | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:--------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**   |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureGatherOffset |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureGatherOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureGatherOffset.xhtml)"
- name: textureGatherOffsets
  id: texturegatheroffsets.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureGatherOffsets — gathers four texels from a texture with an array of offsets\n\n## Declaration\n\n`gvec4 `**`textureGatherOffsets`**`(` gsampler2D `sampler`, vec2 `P`, ivec2 `offsets[4]`, \\[int `comp]``)`;\n\n`gvec4 `**`textureGatherOffsets`**`(` gsampler2DArray `sampler`, vec3 `P`, ivec2 `offsets[4]`, \\[int `comp]``)`;\n\n`gvec4 `**`textureGatherOffsets`**`(` gsampler2DRect `sampler`, vec3 `P`, ivec2 `offsets[4]`, \\[int `comp]``)`;\n\n`vec4 `**`textureGatherOffsets`**`(` sampler2DShadow `sampler`, vec2 `P`, float `refZ`, ivec2 `offsets[4]``)`;\n\n`vec4 `**`textureGatherOffsets`**`(` sampler2DArrayShadow `sampler`, vec3 `P`, float `refZ`, ivec2 `offsets[4]``)`;\n\n`vec4 `**`textureGatherOffsets`**`(` sampler2DRectShadow `sampler`, vec2 `P`, float `refZ`, ivec2 `offsets[4]``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`comp`*  \nSpecifies the component of the source texture that will be used to generate the resulting vector.\n\n *`refZ`*  \nSpecifies the reference Z value used in the comparison for shadow forms.\n\n *`offsets`*  \nSpecifies an array of offsets from the specified texture coordinate *`P`* from which the texels will be gathered.\n\n## Description\n\n`textureGatherOffsets` operates identically to [textureGatherOffset](texturegatheroffset.xhtml), except that *`offsets`* is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the offset in *`offsets`* as a (u, v) coordinate offset to *`P`*, identifying the four-texel `GL_LINEAR` footprint, and then selecting the texel *i*₀*i*₀ of that footprint. The specified values in *`offsets`* must be set with constant integral expressions.\n\n## Version Support\n\n|                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureGatherOffsets |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureGatherOffsets.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureGatherOffsets.xhtml)"
- name: textureGrad
  id: texturegrad.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureGrad — perform a texture lookup with explicit gradients\n\n## Declaration\n\n`gvec4 `**`textureGrad`**`(` gsampler1D `sampler`, float `P`, float `dPdx`, float `dPdy``)`;\n\n`gvec4 `**`textureGrad`**`(` gsampler2D `sampler`, vec2 `P`, vec2 `dPdx`, vec2 `dPdy``)`;\n\n`gvec4 `**`textureGrad`**`(` gsampler3D `sampler`, vec3 `P`, vec3 `dPdx`, vec3 `dPdy``)`;\n\n`gvec4 `**`textureGrad`**`(` gsamplerCube `sampler`, vec3 `P`, vec3 `dPdx`, vec3 `dPdy``)`;\n\n`gvec4 `**`textureGrad`**`(` gsampler2DRect `sampler`, vec2 `P`, vec2 `dPdx`, vec2 `dPdy``)`;\n\n`float `**`textureGrad`**`(` sampler2DRectShadow `sampler`, vec3 `P`, vec2 `dPdx`, vec2 `dPdy``)`;\n\n`float `**`textureGrad`**`(` sampler1DShadow `sampler`, vec3 `P`, float `dPdx`, float `dPdy``)`;\n\n`gvec4 `**`textureGrad`**`(` gsampler1DArray `sampler`, vec2 `P`, float `dPdx`, float `dPdy``)`;\n\n`gvec4 `**`textureGrad`**`(` gsampler2DArray `sampler`, vec3 `P`, vec2 `dPdx`, vec2 `dPdy``)`;\n\n`float `**`textureGrad`**`(` sampler1DArrayShadow `sampler`, vec3 `P`, float `dPdx`, float `dPdy``)`;\n\n`float `**`textureGrad`**`(` sampler2DShadow `sampler`, vec3 `P`, vec2 `dPdx`, vec2 `dPdy``)`;\n\n`float `**`textureGrad`**`(` samplerCubeShadow `sampler`, vec4 `P`, vec3 `dPdx`, vec3 `dPdy``)`;\n\n`float `**`textureGrad`**`(` sampler2DArrayShadow `sampler`, vec4 `P`, vec2 `dPdx`, vec2 `dPdy``)`;\n\n`gvec4 `**`textureGrad`**`(` gsamplerCubeArray `sampler`, vec4 `P`, vec3 `dPdx`, vec3 `dPdy``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`dPdx`*  \nSpecifies the partial derivative of *`P`* with respect to window x.\n\n *`dPdy`*  \nSpecifies the partial derivative of *`P`* with respect to window y.\n\n## Description\n\n`textureGrad` performs a texture lookup at coordinate *`P`* from the texture bound to *`sampler`* with explicit texture coordinate gradiends as specified in *`dPdx`* and *`dPdy`*. Set:\n\n$\\frac{\\delta s}{\\delta x} = \\frac{\\delta P}{\\delta x}{for\\\\a\\\\1D\\\\texture,}\\frac{\\delta P.s}{\\delta x}{otherwise}$\n\n$\\frac{\\delta s}{\\delta y} = \\frac{\\delta P}{\\delta y}{for\\\\a\\\\1D\\\\texture,}\\frac{\\delta P.s}{\\delta y}{otherwise}$\n\n$\\frac{\\delta t}{\\delta x} = 0.0{for\\\\a\\\\1D\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\texture,}\\frac{\\delta P.t}{\\delta x}{otherwise}$\n\n$\\frac{\\delta t}{\\delta y} = 0.0{for\\\\a\\\\1D\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\texture,}\\frac{\\delta P.t}{\\delta y}{otherwise}$\n\n$\\frac{\\delta r}{\\delta x} = 0.0{for\\\\a\\\\1D\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\or\\\\2D\\\\texture,}\\frac{\\delta P.p}{\\delta x}{otherwise}$\n\n$\\frac{\\delta r}{\\delta y} = 0.0{for\\\\a\\\\1D\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\or\\\\2D\\\\texture,}\\frac{\\delta P.p}{\\delta y}{otherwise}$\n\nFor the cube version, the partial derivatives of *`P`* are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face.\n\n## Version Support\n\n|                                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureGrad                          |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureGrad (gsampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureGrad (gsamplerCubeArray)      |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureGrad.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureGrad.xhtml)"
- name: textureGradOffset
  id: texturegradoffset.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureGradOffset — perform a texture lookup with explicit gradients and offset\n\n## Declaration\n\n`gvec4 `**`textureGradOffset`**`(` gsampler1D `sampler`, float `P`, float `dPdx`, float `dPdy`, int `offset``)`;\n\n`gvec4 `**`textureGradOffset`**`(` gsampler2D `sampler`, vec2 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`gvec4 `**`textureGradOffset`**`(` gsampler3D `sampler`, vec3 `P`, vec3 `dPdx`, vec3 `dPdy`, ivec3 `offset``)`;\n\n`gvec4 `**`textureGradOffset`**`(` gsampler2DRect `sampler`, vec2 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`float `**`textureGradOffset`**`(` sampler2DRectShadow `sampler`, vec3 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`float `**`textureGradOffset`**`(` sampler1DShadow `sampler`, vec3 `P`, float `dPdx`, float `dPdy`, int `offset``)`;\n\n`float `**`textureGradOffset`**`(` sampler2DShadow `sampler`, vec3 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`gvec4 `**`textureGradOffset`**`(` gsampler1DArray `sampler`, vec2 `P`, float `dPdx`, float `dPdy`, int `offset``)`;\n\n`gvec4 `**`textureGradOffset`**`(` gsampler2DArray `sampler`, vec3 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`float `**`textureGradOffset`**`(` sampler1DArrayShadow `sampler`, vec3 `P`, float `dPdx`, float `dPdy`, int `offset``)`;\n\n`float `**`textureGradOffset`**`(` sampler2DArrayShadow `sampler`, vec4 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`dPdx`*  \nSpecifies the partial derivative of *`P`* with respect to window x.\n\n *`dPdy`*  \nSpecifies the partial derivative of *`P`* with respect to window y.\n\n *`offset`*  \nSpecifies the offset to be applied to the texture coordinates before sampling.\n\n## Description\n\n`textureGradOffset` performs a texture lookup at coordinate *`P`* from the texture bound to *`sampler`* with explicit texture coordinate gradiends as specified in *`dPdx`* and *`dPdy`*. An explicit offset is also supplied in *`offset`*. `textureGradOffset` consumes *`dPdx`* and *`dPdy`* as [textureGrad](texturegrad.xhtml) and *`offset`* as [textureOffset](textureoffset.xhtml).\n\n## Version Support\n\n|                                            | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                          |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureGradOffset                          |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureGradOffset (gsampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureGradOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureGradOffset.xhtml)"
- name: textureLod
  id: texturelod.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureLod — perform a texture lookup with explicit level-of-detail\n\n## Declaration\n\n`gvec4 `**`textureLod`**`(` gsampler1D `sampler`, float `P`, float `lod``)`;\n\n`gvec4 `**`textureLod`**`(` gsampler2D `sampler`, vec2 `P`, float `lod``)`;\n\n`gvec4 `**`textureLod`**`(` gsampler3D `sampler`, vec3 `P`, float `lod``)`;\n\n`gvec4 `**`textureLod`**`(` gsamplerCube `sampler`, vec3 `P`, float `lod``)`;\n\n`float `**`textureLod`**`(` sampler1DShadow `sampler`, vec3 `P`, float `lod``)`;\n\n`float `**`textureLod`**`(` sampler2DShadow `sampler`, vec3 `P`, float `lod``)`;\n\n`gvec4 `**`textureLod`**`(` gsampler1DArray `sampler`, vec2 `P`, float `lod``)`;\n\n`gvec4 `**`textureLod`**`(` gsampler2DArray `sampler`, vec3 `P`, float `lod``)`;\n\n`float `**`textureLod`**`(` sampler1DArrayShadow `sampler`, vec3 `P`, float `lod``)`;\n\n`gvec4 `**`textureLod`**`(` gsamplerCubeArray `sampler`, vec4 `P`, float `lod``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`lod`*  \nSpecifies the explicit level-of-detail\n\n## Description\n\n`textureLod` performs a texture lookup at coordinate *`P`* from the texture bound to *`sampler`* with an explicit level-of-detail as specified in *`lod`*. *`lod`* specifies *λ*_(*b**a**s**e*) and sets the partial derivatives as follows:\n\n$\\begin{matrix}\n{\\frac{\\delta u}{\\delta x} = 0,} & {\\frac{\\delta v}{\\delta x} = 0,} & {\\frac{\\delta w}{\\delta x} = 0} \\\\\n{\\frac{\\delta u}{\\delta y} = 0,} & {\\frac{\\delta v}{\\delta y} = 0,} & {\\frac{\\delta w}{\\delta y} = 0}\n\\end{matrix}$\n\n## Version Support\n\n|                                     | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                   |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureLod                          |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureLod (gsampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureLod (gsamplerCubeArray)      |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureLod.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureLod.xhtml)"
- name: textureLodOffset
  id: texturelodoffset.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureLodOffset — perform a texture lookup with explicit level-of-detail and offset\n\n## Declaration\n\n`gvec4 `**`textureLodOffset`**`(` gsampler1D `sampler`, float `P`, float `lod`, int `offset``)`;\n\n`gvec4 `**`textureLodOffset`**`(` gsampler2D `sampler`, vec2 `P`, float `lod`, ivec2 `offset``)`;\n\n`gvec4 `**`textureLodOffset`**`(` gsampler3D `sampler`, vec3 `P`, float `lod`, ivec3 `offset``)`;\n\n`float `**`textureLodOffset`**`(` sampler1DShadow `sampler`, vec3 `P`, float `lod`, int `offset``)`;\n\n`float `**`textureLodOffset`**`(` sampler2DShadow `sampler`, vec3 `P`, float `lod`, ivec2 `offset``)`;\n\n`gvec4 `**`textureLodOffset`**`(` gsampler1DArray `sampler`, vec2 `P`, float `lod`, int `offset``)`;\n\n`gvec4 `**`textureLodOffset`**`(` gsampler2DArray `sampler`, vec3 `P`, float `lod`, ivec2 `offset``)`;\n\n`float `**`textureLodOffset`**`(` sampler1DArrayShadow `sampler`, vec3 `P`, float `lod`, int `offset``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which the texture will be sampled.\n\n *`lod`*  \nSpecifies the explicit level-of-detail from which texels will be fetched.\n\n *`offset`*  \nSpecifies the offset that will be applied to *`P`* before texels are fetched.\n\n## Description\n\n`textureLodOffset` performs a texture lookup at coordinate *`P`* from the texture bound to *`sampler`* with an explicit level-of-detail as specified in *`lod`*. Behavior is the same as in [textureLod](texturelod.xhtml) except that before sampling, *`offset`* is added to *`P`*.\n\n## Version Support\n\n|                                           | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                         |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureLodOffset                          |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureLodOffset (gsampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureLodOffset (gsamplerCubeArray)      |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureLodOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureLodOffset.xhtml)"
- name: textureOffset
  id: textureoffset.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureOffset — perform a texture lookup with offset\n\n## Declaration\n\n`gvec4 `**`textureOffset`**`(` gsampler1D `sampler`, float `P`, int `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureOffset`**`(` gsampler2D `sampler`, vec2 `P`, ivec2 `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureOffset`**`(` gsampler3D `sampler`, vec3 `P`, ivec3 `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureOffset`**`(` gsampler2DRect `sampler`, vec2 `P`, ivec2 `offset``)`;\n\n`float `**`textureOffset`**`(` sampler2DRectShadow `sampler`, vec3 `P`, ivec2 `offset``)`;\n\n`float `**`textureOffset`**`(` sampler1DShadow `sampler`, vec3 `P`, int `offset`, \\[float `bias`\\]`)`;\n\n`float `**`textureOffset`**`(` sampler2DShadow `sampler`, vec4 `P`, ivec2 `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureOffset`**`(` gsampler1DArray `sampler`, vec2 `P`, int `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureOffset`**`(` gsampler2DArray `sampler`, vec3 `P`, ivec2 `offset`, \\[float `bias`\\]`)`;\n\n`float `**`textureOffset`**`(` sampler1DArrayShadow `sampler`, vec3 `P`, int `offset``)`;\n\n`float `**`textureOffset`**`(` sampler2DArrayShadow `sampler`, vec4 `P`, vec2 `offset``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`offset`*  \nSpecifies offset, in texels that will be applied to *`P`* before looking up the texel.\n\n## Description\n\n`textureOffset` performs a texture lookup at coordinate *`P`* from the texture bound to *`sampler`* with an additional offset, specified in texels in *`offset`* that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying `GL_MIN_PROGRAM_TEXEL_OFFSET` and `GL_MAX_PROGRAM_TEXEL_OFFSET`, respectively.\n\nNote that *`offset`* does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps.\n\n## Version Support\n\n|                                        | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                      |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureOffset                          |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureOffset (gsampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureOffset.xhtml)"
- name: textureProj
  id: textureproj.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureProj — perform a texture lookup with projection\n\n## Declaration\n\n`gvec4 `**`textureProj`**`(` gsampler1D `sampler`, vec2 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProj`**`(` gsampler1D `sampler`, vec4 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProj`**`(` gsampler2D `sampler`, vec3 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProj`**`(` gsampler2D `sampler`, vec4 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProj`**`(` gsampler3D `sampler`, vec4 `P`, \\[float `bias`\\]`)`;\n\n`float `**`textureProj`**`(` sampler1DShadow `sampler`, vec4 `P`, \\[float `bias`\\]`)`;\n\n`float `**`textureProj`**`(` sampler2DShadow `sampler`, vec4 `P`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProj`**`(` gsampler2DRect `sampler`, vec3 `P``)`;\n\n`gvec4 `**`textureProj`**`(` gsampler2DRect `sampler`, vec4 `P``)`;\n\n`float `**`textureProj`**`(` sampler2DRectShadow `sampler`, vec4 `P``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`bias`*  \nSpecifies an optional bias to be applied during level-of-detail computation.\n\n## Description\n\n`textureProj` performs a texture lookup with projection. The texture coordinates consumed from *`P`*, not including the last component of *`P`*, are divided by the last component of *`P`*. The resulting 3^(*r**d*) component of *`P`* in the shadow forms is used as *D*_(*r**e**f*). After these values are computed, the texture lookup proceeds as in [texture](texture.xhtml).\n\n## Version Support\n\n|                                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureProj                          |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureProj (gsampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureProj.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureProj.xhtml)"
- name: textureProjGrad
  id: textureprojgrad.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureProjGrad — perform a texture lookup with projection and explicit gradients\n\n## Declaration\n\n`gvec4 `**`textureProjGrad`**`(` gsampler1D `sampler`, vec2 `P`, float `pDx`, float `pDy``)`;\n\n`gvec4 `**`textureProjGrad`**`(` gsampler1D `sampler`, vec4 `P`, float `pDx`, float `pDy``)`;\n\n`gvec4 `**`textureProjGrad`**`(` gsampler2D `sampler`, vec3 `P`, vec2 `pDx`, vec2 `pDy``)`;\n\n`gvec4 `**`textureProjGrad`**`(` gsampler2D `sampler`, vec4 `P`, vec2 `pDx`, vec2 `pDy``)`;\n\n`gvec4 `**`textureProjGrad`**`(` gsampler3D `sampler`, vec4 `P`, vec3 `pDx`, vec3 `pDy``)`;\n\n`float `**`textureProjGrad`**`(` sampler1DShadow `sampler`, vec4 `P`, float `pDx`, float `pDy``)`;\n\n`float `**`textureProjGrad`**`(` sampler2DShadow `sampler`, vec4 `P`, vec2 `pDx`, vec2 `pDy``)`;\n\n`gvec4 `**`textureProjGrad`**`(` gsampler2DRect `sampler`, vec3 `P`, vec2 `pDx`, vec2 `pDy``)`;\n\n`gvec4 `**`textureProjGrad`**`(` gsampler2DRect `sampler`, vec4 `P`, vec2 `pDx`, vec2 `pDy``)`;\n\n`float `**`textureProjGrad`**`(` sampler2DRectShadow `sampler`, vec4 `P`, vec2 `pDx`, vec2 `pDy``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`dPdx`*  \nSpecifies the partial derivative of *`P`* with respect to window x.\n\n *`dPdy`*  \nSpecifies the partial derivative of *`P`* with respect to window y.\n\n## Description\n\n`textureProjGrad` performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from *`P`*, not including the last component of *`P`*, are divided by the last component of *`P`*. The resulting 3^(*r**d*) component of *`P`* in the shadow forms is used as *D*_(*r**e**f*). After these values are computed, the texture lookup proceeds as in [textureGrad](texturegrad.xhtml), passing *`dPdx`* and *`dPdy`* as gradients.\n\n## Version Support\n\n|                                          | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-----------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                        |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureProjGrad                          |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureProjGrad (gsampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjGrad.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjGrad.xhtml)"
- name: textureProjGradOffset
  id: textureprojgradoffset.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureProjGradOffset — perform a texture lookup with projection, explicit gradients and offset\n\n## Declaration\n\n`gvec4 `**`textureProjGradOffset`**`(` gsampler1D `sampler`, vec2 `P`, float `dPdx`, float `dPdy`, int `offset``)`;\n\n`gvec4 `**`textureProjGradOffset`**`(` gsampler1D `sampler`, vec4 `P`, float `dPdx`, float `dPdy`, int `offset``)`;\n\n`gvec4 `**`textureProjGradOffset`**`(` gsampler2D `sampler`, vec3 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`gvec4 `**`textureProjGradOffset`**`(` gsampler2D `sampler`, vec4 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`gvec4 `**`textureProjGradOffset`**`(` gsampler3D `sampler`, vec4 `P`, vec3 `dPdx`, vec3 `dPdy`, ivec3 `offset``)`;\n\n`float `**`textureProjGradOffset`**`(` sampler1DShadow `sampler`, vec4 `P`, float `dPdx`, float `dPdy`, int `offset``)`;\n\n`float `**`textureProjGradOffset`**`(` sampler2DShadow `sampler`, vec4 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`gvec4 `**`textureProjGradOffset`**`(` gsampler2DRect `sampler`, vec3 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`gvec4 `**`textureProjGradOffset`**`(` gsampler2DRect `sampler`, vec4 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n`float `**`textureProjGradOffset`**`(` sampler2DRectShadow `sampler`, vec4 `P`, vec2 `dPdx`, vec2 `dPdy`, ivec2 `offset``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`dPdx`*  \nSpecifies the partial derivative of *`P`* with respect to window x.\n\n *`dPdy`*  \nSpecifies the partial derivative of *`P`* with respect to window y.\n\n *`offset`*  \nSpecifies the offsets, in texels at which the texture will be sampled relative to the projection of *`P`*.\n\n## Description\n\n`textureProjGradOffset` performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from *`P`*, not including the last component of *`P`*, are divided by the last component of *`P`*. The resulting 3^(*r**d*) component of *`P`* in the shadow forms is used as *D*_(*r**e**f*). After these values are computed, the texture lookup proceeds as in [textureGradOffset](texturegradoffset.xhtml), passing *`dPdx`* and *`dPdy`* as gradients, and *`offset`* as the offset.\n\n## Version Support\n\n|                                                | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-----------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                              |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureProjGradOffset                          |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureProjGradOffset (gsampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjGradOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjGradOffset.xhtml)"
- name: textureProjLod
  id: textureprojlod.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureProjLod — perform a texture lookup with projection and explicit level-of-detail\n\n## Declaration\n\n`gvec4 `**`textureProjLod`**`(` gsampler1D `sampler`, vec2 `P`, float `lod``)`;\n\n`gvec4 `**`textureProjLod`**`(` gsampler1D `sampler`, vec4 `P`, float `lod``)`;\n\n`gvec4 `**`textureProjLod`**`(` gsampler2D `sampler`, vec3 `P`, float `lod``)`;\n\n`gvec4 `**`textureProjLod`**`(` gsampler2D `sampler`, vec4 `P`, float `lod``)`;\n\n`gvec4 `**`textureProjLod`**`(` gsampler3D `sampler`, vec4 `P`, float `lod``)`;\n\n`float `**`textureProjLod`**`(` sampler1DShadow `sampler`, vec4 `P`, float `lod``)`;\n\n`float `**`textureProjLod`**`(` sampler2DShadow `sampler`, vec4 `P`, float `lod``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`lod`*  \nSpecifies the explicit level-of-detail from which to fetch texels.\n\n## Description\n\n`textureProjLod` performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from *`P`*, not including the last component of *`P`*, are divided by the last component of *`P`*. The resulting 3^(*r**d*) component of *`P`* in the shadow forms is used as *D*_(*r**e**f*). After these values are computed, the texture lookup proceeds as in [textureLod](texturelod.xhtml), with *`lod`* used to specify the level-of-detail from which the texture will be sampled.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureProjLod    |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjLod.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjLod.xhtml)"
- name: textureProjLodOffset
  id: textureprojlodoffset.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureProjLodOffset — perform a texture lookup with projection and explicit level-of-detail and offset\n\n## Declaration\n\n`gvec4 `**`textureProjLodOffset`**`(` gsampler1D `sampler`, vec2 `P`, float `lod`, int `offset``)`;\n\n`gvec4 `**`textureProjLodOffset`**`(` gsampler1D `sampler`, vec4 `P`, float `lod`, int `offset``)`;\n\n`gvec4 `**`textureProjLodOffset`**`(` gsampler2D `sampler`, vec3 `P`, float `lod`, ivec2 `offset``)`;\n\n`gvec4 `**`textureProjLodOffset`**`(` gsampler2D `sampler`, vec4 `P`, float `lod`, ivec2 `offset``)`;\n\n`gvec4 `**`textureProjLodOffset`**`(` gsampler3D `sampler`, vec4 `P`, float `lod`, ivec3 `offset``)`;\n\n`float `**`textureProjLodOffset`**`(` sampler1DShadow `sampler`, vec4 `P`, float `lod`, int `offset``)`;\n\n`float `**`textureProjLodOffset`**`(` sampler2DShadow `sampler`, vec4 `P`, float `lod`, ivec2 `offset``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which texture will be sampled.\n\n *`lod`*  \nSpecifies the explicit level-of-detail from which to fetch texels.\n\n *`offset`*  \nSpecifies the offset, in texels, to be applied to *`P`* before fetching texels.\n\n## Description\n\n`textureProjLodOffset` performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from *`P`*, not including the last component of *`P`*, are divided by the last component of *`P`*. The resulting 3^(*r**d*) component of *`P`* in the shadow forms is used as *D*_(*r**e**f*). After these values are computed, the texture lookup proceeds as in [textureLodOffset](texturelodoffset.xhtml), with *`lod`* used to specify the level-of-detail from which the texture will be sampled and *`offset`* used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling.\n\n## Version Support\n\n|                      | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**    |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureProjLodOffset |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjLodOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjLodOffset.xhtml)"
- name: textureProjOffset
  id: textureprojoffset.xhtml
  summary: sampler Specifies the sampler to which the texture from which texels will be retrieved is bound
  description: "## Name\n\ntextureProjOffset — perform a texture lookup with projection and offset\n\n## Declaration\n\n`gvec4 `**`textureProjOffset`**`(` gsampler1D `sampler`, vec2 `P`, int `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProjOffset`**`(` gsampler1D `sampler`, vec4 `P`, int `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProjOffset`**`(` gsampler2D `sampler`, vec3 `P`, ivec2 `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProjOffset`**`(` gsampler2D `sampler`, vec4 `P`, ivec2 `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProjOffset`**`(` gsampler3D `sampler`, vec4 `P`, ivec3 `offset`, \\[float `bias`\\]`)`;\n\n`float `**`textureProjOffset`**`(` sampler1DShadow `sampler`, vec4 `P`, int `offset`, \\[float `bias`\\]`)`;\n\n`float `**`textureProjOffset`**`(` sampler2DShadow `sampler`, vec4 `P`, ivec2 `offset`, \\[float `bias`\\]`)`;\n\n`gvec4 `**`textureProjOffset`**`(` gsampler2DRect `sampler`, vec3 `P`, ivec2 `offset``)`;\n\n`gvec4 `**`textureProjOffset`**`(` gsampler2DRect `sampler`, vec4 `P`, ivec2 `offset``)`;\n\n`float `**`textureProjOffset`**`(` sampler2DRectShadow `sampler`, vec4 `P`, ivec2 `offset``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture from which texels will be retrieved is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which the texture will be sampled.\n\n *`offset`*  \nSpecifies the offset that is applied to *`P`* before sampling occurs.\n\n *`bias`*  \nSpecifies an optional bias to be applied during level-of-detail computation.\n\n## Description\n\n`textureProjOffset` performs a texture lookup with projection. The texture coordinates consumed from *`P`*, not including the last component of *`P`*, are divided by the last component of *`P`*. The resulting 3^(*r**d*) component of *`P`* in the shadow forms is used as *D*_(*r**e**f*). After these values are computed, the texture lookup proceeds as in [textureOffset](textureoffset.xhtml), with the *`offset`* used to offset the computed texture coordinates.\n\n## Version Support\n\n|                                            | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                          |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureProjOffset                          |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureProjOffset (gsampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjOffset.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureProjOffset.xhtml)"
- name: textureQueryLevels
  id: texturequerylevels.xhtml
  summary: sampler Specifies the sampler to which the texture whose mipmap level count will be queried is bound
  description: "## Name\n\ntextureQueryLevels — compute the number of accessible mipmap levels of a texture\n\n## Declaration\n\n`int `**`textureQueryLevels`**`(` gsampler1D `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` gsampler2D `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` gsampler3D `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` gsamplerCube `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` gsampler1DArray `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` gsampler2DArray `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` gsamplerCubeArray `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` sampler1DShadow `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` sampler2DShadow `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` samplerCubeShadow `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` sampler1DArrayShadow `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` sampler2DArrayShadow `sampler``)`;\n\n`int `**`textureQueryLevels`**`(` samplerCubeArrayShadow `sampler``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture whose mipmap level count will be queried is bound.\n\n## Description\n\n`textureQueryLevels` returns the number of accessible mipmap levels in the texture associated with *`sampler`*.\n\nIf called on an incomplete texture, or if no texture is associated with *`sampler`*, zero is returned.\n\n## Version Support\n\n|                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureQueryLevels |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureQueryLevels.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureQueryLevels.xhtml)"
- name: textureQueryLod
  id: texturequerylod.xhtml
  summary: sampler Specifies the sampler to which the texture whose level-of-detail will be queried is bound
  description: "## Name\n\ntextureQueryLod — compute the level-of-detail that would be used to sample from a texture\n\n## Declaration\n\n`vec2 `**`textureQueryLod`**`(` gsampler1D `sampler`, float `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` gsampler2D `sampler`, vec2 `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` gsampler3D `sampler`, vec3 `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` gsamplerCube `sampler`, vec3 `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` gsampler1DArray `sampler`, float `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` gsampler2DArray `sampler`, vec2 `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` gsamplerCubeArray `sampler`, vec3 `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` sampler1DShadow `sampler`, float `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` sampler2DShadow `sampler`, vec2 `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` samplerCubeShadow `sampler`, vec3 `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` sampler1DArrayShadow `sampler`, float `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` sampler2DArrayShadow `sampler`, vec2 `P``)`;\n\n`vec2 `**`textureQueryLod`**`(` samplerCubeArrayShadow `sampler`, vec3 `P``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture whose level-of-detail will be queried is bound.\n\n *`P`*  \nSpecifies the texture coordinates at which the level-of-detail will be queried.\n\n## Description\n\n*Available only in the fragment shader*, `textureQueryLod` computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the *x* component of the return value. The computed level-of-detail relative to the base level is returned in the *y* component of the return value.\n\nIf called on an incomplete texture, the result of the operation is undefined.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureQueryLod   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureQueryLod.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureQueryLod.xhtml)"
- name: textureSamples
  id: texturesamples.xhtml
  summary: sampler Specifies the sampler to which the texture is bound
  description: "## Name\n\ntextureSamples — return the number of samples of a texture\n\n## Declaration\n\n`int `**`textureSamples`**`(` gsampler2DMS `sampler``)`;\n\n`int `**`textureSamples`**`(` gsampler2DMSArray `sampler``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture is bound.\n\n## Description\n\n`textureSamples` returns the number of samples per texel of the texture bound to *`sampler`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureSamples    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |\n\n## See Also\n\n[texture](texture.xhtml), [textureQueryLevels](texturequerylevels.xhtml), [textureQueryLod](texturequerylod.xhtml), [textureSize](texturesize.xhtml)\n\n## Copyright\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureSamples.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureSamples.xhtml)"
- name: textureSize
  id: texturesize.xhtml
  summary: sampler Specifies the sampler to which the texture whose dimensions to retrieve is bound
  description: "## Name\n\ntextureSize — retrieve the dimensions of a level of a texture\n\n## Declaration\n\n`int `**`textureSize`**`(` gsampler1D `sampler`, int `lod``)`;\n\n`ivec2 `**`textureSize`**`(` gsampler2D `sampler`, int `lod``)`;\n\n`ivec3 `**`textureSize`**`(` gsampler3D `sampler`, int `lod``)`;\n\n`ivec2 `**`textureSize`**`(` gsamplerCube `sampler`, int `lod``)`;\n\n`int `**`textureSize`**`(` sampler1DShadow `sampler`, int `lod``)`;\n\n`ivec2 `**`textureSize`**`(` sampler2DShadow `sampler`, int `lod``)`;\n\n`ivec2 `**`textureSize`**`(` samplerCubeShadow `sampler`, int `lod``)`;\n\n`ivec3 `**`textureSize`**`(` samplerCubeArray `sampler`, int `lod``)`;\n\n`ivec3 `**`textureSize`**`(` samplerCubeArrayShadow `sampler`, int `lod``)`;\n\n`ivec2 `**`textureSize`**`(` gsampler2DRect `sampler``)`;\n\n`ivec2 `**`textureSize`**`(` sampler2DRectShadow `sampler``)`;\n\n`ivec2 `**`textureSize`**`(` gsampler1DArray `sampler`, int `lod``)`;\n\n`ivec3 `**`textureSize`**`(` gsampler2DArray `sampler`, int `lod``)`;\n\n`ivec2 `**`textureSize`**`(` sampler1DArrayShadow `sampler`, int `lod``)`;\n\n`ivec3 `**`textureSize`**`(` sampler2DArrayShadow `sampler`, int `lod``)`;\n\n`int `**`textureSize`**`(` gsamplerBuffer `sampler``)`;\n\n`ivec2 `**`textureSize`**`(` gsampler2DMS `sampler``)`;\n\n`ivec3 `**`textureSize`**`(` gsampler2DMSArray `sampler``)`;\n\n## Parameters\n\n *`sampler`*  \nSpecifies the sampler to which the texture whose dimensions to retrieve is bound.\n\n *`lod`*  \nSpecifies the level of the texture for which to retrieve the dimensions.\n\n## Description\n\n`textureSize` returns the dimensions of level *`lod`* (if present) of the texture bound to *`sampler`*. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array.\n\n## Version Support\n\n|                                                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:---------------------------------------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**                                  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| textureSize                                        |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureSize (samplerBuffer, sampler2DRect{Shadow}) |                 \\-                  |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| textureSize (samplerCube{Shadow})                  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[texelFetch](texelfetch.xhtml), [texelFetchOffset](texelfetchoffset.xhtml), [texture](texture.xhtml), [textureGather](texturegather.xhtml), [textureGatherOffset](texturegatheroffset.xhtml), [textureGatherOffsets](texturegatheroffsets.xhtml), [textureGrad](texturegrad.xhtml), [textureGradOffset](texturegradoffset.xhtml), [textureLod](texturelod.xhtml), [textureLodOffset](texturelodoffset.xhtml), [textureOffset](textureoffset.xhtml), [textureProj](textureproj.xhtml), [textureProjGrad](textureprojgrad.xhtml), [textureProjGradOffset](textureprojgradoffset.xhtml), [textureProjLod](textureprojlod.xhtml), [textureProjLodOffset](textureprojlodoffset.xhtml), [textureProjOffset](textureprojoffset.xhtml), [textureQueryLod](texturequerylod.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/textureSize.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/textureSize.xhtml)"
- name: transpose
  id: transpose.xhtml
  summary: m Specifies the matrix of which to take the transpose
  description: "## Name\n\ntranspose — calculate the transpose of a matrix\n\n## Declaration\n\n`mat2 `**`transpose`**`(` mat2 `m``)`;\n\n`mat3 `**`transpose`**`(` mat3 `m``)`;\n\n`mat4 `**`transpose`**`(` mat4 `m``)`;\n\n`mat2x3 `**`transpose`**`(` mat3x2 `m``)`;\n\n`mat2x4 `**`transpose`**`(` mat4x2 `m``)`;\n\n`mat3x2 `**`transpose`**`(` mat2x3 `m``)`;\n\n`mat3x4 `**`transpose`**`(` mat4x3 `m``)`;\n\n`mat4x2 `**`transpose`**`(` mat2x4 `m``)`;\n\n`mat4x3 `**`transpose`**`(` mat3x4 `m``)`;\n\n`dmat2 `**`transpose`**`(` dmat2 `m``)`;\n\n`dmat3 `**`transpose`**`(` dmat3 `m``)`;\n\n`dmat4 `**`transpose`**`(` dmat4 `m``)`;\n\n`dmat2x3 `**`transpose`**`(` dmat3x2 `m``)`;\n\n`dmat2x4 `**`transpose`**`(` dmat4x2 `m``)`;\n\n`dmat3x2 `**`transpose`**`(` dmat2x3 `m``)`;\n\n`dmat3x4 `**`transpose`**`(` dmat4x3 `m``)`;\n\n`dmat4x2 `**`transpose`**`(` dmat2x4 `m``)`;\n\n`dmat4x3 `**`transpose`**`(` dmat3x4 `m``)`;\n\n## Parameters\n\n *`m`*  \nSpecifies the matrix of which to take the transpose.\n\n## Description\n\n`transpose` returns the transpose of the matrix *`m`*.\n\n## Version Support\n\n|                    | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:-------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name**  |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| transpose (float)  |                 \\-                  |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| transpose (double) |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[determinant](determinant.xhtml), [inverse](inverse.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/transpose.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/transpose.xhtml)"
- name: trunc
  id: trunc.xhtml
  summary: x Specify the value to evaluate
  description: "## Name\n\ntrunc — find the truncated value of the parameter\n\n## Declaration\n\n`genType `**`trunc`**`(` genType `x``)`;\n\n`genDType `**`trunc`**`(` genDType `x``)`;\n\n## Parameters\n\n *`x`*  \nSpecify the value to evaluate.\n\n## Description\n\n`trunc` returns a value equal to the nearest integer to *`x`* whose absolute value is not larger than the absolute value of *`x`*.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| trunc (genType)   |                 \\-                  |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| trunc (genDType)  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[floor](floor.xhtml), [round](round.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/trunc.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/trunc.xhtml)"
- name: uaddCarry
  id: uaddcarry.xhtml
  summary: x Specifies the first vector to be used in the summation operation
  description: "## Name\n\nuaddCarry — add unsigned integers and generate carry\n\n## Declaration\n\n`genUType `**`uaddCarry`**`(` genUType `x`, genUType `y`, out genUType `carry``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first vector to be used in the summation operation.\n\n *`y`*  \nSpecifies the second vector to be used in the summation operation.\n\n *`carry`*  \nSpecifies the variable to receive the carry output of the sum.\n\n## Description\n\n`uaddCarry` adds two 32-bit unsigned integer variables (scalars or vectors) and generates a 32-bit unsigned integer result, along with a carry output. The result is the sum of *`x`* and *`y`* modulo 2³². The value *`carry`* is set to 0 if the sum is less than 2³² and to 1 otherwise.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| uaddCarry         |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[usubBorrow](usubborrow.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/uaddCarry.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/uaddCarry.xhtml)"
- name: uintBitsToFloat
  id: intbitstofloat.xhtml#uintBitsToFloat
  summary: Specifies the bit encoding to return as a floating point value
  belongs_to: intBitsToFloat
  description: "`genType `**`uintBitsToFloat`**`(` genUType `x``)`;\n\n## Parameters\n\n*`x`*\n\nSpecifies the bit encoding to return as a floating point value.\n\n## Description\n\n`intBitsToFloat` and `uintBitsToFloat` return the encoding passed in parameter *`x`* as a floating-point value. If the encoding of a NaN is passed in *`x`*, it will not signal and the resulting value will be undefined. If the encoding of a floating point infinity is passed in parameter *`x`*, the resulting floating-point value is the corresponding (positive or negative) floating point infinity.\n\n## Version Support\n\n|                     |  **OpenGL Shading Language Version**  |            |            |            |            |            |            |            |            |            |            |            |\n|:--------------------|:-------------------------------------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|\n|  **Function Name**  |                **1.10**               |  **1.20**  |  **1.30**  |  **1.40**  |  **1.50**  |  **3.30**  |  **4.00**  |  **4.10**  |  **4.20**  |  **4.30**  |  **4.40**  |  **4.50**  |\n| intBitsToFloat      |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n\n## See Also\n\n[floatBitsToInt](floatbitstoint.xhtml), `floatBitsToUint`, [isnan](isnan.xhtml), [isinf](isinf.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/intBitsToFloat.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/intBitsToFloat.xhtml)"
- name: umulExtended
  id: umulextended.xhtml
  summary: x Specifies the first multiplicand
  description: "## Name\n\numulExtended — perform a 32- by 32-bit multiply to produce a 64-bit result\n\n## Declaration\n\n`void `**`umulExtended`**`(` genUType `x`, genUType `y`, out genUType `msb`, out genUType `lsb``)`;\n\n`void `**`imulExtended`**`(` genIType `x`, genIType `y`, out genIType `msb`, out genIType `lsb``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first multiplicand.\n\n *`y`*  \nSpecifies the second multiplicand.\n\n *`msb`*  \nSpecifies the variable to receive the most significant word of the product.\n\n *`lsb`*  \nSpecifies the variable to receive the least significant word of the product.\n\n## Description\n\n`umulExtended` and `imulExtended` perform multiplication of the two 32-bit integer quantities *`x`* and *`y`*, producing a 64-bit integer result. The 32 least significant bits of this product are returned in *`lsb`* and the 32 most significant bits are returned in *`msb`*. `umulExtended` and `imulExtended` perform unsigned and signed multiplication, respectively.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| umulExtended      |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[uaddCarry](uaddcarry.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/umulExtended.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/umulExtended.xhtml)"
- name: unpackDouble2x32
  id: unpackdouble2x32.xhtml
  summary: d Specifies double precision value to break into a pair of unsigned integers
  description: "## Name\n\nunpackDouble2x32 — produce two unsigned integers containing the bit encoding of a double precision floating point value\n\n## Declaration\n\n`uvec2 `**`unpackDouble2x32`**`(` double `d``)`;\n\n## Parameters\n\n *`d`*  \nSpecifies double precision value to break into a pair of unsigned integers.\n\n## Description\n\n`unpackDouble2x32` returns a two-component unsigned integer vector representation of *`d`*. The bit-level representation of *`d`* is preserved. The first component of the returned vector contains the 32 least significant bits of the double; the second component consists the 32 most significant bits.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| unpackDouble2x32  |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[packDouble2x32](packdouble2x32.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/unpackDouble2x32.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/unpackDouble2x32.xhtml)"
- name: unpackHalf2x16
  id: unpackhalf2x16.xhtml
  summary: v Specify a single 32-bit unsigned integer values that contains two 16-bit floating point values to be unpacked
  description: "## Name\n\nunpackHalf2x16 — convert two 16-bit floating-point values packed into a single 32-bit integer into a vector of two 32-bit floating-point quantities\n\n## Declaration\n\n`vec2 `**`unpackHalf2x16`**`(` uint `v``)`;\n\n## Parameters\n\n *`v`*  \nSpecify a single 32-bit unsigned integer values that contains two 16-bit floating point values to be unpacked.\n\n## Description\n\n`unpackHalf2x16` returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values. The first component of the vector is obtained from the 16 least-significant bits of v; the second component is obtained from the 16 most-significant bits of v.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| unpackHalf2x16    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[packDouble2x32](packdouble2x32.xhtml), [unpackDouble2x32](unpackdouble2x32.xhtml), [packHalf2x16](packhalf2x16.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/unpackHalf2x16.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/unpackHalf2x16.xhtml)"
- name: unpackSnorm2x16
  id: unpackunorm.xhtml#unpackSnorm2x16
  summary: null
  belongs_to: unpackUnorm
  description: '`vec2 `**`unpackSnorm2x16`**`(` uint `p``)`;'
- name: unpackSnorm4x8
  id: unpackunorm.xhtml#unpackSnorm4x8
  summary: Specifies an unsigned integer containing packed floating-point values
  belongs_to: unpackUnorm
  description: "`vec4 `**`unpackSnorm4x8`**`(` uint `p``)`;\n\n## Parameters\n\n*`p`*\n\nSpecifies an unsigned integer containing packed floating-point values.\n\n## Description\n\n`unpackUnorm2x16`, `unpackSnorm2x16`, `unpackUnorm4x8` and `unpackSnorm4x8` unpack single 32-bit unsigned integers, specified in the parameter *`p`* into a pair of 16-bit unsigned integers, four 8-bit unsigned integers or four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.\n\nThe conversion for unpacked fixed point value *f* to floating-point is performed as follows:\n\n- `packUnorm2x16`: `f / 65535.0`\n\n- `packSnorm2x16`: `clamp``(f / 32727.0, -1.0, 1.0)`\n\n- `packUnorm4x8`: `f / 255.0`\n\n- `packSnorm4x8`: `clamp``(f / 127.0, -1.0, 1.0)`\n\nThe first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\n\n## Version Support\n\n|                     |  **OpenGL Shading Language Version**  |            |            |            |            |            |            |            |            |            |            |            |\n|:--------------------|:-------------------------------------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|\n|  **Function Name**  |                **1.10**               |  **1.20**  |  **1.30**  |  **1.40**  |  **1.50**  |  **3.30**  |  **4.00**  |  **4.10**  |  **4.20**  |  **4.30**  |  **4.40**  |  **4.50**  |\n| unpackUnorm2x16     |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| unpackSnorm2x16     |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |\n| unpackUnorm4x8      |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n| unpackSnorm4x8      |                  \\-                   |     \\-     |     \\-     |     \\-     |     \\-     |     \\-     |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |     ✔      |\n\n## See Also\n\n`packUnorm2x16`, `packUnorm4x8`, `packSnorm4x8`\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/unpackUnorm.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/unpackUnorm.xhtml)"
- name: unpackUnorm
  id: unpackunorm.xhtml
  summary: p Specifies an unsigned integer containing packed floating-point values
  description: "## Name\n\nunpackUnorm2x16, unpackUnorm4x8, unpackSnorm4x8 — unpack floating-point values from an unsigned integer\n\n## Declaration\n\n`vec2 `**`unpackUnorm2x16`**`(` uint `p``)`;\n\n`vec2 `**`unpackSnorm2x16`**`(` uint `p``)`;\n\n`vec4 `**`unpackUnorm4x8`**`(` uint `p``)`;\n\n`vec4 `**`unpackSnorm4x8`**`(` uint `p``)`;\n\n## Parameters\n\n *`p`*  \nSpecifies an unsigned integer containing packed floating-point values.\n\n## Description\n\n`unpackUnorm2x16`, `unpackSnorm2x16`, `unpackUnorm4x8` and `unpackSnorm4x8` unpack single 32-bit unsigned integers, specified in the parameter *`p`* into a pair of 16-bit unsigned integers, four 8-bit unsigned integers or four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.\n\nThe conversion for unpacked fixed point value *f* to floating-point is performed as follows:\n\n- `packUnorm2x16`: `f / 65535.0`\n\n- `packSnorm2x16`: `clamp``(f / 32727.0, -1.0, 1.0)`\n\n- `packUnorm4x8`: `f / 255.0`\n\n- `packSnorm4x8`: `clamp``(f / 127.0, -1.0, 1.0)`\n\nThe first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| unpackUnorm2x16   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| unpackSnorm2x16   |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |\n| unpackUnorm4x8    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n| unpackSnorm4x8    |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n`packUnorm2x16`, `packUnorm4x8`, `packSnorm4x8`\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/unpackUnorm.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/unpackUnorm.xhtml)"
- name: unpackUnorm2x16
  id: unpackunorm.xhtml#unpackUnorm2x16
  summary: null
  belongs_to: unpackUnorm
  description: '`vec2 `**`unpackUnorm2x16`**`(` uint `p``)`;'
- name: unpackUnorm4x8
  id: unpackunorm.xhtml#unpackUnorm4x8
  summary: null
  belongs_to: unpackUnorm
  description: '`vec4 `**`unpackUnorm4x8`**`(` uint `p``)`;'
- name: usubBorrow
  id: usubborrow.xhtml
  summary: x Specifies the first vector to be used in the subtraction operation
  description: "## Name\n\nusubBorrow — subtract unsigned integers and generate borrow\n\n## Declaration\n\n`genUType `**`usubBorrow`**`(` genUType `x`, genUType `y`, out genUType `borrow``)`;\n\n## Parameters\n\n *`x`*  \nSpecifies the first vector to be used in the subtraction operation.\n\n *`y`*  \nSpecifies the second vector to be used in the subtraction operation.\n\n *`borrow`*  \nSpecifies the variable to receive the borrow output of the difference.\n\n## Description\n\n`usubBorrow` subtracts two 32-bit unsigned integer variables (scalars or vectors) and generates a 32-bit unsigned integer result, along with a borrow output. The result is the difference of *`x`* and *`y`* if non-negative, or 2³² plus that difference otherwise. The value *`borrow`* is set to 0 if *`x`* ≥ *`y`* and to 1 otherwise.\n\n## Version Support\n\n|                   | **OpenGL Shading Language Version** |          |          |          |          |          |          |          |          |          |          |          |\n|:------------------|:-----------------------------------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|\n| **Function Name** |              **1.10**               | **1.20** | **1.30** | **1.40** | **1.50** | **3.30** | **4.00** | **4.10** | **4.20** | **4.30** | **4.40** | **4.50** |\n| usubBorrow        |                 \\-                  |    \\-    |    \\-    |    \\-    |    \\-    |    \\-    |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |    ✔     |\n\n## See Also\n\n[uaddCarry](uaddcarry.xhtml)\n\n## Copyright\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. [https://opencontent.org/openpub/](https://opencontent.org/openpub/).\n\nCopyright © 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.  \n[https://registry.khronos.org/OpenGL-Refpages/gl4/usubBorrow.xhtml](https://registry.khronos.org/OpenGL-Refpages/gl4/usubBorrow.xhtml)"
