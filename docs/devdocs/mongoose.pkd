---
name: Mongoose
slug: mongoose
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2010 LearnBoost
  Licensed under the MIT License.
  https://mongoosejs.com/docs/index.html
homepage: http://mongoosejs.com/

---
- name: Aggregate
  id: api/aggregate
  summary: Aggregate constructor used for building aggregation pipelines
  description: "# Aggregate\n\n### Aggregate()\n\n##### Parameters:\n\n- `[pipeline]` «Array» aggregation pipeline as an array of objects\n- `[model]` «Model» the model to use with this aggregate.\n\n##### See:\n\n- [MongoDB](https://www.mongodb.com/docs/manual/applications/aggregation/)\n- [driver](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#aggregate)\n\nAggregate constructor used for building aggregation pipelines. Do not instantiate this class directly, use [Model.aggregate()](model#Model.aggregate()) instead.\n\n#### [Example:](#example)\n\n``` javascript\nconst aggregate = Model.aggregate([\n  { $project: { a: 1, b: 1 } },\n  { $skip: 5 }\n]);\n\nModel.\n  aggregate([{ $match: { age: { $gte: 21 }}}]).\n  unwind('tags').\n  exec();\n```\n\n#### [Note:](#note)\n\n- The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n\n- Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\n\n  new Aggregate(\\[{ $match: { \\_id: '00000000000000000000000a' } }\\]); // Do this instead to cast to an ObjectId new Aggregate(\\[{ $match: { \\_id: new mongoose.Types.ObjectId('00000000000000000000000a') } }\\]);\n\n### Aggregate.prototype.addFields()\n\n##### Parameters:\n\n- `arg` «Object» field specification\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$addFields](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/)\n\nAppends a new $addFields operator to this aggregate pipeline. Requires MongoDB v3.4+ to work\n\n#### [Example:](#example)\n\n``` javascript\n// adding new fields based on existing fields\naggregate.addFields({\n    newField: '$b.nested'\n  , plusTen: { $add: ['$val', 10]}\n  , sub: {\n       name: '$a'\n    }\n})\n\n// etc\naggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n```\n\n### Aggregate.prototype.allowDiskUse()\n\n##### Parameters:\n\n- `value` «Boolean» Should tell server it can use hard drive to store data during aggregation.\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/command/aggregate/)\n\nSets the allowDiskUse option for the aggregation query\n\n#### [Example:](#example)\n\n``` javascript\nawait Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\n```\n\n### Aggregate.prototype.append()\n\n##### Parameters:\n\n- `...ops` «Object\\|Array\\[Object\\]» operator(s) to append. Can either be a spread of objects or a single parameter of a object array.\n\n##### Returns:\n\n- «Aggregate»\n\nAppends new operators to this aggregate pipeline\n\n#### [Example:](#example)\n\n``` javascript\naggregate.append({ $project: { field: 1 }}, { $limit: 2 });\n\n// or pass an array\nconst pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\naggregate.append(pipeline);\n```\n\n### Aggregate.prototype.catch()\n\n##### Parameters:\n\n- `[reject]` «Function»\n\n##### Returns:\n\n- «Promise»\n\nExecutes the aggregation returning a `Promise` which will be resolved with either the doc(s) or rejected with the error. Like [`.then()`](query#Query.prototype.then), but only takes a rejection handler. Compatible with `await`.\n\n### Aggregate.prototype.collation()\n\n##### Parameters:\n\n- `collation` «Object» options\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [mongodb](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/CollationOptions.html)\n\nAdds a collation\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });\n```\n\n### Aggregate.prototype.count()\n\n##### Parameters:\n\n- `fieldName` «String» The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$count](https://www.mongodb.com/docs/manual/reference/operator/aggregation/count)\n\nAppends a new $count operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.count(\"userCount\");\n```\n\n### Aggregate.prototype.cursor()\n\n##### Parameters:\n\n- `options` «Object»\n\n- `[options.batchSize]` «Number» set the cursor batch size\n\n&nbsp;\n\n- `[options.useMongooseAggCursor]` «Boolean» use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\n\n##### Returns:\n\n- «AggregationCursor» cursor representing this aggregation\n\n##### See:\n\n- [mongodb](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html)\n\nSets the `cursor` option and executes this aggregation, returning an aggregation cursor. Cursors are useful if you want to process the results of the aggregation one-at-a-time because the aggregation result is too big to fit into memory.\n\n#### [Example:](#example)\n\n``` javascript\nconst cursor = Model.aggregate(..).cursor({ batchSize: 1000 });\ncursor.eachAsync(function(doc, i) {\n  // use doc\n});\n```\n\n### Aggregate.prototype.densify()\n\n##### Parameters:\n\n- `arg` «Object» $densify operator contents\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$densify](https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/)\n\nAppends a new $densify operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\n aggregate.densify({\n   field: 'timestamp',\n   range: {\n     step: 1,\n     unit: 'hour',\n     bounds: [new Date('2021-05-18T00:00:00.000Z'), new Date('2021-05-18T08:00:00.000Z')]\n   }\n });\n```\n\n### Aggregate.prototype.exec()\n\n##### Returns:\n\n- «Promise»\n\nExecutes the aggregate pipeline on the currently bound Model.\n\n#### [Example:](#example)\n\n``` javascript\nconst result = await aggregate.exec();\n```\n\n### Aggregate.prototype.explain()\n\n##### Parameters:\n\n- `[verbosity]` «String»\n\n##### Returns:\n\n- «Promise»\n\nExecute the aggregation with explain\n\n#### [Example:](#example)\n\n``` javascript\nModel.aggregate(..).explain()\n```\n\n### Aggregate.prototype.facet()\n\n##### Parameters:\n\n- `facet` «Object» options\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [$facet](https://www.mongodb.com/docs/manual/reference/operator/aggregation/facet/)\n\nCombines multiple aggregation pipelines.\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await Model.aggregate().facet({\n  books: [{ groupBy: '$author' }],\n  price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\n});\n\n// Output: { books: [...], price: [{...}, {...}] }\n```\n\n### Aggregate.prototype.fill()\n\n##### Parameters:\n\n- `arg` «Object» $fill operator contents\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$fill](https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/)\n\nAppends a new $fill operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\n aggregate.fill({\n   output: {\n     bootsSold: { value: 0 },\n     sandalsSold: { value: 0 },\n     sneakersSold: { value: 0 }\n   }\n });\n```\n\n### Aggregate.prototype.finally()\n\n##### Parameters:\n\n- `[onFinally]` «Function»\n\n##### Returns:\n\n- «Promise»\n\nExecutes the aggregate returning a `Promise` which will be resolved with `.finally()` chained.\n\nMore about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n\n### Aggregate.prototype.graphLookup()\n\n##### Parameters:\n\n- `options` «Object» to $graphLookup as described in the above link\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$graphLookup](https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup)\n\nAppends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n\nNote that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\n\n#### [Example:](#example)\n\n``` javascript\n // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\n aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\n```\n\n### Aggregate.prototype.group()\n\n##### Parameters:\n\n- `arg` «Object» $group operator contents\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$group](https://www.mongodb.com/docs/manual/reference/aggregation/group/)\n\nAppends a new custom $group operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.group({ _id: \"$department\" });\n```\n\n### Aggregate.prototype.hint()\n\n##### Parameters:\n\n- `value` «Object\\|String» a hint object or the index name\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/command/aggregate/)\n\nSets the hint option for the aggregation query\n\n#### [Example:](#example)\n\n``` javascript\nModel.aggregate(..).hint({ qty: 1, category: 1 }).exec();\n```\n\n### Aggregate.prototype.limit()\n\n##### Parameters:\n\n- `num` «Number» maximum number of records to pass to the next stage\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$limit](https://www.mongodb.com/docs/manual/reference/aggregation/limit/)\n\nAppends a new $limit operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.limit(10);\n```\n\n### Aggregate.prototype.lookup()\n\n##### Parameters:\n\n- `options` «Object» to $lookup as described in the above link\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$lookup](https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/#pipe._S_lookup)\n\nAppends new custom $lookup operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\n```\n\n### Aggregate.prototype.match()\n\n##### Parameters:\n\n- `arg` «Object» $match operator contents\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$match](https://www.mongodb.com/docs/manual/reference/aggregation/match/)\n\nAppends a new custom $match operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\n```\n\n### Aggregate.prototype.model()\n\n##### Parameters:\n\n- `[model]` «Model» Set the model associated with this aggregate. If not provided, returns the already stored model.\n\n##### Returns:\n\n- «Model»\n\nGet/set the model that this aggregation will execute on.\n\n#### [Example:](#example)\n\n``` javascript\nconst aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);\naggregate.model() === MyModel; // true\n\n// Change the model. There's rarely any reason to do this.\naggregate.model(SomeOtherModel);\naggregate.model() === SomeOtherModel; // true\n```\n\n### Aggregate.prototype.near()\n\n##### Parameters:\n\n- `arg` «Object»\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$geoNear](https://www.mongodb.com/docs/manual/reference/aggregation/geoNear/)\n\nAppends a new $geoNear operator to this aggregate pipeline.\n\n#### [Note:](#note)\n\n**MUST** be used as the first operator in the pipeline.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.near({\n  near: { type: 'Point', coordinates: [40.724, -73.997] },\n  distanceField: \"dist.calculated\", // required\n  maxDistance: 0.008,\n  query: { type: \"public\" },\n  includeLocs: \"dist.location\",\n  spherical: true,\n});\n```\n\n### Aggregate.prototype.option()\n\n##### Parameters:\n\n- `options` «Object» keys to merge into current options\n\n&nbsp;\n\n- `[options.maxTimeMS]` «Number» number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n\n&nbsp;\n\n- `[options.allowDiskUse]` «Boolean» boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\n\n&nbsp;\n\n- `[options.collation]` «Object» object see [`Aggregate.prototype.collation()`](#Aggregate.prototype.collation())\n\n&nbsp;\n\n- `[options.session]` «ClientSession» ClientSession see [`Aggregate.prototype.session()`](#Aggregate.prototype.session())\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/command/aggregate/)\n\nLets you set arbitrary options, for middleware or plugins.\n\n#### [Example:](#example)\n\n``` javascript\nconst agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\nagg.options; // `{ allowDiskUse: true }`\n```\n\n### Aggregate.prototype.options\n\n##### Type:\n\n- «property»\n\nContains options passed down to the [aggregate command](https://www.mongodb.com/docs/manual/reference/command/aggregate/). Supported options are:\n\n- [`allowDiskUse`](#Aggregate.prototype.allowDiskUse())\n- `bypassDocumentValidation`\n- [`collation`](#Aggregate.prototype.collation())\n- `comment`\n- [`cursor`](#Aggregate.prototype.cursor())\n- [`explain`](#Aggregate.prototype.explain())\n- `fieldsAsRaw`\n- [`hint`](#Aggregate.prototype.hint())\n- `let`\n- `maxTimeMS`\n- `raw`\n- [`readConcern`](#Aggregate.prototype.readConcern())\n- `readPreference`\n- [`session`](#Aggregate.prototype.session())\n- `writeConcern`\n\n### Aggregate.prototype.pipeline()\n\n##### Returns:\n\n- «Array» The current pipeline similar to the operation that will be executed\n\nReturns the current pipeline\n\n#### [Example:](#example)\n\n``` javascript\nMyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\n```\n\n### Aggregate.prototype.project()\n\n##### Parameters:\n\n- `arg` «Object\\|String» field specification\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [projection](https://www.mongodb.com/docs/manual/reference/aggregation/project/)\n\nAppends a new $project operator to this aggregate pipeline.\n\nMongoose query [selection syntax](query#Query.prototype.select()) is also supported.\n\n#### [Example:](#example)\n\n``` javascript\n// include a, include b, exclude _id\naggregate.project(\"a b -_id\");\n\n// or you may use object notation, useful when\n// you have keys already prefixed with a \"-\"\naggregate.project({a: 1, b: 1, _id: 0});\n\n// reshaping documents\naggregate.project({\n    newField: '$b.nested'\n  , plusTen: { $add: ['$val', 10]}\n  , sub: {\n       name: '$a'\n    }\n})\n\n// etc\naggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n```\n\n### Aggregate.prototype.read()\n\n##### Parameters:\n\n- `pref` «String\\|ReadPreference» one of the listed preference options or their aliases\n- `[tags]` «Array» optional tags for this query. DEPRECATED\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)\n\nSets the readPreference option for the aggregation query.\n\n#### [Example:](#example)\n\n``` javascript\nawait Model.aggregate(pipeline).read('primaryPreferred');\n```\n\n### Aggregate.prototype.readConcern()\n\n##### Parameters:\n\n- `level` «String» one of the listed read concern level or their aliases\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/read-concern/)\n\nSets the readConcern level for the aggregation query.\n\n#### [Example:](#example)\n\n``` javascript\nawait Model.aggregate(pipeline).readConcern('majority');\n```\n\n### Aggregate.prototype.redact()\n\n##### Parameters:\n\n- `expression` «Object» redact options or conditional expression\n- `[thenExpr]` «String\\|Object» true case for the condition\n- `[elseExpr]` «String\\|Object» false case for the condition\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [$redact](https://www.mongodb.com/docs/manual/reference/operator/aggregation/redact/)\n\nAppends a new $redact operator to this aggregate pipeline.\n\nIf 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\n\n#### [Example:](#example)\n\n``` javascript\nawait Model.aggregate(pipeline).redact({\n  $cond: {\n    if: { $eq: [ '$level', 5 ] },\n    then: '$$PRUNE',\n    else: '$$DESCEND'\n  }\n});\n\n// $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\nawait Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');\n```\n\n### Aggregate.prototype.replaceRoot()\n\n##### Parameters:\n\n- `newRoot` «String\\|Object» the field or document which will become the new root document\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$replaceRoot](https://www.mongodb.com/docs/manual/reference/operator/aggregation/replaceRoot)\n\nAppends a new $replaceRoot operator to this aggregate pipeline.\n\nNote that the `$replaceRoot` operator requires field strings to start with '$'. If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'. If you are passing in an object the strings in your expression will not be altered.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.replaceRoot(\"user\");\n\naggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\n```\n\n### Aggregate.prototype.sample()\n\n##### Parameters:\n\n- `size` «Number» number of random documents to pick\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$sample](https://www.mongodb.com/docs/manual/reference/operator/aggregation/sample/#pipe._S_sample)\n\nAppends new custom $sample operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.sample(3); // Add a pipeline that picks 3 random documents\n```\n\n### Aggregate.prototype.search()\n\n##### Parameters:\n\n- `$search` «Object» options\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [$search](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/)\n\nHelper for [Atlas Text Search](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/)'s `$search` stage.\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await Model.aggregate().\n search({\n   text: {\n     query: 'baseball',\n     path: 'plot'\n   }\n });\n\n// Output: [{ plot: '...', title: '...' }]\n```\n\n### Aggregate.prototype.session()\n\n##### Parameters:\n\n- `session` «ClientSession»\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/command/aggregate/)\n\nSets the session for this aggregation. Useful for [transactions](../transactions).\n\n#### [Example:](#example)\n\n``` javascript\nconst session = await Model.startSession();\nawait Model.aggregate(..).session(session);\n```\n\n### Aggregate.prototype.skip()\n\n##### Parameters:\n\n- `num` «Number» number of records to skip before next stage\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$skip](https://www.mongodb.com/docs/manual/reference/aggregation/skip/)\n\nAppends a new $skip operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.skip(10);\n```\n\n### Aggregate.prototype.sort()\n\n##### Parameters:\n\n- `arg` «Object\\|String»\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [$sort](https://www.mongodb.com/docs/manual/reference/aggregation/sort/)\n\nAppends a new $sort operator to this aggregate pipeline.\n\nIf an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n\nIf a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n\n#### [Example:](#example)\n\n``` javascript\n// these are equivalent\naggregate.sort({ field: 'asc', test: -1 });\naggregate.sort('field -test');\n```\n\n### Aggregate.prototype.sortByCount()\n\n##### Parameters:\n\n- `arg` «Object\\|String»\n\n##### Returns:\n\n- «Aggregate» this\n\n##### See:\n\n- [$sortByCount](https://www.mongodb.com/docs/manual/reference/operator/aggregation/sortByCount/)\n\nAppends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name or a pipeline object.\n\nNote that the `$sortByCount` operator requires the new root to start with '$'. Mongoose will prepend '$' if the specified field name doesn't start with '$'.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.sortByCount('users');\naggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\n```\n\n### Aggregate.prototype.then()\n\n##### Parameters:\n\n- `[resolve]` «Function» successCallback\n- `[reject]` «Function» errorCallback\n\n##### Returns:\n\n- «Promise»\n\nProvides a Promise-like `then` function, which will call `.exec` without a callback Compatible with `await`.\n\n#### [Example:](#example)\n\n``` javascript\nModel.aggregate(..).then(successCallback, errorCallback);\n```\n\n### Aggregate.prototype.unionWith()\n\n##### Parameters:\n\n- `options` «Object» to $unionWith query as described in the above link\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$unionWith](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unionWith)\n\nAppends new $unionWith operator to this aggregate pipeline.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });\n```\n\n### Aggregate.prototype.unwind()\n\n##### Parameters:\n\n- `fields` «String\\|Object\\|Array\\[String\\]\\|Array\\[Object\\]» the field(s) to unwind, either as field names or as [objects with options](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [$unwind](https://www.mongodb.com/docs/manual/reference/aggregation/unwind/)\n\nAppends new custom $unwind operator(s) to this aggregate pipeline.\n\nNote that the `$unwind` operator requires the path name to start with '$'. Mongoose will prepend '$' if the specified field doesn't start '$'.\n\n#### [Example:](#example)\n\n``` javascript\naggregate.unwind(\"tags\");\naggregate.unwind(\"a\", \"b\", \"c\");\naggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });\n```\n\n### Aggregate.prototype\\[Symbol.asyncIterator\\]()\n\nReturns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js) You do not need to call this function explicitly, the JavaScript runtime will call it for you.\n\n#### [Example:](#example)\n\n``` javascript\nconst agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\nfor await (const doc of agg) {\n  console.log(doc.name);\n}\n```\n\nNode.js 10.x supports async iterators natively without any flags. You can enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n\n**Note:** This function is not set if `Symbol.asyncIterator` is undefined. If `Symbol.asyncIterator` is undefined, that means your Node.js version does not support async iterators.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/aggregate.html](https://mongoosejs.com/docs/api/aggregate.html)"
- name: Aggregate()
  id: api/aggregate#Aggregate()
  summary: Aggregate constructor used for building aggregation pipelines
  belongs_to: Aggregate
  description: |-
    ### Aggregate()

    ##### Parameters:

    - `[pipeline]`«Array» aggregation pipeline as an array of objects
    - `[model]`«Model» the model to use with this aggregate.

    ##### See:

    -  [MongoDB](https://www.mongodb.com/docs/manual/applications/aggregation/)
    -  [driver](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#aggregate)

    Aggregate constructor used for building aggregation pipelines. Do not instantiate this class directly, use [Model.aggregate()](model#Model.aggregate()) instead.

    #### [Example:](#example)

    ``` javascript
    const aggregate = Model.aggregate([
      { $project: { a: 1, b: 1 } },
      { $skip: 5 }
    ]);

    Model.
      aggregate([{ $match: { age: { $gte: 21 }}}]).
      unwind('tags').
      exec();
    ```

    #### [Note:](#note)

    - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).

    - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database

      new Aggregate(\[{ $match: { \_id: '00000000000000000000000a' } }\]); // Do this instead to cast to an ObjectId new Aggregate(\[{ $match: { \_id: new mongoose.Types.ObjectId('00000000000000000000000a') } }\]);
- name: Aggregate.prototype.addFields()
  id: api/aggregate#Aggregate.prototype.addFields()
  summary: Appends a new $addFields operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.addFields()

    ##### Parameters:

    - `arg`«Object» field specification

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$addFields](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/)

    Appends a new $addFields operator to this aggregate pipeline. Requires MongoDB v3.4+ to work

    #### [Example:](#example)

    ``` javascript
    // adding new fields based on existing fields
    aggregate.addFields({
        newField: '$b.nested'
      , plusTen: { $add: ['$val', 10]}
      , sub: {
           name: '$a'
        }
    })

    // etc
    aggregate.addFields({ salary_k: { $divide: [ "$salary", 1000 ] } });
    ```
- name: Aggregate.prototype.allowDiskUse()
  id: api/aggregate#Aggregate.prototype.allowDiskUse()
  summary: null
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.allowDiskUse()

    ##### Parameters:

    - `value`«Boolean» Should tell server it can use hard drive to store data during aggregation.

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/command/aggregate/)

    Sets the allowDiskUse option for the aggregation query

    #### [Example:](#example)

    ``` javascript
    awaitModel.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);
    ```
- name: Aggregate.prototype.append()
  id: api/aggregate#Aggregate.prototype.append()
  summary: null
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.append()

    ##### Parameters:

    - `...ops`«Object\|Array\[Object\]» operator(s) to append. Can either be a spread of objects or a single parameter of a object array.

    ##### Returns:

    - «Aggregate»

    Appends new operators to this aggregate pipeline

    #### [Example:](#example)

    ``` javascript
    aggregate.append({ $project: { field: 1 }}, { $limit: 2 });

    // or pass an array
    const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];
    aggregate.append(pipeline);
    ```
- name: Aggregate.prototype.catch()
  id: api/aggregate#Aggregate.prototype.catch()
  summary: Executes the aggregation returning a Promise which will be resolved with either the doc(s) or rejected with the error
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.catch()

    ##### Parameters:

    - `[reject]` «Function»

    ##### Returns:

    - «Promise»

    Executes the aggregation returning a `Promise` which will be resolved with either the doc(s) or rejected with the error. Like [`.then()`](query#Query.prototype.then), but only takes a rejection handler. Compatible with `await`.
- name: Aggregate.prototype.collation()
  id: api/aggregate#Aggregate.prototype.collation()
  summary: null
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.collation()

    ##### Parameters:

    - `collation`«Object» options

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [mongodb](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/CollationOptions.html)

    Adds a collation

    #### [Example:](#example)

    ``` javascript
    const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });
    ```
- name: Aggregate.prototype.count()
  id: api/aggregate#Aggregate.prototype.count()
  summary: Appends a new $count operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.count()

    ##### Parameters:

    - `fieldName`«String» The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$count](https://www.mongodb.com/docs/manual/reference/operator/aggregation/count)

    Appends a new $count operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
    aggregate.count("userCount");
    ```
- name: Aggregate.prototype.cursor()
  id: api/aggregate#Aggregate.prototype.cursor()
  summary: Sets the cursor option and executes this aggregation, returning an aggregation cursor
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.cursor()

    ##### Parameters:

    - `options` «Object»

    - `[options.batchSize]`«Number» set the cursor batch size

    &nbsp;

    - `[options.useMongooseAggCursor]`«Boolean» use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)

    ##### Returns:

    - «AggregationCursor» cursor representing this aggregation

    ##### See:

    -  [mongodb](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html)

    Sets the `cursor` option and executes this aggregation, returning an aggregation cursor. Cursors are useful if you want to process the results of the aggregation one-at-a-time because the aggregation result is too big to fit into memory.

    #### [Example:](#example)

    ``` javascript
    const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });
    cursor.eachAsync(function(doc, i) {
      // use doc
    });
    ```
- name: Aggregate.prototype.densify()
  id: api/aggregate#Aggregate.prototype.densify()
  summary: Appends a new $densify operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.densify()

    ##### Parameters:

    - `arg`«Object» $densify operator contents

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$densify](https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/)

    Appends a new $densify operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
     aggregate.densify({
       field: 'timestamp',
       range: {
         step: 1,
         unit: 'hour',
         bounds: [new Date('2021-05-18T00:00:00.000Z'), new Date('2021-05-18T08:00:00.000Z')]
       }
     });
    ```
- name: Aggregate.prototype.exec()
  id: api/aggregate#Aggregate.prototype.exec()
  summary: Executes the aggregate pipeline on the currently bound Model
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.exec()

    ##### Returns:

    - «Promise»

    Executes the aggregate pipeline on the currently bound Model.

    #### [Example:](#example)

    ``` javascript
    const result = await aggregate.exec();
    ```
- name: Aggregate.prototype.explain()
  id: api/aggregate#Aggregate.prototype.explain()
  summary: null
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.explain()

    ##### Parameters:

    - `[verbosity]` «String»

    ##### Returns:

    - «Promise»

    Execute the aggregation with explain

    #### [Example:](#example)

    ``` javascript
    Model.aggregate(..).explain()
    ```
- name: Aggregate.prototype.facet()
  id: api/aggregate#Aggregate.prototype.facet()
  summary: Combines multiple aggregation pipelines
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.facet()

    ##### Parameters:

    - `facet`«Object» options

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [$facet](https://www.mongodb.com/docs/manual/reference/operator/aggregation/facet/)

    Combines multiple aggregation pipelines.

    #### [Example:](#example)

    ``` javascript
    const res = await Model.aggregate().facet({
      books: [{ groupBy: '$author' }],
      price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]
    });

    // Output: { books: [...], price: [{...}, {...}] }
    ```
- name: Aggregate.prototype.fill()
  id: api/aggregate#Aggregate.prototype.fill()
  summary: Appends a new $fill operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.fill()

    ##### Parameters:

    - `arg`«Object» $fill operator contents

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$fill](https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/)

    Appends a new $fill operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
     aggregate.fill({
       output: {
         bootsSold: { value: 0 },
         sandalsSold: { value: 0 },
         sneakersSold: { value: 0 }
       }
     });
    ```
- name: Aggregate.prototype.finally()
  id: api/aggregate#Aggregate.prototype.finally()
  summary: Executes the aggregate returning a Promise which will be resolved with .finally() chained
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.finally()

    ##### Parameters:

    - `[onFinally]` «Function»

    ##### Returns:

    - «Promise»

    Executes the aggregate returning a `Promise` which will be resolved with `.finally()` chained.

    More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).
- name: Aggregate.prototype.graphLookup()
  id: api/aggregate#Aggregate.prototype.graphLookup()
  summary: Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.graphLookup()

    ##### Parameters:

    - `options`«Object» to $graphLookup as described in the above link

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$graphLookup](https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup)

    Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.

    Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.

    #### [Example:](#example)

    ``` javascript
    // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`
     aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites
    ```
- name: Aggregate.prototype.group()
  id: api/aggregate#Aggregate.prototype.group()
  summary: Appends a new custom $group operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.group()

    ##### Parameters:

    - `arg`«Object» $group operator contents

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$group](https://www.mongodb.com/docs/manual/reference/aggregation/group/)

    Appends a new custom $group operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
    aggregate.group({ _id: "$department" });
    ```
- name: Aggregate.prototype.hint()
  id: api/aggregate#Aggregate.prototype.hint()
  summary: null
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.hint()

    ##### Parameters:

    - `value`«Object\|String» a hint object or the index name

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/command/aggregate/)

    Sets the hint option for the aggregation query

    #### [Example:](#example)

    ``` javascript
    Model.aggregate(..).hint({ qty: 1, category: 1 }).exec();
    ```
- name: Aggregate.prototype.limit()
  id: api/aggregate#Aggregate.prototype.limit()
  summary: Appends a new $limit operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.limit()

    ##### Parameters:

    - `num`«Number» maximum number of records to pass to the next stage

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$limit](https://www.mongodb.com/docs/manual/reference/aggregation/limit/)

    Appends a new $limit operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
    aggregate.limit(10);
    ```
- name: Aggregate.prototype.lookup()
  id: api/aggregate#Aggregate.prototype.lookup()
  summary: Appends new custom $lookup operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.lookup()

    ##### Parameters:

    - `options`«Object» to $lookup as described in the above link

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$lookup](https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/#pipe._S_lookup)

    Appends new custom $lookup operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
    aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });
    ```
- name: Aggregate.prototype.match()
  id: api/aggregate#Aggregate.prototype.match()
  summary: Appends a new custom $match operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.match()

    ##### Parameters:

    - `arg`«Object» $match operator contents

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$match](https://www.mongodb.com/docs/manual/reference/aggregation/match/)

    Appends a new custom $match operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
    aggregate.match({ department: { $in: [ "sales", "engineering" ] } });
    ```
- name: Aggregate.prototype.model()
  id: api/aggregate#Aggregate.prototype.model()
  summary: Get/set the model that this aggregation will execute on
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.model()

    ##### Parameters:

    - `[model]`«Model» Set the model associated with this aggregate. If not provided, returns the already stored model.

    ##### Returns:

    - «Model»

    Get/set the model that this aggregation will execute on.

    #### [Example:](#example)

    ``` javascript
    const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);
    aggregate.model() === MyModel; // true

    // Change the model. There's rarely any reason to do this.
    aggregate.model(SomeOtherModel);
    aggregate.model() === SomeOtherModel; // true
    ```
- name: Aggregate.prototype.near()
  id: api/aggregate#Aggregate.prototype.near()
  summary: Appends a new $geoNear operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.near()

    ##### Parameters:

    - `arg` «Object»

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$geoNear](https://www.mongodb.com/docs/manual/reference/aggregation/geoNear/)

    Appends a new $geoNear operator to this aggregate pipeline.

    #### [Note:](#note)

    **MUST** be used as the first operator in the pipeline.

    #### [Example:](#example)

    ``` javascript
    aggregate.near({
      near: { type: 'Point', coordinates: [40.724, -73.997] },
      distanceField: "dist.calculated", // required
      maxDistance: 0.008,
      query: { type: "public" },
      includeLocs: "dist.location",
      spherical: true,
    });
    ```
- name: Aggregate.prototype.option()
  id: api/aggregate#Aggregate.prototype.option()
  summary: Lets you set arbitrary options, for middleware or plugins
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.option()

    ##### Parameters:

    - `options`«Object» keys to merge into current options

    &nbsp;

    - `[options.maxTimeMS]`«Number» number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)

    &nbsp;

    - `[options.allowDiskUse]`«Boolean» boolean if true, the MongoDB server will use the hard drive to store data during this aggregation

    &nbsp;

    - `[options.collation]`«Object» object see [`Aggregate.prototype.collation()`](#Aggregate.prototype.collation())

    &nbsp;

    - `[options.session]`«ClientSession» ClientSession see [`Aggregate.prototype.session()`](#Aggregate.prototype.session())

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/command/aggregate/)

    Lets you set arbitrary options, for middleware or plugins.

    #### [Example:](#example)

    ``` javascript
    const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option
    agg.options; // `{ allowDiskUse: true }`
    ```
- name: Aggregate.prototype.options
  id: api/aggregate#Aggregate.prototype.options
  summary: Contains options passed down to the aggregate command
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.options

    ##### Type:

    - «property»

    Contains options passed down to the [aggregate command](https://www.mongodb.com/docs/manual/reference/command/aggregate/). Supported options are:

    - [`allowDiskUse`](#Aggregate.prototype.allowDiskUse())
    - `bypassDocumentValidation`
    - [`collation`](#Aggregate.prototype.collation())
    - `comment`
    - [`cursor`](#Aggregate.prototype.cursor())
    - [`explain`](#Aggregate.prototype.explain())
    - `fieldsAsRaw`
    - [`hint`](#Aggregate.prototype.hint())
    - `let`
    - `maxTimeMS`
    - `raw`
    - [`readConcern`](#Aggregate.prototype.readConcern())
    - `readPreference`
    - [`session`](#Aggregate.prototype.session())
    - `writeConcern`
- name: Aggregate.prototype.pipeline()
  id: api/aggregate#Aggregate.prototype.pipeline()
  summary: null
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.pipeline()

    ##### Returns:

    - «Array» The current pipeline similar to the operation that will be executed

    Returns the current pipeline

    #### [Example:](#example)

    ``` javascript
    MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]
    ```
- name: Aggregate.prototype.project()
  id: api/aggregate#Aggregate.prototype.project()
  summary: Appends a new $project operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.project()

    ##### Parameters:

    - `arg`«Object\|String» field specification

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [projection](https://www.mongodb.com/docs/manual/reference/aggregation/project/)

    Appends a new $project operator to this aggregate pipeline.

    Mongoose query [selection syntax](query#Query.prototype.select()) is also supported.

    #### [Example:](#example)

    ``` javascript
    // include a, include b, exclude _id
    aggregate.project("a b -_id");

    // or you may use object notation, useful when
    // you have keys already prefixed with a "-"
    aggregate.project({a: 1, b: 1, _id: 0});

    // reshaping documents
    aggregate.project({
        newField: '$b.nested'
      , plusTen: { $add: ['$val', 10]}
      , sub: {
           name: '$a'
        }
    })

    // etc
    aggregate.project({ salary_k: { $divide: [ "$salary", 1000 ] } });
    ```
- name: Aggregate.prototype.read()
  id: api/aggregate#Aggregate.prototype.read()
  summary: Sets the readPreference option for the aggregation query
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.read()

    ##### Parameters:

    - `pref`«String\|ReadPreference» one of the listed preference options or their aliases
    - `[tags]`«Array» optional tags for this query. DEPRECATED

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)

    Sets the readPreference option for the aggregation query.

    #### [Example:](#example)

    ``` javascript
    awaitModel.aggregate(pipeline).read('primaryPreferred');
    ```
- name: Aggregate.prototype.readConcern()
  id: api/aggregate#Aggregate.prototype.readConcern()
  summary: Sets the readConcern level for the aggregation query
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.readConcern()

    ##### Parameters:

    - `level`«String» one of the listed read concern level or their aliases

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/read-concern/)

    Sets the readConcern level for the aggregation query.

    #### [Example:](#example)

    ``` javascript
    awaitModel.aggregate(pipeline).readConcern('majority');
    ```
- name: Aggregate.prototype.redact()
  id: api/aggregate#Aggregate.prototype.redact()
  summary: Appends a new $redact operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.redact()

    ##### Parameters:

    - `expression`«Object» redact options or conditional expression
    - `[thenExpr]`«String\|Object» true case for the condition
    - `[elseExpr]`«String\|Object» false case for the condition

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [$redact](https://www.mongodb.com/docs/manual/reference/operator/aggregation/redact/)

    Appends a new $redact operator to this aggregate pipeline.

    If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.

    #### [Example:](#example)

    ``` javascript
    awaitModel.aggregate(pipeline).redact({
      $cond: {
        if: { $eq: [ '$level', 5 ] },
        then: '$$PRUNE',
        else: '$$DESCEND'
      }
    });

    // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose
    await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');
    ```
- name: Aggregate.prototype.replaceRoot()
  id: api/aggregate#Aggregate.prototype.replaceRoot()
  summary: Appends a new $replaceRoot operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.replaceRoot()

    ##### Parameters:

    - `newRoot`«String\|Object» the field or document which will become the new root document

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$replaceRoot](https://www.mongodb.com/docs/manual/reference/operator/aggregation/replaceRoot)

    Appends a new $replaceRoot operator to this aggregate pipeline.

    Note that the `$replaceRoot` operator requires field strings to start with '$'. If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'. If you are passing in an object the strings in your expression will not be altered.

    #### [Example:](#example)

    ``` javascript
    aggregate.replaceRoot("user");

    aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });
    ```
- name: Aggregate.prototype.sample()
  id: api/aggregate#Aggregate.prototype.sample()
  summary: Appends new custom $sample operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.sample()

    ##### Parameters:

    - `size`«Number» number of random documents to pick

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$sample](https://www.mongodb.com/docs/manual/reference/operator/aggregation/sample/#pipe._S_sample)

    Appends new custom $sample operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
    aggregate.sample(3); // Add a pipeline that picks 3 random documents
    ```
- name: Aggregate.prototype.search()
  id: api/aggregate#Aggregate.prototype.search()
  summary: Helper for Atlas Text Search's $search stage
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.search()

    ##### Parameters:

    - `$search`«Object» options

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [$search](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/)

    Helper for [Atlas Text Search](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/)'s `$search` stage.

    #### [Example:](#example)

    ``` javascript
    const res = await Model.aggregate().
     search({
       text: {
         query: 'baseball',
         path: 'plot'
       }
     });

    // Output: [{ plot: '...', title: '...' }]
    ```
- name: Aggregate.prototype.session()
  id: api/aggregate#Aggregate.prototype.session()
  summary: Sets the session for this aggregation
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.session()

    ##### Parameters:

    - `session` «ClientSession»

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/command/aggregate/)

    Sets the session for this aggregation. Useful for [transactions](../transactions).

    #### [Example:](#example)

    ``` javascript
    const session = await Model.startSession();
    await Model.aggregate(..).session(session);
    ```
- name: Aggregate.prototype.skip()
  id: api/aggregate#Aggregate.prototype.skip()
  summary: Appends a new $skip operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.skip()

    ##### Parameters:

    - `num`«Number» number of records to skip before next stage

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$skip](https://www.mongodb.com/docs/manual/reference/aggregation/skip/)

    Appends a new $skip operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
    aggregate.skip(10);
    ```
- name: Aggregate.prototype.sort()
  id: api/aggregate#Aggregate.prototype.sort()
  summary: Appends a new $sort operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.sort()

    ##### Parameters:

    - `arg` «Object\|String»

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [$sort](https://www.mongodb.com/docs/manual/reference/aggregation/sort/)

    Appends a new $sort operator to this aggregate pipeline.

    If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.

    If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.

    #### [Example:](#example)

    ``` javascript
    // these are equivalent
    aggregate.sort({ field: 'asc', test: -1 });
    aggregate.sort('field -test');
    ```
- name: Aggregate.prototype.sortByCount()
  id: api/aggregate#Aggregate.prototype.sortByCount()
  summary: Appends a new $sortByCount operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.sortByCount()

    ##### Parameters:

    - `arg` «Object\|String»

    ##### Returns:

    - «Aggregate» this

    ##### See:

    -  [$sortByCount](https://www.mongodb.com/docs/manual/reference/operator/aggregation/sortByCount/)

    Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name or a pipeline object.

    Note that the `$sortByCount` operator requires the new root to start with '$'. Mongoose will prepend '$' if the specified field name doesn't start with '$'.

    #### [Example:](#example)

    ``` javascript
    aggregate.sortByCount('users');
    aggregate.sortByCount({ $mergeObjects: [ "$employee", "$business" ] })
    ```
- name: Aggregate.prototype.then()
  id: api/aggregate#Aggregate.prototype.then()
  summary: Provides a Promise-like then function, which will call .exec without a callback Compatible with await
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.then()

    ##### Parameters:

    - `[resolve]`«Function» successCallback
    - `[reject]`«Function» errorCallback

    ##### Returns:

    - «Promise»

    Provides a Promise-like `then` function, which will call `.exec` without a callback Compatible with `await`.

    #### [Example:](#example)

    ``` javascript
    Model.aggregate(..).then(successCallback, errorCallback);
    ```
- name: Aggregate.prototype.unionWith()
  id: api/aggregate#Aggregate.prototype.unionWith()
  summary: Appends new $unionWith operator to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.unionWith()

    ##### Parameters:

    - `options`«Object» to $unionWith query as described in the above link

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$unionWith](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unionWith)

    Appends new $unionWith operator to this aggregate pipeline.

    #### [Example:](#example)

    ``` javascript
    aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });
    ```
- name: Aggregate.prototype.unwind()
  id: api/aggregate#Aggregate.prototype.unwind()
  summary: Appends new custom $unwind operator(s) to this aggregate pipeline
  belongs_to: Aggregate
  description: |-
    ### Aggregate.prototype.unwind()

    ##### Parameters:

    - `fields`«String\|Object\|Array\[String\]\|Array\[Object\]» the field(s) to unwind, either as field names or as [objects with options](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [$unwind](https://www.mongodb.com/docs/manual/reference/aggregation/unwind/)

    Appends new custom $unwind operator(s) to this aggregate pipeline.

    Note that the `$unwind` operator requires the path name to start with '$'. Mongoose will prepend '$' if the specified field doesn't start '$'.

    #### [Example:](#example)

    ``` javascript
    aggregate.unwind("tags");
    aggregate.unwind("a", "b", "c");
    aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });
    ```
- name: Aggregate.prototype[Symbol.asyncIterator]()
  id: api/aggregate#Aggregate.prototype[Symbol.asyncIterator]()
  summary: Returns an asyncIterator for use with for/await/of loops You do not need to call this function explicitly, the JavaScript runtime will call it for you
  belongs_to: Aggregate
  description: "### Aggregate.prototype\\[Symbol.asyncIterator\\]()\n\nReturns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js) You do not need to call this function explicitly, the JavaScript runtime will call it for you.\n\n#### [Example:](#example)\n\n``` javascript\nconst agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\nfor await (const doc of agg) {\n  console.log(doc.name);\n}\n```\n\nNode.js 10.x supports async iterators natively without any flags. You can enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n\n**Note:** This function is not set if `Symbol.asyncIterator` is undefined. If `Symbol.asyncIterator` is undefined, that means your Node.js version does not support async iterators.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/aggregate.html](https://mongoosejs.com/docs/api/aggregate.html)"
- name: AggregationCursor
  id: api/aggregationcursor
  summary: An AggregationCursor is a concurrency primitive for processing aggregation results one document at a time
  description: "# AggregationCursor\n\n### AggregationCursor()\n\n##### Parameters:\n\n- `agg` «Aggregate»\n\n##### Inherits:\n\n- [«Readable»](https://nodejs.org/api/stream.html#class-streamreadable)\n\nAn AggregationCursor is a concurrency primitive for processing aggregation results one document at a time. It is analogous to QueryCursor.\n\nAn AggregationCursor fulfills the Node.js streams3 API, in addition to several other mechanisms for loading documents from MongoDB one at a time.\n\nCreating an AggregationCursor executes the model's pre aggregate hooks, but **not** the model's post aggregate hooks.\n\nUnless you're an advanced user, do **not** instantiate this class directly. Use [`Aggregate#cursor()`](aggregate#Aggregate.prototype.cursor()) instead.\n\n### AggregationCursor.prototype.addCursorFlag()\n\n##### Parameters:\n\n- `flag` «String»\n- `value` «Boolean»\n\n##### Returns:\n\n- «AggregationCursor» this\n\nAdds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag). Useful for setting the `noCursorTimeout` and `tailable` flags.\n\n### AggregationCursor.prototype.close()\n\n##### Parameters:\n\n- `callback` «Function»\n\n##### Returns:\n\n- «Promise»\n\n##### See:\n\n- [AggregationCursor.close](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close)\n\nMarks this cursor as closed. Will stop streaming and subsequent calls to `next()` will error.\n\n### AggregationCursor.prototype.eachAsync()\n\n##### Parameters:\n\n- `fn` «Function»\n- `[options]` «Object»\n\n- `[options.parallel]` «Number» the number of promises to execute in parallel. Defaults to 1.\n\n&nbsp;\n\n- `[callback]` «Function» executed when all docs have been processed\n\n##### Returns:\n\n- «Promise»\n\nExecute `fn` for every document in the cursor. If `fn` returns a promise, will wait for the promise to resolve before iterating on to the next one. Returns a promise that resolves when done.\n\n### AggregationCursor.prototype.map()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «AggregationCursor»\n\nRegisters a transform function which subsequently maps documents retrieved via the streams interface or `.next()`\n\n#### [Example:](#example)\n\n``` javascript\n// Map documents returned by `data` events\nThing.\n  find({ name: /^hello/ }).\n  cursor().\n  map(function (doc) {\n   doc.foo = \"bar\";\n   return doc;\n  })\n  on('data', function(doc) { console.log(doc.foo); });\n\n// Or map documents returned by `.next()`\nconst cursor = Thing.find({ name: /^hello/ }).\n  cursor().\n  map(function (doc) {\n    doc.foo = \"bar\";\n    return doc;\n  });\ncursor.next(function(error, doc) {\n  console.log(doc.foo);\n});\n```\n\n### AggregationCursor.prototype.next()\n\n##### Returns:\n\n- «Promise»\n\nGet the next document from this cursor. Will return `null` when there are no documents left.\n\n### AggregationCursor.prototype\\[Symbol.asyncIterator\\]()\n\nReturns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js) You do not need to call this function explicitly, the JavaScript runtime will call it for you.\n\n#### [Example:](#example)\n\n``` javascript\n// Async iterator without explicitly calling `cursor()`. Mongoose still\n// creates an AggregationCursor instance internally.\nconst agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\nfor await (const doc of agg) {\n  console.log(doc.name);\n}\n\n// You can also use an AggregationCursor instance for async iteration\nconst cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\nfor await (const doc of cursor) {\n  console.log(doc.name);\n}\n```\n\nNode.js 10.x supports async iterators natively without any flags. You can enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n\n**Note:** This function is not set if `Symbol.asyncIterator` is undefined. If `Symbol.asyncIterator` is undefined, that means your Node.js version does not support async iterators.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/aggregationcursor.html](https://mongoosejs.com/docs/api/aggregationcursor.html)"
- name: AggregationCursor()
  id: api/aggregationcursor#AggregationCursor()
  summary: An AggregationCursor is a concurrency primitive for processing aggregation results one document at a time
  belongs_to: AggregationCursor
  description: |-
    ### AggregationCursor()

    ##### Parameters:

    - `agg` «Aggregate»

    ##### Inherits:

    -  [«Readable»](https://nodejs.org/api/stream.html#class-streamreadable)

    An AggregationCursor is a concurrency primitive for processing aggregation results one document at a time. It is analogous to QueryCursor.

    An AggregationCursor fulfills the Node.js streams3 API, in addition to several other mechanisms for loading documents from MongoDB one at a time.

    Creating an AggregationCursor executes the model's pre aggregate hooks, but **not** the model's post aggregate hooks.

    Unless you're an advanced user, do **not** instantiate this class directly. Use [`Aggregate#cursor()`](aggregate#Aggregate.prototype.cursor()) instead.
- name: AggregationCursor.prototype.addCursorFlag()
  id: api/aggregationcursor#AggregationCursor.prototype.addCursorFlag()
  summary: Adds a cursor flag
  belongs_to: AggregationCursor
  description: |-
    ### AggregationCursor.prototype.addCursorFlag()

    ##### Parameters:

    - `flag` «String»
    - `value` «Boolean»

    ##### Returns:

    - «AggregationCursor» this

    Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag). Useful for setting the `noCursorTimeout` and `tailable` flags.
- name: AggregationCursor.prototype.close()
  id: api/aggregationcursor#AggregationCursor.prototype.close()
  summary: Marks this cursor as closed
  belongs_to: AggregationCursor
  description: |-
    ### AggregationCursor.prototype.close()

    ##### Parameters:

    - `callback` «Function»

    ##### Returns:

    - «Promise»

    ##### See:

    -  [AggregationCursor.close](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close)

    Marks this cursor as closed. Will stop streaming and subsequent calls to `next()` will error.
- name: AggregationCursor.prototype.eachAsync()
  id: api/aggregationcursor#AggregationCursor.prototype.eachAsync()
  summary: '[options.parallel]«Number» the number of promises to execute in parallel'
  belongs_to: AggregationCursor
  description: |-
    ### AggregationCursor.prototype.eachAsync()

    ##### Parameters:

    - `fn` «Function»
    - `[options]` «Object»

    - `[options.parallel]`«Number» the number of promises to execute in parallel. Defaults to 1.

    &nbsp;

    - `[callback]`«Function» executed when all docs have been processed

    ##### Returns:

    - «Promise»

    Execute `fn` for every document in the cursor. If `fn` returns a promise, will wait for the promise to resolve before iterating on to the next one. Returns a promise that resolves when done.
- name: AggregationCursor.prototype.map()
  id: api/aggregationcursor#AggregationCursor.prototype.map()
  summary: null
  belongs_to: AggregationCursor
  description: |-
    ### AggregationCursor.prototype.map()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «AggregationCursor»

    Registers a transform function which subsequently maps documents retrieved via the streams interface or `.next()`

    #### [Example:](#example)

    ``` javascript
    // Map documents returned by `data` eventsThing.
      find({ name: /^hello/ }).
      cursor().
      map(function (doc) {
       doc.foo = "bar";
       return doc;
      })
      on('data', function(doc) { console.log(doc.foo); });

    // Or map documents returned by `.next()`
    const cursor = Thing.find({ name: /^hello/ }).
      cursor().
      map(function (doc) {
        doc.foo = "bar";
        return doc;
      });
    cursor.next(function(error, doc) {
      console.log(doc.foo);
    });
    ```
- name: AggregationCursor.prototype.next()
  id: api/aggregationcursor#AggregationCursor.prototype.next()
  summary: Get the next document from this cursor
  belongs_to: AggregationCursor
  description: |-
    ### AggregationCursor.prototype.next()

    ##### Returns:

    - «Promise»

    Get the next document from this cursor. Will return `null` when there are no documents left.
- name: AggregationCursor.prototype[Symbol.asyncIterator]()
  id: api/aggregationcursor#AggregationCursor.prototype[Symbol.asyncIterator]()
  summary: Returns an asyncIterator for use with for/await/of loops You do not need to call this function explicitly, the JavaScript runtime will call it for you
  belongs_to: AggregationCursor
  description: "### AggregationCursor.prototype\\[Symbol.asyncIterator\\]()\n\nReturns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js) You do not need to call this function explicitly, the JavaScript runtime will call it for you.\n\n#### [Example:](#example)\n\n``` javascript\n// Async iterator without explicitly calling `cursor()`. Mongoose still// creates an AggregationCursor instance internally.const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\nfor await (const doc of agg) {\n  console.log(doc.name);\n}\n\n// You can also use an AggregationCursor instance for async iteration\nconst cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\nfor await (const doc of cursor) {\n  console.log(doc.name);\n}\n```\n\nNode.js 10.x supports async iterators natively without any flags. You can enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n\n**Note:** This function is not set if `Symbol.asyncIterator` is undefined. If `Symbol.asyncIterator` is undefined, that means your Node.js version does not support async iterators.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/aggregationcursor.html](https://mongoosejs.com/docs/api/aggregationcursor.html)"
- name: Array
  id: api/array
  summary: Pops the array atomically at most one time per document save()
  description: "# Array\n\n### MongooseArray.prototype.$pop()\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/operator/update/pop/)\n\nPops the array atomically at most one time per document `save()`.\n\n#### [NOTE:](#note)\n\n*Calling this multiple times on an array before saving sends the same command as calling it once.* *This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction.*\n\n``` javascript\n doc.array = [1,2,3];\n\n const popped = doc.array.$pop();\n console.log(popped); // 3\n console.log(doc.array); // [1,2]\n\n // no affect\n popped = doc.array.$pop();\n console.log(doc.array); // [1,2]\n\n doc.save(function (err) {\n   if (err) return handleError(err);\n\n   // we saved, now $pop works again\n   popped = doc.array.$pop();\n   console.log(popped); // 2\n   console.log(doc.array); // [1]\n })\n```\n\n### MongooseArray.prototype.$shift()\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/operator/update/pop/)\n\nAtomically shifts the array at most one time per document `save()`.\n\n#### [Note:](#note)\n\n*Calling this multiple times on an array before saving sends the same command as calling it once.* *This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction.*\n\n``` javascript\n doc.array = [1,2,3];\n\n const shifted = doc.array.$shift();\n console.log(shifted); // 1\n console.log(doc.array); // [2,3]\n\n // no affect\n shifted = doc.array.$shift();\n console.log(doc.array); // [2,3]\n\n doc.save(function (err) {\n   if (err) return handleError(err);\n\n   // we saved, now $shift works again\n   shifted = doc.array.$shift();\n   console.log(shifted ); // 2\n   console.log(doc.array); // [3]\n })\n```\n\n### MongooseArray.prototype.addToSet()\n\n##### Parameters:\n\n- `[...args]` «any»\n\n##### Returns:\n\n- «Array» the values that were added\n\nAdds values to the array if not already present.\n\n#### [Example:](#example)\n\n``` javascript\nconsole.log(doc.array) // [2,3,4]\nconst added = doc.array.addToSet(4,5);\nconsole.log(doc.array) // [2,3,4,5]\nconsole.log(added)     // [5]\n```\n\n### MongooseArray.prototype.includes()\n\n##### Parameters:\n\n- `obj` «Object» the item to check\n- `fromIndex` «Number»\n\n##### Returns:\n\n- «Boolean»\n\nReturn whether or not the `obj` is included in the array.\n\n### MongooseArray.prototype.indexOf()\n\n##### Parameters:\n\n- `obj` «Object» the item to look for\n- `fromIndex` «Number»\n\n##### Returns:\n\n- «Number»\n\nReturn the index of `obj` or `-1` if not found.\n\n### MongooseArray.prototype.inspect()\n\nHelper for console.log\n\n### MongooseArray.prototype.nonAtomicPush()\n\n##### Parameters:\n\n- `[...args]` «any»\n\nPushes items to the array non-atomically.\n\n#### [Note:](#note)\n\n*marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.*\n\n### MongooseArray.prototype.pop()\n\n##### See:\n\n- [MongooseArray#$pop](#MongooseArray.prototype.$pop())\n\nWraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n\n#### [Note:](#note)\n\n*marks the entire array as modified which will pass the entire thing to $set potentially overwriting any changes that happen between when you retrieved the object and when you save it.*\n\n### MongooseArray.prototype.pull()\n\n##### Parameters:\n\n- `[...args]` «any»\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/operator/update/pull/)\n\nPulls items from the array atomically. Equality is determined by casting the provided value to an embedded document and comparing using [the `Document.equals()` function.](document#Document.prototype.equals())\n\n#### [Example:](#example)\n\n``` javascript\ndoc.array.pull(ObjectId)\ndoc.array.pull({ _id: 'someId' })\ndoc.array.pull(36)\ndoc.array.pull('tag 1', 'tag 2')\n```\n\nTo remove a document from a subdocument array we may pass an object with a matching `_id`.\n\n``` javascript\ndoc.subdocs.push({ _id: 4815162342 })\ndoc.subdocs.pull({ _id: 4815162342 }) // removed\n```\n\nOr we may passing the \\_id directly and let mongoose take care of it.\n\n``` javascript\ndoc.subdocs.push({ _id: 4815162342 })\ndoc.subdocs.pull(4815162342); // works\n```\n\nThe first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n\n### MongooseArray.prototype.push()\n\n##### Parameters:\n\n- `[...args]` «Object»\n\nWraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = Schema({ nums: [Number] });\nconst Model = mongoose.model('Test', schema);\n\nconst doc = await Model.create({ nums: [3, 4] });\ndoc.nums.push(5); // Add 5 to the end of the array\nawait doc.save();\n\n// You can also pass an object with `$each` as the\n// first parameter to use MongoDB's `$position`\ndoc.nums.push({\n  $each: [1, 2],\n  $position: 0\n});\ndoc.nums; // [1, 2, 3, 4, 5]\n```\n\n### MongooseArray.prototype.remove()\n\n##### See:\n\n- [MongooseArray#pull](#MongooseArray.prototype.pull())\n- [mongodb](https://www.mongodb.com/docs/manual/reference/operator/update/pull/)\n\nAlias of [pull](#MongooseArray.prototype.pull())\n\n### MongooseArray.prototype.set()\n\n##### Returns:\n\n- «Array» this\n\nSets the casted `val` at index `i` and marks the array modified.\n\n#### [Example:](#example)\n\n``` javascript\n// given documents based on the following\nconst Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n\nconst doc = new Doc({ array: [2,3,4] })\n\nconsole.log(doc.array) // [2,3,4]\n\ndoc.array.set(1,\"5\");\nconsole.log(doc.array); // [2,5,4] // properly cast to number\ndoc.save() // the change is saved\n\n// VS not using array#set\ndoc.array[1] = \"5\";\nconsole.log(doc.array); // [2,\"5\",4] // no casting\ndoc.save() // change is not saved\n```\n\n### MongooseArray.prototype.shift()\n\nWraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n\n#### [Example:](#example)\n\n``` javascript\ndoc.array = [2,3];\nconst res = doc.array.shift();\nconsole.log(res) // 2\nconsole.log(doc.array) // [3]\n```\n\n#### [Note:](#note)\n\n*marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.*\n\n### MongooseArray.prototype.sort()\n\n##### See:\n\n- [MasteringJS: Array sort](https://masteringjs.io/tutorials/fundamentals/array-sort)\n\nWraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n\n#### [Note:](#note)\n\n*marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.*\n\n### MongooseArray.prototype.splice()\n\n##### See:\n\n- [MasteringJS: Array splice](https://masteringjs.io/tutorials/fundamentals/array-splice)\n\nWraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n\n#### [Note:](#note)\n\n*marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.*\n\n### MongooseArray.prototype.toObject()\n\n##### Parameters:\n\n- `options` «Object»\n\n##### Returns:\n\n- «Array»\n\nReturns a native js Array.\n\n### MongooseArray.prototype.unshift()\n\nWraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n\n#### [Note:](#note)\n\n*marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwriting any changes that happen between when you retrieved the object and when you save it.*\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/array.html](https://mongoosejs.com/docs/api/array.html)"
- name: Arrays
  id: schematypes#arrays
  summary: Mongoose supports arrays of SchemaTypes and arrays of subdocuments
  belongs_to: SchemaTypes
  description: |-
    ### Arrays

    Mongoose supports arrays of [SchemaTypes](api/schema#schema_Schema-Types) and arrays of [subdocuments](subdocs). Arrays of SchemaTypes are also called *primitive arrays*, and arrays of subdocuments are also called *document arrays*.

    ``` javascript
    constToySchema = new Schema({ name: String });
    const ToyBoxSchema = new Schema({
      toys: [ToySchema],
      buffers: [Buffer],
      strings: [String],
      numbers: [Number]
      // ... etc
    });
    ```

    Arrays are special because they implicitly have a default value of `[]` (empty array).

    ``` javascript
    constToyBox = mongoose.model('ToyBox', ToyBoxSchema);
    console.log((new ToyBox()).toys); // []
    ```

    To overwrite this default, you need to set the default value to `undefined`

    ``` javascript
    constToyBoxSchema = new Schema({
      toys: {
        type: [ToySchema],
        default: undefined
      }
    });
    ```

    Note: specifying an empty array is equivalent to `Mixed`. The following all create arrays of `Mixed`:

    ``` javascript
    constEmpty1 = new Schema({ any: [] });
    const Empty2 = new Schema({ any: Array });
    const Empty3 = new Schema({ any: [Schema.Types.Mixed] });
    const Empty4 = new Schema({ any: [{}] });
    ```
- name: ArraySubdocument
  id: api/arraysubdocument
  summary: Returns this sub-documents parent document
  description: "# ArraySubdocument\n\n### ArraySubdocument.prototype.$parent()\n\nReturns this sub-documents parent document.\n\n### ArraySubdocument.prototype.parentArray()\n\nReturns this subdocument's parent array.\n\n#### [Example:](#example)\n\n``` javascript\nconst Test = mongoose.model('Test', new Schema({\n  docArr: [{ name: String }]\n}));\nconst doc = new Test({ docArr: [{ name: 'test subdoc' }] });\n\ndoc.docArr[0].parentArray() === doc.docArr; // true\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/arraysubdocument.html](https://mongoosejs.com/docs/api/arraysubdocument.html)"
- name: ArraySubdocument.prototype.$parent()
  id: api/arraysubdocument#ArraySubdocument.prototype.$parent()
  summary: Returns this sub-documents parent document
  belongs_to: ArraySubdocument
  description: |-
    ### ArraySubdocument.prototype.$parent()

    Returns this sub-documents parent document.
- name: ArraySubdocument.prototype.parentArray()
  id: api/arraysubdocument#ArraySubdocument.prototype.parentArray()
  summary: Returns this subdocument's parent array
  belongs_to: ArraySubdocument
  description: "### ArraySubdocument.prototype.parentArray()\n\nReturns this subdocument's parent array.\n\n#### [Example:](#example)\n\n``` javascript\nconstTest = mongoose.model('Test', new Schema({\n  docArr: [{ name: String }]\n}));\nconst doc = new Test({ docArr: [{ name: 'test subdoc' }] });\n\ndoc.docArr[0].parentArray() === doc.docArr; // true\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/arraysubdocument.html](https://mongoosejs.com/docs/api/arraysubdocument.html)"
- name: BigInt
  id: schematypes#bigint
  summary: Mongoose supports JavaScript BigInts as a SchemaType
  belongs_to: SchemaTypes
  description: "### BigInt\n\nMongoose supports [JavaScript BigInts](https://thecodebarbarian.com/an-overview-of-bigint-in-node-js.html) as a SchemaType. BigInts are stored as [64-bit integers in MongoDB (BSON type \"long\")](https://www.mongodb.com/docs/manual/reference/bson-types/).\n\n``` javascript\nconst questionSchema = new Schema({\n  answer: BigInt\n});\nconst Question = mongoose.model('Question', questionSchema);\n\nconst question = new Question({ answer: 42n });\ntypeof question.answer; // 'bigint'\n```\n\n## Getters\n\nGetters are like virtuals for paths defined in your schema. For example, let's say you wanted to store user profile pictures as relative paths and then add the hostname in your application. Below is how you would structure your `userSchema`:\n\n``` javascript\nconst root = 'https://s3.amazonaws.com/mybucket';\n\nconst userSchema = new Schema({\n  name: String,\n  picture: {\n    type: String,\n    get: v => `${root}${v}`\n  }\n});\n\nconst User = mongoose.model('User', userSchema);\n\nconst doc = new User({ name: 'Val', picture: '/123.png' });\ndoc.picture; // 'https://s3.amazonaws.com/mybucket/123.png'\ndoc.toObject({ getters: false }).picture; // '/123.png'\n```\n\nGenerally, you only use getters on primitive paths as opposed to arrays or subdocuments. Because getters override what accessing a Mongoose path returns, declaring a getter on an object may remove Mongoose change tracking for that path.\n\n``` javascript\nconst schema = new Schema({\n  arr: [{ url: String }]\n});\n\nconst root = 'https://s3.amazonaws.com/mybucket';\n\n// Bad, don't do this!\nschema.path('arr').get(v => {\n  return v.map(el => Object.assign(el, { url: root + el.url }));\n});\n\n// Later\ndoc.arr.push({ key: String });\ndoc.arr[0]; // 'undefined' because every `doc.arr` creates a new array!\n```\n\nInstead of declaring a getter on the array as shown above, you should declare a getter on the `url` string as shown below. If you need to declare a getter on a nested document or array, be very careful!\n\n``` javascript\nconst schema = new Schema({\n  arr: [{ url: String }]\n});\n\nconst root = 'https://s3.amazonaws.com/mybucket';\n\n// Good, do this instead of declaring a getter on `arr`\nschema.path('arr.0.url').get(v => `${root}${v}`);\n```\n\n## Schemas\n\nTo declare a path as another [schema](guide#definition), set `type` to the sub-schema's instance.\n\nTo set a default value based on the sub-schema's shape, simply set a default value, and the value will be cast based on the sub-schema's definition before being set during document creation.\n\n``` javascript\nconst subSchema = new mongoose.Schema({\n  // some schema definition here\n});\n\nconst schema = new mongoose.Schema({\n  data: {\n    type: subSchema,\n    default: {}\n  }\n});\n```\n\n## Creating Custom Types\n\nMongoose can also be extended with [custom SchemaTypes](customschematypes). Search the [plugins](http://plugins.mongoosejs.io) site for compatible types like [mongoose-long](https://github.com/aheckmann/mongoose-long), [mongoose-int32](https://github.com/vkarpov15/mongoose-int32), and [mongoose-function](https://github.com/aheckmann/mongoose-function).\n\nRead more about creating custom SchemaTypes [here](customschematypes).\n\n## The \\`schema.path()\\` Function\n\nThe `schema.path()` function returns the instantiated schema type for a given path.\n\n``` javascript\nconst sampleSchema = new Schema({ name: { type: String, required: true } });\nconsole.log(sampleSchema.path('name'));\n// Output looks like:\n/**\n * SchemaString {\n *   enumValues: [],\n  *   regExp: null,\n  *   path: 'name',\n  *   instance: 'String',\n  *   validators: ...\n  */\n```\n\nYou can use this function to inspect the schema type for a given path, including what validators it has and what the type is.\n\n## Further Reading\n\n- [An Introduction to Mongoose SchemaTypes](https://masteringjs.io/tutorials/mongoose/schematype)\n- [Mongoose Schema Types](https://kb.objectrocket.com/mongo-db/mongoose-schema-types-1418)\n\n## Next Up\n\nNow that we've covered `SchemaTypes`, let's take a look at [Connections](connections).\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/schematypes.html](https://mongoosejs.com/docs/schematypes.html)"
- name: Boolean
  id: schematypes#booleans
  summary: Booleans in Mongoose are plain JavaScript booleans
  belongs_to: SchemaTypes
  description: |-
    ### Boolean

    Booleans in Mongoose are [plain JavaScript booleans](https://www.w3schools.com/js/js_booleans.asp). By default, Mongoose casts the below values to `true`:

    - `true`
    - `'true'`
    - `1`
    - `'1'`
    - `'yes'`

    Mongoose casts the below values to `false`:

    - `false`
    - `'false'`
    - `0`
    - `'0'`
    - `'no'`

    Any other value causes a [CastError](validation#cast-errors). You can modify what values Mongoose converts to true or false using the `convertToTrue` and `convertToFalse` properties, which are [JavaScript sets](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set).

    ``` javascript
    const M = mongoose.model('Test', new Schema({ b: Boolean }));
    console.log(new M({ b: 'nay' }).b); // undefined

    // Set { false, 'false', 0, '0', 'no' }
    console.log(mongoose.Schema.Types.Boolean.convertToFalse);

    mongoose.Schema.Types.Boolean.convertToFalse.add('nay');
    console.log(new M({ b: 'nay' }).b); // false
    ```
- name: Buffer
  id: api/buffer
  summary: Copies the buffer
  description: "# Buffer\n\n### MongooseBuffer.mixin.copy()\n\n##### Parameters:\n\n- `target` «Buffer»\n\n##### Returns:\n\n- «Number» The number of bytes copied.\n\n##### Type:\n\n- «property»\n\nCopies the buffer.\n\n#### [Note:](#note)\n\n`Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.\n\n### MongooseBuffer.mixin.equals()\n\n##### Parameters:\n\n- `other` «Buffer»\n\n##### Returns:\n\n- «Boolean»\n\nDetermines if this buffer is equals to `other` buffer\n\n### MongooseBuffer.mixin.subtype()\n\n##### Parameters:\n\n- `subtype` «Hex»\n\n##### See:\n\n- [bsonspec](https://bsonspec.org/#/specification)\n\nSets the subtype option and marks the buffer modified.\n\n#### [SubTypes:](#subtypes)\n\n``` javascript\nconst bson = require('bson')\nbson.BSON_BINARY_SUBTYPE_DEFAULT\nbson.BSON_BINARY_SUBTYPE_FUNCTION\nbson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\nbson.BSON_BINARY_SUBTYPE_UUID\nbson.BSON_BINARY_SUBTYPE_MD5\nbson.BSON_BINARY_SUBTYPE_USER_DEFINED\n\ndoc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);\n```\n\n### MongooseBuffer.mixin.toBSON()\n\n##### Returns:\n\n- «Binary»\n\nConverts this buffer for storage in MongoDB, including subtype\n\n### MongooseBuffer.mixin.toObject()\n\n##### Parameters:\n\n- `[subtype]` «Hex»\n\n##### Returns:\n\n- «Binary»\n\n##### See:\n\n- [bsonspec](https://bsonspec.org/#/specification)\n\nConverts this buffer to its Binary type representation.\n\n#### [SubTypes:](#subtypes)\n\n``` javascript\nconst bson = require('bson')\nbson.BSON_BINARY_SUBTYPE_DEFAULT\nbson.BSON_BINARY_SUBTYPE_FUNCTION\nbson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\nbson.BSON_BINARY_SUBTYPE_UUID\nbson.BSON_BINARY_SUBTYPE_MD5\nbson.BSON_BINARY_SUBTYPE_USER_DEFINED\ndoc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);\n```\n\n### MongooseBuffer.mixin.write()\n\n##### Type:\n\n- «property»\n\nWrites the buffer.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/buffer.html](https://mongoosejs.com/docs/api/buffer.html)"
- name: Buffer
  id: schematypes#buffers
  summary: Mongoose will successfully cast the below values to buffers
  belongs_to: SchemaTypes
  description: |-
    ### Buffer

    To declare a path as a Buffer, you may use either the `Buffer` global constructor or the string `'Buffer'`.

    ``` javascript
    const schema1 = new Schema({ binData: Buffer }); // binData will be cast to a Buffer
    const schema2 = new Schema({ binData: 'Buffer' }); // Equivalent

    const Data = mongoose.model('Data', schema2);
    ```

    Mongoose will successfully cast the below values to buffers.

    ``` javascript
    const file1 = new Data({ binData: 'test'}); // {"type":"Buffer","data":[116,101,115,116]}
    const file2 = new Data({ binData: 72987 }); // {"type":"Buffer","data":[27]}
    const file4 = new Data({ binData: { type: 'Buffer', data: [1, 2, 3]}}); // {"type":"Buffer","data":[1,2,3]}
    ```
- name: Connection
  id: api/connection
  summary: For practical reasons, a Connection equals a Db
  description: "# Connection\n\n### Connection()\n\n##### Parameters:\n\n- `base` «Mongoose» a mongoose instance\n\n##### Inherits:\n\n- [«NodeJS EventEmitter»](https://nodejs.org/api/events.html#class-eventemitter)\n\nConnection constructor\n\nFor practical reasons, a Connection equals a Db.\n\n### Connection.prototype.asPromise()\n\n##### Returns:\n\n- «Promise»\n\nReturns a promise that resolves when this connection successfully connects to MongoDB, or rejects if this connection failed to connect.\n\n#### [Example:](#example)\n\n``` javascript\nconst conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n  asPromise();\nconn.readyState; // 1, means Mongoose is connected\n```\n\n### Connection.prototype.client\n\n##### Type:\n\n- «property»\n\nThe MongoClient instance this connection uses to talk to MongoDB. Mongoose automatically sets this property when the connection is opened.\n\n### Connection.prototype.close()\n\n##### Parameters:\n\n- `[force]` «Boolean» optional\n\n##### Returns:\n\n- «Promise»\n\nCloses the connection\n\n### Connection.prototype.collection()\n\n##### Parameters:\n\n- `name` «String» of the collection\n- `[options]` «Object» optional collection options\n\n##### Returns:\n\n- «Collection» collection instance\n\nRetrieves a raw collection instance, creating it if not cached. This method returns a thin wrapper around a \\[MongoDB Node.js driver collection\\]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)). Using a Collection bypasses Mongoose middleware, validation, and casting, letting you use [MongoDB Node.js driver](https://mongodb.github.io/node-mongodb-native/) functionality directly.\n\n### Connection.prototype.collections\n\n##### Type:\n\n- «property»\n\nA hash of the collections associated with this connection\n\n### Connection.prototype.config\n\n##### Type:\n\n- «property»\n\nA hash of the global options that are associated with this connection\n\n### Connection.prototype.createCollection()\n\n##### Parameters:\n\n- `collection` «string» The collection to create\n- `[options]` «Object» see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n\n##### Returns:\n\n- «Promise»\n\nHelper for `createCollection()`. Will explicitly create the given collection with specified options. Used to create [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections/) and [views](https://www.mongodb.com/docs/manual/core/views/) from mongoose.\n\nOptions are passed down without modification to the [MongoDB driver's `createCollection()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n\n### Connection.prototype.createCollections()\n\n##### Parameters:\n\n- `continueOnError` «Boolean» When true, will continue to create collections and create a new error class for the collections that errored.\n\nCalls `createCollection()` on a models in a series.\n\n### Connection.prototype.db\n\n##### Type:\n\n- «property»\n\nThe mongodb.Db instance, set when the connection is opened\n\n### Connection.prototype.deleteModel()\n\n##### Parameters:\n\n- `name` «String\\|RegExp» if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n\n##### Returns:\n\n- «Connection» this\n\nRemoves the model named `name` from this connection, if it exists. You can use this function to clean up any models you created in your tests to prevent OverwriteModelErrors.\n\n#### [Example:](#example)\n\n``` javascript\nconn.model('User', new Schema({ name: String }));\nconsole.log(conn.model('User')); // Model object\nconn.deleteModel('User');\nconsole.log(conn.model('User')); // undefined\n\n// Usually useful in a Mocha `afterEach()` hook\nafterEach(function() {\n  conn.deleteModel(/.+/); // Delete every model\n});\n```\n\n### Connection.prototype.destroy()\n\n##### Parameters:\n\n- `[force]` «Boolean»\n\nDestroy the connection. Similar to [`.close`](#Connection.prototype.close()), but also removes the connection from Mongoose's `connections` list and prevents the connection from ever being re-opened.\n\n### Connection.prototype.dropCollection()\n\n##### Parameters:\n\n- `collection` «string» The collection to delete\n\n##### Returns:\n\n- «Promise»\n\nHelper for `dropCollection()`. Will delete the given collection, including all documents and indexes.\n\n### Connection.prototype.dropDatabase()\n\n##### Returns:\n\n- «Promise»\n\nHelper for `dropDatabase()`. Deletes the given database, including all collections, documents, and indexes.\n\n#### [Example:](#example)\n\n``` javascript\nconst conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n// Deletes the entire 'mydb' database\nawait conn.dropDatabase();\n```\n\n### Connection.prototype.get()\n\n##### Parameters:\n\n- `key` «String»\n\nGets the value of the option `key`. Equivalent to `conn.options[key]`\n\n#### [Example:](#example)\n\n``` javascript\nconn.get('test'); // returns the 'test' value\n```\n\n### Connection.prototype.getClient()\n\n##### Returns:\n\n- «MongoClient»\n\nReturns the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance that this connection uses to talk to MongoDB.\n\n#### [Example:](#example)\n\n``` javascript\nconst conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n  asPromise();\n\nconn.getClient(); // MongoClient { ... }\n```\n\n### Connection.prototype.host\n\n##### Type:\n\n- «property»\n\nThe host name portion of the URI. If multiple hosts, such as a replica set, this will contain the first host name in the URI\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.createConnection('mongodb://127.0.0.1:27017/mydb').host; // \"127.0.0.1\"\n```\n\n### Connection.prototype.id\n\n##### Type:\n\n- «property»\n\nA number identifier for this connection. Used for debugging when you have [multiple connections](../connections#multiple_connections).\n\n#### [Example:](#example)\n\n``` javascript\n// The default connection has `id = 0`\nmongoose.connection.id; // 0\n\n// If you create a new connection, Mongoose increments id\nconst conn = mongoose.createConnection();\nconn.id; // 1\n```\n\n### Connection.prototype.model()\n\n##### Parameters:\n\n- `name` «String\\|Function» the model name or class extending Model\n- `[schema]` «Schema» a schema. necessary when defining a model\n- `[collection]` «String» name of mongodb collection (optional) if not given it will be induced from model name\n- `[options]` «Object»\n\n- `[options.overwriteModels=false]` «Boolean» If true, overwrite existing models with the same name to avoid `OverwriteModelError`\n\n##### Returns:\n\n- «Model» The compiled model\n\n##### See:\n\n- [Mongoose#model](mongoose#Mongoose.prototype.model())\n\nDefines or retrieves a model.\n\n``` javascript\nconst mongoose = require('mongoose');\nconst db = mongoose.createConnection(..);\ndb.model('Venue', new Schema(..));\nconst Ticket = db.model('Ticket', new Schema(..));\nconst Venue = db.model('Venue');\n```\n\n*When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the `utils.toCollectionName` method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.*\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: String }, { collection: 'actor' });\n\n// or\n\nschema.set('collection', 'actor');\n\n// or\n\nconst collectionName = 'actor'\nconst M = conn.model('Actor', schema, collectionName)\n```\n\n### Connection.prototype.modelNames()\n\n##### Returns:\n\n- «Array\\[String\\]»\n\nReturns an array of model names created on this connection.\n\n### Connection.prototype.models\n\n##### Type:\n\n- «property»\n\nA [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing a map from model names to models. Contains all models that have been added to this connection using [`Connection#model()`](#Connection.prototype.model()).\n\n#### [Example:](#example)\n\n``` javascript\nconst conn = mongoose.createConnection();\nconst Test = conn.model('Test', mongoose.Schema({ name: String }));\n\nObject.keys(conn.models).length; // 1\nconn.models.Test === Test; // true\n```\n\n### Connection.prototype.name\n\n##### Type:\n\n- «property»\n\nThe name of the database this connection points to.\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.createConnection('mongodb://127.0.0.1:27017/mydb').name; // \"mydb\"\n```\n\n### Connection.prototype.openUri()\n\n##### Parameters:\n\n- `uri` «String» The URI to connect with.\n- `[options]` «Object» Passed on to [`MongoClient.connect`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#connect-1)\n\n&nbsp;\n\n- `[options.bufferCommands=true]` «Boolean» Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n\n&nbsp;\n\n- `[options.bufferTimeoutMS=10000]` «Number» Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n\n&nbsp;\n\n- `[options.dbName]` «String» The name of the database we want to use. If not provided, use database name from connection string.\n\n&nbsp;\n\n- `[options.user]` «String» username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n\n&nbsp;\n\n- `[options.pass]` «String» password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n\n&nbsp;\n\n- `[options.maxPoolSize=100]` «Number» The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n\n&nbsp;\n\n- `[options.minPoolSize=0]` «Number» The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n\n&nbsp;\n\n- `[options.serverSelectionTimeoutMS]` «Number» If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n\n&nbsp;\n\n- `[options.heartbeatFrequencyMS]` «Number» If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n\n&nbsp;\n\n- `[options.autoIndex=true]` «Boolean» Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n\n&nbsp;\n\n- `[options.promiseLibrary]` «Class» Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n\n&nbsp;\n\n- `[options.socketTimeoutMS=0]` «Number» How long the MongoDB driver will wait before killing a socket due to inactivity *after initial connection*. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n\n&nbsp;\n\n- `[options.family=0]` «Number» Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4`means use IPv4 only,`6`means use IPv6 only,`0\\` means try both.\n\n&nbsp;\n\n- `[options.autoCreate=false]` «Boolean» Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n\nOpens the connection with a URI using `MongoClient.connect()`.\n\n### Connection.prototype.pass\n\n##### Type:\n\n- «property»\n\nThe password specified in the URI\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').pass; // \"psw\"\n```\n\n### Connection.prototype.plugin()\n\n##### Parameters:\n\n- `fn` «Function» plugin callback\n- `[opts]` «Object» optional options\n\n##### Returns:\n\n- «Connection» this\n\n##### See:\n\n- [plugins](../plugins)\n\nDeclares a plugin executed on all schemas you pass to `conn.model()`\n\nEquivalent to calling `.plugin(fn)` on each schema you create.\n\n#### [Example:](#example)\n\n``` javascript\nconst db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\ndb.plugin(() => console.log('Applied'));\ndb.plugins.length; // 1\n\ndb.model('Test', new Schema({})); // Prints \"Applied\"\n```\n\n### Connection.prototype.plugins\n\n##### Type:\n\n- «property»\n\nThe plugins that will be applied to all models created on this connection.\n\n#### [Example:](#example)\n\n``` javascript\nconst db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\ndb.plugin(() => console.log('Applied'));\ndb.plugins.length; // 1\n\ndb.model('Test', new Schema({})); // Prints \"Applied\"\n```\n\n### Connection.prototype.port\n\n##### Type:\n\n- «property»\n\nThe port portion of the URI. If multiple hosts, such as a replica set, this will contain the port from the first host name in the URI.\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.createConnection('mongodb://127.0.0.1:27017/mydb').port; // 27017\n```\n\n### Connection.prototype.readyState\n\n##### Type:\n\n- «property»\n\nConnection ready state\n\n- 0 = disconnected\n- 1 = connected\n- 2 = connecting\n- 3 = disconnecting\n\nEach state change emits its associated event name.\n\n#### [Example:](#example)\n\n``` javascript\nconn.on('connected', callback);\nconn.on('disconnected', callback);\n```\n\n### Connection.prototype.removeDb()\n\n##### Parameters:\n\n- `name` «String» The database name\n\n##### Returns:\n\n- «Connection» this\n\nRemoves the database connection with the given name created with with `useDb()`.\n\nThrows an error if the database connection was not found.\n\n#### [Example:](#example)\n\n``` javascript\n// Connect to `initialdb` first\nconst conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n\n// Creates an un-cached connection to `mydb`\nconst db = conn.useDb('mydb');\n\n// Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\nawait conn.removeDb('mydb');\n```\n\n### Connection.prototype.set()\n\n##### Parameters:\n\n- `key` «String»\n- `val` «Any»\n\nSets the value of the option `key`. Equivalent to `conn.options[key] = val`\n\nSupported options include:\n\n- `maxTimeMS`: Set [`maxTimeMS`](query#Query.prototype.maxTimeMS()) for all queries on this connection.\n- 'debug': If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arugments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n\n#### [Example:](#example)\n\n``` javascript\nconn.set('test', 'foo');\nconn.get('test'); // 'foo'\nconn.options.test; // 'foo'\n```\n\n### Connection.prototype.setClient()\n\n##### Parameters:\n\n- `client` «MongClient» The Client to set to be used.\n\n##### Returns:\n\n- «Connection» this\n\nSet the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to reuse it.\n\n#### [Example:](#example)\n\n``` javascript\nconst client = await mongodb.MongoClient.connect('mongodb://127.0.0.1:27017/test');\n\nconst conn = mongoose.createConnection().setClient(client);\n\nconn.getClient(); // MongoClient { ... }\nconn.readyState; // 1, means 'CONNECTED'\n```\n\n### Connection.prototype.startSession()\n\n##### Parameters:\n\n- `[options]` «Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n\n&nbsp;\n\n- `[options.causalConsistency=true]` «Boolean» set to false to disable causal consistency\n\n##### Returns:\n\n- «Promise\\<ClientSession\\>» promise that resolves to a MongoDB driver `ClientSession`\n\n*Requires MongoDB \\>= 3.6.0.* Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions) for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/), and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n\n#### [Example:](#example)\n\n``` javascript\nconst session = await conn.startSession();\nlet doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\nawait doc.remove();\n// `doc` will always be null, even if reading from a replica set\n// secondary. Without causal consistency, it is possible to\n// get a doc back from the below query if the query reads from a\n// secondary that is experiencing replication lag.\ndoc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n```\n\n### Connection.prototype.syncIndexes()\n\n##### Parameters:\n\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.continueOnError]` «Boolean» `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n\n##### Returns:\n\n- «Promise\\<Object\\>» Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n\nSyncs all the indexes for the models registered with this connection.\n\n### Connection.prototype.transaction()\n\n##### Parameters:\n\n- `fn` «Function» Function to execute in a transaction\n- `[options]` «\\[object Object\\]» Optional settings for the transaction\n\n##### Returns:\n\n- «Promise\\<Any\\>» promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.\n\n*Requires MongoDB \\>= 3.6.0.* Executes the wrapped async function in a transaction. Mongoose will commit the transaction if the async function executes successfully and attempt to retry if there was a retriable error.\n\nCalls the MongoDB driver's [`session.withTransaction()`](https://mongodb.github.io/node-mongodb-native/4.9/classes/ClientSession.html#withTransaction), but also handles resetting Mongoose document state as shown below.\n\n#### [Example:](#example)\n\n``` javascript\nconst doc = new Person({ name: 'Will Riker' });\nawait db.transaction(async function setRank(session) {\n  doc.rank = 'Captain';\n  await doc.save({ session });\n  doc.isNew; // false\n\n  // Throw an error to abort the transaction\n  throw new Error('Oops!');\n},{ readPreference: 'primary' }).catch(() => {});\n\n// true, `transaction()` reset the document's state because the\n// transaction was aborted.\ndoc.isNew;\n```\n\n### Connection.prototype.useDb()\n\n##### Parameters:\n\n- `name` «String» The database name\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.useCache=false]` «Boolean» If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n\n&nbsp;\n\n- `[options.noListener=false]` «Boolean» If true, the connection object will not make the db listen to events on the original connection. See [issue \\#9961](https://github.com/Automattic/mongoose/issues/9961).\n\n##### Returns:\n\n- «Connection» New Connection Object\n\nSwitches to a different database using the same [connection pool](connectionshtml#connection_pools).\n\nReturns a new connection object, with the new db.\n\n#### [Example:](#example)\n\n``` javascript\n// Connect to `initialdb` first\nconst conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n\n// Creates an un-cached connection to `mydb`\nconst db = conn.useDb('mydb');\n// Creates a cached connection to `mydb2`. All calls to `conn.useDb('mydb2', { useCache: true })` will return the same\n// connection instance as opposed to creating a new connection instance\nconst db2 = conn.useDb('mydb2', { useCache: true });\n```\n\n### Connection.prototype.user\n\n##### Type:\n\n- «property»\n\nThe username specified in the URI\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').user; // \"val\"\n```\n\n### Connection.prototype.watch()\n\n##### Parameters:\n\n- `[pipeline]` «Array»\n- `[options]` «Object» passed without changes to [the MongoDB driver's `Db#watch()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#watch)\n\n##### Returns:\n\n- «ChangeStream» mongoose-specific change stream wrapper, inherits from EventEmitter\n\nWatches the entire underlying database for changes. Similar to [`Model.watch()`](model#Model.watch()).\n\nThis function does **not** trigger any middleware. In particular, it does **not** trigger aggregate middleware.\n\nThe ChangeStream object is an event emitter that emits the following events:\n\n- 'change': A change occurred, see below example\n- 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n- 'end': Emitted if the underlying stream is closed\n- 'close': Emitted if the underlying stream is closed\n\n#### [Example:](#example)\n\n``` javascript\nconst User = conn.model('User', new Schema({ name: String }));\n\nconst changeStream = conn.watch().on('change', data => console.log(data));\n\n// Triggers a 'change' event on the change stream.\nawait User.create({ name: 'test' });\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/connection.html](https://mongoosejs.com/docs/api/connection.html)"
- name: Connection()
  id: api/connection#Connection()
  summary: For practical reasons, a Connection equals a Db
  belongs_to: Connection
  description: |-
    ### Connection()

    ##### Parameters:

    - `base`«Mongoose» a mongoose instance

    ##### Inherits:

    -  [«NodeJS EventEmitter»](https://nodejs.org/api/events.html#class-eventemitter)

    Connection constructor

    For practical reasons, a Connection equals a Db.
- name: Connection.prototype.asPromise()
  id: api/connection#Connection.prototype.asPromise()
  summary: Returns a promise that resolves when this connection successfully connects to MongoDB, or rejects if this connection failed to connect
  belongs_to: Connection
  description: |-
    ### Connection.prototype.asPromise()

    ##### Returns:

    - «Promise»

    Returns a promise that resolves when this connection successfully connects to MongoDB, or rejects if this connection failed to connect.

    #### [Example:](#example)

    ``` javascript
    const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').
      asPromise();
    conn.readyState; // 1, means Mongoose is connected
    ```
- name: Connection.prototype.client
  id: api/connection#Connection.prototype.client
  summary: The MongoClient instance this connection uses to talk to MongoDB
  belongs_to: Connection
  description: |-
    ### Connection.prototype.client

    ##### Type:

    - «property»

    The MongoClient instance this connection uses to talk to MongoDB. Mongoose automatically sets this property when the connection is opened.
- name: Connection.prototype.close()
  id: api/connection#Connection.prototype.close()
  summary: null
  belongs_to: Connection
  description: |-
    ### Connection.prototype.close()

    ##### Parameters:

    - `[force]`«Boolean» optional

    ##### Returns:

    - «Promise»

    Closes the connection
- name: Connection.prototype.collection()
  id: api/connection#Connection.prototype.collection()
  summary: Retrieves a raw collection instance, creating it if not cached
  belongs_to: Connection
  description: |-
    ### Connection.prototype.collection()

    ##### Parameters:

    - `name`«String» of the collection
    - `[options]`«Object» optional collection options

    ##### Returns:

    - «Collection» collection instance

    Retrieves a raw collection instance, creating it if not cached. This method returns a thin wrapper around a \[MongoDB Node.js driver collection\]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)). Using a Collection bypasses Mongoose middleware, validation, and casting, letting you use [MongoDB Node.js driver](https://mongodb.github.io/node-mongodb-native/) functionality directly.
- name: Connection.prototype.collections
  id: api/connection#Connection.prototype.collections
  summary: null
  belongs_to: Connection
  description: |-
    ### Connection.prototype.collections

    ##### Type:

    - «property»

    A hash of the collections associated with this connection
- name: Connection.prototype.config
  id: api/connection#Connection.prototype.config
  summary: null
  belongs_to: Connection
  description: |-
    ### Connection.prototype.config

    ##### Type:

    - «property»

    A hash of the global options that are associated with this connection
- name: Connection.prototype.createCollection()
  id: api/connection#Connection.prototype.createCollection()
  summary: Helper for createCollection()
  belongs_to: Connection
  description: |-
    ### Connection.prototype.createCollection()

    ##### Parameters:

    - `collection`«string» The collection to create
    - `[options]`«Object» see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)

    ##### Returns:

    - «Promise»

    Helper for `createCollection()`. Will explicitly create the given collection with specified options. Used to create [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections/) and [views](https://www.mongodb.com/docs/manual/core/views/) from mongoose.

    Options are passed down without modification to the [MongoDB driver's `createCollection()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)
- name: Connection.prototype.createCollections()
  id: api/connection#Connection.prototype.createCollections()
  summary: Calls createCollection() on a models in a series
  belongs_to: Connection
  description: |-
    ### Connection.prototype.createCollections()

    ##### Parameters:

    - `continueOnError`«Boolean» When true, will continue to create collections and create a new error class for the collections that errored.

    Calls `createCollection()` on a models in a series.
- name: Connection.prototype.db
  id: api/connection#Connection.prototype.db
  summary: null
  belongs_to: Connection
  description: |-
    ### Connection.prototype.db

    ##### Type:

    - «property»

    The mongodb.Db instance, set when the connection is opened
- name: Connection.prototype.deleteModel()
  id: api/connection#Connection.prototype.deleteModel()
  summary: Removes the model named name from this connection, if it exists
  belongs_to: Connection
  description: |-
    ### Connection.prototype.deleteModel()

    ##### Parameters:

    - `name`«String\|RegExp» if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.

    ##### Returns:

    - «Connection» this

    Removes the model named `name` from this connection, if it exists. You can use this function to clean up any models you created in your tests to prevent OverwriteModelErrors.

    #### [Example:](#example)

    ``` javascript
    conn.model('User', new Schema({ name: String }));
    console.log(conn.model('User')); // Model object
    conn.deleteModel('User');
    console.log(conn.model('User')); // undefined

    // Usually useful in a Mocha `afterEach()` hook
    afterEach(function() {
      conn.deleteModel(/.+/); // Delete every model
    });
    ```
- name: Connection.prototype.destroy()
  id: api/connection#Connection.prototype.destroy()
  summary: Destroy the connection
  belongs_to: Connection
  description: |-
    ### Connection.prototype.destroy()

    ##### Parameters:

    - `[force]` «Boolean»

    Destroy the connection. Similar to [`.close`](#Connection.prototype.close()), but also removes the connection from Mongoose's `connections` list and prevents the connection from ever being re-opened.
- name: Connection.prototype.dropCollection()
  id: api/connection#Connection.prototype.dropCollection()
  summary: Helper for dropCollection()
  belongs_to: Connection
  description: |-
    ### Connection.prototype.dropCollection()

    ##### Parameters:

    - `collection`«string» The collection to delete

    ##### Returns:

    - «Promise»

    Helper for `dropCollection()`. Will delete the given collection, including all documents and indexes.
- name: Connection.prototype.dropDatabase()
  id: api/connection#Connection.prototype.dropDatabase()
  summary: Helper for dropDatabase()
  belongs_to: Connection
  description: |-
    ### Connection.prototype.dropDatabase()

    ##### Returns:

    - «Promise»

    Helper for `dropDatabase()`. Deletes the given database, including all collections, documents, and indexes.

    #### [Example:](#example)

    ``` javascript
    const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');
    // Deletes the entire 'mydb' database
    await conn.dropDatabase();
    ```
- name: Connection.prototype.get()
  id: api/connection#Connection.prototype.get()
  summary: Gets the value of the option key
  belongs_to: Connection
  description: |-
    ### Connection.prototype.get()

    ##### Parameters:

    - `key` «String»

    Gets the value of the option `key`. Equivalent to `conn.options[key]`

    #### [Example:](#example)

    ``` javascript
    conn.get('test'); // returns the 'test' value
    ```
- name: Connection.prototype.getClient()
  id: api/connection#Connection.prototype.getClient()
  summary: Returns the MongoDB driver MongoClient instance that this connection uses to talk to MongoDB
  belongs_to: Connection
  description: |-
    ### Connection.prototype.getClient()

    ##### Returns:

    - «MongoClient»

    Returns the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance that this connection uses to talk to MongoDB.

    #### [Example:](#example)

    ``` javascript
    const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').
      asPromise();

    conn.getClient(); // MongoClient { ... }
    ```
- name: Connection.prototype.host
  id: api/connection#Connection.prototype.host
  summary: The host name portion of the URI
  belongs_to: Connection
  description: |-
    ### Connection.prototype.host

    ##### Type:

    - «property»

    The host name portion of the URI. If multiple hosts, such as a replica set, this will contain the first host name in the URI

    #### [Example:](#example)

    ``` javascript
    mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').host; // "127.0.0.1"
    ```
- name: Connection.prototype.id
  id: api/connection#Connection.prototype.id
  summary: A number identifier for this connection
  belongs_to: Connection
  description: |-
    ### Connection.prototype.id

    ##### Type:

    - «property»

    A number identifier for this connection. Used for debugging when you have [multiple connections](../connections#multiple_connections).

    #### [Example:](#example)

    ``` javascript
    // The default connection has `id = 0`
    mongoose.connection.id; // 0

    // If you create a new connection, Mongoose increments id
    const conn = mongoose.createConnection();
    conn.id; // 1
    ```
- name: Connection.prototype.model()
  id: api/connection#Connection.prototype.model()
  summary: '[schema]«Schema» a schema'
  belongs_to: Connection
  description: |-
    ### Connection.prototype.model()

    ##### Parameters:

    - `name`«String\|Function» the model name or class extending Model
    - `[schema]`«Schema» a schema. necessary when defining a model
    - `[collection]`«String» name of mongodb collection (optional) if not given it will be induced from model name
    - `[options]` «Object»

    - `[options.overwriteModels=false]`«Boolean» If true, overwrite existing models with the same name to avoid `OverwriteModelError`

    ##### Returns:

    - «Model» The compiled model

    ##### See:

    -  [Mongoose#model](mongoose#Mongoose.prototype.model())

    Defines or retrieves a model.

    ``` javascript
    const mongoose = require('mongoose');
    const db = mongoose.createConnection(..);
    db.model('Venue', new Schema(..));
    const Ticket = db.model('Ticket', new Schema(..));
    const Venue = db.model('Venue');
    ```

    *When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the `utils.toCollectionName` method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.*

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ name: String }, { collection: 'actor' });

    // or

    schema.set('collection', 'actor');

    // or

    const collectionName = 'actor'
    const M = conn.model('Actor', schema, collectionName)
    ```
- name: Connection.prototype.modelNames()
  id: api/connection#Connection.prototype.modelNames()
  summary: Returns an array of model names created on this connection
  belongs_to: Connection
  description: |-
    ### Connection.prototype.modelNames()

    ##### Returns:

    - «Array\[String\]»

    Returns an array of model names created on this connection.
- name: Connection.prototype.models
  id: api/connection#Connection.prototype.models
  summary: A POJO containing a map from model names to models
  belongs_to: Connection
  description: |-
    ### Connection.prototype.models

    ##### Type:

    - «property»

    A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing a map from model names to models. Contains all models that have been added to this connection using [`Connection#model()`](#Connection.prototype.model()).

    #### [Example:](#example)

    ``` javascript
    const conn = mongoose.createConnection();
    const Test = conn.model('Test', mongoose.Schema({ name: String }));

    Object.keys(conn.models).length; // 1
    conn.models.Test === Test; // true
    ```
- name: Connection.prototype.name
  id: api/connection#Connection.prototype.name
  summary: The name of the database this connection points to
  belongs_to: Connection
  description: |-
    ### Connection.prototype.name

    ##### Type:

    - «property»

    The name of the database this connection points to.

    #### [Example:](#example)

    ``` javascript
    mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').name; // "mydb"
    ```
- name: Connection.prototype.openUri()
  id: api/connection#Connection.prototype.openUri()
  summary: Opens the connection with a URI using MongoClient.connect()
  belongs_to: Connection
  description: |-
    ### Connection.prototype.openUri()

    ##### Parameters:

    - `uri`«String» The URI to connect with.
    - `[options]`«Object» Passed on to [`MongoClient.connect`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#connect-1)

    &nbsp;

    - `[options.bufferCommands=true]`«Boolean» Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.

    &nbsp;

    - `[options.bufferTimeoutMS=10000]`«Number» Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.

    &nbsp;

    - `[options.dbName]`«String» The name of the database we want to use. If not provided, use database name from connection string.

    &nbsp;

    - `[options.user]`«String» username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.

    &nbsp;

    - `[options.pass]`«String» password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.

    &nbsp;

    - `[options.maxPoolSize=100]`«Number» The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).

    &nbsp;

    - `[options.minPoolSize=0]`«Number» The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).

    &nbsp;

    - `[options.serverSelectionTimeoutMS]`«Number» If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).

    &nbsp;

    - `[options.heartbeatFrequencyMS]`«Number» If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.

    &nbsp;

    - `[options.autoIndex=true]`«Boolean» Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.

    &nbsp;

    - `[options.promiseLibrary]`«Class» Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).

    &nbsp;

    - `[options.socketTimeoutMS=0]`«Number» How long the MongoDB driver will wait before killing a socket due to inactivity *after initial connection*. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.

    &nbsp;

    - `[options.family=0]`«Number» Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4`means use IPv4 only,`6`means use IPv6 only,`0\` means try both.

    &nbsp;

    - `[options.autoCreate=false]`«Boolean» Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.

    Opens the connection with a URI using `MongoClient.connect()`.
- name: Connection.prototype.pass
  id: api/connection#Connection.prototype.pass
  summary: null
  belongs_to: Connection
  description: |-
    ### Connection.prototype.pass

    ##### Type:

    - «property»

    The password specified in the URI

    #### [Example:](#example)

    ``` javascript
    mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').pass; // "psw"
    ```
- name: Connection.prototype.plugin()
  id: api/connection#Connection.prototype.plugin()
  summary: Equivalent to calling .plugin(fn) on each schema you create
  belongs_to: Connection
  description: |-
    ### Connection.prototype.plugin()

    ##### Parameters:

    - `fn`«Function» plugin callback
    - `[opts]`«Object» optional options

    ##### Returns:

    - «Connection» this

    ##### See:

    -  [plugins](../plugins)

    Declares a plugin executed on all schemas you pass to `conn.model()`

    Equivalent to calling `.plugin(fn)` on each schema you create.

    #### [Example:](#example)

    ``` javascript
    const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');
    db.plugin(() => console.log('Applied'));
    db.plugins.length; // 1

    db.model('Test', new Schema({})); // Prints "Applied"
    ```
- name: Connection.prototype.plugins
  id: api/connection#Connection.prototype.plugins
  summary: The plugins that will be applied to all models created on this connection
  belongs_to: Connection
  description: |-
    ### Connection.prototype.plugins

    ##### Type:

    - «property»

    The plugins that will be applied to all models created on this connection.

    #### [Example:](#example)

    ``` javascript
    const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');
    db.plugin(() => console.log('Applied'));
    db.plugins.length; // 1

    db.model('Test', new Schema({})); // Prints "Applied"
    ```
- name: Connection.prototype.port
  id: api/connection#Connection.prototype.port
  summary: The port portion of the URI
  belongs_to: Connection
  description: |-
    ### Connection.prototype.port

    ##### Type:

    - «property»

    The port portion of the URI. If multiple hosts, such as a replica set, this will contain the port from the first host name in the URI.

    #### [Example:](#example)

    ``` javascript
    mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').port; // 27017
    ```
- name: Connection.prototype.readyState
  id: api/connection#Connection.prototype.readyState
  summary: Each state change emits its associated event name
  belongs_to: Connection
  description: |-
    ### Connection.prototype.readyState

    ##### Type:

    - «property»

    Connection ready state

    - 0 = disconnected
    - 1 = connected
    - 2 = connecting
    - 3 = disconnecting

    Each state change emits its associated event name.

    #### [Example:](#example)

    ``` javascript
    conn.on('connected', callback);
    conn.on('disconnected', callback);
    ```
- name: Connection.prototype.removeDb()
  id: api/connection#Connection.prototype.removeDb()
  summary: Removes the database connection with the given name created with with useDb()
  belongs_to: Connection
  description: |-
    ### Connection.prototype.removeDb()

    ##### Parameters:

    - `name`«String» The database name

    ##### Returns:

    - «Connection» this

    Removes the database connection with the given name created with with `useDb()`.

    Throws an error if the database connection was not found.

    #### [Example:](#example)

    ``` javascript
    // Connect to `initialdb` firstconst conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();

    // Creates an un-cached connection to `mydb`
    const db = conn.useDb('mydb');

    // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`
    await conn.removeDb('mydb');
    ```
- name: Connection.prototype.set()
  id: api/connection#Connection.prototype.set()
  summary: Sets the value of the option key
  belongs_to: Connection
  description: |-
    ### Connection.prototype.set()

    ##### Parameters:

    - `key` «String»
    - `val` «Any»

    Sets the value of the option `key`. Equivalent to `conn.options[key] = val`

    Supported options include:

    - `maxTimeMS`: Set [`maxTimeMS`](query#Query.prototype.maxTimeMS()) for all queries on this connection.
    - 'debug': If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arugments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.

    #### [Example:](#example)

    ``` javascript
    conn.set('test', 'foo');
    conn.get('test'); // 'foo'
    conn.options.test; // 'foo'
    ```
- name: Connection.prototype.setClient()
  id: api/connection#Connection.prototype.setClient()
  summary: Set the MongoDB driver MongoClient instance that this connection uses to talk to MongoDB
  belongs_to: Connection
  description: |-
    ### Connection.prototype.setClient()

    ##### Parameters:

    - `client`«MongClient» The Client to set to be used.

    ##### Returns:

    - «Connection» this

    Set the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to reuse it.

    #### [Example:](#example)

    ``` javascript
    const client = await mongodb.MongoClient.connect('mongodb://127.0.0.1:27017/test');

    const conn = mongoose.createConnection().setClient(client);

    conn.getClient(); // MongoClient { ... }
    conn.readyState; // 1, means 'CONNECTED'
    ```
- name: Connection.prototype.startSession()
  id: api/connection#Connection.prototype.startSession()
  summary: Requires MongoDB >= 3.6.0
  belongs_to: Connection
  description: |-
    ### Connection.prototype.startSession()

    ##### Parameters:

    - `[options]`«Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)

    &nbsp;

    - `[options.causalConsistency=true]`«Boolean» set to false to disable causal consistency

    ##### Returns:

    - «Promise\<ClientSession\>» promise that resolves to a MongoDB driver `ClientSession`

    *Requires MongoDB \>= 3.6.0.* Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions) for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/), and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).

    #### [Example:](#example)

    ``` javascript
    const session = await conn.startSession();
    let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });
    await doc.remove();
    // `doc` will always be null, even if reading from a replica set
    // secondary. Without causal consistency, it is possible to
    // get a doc back from the below query if the query reads from a
    // secondary that is experiencing replication lag.
    doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });
    ```
- name: Connection.prototype.syncIndexes()
  id: api/connection#Connection.prototype.syncIndexes()
  summary: Syncs all the indexes for the models registered with this connection
  belongs_to: Connection
  description: |-
    ### Connection.prototype.syncIndexes()

    ##### Parameters:

    - `[options]` «Object»

    &nbsp;

    - `[options.continueOnError]`«Boolean»`false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.

    ##### Returns:

    - «Promise\<Object\>» Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.

    Syncs all the indexes for the models registered with this connection.
- name: Connection.prototype.transaction()
  id: api/connection#Connection.prototype.transaction()
  summary: Requires MongoDB >= 3.6.0
  belongs_to: Connection
  description: |-
    ### Connection.prototype.transaction()

    ##### Parameters:

    - `fn`«Function» Function to execute in a transaction
    - `[options]`«\[object Object\]» Optional settings for the transaction

    ##### Returns:

    - «Promise\<Any\>» promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.

    *Requires MongoDB \>= 3.6.0.* Executes the wrapped async function in a transaction. Mongoose will commit the transaction if the async function executes successfully and attempt to retry if there was a retriable error.

    Calls the MongoDB driver's [`session.withTransaction()`](https://mongodb.github.io/node-mongodb-native/4.9/classes/ClientSession.html#withTransaction), but also handles resetting Mongoose document state as shown below.

    #### [Example:](#example)

    ``` javascript
    const doc = new Person({ name: 'Will Riker' });
    await db.transaction(async function setRank(session) {
      doc.rank = 'Captain';
      await doc.save({ session });
      doc.isNew; // false

      // Throw an error to abort the transaction
      throw new Error('Oops!');
    },{ readPreference: 'primary' }).catch(() => {});

    // true, `transaction()` reset the document's state because the
    // transaction was aborted.
    doc.isNew;
    ```
- name: Connection.prototype.useDb()
  id: api/connection#Connection.prototype.useDb()
  summary: Switches to a different database using the same connection pool
  belongs_to: Connection
  description: |-
    ### Connection.prototype.useDb()

    ##### Parameters:

    - `name`«String» The database name
    - `[options]` «Object»

    &nbsp;

    - `[options.useCache=false]`«Boolean» If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.

    &nbsp;

    - `[options.noListener=false]`«Boolean» If true, the connection object will not make the db listen to events on the original connection. See [issue \#9961](https://github.com/Automattic/mongoose/issues/9961).

    ##### Returns:

    - «Connection» New Connection Object

    Switches to a different database using the same [connection pool](connectionshtml#connection_pools).

    Returns a new connection object, with the new db.

    #### [Example:](#example)

    ``` javascript
    // Connect to `initialdb` firstconst conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();

    // Creates an un-cached connection to `mydb`
    const db = conn.useDb('mydb');
    // Creates a cached connection to `mydb2`. All calls to `conn.useDb('mydb2', { useCache: true })` will return the same
    // connection instance as opposed to creating a new connection instance
    const db2 = conn.useDb('mydb2', { useCache: true });
    ```
- name: Connection.prototype.user
  id: api/connection#Connection.prototype.user
  summary: null
  belongs_to: Connection
  description: |-
    ### Connection.prototype.user

    ##### Type:

    - «property»

    The username specified in the URI

    #### [Example:](#example)

    ``` javascript
    mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').user; // "val"
    ```
- name: Connection.prototype.watch()
  id: api/connection#Connection.prototype.watch()
  summary: Watches the entire underlying database for changes
  belongs_to: Connection
  description: "### Connection.prototype.watch()\n\n##### Parameters:\n\n- `[pipeline]` «Array»\n- `[options]`«Object» passed without changes to [the MongoDB driver's `Db#watch()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#watch)\n\n##### Returns:\n\n- «ChangeStream» mongoose-specific change stream wrapper, inherits from EventEmitter\n\nWatches the entire underlying database for changes. Similar to [`Model.watch()`](model#Model.watch()).\n\nThis function does **not** trigger any middleware. In particular, it does **not** trigger aggregate middleware.\n\nThe ChangeStream object is an event emitter that emits the following events:\n\n- 'change': A change occurred, see below example\n- 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n- 'end': Emitted if the underlying stream is closed\n- 'close': Emitted if the underlying stream is closed\n\n#### [Example:](#example)\n\n``` javascript\nconstUser = conn.model('User', new Schema({ name: String }));\n\nconst changeStream = conn.watch().on('change', data => console.log(data));\n\n// Triggers a 'change' event on the change stream.\nawait User.create({ name: 'test' });\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/connection.html](https://mongoosejs.com/docs/api/connection.html)"
- name: Connections
  id: connections
  summary: You can connect to MongoDB with the mongoose.connect() method
  description: "# Connections\n\nYou can connect to MongoDB with the `mongoose.connect()` method.\n\n``` javascript\nmongoose.connect('mongodb://127.0.0.1:27017/myapp');\n```\n\nThis is the minimum needed to connect the `myapp` database running locally on the default port (27017). For local MongoDB databases, we recommend using `127.0.0.1` instead of `localhost`. That is because Node.js 18 and up prefer IPv6 addresses, which means, on many machines, Node.js will resolve `localhost` to the IPv6 address `::1` and Mongoose will be unable to connect, unless the mongodb instance is running with ipv6 enabled.\n\nYou can also specify several more parameters in the `uri`:\n\n``` javascript\nmongoose.connect('mongodb://username:password@host:port/database?options...');\n```\n\nSee the [mongodb connection string spec](http://www.mongodb.com/docs/manual/reference/connection-string/) for more details.\n\n## Operation Buffering\n\nMongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.\n\n``` javascript\nmongoose.connect('mongodb://127.0.0.1:27017/myapp');\nconst MyModel = mongoose.model('Test', new Schema({ name: String }));\n// Works\nawait MyModel.findOne();\n```\n\nThat's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will *not* throw any errors by default if you use a model without connecting.\n\n``` javascript\nconst MyModel = mongoose.model('Test', new Schema({ name: String }));\nconst promise = MyModel.findOne();\n\nsetTimeout(function() {\n  mongoose.connect('mongodb://127.0.0.1:27017/myapp');\n}, 60000);\n\n// Will just hang until mongoose successfully connects\nawait promise;\n```\n\nTo disable buffering, turn off the [`bufferCommands` option on your schema](guide#bufferCommands). If you have `bufferCommands` on and your connection is hanging, try turning `bufferCommands` off to see if you haven't opened a connection properly. You can also disable `bufferCommands` globally:\n\n``` javascript\nmongoose.set('bufferCommands', false);\n```\n\nNote that buffering is also responsible for waiting until Mongoose creates collections if you use the [`autoCreate` option](guide#autoCreate). If you disable buffering, you should also disable the `autoCreate` option and use [`createCollection()`](api/model#model_Model-createCollection) to create [capped collections](guide#capped) or [collections with collations](guide#collation).\n\n``` javascript\nconst schema = new Schema({\n  name: String\n}, {\n  capped: { size: 1024 },\n  bufferCommands: false,\n  autoCreate: false // disable `autoCreate` since `bufferCommands` is false\n});\n\nconst Model = mongoose.model('Test', schema);\n// Explicitly create the collection before using it\n// so the collection is capped.\nawait Model.createCollection();\n```\n\n## Error Handling\n\nThere are two classes of errors that can occur with a Mongoose connection.\n\n- **Error on initial connection**: If initial connection fails, Mongoose will emit an 'error' event and the promise `mongoose.connect()` returns will reject. However, Mongoose will **not** automatically try to reconnect.\n- **Error after initial connection was established**: Mongoose will attempt to reconnect, and it will emit an 'error' event.\n\nTo handle initial connection errors, you should use `.catch()` or `try/catch` with async/await.\n\n``` javascript\nmongoose.connect('mongodb://127.0.0.1:27017/test').\n  catch(error => handleError(error));\n\n// Or:\ntry {\n  await mongoose.connect('mongodb://127.0.0.1:27017/test');\n} catch (error) {\n  handleError(error);\n}\n```\n\nTo handle errors after initial connection was established, you should listen for error events on the connection. However, you still need to handle initial connection errors as shown above.\n\n``` javascript\nmongoose.connection.on('error', err => {\n  logError(err);\n});\n```\n\nNote that Mongoose does not necessarily emit an 'error' event if it loses connectivity to MongoDB. You should listen to the `disconnected` event to report when Mongoose is disconnected from MongoDB.\n\n## Options\n\nThe `connect` method also accepts an `options` object which will be passed on to the underlying MongoDB driver.\n\n``` javascript\nmongoose.connect(uri, options);\n```\n\nA full list of options can be found on the [MongoDB Node.js driver docs for `MongoClientOptions`](https://mongodb.github.io/node-mongodb-native/4.2/interfaces/MongoClientOptions.html). Mongoose passes options to the driver without modification, modulo a few exceptions that are explained below.\n\n- `bufferCommands` - This is a mongoose-specific option (not passed to the MongoDB driver) that disables [Mongoose's buffering mechanism](https://mongoosejs.com/docs/faq.html#callback_never_executes)\n- `user`/`pass` - The username and password for authentication. These options are Mongoose-specific, they are equivalent to the MongoDB driver's `auth.username` and `auth.password` options.\n- `autoIndex` - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set `autoIndex` to false, mongoose will not automatically build indexes for **any** model associated with this connection.\n- `dbName` - Specifies which database to connect to and overrides any database specified in the connection string. This is useful if you are unable to specify a default database in the connection string like with [some `mongodb+srv` syntax connections](https://stackoverflow.com/questions/48917591/fail-to-connect-mongoose-to-atlas/48917626#48917626).\n\nBelow are some of the options that are important for tuning Mongoose.\n\n- `promiseLibrary` - Sets the [underlying driver's promise library](http://mongodb.github.io/node-mongodb-native/3.1/api/MongoClient.html).\n- `maxPoolSize` - The maximum number of sockets the MongoDB driver will keep open for this connection. By default, `maxPoolSize` is 100. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](http://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs). You may want to decrease `maxPoolSize` if you are running into [connection limits](https://www.mongodb.com/docs/atlas/reference/atlas-limits/#connection-limits-and-cluster-tier).\n- `minPoolSize` - The minimum number of sockets the MongoDB driver will keep open for this connection. The MongoDB driver may close sockets that have been inactive for some time. You may want to increase `minPoolSize` if you expect your app to go through long idle times and want to make sure your sockets stay open to avoid slow trains when activity picks up.\n- `socketTimeoutMS` - How long the MongoDB driver will wait before killing a socket due to inactivity *after initial connection*. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n- `family` - Whether to connect using IPv4 or IPv6. This option passed to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your `mongoose.connect(uri)` call takes a long time, try `mongoose.connect(uri, { family: 4 })`\n- `authSource` - The database to use when authenticating with `user` and `pass`. In MongoDB, [users are scoped to a database](https://www.mongodb.com/docs/manual/tutorial/manage-users-and-roles/). If you are getting an unexpected login failure, you may need to set this option.\n- `serverSelectionTimeoutMS` - The MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n- `heartbeatFrequencyMS` - The MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n\n## serverSelectionTimeoutMS\n\nThe `serverSelectionTimeoutMS` option is extremely important: it controls how long the MongoDB Node.js driver will attempt to retry any operation before erroring out. This includes initial connection, like `await mongoose.connect()`, as well as any operations that make requests to MongoDB, like `save()` or `find()`.\n\nBy default, `serverSelectionTimeoutMS` is 30000 (30 seconds). This means that, for example, if you call `mongoose.connect()` when your standalone MongoDB server is down, your `mongoose.connect()` call will only throw an error after 30 seconds.\n\n``` javascript\n// Throws an error \"getaddrinfo ENOTFOUND doesnt.exist\" after 30 seconds\nawait mongoose.connect('mongodb://doesnt.exist:27017/test');\n```\n\nSimilarly, if your standalone MongoDB server goes down after initial connection, any `find()` or `save()` calls will error out after 30 seconds, unless your MongoDB server is restarted.\n\nWhile 30 seconds seems like a long time, `serverSelectionTimeoutMS` means you're unlikely to see any interruptions during a [replica set failover](https://www.mongodb.com/docs/manual/replication/#automatic-failover). If you lose your replica set primary, the MongoDB Node driver will ensure that any operations you send during the replica set election will eventually execute, assuming that the replica set election takes less than `serverSelectionTimeoutMS`.\n\nTo get faster feedback on failed connections, you can reduce `serverSelectionTimeoutMS` to 5000 as follows. We don't recommend reducing `serverSelectionTimeoutMS` unless you are running a standalone MongoDB server rather than a replica set, or unless you are using a serverless runtime like [AWS Lambda](lambda).\n\n``` javascript\nmongoose.connect(uri, {\n  serverSelectionTimeoutMS: 5000\n});\n```\n\nThere is no way to tune `serverSelectionTimeoutMS` independently for `mongoose.connect()` vs for queries. If you want to reduce `serverSelectionTimeoutMS` for queries and other operations, but still retry `mongoose.connect()` for longer, you are responsible for retrying the `connect()` calls yourself using a `for` loop or [a tool like p-retry](https://github.com/Automattic/mongoose/issues/12967#issuecomment-1411227968).\n\n``` javascript\nconst serverSelectionTimeoutMS = 5000;\n\n// Prints \"Failed 0\", \"Failed 1\", \"Failed 2\" and then throws an\n// error. Exits after approximately 15 seconds.\nfor (let i = 0; i < 3; ++i) {\n  try {\n    await mongoose.connect('mongodb://doesnt.exist:27017/test', {\n      serverSelectionTimeoutMS\n    });\n    break;\n  } catch (err) {\n    console.log('Failed', i);\n    if (i >= 2) {\n      throw err;\n    }\n  }\n}\n```\n\n## Callback\n\nThe `connect()` function also accepts a callback parameter and returns a [promise](promises).\n\n``` javascript\nmongoose.connect(uri, options, function(error) {\n  // Check error in initial connection. There is no 2nd param to the callback.\n});\n\n// Or using promises\nmongoose.connect(uri, options).then(\n  () => { /** ready to use. The `mongoose.connect()` promise resolves to mongoose instance. */ },\n  err => { /** handle initial connection error */ }\n);\n```\n\n## Connection String Options\n\nYou can also specify driver options in your connection string as [parameters in the query string](https://en.wikipedia.org/wiki/Query_string) portion of the URI. This only applies to options passed to the MongoDB driver. You **can't** set Mongoose-specific options like `bufferCommands` in the query string.\n\n``` javascript\nmongoose.connect('mongodb://127.0.0.1:27017/test?socketTimeoutMS=1000&bufferCommands=false&authSource=otherdb');\n// The above is equivalent to:\nmongoose.connect('mongodb://127.0.0.1:27017/test', {\n  socketTimeoutMS: 1000\n  // Note that mongoose will **not** pull `bufferCommands` from the query string\n});\n```\n\nThe disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for `socketTimeoutMS`, etc. Best practice is to put options that likely differ between development and production, like `replicaSet` or `ssl`, in the connection string, and options that should remain constant, like `socketTimeoutMS` or `maxPoolSize`, in the options object.\n\nThe MongoDB docs have a full list of [supported connection string options](https://www.mongodb.com/docs/manual/reference/connection-string/). Below are some options that are often useful to set in the connection string because they are closely associated with the hostname and authentication information.\n\n- `authSource` - The database to use when authenticating with `user` and `pass`. In MongoDB, [users are scoped to a database](https://www.mongodb.com/docs/manual/tutorial/manage-users-and-roles/). If you are getting an unexpected login failure, you may need to set this option.\n- `family` - Whether to connect using IPv4 or IPv6. This option passed to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your `mongoose.connect(uri)` call takes a long time, try `mongoose.connect(uri, { family: 4 })`\n\n## Connection Events\n\nConnections inherit from [Node.js' `EventEmitter` class](https://nodejs.org/api/events.html#events_class_eventemitter), and emit events when something happens to the connection, like losing connectivity to the MongoDB server. Below is a list of events that a connection may emit.\n\n- `connecting`: Emitted when Mongoose starts making its initial connection to the MongoDB server\n- `connected`: Emitted when Mongoose successfully makes its initial connection to the MongoDB server, or when Mongoose reconnects after losing connectivity. May be emitted multiple times if Mongoose loses connectivity.\n- `open`: Emitted after `'connected'` and `onOpen` is executed on all of this connection's models.\n- `disconnecting`: Your app called [`Connection#close()`](api/connection#connection_Connection-close) to disconnect from MongoDB\n- `disconnected`: Emitted when Mongoose lost connection to the MongoDB server. This event may be due to your code explicitly closing the connection, the database server crashing, or network connectivity issues.\n- `close`: Emitted after [`Connection#close()`](api/connection#connection_Connection-close) successfully closes the connection. If you call `conn.close()`, you'll get both a 'disconnected' event and a 'close' event.\n- `reconnected`: Emitted if Mongoose lost connectivity to MongoDB and successfully reconnected. Mongoose attempts to [automatically reconnect](https://thecodebarbarian.com/managing-connections-with-the-mongodb-node-driver.html) when it loses connection to the database.\n- `error`: Emitted if an error occurs on a connection, like a `parseError` due to malformed data or a payload larger than [16MB](https://www.mongodb.com/docs/manual/reference/limits/#BSON-Document-Size).\n- `fullsetup`: Emitted when you're connecting to a replica set and Mongoose has successfully connected to the primary and at least one secondary.\n- `all`: Emitted when you're connecting to a replica set and Mongoose has successfully connected to all servers specified in your connection string.\n\nWhen you're connecting to a single MongoDB server (a \"standalone\"), Mongoose will emit 'disconnected' if it gets disconnected from the standalone server, and 'connected' if it successfully connects to the standalone. In a replica set, Mongoose will emit 'disconnected' if it loses connectivity to the replica set primary, and 'connected' if it manages to reconnect to the replica set primary.\n\n## A note about keepAlive\n\nBefore Mongoose 5.2.0, you needed to enable the `keepAlive` option to initiate [TCP keepalive](https://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html) to prevent `\"connection closed\"` errors errors. However, `keepAlive` has been `true` by default since Mongoose 5.2.0, and the `keepAlive` is deprecated as of Mongoose 7.2.0. Please remove `keepAlive` and `keepAliveInitialDelay` options from your Mongoose connections.\n\n## Replica Set Connections\n\nTo connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host.\n\n``` javascript\nmongoose.connect('mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]' [, options]);\n```\n\nFor example:\n\n``` javascript\nmongoose.connect('mongodb://user:pw@host1.com:27017,host2.com:27017,host3.com:27017/testdb');\n```\n\nTo connect to a single node replica set, specify the `replicaSet` option.\n\n``` javascript\nmongoose.connect('mongodb://host1:port1/?replicaSet=rsName');\n```\n\n## Server Selection\n\nThe underlying MongoDB driver uses a process known as [server selection](https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst) to connect to MongoDB and send operations to MongoDB. If the MongoDB driver can't find a server to send an operation to after `serverSelectionTimeoutMS`, you'll get the below error:\n\n``` javascript\nMongoTimeoutError: Server selection timed out after 30000 ms\n```\n\nYou can configure the timeout using the `serverSelectionTimeoutMS` option to `mongoose.connect()`:\n\n``` javascript\nmongoose.connect(uri, {\n  serverSelectionTimeoutMS: 5000 // Timeout after 5s instead of 30s\n});\n```\n\nA `MongoTimeoutError` has a `reason` property that explains why server selection timed out. For example, if you're connecting to a standalone server with an incorrect password, `reason` will contain an \"Authentication failed\" error.\n\n``` javascript\nconst mongoose = require('mongoose');\n\nconst uri = 'mongodb+srv://username:badpw@cluster0-OMITTED.mongodb.net/' +\n  'test?retryWrites=true&w=majority';\n// Prints \"MongoServerError: bad auth Authentication failed.\"\nmongoose.connect(uri, {\n  serverSelectionTimeoutMS: 5000\n}).catch(err => console.log(err.reason));\n```\n\n## Replica Set Host Names\n\nMongoDB replica sets rely on being able to reliably figure out the domain name for each member.  \nOn Linux and OSX, the MongoDB server uses the output of the [`hostname` command](https://linux.die.net/man/1/hostname) to figure out the domain name to report to the replica set. This can cause confusing errors if you're connecting to a remote MongoDB replica set running on a machine that reports its `hostname` as `localhost`:\n\n``` javascript\n// Can get this error even if your connection string doesn't include\n// `localhost` if `rs.conf()` reports that one replica set member has\n// `localhost` as its host name.\nMongooseServerSelectionError: connect ECONNREFUSED localhost:27017\n```\n\nIf you're experiencing a similar error, connect to the replica set using the `mongo` shell and run the [`rs.conf()`](https://www.mongodb.com/docs/manual/reference/method/rs.conf/) command to check the host names of each replica set member. Follow [this page's instructions to change a replica set member's host name](https://www.mongodb.com/docs/manual/tutorial/change-hostnames-in-a-replica-set/#change-hostnames-while-maintaining-replica-set-availability).\n\nYou can also check the `reason.servers` property of `MongooseServerSelectionError` to see what the MongoDB Node driver thinks the state of your replica set is. The `reason.servers` property contains a [map](https://masteringjs.io/tutorials/fundamentals/map) of server descriptions.\n\n``` javascript\nif (err.name === 'MongooseServerSelectionError') {\n  // Contains a Map describing the state of your replica set. For example:\n  // Map(1) {\n  //   'localhost:27017' => ServerDescription {\n  //     address: 'localhost:27017',\n  //     type: 'Unknown',\n  //     ...\n  //   }\n  // }\n  console.log(err.reason.servers);\n}\n```\n\n## Multi-mongos support\n\nYou can also connect to multiple [mongos](https://www.mongodb.com/docs/manual/reference/program/mongos/) instances for high availability in a sharded cluster. You do [not need to pass any special options to connect to multiple mongos](http://mongodb.github.io/node-mongodb-native/3.0/tutorials/connect/#connect-to-sharded-cluster) in mongoose 5.x.\n\n``` javascript\n// Connect to 2 mongos servers\nmongoose.connect('mongodb://mongosA:27501,mongosB:27501', cb);\n```\n\n## Multiple connections\n\nSo far we've seen how to connect to MongoDB using Mongoose's default connection. Mongoose creates a *default connection* when you call `mongoose.connect()`. You can access the default connection using `mongoose.connection`.\n\nYou may need multiple connections to MongoDB for several reasons. One reason is if you have multiple databases or multiple MongoDB clusters. Another reason is to work around [slow trains](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs). The `mongoose.createConnection()` function takes the same arguments as `mongoose.connect()` and returns a new connection.\n\n``` javascript\nconst conn = mongoose.createConnection('mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]', options);\n```\n\nThis [connection](api/connection#connection_Connection) object is then used to create and retrieve [models](api/model#model_Model). Models are **always** scoped to a single connection.\n\n``` javascript\nconst UserModel = conn.model('User', userSchema);\n```\n\nIf you use multiple connections, you should make sure you export schemas, **not** models. Exporting a model from a file is called the *export model pattern*. The export model pattern is limited because you can only use one connection.\n\n``` javascript\nconst userSchema = new Schema({ name: String, email: String });\n\n// The alternative to the export model pattern is the export schema pattern.\nmodule.exports = userSchema;\n\n// Because if you export a model as shown below, the model will be scoped\n// to Mongoose's default connection.\n// module.exports = mongoose.model('User', userSchema);\n```\n\nIf you use the export schema pattern, you still need to create models somewhere. There are two common patterns. First is to export a connection and register the models on the connection in the file:\n\n``` javascript\n// connections/fast.js\nconst mongoose = require('mongoose');\n\nconst conn = mongoose.createConnection(process.env.MONGODB_URI);\nconn.model('User', require('../schemas/user'));\n\nmodule.exports = conn;\n\n// connections/slow.js\nconst mongoose = require('mongoose');\n\nconst conn = mongoose.createConnection(process.env.MONGODB_URI);\nconn.model('User', require('../schemas/user'));\nconn.model('PageView', require('../schemas/pageView'));\n\nmodule.exports = conn;\n```\n\nAnother alternative is to register connections with a dependency injector or another [inversion of control (IOC) pattern](https://thecodebarbarian.com/using-ramda-as-a-dependency-injector).\n\n``` javascript\nconst mongoose = require('mongoose');\n\nmodule.exports = function connectionFactory() {\n  const conn = mongoose.createConnection(process.env.MONGODB_URI);\n\n  conn.model('User', require('../schemas/user'));\n  conn.model('PageView', require('../schemas/pageView'));\n\n  return conn;\n};\n```\n\n## Connection Pools\n\nEach `connection`, whether created with `mongoose.connect` or `mongoose.createConnection` are all backed by an internal configurable connection pool defaulting to a maximum size of 100. Adjust the pool size using your connection options:\n\n``` javascript\n// With object options\nmongoose.createConnection(uri, { maxPoolSize: 10 });\n\n// With connection string options\nconst uri = 'mongodb://127.0.0.1:27017/test?maxPoolSize=10';\nmongoose.createConnection(uri);\n```\n\nThe connection pool size is important because [MongoDB currently can only process one operation per socket](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs). So `maxPoolSize` functions as a cap on the number of concurrent operations.\n\n## Multi Tenant Connections\n\nIn the context of Mongoose, a multi-tenant architecture typically means a case where multiple different clients talk to MongoDB through a single Mongoose application. This typically means each client makes queries and executes updates through a single Mongoose application, but has a distinct MongoDB database within the same MongoDB cluster.\n\nWe recommend reading [this article about multi-tenancy with Mongoose](https://medium.com/brightlab-techblog/multitenant-node-js-application-with-mongoose-mongodb-f8841a285b4f); it has a good description of how we define multi-tenancy and a more detailed overview of our recommended patterns.\n\nThere are two patterns we recommend for multi-tenancy in Mongoose:\n\n1.  Maintain one connection pool, switch between tenants using the [`Connection.prototype.useDb()` method](api/connection#Connection.prototype.useDb()).\n2.  Maintain a separate connection pool per tenant, store connections in a map or [POJO](https://masteringjs.io/tutorials/fundamentals/pojo).\n\nThe following is an example of pattern (1). We recommend pattern (1) for cases where you have a small number of tenants, or if each individual tenant's workload is light (approximately \\< 1 request per second, all requests take \\< 10ms of database processing time). Pattern (1) is simpler to implement and simpler to manage in production, because there is only 1 connection pool. But, under high load, you will likely run into issues where some tenants' operations slow down other tenants' operations due to [slow trains](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n\n``` javascript\nconst express = require('express');\nconst mongoose = require('mongoose');\n\nmongoose.connect('mongodb://127.0.0.1:27017/main');\nmongoose.set('debug', true);\n\nmongoose.model('User', mongoose.Schema({ name: String }));\n\nconst app = express();\n\napp.get('/users/:tenantId', function(req, res) {\n  const db = mongoose.connection.useDb(`tenant_${req.params.tenantId}`, {\n    // `useCache` tells Mongoose to cache connections by database name, so\n    // `mongoose.connection.useDb('foo', { useCache: true })` returns the\n    // same reference each time.\n    useCache: true\n  });\n  // Need to register models every time a new connection is created\n  if (!db.models['User']) {\n    db.model('User', mongoose.Schema({ name: String }));\n  }\n  console.log('Find users from', db.name);\n  db.model('User').find().\n    then(users => res.json({ users })).\n    catch(err => res.status(500).json({ message: err.message }));\n});\n\napp.listen(3000);\n```\n\nThe following is an example of pattern (2). Pattern (2) is more flexible and better for use cases with \\> 10k tenants and \\> 1 requests/second. Because each tenant has a separate connection pool, one tenants' slow operations will have minimal impact on other tenants. However, this pattern is harder to implement and manage in production. In particular, [MongoDB does have a limit on the number of open connections](https://www.mongodb.com/blog/post/tuning-mongodb--linux-to-allow-for-tens-of-thousands-connections), and [MongoDB Atlas has separate limits on the number of open connections](https://www.mongodb.com/docs/atlas/reference/atlas-limits), so you need to make sure the total number of sockets in your connection pools doesn't go over MongoDB's limits.\n\n``` javascript\nconst express = require('express');\nconst mongoose = require('mongoose');\n\nconst tenantIdToConnection = {};\n\nconst app = express();\n\napp.get('/users/:tenantId', function(req, res) {\n  let initialConnection = Promise.resolve();\n  const { tenantId } = req.params;\n  if (!tenantIdToConnection[tenantId]) {\n    tenantIdToConnection[tenantId] = mongoose.createConnection(`mongodb://127.0.0.1:27017/tenant_${tenantId}`);\n    tenantIdToConnection[tenantId].model('User', mongoose.Schema({ name: String }));\n    initialConnection = tenantIdToConnection[tenantId].asPromise();\n  }\n  const db = tenantIdToConnection[tenantId];\n  initialConnection.\n    then(() => db.model('User').find()).\n    then(users => res.json({ users })).\n    catch(err => res.status(500).json({ message: err.message }));\n});\n\napp.listen(3000);\n```\n\n## Next Up\n\nNow that we've covered connections, let's take a look at [models](models).\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/connections.html](https://mongoosejs.com/docs/connections.html)"
- name: Custom Schema Types
  id: customschematypes
  summary: 'New in Mongoose 4.4.0: Mongoose supports custom types'
  description: "# Custom Schema Types\n\n## Creating a Basic Custom Schema Type\n\n*New in Mongoose 4.4.0:* Mongoose supports custom types. Before you reach for a custom type, however, know that a custom type is overkill for most use cases. You can do most basic tasks with [custom getters/setters](http://mongoosejs.com/docs/2.7.x/docs/getters-setters.html), [virtuals](http://mongoosejs.com/docs/guide.html#virtuals), and [single embedded docs](http://mongoosejs.com/docs/subdocs.html#single-embedded).\n\nLet's take a look at an example of a basic schema type: a 1-byte integer. To create a new schema type, you need to inherit from `mongoose.SchemaType` and add the corresponding property to `mongoose.Schema.Types`. The one method you need to implement is the `cast()` method.\n\n``` javascript\nclass Int8 extends mongoose.SchemaType {\n  constructor(key, options) {\n    super(key, options, 'Int8');\n  }\n\n  // `cast()` takes a parameter that can be anything. You need to\n  // validate the provided `val` and throw a `CastError` if you\n  // can't convert it.\n  cast(val) {\n    let _val = Number(val);\n    if (isNaN(_val)) {\n      throw new Error('Int8: ' + val + ' is not a number');\n    }\n    _val = Math.round(_val);\n    if (_val < -0x80 || _val > 0x7F) {\n      throw new Error('Int8: ' + val +\n        ' is outside of the range of valid 8-bit ints');\n    }\n    return _val;\n  }\n}\n\n// Don't forget to add `Int8` to the type registry\nmongoose.Schema.Types.Int8 = Int8;\n\nconst testSchema = new Schema({ test: Int8 });\nconst Test = mongoose.model('CustomTypeExample', testSchema);\n\nconst t = new Test();\nt.test = 'abc';\nassert.ok(t.validateSync());\nassert.equal(t.validateSync().errors['test'].name, 'CastError');\nassert.equal(t.validateSync().errors['test'].message,\n  'Cast to Int8 failed for value \"abc\" (type string) at path \"test\"');\nassert.equal(t.validateSync().errors['test'].reason.message,\n  'Int8: abc is not a number');\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/customschematypes.html](https://mongoosejs.com/docs/customschematypes.html)"
- name: Dates
  id: schematypes#dates
  summary: Built-in Date methods are not hooked into the mongoose change tracking logic which in English means that if you use a Date in your document and modify it with a method like setMonth(), mongoose will be unaware of this change and doc.save() will not persist this modification
  belongs_to: SchemaTypes
  description: |-
    ### Dates

    [Built-in `Date` methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) are [**not** hooked into](https://github.com/Automattic/mongoose/issues/1598) the mongoose change tracking logic which in English means that if you use a `Date` in your document and modify it with a method like `setMonth()`, mongoose will be unaware of this change and `doc.save()` will not persist this modification. If you must modify `Date` types using built-in methods, tell mongoose about the change with `doc.markModified('pathToYourDate')` before saving.

    ``` javascript
    constAssignment = mongoose.model('Assignment', { dueDate: Date });
    const doc = await Assignment.findOne();
    doc.dueDate.setMonth(3);
    await doc.save(); // THIS DOES NOT SAVE YOUR CHANGE

    doc.markModified('dueDate');
    await doc.save(); // works
    ```
- name: Decimal128
  id: api/decimal128
  summary: © 2010 LearnBoost Licensed under the MIT License
  description: "# Decimal128\n\n### Decimal128()\n\nDecimal128 type constructor\n\n#### [Example:](#example)\n\n``` javascript\nconst id = new mongoose.Types.Decimal128('3.1415');\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/decimal128.html](https://mongoosejs.com/docs/api/decimal128.html)"
- name: Decimal128()
  id: api/decimal128#Decimal128()
  summary: © 2010 LearnBoost Licensed under the MIT License
  belongs_to: Decimal128
  description: "### Decimal128()\n\nDecimal128 type constructor\n\n#### [Example:](#example)\n\n``` javascript\nconst id = new mongoose.Types.Decimal128('3.1415');\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/decimal128.html](https://mongoosejs.com/docs/api/decimal128.html)"
- name: Defaults
  id: defaults
  summary: Your schemas can define default values for certain paths
  description: "# Defaults\n\n## Declaring Defaults in Your Schema\n\nYour schemas can define default values for certain paths. If you create a new document without that path set, the default will kick in.\n\nNote: Mongoose only applies a default if the value of the path is strictly `undefined`.\n\n``` javascript\nconst schema = new Schema({\n  name: String,\n  role: { type: String, default: 'guitarist' }\n});\n\nconst Person = db.model('Person', schema);\n\nconst axl = new Person({ name: 'Axl Rose', role: 'singer' });\nassert.equal(axl.role, 'singer');\n\nconst slash = new Person({ name: 'Slash' });\nassert.equal(slash.role, 'guitarist');\n\nconst izzy = new Person({ name: 'Izzy', role: undefined });\nassert.equal(izzy.role, 'guitarist');\n\n// Defaults do **not** run on `null`, `''`, or value other than `undefined`.\nconst foo = new Person({ name: 'Bar', role: null });\nassert.strictEqual(foo.role, null);\n\nawait Person.create(axl, slash);\n\nconst docs = await Person.find({ role: 'guitarist' });\n\nassert.equal(docs.length, 1);\nassert.equal(docs[0].name, 'Slash');\n```\n\n## Default Functions\n\nYou can also set the `default` schema option to a function. Mongoose will execute that function and use the return value as the default.\n\n``` javascript\nconst schema = new Schema({\n  title: String,\n  date: {\n    type: Date,\n    // `Date.now()` returns the current unix timestamp as a number\n    default: Date.now\n  }\n});\n\nconst BlogPost = db.model('BlogPost', schema);\n\nconst post = new BlogPost({ title: '5 Best Arnold Schwarzenegger Movies' });\n\n// The post has a default Date set to now\nassert.ok(post.date.getTime() >= Date.now() - 1000);\nassert.ok(post.date.getTime() <= Date.now());\n```\n\n## The `setDefaultsOnInsert` Option\n\nMongoose also sets defaults on `update()` and `findOneAndUpdate()` when the `upsert` option is set by adding your schema's defaults to a [MongoDB `$setOnInsert` operator](https://www.mongodb.com/docs/manual/reference/operator/update/setOnInsert/). You can disable this behavior by setting the `setDefaultsOnInsert` option to `false`.\n\n``` javascript\nconst schema = new Schema({\n  title: String,\n  genre: { type: String, default: 'Action' }\n});\n\nconst Movie = db.model('Movie', schema);\n\nconst query = {};\nconst update = { title: 'The Terminator' };\nconst options = {\n  // Return the document after updates are applied\n  new: true,\n  // Create a document if one isn't found.\n  upsert: true\n};\n\nlet doc = await Movie.findOneAndUpdate(query, update, options).lean();\ndoc.genre; // 'Action', Mongoose set a default value.\n\nawait Movie.deleteMany({});\n\ndoc = await Movie.findOneAndUpdate(query, update, { new: true, upsert: true, setDefaultsOnInsert: false }).lean();\ndoc.genre; // undefined, Mongoose did not set a default value\n```\n\nYou can also set `setDefaultsOnInsert` to `false` globally:\n\n``` javascript\nmongoose.set('setDefaultsOnInsert', false);\n```\n\n## Default functions and `this`\n\nUnless it is running on a query with `setDefaultsOnInsert`, a default function's `this` refers to the document.\n\n``` javascript\nconst schema = new Schema({\n  title: String,\n  released: Boolean,\n  releaseDate: {\n    type: Date,\n    default: function() {\n      if (this.released) {\n        return Date.now();\n      }\n      return null;\n    }\n  }\n});\n\nconst Movie = db.model('Movie', schema);\n\nconst movie1 = new Movie({ title: 'The Terminator', released: true });\n\n// The post has a default Date set to now\nassert.ok(movie1.releaseDate.getTime() >= Date.now() - 1000);\nassert.ok(movie1.releaseDate.getTime() <= Date.now());\n\nconst movie2 = new Movie({ title: 'The Legend of Conan', released: false });\n\n// Since `released` is false, the default function will return null\nassert.strictEqual(movie2.releaseDate, null);\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/defaults.html](https://mongoosejs.com/docs/defaults.html)"
- name: Discriminators
  id: discriminators
  summary: Discriminators are a schema inheritance mechanism
  description: "# Discriminators\n\n## The `model.discriminator()` function\n\nDiscriminators are a schema inheritance mechanism. They enable you to have multiple models with overlapping schemas on top of the same underlying MongoDB collection.\n\nSuppose you wanted to track different types of events in a single collection. Every event will have a timestamp, but events that represent clicked links should have a URL. You can achieve this using the `model.discriminator()` function. This function takes 3 parameters, a model name, a discriminator schema and an optional key (defaults to the model name). It returns a model whose schema is the union of the base schema and the discriminator schema.\n\n``` javascript\nconst options = { discriminatorKey: 'kind' };\n\nconst eventSchema = new mongoose.Schema({ time: Date }, options);\nconst Event = mongoose.model('Event', eventSchema);\n\n// ClickedLinkEvent is a special type of Event that has\n// a URL.\nconst ClickedLinkEvent = Event.discriminator('ClickedLink',\n  new mongoose.Schema({ url: String }, options));\n\n// When you create a generic event, it can't have a URL field...\nconst genericEvent = new Event({ time: Date.now(), url: 'google.com' });\nassert.ok(!genericEvent.url);\n\n// But a ClickedLinkEvent can\nconst clickedEvent = new ClickedLinkEvent({ time: Date.now(), url: 'google.com' });\nassert.ok(clickedEvent.url);\n```\n\n## Discriminators save to the Event model's collection\n\nSuppose you created another discriminator to track events where a new user registered. These `SignedUpEvent` instances will be stored in the same collection as generic events and `ClickedLinkEvent` instances.\n\n``` javascript\nconst event1 = new Event({ time: Date.now() });\nconst event2 = new ClickedLinkEvent({ time: Date.now(), url: 'google.com' });\nconst event3 = new SignedUpEvent({ time: Date.now(), user: 'testuser' });\n\n\nawait Promise.all([event1.save(), event2.save(), event3.save()]);\nconst count = await Event.countDocuments();\nassert.equal(count, 3);\n```\n\n## Discriminator keys\n\nThe way Mongoose tells the difference between the different discriminator models is by the 'discriminator key', which is `__t` by default. Mongoose adds a String path called `__t` to your schemas that it uses to track which discriminator this document is an instance of.\n\n``` javascript\nconst event1 = new Event({ time: Date.now() });\nconst event2 = new ClickedLinkEvent({ time: Date.now(), url: 'google.com' });\nconst event3 = new SignedUpEvent({ time: Date.now(), user: 'testuser' });\n\nassert.ok(!event1.__t);\nassert.equal(event2.__t, 'ClickedLink');\nassert.equal(event3.__t, 'SignedUp');\n```\n\n## Updating the discriminator key\n\nBy default, Mongoose doesn't let you update the discriminator key. `save()` will throw an error if you attempt to update the discriminator key. And `findOneAndUpdate()`, `updateOne()`, etc. will strip out discriminator key updates.\n\n``` javascript\nlet event = new ClickedLinkEvent({ time: Date.now(), url: 'google.com' });\nawait event.save();\n\nevent.__t = 'SignedUp';\n// ValidationError: ClickedLink validation failed: __t: Cast to String failed for value \"SignedUp\" (type string) at path \"__t\"\n  await event.save();\n\nevent = await ClickedLinkEvent.findByIdAndUpdate(event._id, { __t: 'SignedUp' }, { new: true });\nevent.__t; // 'ClickedLink', update was a no-op\n```\n\nTo update a document's discriminator key, use `findOneAndUpdate()` or `updateOne()` with the `overwriteDiscriminatorKey` option set as follows.\n\n``` javascript\nlet event = new ClickedLinkEvent({ time: Date.now(), url: 'google.com' });\nawait event.save();\n\nevent = await ClickedLinkEvent.findByIdAndUpdate(\n  event._id,\n  { __t: 'SignedUp' },\n  { overwriteDiscriminatorKey: true, new: true }\n);\nevent.__t; // 'SignedUp', updated discriminator key\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/discriminators.html](https://mongoosejs.com/docs/discriminators.html)"
- name: Document
  id: api/document
  summary: Hash containing current validation $errors
  description: "# Document\n\n### Document.prototype.$assertPopulated()\n\n##### Parameters:\n\n- `path` «String\\|Array\\[String\\]» path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.\n- `[values]` «Object» optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\n\n##### Returns:\n\n- «Document» this\n\nThrows an error if a given path is not populated\n\n#### [Example:](#example)\n\n``` javascript\nconst doc = await Model.findOne().populate('author');\n\ndoc.$assertPopulated('author'); // does not throw\ndoc.$assertPopulated('other path'); // throws an error\n\n// Manually populate and assert in one call. The following does\n// `doc.$set({ likes })` before asserting.\ndoc.$assertPopulated('likes', { likes });\n```\n\n### Document.prototype.$clone()\n\n##### Returns:\n\n- «Document» a copy of this document\n\nReturns a copy of this document with a deep clone of `_doc` and `$__`.\n\n### Document.prototype.$errors\n\n##### Type:\n\n- «property»\n\nHash containing current validation $errors.\n\n### Document.prototype.$getAllSubdocs()\n\n##### Returns:\n\n- «Array»\n\nGet all subdocs (by bfs)\n\n### Document.prototype.$getPopulatedDocs()\n\n##### Returns:\n\n- «Array\\[Document\\]» array of populated documents. Empty array if there are no populated documents associated with this document.\n\nGets all populated documents associated with this document.\n\n### Document.prototype.$ignore()\n\n##### Parameters:\n\n- `path` «String» the path to ignore\n\nDon't run validation on this path or persist changes to this path.\n\n#### [Example:](#example)\n\n``` javascript\ndoc.foo = null;\ndoc.$ignore('foo');\ndoc.save(); // changes to foo will not be persisted and validators won't be run\n```\n\n### Document.prototype.$inc()\n\n##### Parameters:\n\n- `path` «String\\|Array» path or paths to update\n- `val` «Number» increment `path` by this value\n\n##### Returns:\n\n- «Document» this\n\nIncrements the numeric value at `path` by the given `val`. When you call `save()` on this document, Mongoose will send a [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/) as opposed to a `$set`.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ counter: Number });\nconst Test = db.model('Test', schema);\n\nconst doc = await Test.create({ counter: 0 });\ndoc.$inc('counter', 2);\nawait doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB\ndoc.counter; // 2\n\ndoc.counter += 2;\nawait doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB\n```\n\n### Document.prototype.$init()\n\nAlias for [`.init`](#Document.prototype.init())\n\n### Document.prototype.$isDefault()\n\n##### Parameters:\n\n- `[path]` «String»\n\n##### Returns:\n\n- «Boolean»\n\nChecks if a path is set to its default.\n\n#### [Example:](#example)\n\n``` javascript\nMyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\nconst m = new MyModel();\nm.$isDefault('name'); // true\n```\n\n### Document.prototype.$isDeleted()\n\n##### Parameters:\n\n- `[val]` «Boolean» optional, overrides whether mongoose thinks the doc is deleted\n\n##### Returns:\n\n- «Boolean,Document» whether mongoose thinks this doc is deleted.\n\nGetter/setter, determines whether the document was removed or not.\n\n#### [Example:](#example)\n\n``` javascript\nconst product = await product.remove();\nproduct.$isDeleted(); // true\nproduct.remove(); // no-op, doesn't send anything to the db\n\nproduct.$isDeleted(false);\nproduct.$isDeleted(); // false\nproduct.remove(); // will execute a remove against the db\n```\n\n### Document.prototype.$isEmpty()\n\n##### Parameters:\n\n- `[path]` «String»\n\n##### Returns:\n\n- «Boolean»\n\nReturns true if the given path is nullish or only contains empty objects. Useful for determining whether this subdoc will get stripped out by the [minimize option](../guide#minimize).\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ nested: { foo: String } });\nconst Model = mongoose.model('Test', schema);\nconst doc = new Model({});\ndoc.$isEmpty('nested'); // true\ndoc.nested.$isEmpty(); // true\n\ndoc.nested.foo = 'bar';\ndoc.$isEmpty('nested'); // false\ndoc.nested.$isEmpty(); // false\n```\n\n### Document.prototype.$isModified()\n\nAlias of [`.isModified`](#Document.prototype.isModified())\n\n### Document.prototype.$isNew\n\n##### Type:\n\n- «property»\n\nBoolean flag specifying if the document is new. If you create a document using `new`, this document will be considered \"new\". `$isNew` is how Mongoose determines whether `save()` should use `insertOne()` to create a new document or `updateOne()` to update an existing document.\n\n#### [Example:](#example)\n\n``` javascript\nconst user = new User({ name: 'John Smith' });\nuser.$isNew; // true\n\nawait user.save(); // Sends an `insertOne` to MongoDB\n```\n\nOn the other hand, if you load an existing document from the database using `findOne()` or another [query operation](../queries), `$isNew` will be false.\n\n#### [Example:](#example-1)\n\n``` javascript\nconst user = await User.findOne({ name: 'John Smith' });\nuser.$isNew; // false\n```\n\nMongoose sets `$isNew` to `false` immediately after `save()` succeeds. That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run. In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.\n\n#### [Example:](#example-2)\n\n``` javascript\nuserSchema.post('save', function() {\n  this.$isNew; // false\n});\nawait User.create({ name: 'John Smith' });\n```\n\nFor subdocuments, `$isNew` is true if either the parent has `$isNew` set, or if you create a new subdocument.\n\n#### [Example:](#example-3)\n\n``` javascript\n// Assume `Group` has a document array `users`\nconst group = await Group.findOne();\ngroup.users[0].$isNew; // false\n\ngroup.users.push({ name: 'John Smith' });\ngroup.users[1].$isNew; // true\n```\n\n### Document.prototype.$locals\n\n##### Type:\n\n- «property»\n\nEmpty object that you can use for storing properties on the document. This is handy for passing data to middleware without conflicting with Mongoose internals.\n\n#### [Example:](#example)\n\n``` javascript\nschema.pre('save', function() {\n  // Mongoose will set `isNew` to `false` if `save()` succeeds\n  this.$locals.wasNew = this.isNew;\n});\n\nschema.post('save', function() {\n  // Prints true if `isNew` was set before `save()`\n  console.log(this.$locals.wasNew);\n});\n```\n\n### Document.prototype.$markValid()\n\n##### Parameters:\n\n- `path` «String» the field to mark as valid\n\nMarks a path as valid, removing existing validation errors.\n\n### Document.prototype.$op\n\n##### Type:\n\n- «property»\n\nA string containing the current operation that Mongoose is executing on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n\n#### [Example:](#example)\n\n``` javascript\nconst doc = new Model({ name: 'test' });\ndoc.$op; // null\n\nconst promise = doc.save();\ndoc.$op; // 'save'\n\nawait promise;\ndoc.$op; // null\n```\n\n### Document.prototype.$parent()\n\n##### Returns:\n\n- «Document»\n\nAlias for [`parent()`](#Document.prototype.parent()). If this document is a subdocument or populated document, returns the document's parent. Returns `undefined` otherwise.\n\n### Document.prototype.$populated()\n\nAlias of [`.populated`](#Document.prototype.populated()).\n\n### Document.prototype.$session()\n\n##### Parameters:\n\n- `[session]` «ClientSession» overwrite the current session\n\n##### Returns:\n\n- «ClientSession»\n\nGetter/setter around the session associated with this document. Used to automatically set `session` if you `save()` a doc that you got from a query with an associated session.\n\n#### [Example:](#example)\n\n``` javascript\nconst session = MyModel.startSession();\nconst doc = await MyModel.findOne().session(session);\ndoc.$session() === session; // true\ndoc.$session(null);\ndoc.$session() === null; // true\n```\n\nIf this is a top-level document, setting the session propagates to all child docs.\n\n### Document.prototype.$set()\n\n##### Parameters:\n\n- `path` «String\\|Object» path or object of key/vals to set\n- `val` «Any» the value to set\n- `[type]` «Schema\\|String\\|Number\\|Buffer\\|\\[object Object\\]» optionally specify a type for \"on-the-fly\" attributes\n- `[options]` «Object» optionally specify options that modify the behavior of the set\n\n- `[options.merge=false]` «Boolean» if true, setting a [nested path](../subdocs#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`\n\n##### Returns:\n\n- «Document» this\n\nAlias for `set()`, used internally to avoid conflicts\n\n### Document.prototype.$timestamps()\n\n##### Parameters:\n\n- `[value]` «Boolean» overwrite the current session\n\n##### Returns:\n\n- «Document,boolean,undefined,void» When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\n\nGetter/setter around whether this document will apply timestamps by default when using `save()` and `bulkSave()`.\n\n#### [Example:](#example)\n\n``` javascript\nconst TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));\nconst doc = new TestModel({ name: 'John Smith' });\n\ndoc.$timestamps(); // true\n\ndoc.$timestamps(false);\nawait doc.save(); // Does **not** apply timestamps\n```\n\n### Document.prototype.$validate()\n\nAlias of [`.validate`](#Document.prototype.validate())\n\n### Document.prototype.$where\n\n##### Type:\n\n- «property»\n\nSet this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n\n#### [Example:](#example)\n\n``` javascript\n// Make sure `save()` never updates a soft deleted document.\nschema.pre('save', function() {\n  this.$where = { isDeleted: false };\n});\n```\n\n### Document.prototype.depopulate()\n\n##### Parameters:\n\n- `[path]` «String\\|Array\\[String\\]» Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\n\n##### Returns:\n\n- «Document» this\n\n##### See:\n\n- [Document.populate](#Document.prototype.populate())\n\nTakes a populated field and returns it to its unpopulated state.\n\n#### [Example:](#example)\n\n``` javascript\nModel.findOne().populate('author').exec(function (err, doc) {\n  console.log(doc.author.name); // Dr.Seuss\n  console.log(doc.depopulate('author'));\n  console.log(doc.author); // '5144cf8050f071d979c118a7'\n})\n```\n\nIf the path was not provided, then all populated fields are returned to their unpopulated state.\n\n### Document.prototype.directModifiedPaths()\n\n##### Returns:\n\n- «Array\\[String\\]»\n\nReturns the list of paths that have been directly modified. A direct modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`, `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n\nA path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()` because a child of `a` was directly modified.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ foo: String, nested: { bar: String } });\nconst Model = mongoose.model('Test', schema);\nawait Model.create({ foo: 'original', nested: { bar: 'original' } });\n\nconst doc = await Model.findOne();\ndoc.nested.bar = 'modified';\ndoc.directModifiedPaths(); // ['nested.bar']\ndoc.modifiedPaths(); // ['nested', 'nested.bar']\n```\n\n### Document.prototype.equals()\n\n##### Parameters:\n\n- `[doc]` «Document» a document to compare. If falsy, will always return \"false\".\n\n##### Returns:\n\n- «Boolean»\n\nReturns true if this document is equal to another document.\n\nDocuments are considered equal when they have matching `_id`s, unless neither document has an `_id`, in which case this function falls back to using `deepEqual()`.\n\n### Document.prototype.errors\n\n##### Type:\n\n- «property»\n\nHash containing current validation errors.\n\n### Document.prototype.get()\n\n##### Parameters:\n\n- `path` «String»\n- `[type]` «Schema\\|String\\|Number\\|Buffer\\|\\[object Object\\]» optionally specify a type for on-the-fly attributes\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.virtuals=false]` «Boolean» Apply virtuals before getting this path\n\n&nbsp;\n\n- `[options.getters=true]` «Boolean» If false, skip applying getters and just get the raw value\n\n##### Returns:\n\n- «Any»\n\nReturns the value of a path.\n\n#### [Example:](#example)\n\n``` javascript\n// path\ndoc.get('age') // 47\n\n// dynamic casting to a string\ndoc.get('age', String) // \"47\"\n```\n\n### Document.prototype.getChanges()\n\n##### Returns:\n\n- «Object»\n\nReturns the changes that happened to the document in the format that will be sent to MongoDB.\n\n#### [Example:](#example)\n\n``` javascript\nconst userSchema = new Schema({\n  name: String,\n  age: Number,\n  country: String\n});\nconst User = mongoose.model('User', userSchema);\nconst user = await User.create({\n  name: 'Hafez',\n  age: 25,\n  country: 'Egypt'\n});\n\n// returns an empty object, no changes happened yet\nuser.getChanges(); // { }\n\nuser.country = undefined;\nuser.age = 26;\n\nuser.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n\nawait user.save();\n\nuser.getChanges(); // { }\n```\n\nModifying the object that `getChanges()` returns does not affect the document's change tracking state. Even if you `delete user.getChanges().$set`, Mongoose will still send a `$set` to the server.\n\n### Document.prototype.id\n\n##### Type:\n\n- «property»\n\n##### See:\n\n- [Schema options](../guide#options)\n\nThe string version of this documents \\_id.\n\n#### [Note:](#note)\n\nThis getter exists on all documents by default. The getter can be disabled by setting the `id` [option](../guide#id) of its `Schema` to false at construction time.\n\n``` javascript\nnew Schema({ name: String }, { id: false });\n```\n\n### Document.prototype.init()\n\n##### Parameters:\n\n- `doc` «Object» document returned by mongo\n- `[opts]` «Object»\n- `[fn]` «Function»\n\nInitializes the document without setters or marking anything modified.\n\nCalled internally after a document is returned from mongodb. Normally, you do **not** need to call this function on your own.\n\nThis function triggers `init` [middleware](../middleware). Note that `init` hooks are [synchronous](../middleware#synchronous).\n\n### Document.prototype.inspect()\n\n##### Returns:\n\n- «String»\n\nHelper for console.log\n\n### Document.prototype.invalidate()\n\n##### Parameters:\n\n- `path` «String» the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n- `err` «String\\|Error» the error which states the reason `path` was invalid\n- `val` «Object\\|String\\|Number\\|any» optional invalid value\n- `[kind]` «String» optional `kind` property for the error\n\n##### Returns:\n\n- «ValidationError» the current ValidationError, with all currently invalidated paths\n\nMarks a path as invalid, causing validation to fail.\n\nThe `errorMsg` argument will become the message of the `ValidationError`.\n\nThe `value` argument (if passed) will be available through the `ValidationError.value` property.\n\n``` javascript\ndoc.invalidate('size', 'must be less than 20', 14);\n\ndoc.validate(function (err) {\n  console.log(err)\n  // prints\n  { message: 'Validation failed',\n    name: 'ValidationError',\n    errors:\n     { size:\n        { message: 'must be less than 20',\n          name: 'ValidatorError',\n          path: 'size',\n          type: 'user defined',\n          value: 14 } } }\n})\n```\n\n### Document.prototype.isDirectModified()\n\n##### Parameters:\n\n- `[path]` «String\\|Array\\[String\\]»\n\n##### Returns:\n\n- «Boolean»\n\nReturns true if `path` was directly set and modified, else false.\n\n#### [Example:](#example)\n\n``` javascript\ndoc.set('documents.0.title', 'changed');\ndoc.isDirectModified('documents.0.title') // true\ndoc.isDirectModified('documents') // false\n```\n\n### Document.prototype.isDirectSelected()\n\n##### Parameters:\n\n- `path` «String»\n\n##### Returns:\n\n- «Boolean»\n\nChecks if `path` was explicitly selected. If no projection, always returns true.\n\n#### [Example:](#example)\n\n``` javascript\nThing.findOne().select('nested.name').exec(function (err, doc) {\n   doc.isDirectSelected('nested.name') // true\n   doc.isDirectSelected('nested.otherName') // false\n   doc.isDirectSelected('nested')  // false\n})\n```\n\n### Document.prototype.isInit()\n\n##### Parameters:\n\n- `[path]` «String»\n\n##### Returns:\n\n- «Boolean»\n\nChecks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n\n### Document.prototype.isModified()\n\n##### Parameters:\n\n- `[path]` «String» optional\n\n##### Returns:\n\n- «Boolean»\n\nReturns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path in this document is modified.\n\nIf `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n\n#### [Example:](#example)\n\n``` javascript\ndoc.set('documents.0.title', 'changed');\ndoc.isModified()                      // true\ndoc.isModified('documents')           // true\ndoc.isModified('documents.0.title')   // true\ndoc.isModified('documents otherProp') // true\ndoc.isDirectModified('documents')     // false\n```\n\n### Document.prototype.isNew\n\n##### Type:\n\n- «property»\n\n##### See:\n\n- [$isNew](#Document.prototype.$isNew)\n\nLegacy alias for `$isNew`.\n\n### Document.prototype.isSelected()\n\n##### Parameters:\n\n- `path` «String\\|Array\\[String\\]»\n\n##### Returns:\n\n- «Boolean»\n\nChecks if `path` was selected in the source query which initialized this document.\n\n#### [Example:](#example)\n\n``` javascript\nconst doc = await Thing.findOne().select('name');\ndoc.isSelected('name') // true\ndoc.isSelected('age')  // false\n```\n\n### Document.prototype.markModified()\n\n##### Parameters:\n\n- `path` «String» the path to mark modified\n- `[scope]` «Document» the scope to run validators with\n\nMarks the path as having pending changes to write to the db.\n\n*Very helpful when using [Mixed](../schematypes#mixed) types.*\n\n#### [Example:](#example)\n\n``` javascript\ndoc.mixed.type = 'changed';\ndoc.markModified('mixed.type');\ndoc.save() // changes to mixed.type are now persisted\n```\n\n### Document.prototype.modifiedPaths()\n\n##### Parameters:\n\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.includeChildren=false]` «Boolean» if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n\n##### Returns:\n\n- «Array\\[String\\]»\n\nReturns the list of paths that have been modified.\n\n### Document.prototype.overwrite()\n\n##### Parameters:\n\n- `obj` «Object» the object to overwrite this document with\n\n##### Returns:\n\n- «Document» this\n\nOverwrite all values in this document with the values of `obj`, except for immutable properties. Behaves similarly to `set()`, except for it unsets all properties that aren't in `obj`.\n\n### Document.prototype.parent()\n\n##### Returns:\n\n- «Document»\n\nIf this document is a subdocument or populated document, returns the document's parent. Returns the original document if there is no parent.\n\n### Document.prototype.populate()\n\n##### Parameters:\n\n- `path` «String\\|Object\\|Array» either the path to populate or an object specifying all parameters, or either an array of those\n- `[select]` «Object\\|String» Field selection for the population query\n- `[model]` «Model» The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n- `[match]` «Object» Conditions for the population query\n- `[options]` «Object» Options for the population query (sort, etc)\n\n&nbsp;\n\n- `[options.path=null]` «String» The path to populate.\n\n&nbsp;\n\n- `[options.populate=null]` «string\\|PopulateOptions» Recursively populate paths in the populated documents. See [deep populate docs](../populate#deep-populate).\n\n&nbsp;\n\n- `[options.retainNullValues=false]` «boolean» by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n\n&nbsp;\n\n- `[options.getters=false]` «boolean» if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](../schematypes#schematype-options).\n\n&nbsp;\n\n- `[options.clone=false]` «boolean» When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n\n&nbsp;\n\n- `[options.match=null]` «Object\\|Function» Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n\n&nbsp;\n\n- `[options.transform=null]` «Function» Function that Mongoose will call on every populated document that allows you to transform the populated document.\n\n&nbsp;\n\n- `[options.options=null]` «Object» Additional options like `limit` and `lean`.\n\n&nbsp;\n\n- `[callback]` «Function» Callback\n\n##### Returns:\n\n- «Promise,null» Returns a Promise if no `callback` is given.\n\n##### See:\n\n- [population](../populate)\n- [Query#select](query#Query.prototype.select())\n- [Model.populate](model#Model.populate())\n\nPopulates paths on an existing document.\n\n#### [Example:](#example)\n\n``` javascript\n// Given a document, `populate()` lets you pull in referenced docs\nawait doc.populate([\n  'stories',\n  { path: 'fans', sort: { name: -1 } }\n]);\ndoc.populated('stories'); // Array of ObjectIds\ndoc.stories[0].title; // 'Casino Royale'\ndoc.populated('fans'); // Array of ObjectIds\n\n// If the referenced doc has been deleted, `populate()` will\n// remove that entry from the array.\nawait Story.delete({ title: 'Casino Royale' });\nawait doc.populate('stories'); // Empty array\n\n// You can also pass additional query options to `populate()`,\n// like projections:\nawait doc.populate('fans', '-email');\ndoc.fans[0].email // undefined because of 2nd param `select`\n```\n\n### Document.prototype.populated()\n\n##### Parameters:\n\n- `path` «String»\n- `[val]` «Any»\n- `[options]` «Object»\n\n##### Returns:\n\n- «Array,ObjectId,Number,Buffer,String,undefined,void»\n\nGets \\_id(s) used during population of the given `path`.\n\n#### [Example:](#example)\n\n``` javascript\nconst doc = await Model.findOne().populate('author');\n\nconsole.log(doc.author.name); // Dr.Seuss\nconsole.log(doc.populated('author')); // '5144cf8050f071d979c118a7'\n```\n\nIf the path was not populated, returns `undefined`.\n\n### Document.prototype.replaceOne()\n\n##### Parameters:\n\n- `doc` «Object»\n- `[options]` «Object»\n- `[callback]` «Function»\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Model.replaceOne](model#Model.replaceOne())\n\nSends a replaceOne command with this document `_id` as the query selector.\n\n#### [Valid options:](#valid-options)\n\n- same as in [Model.replaceOne](model#Model.replaceOne())\n\n### Document.prototype.save()\n\n##### Parameters:\n\n- `[options]` «Object» options optional options\n\n&nbsp;\n\n- `[options.session=null]` «Session» the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](#Document.prototype.$session()).\n\n&nbsp;\n\n- `[options.safe]` «Object» (DEPRECATED) overrides [schema's safe option](../guide#safe). Use the `w` option instead.\n\n&nbsp;\n\n- `[options.validateBeforeSave]` «Boolean» set to false to save without validating.\n\n&nbsp;\n\n- `[options.validateModifiedOnly=false]` «Boolean» If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n\n&nbsp;\n\n- `[options.w]` «Number\\|String» set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.j]` «Boolean» set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.wtimeout]` «Number» sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](../guide#writeConcern).\n\n&nbsp;\n\n- `[options.checkKeys=true]` «Boolean» the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://www.mongodb.com/docs/manual/reference/limits/#Restrictions-on-Field-Names)\n\n&nbsp;\n\n- `[options.timestamps=true]` «Boolean» if `false` and [timestamps](../guide#timestamps) are enabled, skip timestamps for this `save()`.\n\n&nbsp;\n\n- `[fn]` «Function» optional callback\n\n##### Returns:\n\n- «Promise,undefined,void» Returns undefined if used with callback or a Promise otherwise.\n\n##### See:\n\n- [middleware](../middleware)\n\nSaves this document by inserting a new document into the database if [document.isNew](#Document.prototype.isNew()) is `true`, or sends an [updateOne](#Document.prototype.updateOne()) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n\n#### [Example:](#example)\n\n``` javascript\nproduct.sold = Date.now();\nproduct = await product.save();\n```\n\nIf save is successful, the returned promise will fulfill with the document saved.\n\n#### [Example:](#example-1)\n\n``` javascript\nconst newProduct = await product.save();\nnewProduct === product; // true\n```\n\n### Document.prototype.schema\n\n##### Type:\n\n- «property»\n\nThe document's schema.\n\n### Document.prototype.set()\n\n##### Parameters:\n\n- `path` «String\\|Object» path or object of key/vals to set\n- `val` «Any» the value to set\n- `[type]` «Schema\\|String\\|Number\\|Buffer\\|\\[object Object\\]» optionally specify a type for \"on-the-fly\" attributes\n- `[options]` «Object» optionally specify options that modify the behavior of the set\n\n##### Returns:\n\n- «Document» this\n\nSets the value of a path, or many paths. Alias for [`.$set`](#Document.prototype.$set()).\n\n#### [Example:](#example)\n\n``` javascript\n// path, value\ndoc.set(path, value)\n\n// object\ndoc.set({\n    path  : value\n  , path2 : {\n       path  : value\n    }\n})\n\n// on-the-fly cast to number\ndoc.set(path, value, Number)\n\n// on-the-fly cast to string\ndoc.set(path, value, String)\n\n// changing strict mode behavior\ndoc.set(path, value, { strict: false });\n```\n\n### Document.prototype.toJSON()\n\n##### Parameters:\n\n- `options` «Object»\n\n&nbsp;\n\n- `[options.flattenMaps=true]` «Boolean» if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\n\n&nbsp;\n\n- `[options.flattenObjectIds=false]` «Boolean» if true, convert any ObjectIds in the result to 24 character hex strings.\n\n##### Returns:\n\n- «Object»\n\n##### See:\n\n- [Document#toObject](#Document.prototype.toObject())\n- [JSON.stringify() in JavaScript](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html)\n\nThe return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\n\nThis method accepts the same options as [Document#toObject](#Document.prototype.toObject()). To apply the options to every document of your schema by default, set your [schemas](schema#Schema()) `toJSON` option to the same argument.\n\n``` javascript\nschema.set('toJSON', { virtuals: true });\n```\n\nThere is one difference between `toJSON()` and `toObject()` options. When you call `toJSON()`, the [`flattenMaps` option](#Document.prototype.toObject()) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default. When you call `toObject()`, the `flattenMaps` option is `false` by default.\n\nSee [schema options](../guide#toJSON) for more information on setting `toJSON` option defaults.\n\n### Document.prototype.toObject()\n\n##### Parameters:\n\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.getters=false]` «Boolean» if true, apply all getters, including virtuals\n\n&nbsp;\n\n- `[options.virtuals=false]` «Boolean» if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n\n&nbsp;\n\n- `[options.aliases=true]` «Boolean» if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n\n&nbsp;\n\n- `[options.minimize=true]` «Boolean» if true, omit any empty objects from the output\n\n&nbsp;\n\n- `[options.transform=null]` «Function\\|null» if set, mongoose will call this function to allow you to transform the returned object\n\n&nbsp;\n\n- `[options.depopulate=false]` «Boolean» if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n\n&nbsp;\n\n- `[options.versionKey=true]` «Boolean» if false, exclude the version key (`__v` by default) from the output\n\n&nbsp;\n\n- `[options.flattenMaps=false]` «Boolean» if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n\n&nbsp;\n\n- `[options.flattenObjectIds=false]` «Boolean» if true, convert any ObjectIds in the result to 24 character hex strings.\n\n&nbsp;\n\n- `[options.useProjection=false]` «Boolean»\n  - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n\n##### Returns:\n\n- «Object» js object (not a POJO)\n\n##### See:\n\n- [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html)\n\nConverts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n\nBuffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.\n\n#### [Getters/Virtuals](#gettersvirtuals)\n\nExample of only applying path getters\n\n``` javascript\ndoc.toObject({ getters: true, virtuals: false })\n```\n\nExample of only applying virtual getters\n\n``` javascript\ndoc.toObject({ virtuals: true })\n```\n\nExample of applying both path and virtual getters\n\n``` javascript\ndoc.toObject({ getters: true })\n```\n\nTo apply these options to every document of your schema by default, set your [schemas](schema#Schema()) `toObject` option to the same argument.\n\n``` javascript\nschema.set('toObject', { virtuals: true })\n```\n\n#### [Transform:](#transform)\n\nWe may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n\nTransform functions receive three arguments\n\n``` javascript\nfunction (doc, ret, options) {}\n```\n\n- `doc` The mongoose document which is being converted\n- `ret` The plain object representation which has been converted\n- `options` The options in use (either schema options or the options passed inline)\n\n#### [Example:](#example)\n\n``` javascript\n// specify the transform schema option\nif (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  // remove the _id of every document before returning the result\n  delete ret._id;\n  return ret;\n}\n\n// without the transformation in the schema\ndoc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n\n// with the transformation\ndoc.toObject(); // { name: 'Wreck-it Ralph' }\n```\n\nWith transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n\n``` javascript\nif (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  return { movie: ret.name }\n}\n\n// without the transformation in the schema\ndoc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n\n// with the transformation\ndoc.toObject(); // { movie: 'Wreck-it Ralph' }\n```\n\n*Note: if a transform function returns `undefined`, the return value will be ignored.*\n\nTransformations may also be applied inline, overridding any transform set in the options:\n\n``` javascript\nfunction xform (doc, ret, options) {\n  return { inline: ret.name, custom: true }\n}\n\n// pass the transform as an inline option\ndoc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n```\n\nIf you want to skip transformations, use `transform: false`:\n\n``` javascript\nschema.options.toObject.hide = '_id';\nschema.options.toObject.transform = function (doc, ret, options) {\n  if (options.hide) {\n    options.hide.split(' ').forEach(function (prop) {\n      delete ret[prop];\n    });\n  }\n  return ret;\n}\n\nconst doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\ndoc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\ndoc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\ndoc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n```\n\nIf you pass a transform in `toObject()` options, Mongoose will apply the transform to [subdocuments](../subdocs) in addition to the top-level document. Similarly, `transform: false` skips transforms for all subdocuments. Note that this behavior is different for transforms defined in the schema: if you define a transform in `schema.options.toObject.transform`, that transform will **not** apply to subdocuments.\n\n``` javascript\nconst memberSchema = new Schema({ name: String, email: String });\nconst groupSchema = new Schema({ members: [memberSchema], name: String, email });\nconst Group = mongoose.model('Group', groupSchema);\n\nconst doc = new Group({\n  name: 'Engineering',\n  email: 'dev@mongoosejs.io',\n  members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n});\n\n// Removes `email` from both top-level document **and** array elements\n// { name: 'Engineering', members: [{ name: 'Val' }] }\ndoc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n```\n\nTransforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n\nSee [schema options](../guide#toObject) for some more details.\n\n*During save, no custom options are applied to the document before being sent to the database.*\n\n### Document.prototype.toString()\n\n##### Returns:\n\n- «String»\n\nHelper for console.log\n\n### Document.prototype.unmarkModified()\n\n##### Parameters:\n\n- `path` «String» the path to unmark modified\n\nClears the modified state on the specified path.\n\n#### [Example:](#example)\n\n``` javascript\ndoc.foo = 'bar';\ndoc.unmarkModified('foo');\ndoc.save(); // changes to foo will not be persisted\n```\n\n### Document.prototype.updateOne()\n\n##### Parameters:\n\n- `doc` «Object»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.lean]` «Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](query#Query.prototype.lean()) and the [Mongoose lean tutorial](../tutorials/lean).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[callback]` «Function»\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Model.updateOne](model#Model.updateOne)\n\nSends an updateOne command with this document `_id` as the query selector.\n\n#### [Example:](#example)\n\n``` javascript\nweirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n```\n\n#### [Valid options:](#valid-options)\n\n- same as in [Model.updateOne](model#Model.updateOne)\n\n### Document.prototype.validate()\n\n##### Parameters:\n\n- `[pathsToValidate]` «Array\\|String» list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n- `[options]` «Object» internal options\n\n&nbsp;\n\n- `[options.validateModifiedOnly=false]` «Boolean» if `true` mongoose validates only modified paths.\n\n&nbsp;\n\n- `[options.pathsToSkip]` «Array\\|string» list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n\n##### Returns:\n\n- «Promise» Returns a Promise.\n\nExecutes registered validation rules for this document.\n\n#### [Note:](#note)\n\nThis method is called `pre` save and if a validation rule is violated, [save](model#Model.prototype.save()) is aborted and the error is thrown.\n\n#### [Example:](#example)\n\n``` javascript\nawait doc.validate({ validateModifiedOnly: false, pathsToSkip: ['name', 'email']});\n```\n\n### Document.prototype.validateSync()\n\n##### Parameters:\n\n- `[pathsToValidate]` «Array\\|string» only validate the given paths\n- `[options]` «Object» options for validation\n\n&nbsp;\n\n- `[options.validateModifiedOnly=false]` «Boolean» If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n\n&nbsp;\n\n- `[options.pathsToSkip]` «Array\\|string» list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n\n##### Returns:\n\n- «ValidationError,undefined,void» ValidationError if there are errors during validation, or undefined if there is no error.\n\nExecutes registered validation rules (skipping asynchronous validators) for this document.\n\n#### [Note:](#note)\n\nThis method is useful if you need synchronous validation.\n\n#### [Example:](#example)\n\n``` javascript\nconst err = doc.validateSync();\nif (err) {\n  handleError(err);\n} else {\n  // validation passed\n}\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/document.html](https://mongoosejs.com/docs/api/document.html)"
- name: Document.prototype.$assertPopulated()
  id: api/document#Document.prototype.$assertPopulated()
  summary: null
  belongs_to: Document
  description: |-
    ### Document.prototype.$assertPopulated()

    ##### Parameters:

    - `path`«String\|Array\[String\]» path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.
    - `[values]`«Object» optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.

    ##### Returns:

    - «Document» this

    Throws an error if a given path is not populated

    #### [Example:](#example)

    ``` javascript
    const doc = await Model.findOne().populate('author');

    doc.$assertPopulated('author'); // does not throw
    doc.$assertPopulated('other path'); // throws an error

    // Manually populate and assert in one call. The following does
    // `doc.$set({ likes })` before asserting.
    doc.$assertPopulated('likes', { likes });
    ```
- name: Document.prototype.$clone()
  id: api/document#Document.prototype.$clone()
  summary: null
  belongs_to: Document
  description: |-
    ### Document.prototype.$clone()

    ##### Returns:

    - «Document» a copy of this document

    Returns a copy of this document with a deep clone of `_doc` and `$__`.
- name: Document.prototype.$errors
  id: api/document#Document.prototype.$errors
  summary: Hash containing current validation $errors
  belongs_to: Document
  description: |-
    ### Document.prototype.$errors

    ##### Type:

    - «property»

    Hash containing current validation $errors.
- name: Document.prototype.$getAllSubdocs()
  id: api/document#Document.prototype.$getAllSubdocs()
  summary: null
  belongs_to: Document
  description: |-
    ### Document.prototype.$getAllSubdocs()

    ##### Returns:

    - «Array»

    Get all subdocs (by bfs)
- name: Document.prototype.$getPopulatedDocs()
  id: api/document#Document.prototype.$getPopulatedDocs()
  summary: Gets all populated documents associated with this document
  belongs_to: Document
  description: |-
    ### Document.prototype.$getPopulatedDocs()

    ##### Returns:

    - «Array\[Document\]» array of populated documents. Empty array if there are no populated documents associated with this document.

    Gets all populated documents associated with this document.
- name: Document.prototype.$ignore()
  id: api/document#Document.prototype.$ignore()
  summary: Don't run validation on this path or persist changes to this path
  belongs_to: Document
  description: |-
    ### Document.prototype.$ignore()

    ##### Parameters:

    - `path`«String» the path to ignore

    Don't run validation on this path or persist changes to this path.

    #### [Example:](#example)

    ``` javascript
    doc.foo = null;
    doc.$ignore('foo');
    doc.save(); // changes to foo will not be persisted and validators won't be run
    ```
- name: Document.prototype.$inc()
  id: api/document#Document.prototype.$inc()
  summary: Increments the numeric value at path by the given val
  belongs_to: Document
  description: |-
    ### Document.prototype.$inc()

    ##### Parameters:

    - `path`«String\|Array» path or paths to update
    - `val`«Number» increment `path` by this value

    ##### Returns:

    - «Document» this

    Increments the numeric value at `path` by the given `val`. When you call `save()` on this document, Mongoose will send a [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/) as opposed to a `$set`.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ counter: Number });
    const Test = db.model('Test', schema);

    const doc = await Test.create({ counter: 0 });
    doc.$inc('counter', 2);
    await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB
    doc.counter; // 2

    doc.counter += 2;
    await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB
    ```
- name: Document.prototype.$init()
  id: api/document#Document.prototype.$init()
  summary: null
  belongs_to: Document
  description: |-
    ### Document.prototype.$init()

    Alias for [`.init`](#Document.prototype.init())
- name: Document.prototype.$isDefault()
  id: api/document#Document.prototype.$isDefault()
  summary: Checks if a path is set to its default
  belongs_to: Document
  description: |-
    ### Document.prototype.$isDefault()

    ##### Parameters:

    - `[path]` «String»

    ##### Returns:

    - «Boolean»

    Checks if a path is set to its default.

    #### [Example:](#example)

    ``` javascript
    MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });
    const m = new MyModel();
    m.$isDefault('name'); // true
    ```
- name: Document.prototype.$isDeleted()
  id: api/document#Document.prototype.$isDeleted()
  summary: Getter/setter, determines whether the document was removed or not
  belongs_to: Document
  description: |-
    ### Document.prototype.$isDeleted()

    ##### Parameters:

    - `[val]`«Boolean» optional, overrides whether mongoose thinks the doc is deleted

    ##### Returns:

    - «Boolean,Document» whether mongoose thinks this doc is deleted.

    Getter/setter, determines whether the document was removed or not.

    #### [Example:](#example)

    ``` javascript
    const product = await product.remove();
    product.$isDeleted(); // true
    product.remove(); // no-op, doesn't send anything to the db

    product.$isDeleted(false);
    product.$isDeleted(); // false
    product.remove(); // will execute a remove against the db
    ```
- name: Document.prototype.$isEmpty()
  id: api/document#Document.prototype.$isEmpty()
  summary: Returns true if the given path is nullish or only contains empty objects
  belongs_to: Document
  description: |-
    ### Document.prototype.$isEmpty()

    ##### Parameters:

    - `[path]` «String»

    ##### Returns:

    - «Boolean»

    Returns true if the given path is nullish or only contains empty objects. Useful for determining whether this subdoc will get stripped out by the [minimize option](../guide#minimize).

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ nested: { foo: String } });
    const Model = mongoose.model('Test', schema);
    const doc = new Model({});
    doc.$isEmpty('nested'); // true
    doc.nested.$isEmpty(); // true

    doc.nested.foo = 'bar';
    doc.$isEmpty('nested'); // false
    doc.nested.$isEmpty(); // false
    ```
- name: Document.prototype.$isModified()
  id: api/document#Document.prototype.$isModified()
  summary: null
  belongs_to: Document
  description: |-
    ### Document.prototype.$isModified()

    Alias of [`.isModified`](#Document.prototype.isModified())
- name: Document.prototype.$isNew
  id: api/document#Document.prototype.$isNew
  summary: Boolean flag specifying if the document is new
  belongs_to: Document
  description: |-
    ### Document.prototype.$isNew

    ##### Type:

    - «property»

    Boolean flag specifying if the document is new. If you create a document using `new`, this document will be considered "new". `$isNew` is how Mongoose determines whether `save()` should use `insertOne()` to create a new document or `updateOne()` to update an existing document.

    #### [Example:](#example)

    ``` javascript
    const user = new User({ name: 'John Smith' });
    user.$isNew; // true

    await user.save(); // Sends an `insertOne` to MongoDB
    ```

    On the other hand, if you load an existing document from the database using `findOne()` or another [query operation](../queries), `$isNew` will be false.

    #### [Example:](#example-1)

    ``` javascript
    const user = await User.findOne({ name: 'John Smith' });
    user.$isNew; // false
    ```

    Mongoose sets `$isNew` to `false` immediately after `save()` succeeds. That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run. In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.

    #### [Example:](#example-2)

    ``` javascript
    userSchema.post('save', function() {
      this.$isNew; // false
    });
    await User.create({ name: 'John Smith' });
    ```

    For subdocuments, `$isNew` is true if either the parent has `$isNew` set, or if you create a new subdocument.

    #### [Example:](#example-3)

    ``` javascript
    // Assume `Group` has a document array `users`const group = await Group.findOne();
    group.users[0].$isNew; // false

    group.users.push({ name: 'John Smith' });
    group.users[1].$isNew; // true
    ```
- name: Document.prototype.$locals
  id: api/document#Document.prototype.$locals
  summary: Empty object that you can use for storing properties on the document
  belongs_to: Document
  description: |-
    ### Document.prototype.$locals

    ##### Type:

    - «property»

    Empty object that you can use for storing properties on the document. This is handy for passing data to middleware without conflicting with Mongoose internals.

    #### [Example:](#example)

    ``` javascript
    schema.pre('save', function() {
      // Mongoose will set `isNew` to `false` if `save()` succeeds
      this.$locals.wasNew = this.isNew;
    });

    schema.post('save', function() {
      // Prints true if `isNew` was set before `save()`
      console.log(this.$locals.wasNew);
    });
    ```
- name: Document.prototype.$markValid()
  id: api/document#Document.prototype.$markValid()
  summary: Marks a path as valid, removing existing validation errors
  belongs_to: Document
  description: |-
    ### Document.prototype.$markValid()

    ##### Parameters:

    - `path`«String» the field to mark as valid

    Marks a path as valid, removing existing validation errors.
- name: Document.prototype.$op
  id: api/document#Document.prototype.$op
  summary: A string containing the current operation that Mongoose is executing on this document
  belongs_to: Document
  description: |-
    ### Document.prototype.$op

    ##### Type:

    - «property»

    A string containing the current operation that Mongoose is executing on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.

    #### [Example:](#example)

    ``` javascript
    const doc = new Model({ name: 'test' });
    doc.$op; // null

    const promise = doc.save();
    doc.$op; // 'save'

    await promise;
    doc.$op; // null
    ```
- name: Document.prototype.$parent()
  id: api/document#Document.prototype.$parent()
  summary: Alias for parent()
  belongs_to: Document
  description: |-
    ### Document.prototype.$parent()

    ##### Returns:

    - «Document»

    Alias for [`parent()`](#Document.prototype.parent()). If this document is a subdocument or populated document, returns the document's parent. Returns `undefined` otherwise.
- name: Document.prototype.$populated()
  id: api/document#Document.prototype.$populated()
  summary: Alias of .populated
  belongs_to: Document
  description: |-
    ### Document.prototype.$populated()

    Alias of [`.populated`](#Document.prototype.populated()).
- name: Document.prototype.$session()
  id: api/document#Document.prototype.$session()
  summary: Getter/setter around the session associated with this document
  belongs_to: Document
  description: |-
    ### Document.prototype.$session()

    ##### Parameters:

    - `[session]`«ClientSession» overwrite the current session

    ##### Returns:

    - «ClientSession»

    Getter/setter around the session associated with this document. Used to automatically set `session` if you `save()` a doc that you got from a query with an associated session.

    #### [Example:](#example)

    ``` javascript
    const session = MyModel.startSession();
    const doc = await MyModel.findOne().session(session);
    doc.$session() === session; // true
    doc.$session(null);
    doc.$session() === null; // true
    ```

    If this is a top-level document, setting the session propagates to all child docs.
- name: Document.prototype.$set()
  id: api/document#Document.prototype.$set()
  summary: '[options.merge=false]«Boolean» if true, setting a nested path will merge existing values rather than overwrite the whole object'
  belongs_to: Document
  description: |-
    ### Document.prototype.$set()

    ##### Parameters:

    - `path`«String\|Object» path or object of key/vals to set
    - `val`«Any» the value to set
    - `[type]`«Schema\|String\|Number\|Buffer\|\[object Object\]» optionally specify a type for "on-the-fly" attributes
    - `[options]`«Object» optionally specify options that modify the behavior of the set

    - `[options.merge=false]`«Boolean» if true, setting a [nested path](../subdocs#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`

    ##### Returns:

    - «Document» this

    Alias for `set()`, used internally to avoid conflicts
- name: Document.prototype.$timestamps()
  id: api/document#Document.prototype.$timestamps()
  summary: Getter/setter around whether this document will apply timestamps by default when using save() and bulkSave()
  belongs_to: Document
  description: |-
    ### Document.prototype.$timestamps()

    ##### Parameters:

    - `[value]`«Boolean» overwrite the current session

    ##### Returns:

    - «Document,boolean,undefined,void» When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset "undefined" will be used, otherwise will return "this"

    Getter/setter around whether this document will apply timestamps by default when using `save()` and `bulkSave()`.

    #### [Example:](#example)

    ``` javascript
    constTestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));
    const doc = new TestModel({ name: 'John Smith' });

    doc.$timestamps(); // true

    doc.$timestamps(false);
    await doc.save(); // Does **not** apply timestamps
    ```
- name: Document.prototype.$validate()
  id: api/document#Document.prototype.$validate()
  summary: null
  belongs_to: Document
  description: |-
    ### Document.prototype.$validate()

    Alias of [`.validate`](#Document.prototype.validate())
- name: Document.prototype.$where
  id: api/document#Document.prototype.$where
  summary: Set this property to add additional query filters when Mongoose saves this document and isNew is false
  belongs_to: Document
  description: |-
    ### Document.prototype.$where

    ##### Type:

    - «property»

    Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.

    #### [Example:](#example)

    ``` javascript
    // Make sure `save()` never updates a soft deleted document.
    schema.pre('save', function() {
      this.$where = { isDeleted: false };
    });
    ```
- name: Document.prototype.depopulate()
  id: api/document#Document.prototype.depopulate()
  summary: Takes a populated field and returns it to its unpopulated state
  belongs_to: Document
  description: |-
    ### Document.prototype.depopulate()

    ##### Parameters:

    - `[path]`«String\|Array\[String\]» Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.

    ##### Returns:

    - «Document» this

    ##### See:

    -  [Document.populate](#Document.prototype.populate())

    Takes a populated field and returns it to its unpopulated state.

    #### [Example:](#example)

    ``` javascript
    Model.findOne().populate('author').exec(function (err, doc) {
      console.log(doc.author.name); // Dr.Seuss
      console.log(doc.depopulate('author'));
      console.log(doc.author); // '5144cf8050f071d979c118a7'
    })
    ```

    If the path was not provided, then all populated fields are returned to their unpopulated state.
- name: Document.prototype.directModifiedPaths()
  id: api/document#Document.prototype.directModifiedPaths()
  summary: Returns the list of paths that have been directly modified
  belongs_to: Document
  description: |-
    ### Document.prototype.directModifiedPaths()

    ##### Returns:

    - «Array\[String\]»

    Returns the list of paths that have been directly modified. A direct modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`, `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.

    A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()` because a child of `a` was directly modified.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ foo: String, nested: { bar: String } });
    const Model = mongoose.model('Test', schema);
    await Model.create({ foo: 'original', nested: { bar: 'original' } });

    const doc = await Model.findOne();
    doc.nested.bar = 'modified';
    doc.directModifiedPaths(); // ['nested.bar']
    doc.modifiedPaths(); // ['nested', 'nested.bar']
    ```
- name: Document.prototype.equals()
  id: api/document#Document.prototype.equals()
  summary: Returns true if this document is equal to another document
  belongs_to: Document
  description: |-
    ### Document.prototype.equals()

    ##### Parameters:

    - `[doc]`«Document» a document to compare. If falsy, will always return "false".

    ##### Returns:

    - «Boolean»

    Returns true if this document is equal to another document.

    Documents are considered equal when they have matching `_id`s, unless neither document has an `_id`, in which case this function falls back to using `deepEqual()`.
- name: Document.prototype.errors
  id: api/document#Document.prototype.errors
  summary: Hash containing current validation errors
  belongs_to: Document
  description: |-
    ### Document.prototype.errors

    ##### Type:

    - «property»

    Hash containing current validation errors.
- name: Document.prototype.get()
  id: api/document#Document.prototype.get()
  summary: Returns the value of a path
  belongs_to: Document
  description: |-
    ### Document.prototype.get()

    ##### Parameters:

    - `path` «String»
    - `[type]`«Schema\|String\|Number\|Buffer\|\[object Object\]» optionally specify a type for on-the-fly attributes
    - `[options]` «Object»

    &nbsp;

    - `[options.virtuals=false]`«Boolean» Apply virtuals before getting this path

    &nbsp;

    - `[options.getters=true]`«Boolean» If false, skip applying getters and just get the raw value

    ##### Returns:

    - «Any»

    Returns the value of a path.

    #### [Example:](#example)

    ``` javascript
    // path
    doc.get('age') // 47

    // dynamic casting to a string
    doc.get('age', String) // "47"
    ```
- name: Document.prototype.getChanges()
  id: api/document#Document.prototype.getChanges()
  summary: Returns the changes that happened to the document in the format that will be sent to MongoDB
  belongs_to: Document
  description: |-
    ### Document.prototype.getChanges()

    ##### Returns:

    - «Object»

    Returns the changes that happened to the document in the format that will be sent to MongoDB.

    #### [Example:](#example)

    ``` javascript
    const userSchema = new Schema({
      name: String,
      age: Number,
      country: String
    });
    const User = mongoose.model('User', userSchema);
    const user = await User.create({
      name: 'Hafez',
      age: 25,
      country: 'Egypt'
    });

    // returns an empty object, no changes happened yet
    user.getChanges(); // { }

    user.country = undefined;
    user.age = 26;

    user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }

    await user.save();

    user.getChanges(); // { }
    ```

    Modifying the object that `getChanges()` returns does not affect the document's change tracking state. Even if you `delete user.getChanges().$set`, Mongoose will still send a `$set` to the server.
- name: Document.prototype.id
  id: api/document#Document.prototype.id
  summary: The string version of this documents _id
  belongs_to: Document
  description: |-
    ### Document.prototype.id

    ##### Type:

    - «property»

    ##### See:

    -  [Schema options](../guide#options)

    The string version of this documents \_id.

    #### [Note:](#note)

    This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](../guide#id) of its `Schema` to false at construction time.

    ``` javascript
    newSchema({ name: String }, { id: false });
    ```
- name: Document.prototype.init()
  id: api/document#Document.prototype.init()
  summary: Initializes the document without setters or marking anything modified
  belongs_to: Document
  description: |-
    ### Document.prototype.init()

    ##### Parameters:

    - `doc`«Object» document returned by mongo
    - `[opts]` «Object»
    - `[fn]` «Function»

    Initializes the document without setters or marking anything modified.

    Called internally after a document is returned from mongodb. Normally, you do **not** need to call this function on your own.

    This function triggers `init` [middleware](../middleware). Note that `init` hooks are [synchronous](../middleware#synchronous).
- name: Document.prototype.inspect()
  id: api/document#Document.prototype.inspect()
  summary: null
  belongs_to: Document
  description: |-
    ### Document.prototype.inspect()

    ##### Returns:

    - «String»

    Helper for console.log
- name: Document.prototype.invalidate()
  id: api/document#Document.prototype.invalidate()
  summary: Marks a path as invalid, causing validation to fail
  belongs_to: Document
  description: |-
    ### Document.prototype.invalidate()

    ##### Parameters:

    - `path`«String» the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.
    - `err`«String\|Error» the error which states the reason `path` was invalid
    - `val`«Object\|String\|Number\|any» optional invalid value
    - `[kind]`«String» optional `kind` property for the error

    ##### Returns:

    - «ValidationError» the current ValidationError, with all currently invalidated paths

    Marks a path as invalid, causing validation to fail.

    The `errorMsg` argument will become the message of the `ValidationError`.

    The `value` argument (if passed) will be available through the `ValidationError.value` property.

    ``` javascript
    doc.invalidate('size', 'must be less than 20', 14);

    doc.validate(function (err) {
      console.log(err)
      // prints
      { message: 'Validation failed',
        name: 'ValidationError',
        errors:
         { size:
            { message: 'must be less than 20',
              name: 'ValidatorError',
              path: 'size',
              type: 'user defined',
              value: 14 } } }
    })
    ```
- name: Document.prototype.isDirectModified()
  id: api/document#Document.prototype.isDirectModified()
  summary: Returns true if path was directly set and modified, else false
  belongs_to: Document
  description: |-
    ### Document.prototype.isDirectModified()

    ##### Parameters:

    - `[path]` «String\|Array\[String\]»

    ##### Returns:

    - «Boolean»

    Returns true if `path` was directly set and modified, else false.

    #### [Example:](#example)

    ``` javascript
    doc.set('documents.0.title', 'changed');
    doc.isDirectModified('documents.0.title') // true
    doc.isDirectModified('documents') // false
    ```
- name: Document.prototype.isDirectSelected()
  id: api/document#Document.prototype.isDirectSelected()
  summary: Checks if path was explicitly selected
  belongs_to: Document
  description: |-
    ### Document.prototype.isDirectSelected()

    ##### Parameters:

    - `path` «String»

    ##### Returns:

    - «Boolean»

    Checks if `path` was explicitly selected. If no projection, always returns true.

    #### [Example:](#example)

    ``` javascript
    Thing.findOne().select('nested.name').exec(function (err, doc) {
       doc.isDirectSelected('nested.name') // true
       doc.isDirectSelected('nested.otherName') // false
       doc.isDirectSelected('nested')  // false
    })
    ```
- name: Document.prototype.isInit()
  id: api/document#Document.prototype.isInit()
  summary: Checks if path is in the init state, that is, it was set by Document#init() and not modified since
  belongs_to: Document
  description: |-
    ### Document.prototype.isInit()

    ##### Parameters:

    - `[path]` «String»

    ##### Returns:

    - «Boolean»

    Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.
- name: Document.prototype.isModified()
  id: api/document#Document.prototype.isModified()
  summary: Returns true if any of the given paths is modified, else false
  belongs_to: Document
  description: |-
    ### Document.prototype.isModified()

    ##### Parameters:

    - `[path]`«String» optional

    ##### Returns:

    - «Boolean»

    Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path in this document is modified.

    If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.

    #### [Example:](#example)

    ``` javascript
    doc.set('documents.0.title', 'changed');
    doc.isModified()                      // true
    doc.isModified('documents')           // true
    doc.isModified('documents.0.title')   // true
    doc.isModified('documents otherProp') // true
    doc.isDirectModified('documents')     // false
    ```
- name: Document.prototype.isNew
  id: api/document#Document.prototype.isNew
  summary: Legacy alias for $isNew
  belongs_to: Document
  description: |-
    ### Document.prototype.isNew

    ##### Type:

    - «property»

    ##### See:

    -  [$isNew](#Document.prototype.$isNew)

    Legacy alias for `$isNew`.
- name: Document.prototype.isSelected()
  id: api/document#Document.prototype.isSelected()
  summary: Checks if path was selected in the source query which initialized this document
  belongs_to: Document
  description: |-
    ### Document.prototype.isSelected()

    ##### Parameters:

    - `path` «String\|Array\[String\]»

    ##### Returns:

    - «Boolean»

    Checks if `path` was selected in the source query which initialized this document.

    #### [Example:](#example)

    ``` javascript
    const doc = await Thing.findOne().select('name');
    doc.isSelected('name') // true
    doc.isSelected('age')  // false
    ```
- name: Document.prototype.markModified()
  id: api/document#Document.prototype.markModified()
  summary: Marks the path as having pending changes to write to the db
  belongs_to: Document
  description: |-
    ### Document.prototype.markModified()

    ##### Parameters:

    - `path`«String» the path to mark modified
    - `[scope]`«Document» the scope to run validators with

    Marks the path as having pending changes to write to the db.

    *Very helpful when using [Mixed](../schematypes#mixed) types.*

    #### [Example:](#example)

    ``` javascript
    doc.mixed.type = 'changed';
    doc.markModified('mixed.type');
    doc.save() // changes to mixed.type are now persisted
    ```
- name: Document.prototype.modifiedPaths()
  id: api/document#Document.prototype.modifiedPaths()
  summary: Returns the list of paths that have been modified
  belongs_to: Document
  description: |-
    ### Document.prototype.modifiedPaths()

    ##### Parameters:

    - `[options]` «Object»

    &nbsp;

    - `[options.includeChildren=false]`«Boolean» if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.

    ##### Returns:

    - «Array\[String\]»

    Returns the list of paths that have been modified.
- name: Document.prototype.overwrite()
  id: api/document#Document.prototype.overwrite()
  summary: Overwrite all values in this document with the values of obj, except for immutable properties
  belongs_to: Document
  description: |-
    ### Document.prototype.overwrite()

    ##### Parameters:

    - `obj`«Object» the object to overwrite this document with

    ##### Returns:

    - «Document» this

    Overwrite all values in this document with the values of `obj`, except for immutable properties. Behaves similarly to `set()`, except for it unsets all properties that aren't in `obj`.
- name: Document.prototype.parent()
  id: api/document#Document.prototype.parent()
  summary: If this document is a subdocument or populated document, returns the document's parent
  belongs_to: Document
  description: |-
    ### Document.prototype.parent()

    ##### Returns:

    - «Document»

    If this document is a subdocument or populated document, returns the document's parent. Returns the original document if there is no parent.
- name: Document.prototype.populate()
  id: api/document#Document.prototype.populate()
  summary: Populates paths on an existing document
  belongs_to: Document
  description: |-
    ### Document.prototype.populate()

    ##### Parameters:

    - `path`«String\|Object\|Array» either the path to populate or an object specifying all parameters, or either an array of those
    - `[select]`«Object\|String» Field selection for the population query
    - `[model]`«Model» The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.
    - `[match]`«Object» Conditions for the population query
    - `[options]`«Object» Options for the population query (sort, etc)

    &nbsp;

    - `[options.path=null]`«String» The path to populate.

    &nbsp;

    - `[options.populate=null]`«string\|PopulateOptions» Recursively populate paths in the populated documents. See [deep populate docs](../populate#deep-populate).

    &nbsp;

    - `[options.retainNullValues=false]`«boolean» by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.

    &nbsp;

    - `[options.getters=false]`«boolean» if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](../schematypes#schematype-options).

    &nbsp;

    - `[options.clone=false]`«boolean» When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.

    &nbsp;

    - `[options.match=null]`«Object\|Function» Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.

    &nbsp;

    - `[options.transform=null]`«Function» Function that Mongoose will call on every populated document that allows you to transform the populated document.

    &nbsp;

    - `[options.options=null]`«Object» Additional options like `limit` and `lean`.

    &nbsp;

    - `[callback]`«Function» Callback

    ##### Returns:

    - «Promise,null» Returns a Promise if no `callback` is given.

    ##### See:

    -  [population](../populate)
    -  [Query#select](query#Query.prototype.select())
    -  [Model.populate](model#Model.populate())

    Populates paths on an existing document.

    #### [Example:](#example)

    ``` javascript
    // Given a document, `populate()` lets you pull in referenced docsawait doc.populate([
      'stories',
      { path: 'fans', sort: { name: -1 } }
    ]);
    doc.populated('stories'); // Array of ObjectIds
    doc.stories[0].title; // 'Casino Royale'
    doc.populated('fans'); // Array of ObjectIds

    // If the referenced doc has been deleted, `populate()` will
    // remove that entry from the array.
    await Story.delete({ title: 'Casino Royale' });
    await doc.populate('stories'); // Empty array

    // You can also pass additional query options to `populate()`,
    // like projections:
    await doc.populate('fans', '-email');
    doc.fans[0].email // undefined because of 2nd param `select`
    ```
- name: Document.prototype.populated()
  id: api/document#Document.prototype.populated()
  summary: Gets _id(s) used during population of the given path
  belongs_to: Document
  description: |-
    ### Document.prototype.populated()

    ##### Parameters:

    - `path` «String»
    - `[val]` «Any»
    - `[options]` «Object»

    ##### Returns:

    - «Array,ObjectId,Number,Buffer,String,undefined,void»

    Gets \_id(s) used during population of the given `path`.

    #### [Example:](#example)

    ``` javascript
    const doc = await Model.findOne().populate('author');

    console.log(doc.author.name); // Dr.Seuss
    console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'
    ```

    If the path was not populated, returns `undefined`.
- name: Document.prototype.replaceOne()
  id: api/document#Document.prototype.replaceOne()
  summary: Sends a replaceOne command with this document _id as the query selector
  belongs_to: Document
  description: |-
    ### Document.prototype.replaceOne()

    ##### Parameters:

    - `doc` «Object»
    - `[options]` «Object»
    - `[callback]` «Function»

    ##### Returns:

    - «Query»

    ##### See:

    -  [Model.replaceOne](model#Model.replaceOne())

    Sends a replaceOne command with this document `_id` as the query selector.

    #### [Valid options:](#valid-options)

    - same as in [Model.replaceOne](model#Model.replaceOne())
- name: Document.prototype.save()
  id: api/document#Document.prototype.save()
  summary: Saves this document by inserting a new document into the database if document.isNew is true, or sends an updateOne operation only with the modifications to the database, it does not replace the whole document in the latter case
  belongs_to: Document
  description: |-
    ### Document.prototype.save()

    ##### Parameters:

    - `[options]`«Object» options optional options

    &nbsp;

    - `[options.session=null]`«Session» the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](#Document.prototype.$session()).

    &nbsp;

    - `[options.safe]`«Object» (DEPRECATED) overrides [schema's safe option](../guide#safe). Use the `w` option instead.

    &nbsp;

    - `[options.validateBeforeSave]`«Boolean» set to false to save without validating.

    &nbsp;

    - `[options.validateModifiedOnly=false]`«Boolean» If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.

    &nbsp;

    - `[options.w]`«Number\|String» set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](../guide#writeConcern)

    &nbsp;

    - `[options.j]`«Boolean» set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](../guide#writeConcern)

    &nbsp;

    - `[options.wtimeout]`«Number» sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](../guide#writeConcern).

    &nbsp;

    - `[options.checkKeys=true]`«Boolean» the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://www.mongodb.com/docs/manual/reference/limits/#Restrictions-on-Field-Names)

    &nbsp;

    - `[options.timestamps=true]`«Boolean» if `false` and [timestamps](../guide#timestamps) are enabled, skip timestamps for this `save()`.

    &nbsp;

    - `[fn]`«Function» optional callback

    ##### Returns:

    - «Promise,undefined,void» Returns undefined if used with callback or a Promise otherwise.

    ##### See:

    -  [middleware](../middleware)

    Saves this document by inserting a new document into the database if [document.isNew](#Document.prototype.isNew()) is `true`, or sends an [updateOne](#Document.prototype.updateOne()) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.

    #### [Example:](#example)

    ``` javascript
    product.sold = Date.now();
    product = await product.save();
    ```

    If save is successful, the returned promise will fulfill with the document saved.

    #### [Example:](#example-1)

    ``` javascript
    const newProduct = await product.save();
    newProduct === product; // true
    ```
- name: Document.prototype.schema
  id: api/document#Document.prototype.schema
  summary: The document's schema
  belongs_to: Document
  description: |-
    ### Document.prototype.schema

    ##### Type:

    - «property»

    The document's schema.
- name: Document.prototype.set()
  id: api/document#Document.prototype.set()
  summary: Sets the value of a path, or many paths
  belongs_to: Document
  description: |-
    ### Document.prototype.set()

    ##### Parameters:

    - `path`«String\|Object» path or object of key/vals to set
    - `val`«Any» the value to set
    - `[type]`«Schema\|String\|Number\|Buffer\|\[object Object\]» optionally specify a type for "on-the-fly" attributes
    - `[options]`«Object» optionally specify options that modify the behavior of the set

    ##### Returns:

    - «Document» this

    Sets the value of a path, or many paths. Alias for [`.$set`](#Document.prototype.$set()).

    #### [Example:](#example)

    ``` javascript
    // path, value
    doc.set(path, value)

    // object
    doc.set({
        path  : value
      , path2 : {
           path  : value
        }
    })

    // on-the-fly cast to number
    doc.set(path, value, Number)

    // on-the-fly cast to string
    doc.set(path, value, String)

    // changing strict mode behavior
    doc.set(path, value, { strict: false });
    ```
- name: Document.prototype.toJSON()
  id: api/document#Document.prototype.toJSON()
  summary: The return value of this method is used in calls to JSON.stringify(doc)
  belongs_to: Document
  description: |-
    ### Document.prototype.toJSON()

    ##### Parameters:

    - `options` «Object»

    &nbsp;

    - `[options.flattenMaps=true]`«Boolean» if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.

    &nbsp;

    - `[options.flattenObjectIds=false]`«Boolean» if true, convert any ObjectIds in the result to 24 character hex strings.

    ##### Returns:

    - «Object»

    ##### See:

    -  [Document#toObject](#Document.prototype.toObject())
    -  [JSON.stringify() in JavaScript](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html)

    The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).

    This method accepts the same options as [Document#toObject](#Document.prototype.toObject()). To apply the options to every document of your schema by default, set your [schemas](schema#Schema()) `toJSON` option to the same argument.

    ``` javascript
    schema.set('toJSON', { virtuals: true });
    ```

    There is one difference between `toJSON()` and `toObject()` options. When you call `toJSON()`, the [`flattenMaps` option](#Document.prototype.toObject()) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default. When you call `toObject()`, the `flattenMaps` option is `false` by default.

    See [schema options](../guide#toJSON) for more information on setting `toJSON` option defaults.
- name: Document.prototype.toObject()
  id: api/document#Document.prototype.toObject()
  summary: Converts this document into a plain-old JavaScript object (POJO)
  belongs_to: Document
  description: |-
    ### Document.prototype.toObject()

    ##### Parameters:

    - `[options]` «Object»

    &nbsp;

    - `[options.getters=false]`«Boolean» if true, apply all getters, including virtuals

    &nbsp;

    - `[options.virtuals=false]`«Boolean» if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals

    &nbsp;

    - `[options.aliases=true]`«Boolean» if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.

    &nbsp;

    - `[options.minimize=true]`«Boolean» if true, omit any empty objects from the output

    &nbsp;

    - `[options.transform=null]`«Function\|null» if set, mongoose will call this function to allow you to transform the returned object

    &nbsp;

    - `[options.depopulate=false]`«Boolean» if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.

    &nbsp;

    - `[options.versionKey=true]`«Boolean» if false, exclude the version key (`__v` by default) from the output

    &nbsp;

    - `[options.flattenMaps=false]`«Boolean» if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.

    &nbsp;

    - `[options.flattenObjectIds=false]`«Boolean» if true, convert any ObjectIds in the result to 24 character hex strings.

    &nbsp;

    - `[options.useProjection=false]` «Boolean»
      - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.

    ##### Returns:

    - «Object» js object (not a POJO)

    ##### See:

    -  [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html)

    Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).

    Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.

    #### [Getters/Virtuals](#gettersvirtuals)

    Example of only applying path getters

    ``` javascript
    doc.toObject({ getters: true, virtuals: false })
    ```

    Example of only applying virtual getters

    ``` javascript
    doc.toObject({ virtuals: true })
    ```

    Example of applying both path and virtual getters

    ``` javascript
    doc.toObject({ getters: true })
    ```

    To apply these options to every document of your schema by default, set your [schemas](schema#Schema()) `toObject` option to the same argument.

    ``` javascript
    schema.set('toObject', { virtuals: true })
    ```

    #### [Transform:](#transform)

    We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.

    Transform functions receive three arguments

    ``` javascript
    function (doc, ret, options) {}
    ```

    - `doc` The mongoose document which is being converted
    - `ret` The plain object representation which has been converted
    - `options` The options in use (either schema options or the options passed inline)

    #### [Example:](#example)

    ``` javascript
    // specify the transform schema optionif (!schema.options.toObject) schema.options.toObject = {};
    schema.options.toObject.transform = function (doc, ret, options) {
      // remove the _id of every document before returning the result
      delete ret._id;
      return ret;
    }

    // without the transformation in the schema
    doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }

    // with the transformation
    doc.toObject(); // { name: 'Wreck-it Ralph' }
    ```

    With transformations we can do a lot more than remove properties. We can even return completely new customized objects:

    ``` javascript
    if (!schema.options.toObject) schema.options.toObject = {};
    schema.options.toObject.transform = function (doc, ret, options) {
      return { movie: ret.name }
    }

    // without the transformation in the schema
    doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }

    // with the transformation
    doc.toObject(); // { movie: 'Wreck-it Ralph' }
    ```

    *Note: if a transform function returns `undefined`, the return value will be ignored.*

    Transformations may also be applied inline, overridding any transform set in the options:

    ``` javascript
    functionxform (doc, ret, options) {
      return { inline: ret.name, custom: true }
    }

    // pass the transform as an inline option
    doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }
    ```

    If you want to skip transformations, use `transform: false`:

    ``` javascript
    schema.options.toObject.hide = '_id';
    schema.options.toObject.transform = function (doc, ret, options) {
      if (options.hide) {
        options.hide.split(' ').forEach(function (prop) {
          delete ret[prop];
        });
      }
      return ret;
    }

    const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });
    doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }
    doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }
    doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }
    ```

    If you pass a transform in `toObject()` options, Mongoose will apply the transform to [subdocuments](../subdocs) in addition to the top-level document. Similarly, `transform: false` skips transforms for all subdocuments. Note that this behavior is different for transforms defined in the schema: if you define a transform in `schema.options.toObject.transform`, that transform will **not** apply to subdocuments.

    ``` javascript
    const memberSchema = new Schema({ name: String, email: String });
    const groupSchema = new Schema({ members: [memberSchema], name: String, email });
    const Group = mongoose.model('Group', groupSchema);

    const doc = new Group({
      name: 'Engineering',
      email: 'dev@mongoosejs.io',
      members: [{ name: 'Val', email: 'val@mongoosejs.io' }]
    });

    // Removes `email` from both top-level document **and** array elements
    // { name: 'Engineering', members: [{ name: 'Val' }] }
    doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });
    ```

    Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.

    See [schema options](../guide#toObject) for some more details.

    *During save, no custom options are applied to the document before being sent to the database.*
- name: Document.prototype.toString()
  id: api/document#Document.prototype.toString()
  summary: null
  belongs_to: Document
  description: |-
    ### Document.prototype.toString()

    ##### Returns:

    - «String»

    Helper for console.log
- name: Document.prototype.unmarkModified()
  id: api/document#Document.prototype.unmarkModified()
  summary: Clears the modified state on the specified path
  belongs_to: Document
  description: |-
    ### Document.prototype.unmarkModified()

    ##### Parameters:

    - `path`«String» the path to unmark modified

    Clears the modified state on the specified path.

    #### [Example:](#example)

    ``` javascript
    doc.foo = 'bar';
    doc.unmarkModified('foo');
    doc.save(); // changes to foo will not be persisted
    ```
- name: Document.prototype.updateOne()
  id: api/document#Document.prototype.updateOne()
  summary: Sends an updateOne command with this document _id as the query selector
  belongs_to: Document
  description: |-
    ### Document.prototype.updateOne()

    ##### Parameters:

    - `doc` «Object»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.lean]`«Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](query#Query.prototype.lean()) and the [Mongoose lean tutorial](../tutorials/lean).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[callback]` «Function»

    ##### Returns:

    - «Query»

    ##### See:

    -  [Model.updateOne](model#Model.updateOne)

    Sends an updateOne command with this document `_id` as the query selector.

    #### [Example:](#example)

    ``` javascript
    weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);
    ```

    #### [Valid options:](#valid-options)

    - same as in [Model.updateOne](model#Model.updateOne)
- name: Document.prototype.validate()
  id: api/document#Document.prototype.validate()
  summary: Executes registered validation rules for this document
  belongs_to: Document
  description: |-
    ### Document.prototype.validate()

    ##### Parameters:

    - `[pathsToValidate]`«Array\|String» list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.
    - `[options]`«Object» internal options

    &nbsp;

    - `[options.validateModifiedOnly=false]`«Boolean» if `true` mongoose validates only modified paths.

    &nbsp;

    - `[options.pathsToSkip]`«Array\|string» list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.

    ##### Returns:

    - «Promise» Returns a Promise.

    Executes registered validation rules for this document.

    #### [Note:](#note)

    This method is called `pre` save and if a validation rule is violated, [save](model#Model.prototype.save()) is aborted and the error is thrown.

    #### [Example:](#example)

    ``` javascript
    await doc.validate({ validateModifiedOnly: false, pathsToSkip: ['name', 'email']});
    ```
- name: Document.prototype.validateSync()
  id: api/document#Document.prototype.validateSync()
  summary: Executes registered validation rules (skipping asynchronous validators) for this document
  belongs_to: Document
  description: "### Document.prototype.validateSync()\n\n##### Parameters:\n\n- `[pathsToValidate]`«Array\\|string» only validate the given paths\n- `[options]`«Object» options for validation\n\n&nbsp;\n\n- `[options.validateModifiedOnly=false]`«Boolean» If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n\n&nbsp;\n\n- `[options.pathsToSkip]`«Array\\|string» list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n\n##### Returns:\n\n- «ValidationError,undefined,void» ValidationError if there are errors during validation, or undefined if there is no error.\n\nExecutes registered validation rules (skipping asynchronous validators) for this document.\n\n#### [Note:](#note)\n\nThis method is useful if you need synchronous validation.\n\n#### [Example:](#example)\n\n``` javascript\nconst err = doc.validateSync();\nif (err) {\n  handleError(err);\n} else {\n  // validation passed\n}\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/document.html](https://mongoosejs.com/docs/api/document.html)"
- name: DocumentArrayPath
  id: api/documentarraypath
  summary: Options for all document arrays
  description: "# DocumentArrayPath\n\n### DocumentArrayPath()\n\n##### Parameters:\n\n- `key` «String»\n- `schema` «Schema»\n- `options` «Object»\n- `schemaOptions` «Object»\n\n##### Inherits:\n\n- [«SchemaArray»](schemaarray)\n\nSubdocsArray SchemaType constructor\n\n### DocumentArrayPath.get()\n\n##### Parameters:\n\n- `getter` «Function»\n\n##### Returns:\n\n- «this»\n\n##### Type:\n\n- «property»\n\nAttaches a getter for all DocumentArrayPath instances\n\n### DocumentArrayPath.options\n\n##### Type:\n\n- «property»\n\nOptions for all document arrays.\n\n- `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n\n### DocumentArrayPath.prototype.discriminator()\n\n##### Parameters:\n\n- `name` «String»\n- `schema` «Schema» fields to add to the schema for instances of this sub-class\n- `[options]` «Object\\|string» If string, same as `options.value`.\n\n- `[options.value]` «String» the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n\n&nbsp;\n\n- `[options.clone=true]` «Boolean» By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n\n##### Returns:\n\n- «Function» the constructor Mongoose will use for creating instances of this discriminator model\n\n##### See:\n\n- [discriminators](../discriminators)\n\nAdds a discriminator to this document array.\n\n#### [Example:](#example)\n\n``` javascript\nconst shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\nconst schema = Schema({ shapes: [shapeSchema] });\n\nconst docArrayPath = parentSchema.path('shapes');\ndocArrayPath.discriminator('Circle', Schema({ radius: Number }));\n```\n\n### DocumentArrayPath.schemaName\n\n##### Type:\n\n- «property»\n\nThis schema type's name, to defend against minifiers that mangle function names.\n\n### DocumentArrayPath.set()\n\n##### Parameters:\n\n- `option` «String» The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n- `value` «Any» The value of the option you'd like to set.\n\n##### Returns:\n\n- «void,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all DocumentArray instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all numbers have option `min` equal to 0.\nmongoose.Schema.DocumentArray.set('_id', false);\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/documentarraypath.html](https://mongoosejs.com/docs/api/documentarraypath.html)"
- name: DocumentArrayPath()
  id: api/documentarraypath#DocumentArrayPath()
  summary: null
  belongs_to: DocumentArrayPath
  description: |-
    ### DocumentArrayPath()

    ##### Parameters:

    - `key` «String»
    - `schema` «Schema»
    - `options` «Object»
    - `schemaOptions` «Object»

    ##### Inherits:

    -  [«SchemaArray»](schemaarray)

    SubdocsArray SchemaType constructor
- name: DocumentArrayPath.get()
  id: api/documentarraypath#DocumentArrayPath.get()
  summary: null
  belongs_to: DocumentArrayPath
  description: |-
    ### DocumentArrayPath.get()

    ##### Parameters:

    - `getter` «Function»

    ##### Returns:

    - «this»

    ##### Type:

    - «property»

    Attaches a getter for all DocumentArrayPath instances
- name: DocumentArrayPath.options
  id: api/documentarraypath#DocumentArrayPath.options
  summary: Options for all document arrays
  belongs_to: DocumentArrayPath
  description: |-
    ### DocumentArrayPath.options

    ##### Type:

    - «property»

    Options for all document arrays.

    - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.
- name: DocumentArrayPath.prototype.discriminator()
  id: api/documentarraypath#DocumentArrayPath.prototype.discriminator()
  summary: '[options]«Object|string» If string, same as options.value'
  belongs_to: DocumentArrayPath
  description: |-
    ### DocumentArrayPath.prototype.discriminator()

    ##### Parameters:

    - `name` «String»
    - `schema`«Schema» fields to add to the schema for instances of this sub-class
    - `[options]`«Object\|string» If string, same as `options.value`.

    - `[options.value]`«String» the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.

    &nbsp;

    - `[options.clone=true]`«Boolean» By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.

    ##### Returns:

    - «Function» the constructor Mongoose will use for creating instances of this discriminator model

    ##### See:

    -  [discriminators](../discriminators)

    Adds a discriminator to this document array.

    #### [Example:](#example)

    ``` javascript
    const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });
    const schema = Schema({ shapes: [shapeSchema] });

    const docArrayPath = parentSchema.path('shapes');
    docArrayPath.discriminator('Circle', Schema({ radius: Number }));
    ```
- name: DocumentArrayPath.schemaName
  id: api/documentarraypath#DocumentArrayPath.schemaName
  summary: This schema type's name, to defend against minifiers that mangle function names
  belongs_to: DocumentArrayPath
  description: |-
    ### DocumentArrayPath.schemaName

    ##### Type:

    - «property»

    This schema type's name, to defend against minifiers that mangle function names.
- name: DocumentArrayPath.set()
  id: api/documentarraypath#DocumentArrayPath.set()
  summary: Sets a default option for all DocumentArray instances
  belongs_to: DocumentArrayPath
  description: "### DocumentArrayPath.set()\n\n##### Parameters:\n\n- `option`«String» The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n- `value`«Any» The value of the option you'd like to set.\n\n##### Returns:\n\n- «void,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all DocumentArray instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all numbers have option `min` equal to 0.\nmongoose.Schema.DocumentArray.set('_id', false);\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/documentarraypath.html](https://mongoosejs.com/docs/api/documentarraypath.html)"
- name: Documents
  id: documents
  summary: Mongoose documents represent a one-to-one mapping to documents as stored in MongoDB
  description: "# Documents\n\nMongoose [documents](api/document) represent a one-to-one mapping to documents as stored in MongoDB. Each document is an instance of its [Model](models).\n\n## Documents vs Models\n\n[Document](api/document#Document) and [Model](api/model#Model) are distinct classes in Mongoose. The Model class is a subclass of the Document class. When you use the [Model constructor](api/model#Model), you create a new document.\n\n``` javascript\nconst MyModel = mongoose.model('Test', new Schema({ name: String }));\nconst doc = new MyModel();\n\ndoc instanceof MyModel; // true\ndoc instanceof mongoose.Model; // true\ndoc instanceof mongoose.Document; // true\n```\n\nIn Mongoose, a \"document\" generally means an instance of a model. You should not have to create an instance of the Document class without going through a model.\n\n## Retrieving\n\nWhen you load documents from MongoDB using model functions like [`findOne()`](api/model#model_Model-findOne), you get a Mongoose document back.\n\n``` javascript\nconst doc = await MyModel.findOne();\n\ndoc instanceof MyModel; // true\ndoc instanceof mongoose.Model; // true\ndoc instanceof mongoose.Document; // true\n```\n\n## Updating Using `save()`\n\nMongoose documents track changes. You can modify a document using vanilla JavaScript assignments and Mongoose will convert it into [MongoDB update operators](https://www.mongodb.com/docs/manual/reference/operator/update/).\n\n``` javascript\ndoc.name = 'foo';\n\n// Mongoose sends an `updateOne({ _id: doc._id }, { $set: { name: 'foo' } })`\n// to MongoDB.\nawait doc.save();\n```\n\nThe `save()` method returns a promise. If `save()` succeeds, the promise resolves to the document that was saved.\n\n``` javascript\ndoc.save().then(savedDoc => {\n  savedDoc === doc; // true\n});\n```\n\nIf the document with the corresponding `_id` is not found, Mongoose will report a `DocumentNotFoundError`:\n\n``` javascript\nconst doc = await MyModel.findOne();\n\n// Delete the document so Mongoose won't be able to save changes\nawait MyModel.deleteOne({ _id: doc._id });\n\ndoc.name = 'foo';\nawait doc.save(); // Throws DocumentNotFoundError\n```\n\n## Updating Using Queries\n\nThe [`save()`](api/model#model_Model-save) function is generally the right way to update a document with Mongoose. With `save()`, you get full [validation](validation) and [middleware](middleware).\n\nFor cases when `save()` isn't flexible enough, Mongoose lets you create your own [MongoDB updates](https://www.mongodb.com/docs/manual/reference/operator/update/) with casting, [middleware](middleware#notes), and [limited validation](validation#update-validators).\n\n``` javascript\n// Update all documents in the `mymodels` collection\nawait MyModel.updateMany({}, { $set: { name: 'foo' } });\n```\n\n*Note that `update()`, `updateMany()`, `findOneAndUpdate()`, etc. do **not** execute `save()` middleware. If you need save middleware and full validation, first query for the document and then `save()` it.*\n\n## Validating\n\nDocuments are casted and validated before they are saved. Mongoose first casts values to the specified type and then validates them. Internally, Mongoose calls the document's [`validate()` method](api/document#document_Document-validate) before saving.\n\n``` javascript\nconst schema = new Schema({ name: String, age: { type: Number, min: 0 } });\nconst Person = mongoose.model('Person', schema);\n\nconst p = new Person({ name: 'foo', age: 'bar' });\n// Cast to Number failed for value \"bar\" at path \"age\"\nawait p.validate();\n\nconst p2 = new Person({ name: 'foo', age: -1 });\n// Path `age` (-1) is less than minimum allowed value (0).\nawait p2.validate();\n```\n\nMongoose also supports limited validation on updates using the [`runValidators` option](validation#update-validators). Mongoose casts parameters to query functions like `findOne()`, `updateOne()` by default. However, Mongoose does *not* run validation on query function parameters by default. You need to set `runValidators: true` for Mongoose to validate.\n\n``` javascript\n// Cast to number failed for value \"bar\" at path \"age\"\nawait Person.updateOne({}, { age: 'bar' });\n\n// Path `age` (-1) is less than minimum allowed value (0).\nawait Person.updateOne({}, { age: -1 }, { runValidators: true });\n```\n\nRead the [validation](validation) guide for more details.\n\n## Overwriting\n\nThere are 2 different ways to overwrite a document (replacing all keys in the document). One way is to use the [`Document#overwrite()` function](api/document#document_Document-overwrite) followed by `save()`.\n\n``` javascript\nconst doc = await Person.findOne({ _id });\n\n// Sets `name` and unsets all other properties\ndoc.overwrite({ name: 'Jean-Luc Picard' });\nawait doc.save();\n```\n\nThe other way is to use [`Model.replaceOne()`](api/model#model_Model-replaceOne).\n\n``` javascript\n// Sets `name` and unsets all other properties\nawait Person.replaceOne({ _id }, { name: 'Jean-Luc Picard' });\n```\n\n## Next Up\n\nNow that we've covered Documents, let's take a look at [Subdocuments](subdocs).\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/documents.html](https://mongoosejs.com/docs/documents.html)"
- name: Error
  id: api/error
  summary: MongooseError constructor
  description: "# Error\n\n### Error()\n\n##### Parameters:\n\n- `msg` «String» Error message\n\n##### Type:\n\n- «constructor»\n\n##### Inherits:\n\n- [«Error»](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error)\n\nMongooseError constructor. MongooseError is the base class for all Mongoose-specific errors.\n\n#### [Example:](#example)\n\n``` javascript\nconst Model = mongoose.model('Test', new mongoose.Schema({ answer: Number }));\nconst doc = new Model({ answer: 'not a number' });\nconst err = doc.validateSync();\n\nerr instanceof mongoose.Error.ValidationError; // true\n```\n\n### Error.CastError\n\n##### Type:\n\n- «property»\n\nAn instance of this error class will be returned when mongoose failed to cast a value.\n\n### Error.DivergentArrayError\n\n##### Type:\n\n- «property»\n\nAn instance of this error will be returned if you used an array projection and then modified the array in an unsafe way.\n\n### Error.DocumentNotFoundError\n\n##### Type:\n\n- «property»\n\nAn instance of this error class will be returned when `save()` fails because the underlying document was not found. The constructor takes one parameter, the conditions that mongoose passed to `updateOne()` when trying to update the document.\n\n### Error.MissingSchemaError\n\n##### Type:\n\n- «property»\n\nThrown when you try to access a model that has not been registered yet\n\n### Error.MongooseServerSelectionError\n\n##### Type:\n\n- «property»\n\nThrown when the MongoDB Node driver can't connect to a valid server to send an operation to.\n\n### Error.OverwriteModelError\n\n##### Type:\n\n- «property»\n\nThrown when a model with the given name was already registered on the connection. See [the FAQ about `OverwriteModelError`](https://mongoosejs.com/docs/faq.html#overwrite-model-error).\n\n### Error.ParallelSaveError\n\n##### Type:\n\n- «property»\n\nAn instance of this error class will be returned when you call `save()` multiple times on the same document in parallel. See the [FAQ](https://mongoosejs.com/docs/faq.html) for more information.\n\n### Error.StrictModeError\n\n##### Type:\n\n- «property»\n\nThrown when your try to pass values to model constructor that were not specified in schema or change immutable properties when `strict` mode is `\"throw\"`\n\n### Error.StrictPopulateError\n\n##### Type:\n\n- «property»\n\nAn instance of this error class will be returned when mongoose failed to populate with a path that is not existing.\n\n### Error.ValidationError\n\n##### Type:\n\n- «property»\n\nAn instance of this error class will be returned when [validation](../validation) failed. The `errors` property contains an object whose keys are the paths that failed and whose values are instances of CastError or ValidationError.\n\n### Error.ValidatorError\n\n##### Type:\n\n- «property»\n\nA `ValidationError` has a hash of `errors` that contain individual `ValidatorError` instances.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = Schema({ name: { type: String, required: true } });\nconst Model = mongoose.model('Test', schema);\nconst doc = new Model({});\n\n// Top-level error is a ValidationError, **not** a ValidatorError\nconst err = doc.validateSync();\nerr instanceof mongoose.Error.ValidationError; // true\n\n// A ValidationError `err` has 0 or more ValidatorErrors keyed by the\n// path in the `err.errors` property.\nerr.errors['name'] instanceof mongoose.Error.ValidatorError;\n\nerr.errors['name'].kind; // 'required'\nerr.errors['name'].path; // 'name'\nerr.errors['name'].value; // undefined\n```\n\nInstances of `ValidatorError` have the following properties:\n\n- `kind`: The validator's `type`, like `'required'` or `'regexp'`\n- `path`: The path that failed validation\n- `value`: The value that failed validation\n\n### Error.VersionError\n\n##### Type:\n\n- «property»\n\nAn instance of this error class will be returned when you call `save()` after the document in the database was changed in a potentially unsafe way. See the [`versionKey` option](../guide#versionKey) for more information.\n\n### Error.messages\n\n##### Type:\n\n- «property»\n\n##### See:\n\n- [Error.messages](#Error.messages)\n\nThe default built-in validator error messages.\n\n### Error.prototype.name\n\n##### Type:\n\n- «String»\n\nThe name of the error. The name uniquely identifies this Mongoose error. The possible values are:\n\n- `MongooseError`: general Mongoose error\n- `CastError`: Mongoose could not convert a value to the type defined in the schema path. May be in a `ValidationError` class' `errors` property.\n- `DivergentArrayError`: You attempted to `save()` an array that was modified after you loaded it with a `$elemMatch` or similar projection\n- `MissingSchemaError`: You tried to access a model with [`mongoose.model()`](mongoose#Mongoose.model()) that was not defined\n- `DocumentNotFoundError`: The document you tried to [`save()`](document#Document.prototype.save()) was not found\n- `ValidatorError`: error from an individual schema path's validator\n- `ValidationError`: error returned from [`validate()`](document#Document.prototype.validate()) or [`validateSync()`](document#Document.prototype.validateSync()). Contains zero or more `ValidatorError` instances in `.errors` property.\n- `MissingSchemaError`: You called `mongoose.Document()` without a schema\n- `ObjectExpectedError`: Thrown when you set a nested path to a non-object value with [strict mode set](../guide#strict).\n- `ObjectParameterError`: Thrown when you pass a non-object value to a function which expects an object as a paramter\n- `OverwriteModelError`: Thrown when you call [`mongoose.model()`](mongoose#Mongoose.model()) to re-define a model that was already defined.\n- `ParallelSaveError`: Thrown when you call [`save()`](model#Model.prototype.save()) on a document when the same document instance is already saving.\n- `StrictModeError`: Thrown when you set a path that isn't the schema and [strict mode](../guide#strict) is set to `throw`.\n- `VersionError`: Thrown when the [document is out of sync](../guide#versionKey)\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/error.html](https://mongoosejs.com/docs/api/error.html)"
- name: Error()
  id: api/error#Error()
  summary: MongooseError constructor
  belongs_to: Error
  description: |-
    ### Error()

    ##### Parameters:

    - `msg`«String» Error message

    ##### Type:

    - «constructor»

    ##### Inherits:

    -  [«Error»](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error)

    MongooseError constructor. MongooseError is the base class for all Mongoose-specific errors.

    #### [Example:](#example)

    ``` javascript
    constModel = mongoose.model('Test', new mongoose.Schema({ answer: Number }));
    const doc = new Model({ answer: 'not a number' });
    const err = doc.validateSync();

    err instanceof mongoose.Error.ValidationError; // true
    ```
- name: Error.CastError
  id: api/error#Error.CastError
  summary: An instance of this error class will be returned when mongoose failed to cast a value
  belongs_to: Error
  description: |-
    ### Error.CastError

    ##### Type:

    - «property»

    An instance of this error class will be returned when mongoose failed to cast a value.
- name: Error.DivergentArrayError
  id: api/error#Error.DivergentArrayError
  summary: An instance of this error will be returned if you used an array projection and then modified the array in an unsafe way
  belongs_to: Error
  description: |-
    ### Error.DivergentArrayError

    ##### Type:

    - «property»

    An instance of this error will be returned if you used an array projection and then modified the array in an unsafe way.
- name: Error.DocumentNotFoundError
  id: api/error#Error.DocumentNotFoundError
  summary: An instance of this error class will be returned when save() fails because the underlying document was not found
  belongs_to: Error
  description: |-
    ### Error.DocumentNotFoundError

    ##### Type:

    - «property»

    An instance of this error class will be returned when `save()` fails because the underlying document was not found. The constructor takes one parameter, the conditions that mongoose passed to `updateOne()` when trying to update the document.
- name: Error.messages
  id: api/error#Error.messages
  summary: The default built-in validator error messages
  belongs_to: Error
  description: |-
    ### Error.messages

    ##### Type:

    - «property»

    ##### See:

    -  [Error.messages](#Error.messages)

    The default built-in validator error messages.
- name: Error.MissingSchemaError
  id: api/error#Error.MissingSchemaError
  summary: null
  belongs_to: Error
  description: |-
    ### Error.MissingSchemaError

    ##### Type:

    - «property»

    Thrown when you try to access a model that has not been registered yet
- name: Error.MongooseServerSelectionError
  id: api/error#Error.MongooseServerSelectionError
  summary: Thrown when the MongoDB Node driver can't connect to a valid server to send an operation to
  belongs_to: Error
  description: |-
    ### Error.MongooseServerSelectionError

    ##### Type:

    - «property»

    Thrown when the MongoDB Node driver can't connect to a valid server to send an operation to.
- name: Error.OverwriteModelError
  id: api/error#Error.OverwriteModelError
  summary: Thrown when a model with the given name was already registered on the connection
  belongs_to: Error
  description: |-
    ### Error.OverwriteModelError

    ##### Type:

    - «property»

    Thrown when a model with the given name was already registered on the connection. See [the FAQ about `OverwriteModelError`](https://mongoosejs.com/docs/faq.html#overwrite-model-error).
- name: Error.ParallelSaveError
  id: api/error#Error.ParallelSaveError
  summary: An instance of this error class will be returned when you call save() multiple times on the same document in parallel
  belongs_to: Error
  description: |-
    ### Error.ParallelSaveError

    ##### Type:

    - «property»

    An instance of this error class will be returned when you call `save()` multiple times on the same document in parallel. See the [FAQ](https://mongoosejs.com/docs/faq.html) for more information.
- name: Error.prototype.name
  id: api/error#Error.prototype.name
  summary: The name of the error
  belongs_to: Error
  description: "### Error.prototype.name\n\n##### Type:\n\n- «String»\n\nThe name of the error. The name uniquely identifies this Mongoose error. The possible values are:\n\n- `MongooseError`: general Mongoose error\n- `CastError`: Mongoose could not convert a value to the type defined in the schema path. May be in a `ValidationError` class' `errors` property.\n- `DivergentArrayError`: You attempted to `save()` an array that was modified after you loaded it with a `$elemMatch` or similar projection\n- `MissingSchemaError`: You tried to access a model with [`mongoose.model()`](mongoose#Mongoose.model()) that was not defined\n- `DocumentNotFoundError`: The document you tried to [`save()`](document#Document.prototype.save()) was not found\n- `ValidatorError`: error from an individual schema path's validator\n- `ValidationError`: error returned from [`validate()`](document#Document.prototype.validate()) or [`validateSync()`](document#Document.prototype.validateSync()). Contains zero or more `ValidatorError` instances in `.errors` property.\n- `MissingSchemaError`: You called `mongoose.Document()` without a schema\n- `ObjectExpectedError`: Thrown when you set a nested path to a non-object value with [strict mode set](../guide#strict).\n- `ObjectParameterError`: Thrown when you pass a non-object value to a function which expects an object as a paramter\n- `OverwriteModelError`: Thrown when you call [`mongoose.model()`](mongoose#Mongoose.model()) to re-define a model that was already defined.\n- `ParallelSaveError`: Thrown when you call [`save()`](model#Model.prototype.save()) on a document when the same document instance is already saving.\n- `StrictModeError`: Thrown when you set a path that isn't the schema and [strict mode](../guide#strict) is set to `throw`.\n- `VersionError`: Thrown when the [document is out of sync](../guide#versionKey)\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/error.html](https://mongoosejs.com/docs/api/error.html)"
- name: Error.StrictModeError
  id: api/error#Error.StrictModeError
  summary: null
  belongs_to: Error
  description: |-
    ### Error.StrictModeError

    ##### Type:

    - «property»

    Thrown when your try to pass values to model constructor that were not specified in schema or change immutable properties when `strict` mode is `"throw"`
- name: Error.StrictPopulateError
  id: api/error#Error.StrictPopulateError
  summary: An instance of this error class will be returned when mongoose failed to populate with a path that is not existing
  belongs_to: Error
  description: |-
    ### Error.StrictPopulateError

    ##### Type:

    - «property»

    An instance of this error class will be returned when mongoose failed to populate with a path that is not existing.
- name: Error.ValidationError
  id: api/error#Error.ValidationError
  summary: An instance of this error class will be returned when validation failed
  belongs_to: Error
  description: |-
    ### Error.ValidationError

    ##### Type:

    - «property»

    An instance of this error class will be returned when [validation](../validation) failed. The `errors` property contains an object whose keys are the paths that failed and whose values are instances of CastError or ValidationError.
- name: Error.ValidatorError
  id: api/error#Error.ValidatorError
  summary: A ValidationError has a hash of errors that contain individual ValidatorError instances
  belongs_to: Error
  description: |-
    ### Error.ValidatorError

    ##### Type:

    - «property»

    A `ValidationError` has a hash of `errors` that contain individual `ValidatorError` instances.

    #### [Example:](#example)

    ``` javascript
    const schema = Schema({ name: { type: String, required: true } });
    const Model = mongoose.model('Test', schema);
    const doc = new Model({});

    // Top-level error is a ValidationError, **not** a ValidatorError
    const err = doc.validateSync();
    err instanceof mongoose.Error.ValidationError; // true

    // A ValidationError `err` has 0 or more ValidatorErrors keyed by the
    // path in the `err.errors` property.
    err.errors['name'] instanceof mongoose.Error.ValidatorError;

    err.errors['name'].kind; // 'required'
    err.errors['name'].path; // 'name'
    err.errors['name'].value; // undefined
    ```

    Instances of `ValidatorError` have the following properties:

    - `kind`: The validator's `type`, like `'required'` or `'regexp'`
    - `path`: The path that failed validation
    - `value`: The value that failed validation
- name: Error.VersionError
  id: api/error#Error.VersionError
  summary: An instance of this error class will be returned when you call save() after the document in the database was changed in a potentially unsafe way
  belongs_to: Error
  description: |-
    ### Error.VersionError

    ##### Type:

    - «property»

    An instance of this error class will be returned when you call `save()` after the document in the database was changed in a potentially unsafe way. See the [`versionKey` option](../guide#versionKey) for more information.
- name: 'Example:'
  id: api/schematype#example
  summary: null
  belongs_to: Schematype
  description: |-
    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ name: String });
    schema.path('name') instanceof SchemaType; // true
    ```
- name: Faster Mongoose Queries With Lean
  id: tutorials/lean
  summary: The lean option tells Mongoose to skip hydrating the result documents
  description: "# Faster Mongoose Queries With Lean\n\nThe [lean option](../api/query#query_Query-lean) tells Mongoose to skip [hydrating](../api/model#model_Model-hydrate) the result documents. This makes queries faster and less memory intensive, but the result documents are plain old JavaScript objects (POJOs), **not** [Mongoose documents](../documents). In this tutorial, you'll learn more about the tradeoffs of using `lean()`.\n\n- [Using Lean](#using-lean)\n- [Lean and Populate](#lean-and-populate)\n- [When to Use Lean](#when-to-use-lean)\n- [Plugins](#plugins)\n- [BigInts](#bigints)\n\n## Using Lean\n\nBy default, Mongoose queries return an instance of the [Mongoose `Document` class](../api/document#Document). Documents are much heavier than vanilla JavaScript objects, because they have a lot of internal state for change tracking. Enabling the `lean` option tells Mongoose to skip instantiating a full Mongoose document and just give you the POJO.\n\n``` javascript\nconst leanDoc = await MyModel.findOne().lean();\n```\n\nHow much smaller are lean documents? Here's a comparison.\n\n``` javascript\nconst schema = new mongoose.Schema({ name: String });\nconst MyModel = mongoose.model('Test', schema);\n\nawait MyModel.create({ name: 'test' });\n\nconst normalDoc = await MyModel.findOne();\n// To enable the `lean` option for a query, use the `lean()` function.\nconst leanDoc = await MyModel.findOne().lean();\n\nv8Serialize(normalDoc).length; // approximately 180\nv8Serialize(leanDoc).length; // 32, about 5x smaller!\n\n// In case you were wondering, the JSON form of a Mongoose doc is the same\n// as the POJO. This additional memory only affects how much memory your\n// Node.js process uses, not how much data is sent over the network.\nJSON.stringify(normalDoc).length === JSON.stringify(leanDoc).length; // true\n```\n\nUnder the hood, after executing a query, Mongoose converts the query results from POJOs to Mongoose documents. If you turn on the `lean` option, Mongoose skips this step.\n\n``` javascript\nconst normalDoc = await MyModel.findOne();\nconst leanDoc = await MyModel.findOne().lean();\n\nnormalDoc instanceof mongoose.Document; // true\nnormalDoc.constructor.name; // 'model'\n\nleanDoc instanceof mongoose.Document; // false\nleanDoc.constructor.name; // 'Object'\n```\n\nThe downside of enabling `lean` is that lean docs don't have:\n\n- Change tracking\n- Casting and validation\n- Getters and setters\n- Virtuals\n- `save()`\n\nFor example, the following code sample shows that the `Person` model's getters and virtuals don't run if you enable `lean`.\n\n``` javascript\n// Define a `Person` model. Schema has 2 custom getters and a `fullName`\n// virtual. Neither the getters nor the virtuals will run if lean is enabled.\nconst personSchema = new mongoose.Schema({\n  firstName: {\n    type: String,\n    get: capitalizeFirstLetter\n  },\n  lastName: {\n    type: String,\n    get: capitalizeFirstLetter\n  }\n});\npersonSchema.virtual('fullName').get(function() {\n  return `${this.firstName} ${this.lastName}`;\n});\nfunction capitalizeFirstLetter(v) {\n  // Convert 'bob' -> 'Bob'\n  return v.charAt(0).toUpperCase() + v.substring(1);\n}\nconst Person = mongoose.model('Person', personSchema);\n\n// Create a doc and load it as a lean doc\nawait Person.create({ firstName: 'benjamin', lastName: 'sisko' });\nconst normalDoc = await Person.findOne();\nconst leanDoc = await Person.findOne().lean();\n\nnormalDoc.fullName; // 'Benjamin Sisko'\nnormalDoc.firstName; // 'Benjamin', because of `capitalizeFirstLetter()`\nnormalDoc.lastName; // 'Sisko', because of `capitalizeFirstLetter()`\n\nleanDoc.fullName; // undefined\nleanDoc.firstName; // 'benjamin', custom getter doesn't run\nleanDoc.lastName; // 'sisko', custom getter doesn't run\n```\n\n## Lean and Populate\n\n[Populate](../populate) works with `lean()`. If you use both `populate()` and `lean()`, the `lean` option propagates to the populated documents as well. In the below example, both the top-level 'Group' documents and the populated 'Person' documents will be lean.\n\n``` javascript\n// Create models\nconst Group = mongoose.model('Group', new mongoose.Schema({\n  name: String,\n  members: [{ type: mongoose.ObjectId, ref: 'Person' }]\n}));\nconst Person = mongoose.model('Person', new mongoose.Schema({\n  name: String\n}));\n\n// Initialize data\nconst people = await Person.create([\n  { name: 'Benjamin Sisko' },\n  { name: 'Kira Nerys' }\n]);\nawait Group.create({\n  name: 'Star Trek: Deep Space Nine Characters',\n  members: people.map(p => p._id)\n});\n\n// Execute a lean query\nconst group = await Group.findOne().lean().populate('members');\ngroup.members[0].name; // 'Benjamin Sisko'\ngroup.members[1].name; // 'Kira Nerys'\n\n// Both the `group` and the populated `members` are lean.\ngroup instanceof mongoose.Document; // false\ngroup.members[0] instanceof mongoose.Document; // false\ngroup.members[1] instanceof mongoose.Document; // false\n```\n\n[Virtual populate](../populate#populate-virtuals) also works with lean.\n\n``` javascript\n// Create models\nconst groupSchema = new mongoose.Schema({ name: String });\ngroupSchema.virtual('members', {\n  ref: 'Person',\n  localField: '_id',\n  foreignField: 'groupId'\n});\nconst Group = mongoose.model('Group', groupSchema);\nconst Person = mongoose.model('Person', new mongoose.Schema({\n  name: String,\n  groupId: mongoose.ObjectId\n}));\n\n// Initialize data\nconst g = await Group.create({ name: 'DS9 Characters' });\nawait Person.create([\n  { name: 'Benjamin Sisko', groupId: g._id },\n  { name: 'Kira Nerys', groupId: g._id }\n]);\n\n// Execute a lean query\nconst group = await Group.findOne().lean().populate({\n  path: 'members',\n  options: { sort: { name: 1 } }\n});\ngroup.members[0].name; // 'Benjamin Sisko'\ngroup.members[1].name; // 'Kira Nerys'\n\n// Both the `group` and the populated `members` are lean.\ngroup instanceof mongoose.Document; // false\ngroup.members[0] instanceof mongoose.Document; // false\ngroup.members[1] instanceof mongoose.Document; // false\n```\n\n## When to Use Lean\n\nIf you're executing a query and sending the results without modification to, say, an [Express response](http://expressjs.com/en/4x/api.html#res), you should use lean. In general, if you do not modify the query results and do not use [custom getters](../api/schematype#schematype_SchemaType-get), you should use `lean()`. If you modify the query results or rely on features like getters or [transforms](../api/document#document_Document-toObject), you should not use `lean()`.\n\nBelow is an example of an [Express route](http://expressjs.com/en/guide/routing.html) that is a good candidate for `lean()`. This route does not modify the `person` doc and doesn't rely on any Mongoose-specific functionality.\n\n``` javascript\n// As long as you don't need any of the Person model's virtuals or getters,\n// you can use `lean()`.\napp.get('/person/:id', function(req, res) {\n  Person.findOne({ _id: req.params.id }).lean().\n    then(person => res.json({ person })).\n    catch(error => res.json({ error: error.message }));\n});\n```\n\nBelow is an example of an Express route that should **not** use `lean()`. As a general rule of thumb, `GET` routes are good candidates for `lean()` in a [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer). On the other hand, `PUT`, `POST`, etc. routes generally should not use `lean()`.\n\n``` javascript\n// This route should **not** use `lean()`, because lean means no `save()`.\napp.put('/person/:id', function(req, res) {\n  Person.findOne({ _id: req.params.id }).\n    then(person => {\n      assert.ok(person);\n      Object.assign(person, req.body);\n      return person.save();\n    }).\n    then(person => res.json({ person })).\n    catch(error => res.json({ error: error.message }));\n});\n```\n\nRemember that virtuals do **not** end up in `lean()` query results. Use the [mongoose-lean-virtuals plugin](http://plugins.mongoosejs.io/plugins/lean-virtuals) to add virtuals to your lean query results.\n\n## Plugins\n\nUsing `lean()` bypasses all Mongoose features, including [virtuals](virtuals), [getters/setters](getters-setters), and [defaults](../api/schematype#schematype_SchemaType-default). If you want to use these features with `lean()`, you need to use the corresponding plugin:\n\n- [mongoose-lean-virtuals](https://plugins.mongoosejs.io/plugins/lean-virtuals)\n- [mongoose-lean-getters](https://plugins.mongoosejs.io/plugins/lean-getters)\n- [mongoose-lean-defaults](https://www.npmjs.com/package/mongoose-lean-defaults)\n\nHowever, you need to keep in mind that Mongoose does not hydrate lean documents, so `this` will be a POJO in virtuals, getters, and default functions.\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.plugin(require('mongoose-lean-virtuals'));\n\nschema.virtual('lowercase', function() {\n  this instanceof mongoose.Document; // false\n\n  this.name; // Works\n  this.get('name'); // Crashes because `this` is not a Mongoose document.\n});\n```\n\n## BigInts\n\nBy default, the MongoDB Node driver converts longs stored in MongoDB into JavaScript numbers, **not** [BigInts](https://thecodebarbarian.com/an-overview-of-bigint-in-node-js.html). Set the `useBigInt64` option on your `lean()` queries to inflate longs into BigInts.\n\n``` javascript\nconst Person = mongoose.model('Person', new mongoose.Schema({\n  name: String,\n  age: BigInt\n}));\n// Mongoose will convert `age` to a BigInt\nconst { age } = await Person.create({ name: 'Benjamin Sisko', age: 37 });\ntypeof age; // 'bigint'\n\n// By default, if you store a document with a BigInt property in MongoDB and you\n// load the document with `lean()`, the BigInt property will be a number\nlet person = await Person.findOne({ name: 'Benjamin Sisko' }).lean();\ntypeof person.age; // 'number'\n\n// Set the `useBigInt64` option to opt in to converting MongoDB longs to BigInts.\nperson = await Person.findOne({ name: 'Benjamin Sisko' }).\n  setOptions({ useBigInt64: true }).\n  lean();\ntypeof person.age; // 'bigint'\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/tutorials/lean.html](https://mongoosejs.com/docs/tutorials/lean.html)"
- name: Getters/Setters in Mongoose
  id: tutorials/getters-setters
  summary: Mongoose getters and setters allow you to execute custom logic when getting or setting a property on a Mongoose document
  description: "# Getters/Setters in Mongoose\n\nMongoose getters and setters allow you to execute custom logic when getting or setting a property on a [Mongoose document](../documents). Getters let you transform data in MongoDB into a more user friendly form, and setters let you transform user data before it gets to MongoDB.\n\n## Getters\n\nSuppose you have a `User` collection and you want to obfuscate user emails to protect your users' privacy. Below is a basic `userSchema` that obfuscates the user's email address.\n\n``` javascript\nconst userSchema = new Schema({\n  email: {\n    type: String,\n    get: obfuscate\n  }\n});\n\n// Mongoose passes the raw value in MongoDB `email` to the getter\nfunction obfuscate(email) {\n  const separatorIndex = email.indexOf('@');\n  if (separatorIndex < 3) {\n    // 'ab@gmail.com' -> '**@gmail.com'\n    return email.slice(0, separatorIndex).replace(/./g, '*') +\n      email.slice(separatorIndex);\n  }\n  // 'test42@gmail.com' -> 'te****@gmail.com'\n  return email.slice(0, 2) +\n    email.slice(2, separatorIndex).replace(/./g, '*') +\n    email.slice(separatorIndex);\n}\n\nconst User = mongoose.model('User', userSchema);\nconst user = new User({ email: 'ab@gmail.com' });\nuser.email; // **@gmail.com\n```\n\nKeep in mind that getters do **not** impact the underlying data stored in MongoDB. If you save `user`, the `email` property will be '<ab@gmail.com>' in the database.\n\nBy default, Mongoose does **not** execute getters when converting a document to JSON, including [Express' `res.json()` function](http://expressjs.com/en/4x/api.html#res.json).\n\n``` javascript\napp.get(function(req, res) {\n  return User.findOne().\n    // The `email` getter will NOT run here\n    then(doc => res.json(doc)).\n    catch(err => res.status(500).json({ message: err.message }));\n});\n```\n\nTo run getters when converting a document to JSON, set the [`toJSON.getters` option to `true` in your schema](../guide#toJSON) as shown below.\n\n``` javascript\nconst userSchema = new Schema({\n  email: {\n    type: String,\n    get: obfuscate\n  }\n}, { toJSON: { getters: true } });\n\n// Or, globally\nmongoose.set('toJSON', { getters: true });\n\n// Or, on a one-off basis\napp.get(function(req, res) {\n  return User.findOne().\n    // The `email` getter will run here\n    then(doc => res.json(doc.toJSON({ getters: true }))).\n    catch(err => res.status(500).json({ message: err.message }));\n});\n```\n\nTo skip getters on a one-off basis, use [`user.get()` with the `getters` option set to `false`](../api/document#document_Document-get) as shown below.\n\n``` javascript\nuser.get('email', null, { getters: false }); // 'ab@gmail.com'\n```\n\n## Setters\n\nSuppose you want to make sure all user emails in your database are lowercased to make it easy to search without worrying about case. Below is an example `userSchema` that ensures emails are lowercased.\n\n``` javascript\nconst userSchema = new Schema({\n  email: {\n    type: String,\n    set: v => v.toLowerCase()\n  }\n});\n\nconst User = mongoose.model('User', userSchema);\n\nconst user = new User({ email: 'TEST@gmail.com' });\nuser.email; // 'test@gmail.com'\n\n// The raw value of `email` is lowercased\nuser.get('email', null, { getters: false }); // 'test@gmail.com'\n\nuser.set({ email: 'NEW@gmail.com' });\nuser.email; // 'new@gmail.com'\n```\n\nMongoose also runs setters on update operations, like [`updateOne()`](../api/query#query_Query-updateOne). Mongoose will [upsert a document](https://masteringjs.io/tutorials/mongoose/upsert) with a lowercased `email` in the below example.\n\n``` javascript\nawait User.updateOne({}, { email: 'TEST@gmail.com' }, { upsert: true });\n\nconst doc = await User.findOne();\ndoc.email; // 'test@gmail.com'\n```\n\nIn a setter function, `this` can be either the document being set or the query being run. If you don't want your setter to run when you call `updateOne()`, you add an if statement that checks if `this` is a Mongoose document as shown below.\n\n``` javascript\nconst userSchema = new Schema({\n  email: {\n    type: String,\n    set: toLower\n  }\n});\n\nfunction toLower(email) {\n  // Don't transform `email` if using `updateOne()` or `updateMany()`\n  if (!(this instanceof mongoose.Document)) {\n    return email;\n  }\n  return email.toLowerCase();\n}\n\nconst User = mongoose.model('User', userSchema);\nawait User.updateOne({}, { email: 'TEST@gmail.com' }, { upsert: true });\n\nconst doc = await User.findOne();\ndoc.email; // 'TEST@gmail.com'\n```\n\n## Passing Parameters using `$locals`\n\nYou can't pass parameters to your getter and setter functions like you do to normal function calls. To configure or pass additional properties to your getters and setters, you can use the document's `$locals` property.\n\nThe `$locals` property is the preferred place to store any program-defined data on your document without conflicting with schema-defined properties. In your getter and setter functions, `this` is the document being accessed, so you set properties on `$locals` and then access those properties in your getters examples. For example, the following shows how you can use `$locals` to configure the language for a custom getter that returns a string in different languages.\n\n``` javascript\nconst internationalizedStringSchema = new Schema({\n  en: String,\n  es: String\n});\n\nconst ingredientSchema = new Schema({\n  // Instead of setting `name` to just a string, set `name` to a map\n  // of language codes to strings.\n  name: {\n    type: internationalizedStringSchema,\n    // When you access `name`, pull the document's locale\n    get: function(value) {\n      return value[this.$locals.language || 'en'];\n    }\n  }\n});\n\nconst recipeSchema = new Schema({\n  ingredients: [{ type: mongoose.ObjectId, ref: 'Ingredient' }]\n});\n\nconst Ingredient = mongoose.model('Ingredient', ingredientSchema);\nconst Recipe = mongoose.model('Recipe', recipeSchema);\n\n// Create some sample data\nconst { _id } = await Ingredient.create({\n  name: {\n    en: 'Eggs',\n    es: 'Huevos'\n  }\n});\nawait Recipe.create({ ingredients: [_id] });\n\n// Populate with setting `$locals.language` for internationalization\nconst language = 'es';\nconst recipes = await Recipe.find().populate({\n  path: 'ingredients',\n  transform: function(doc) {\n    doc.$locals.language = language;\n    return doc;\n  }\n});\n\n// Gets the ingredient's name in Spanish `name.es`\nassert.equal(recipes[0].ingredients[0].name, 'Huevos'); // 'Huevos'\n```\n\n## Differences vs ES6 Getters/Setters\n\nMongoose setters are different from [ES6 setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) because they allow you to transform the value being set. With ES6 setters, you would need to store an internal `_email` property to use a setter. With Mongoose, you do **not** need to define an internal `_email` property or define a corresponding getter for `email`.\n\n``` javascript\nclass User {\n  // This won't convert the email to lowercase! That's because `email`\n  // is just a setter, the actual `email` property doesn't store any data.\n  // also eslint will warn about using \"return\" on a setter\n  set email(v) {\n    // eslint-disable-next-line no-setter-return\n    return v.toLowerCase();\n  }\n}\n\nconst user = new User();\nuser.email = 'TEST@gmail.com';\n\nuser.email; // undefined\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/tutorials/getters-setters.html](https://mongoosejs.com/docs/tutorials/getters-setters.html)"
- name: Getting Started
  id: 4.x/docs/index
  summary: First be sure you have MongoDB and Node.js installed
  description: "# Getting Started\n\n*First be sure you have [MongoDB](http://www.mongodb.org/downloads) and [Node.js](http://nodejs.org/) installed.*\n\nNext install Mongoose from the command line using `npm`:\n\n``` javascript\n$ npm install mongoose\n```\n\nNow say we like fuzzy kittens and want to record every kitten we ever meet in MongoDB. The first thing we need to do is include mongoose in our project and open a connection to the `test` database on our locally running instance of MongoDB.\n\n``` javascript\n// getting-started.js\nvar mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost/test');\n```\n\nWe have a pending connection to the test database running on localhost. We now need to get notified if we connect successfully or if a connection error occurs:\n\n``` javascript\nvar db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'connection error:'));\ndb.once('open', function() {\n  // we're connected!\n});\n```\n\nOnce our connection opens, our callback will be called. For brevity, let's assume that all following code is within this callback.\n\nWith Mongoose, everything is derived from a [Schema](../../guide). Let's get a reference to it and define our kittens.\n\n``` javascript\nvar kittySchema = mongoose.Schema({\n    name: String\n});\n```\n\nSo far so good. We've got a schema with one property, `name`, which will be a `String`. The next step is compiling our schema into a [Model](../../models).\n\n``` javascript\nvar Kitten = mongoose.model('Kitten', kittySchema);\n```\n\nA model is a class with which we construct documents. In this case, each document will be a kitten with properties and behaviors as declared in our schema. Let's create a kitten document representing the little guy we just met on the sidewalk outside:\n\n``` javascript\nvar silence = new Kitten({ name: 'Silence' });\nconsole.log(silence.name); // 'Silence'\n```\n\nKittens can meow, so let's take a look at how to add \"speak\" functionality to our documents:\n\n``` javascript\n// NOTE: methods must be added to the schema before compiling it with mongoose.model()\nkittySchema.methods.speak = function () {\n  var greeting = this.name\n    ? \"Meow name is \" + this.name\n    : \"I don't have a name\";\n  console.log(greeting);\n}\n\nvar Kitten = mongoose.model('Kitten', kittySchema);\n```\n\nFunctions added to the `methods` property of a schema get compiled into the `Model` prototype and exposed on each document instance:\n\n``` javascript\nvar fluffy = new Kitten({ name: 'fluffy' });\nfluffy.speak(); // \"Meow name is fluffy\"\n```\n\nWe have talking kittens! But we still haven't saved anything to MongoDB. Each document can be saved to the database by calling its [save](https://mongoosejs.com/docs/api.html#model_Model-save) method. The first argument to the callback will be an error if any occured.\n\n``` javascript\nfluffy.save(function (err, fluffy) {\n  if (err) return console.error(err);\n  fluffy.speak();\n});\n```\n\nSay time goes by and we want to display all the kittens we've seen. We can access all of the kitten documents through our Kitten [model](../../models).\n\n``` javascript\nKitten.find(function (err, kittens) {\n  if (err) return console.error(err);\n  console.log(kittens);\n})\n```\n\nWe just logged all of the kittens in our db to the console. If we want to filter our kittens by name, Mongoose supports MongoDBs rich [querying](../../queries) syntax.\n\n``` javascript\nKitten.find({ name: /^fluff/ }, callback);\n```\n\nThis performs a search for all documents with a name property that begins with \"Fluff\" and returns the result as an array of kittens to the callback.\n\n## Congratulations\n\nThat's the end of our quick start. We created a schema, added a custom document method, saved and queried kittens in MongoDB using Mongoose. Head over to the [guide](guide), or [API docs](api) for more.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/4.x/docs/index.html](https://mongoosejs.com/docs/4.x/docs/index.html)"
- name: How to Use findOneAndUpdate() in Mongoose
  id: tutorials/findoneandupdate
  summary: The findOneAndUpdate() function in Mongoose has a wide variety of use cases
  description: "# How to Use `findOneAndUpdate()` in Mongoose\n\nThe [`findOneAndUpdate()` function in Mongoose](../api/query#query_Query-findOneAndUpdate) has a wide variety of use cases. [You should use `save()` to update documents where possible](https://masteringjs.io/tutorials/mongoose/update), for better [validation](../validation) and [middleware](../middleware) support. However, there are some cases where you need to use [`findOneAndUpdate()`](https://masteringjs.io/tutorials/mongoose/findoneandupdate). In this tutorial, you'll see how to use `findOneAndUpdate()`, and learn when you need to use it.\n\n- [Getting Started](#getting-started)\n- [Atomic Updates](#atomic-updates)\n- [Upsert](#upsert)\n- [The `rawResult` Option](#raw-result)\n\n## Getting Started\n\nAs the name implies, `findOneAndUpdate()` finds the first document that matches a given `filter`, applies an `update`, and returns the document. By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied.\n\n``` javascript\nconst Character = mongoose.model('Character', new mongoose.Schema({\n  name: String,\n  age: Number\n}));\n\nawait Character.create({ name: 'Jean-Luc Picard' });\n\nconst filter = { name: 'Jean-Luc Picard' };\nconst update = { age: 59 };\n\n// `doc` is the document _before_ `update` was applied\nlet doc = await Character.findOneAndUpdate(filter, update);\ndoc.name; // 'Jean-Luc Picard'\ndoc.age; // undefined\n\ndoc = await Character.findOne(filter);\ndoc.age; // 59\n```\n\nYou should set the `new` option to `true` to return the document **after** `update` was applied.\n\n``` javascript\nconst filter = { name: 'Jean-Luc Picard' };\nconst update = { age: 59 };\n\n// `doc` is the document _after_ `update` was applied because of\n// `new: true`\nconst doc = await Character.findOneAndUpdate(filter, update, {\n  new: true\n});\ndoc.name; // 'Jean-Luc Picard'\ndoc.age; // 59\n```\n\nMongoose's `findOneAndUpdate()` is slightly different from [the MongoDB Node.js driver's `findOneAndUpdate()`](http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#findOneAndUpdate) because it returns the document itself, not a [result object](http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#~findAndModifyWriteOpResult).\n\nAs an alternative to the `new` option, you can also use the `returnOriginal` option. `returnOriginal: false` is equivalent to `new: true`. The `returnOriginal` option exists for consistency with the [the MongoDB Node.js driver's `findOneAndUpdate()`](http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#findOneAndUpdate), which has the same option.\n\n``` javascript\nconst filter = { name: 'Jean-Luc Picard' };\nconst update = { age: 59 };\n\n// `doc` is the document _after_ `update` was applied because of\n// `returnOriginal: false`\nconst doc = await Character.findOneAndUpdate(filter, update, {\n  returnOriginal: false\n});\ndoc.name; // 'Jean-Luc Picard'\ndoc.age; // 59\n```\n\n## Atomic Updates\n\nWith the exception of an [unindexed upsert](https://www.mongodb.com/docs/manual/reference/method/db.collection.findAndModify/#upsert-with-unique-index), [`findOneAndUpdate()` is atomic](https://www.mongodb.com/docs/manual/core/write-operations-atomicity/#atomicity). That means you can assume the document doesn't change between when MongoDB finds the document and when it updates the document, *unless* you're doing an [upsert](#upsert).\n\nFor example, if you're using `save()` to update a document, the document can change in MongoDB in between when you load the document using `findOne()` and when you save the document using `save()` as show below. For many use cases, the `save()` race condition is a non-issue. But you can work around it with `findOneAndUpdate()` (or [transactions](../transactions)) if you need to.\n\n``` javascript\nconst filter = { name: 'Jean-Luc Picard' };\nconst update = { age: 59 };\n\nlet doc = await Character.findOne({ name: 'Jean-Luc Picard' });\n\n// Document changed in MongoDB, but not in Mongoose\nawait Character.updateOne(filter, { name: 'Will Riker' });\n\n// This will update `doc` age to `59`, even though the doc changed.\ndoc.age = update.age;\nawait doc.save();\n\ndoc = await Character.findOne();\ndoc.name; // Will Riker\ndoc.age; // 59\n```\n\n## Upsert\n\nUsing the `upsert` option, you can use `findOneAndUpdate()` as a find-and-[upsert](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/#db.collection.update) operation. An upsert behaves like a normal `findOneAndUpdate()` if it finds a document that matches `filter`. But, if no document matches `filter`, MongoDB will insert one by combining `filter` and `update` as shown below.\n\n``` javascript\nconst filter = { name: 'Will Riker' };\nconst update = { age: 29 };\n\nawait Character.countDocuments(filter); // 0\n\nconst doc = await Character.findOneAndUpdate(filter, update, {\n  new: true,\n  upsert: true // Make this update into an upsert\n});\ndoc.name; // Will Riker\ndoc.age; // 29\n```\n\n## The \\`rawResult\\` Option\n\nMongoose transforms the result of `findOneAndUpdate()` by default: it returns the updated document. That makes it difficult to check whether a document was upserted or not. In order to get the updated document and check whether MongoDB upserted a new document in the same operation, you can set the `rawResult` flag to make Mongoose return the raw result from MongoDB.\n\n``` javascript\nconst filter = { name: 'Will Riker' };\nconst update = { age: 29 };\n\nawait Character.countDocuments(filter); // 0\n\nconst res = await Character.findOneAndUpdate(filter, update, {\n  new: true,\n  upsert: true,\n  rawResult: true // Return the raw result from the MongoDB driver\n});\n\nres.value instanceof Character; // true\n// The below property will be `false` if MongoDB upserted a new\n// document, and `true` if MongoDB updated an existing object.\nres.lastErrorObject.updatedExisting; // false\n```\n\nHere's what the `res` object from the above example looks like:\n\n``` javascript\n{ lastErrorObject:\n   { n: 1,\n     updatedExisting: false,\n     upserted: 5e6a9e5ec6e44398ae2ac16a },\n  value:\n   { _id: 5e6a9e5ec6e44398ae2ac16a,\n     name: 'Will Riker',\n     __v: 0,\n     age: 29 },\n  ok: 1 }\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/tutorials/findoneandupdate.html](https://mongoosejs.com/docs/tutorials/findoneandupdate.html)"
- name: Map
  id: api/map
  summary: Overwrites native Map's clear() function to support change tracking
  description: "# Map\n\n### MongooseMap.prototype.$isMongooseMap\n\n##### Type:\n\n- «property»\n\nSet to `true` for all Mongoose map instances\n\n### MongooseMap.prototype.clear()\n\nOverwrites native Map's `clear()` function to support change tracking.\n\n### MongooseMap.prototype.delete()\n\nOverwrites native Map's `delete()` function to support change tracking.\n\n### MongooseMap.prototype.get()\n\nOverwrites native Map's `get()` function to support Mongoose getters.\n\n### MongooseMap.prototype.set()\n\nOverwrites native Map's `set()` function to support setters, `populate()`, and change tracking. Note that Mongoose maps *only* support strings and ObjectIds as keys.\n\n#### [Example:](#example)\n\n``` javascript\ndoc.myMap.set('test', 42); // works\ndoc.myMap.set({ obj: 42 }, 42); // Throws \"Mongoose maps only support string keys\"\n```\n\n### MongooseMap.prototype.toBSON()\n\nConverts this map to a native JavaScript Map so the MongoDB driver can serialize it.\n\n### MongooseMap.prototype.toJSON()\n\n##### Parameters:\n\n- `[options]` «Object»\n\n- `[options.flattenMaps=false]` «Boolean» set to `true` to convert the map to a POJO rather than a native JavaScript map\n\nConverts this map to a native JavaScript Map for `JSON.stringify()`. Set the `flattenMaps` option to convert this map to a POJO instead.\n\n#### [Example:](#example)\n\n``` javascript\ndoc.myMap.toJSON() instanceof Map; // true\ndoc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/map.html](https://mongoosejs.com/docs/api/map.html)"
- name: Maps
  id: schematypes#maps
  summary: A MongooseMap is a subclass of JavaScript's Map class
  belongs_to: SchemaTypes
  description: |-
    ### Maps

    A `MongooseMap` is a subclass of [JavaScript's `Map` class](http://thecodebarbarian.com/the-80-20-guide-to-maps-in-javascript.html). In these docs, we'll use the terms 'map' and `MongooseMap` interchangeably. In Mongoose, maps are how you create a nested document with arbitrary keys.

    **Note**: In Mongoose Maps, keys must be strings in order to store the document in MongoDB.

    ``` javascript
    const userSchema = new Schema({
      // `socialMediaHandles` is a map whose values are strings. A map's
      // keys are always strings. You specify the type of values using `of`.
      socialMediaHandles: {
        type: Map,
        of: String
      }
    });

    const User = mongoose.model('User', userSchema);
    // Map { 'github' => 'vkarpov15', 'twitter' => '@code_barbarian' }
    console.log(new User({
      socialMediaHandles: {
        github: 'vkarpov15',
        twitter: '@code_barbarian'
      }
    }).socialMediaHandles);
    ```

    The above example doesn't explicitly declare `github` or `twitter` as paths, but, since `socialMediaHandles` is a map, you can store arbitrary key/value pairs. However, since `socialMediaHandles` is a map, you **must** use `.get()` to get the value of a key and `.set()` to set the value of a key.

    ``` javascript
    const user = new User({
      socialMediaHandles: {}
    });

    // Good
    user.socialMediaHandles.set('github', 'vkarpov15');
    // Works too
    user.set('socialMediaHandles.twitter', '@code_barbarian');
    // Bad, the `myspace` property will **not** get saved
    user.socialMediaHandles.myspace = 'fail';

    // 'vkarpov15'
    console.log(user.socialMediaHandles.get('github'));
    // '@code_barbarian'
    console.log(user.get('socialMediaHandles.twitter'));
    // undefined
    user.socialMediaHandles.github;

    // Will only save the 'github' and 'twitter' properties
    user.save();
    ```

    Map types are stored as [BSON objects in MongoDB](https://en.wikipedia.org/wiki/BSON#Data_types_and_syntax). Keys in a BSON object are ordered, so this means the [insertion order](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Description) property of maps is maintained.

    Mongoose supports a special `$*` syntax to [populate](populate) all elements in a map. For example, suppose your `socialMediaHandles` map contains a `ref`:

    ``` javascript
    const userSchema = new Schema({
      socialMediaHandles: {
        type: Map,
        of: new Schema({
          handle: String,
          oauth: {
            type: ObjectId,
            ref: 'OAuth'
          }
        })
      }
    });
    const User = mongoose.model('User', userSchema);
    ```

    To populate every `socialMediaHandles` entry's `oauth` property, you should populate on `socialMediaHandles.$*.oauth`:

    ``` javascript
    const user = await User.findOne().populate('socialMediaHandles.$*.oauth');
    ```
- name: Middleware
  id: middleware
  summary: Middleware (also called pre and post hooks) are functions which are passed control during execution of asynchronous functions
  description: "# Middleware\n\nMiddleware (also called pre and post *hooks*) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing [plugins](plugins).\n\n## Types of Middleware\n\nMongoose has 4 types of middleware: document middleware, model middleware, aggregate middleware, and query middleware.\n\nDocument middleware is supported for the following document functions. In Mongoose, a document is an instance of a `Model` class. In document middleware functions, `this` refers to the document. To access the model, use `this.constructor`.\n\n- [validate](api/document#document_Document-validate)\n- [save](api/model#model_Model-save)\n- [remove](api/model#model_Model-remove)\n- [updateOne](api/document#document_Document-updateOne)\n- [deleteOne](api/model#model_Model-deleteOne)\n- [init](api/document#document_Document-init) (note: init hooks are [synchronous](#synchronous))\n\nQuery middleware is supported for the following Query functions. Query middleware executes when you call `exec()` or `then()` on a Query object, or `await` on a Query object. In query middleware functions, `this` refers to the query.\n\n- [count](api/query#query_Query-count)\n- [countDocuments](api/query#query_Query-countDocuments)\n- [deleteMany](api/query#query_Query-deleteMany)\n- [deleteOne](api/query#query_Query-deleteOne)\n- [estimatedDocumentCount](api/query#query_Query-estimatedDocumentCount)\n- [find](api/query#query_Query-find)\n- [findOne](api/query#query_Query-findOne)\n- [findOneAndDelete](api/query#query_Query-findOneAndDelete)\n- [findOneAndRemove](api/query#query_Query-findOneAndRemove)\n- [findOneAndReplace](api/query#query_Query-findOneAndReplace)\n- [findOneAndUpdate](api/query#query_Query-findOneAndUpdate)\n- [remove](api/model#model_Model-remove)\n- [replaceOne](api/query#query_Query-replaceOne)\n- [update](api/query#query_Query-update)\n- [updateOne](api/query#query_Query-updateOne)\n- [updateMany](api/query#query_Query-updateMany)\n- [validate](validation#update-validators)\n\nAggregate middleware is for `MyModel.aggregate()`. Aggregate middleware executes when you call `exec()` on an aggregate object. In aggregate middleware, `this` refers to the [aggregation object](api/model#model_Model-aggregate).\n\n- [aggregate](api/model#model_Model-aggregate)\n\nModel middleware is supported for the following model functions. Don't confuse model middleware and document middleware: model middleware hooks into *static* functions on a `Model` class, document middleware hooks into *methods* on a `Model` class. In model middleware functions, `this` refers to the model.\n\n- [insertMany](api/model#model_Model-insertMany)\n\nHere are the possible strings that can be passed to `pre()`\n\n- aggregate\n- count\n- countDocuments\n- deleteOne\n- deleteMany\n- estimatedDocumentCount\n- find\n- findOne\n- findOneAndDelete\n- findOneAndRemove\n- findOneAndReplace\n- findOneAndUpdate\n- init\n- insertMany\n- remove\n- replaceOne\n- save\n- update\n- updateOne\n- updateMany\n- validate\n\nAll middleware types support pre and post hooks. How pre and post hooks work is described in more detail below.\n\n**Note:** If you specify `schema.pre('remove')`, Mongoose will register this middleware for [`doc.remove()`](api/model#model_Model-remove) by default. If you want your middleware to run on [`Query.remove()`](api/query#query_Query-remove) use [`schema.pre('remove', { query: true, document: false }, fn)`](api/schema#schema_Schema-pre).\n\n**Note:** Unlike `schema.pre('remove')`, Mongoose registers `updateOne` and `deleteOne` middleware on `Query#updateOne()` and `Query#deleteOne()` by default. This means that both `doc.updateOne()` and `Model.updateOne()` trigger `updateOne` hooks, but `this` refers to a query, not a document. To register `updateOne` or `deleteOne` middleware as document middleware, use `schema.pre('updateOne', { document: true, query: false })`.\n\n**Note:** The [`create()`](api/model#model_Model-create) function fires `save()` hooks.\n\n**Note:** Query middlewares are not executed on subdocuments.\n\n``` javascript\nconst childSchema = new mongoose.Schema({\n  name: String\n});\n\nconst mainSchema = new mongoose.Schema({\n  child: [childSchema]\n});\n\nmainSchema.pre('findOneAndUpdate', function() {\n  console.log('Middleware on parent document'); // Will be executed\n});\n\nchildSchema.pre('findOneAndUpdate', function() {\n  console.log('Middleware on subdocument'); // Will not be executed\n});\n```\n\n## Pre\n\nPre middleware functions are executed one after another, when each middleware calls `next`.\n\n``` javascript\nconst schema = new Schema({ /* ... */ });\nschema.pre('save', function(next) {\n  // do stuff\n  next();\n});\n```\n\nIn [mongoose 5.x](http://thecodebarbarian.com/introducing-mongoose-5.html#promises-and-async-await-with-middleware), instead of calling `next()` manually, you can use a function that returns a promise. In particular, you can use [`async/await`](http://thecodebarbarian.com/common-async-await-design-patterns-in-node.js.html).\n\n``` javascript\nschema.pre('save', function() {\n  return doStuff().\n    then(() => doMoreStuff());\n});\n\n// Or, in Node.js >= 7.6.0:\nschema.pre('save', async function() {\n  await doStuff();\n  await doMoreStuff();\n});\n```\n\nIf you use `next()`, the `next()` call does **not** stop the rest of the code in your middleware function from executing. Use [the early `return` pattern](https://www.bennadel.com/blog/2323-use-a-return-statement-when-invoking-callbacks-especially-in-a-guard-statement.htm) to prevent the rest of your middleware function from running when you call `next()`.\n\n``` javascript\nconst schema = new Schema({ /* ... */ });\nschema.pre('save', function(next) {\n  if (foo()) {\n    console.log('calling next!');\n    // `return next();` will make sure the rest of this function doesn't run\n    /* return */ next();\n  }\n  // Unless you comment out the `return` above, 'after next' will print\n  console.log('after next');\n});\n```\n\n### Use Cases\n\nMiddleware are useful for atomizing model logic. Here are some other ideas:\n\n- complex validation\n- removing dependent documents (removing a user removes all their blogposts)\n- asynchronous defaults\n- asynchronous tasks that a certain action triggers\n\n### Errors in Pre Hooks\n\nIf any pre hook errors out, mongoose will not execute subsequent middleware or the hooked function. Mongoose will instead pass an error to the callback and/or reject the returned promise. There are several ways to report an error in middleware:\n\n``` javascript\nschema.pre('save', function(next) {\n  const err = new Error('something went wrong');\n  // If you call `next()` with an argument, that argument is assumed to be\n  // an error.\n  next(err);\n});\n\nschema.pre('save', function() {\n  // You can also return a promise that rejects\n  return new Promise((resolve, reject) => {\n    reject(new Error('something went wrong'));\n  });\n});\n\nschema.pre('save', function() {\n  // You can also throw a synchronous error\n  throw new Error('something went wrong');\n});\n\nschema.pre('save', async function() {\n  await Promise.resolve();\n  // You can also throw an error in an `async` function\n  throw new Error('something went wrong');\n});\n\n// later...\n\n// Changes will not be persisted to MongoDB because a pre hook errored out\nmyDoc.save(function(err) {\n  console.log(err.message); // something went wrong\n});\n```\n\nCalling `next()` multiple times is a no-op. If you call `next()` with an error `err1` and then throw an error `err2`, mongoose will report `err1`.\n\n## Post middleware\n\n[post](https://mongoosejs.com/docs/api.html#schema_Schema-post) middleware are executed *after* the hooked method and all of its `pre` middleware have completed.\n\n``` javascript\nschema.post('init', function(doc) {\n  console.log('%s has been initialized from the db', doc._id);\n});\nschema.post('validate', function(doc) {\n  console.log('%s has been validated (but not saved yet)', doc._id);\n});\nschema.post('save', function(doc) {\n  console.log('%s has been saved', doc._id);\n});\nschema.post('remove', function(doc) {\n  console.log('%s has been removed', doc._id);\n});\n```\n\n## Asynchronous Post Hooks\n\nIf your post hook function takes at least 2 parameters, mongoose will assume the second parameter is a `next()` function that you will call to trigger the next middleware in the sequence.\n\n``` javascript\n// Takes 2 parameters: this is an asynchronous post hook\nschema.post('save', function(doc, next) {\n  setTimeout(function() {\n    console.log('post1');\n    // Kick off the second post hook\n    next();\n  }, 10);\n});\n\n// Will not execute until the first middleware calls `next()`\nschema.post('save', function(doc, next) {\n  console.log('post2');\n  next();\n});\n```\n\n## Define Middleware Before Compiling Models\n\nCalling `pre()` or `post()` after [compiling a model](models#compiling) does **not** work in Mongoose in general. For example, the below `pre('save')` middleware will not fire.\n\n``` javascript\nconst schema = new mongoose.Schema({ name: String });\n\n// Compile a model from the schema\nconst User = mongoose.model('User', schema);\n\n// Mongoose will **not** call the middleware function, because\n// this middleware was defined after the model was compiled\nschema.pre('save', () => console.log('Hello from pre save'));\n\nconst user = new User({ name: 'test' });\nuser.save();\n```\n\nThis means that you must add all middleware and [plugins](plugins) **before** calling [`mongoose.model()`](api/mongoose#mongoose_Mongoose-model). The below script will print out \"Hello from pre save\":\n\n``` javascript\nconst schema = new mongoose.Schema({ name: String });\n// Mongoose will call this middleware function, because this script adds\n// the middleware to the schema before compiling the model.\nschema.pre('save', () => console.log('Hello from pre save'));\n\n// Compile a model from the schema\nconst User = mongoose.model('User', schema);\n\nconst user = new User({ name: 'test' });\nuser.save();\n```\n\nAs a consequence, be careful about exporting Mongoose models from the same file that you define your schema. If you choose to use this pattern, you must define [global plugins](api/mongoose#mongoose_Mongoose-plugin) **before** calling `require()` on your model file.\n\n``` javascript\nconst schema = new mongoose.Schema({ name: String });\n\n// Once you `require()` this file, you can no longer add any middleware\n// to this schema.\nmodule.exports = mongoose.model('User', schema);\n```\n\n## Save/Validate Hooks\n\nThe `save()` function triggers `validate()` hooks, because mongoose has a built-in `pre('save')` hook that calls `validate()`. This means that all `pre('validate')` and `post('validate')` hooks get called **before** any `pre('save')` hooks.\n\n``` javascript\nschema.pre('validate', function() {\n  console.log('this gets printed first');\n});\nschema.post('validate', function() {\n  console.log('this gets printed second');\n});\nschema.pre('save', function() {\n  console.log('this gets printed third');\n});\nschema.post('save', function() {\n  console.log('this gets printed fourth');\n});\n```\n\n## Accessing Parameters in Middleware\n\nMongoose provides 2 ways to get information about the function call that triggered the middleware. For query middleware, we recommend using `this`, which will be a [Mongoose Query instance](api/query).\n\n``` javascript\nconst userSchema = new Schema({ name: String, age: Number });\nuserSchema.pre('findOneAndUpdate', function() {\n  console.log(this.getFilter()); // { name: 'John' }\n  console.log(this.getUpdate()); // { age: 30 }\n});\nconst User = mongoose.model('User', userSchema);\n\nawait User.findOneAndUpdate({ name: 'John' }, { $set: { age: 30 } });\n```\n\nFor document middleware, like `pre('save')`, Mongoose passes the 1st parameter to `save()` as the 2nd argument to your `pre('save')` callback. You should use the 2nd argument to get access to the `save()` call's `options`, because Mongoose documents don't store all the options you can pass to `save()`.\n\n``` javascript\nconst userSchema = new Schema({ name: String, age: Number });\nuserSchema.pre('save', function(next, options) {\n  options.validateModifiedOnly; // true\n\n  // Remember to call `next()` unless you're using an async function or returning a promise\n  next();\n});\nconst User = mongoose.model('User', userSchema);\n\nconst doc = new User({ name: 'John', age: 30 });\nawait doc.save({ validateModifiedOnly: true });\n```\n\n## Naming Conflicts\n\nMongoose has both query and document hooks for `remove()`.\n\n``` javascript\nschema.pre('remove', function() { console.log('Removing!'); });\n\n// Prints \"Removing!\"\ndoc.remove();\n\n// Does **not** print \"Removing!\". Query middleware for `remove` is not\n// executed by default.\nModel.remove();\n```\n\nYou can pass options to [`Schema.pre()`](https://mongoosejs.com/docs/api.html#schema_Schema-pre) and [`Schema.post()`](https://mongoosejs.com/docs/api.html#schema_Schema-post) to switch whether Mongoose calls your `remove()` hook for [`Document.remove()`](api/model#model_Model-remove) or [`Model.remove()`](api/model#model_Model-remove). Note here that you need to set both `document` and `query` properties in the passed object:\n\n``` javascript\n// Only document middleware\nschema.pre('remove', { document: true, query: false }, function() {\n  console.log('Removing doc!');\n});\n\n// Only query middleware. This will get called when you do `Model.remove()`\n// but not `doc.remove()`.\nschema.pre('remove', { query: true, document: false }, function() {\n  console.log('Removing!');\n});\n```\n\n## Notes on findAndUpdate() and Query Middleware\n\nPre and post `save()` hooks are **not** executed on `update()`, `findOneAndUpdate()`, etc. You can see a more detailed discussion why in [this GitHub issue](http://github.com/Automattic/mongoose/issues/964). Mongoose 4.0 introduced distinct hooks for these functions.\n\n``` javascript\nschema.pre('find', function() {\n  console.log(this instanceof mongoose.Query); // true\n  this.start = Date.now();\n});\n\nschema.post('find', function(result) {\n  console.log(this instanceof mongoose.Query); // true\n  // prints returned documents\n  console.log('find() returned ' + JSON.stringify(result));\n  // prints number of milliseconds the query took\n  console.log('find() took ' + (Date.now() - this.start) + ' milliseconds');\n});\n```\n\nQuery middleware differs from document middleware in a subtle but important way: in document middleware, `this` refers to the document being updated. In query middleware, mongoose doesn't necessarily have a reference to the document being updated, so `this` refers to the **query** object rather than the document being updated.\n\nFor instance, if you wanted to add an `updatedAt` timestamp to every `updateOne()` call, you would use the following pre hook.\n\n``` javascript\nschema.pre('updateOne', function() {\n  this.set({ updatedAt: new Date() });\n});\n```\n\nYou **cannot** access the document being updated in `pre('updateOne')` or `pre('findOneAndUpdate')` query middleware. If you need to access the document that will be updated, you need to execute an explicit query for the document.\n\n``` javascript\nschema.pre('findOneAndUpdate', async function() {\n  const docToUpdate = await this.model.findOne(this.getQuery());\n  console.log(docToUpdate); // The document that `findOneAndUpdate()` will modify\n});\n```\n\nHowever, if you define `pre('updateOne')` document middleware, `this` will be the document being updated. That's because `pre('updateOne')` document middleware hooks into [`Document#updateOne()`](api/document#document_Document-updateOne) rather than `Query#updateOne()`.\n\n``` javascript\nschema.pre('updateOne', { document: true, query: false }, function() {\n  console.log('Updating');\n});\nconst Model = mongoose.model('Test', schema);\n\nconst doc = new Model();\nawait doc.updateOne({ $set: { name: 'test' } }); // Prints \"Updating\"\n\n// Doesn't print \"Updating\", because `Query#updateOne()` doesn't fire\n// document middleware.\nawait Model.updateOne({}, { $set: { name: 'test' } });\n```\n\n## Error Handling Middleware\n\nMiddleware execution normally stops the first time a piece of middleware calls `next()` with an error. However, there is a special kind of post middleware called \"error handling middleware\" that executes specifically when an error occurs. Error handling middleware is useful for reporting errors and making error messages more readable.\n\nError handling middleware is defined as middleware that takes one extra parameter: the 'error' that occurred as the first parameter to the function. Error handling middleware can then transform the error however you want.\n\n``` javascript\nconst schema = new Schema({\n  name: {\n    type: String,\n    // Will trigger a MongoServerError with code 11000 when\n    // you save a duplicate\n    unique: true\n  }\n});\n\n// Handler **must** take 3 parameters: the error that occurred, the document\n// in question, and the `next()` function\nschema.post('save', function(error, doc, next) {\n  if (error.name === 'MongoServerError' && error.code === 11000) {\n    next(new Error('There was a duplicate key error'));\n  } else {\n    next();\n  }\n});\n\n// Will trigger the `post('save')` error handler\nPerson.create([{ name: 'Axl Rose' }, { name: 'Axl Rose' }]);\n```\n\nError handling middleware also works with query middleware. You can also define a post `update()` hook that will catch MongoDB duplicate key errors.\n\n``` javascript\n// The same E11000 error can occur when you call `update()`\n// This function **must** take 3 parameters. If you use the\n// `passRawResult` function, this function **must** take 4\n// parameters\nschema.post('update', function(error, res, next) {\n  if (error.name === 'MongoServerError' && error.code === 11000) {\n    next(new Error('There was a duplicate key error'));\n  } else {\n    next(); // The `update()` call will still error out.\n  }\n});\n\nconst people = [{ name: 'Axl Rose' }, { name: 'Slash' }];\nawait Person.create(people);\n\n// Throws \"There was a duplicate key error\"\nawait Person.update({ name: 'Slash' }, { $set: { name: 'Axl Rose' } });\n```\n\nError handling middleware can transform an error, but it can't remove the error. Even if you call `next()` with no error as shown above, the function call will still error out.\n\n## Aggregation Hooks\n\nYou can also define hooks for the [`Model.aggregate()` function](api/model#model_Model-aggregate). In aggregation middleware functions, `this` refers to the [Mongoose `Aggregate` object](api/aggregate#Aggregate). For example, suppose you're implementing soft deletes on a `Customer` model by adding an `isDeleted` property. To make sure `aggregate()` calls only look at customers that aren't soft deleted, you can use the below middleware to add a [`$match` stage](api/aggregate#aggregate_Aggregate-match) to the beginning of each [aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/).\n\n``` javascript\ncustomerSchema.pre('aggregate', function() {\n  // Add a $match state to the beginning of each pipeline.\n  this.pipeline().unshift({ $match: { isDeleted: { $ne: true } } });\n});\n```\n\nThe [`Aggregate#pipeline()` function](api/aggregate#aggregate_Aggregate-pipeline) lets you access the MongoDB aggregation pipeline that Mongoose will send to the MongoDB server. It is useful for adding stages to the beginning of the pipeline from middleware.\n\n## Synchronous Hooks\n\nCertain Mongoose hooks are synchronous, which means they do **not** support functions that return promises or receive a `next()` callback. Currently, only `init` hooks are synchronous, because the [`init()` function](api/document#document_Document-init) is synchronous. Below is an example of using pre and post init hooks.\n\n``` javascript\nconst schema = new Schema({ title: String, loadedAt: Date });\n\nschema.pre('init', pojo => {\n  assert.equal(pojo.constructor.name, 'Object'); // Plain object before init\n});\n\nconst now = new Date();\nschema.post('init', doc => {\n  assert.ok(doc instanceof mongoose.Document); // Mongoose doc after init\n  doc.loadedAt = now;\n});\n\nconst Test = db.model('Test', schema);\n\nreturn Test.create({ title: 'Casino Royale' }).\n  then(doc => Test.findById(doc)).\n  then(doc => assert.equal(doc.loadedAt.valueOf(), now.valueOf()));\n```\n\nTo report an error in an init hook, you must throw a **synchronous** error. Unlike all other middleware, init middleware does **not** handle promise rejections.\n\n``` javascript\nconst schema = new Schema({ title: String });\n\nconst swallowedError = new Error('will not show');\n// init hooks do **not** handle async errors or any sort of async behavior\nschema.pre('init', () => Promise.reject(swallowedError));\nschema.post('init', () => { throw Error('will show'); });\n\nconst Test = db.model('Test', schema);\n\nreturn Test.create({ title: 'Casino Royale' }).\n  then(doc => Test.findById(doc)).\n  catch(error => assert.equal(error.message, 'will show'));\n```\n\n## Next Up\n\nNow that we've covered middleware, let's take a look at Mongoose's approach to faking JOINs with its query [population](populate) helper.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/middleware.html](https://mongoosejs.com/docs/middleware.html)"
- name: Migrating from 4.x to 5.x
  id: migrating_to_5
  summary: 'Please note: we plan to discontinue Mongoose 5 support on March 1, 2024'
  description: "# Migrating from 4.x to 5.x\n\nPlease note: we plan to discontinue Mongoose 5 support on March 1, 2024. Please see our [version support guide](version-support).\n\nThere are several [backwards-breaking changes](https://github.com/Automattic/mongoose/blob/master/History.md) you should be aware of when migrating from Mongoose 4.x to Mongoose 5.x.\n\nIf you're still on Mongoose 3.x, please read the [Mongoose 3.x to 4.x migration guide](https://mongoosejs.com/docs/migration.html).\n\n- [Version Requirements](#version-requirements)\n- [Query Middleware](#query-middleware)\n- [Promises and Callbacks for `mongoose.connect()`](#promises-and-callbacks)\n- [Connection Logic and `useMongoClient`](#connection-logic)\n- [Setter Order](#setter-order)\n- [Checking if a path is populated](#id-getter)\n- [Return Values for `remove()` and `deleteX()`](#return-value-for-delete)\n- [Aggregation Cursors](#aggregation-cursors)\n- [geoNear](#geonear)\n- [Required URI encoding of connection strings](#uri-encoding)\n- [Passwords which contain certain characters](#password-characters)\n- [Domain sockets](#domain-sockets)\n- [`toObject()` Options](#toobject-options)\n- [Aggregate Parameters](#aggregate-parameters)\n- [Boolean Casting](#boolean-casting)\n- [Query Casting](#query-casting)\n- [Post Save Hooks Get Flow Control](#post-save-flow-control)\n- [The `$pushAll` Operator](#pushall)\n- [Always Use Forward Key Order](#retain-key-order)\n- [Run setters on queries](#run-setters-on-queries)\n- [Pre-compiled Browser Bundle](#browser-bundle)\n- [Save Errors](#save-errors)\n- [Init hook signatures](#init-hooks)\n- [`numAffected` and `save()`](#save-num-affected)\n- [`remove()` and debouncing](#remove-debounce)\n- [`getPromiseConstructor()`](#get-promise-constructor)\n- [Passing Parameters from Pre Hooks](#pre-hook-params)\n- [`required` validator for arrays](#array-required)\n- [debug output defaults to stdout instead of stderr](#debug-output)\n- [Overwriting filter properties](#overwrite-filter)\n- [`bulkWrite()` results](#bulkwrite-results)\n- [Strict SSL validation](#strict-ssl-validation)\n\n## Version Requirements\n\nMongoose now requires Node.js \\>= 4.0.0 and MongoDB \\>= 3.0.0. [MongoDB 2.6](https://www.mongodb.com/blog/post/mongodb-2-6-end-of-life) and [Node.js \\< 4](https://github.com/nodejs/Release) where both EOL-ed in 2016.\n\n## Query Middleware\n\nQuery middleware is now compiled when you call `mongoose.model()` or `db.model()`. If you add query middleware after calling `mongoose.model()`, that middleware will **not** get called.\n\n``` javascript\nconst schema = new Schema({ name: String });\nconst MyModel = mongoose.model('Test', schema);\nschema.pre('find', () => { console.log('find!'); });\n\nMyModel.find().exec(function() {\n  // In mongoose 4.x, the above `.find()` will print \"find!\"\n  // In mongoose 5.x, \"find!\" will **not** be printed.\n  // Call `pre('find')` **before** calling `mongoose.model()` to make the middleware apply.\n});\n```\n\n## Promises and Callbacks for `mongoose.connect()`\n\n`mongoose.connect()` and `mongoose.disconnect()` now return a promise if no callback specified, or `null` otherwise. It does **not** return the mongoose singleton.\n\n``` javascript\n// Worked in mongoose 4. Does **not** work in mongoose 5, `mongoose.connect()`\n// now returns a promise consistently. This is to avoid the horrible things\n// we've done to allow mongoose to be a thenable that resolves to itself.\nmongoose.connect('mongodb://127.0.0.1:27017/test').model('Test', new Schema({}));\n\n// Do this instead\nmongoose.connect('mongodb://127.0.0.1:27017/test');\nmongoose.model('Test', new Schema({}));\n```\n\n## Connection Logic and `useMongoClient`\n\nThe [`useMongoClient` option](4.x/docs/connections#use-mongo-client) was removed in Mongoose 5, it is now always `true`. As a consequence, Mongoose 5 no longer supports several function signatures for `mongoose.connect()` that worked in Mongoose 4.x if the `useMongoClient` option was off. Below are some examples of `mongoose.connect()` calls that do **not** work in Mongoose 5.x.\n\n- `mongoose.connect('127.0.0.1', 27017);`\n- `mongoose.connect('127.0.0.1', 'mydb', 27017);`\n- `mongoose.connect('mongodb://host1:27017,mongodb://host2:27017');`\n\nIn Mongoose 5.x, the first parameter to `mongoose.connect()` and `mongoose.createConnection()`, if specified, **must** be a [MongoDB connection string](https://www.mongodb.com/docs/manual/reference/connection-string/). The connection string and options are then passed down to [the MongoDB Node.js driver's `MongoClient.connect()` function](http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#.connect). Mongoose does not modify the connection string, although `mongoose.connect()` and `mongoose.createConnection()` support a [few additional options in addition to the ones the MongoDB driver supports](http://mongoosejs.com/docs/connections.html#options).\n\n## Setter Order\n\nSetters run in reverse order in 4.x:\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.path('name').\n  set(() => console.log('This will print 2nd')).\n  set(() => console.log('This will print first'));\n```\n\nIn 5.x, setters run in the order they're declared.\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.path('name').\n  set(() => console.log('This will print first')).\n  set(() => console.log('This will print 2nd'));\n```\n\n## Checking if a path is populated\n\nMongoose 5.1.0 introduced an `_id` getter to ObjectIds that lets you get an ObjectId regardless of whether a path is populated.\n\n``` javascript\nconst blogPostSchema = new Schema({\n  title: String,\n  author: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'Author'\n  }\n});\nconst BlogPost = mongoose.model('BlogPost', blogPostSchema);\n\nawait BlogPost.create({ title: 'test', author: author._id });\nconst blogPost = await BlogPost.findOne();\n\nconsole.log(blogPost.author); // '5b207f84e8061d1d2711b421'\n// New in Mongoose 5.1.0: this will print '5b207f84e8061d1d2711b421' as well\nconsole.log(blogPost.author._id);\n\nawait blogPost.populate('author');\nconsole.log(blogPost.author._id); // '5b207f84e8061d1d2711b421'\n```\n\nAs a consequence, checking whether `blogPost.author._id` is [no longer viable as a way to check whether `author` is populated](https://github.com/Automattic/mongoose/issues/6415#issuecomment-388579185). Use `blogPost.populated('author') != null` or `blogPost.author instanceof mongoose.Types.ObjectId` to check whether `author` is populated instead.\n\nNote that you can call `mongoose.set('objectIdGetter', false)` to change this behavior.\n\n## Return Values for `remove()` and `deleteX()`\n\n`deleteOne()`, `deleteMany()`, and `remove()` now resolve to the result object rather than the full [driver `WriteOpResult` object](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~writeOpCallback).\n\n``` javascript\n// In 4.x, this is how you got the number of documents deleted\nMyModel.deleteMany().then(res => console.log(res.result.n));\n// In 5.x this is how you get the number of documents deleted\nMyModel.deleteMany().then(res => res.n);\n```\n\n## Aggregation Cursors\n\nThe `useMongooseAggCursor` option from 4.x is now always on. This is the new syntax for aggregation cursors in mongoose 5:\n\n``` javascript\n// When you call `.cursor()`, `.exec()` will now return a mongoose aggregation\n// cursor.\nconst cursor = MyModel.aggregate([{ $match: { name: 'Val' } }]).cursor().exec();\n// No need to `await` on the cursor or wait for a promise to resolve\ncursor.eachAsync(doc => console.log(doc));\n\n// Can also pass options to `cursor()`\nconst cursorWithOptions = MyModel.\n  aggregate([{ $match: { name: 'Val' } }]).\n  cursor({ batchSize: 10 }).\n  exec();\n```\n\n## geoNear\n\n`Model.geoNear()` has been removed because the [MongoDB driver no longer supports it](https://github.com/mongodb/node-mongodb-native/blob/4bac63ce7b9e9fff87c31c5a27d78bcdaca12669/etc/notes/CHANGES_3.0.0.md#geonear-command-helper)\n\n## Required URI encoding of connection strings\n\nDue to changes in the MongoDB driver, connection strings must be URI encoded.\n\nIf they are not, connections may fail with an illegal character message.\n\n## Passwords which contain certain characters\n\nSee a [full list of affected characters](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).\n\nIf your app is used by a lot of different connection strings, it's possible that your test cases will pass, but production passwords will fail. Encode all your connection strings to be safe.\n\nIf you want to continue to use unencoded connection strings, the easiest fix is to use the `mongodb-uri` module to parse the connection strings, and then produce the properly encoded versions. You can use a function like this:\n\n``` javascript\nconst uriFormat = require('mongodb-uri');\nfunction encodeMongoURI(urlString) {\n  if (urlString) {\n    const parsed = uriFormat.parse(urlString);\n    urlString = uriFormat.format(parsed);\n  }\n  return urlString;\n}\n\n// Your un-encoded string.\nconst mongodbConnectString = 'mongodb://...';\nmongoose.connect(encodeMongoURI(mongodbConnectString));\n```\n\nThe function above is safe to use whether the existing string is already encoded or not.\n\n## Domain sockets\n\nDomain sockets must be URI encoded. For example:\n\n``` javascript\n// Works in mongoose 4. Does **not** work in mongoose 5 because of more\n// stringent URI parsing.\nconst host = '/tmp/mongodb-27017.sock';\nmongoose.createConnection(`mongodb://aaron:psw@${host}/fake`);\n\n// Do this instead\nconst host = encodeURIComponent('/tmp/mongodb-27017.sock');\nmongoose.createConnection(`mongodb://aaron:psw@${host}/fake`);\n```\n\n## `toObject()` Options\n\nThe `options` parameter to `toObject()` and `toJSON()` merge defaults rather than overwriting them.\n\n``` javascript\n// Note the `toObject` option below\nconst schema = new Schema({ name: String }, { toObject: { virtuals: true } });\nschema.virtual('answer').get(() => 42);\nconst MyModel = db.model('MyModel', schema);\n\nconst doc = new MyModel({ name: 'test' });\n// In mongoose 4.x this prints \"undefined\", because `{ minimize: false }`\n// overwrites the entire schema-defined options object.\n// In mongoose 5.x this prints \"42\", because `{ minimize: false }` gets\n// merged with the schema-defined options.\nconsole.log(doc.toJSON({ minimize: false }).answer);\n```\n\n## Aggregate Parameters\n\n`aggregate()` no longer accepts a spread, you **must** pass your aggregation pipeline as an array. The below code worked in 4.x:\n\n``` javascript\nMyModel.aggregate({ $match: { isDeleted: false } }, { $skip: 10 }).exec(cb);\n```\n\nThe above code does **not** work in 5.x, you **must** wrap the `$match` and `$skip` stages in an array.\n\n``` javascript\nMyModel.aggregate([{ $match: { isDeleted: false } }, { $skip: 10 }]).exec(cb);\n```\n\n## Boolean Casting\n\nBy default, mongoose 4 would coerce any value to a boolean without error.\n\n``` javascript\n// Fine in mongoose 4, would save a doc with `boolField = true`\nconst MyModel = mongoose.model('Test', new Schema({\n  boolField: Boolean\n}));\n\nMyModel.create({ boolField: 'not a boolean' });\n```\n\nMongoose 5 only casts the following values to `true`:\n\n- `true`\n- `'true'`\n- `1`\n- `'1'`\n- `'yes'`\n\nAnd the following values to `false`:\n\n- `false`\n- `'false'`\n- `0`\n- `'0'`\n- `'no'`\n\nAll other values will cause a `CastError`\n\n## Query Casting\n\nCasting for `update()`, `updateOne()`, `updateMany()`, `replaceOne()`, `remove()`, `deleteOne()`, and `deleteMany()` doesn't happen until `exec()`. This makes it easier for hooks and custom query helpers to modify data, because mongoose won't restructure the data you passed in until after your hooks and query helpers have ran. It also makes it possible to set the `overwrite` option *after* passing in an update.\n\n``` javascript\n// In mongoose 4.x, this becomes `{ $set: { name: 'Baz' } }` despite the `overwrite`\n// In mongoose 5.x, this overwrite is respected and the first document with\n// `name = 'Bar'` will be replaced with `{ name: 'Baz' }`\nUser.where({ name: 'Bar' }).update({ name: 'Baz' }).setOptions({ overwrite: true });\n```\n\n## Post Save Hooks Get Flow Control\n\nPost hooks now get flow control, which means async post save hooks and child document post save hooks execute **before** your `save()` callback.\n\n``` javascript\nconst ChildModelSchema = new mongoose.Schema({\n  text: {\n    type: String\n  }\n});\nChildModelSchema.post('save', function(doc) {\n  // In mongoose 5.x this will print **before** the `console.log()`\n  // in the `save()` callback. In mongoose 4.x this was reversed.\n  console.log('Child post save');\n});\nconst ParentModelSchema = new mongoose.Schema({\n  children: [ChildModelSchema]\n});\n\nconst Model = mongoose.model('Parent', ParentModelSchema);\nconst m = new Model({ children: [{ text: 'test' }] });\nm.save(function() {\n  // In mongoose 5.xm this prints **after** the \"Child post save\" message.\n  console.log('Save callback');\n});\n```\n\n## The `$pushAll` Operator\n\n`$pushAll` is no longer supported and no longer used internally for `save()`, since it has been [deprecated since MongoDB 2.4](https://www.mongodb.com/docs/manual/reference/operator/update/pushAll/). Use `$push` with `$each` instead.\n\n## Always Use Forward Key Order\n\nThe `retainKeyOrder` option was removed, mongoose will now always retain the same key position when cloning objects. If you have queries or indexes that rely on reverse key order, you will have to change them.\n\n## Run setters on queries\n\nSetters now run on queries by default, and the old `runSettersOnQuery` option has been removed.\n\n``` javascript\nconst schema = new Schema({\n  email: { type: String, lowercase: true }\n});\nconst Model = mongoose.model('Test', schema);\nModel.find({ email: 'FOO@BAR.BAZ' }); // Converted to `find({ email: 'foo@bar.baz' })`\n```\n\n## Pre-compiled Browser Bundle\n\nWe no longer have a pre-compiled version of mongoose for the browser. If you want to use mongoose schemas in the browser, you need to build your own bundle with browserify/webpack.\n\n## Save Errors\n\nThe `saveErrorIfNotFound` option was removed, mongoose will now always error out from `save()` if the underlying document was not found\n\n## Init hook signatures\n\n`init` hooks are now fully synchronous and do not receive `next()` as a parameter.\n\n`Document.prototype.init()` no longer takes a callback as a parameter. It was always synchronous, just had a callback for legacy reasons.\n\n## `numAffected` and `save()`\n\n`doc.save()` no longer passes `numAffected` as a 3rd param to its callback.\n\n## `remove()` and debouncing\n\n`doc.remove()` no longer debounces\n\n## `getPromiseConstructor()`\n\n`getPromiseConstructor()` is gone, just use `mongoose.Promise`.\n\n## Passing Parameters from Pre Hooks\n\nYou cannot pass parameters to the next pre middleware in the chain using `next()` in mongoose 5.x. In mongoose 4, `next('Test')` in pre middleware would call the next middleware with 'Test' as a parameter. Mongoose 5.x has removed support for this.\n\n## `required` validator for arrays\n\nIn mongoose 5 the `required` validator only verifies if the value is an array. That is, it will **not** fail for *empty* arrays as it would in mongoose 4.\n\n## debug output defaults to stdout instead of stderr\n\nIn mongoose 5 the default debug function uses `console.info()` to display messages instead of `console.error()`.\n\n## Overwriting filter properties\n\nIn Mongoose 4.x, overwriting a filter property that's a primitive with one that is an object would silently fail. For example, the below code would ignore the `where()` and be equivalent to `Sport.find({ name: 'baseball' })`\n\n``` javascript\nSport.find({ name: 'baseball' }).where({ name: { $ne: 'softball' } });\n```\n\nIn Mongoose 5.x, the above code will correctly overwrite `'baseball'` with `{ $ne: 'softball' }`\n\n## `bulkWrite()` results\n\nMongoose 5.x uses version 3.x of the [MongoDB Node.js driver](http://npmjs.com/package/mongodb). MongoDB driver 3.x changed the format of the result of [`bulkWrite()` calls](api/model#model_Model-bulkWrite) so there is no longer a top-level `nInserted`, `nModified`, etc. property. The new result object structure is [described here](http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#~BulkWriteOpResult).\n\n``` javascript\nconst Model = mongoose.model('Test', new Schema({ name: String }));\n\nconst res = await Model.bulkWrite([{ insertOne: { document: { name: 'test' } } }]);\n\nconsole.log(res);\n```\n\nIn Mongoose 4.x, the above will print:\n\n``` javascript\nBulkWriteResult {\n  ok: [Getter],\n  nInserted: [Getter],\n  nUpserted: [Getter],\n  nMatched: [Getter],\n  nModified: [Getter],\n  nRemoved: [Getter],\n  getInsertedIds: [Function],\n  getUpsertedIds: [Function],\n  getUpsertedIdAt: [Function],\n  getRawResponse: [Function],\n  hasWriteErrors: [Function],\n  getWriteErrorCount: [Function],\n  getWriteErrorAt: [Function],\n  getWriteErrors: [Function],\n  getLastOp: [Function],\n  getWriteConcernError: [Function],\n  toJSON: [Function],\n  toString: [Function],\n  isOk: [Function],\n  insertedCount: 1,\n  matchedCount: 0,\n  modifiedCount: 0,\n  deletedCount: 0,\n  upsertedCount: 0,\n  upsertedIds: {},\n  insertedIds: { '0': 5be9a3101638a066702a0d38 },\n  n: 1 }\n```\n\nIn Mongoose 5.x, the script will print:\n\n``` javascript\nBulkWriteResult {\n  result: \n  { ok: 1,\n    writeErrors: [],\n    writeConcernErrors: [],\n    insertedIds: [ [Object] ],\n    nInserted: 1,\n    nUpserted: 0,\n    nMatched: 0,\n    nModified: 0,\n    nRemoved: 0,\n    upserted: [],\n    lastOp: { ts: [Object], t: 1 } },\n  insertedCount: 1,\n  matchedCount: 0,\n  modifiedCount: 0,\n  deletedCount: 0,\n  upsertedCount: 0,\n  upsertedIds: {},\n  insertedIds: { '0': 5be9a1c87decfc6443dd9f18 },\n  n: 1 }\n```\n\n## Strict SSL Validation\n\nThe most recent versions of the [MongoDB Node.js driver use strict SSL validation by default](http://mongodb.github.io/node-mongodb-native/3.5/tutorials/connect/tls/), which may lead to errors if you're using [self-signed certificates](https://github.com/Automattic/mongoose/issues/9147).\n\nIf this is blocking you from upgrading, you can set the `tlsInsecure` option to `true`.\n\n``` javascript\nmongoose.connect(uri, { tlsInsecure: false }); // Opt out of additional SSL validation\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/migrating_to_5.html](https://mongoosejs.com/docs/migrating_to_5.html)"
- name: Migrating from 5.x to 6.x
  id: migrating_to_6
  summary: 'Please note: we plan to discontinue Mongoose 5 support on March 1, 2024'
  description: "# Migrating from 5.x to 6.x\n\nPlease note: we plan to discontinue Mongoose 5 support on March 1, 2024. Please see our [version support guide](version-support).\n\nThere are several [backwards-breaking changes](https://github.com/Automattic/mongoose/blob/master/CHANGELOG.md) you should be aware of when migrating from Mongoose 5.x to Mongoose 6.x.\n\nIf you're still on Mongoose 4.x, please read the [Mongoose 4.x to 5.x migration guide](migrating_to_5) and upgrade to Mongoose 5.x first.\n\n- [Version Requirements](#version-requirements)\n- [MongoDB Driver 4.0](#mongodb-driver-40)\n- [No More Deprecation Warning Options](#no-more-deprecation-warning-options)\n- [The `asPromise()` Method for Connections](#the-aspromise-method-for-connections)\n- [`mongoose.connect()` Returns a Promise](#mongoose-connect-returns-a-promise)\n- [Duplicate Query Execution](#duplicate-query-execution)\n- [`Model.exists()` Returns a lean document instead of Boolean](#model-exists-returns-a-lean-document-instead-of-boolean)\n- [`strictQuery` is now equal to `strict` by default](#strictquery-is-removed-and-replaced-by-strict)\n- [MongoError is now MongoServerError](#mongoerror-is-now-mongoservererror)\n- [Simplified `isValidObjectId()` and separate `isObjectIdOrHexString()`](#simplified-isvalidobjectid-and-separate-isobjectidorhexstring)\n- [Clone Discriminator Schemas By Default](#clone-discriminator-schemas-by-default)\n- [Schema Defined Document Key Order](#schema-defined-document-key-order)\n- [`sanitizeFilter` and `trusted()`](#sanitizefilter-and-trusted)\n- [Removed `omitUndefined`: Mongoose now removes `undefined` keys in updates instead of setting them to `null`](#removed-omitundefined)\n- [Document Parameter to Default Functions](#document-parameter-to-default-functions)\n- [Arrays are Proxies](#arrays-are-proxies)\n- [`typePojoToMixed`](#typepojotomixed)\n- [`strictPopulate()`](#strictpopulate)\n- [Subdocument `ref` Function Context](#subdocument-ref-function-context)\n- [Schema Reserved Names Warning](#schema-reserved-names-warning)\n- [Subdocument Paths](#subdocument-paths)\n- [Creating Aggregation Cursors](#creating-aggregation-cursors)\n- [`autoCreate` Defaults to `true`](#autocreate-defaults-to-true)\n- [No More `context: 'query'`](#no-more-context-query)\n- [Custom Validators with Populated Paths](#custom-validators-with-populated-paths)\n- [Disconnected Event with Replica Sets](#disconnected-event-with-replica-sets)\n- [Removed `execPopulate()`](#removed-execpopulate)\n- [`create()` with Empty Array](#create-with-empty-array)\n- [Removed Nested Path Merging](#removed-nested-path-merging)\n- [ObjectId `valueOf()`](#objectid-valueof)\n- [Immutable `createdAt`](#immutable-createdat)\n- [Removed Validator `isAsync`](#removed-validator-isasync)\n- [Removed `safe`](#removed-safe)\n- [SchemaType `set` parameters now use `priorValue` as the second parameter instead of `self`](#schematype-set-parameters)\n- [No default model for `Query.prototype.populate()`](#no-default-model-for-query-prototype-populate)\n- [`toObject()` and `toJSON()` Use Nested Schema `minimize`](#toobject-and-tojson-use-nested-schema-minimize)\n- [TypeScript changes](#typescript-changes)\n- [Removed `reconnectTries` and `reconnectInterval` options](#removed-reconnecttries-and-reconnectinterval-options)\n\n## Version Requirements\n\nMongoose now requires Node.js \\>= 12.0.0. Mongoose still supports MongoDB server versions back to 3.0.0.\n\n## MongoDB Driver 4.0\n\nMongoose now uses v4.x of the [MongoDB Node driver](https://www.npmjs.com/package/mongodb). See [the MongoDB Node drivers' migration guide](https://github.com/mongodb/node-mongodb-native/blob/4.0/docs/CHANGES_4.0.0.md) for detailed info. Below are some of the most noteworthy changes:\n\n- MongoDB Driver 4.x is written in TypeScript and has its own TypeScript type definitions. These may conflict with `@types/mongodb`, so if you have TypeScript compiler errors please make sure you upgrade to the [latest version of `@types/mongodb`](https://www.npmjs.com/package/@types/mongodb), which is an empty stub.\n- The `poolSize` option for connections has been [replaced with `minPoolSize` and `maxPoolSize`](https://github.com/mongodb/node-mongodb-native/blob/4.1/docs/CHANGES_4.0.0.md#connection-pool-options). The Mongoose 5.x `poolSize` option is equivalent to the Mongoose 6 `maxPoolSize` option. The default value of `maxPoolSize` has been increased to 100.\n- The result of `updateOne()` and `updateMany()` is now different.\n- The result of `deleteOne()` and `deleteMany()` no longer has an `n` property.\n\n``` javascript\nconst res = await TestModel.updateMany({}, { someProperty: 'someValue' });\n\nres.matchedCount; // Number of documents that were found that match the filter. Replaces `res.n`\nres.modifiedCount; // Number of documents modified. Replaces `res.nModified`\nres.upsertedCount; // Number of documents upserted. Replaces `res.upserted`\n```\n\n``` javascript\nconst res = await TestModel.deleteMany({});\n\n// In Mongoose 6: `{ acknowledged: true, deletedCount: 2 }`\n// In Mongoose 5: `{ n: 2, ok: 1, deletedCount: 2 }`\nres;\n\nres.deletedCount; // Number of documents that were deleted. Replaces `res.n`\n```\n\n## No More Deprecation Warning Options\n\n`useNewUrlParser`, `useUnifiedTopology`, `useFindAndModify`, and `useCreateIndex` are no longer supported options. Mongoose 6 always behaves as if `useNewUrlParser`, `useUnifiedTopology`, and `useCreateIndex` are `true`, and `useFindAndModify` is `false`. Please remove these options from your code.\n\n``` javascript\n// No longer necessary:\nmongoose.set('useFindAndModify', false);\n\nawait mongoose.connect('mongodb://127.0.0.1:27017/test', {\n  useNewUrlParser: true, // <-- no longer necessary\n  useUnifiedTopology: true // <-- no longer necessary\n});\n```\n\n## The `asPromise()` Method for Connections\n\nMongoose connections are no longer [thenable](https://masteringjs.io/tutorials/fundamentals/thenable). This means that `await mongoose.createConnection(uri)` **no longer waits for Mongoose to connect**. Use `mongoose.createConnection(uri).asPromise()` instead. See [\\#8810](https://github.com/Automattic/mongoose/issues/8810).\n\n``` javascript\n// The below no longer works in Mongoose 6\nawait mongoose.createConnection(uri);\n\n// Do this instead\nawait mongoose.createConnection(uri).asPromise();\n```\n\n## `mongoose.connect()` Returns a Promise\n\nThe `mongoose.connect()` function now always returns a promise, **not** a Mongoose instance.\n\n## Duplicate Query Execution\n\nMongoose no longer allows executing the same query object twice. If you do, you'll get a `Query was already executed` error. Executing the same query instance twice is typically indicative of mixing callbacks and promises, but if you need to execute the same query twice, you can call `Query#clone()` to clone the query and re-execute it. See [gh-7398](https://github.com/Automattic/mongoose/issues/7398)\n\n``` javascript\n// Results in 'Query was already executed' error, because technically this `find()` query executes twice.\nawait Model.find({}, function(err, result) {});\n\nconst q = Model.find();\nawait q;\nawait q.clone(); // Can `clone()` the query to allow executing the query again\n```\n\n## Model.exists(...) now returns a lean document instead of boolean\n\n``` javascript\n// in Mongoose 5.x, `existingUser` used to be a boolean\n// now `existingUser` will be either `{ _id: ObjectId(...) }` or `null`.\nconst existingUser = await User.exists({ name: 'John' });\nif (existingUser) {\n  console.log(existingUser._id);\n}\n```\n\n## `strictQuery` is now equal to `strict` by default\n\n~~Mongoose no longer supports a `strictQuery` option. You must now use `strict`.~~ As of Mongoose 6.0.10, we brought back the `strictQuery` option. However, `strictQuery` is tied to `strict` by default. This means that, by default, Mongoose will filter out query filter properties that are not in the schema.\n\n``` javascript\nconst userSchema = new Schema({ name: String });\nconst User = mongoose.model('User', userSchema);\n\n// By default, this is equivalent to `User.find()` because Mongoose filters out `notInSchema`\nawait User.find({ notInSchema: 1 });\n\n// Set `strictQuery: false` to opt in to filtering by properties that aren't in the schema\nawait User.find({ notInSchema: 1 }, null, { strictQuery: false });\n// equivalent:\nawait User.find({ notInSchema: 1 }).setOptions({ strictQuery: false });\n```\n\nYou can also disable `strictQuery` globally to override:\n\n``` javascript\nmongoose.set('strictQuery', false);\n```\n\n## MongoError is now MongoServerError\n\nIn MongoDB Node.js Driver v4.x, 'MongoError' is now 'MongoServerError'. Please change any code that depends on the hardcoded string 'MongoError'.\n\n## Clone Discriminator Schemas By Default\n\nMongoose now clones discriminator schemas by default. This means you need to pass `{ clone: false }` to `discriminator()` if you're using recursive embedded discriminators.\n\n``` javascript\n// In Mongoose 6, these two are equivalent:\nUser.discriminator('author', authorSchema);\nUser.discriminator('author', authorSchema.clone());\n\n// To opt out if `clone()` is causing issues, pass `clone: false`\nUser.discriminator('author', authorSchema, { clone: false });\n```\n\n## Simplified `isValidObjectId()` and separate `isObjectIdOrHexString()`\n\nIn Mongoose 5, `mongoose.isValidObjectId()` returned `false` for values like numbers, which was inconsistent with the MongoDB driver's `ObjectId.isValid()` function. Technically, any JavaScript number can be converted to a MongoDB ObjectId.\n\nIn Mongoose 6, `mongoose.isValidObjectId()` is just a wrapper for `mongoose.Types.ObjectId.isValid()` for consistency.\n\nMongoose 6.2.5 now includes a `mongoose.isObjectIdOrHexString()` function, which does a better job of capturing the more common use case for `isValidObjectId()`: is the given value an `ObjectId` instance or a 24 character hex string representing an `ObjectId`?\n\n``` javascript\n// `isValidObjectId()` returns `true` for some surprising values, because these\n// values are _technically_ ObjectId representations\nmongoose.isValidObjectId(new mongoose.Types.ObjectId()); // true\nmongoose.isValidObjectId('0123456789ab'); // true\nmongoose.isValidObjectId(6); // true\nmongoose.isValidObjectId(new User({ name: 'test' })); // true\n\n// `isObjectIdOrHexString()` instead only returns `true` for ObjectIds and 24\n// character hex strings.\nmongoose.isObjectIdOrHexString(new mongoose.Types.ObjectId()); // true\nmongoose.isObjectIdOrHexString('62261a65d66c6be0a63c051f'); // true\nmongoose.isObjectIdOrHexString('0123456789ab'); // false\nmongoose.isObjectIdOrHexString(6); // false\n```\n\n## Schema Defined Document Key Order\n\nMongoose now saves objects with keys in the order the keys are specified in the schema, not in the user-defined object. So whether `Object.keys(new User({ name: String, email: String }).toObject()` is `['name', 'email']` or `['email', 'name']` depends on the order `name` and `email` are defined in your schema.\n\n``` javascript\nconst schema = new Schema({\n  profile: {\n    name: {\n      first: String,\n      last: String\n    }\n  }\n});\nconst Test = db.model('Test', schema);\n\nconst doc = new Test({\n  profile: { name: { last: 'Musashi', first: 'Miyamoto' } }\n});\n\n// Note that 'first' comes before 'last', even though the argument to `new Test()` flips the key order.\n// Mongoose uses the schema's key order, not the provided objects' key order.\nassert.deepEqual(Object.keys(doc.toObject().profile.name), ['first', 'last']);\n```\n\n## `sanitizeFilter` and `trusted()`\n\nMongoose 6 introduces a new `sanitizeFilter` option to globals and queries that defends against [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html). If you enable `sanitizeFilter`, Mongoose will wrap any object in the query filter in a `$eq`:\n\n``` javascript\n// Mongoose will convert this filter into `{ username: 'val', pwd: { $eq: { $ne: null } } }`, preventing\n// a query selector injection.\nawait Test.find({ username: 'val', pwd: { $ne: null } }).setOptions({ sanitizeFilter: true });\n```\n\nTo explicitly allow a query selector, use `mongoose.trusted()`:\n\n``` javascript\n// `mongoose.trusted()` allows query selectors through\nawait Test.find({ username: 'val', pwd: mongoose.trusted({ $ne: null }) }).setOptions({ sanitizeFilter: true });\n```\n\n## Removed `omitUndefined`: Mongoose now removes `undefined` keys in updates instead of setting them to `null`\n\nIn Mongoose 5.x, setting a key to `undefined` in an update operation was equivalent to setting it to `null`.\n\n``` javascript\nlet res = await Test.findOneAndUpdate({}, { $set: { name: undefined } }, { new: true });\n\nres.name; // `null` in Mongoose 5.x\n\n// Equivalent to `findOneAndUpdate({}, {}, { new: true })` because `omitUndefined` will\n// remove `name: undefined`\nres = await Test.findOneAndUpdate({}, { $set: { name: undefined } }, { new: true, omitUndefined: true });\n```\n\nMongoose 5.x supported an `omitUndefined` option to strip out `undefined` keys. In Mongoose 6.x, the `omitUndefined` option has been removed, and Mongoose will always strip out undefined keys.\n\n``` javascript\n// In Mongoose 6, equivalent to `findOneAndUpdate({}, {}, { new: true })` because Mongoose will\n// remove `name: undefined`\nconst res = await Test.findOneAndUpdate({}, { $set: { name: undefined } }, { new: true });\n```\n\nThe only workaround is to explicitly set properties to `null` in your updates:\n\n``` javascript\nconst res = await Test.findOneAndUpdate({}, { $set: { name: null } }, { new: true });\n```\n\n## Document Parameter to Default Functions\n\nMongoose now passes the document as the first parameter to `default` functions, which is helpful for using [arrow functions](https://masteringjs.io/tutorials/fundamentals/arrow) with defaults.\n\nThis may affect you if you pass a function that expects different parameters to `default`, like `default: mongoose.Types.ObjectId`. See [gh-9633](https://github.com/Automattic/mongoose/issues/9633). If you're passing a default function that does **not** utilize the document, change `default: myFunction` to `default: () => myFunction()` to avoid accidentally passing parameters that potentially change the behavior.\n\n``` javascript\nconst schema = new Schema({\n  name: String,\n  age: Number,\n  canVote: {\n    type: Boolean,\n    // Default functions now receive a `doc` parameter, helpful for arrow functions\n    default: doc => doc.age >= 18\n  }\n});\n```\n\n## Arrays are Proxies\n\nMongoose arrays are now ES6 proxies. You no longer need to `markModified()` after setting an array index directly.\n\n``` javascript\nconst post = await BlogPost.findOne();\n\npost.tags[0] = 'javascript';\nawait post.save(); // Works, no need for `markModified()`!\n```\n\n## `typePojoToMixed`\n\nSchema paths declared with `type: { name: String }` become single nested subdocs in Mongoose 6, as opposed to Mixed in Mongoose 5. This removes the need for the `typePojoToMixed` option. See [gh-7181](https://github.com/Automattic/mongoose/issues/7181).\n\n``` javascript\n// In Mongoose 6, the below makes `foo` into a subdocument with a `name` property.\n// In Mongoose 5, the below would make `foo` a `Mixed` type, _unless_ you set `typePojoToMixed: true`.\nconst schema = new Schema({\n  foo: { type: { name: String } }\n});\n```\n\n## `strictPopulate()`\n\nMongoose now throws an error if you `populate()` a path that isn't defined in your schema. This is only for cases when we can infer the local schema, like when you use `Query#populate()`, **not** when you call `Model.populate()` on a POJO. See [gh-5124](https://github.com/Automattic/mongoose/issues/5124).\n\n## Subdocument `ref` Function Context\n\nWhen populating a subdocument with a function `ref` or `refPath`, `this` is now the subdocument being populated, not the top-level document. See [\\#8469](https://github.com/Automattic/mongoose/issues/8469).\n\n``` javascript\nconst schema = new Schema({\n  works: [{\n    modelId: String,\n    data: {\n      type: mongoose.ObjectId,\n      ref: function(doc) {\n        // In Mongoose 6, `doc` is the array element, so you can access `modelId`.\n        // In Mongoose 5, `doc` was the top-level document.\n        return doc.modelId;\n      }\n    }\n  }]\n});\n```\n\n## Schema Reserved Names Warning\n\nUsing `save`, `isNew`, and other Mongoose reserved names as schema path names now triggers a warning, not an error. You can suppress the warning by setting the `suppressReservedKeysWarning` in your schema options: `new Schema({ save: String }, { suppressReservedKeysWarning: true })`. Keep in mind that this may break plugins that rely on these reserved names.\n\n## Subdocument Paths\n\nSingle nested subdocs have been renamed to \"subdocument paths\". So `SchemaSingleNestedOptions` is now `SchemaSubdocumentOptions` and `mongoose.Schema.Types.Embedded` is now `mongoose.Schema.Types.Subdocument`. See [gh-10419](https://github.com/Automattic/mongoose/issues/10419)\n\n## Creating Aggregation Cursors\n\n`Aggregate#cursor()` now returns an AggregationCursor instance to be consistent with `Query#cursor()`. You no longer need to do `Model.aggregate(pipeline).cursor().exec()` to get an aggregation cursor, just `Model.aggregate(pipeline).cursor()`.\n\n## `autoCreate` Defaults to `true`\n\n`autoCreate` is `true` by default **unless** readPreference is secondary or secondaryPreferred, which means Mongoose will attempt to create every model's underlying collection before creating indexes. If readPreference is secondary or secondaryPreferred, Mongoose will default to `false` for both `autoCreate` and `autoIndex` because both `createCollection()` and `createIndex()` will fail when connected to a secondary.\n\n## No More `context: 'query'`\n\nThe `context` option for queries has been removed. Now Mongoose always uses `context = 'query'`.\n\n## Custom Validators with Populated Paths\n\nMongoose 6 always calls validators with depopulated paths (that is, with the id rather than the document itself). In Mongoose 5, Mongoose would call validators with the populated doc if the path was populated. See [\\#8042](https://github.com/Automattic/mongoose/issues/8042)\n\n## Disconnected Event with Replica Sets\n\nWhen connected to a replica set, connections now emit 'disconnected' when connection to the primary is lost. In Mongoose 5, connections only emitted 'disconnected' when losing connection to all members of the replica set.\n\nHowever, Mongoose 6 does **not** buffer commands while a connection is disconnected. So you can still successfully execute commands like queries with `readPreference = 'secondary'`, even if the Mongoose connection is in the disconnected state.\n\n## Removed `execPopulate()`\n\n`Document#populate()` now returns a promise and is now no longer chainable.\n\n- Replace `await doc.populate('path1').populate('path2').execPopulate();` with `await doc.populate(['path1', 'path2']);`\n\n- Replace `await doc.populate('path1', 'select1').populate('path2', 'select2').execPopulate();` with\n\n  ``` javascript\n  await doc.populate([{path: 'path1', select: 'select1'}, {path: 'path2', select: 'select2'}]);\n  ```\n\n## `create()` with Empty Array\n\n`await Model.create([])` in v6.0 returns an empty array when provided an empty array, in v5.0 it used to return `undefined`. If any of your code is checking whether the output is `undefined` or not, you need to modify it with the assumption that `await Model.create(...)` will always return an array if provided an array.\n\n## Removed Nested Path Merging\n\n`doc.set({ child: { age: 21 } })` now works the same whether `child` is a nested path or a subdocument: Mongoose will overwrite the value of `child`. In Mongoose 5, this operation would merge `child` if `child` was a nested path.\n\n## ObjectId `valueOf()`\n\nMongoose now adds a `valueOf()` function to ObjectIds. This means you can now use `==` to compare an ObjectId against a string.\n\n``` javascript\nconst a = ObjectId('6143b55ac9a762738b15d4f0');\n\na == '6143b55ac9a762738b15d4f0'; // true\n```\n\n## Immutable `createdAt`\n\nIf you set `timestamps: true`, Mongoose will now make the `createdAt` property `immutable`. See [gh-10139](https://github.com/Automattic/mongoose/issues/10139)\n\n## Removed Validator `isAsync`\n\n`isAsync` is no longer an option for `validate`. Use an `async function` instead.\n\n## Removed `safe`\n\n`safe` is no longer an option for schemas, queries, or `save()`. Use `writeConcern` instead.\n\n## SchemaType `set` parameters\n\nMongoose now calls setter functions with `priorValue` as the 2nd parameter, rather than `schemaType` in Mongoose 5.\n\n``` javascript\nconst userSchema = new Schema({\n  name: {\n    type: String,\n    trimStart: true,\n    set: trimStartSetter\n  }\n});\n\n// in v5.x the parameters were (value, schemaType), in v6.x the parameters are (value, priorValue, schemaType).\nfunction trimStartSetter(val, priorValue, schemaType) {\n  if (schemaType.options.trimStart && typeof val === 'string') {\n    return val.trimStart();\n  }\n  return val;\n}\n\nconst User = mongoose.model('User', userSchema);\n\nconst user = new User({ name: 'Robert Martin' });\nconsole.log(user.name); // 'robert martin'\n```\n\n## `toObject()` and `toJSON()` Use Nested Schema `minimize`\n\nThis change was technically released with 5.10.5, but [caused issues for users migrating from 5.9.x to 6.x](https://github.com/Automattic/mongoose/issues/10827). In Mongoose `< 5.10.5`, `toObject()` and `toJSON()` would use the top-level schema's `minimize` option by default.\n\n``` javascript\nconst child = new Schema({ thing: Schema.Types.Mixed });\nconst parent = new Schema({ child }, { minimize: false });\nconst Parent = model('Parent', parent);\nconst p = new Parent({ child: { thing: {} } });\n\n// In v5.10.4, would contain `child.thing` because `toObject()` uses `parent` schema's `minimize` option\n// In `>= 5.10.5`, `child.thing` is omitted because `child` schema has `minimize: true`\nconsole.log(p.toObject());\n```\n\nAs a workaround, you can either explicitly pass `minimize` to `toObject()` or `toJSON()`:\n\n``` javascript\nconsole.log(p.toObject({ minimize: false }));\n```\n\nOr define the `child` schema inline (Mongoose 6 only) to inherit the parent's `minimize` option.\n\n``` javascript\nconst parent = new Schema({\n  // Implicitly creates a new schema with the top-level schema's `minimize` option.\n  child: { type: { thing: Schema.Types.Mixed } }\n}, { minimize: false });\n```\n\n## No default model for `Query.prototype.populate()`\n\nIn Mongoose 5, calling `populate()` on a mixed type or other path with no `ref` would fall back to using the query's model.\n\n``` javascript\nconst testSchema = new mongoose.Schema({\n  data: String,\n  parents: Array // Array of mixed\n});\n\nconst Test = mongoose.model('Test', testSchema);\n\n// The below `populate()`...\nawait Test.findOne().populate('parents');\n// Is a shorthand for the following populate in Mongoose 5\nawait Test.findOne().populate({ path: 'parents', model: Test });\n```\n\nIn Mongoose 6, populating a path with no `ref`, `refPath`, or `model` is a no-op.\n\n``` javascript\n// The below `populate()` does nothing.\nawait Test.findOne().populate('parents');\n```\n\n## TypeScript changes\n\nThe `Schema` class now takes 3 generic params instead of 4. The 3rd generic param, `SchemaDefinitionType`, is now the same as the 1st generic param `DocType`. Replace `new Schema<UserDocument, UserModel, User>(schemaDefinition)` with `new Schema<UserDocument, UserModel>(schemaDefinition)`\n\n`Types.ObjectId` is now a class, which means you can no longer omit `new` when creating a new ObjectId using `new mongoose.Types.ObjectId()`. Currently, you can still omit `new` in JavaScript, but you **must** put `new` in TypeScript.\n\nThe following legacy types have been removed:\n\n- `ModelUpdateOptions`\n- `DocumentQuery`\n- `HookSyncCallback`\n- `HookAsyncCallback`\n- `HookErrorCallback`\n- `HookNextFunction`\n- `HookDoneFunction`\n- `SchemaTypeOpts`\n- `ConnectionOptions`\n\nMongoose 6 infers the document's type for `this` in virtual getters and setters. In Mongoose 5.x, `this` would be `any` in the following code.\n\n``` javascript\nschema.virtual('myVirtual').get(function() {\n  this; // any in Mongoose 5.x\n});\n```\n\nIn Mongoose 6, `this` will be set to the document type.\n\n``` javascript\nconst schema = new Schema({ name: String });\n\nschema.virtual('myVirtual').get(function() {\n  this.name; // string\n});\n```\n\n## Removed `reconnectTries` and `reconnectInterval` options\n\nThe `reconnectTries` and `reconnectInterval` options have been removed since they are no longer necessary.\n\nThe MongoDB node driver will always attempt to retry any operation for up to `serverSelectionTimeoutMS`, even if MongoDB is down for a long period of time. So, it will never run out of retries or try to reconnect to MongoDB.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/migrating_to_6.html](https://mongoosejs.com/docs/migrating_to_6.html)"
- name: Migrating from 6.x to 7.x
  id: migrating_to_7
  summary: There are several backwards-breaking changes you should be aware of when migrating from Mongoose 6.x to Mongoose 7.x
  description: "# Migrating from 6.x to 7.x\n\nThere are several backwards-breaking changes you should be aware of when migrating from Mongoose 6.x to Mongoose 7.x.\n\nIf you're still on Mongoose 5.x, please read the [Mongoose 5.x to 6.x migration guide](migrating_to_6) and upgrade to Mongoose 6.x first.\n\n- [`strictQuery`](#strictquery)\n- [Removed `remove()`](#removed-remove)\n- [Dropped callback support](#dropped-callback-support)\n- [Removed `update()`](#removed-update)\n- [Discriminator schemas use base schema options by default](#discriminator-schemas-use-base-schema-options-by-default)\n- [Removed `castForQueryWrapper()`, updated `castForQuery()` signature](#removed-castforquerywrapper)\n- [Copy schema options in `Schema.prototype.add()`](#copy-schema-options-in-schema-prototype-add)\n- [ObjectId bsontype now has lowercase d](#objectid-bsontype-now-has-lowercase-d)\n- [Removed support for custom promise libraries](#removed-support-for-custom-promise-libraries)\n- [Removed mapReduce](#removed-mapreduce)\n- [TypeScript-specific changes](#typescript-specific-changes)\n  - [Removed `LeanDocument` and support for `extends Document`](#removed-leandocument-and-support-for-extends-document)\n  - [New parameters for `HydratedDocument`](#new-parameters-for-hydrateddocument)\n\n## `strictQuery`\n\n`strictQuery` is now false by default.\n\n``` javascript\nconst mySchema = new Schema({ field: Number });\nconst MyModel = mongoose.model('Test', mySchema);\n\n// Mongoose will not strip out `notInSchema: 1` because `strictQuery` is false by default\nconst docs = await MyModel.find({ notInSchema: 1 });\n// Empty array in Mongoose 7. In Mongoose 6, this would contain all documents in MyModel\ndocs;\n```\n\n## Removed `remove()`\n\nThe `remove()` method on documents and models has been removed. Use `deleteOne()` or `deleteMany()` instead.\n\n``` javascript\nconst mySchema = new Schema({ field: Number });\nconst MyModel = mongoose.model('Test', mySchema);\n\n// Change this:\nawait MyModel.remove(filter);\n\n// To this:\nawait MyModel.deleteOne(filter);\n// Or this, if you want to delete multiple:\nawait MyModel.deleteMany(filter);\n\n// For documents, change this:\nawait doc.remove();\n\n// To this:\nawait doc.deleteOne();\n```\n\nKeep in mind that `deleteOne()` hooks are treated as query middleware by default. So for middleware, please do the following:\n\n``` javascript\n// Replace this:\nschema.pre('remove', function() {\n  /* ... */\n});\n\n// With this:\nschema.pre('deleteOne', { document: true, query: false }, function() {\n  /* ... */\n});\n```\n\n## Dropped callback support\n\nThe following functions no longer accept callbacks. They always return promises.\n\n- `Aggregate.prototype.exec`\n- `Aggregate.prototype.explain`\n- `AggregationCursor.prototype.close`\n- `Connection.prototype.startSession`\n- `Connection.prototype.dropCollection`\n- `Connection.prototype.createCollection`\n- `Connection.prototype.dropDatabase`\n- `Connection.prototype.openUri`\n- `Connection.prototype.close`\n- `Connection.prototype.destroy`\n- `Document.prototype.populate`\n- `Document.prototype.validate`\n- `Mongoose.prototype.connect`\n- `Mongoose.prototype.createConnection`\n- `Model.prototype.save`\n- `Model.aggregate`\n- `Model.bulkWrite`\n- `Model.cleanIndexes`\n- `Model.countDocuments`\n- `Model.create`\n- `Model.createCollection`\n- `Model.createIndexes`\n- `Model.deleteOne`\n- `Model.deleteMany`\n- `Model.distinct`\n- `Model.ensureIndexes`\n- `Model.estimatedDocumentCount`\n- `Model.exists`\n- `Model.find`\n- `Model.findById`\n- `Model.findByIdAndUpdate`\n- `Model.findByIdAndReplace`\n- `Model.findOne`\n- `Model.findOneAndDelete`\n- `Model.findOneAndUpdate`\n- `Model.findOneAndRemove`\n- `Model.insertMany`\n- `Model.listIndexes`\n- `Model.replaceOne`\n- `Model.syncIndexes`\n- `Model.updateMany`\n- `Model.updateOne`\n- `Query.prototype.find`\n- `Query.prototype.findOne`\n- `Query.prototype.findOneAndDelete`\n- `Query.prototype.findOneAndUpdate`\n- `Query.prototype.findOneAndRemove`\n- `Query.prototype.findOneAndReplace`\n- `Query.prototype.validate`\n- `Query.prototype.deleteOne`\n- `Query.prototype.deleteMany`\n- `Query.prototype.exec`\n- `QueryCursor.prototype.close`\n- `QueryCursor.prototype.next`\n\nIf you are using the above functions with callbacks, we recommend switching to async/await, or promises if async functions don't work for you. If you need help refactoring a legacy codebase, [this tool from Mastering JS callbacks to async await](https://masteringjs.io/tutorials/tools/callback-to-async-await) using ChatGPT.\n\n``` javascript\n// Before\nconn.startSession(function(err, session) {\n  // ...\n});\n\n// After\nconst session = await conn.startSession();\n// Or:\nconn.startSession().then(sesson => { /* ... */ });\n\n// With error handling\ntry {\n  await conn.startSession();\n} catch (err) { /* ... */ }\n// Or:\nconst [err, session] = await conn.startSession().then(\n  session => ([null, session]),\n  err => ([err, null])\n);\n```\n\n## Removed `update()`\n\n`Model.update()`, `Query.prototype.update()`, and `Document.prototype.update()` have been removed. Use `updateOne()` instead.\n\n``` javascript\n// Before\nawait Model.update(filter, update);\nawait doc.update(update);\n\n// After\nawait Model.updateOne(filter, update);\nawait doc.updateOne(update);\n```\n\n## Discriminator schemas use base schema options by default\n\nWhen you use `Model.discriminator()`, Mongoose will now use the discriminator base schema's options by default. This means you don't need to explicitly set child schema options to match the base schema's.\n\n``` javascript\nconst baseSchema = Schema({}, { typeKey: '$type' });\nconst Base = db.model('Base', baseSchema);\n\n// In Mongoose 6.x, the `Base.discriminator()` call would throw because\n// no `typeKey` option. In Mongoose 7, Mongoose uses the base schema's\n// `typeKey` by default.\nconst childSchema = new Schema({}, {});\nconst Test = Base.discriminator('Child', childSchema);\n\nTest.schema.options.typeKey; // '$type'\n```\n\n## Removed `castForQueryWrapper`, updated `castForQuery()` signature\n\nMongoose now always calls SchemaType `castForQuery()` method with 3 arguments: `$conditional`, `value`, and `context`. If you've implemented a custom schema type that defines its own `castForQuery()` method, you need to update the method as follows.\n\n``` javascript\n// Mongoose 6.x format:\nMySchemaType.prototype.castForQuery = function($conditional, value) {\n  if (arguments.length === 2) {\n    // Handle casting value with `$conditional` - $eq, $in, $not, etc.\n  } else {\n    value = $conditional;\n    // Handle casting `value` with no conditional\n  }\n};\n\n// Mongoose 7.x format\nMySchemaType.prototype.castForQuery = function($conditional, value, context) {\n  if ($conditional != null) {\n    // Handle casting value with `$conditional` - $eq, $in, $not, etc.\n  } else {\n    // Handle casting `value` with no conditional\n  }\n};\n```\n\n## Copy Schema options in `Schema.prototype.add()`\n\nMongoose now copies user defined schema options when adding one schema to another. For example, `childSchema` below will get `baseSchema`'s `id` and `toJSON` options.\n\n``` javascript\nconst baseSchema = new Schema({ created: Date }, { id: true, toJSON: { virtuals: true } });\nconst childSchema = new Schema([baseSchema, { name: String }]);\n\nchildSchema.options.toJSON; // { virtuals: true } in Mongoose 7. undefined in Mongoose 6.\n```\n\nThis applies both when creating a new schema using an array of schemas, as well as when calling `add()` as follows.\n\n``` javascript\nchildSchema.add(new Schema({}, { toObject: { virtuals: true } }));\n\nchildSchema.options.toObject; // { virtuals: true } in Mongoose 7. undefined in Mongoose 6.\n```\n\n## ObjectId bsontype now has lowercase d\n\nThe internal `_bsontype` property on ObjectIds is equal to `'ObjectId'` in Mongoose 7, as opposed to `'ObjectID'` in Mongoose 6.\n\n``` javascript\nconst oid = new mongoose.Types.ObjectId();\n\noid._bsontype; // 'ObjectId' in Mongoose 7, 'ObjectID' in older versions of Mongoose\n```\n\nPlease update any places where you use `_bsontype` to check if an object is an ObjectId. This may also affect libraries that use Mongoose.\n\n## Removed mapReduce\n\nMongoDB no longer supports `mapReduce`, so Mongoose 7 no longer has a `Model.mapReduce()` function. Use the aggregation framework as a replacement for `mapReduce()`.\n\n``` javascript\n// The following no longer works in Mongoose 7.\nconst o = {\n  map: function() {\n    emit(this.author, 1);\n  },\n  reduce: function(k, vals) {\n    return vals.length;\n  }\n};\n\nawait MR.mapReduce(o);\n```\n\n## Removed Support for custom promise libraries\n\nMongoose 7 no longer supports plugging in custom promise libraries. So the following no longer makes Mongoose return Bluebird promises in Mongoose 7.\n\n``` javascript\nconst mongoose = require('mongoose');\n\n// No-op on Mongoose 7\nmongoose.Promise = require('bluebird');\n```\n\nIf you want to use Bluebird for all promises globally, you can do the following:\n\n``` javascript\nglobal.Promise = require('bluebird');\n```\n\n## TypeScript-specific Changes\n\n### Removed LeanDocument and support for extends Document\n\nMongoose 7 no longer exports a `LeanDocument` type, and no longer supports passing a document type that `extends Document` into `Model<>`.\n\n``` javascript\n// No longer supported\ninterface ITest extends Document {\n  name?: string;\n}\nconst Test = model<ITest>('Test', schema);\n\n// Do this instead, no `extends Document`\ninterface ITest {\n  name?: string;\n}\nconst Test = model<ITest>('Test', schema);\n\n// If you need to access the hydrated document type, use the following code\ntype TestDocument = ReturnType<(typeof Test)['hydrate']>;\n```\n\n### New Parameters for HydratedDocument\n\nMongoose's `HydratedDocument` type transforms a raw document interface into the type of the hydrated Mongoose document, including virtuals, methods, etc. In Mongoose 7, the generic parameters to `HydratedDocument` have changed. In Mongoose 6, the generic parameters were:\n\n``` javascript\ntype HydratedDocument<\n  DocType,\n  TMethodsAndOverrides = {},\n  TVirtuals = {}\n> = Document<unknown, any, DocType> &\nRequire_id<DocType> &\nTMethodsAndOverrides &\nTVirtuals;\n```\n\nIn Mongoose 7, the new type is as follows.\n\n``` javascript\ntype HydratedDocument<\n  DocType,\n  TOverrides = {},\n  TQueryHelpers = {}\n> = Document<unknown, TQueryHelpers, DocType> &\nRequire_id<DocType> &\nTOverrides;\n```\n\nIn Mongoose 7, the first parameter is the raw document interface, the 2nd parameter is any document-specific overrides (usually virtuals and methods), and the 3rd parameter is any query helpers associated with the document's model.\n\nThe key difference is that, in Mongoose 6, the 3rd generic param was the document's *virtuals*. In Mongoose 7, the 3rd generic param is the document's *query helpers*.\n\n``` javascript\n// Mongoose 6 version:\ntype UserDocument = HydratedDocument<TUser, TUserMethods, TUserVirtuals>;\n\n// Mongoose 7:\ntype UserDocument = HydratedDocument<TUser, TUserMethods & TUserVirtuals, TUserQueryHelpers>;\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/migrating_to_7.html](https://mongoosejs.com/docs/migrating_to_7.html)"
- name: Mixed
  id: schematypes#mixed
  summary: An "anything goes" SchemaType
  belongs_to: SchemaTypes
  description: |-
    ### Mixed

    An "anything goes" SchemaType. Mongoose will not do any casting on mixed paths. You can define a mixed path using `Schema.Types.Mixed` or by passing an empty object literal. The following are equivalent.

    ``` javascript
    constAny = new Schema({ any: {} });
    const Any = new Schema({ any: Object });
    const Any = new Schema({ any: Schema.Types.Mixed });
    const Any = new Schema({ any: mongoose.Mixed });
    ```

    Since Mixed is a schema-less type, you can change the value to anything else you like, but Mongoose loses the ability to auto detect and save those changes. To tell Mongoose that the value of a Mixed type has changed, you need to call `doc.markModified(path)`, passing the path to the Mixed type you just changed.

    To avoid these side-effects, a [Subdocument](subdocs) path may be used instead.

    ``` javascript
    person.anything = { x: [3, 4, { y: 'changed' }] };
    person.markModified('anything');
    person.save(); // Mongoose will save changes to `anything`.
    ```
- name: Model
  id: api/model
  summary: A Model is a class that's your primary tool for interacting with MongoDB
  description: "# Model\n\n### Model()\n\n##### Parameters:\n\n- `doc` «Object» values for initial set\n- `[fields]` «Object» optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](query#Query.prototype.select()).\n- `[skipId=false]` «Boolean» optional boolean. If true, mongoose doesn't add an `_id` field to the document.\n\n##### Inherits:\n\n- [«Document»](document)\n\nA Model is a class that's your primary tool for interacting with MongoDB. An instance of a Model is called a [Document](document#Document).\n\nIn Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model` class. You should not use the `mongoose.Model` class directly. The [`mongoose.model()`](mongoose#Mongoose.prototype.model()) and [`connection.model()`](connection#Connection.prototype.model()) functions create subclasses of `mongoose.Model` as shown below.\n\n#### [Example:](#example)\n\n``` javascript\n// `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\nconst UserModel = mongoose.model('User', new Schema({ name: String }));\n\n// You can use a Model to create new documents using `new`:\nconst userDoc = new UserModel({ name: 'Foo' });\nawait userDoc.save();\n\n// You also use a model to create queries:\nconst userFromDb = await UserModel.findOne({ name: 'Foo' });\n```\n\n### Model.$where()\n\n##### Parameters:\n\n- `argument` «String\\|Function» is a javascript string or anonymous function\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Query.$where](query#Query.prototype.$where)\n\nCreates a `Query` and specifies a `$where` condition.\n\nSometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n\n``` javascript\nBlog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n```\n\n### Model.aggregate()\n\n##### Parameters:\n\n- `[pipeline]` «Array» aggregation pipeline as an array of objects\n- `[options]` «Object» aggregation options\n\n##### Returns:\n\n- «Aggregate»\n\n##### See:\n\n- [Aggregate](aggregate#Aggregate())\n- [MongoDB](https://www.mongodb.com/docs/manual/applications/aggregation/)\n\nPerforms [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n\nIf a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.\n\nThis function triggers the following middleware.\n\n- `aggregate()`\n\n#### [Example:](#example)\n\n``` javascript\n// Find the max balance of all accounts\nconst res = await Users.aggregate([\n  { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n  { $project: { _id: 0, maxBalance: 1 }}\n]);\n\nconsole.log(res); // [ { maxBalance: 98000 } ]\n\n// Or use the aggregation pipeline builder.\nconst res = await Users.aggregate().\n  group({ _id: null, maxBalance: { $max: '$balance' } }).\n  project('-id maxBalance').\n  exec();\nconsole.log(res); // [ { maxBalance: 98 } ]\n```\n\n#### [Note:](#note)\n\n- Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n- The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n\n#### [More About Aggregations:](#more-about-aggregations)\n\n- [Mongoose `Aggregate`](aggregate)\n- [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n- [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n\n### Model.applyDefaults()\n\n##### Parameters:\n\n- `obj` «Object\\|Document» object or document to apply defaults on\n\nApply defaults to the given document or POJO.\n\n### Model.bulkSave()\n\n##### Parameters:\n\n- `documents` «Array\\<Document\\>»\n- `[options]` «Object» options passed to the underlying `bulkWrite()`\n\n- `[options.timestamps]` «Boolean» defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this bulk write. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.w=1]` «String\\|number» The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](query#Query.prototype.w()) for more information.\n\n&nbsp;\n\n- `[options.wtimeout=null]` «number» The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n\n&nbsp;\n\n- `[options.j=true]` «Boolean» If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n\ntakes an array of documents, gets the changes and inserts/updates documents in the database according to whether or not the document is new, or whether it has changes or not.\n\n`bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n\n### Model.bulkWrite()\n\n##### Parameters:\n\n- `ops` «Array»\n\n&nbsp;\n\n- `[ops.insertOne.document]` «Object» The document to insert\n\n&nbsp;\n\n- `[ops.updateOne.filter]` «Object» Update the first document that matches this filter\n\n&nbsp;\n\n- `[ops.updateOne.update]` «Object» An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n\n&nbsp;\n\n- `[ops.updateOne.upsert=false]` «Boolean» If true, insert a doc if none match\n\n&nbsp;\n\n- `[ops.updateOne.timestamps=true]` «Boolean» If false, do not apply [timestamps](../guide#timestamps) to the operation\n\n&nbsp;\n\n- `[ops.updateOne.collation]` «Object» The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n\n&nbsp;\n\n- `[ops.updateOne.arrayFilters]` «Array» The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n\n&nbsp;\n\n- `[ops.updateMany.filter]` «Object» Update all the documents that match this filter\n\n&nbsp;\n\n- `[ops.updateMany.update]` «Object» An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n\n&nbsp;\n\n- `[ops.updateMany.upsert=false]` «Boolean» If true, insert a doc if no documents match `filter`\n\n&nbsp;\n\n- `[ops.updateMany.timestamps=true]` «Boolean» If false, do not apply [timestamps](../guide#timestamps) to the operation\n\n&nbsp;\n\n- `[ops.updateMany.collation]` «Object» The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n\n&nbsp;\n\n- `[ops.updateMany.arrayFilters]` «Array» The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n\n&nbsp;\n\n- `[ops.deleteOne.filter]` «Object» Delete the first document that matches this filter\n\n&nbsp;\n\n- `[ops.deleteMany.filter]` «Object» Delete all documents that match this filter\n\n&nbsp;\n\n- `[ops.replaceOne.filter]` «Object» Replace the first document that matches this filter\n\n&nbsp;\n\n- `[ops.replaceOne.replacement]` «Object» The replacement document\n\n&nbsp;\n\n- `[ops.replaceOne.upsert=false]` «Boolean» If true, insert a doc if no documents match `filter`\n\n&nbsp;\n\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.ordered=true]` «Boolean» If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this bulk write. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.w=1]` «String\\|number» The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](query#Query.prototype.w()) for more information.\n\n&nbsp;\n\n- `[options.wtimeout=null]` «number» The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n\n&nbsp;\n\n- `[options.j=true]` «Boolean» If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n\n&nbsp;\n\n- `[options.skipValidation=false]` «Boolean» Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n\n&nbsp;\n\n- `[options.bypassDocumentValidation=false]` «Boolean» If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n\n&nbsp;\n\n- `[options.throwOnValidationError=false]` «Boolean» If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n\n&nbsp;\n\n- `[options.strict=null]` «Boolean» Overwrites the [`strict` option](../guide#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n\n##### Returns:\n\n- «Promise» resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n\nSends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`, `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one command. This is faster than sending multiple independent operations (e.g. if you use `create()`) because with `bulkWrite()` there is only one round trip to MongoDB.\n\nMongoose will perform casting on all operations you provide.\n\nThis function does **not** trigger any middleware, neither `save()`, nor `update()`. If you need to trigger `save()` middleware for every document use [`create()`](#Model.create()) instead.\n\n#### [Example:](#example)\n\n``` javascript\nCharacter.bulkWrite([\n  {\n    insertOne: {\n      document: {\n        name: 'Eddard Stark',\n        title: 'Warden of the North'\n      }\n    }\n  },\n  {\n    updateOne: {\n      filter: { name: 'Eddard Stark' },\n      // If you were using the MongoDB driver directly, you'd need to do\n      // `update: { $set: { title: ... } }` but mongoose adds $set for\n      // you.\n      update: { title: 'Hand of the King' }\n    }\n  },\n  {\n    deleteOne: {\n      filter: { name: 'Eddard Stark' }\n    }\n  }\n]).then(res => {\n // Prints \"1 1 1\"\n console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n});\n```\n\nThe [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n\n- `insertOne`\n- `updateOne`\n- `updateMany`\n- `deleteOne`\n- `deleteMany`\n- `replaceOne`\n\n### Model.castObject()\n\n##### Parameters:\n\n- `obj` «Object» object or document to cast\n- `options` «Object» options passed to castObject\n- `options.ignoreCastErrors` «Boolean» If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n\nCast the given POJO to the model's schema\n\n#### [Example:](#example)\n\n``` javascript\nconst Test = mongoose.model('Test', Schema({ num: Number }));\n\nconst obj = Test.castObject({ num: '42' });\nobj.num; // 42 as a number\n\nTest.castObject({ num: 'not a number' }); // Throws a ValidationError\n```\n\n### Model.cleanIndexes()\n\n##### Parameters:\n\n- `[callback]` «Function» optional callback\n\n##### Returns:\n\n- «Promise,undefined,void» Returns `undefined` if callback is specified, returns a promise if no callback.\n\nDeletes all indexes that aren't defined in this model's schema. Used by `syncIndexes()`.\n\nThe returned promise resolves to a list of the dropped indexes' names as an array\n\n### Model.count()\n\n~DEPRECATED~\n\n##### Parameters:\n\n- `[filter]` «Object»\n\n##### Returns:\n\n- «Query»\n\nCounts number of documents that match `filter` in a database collection.\n\nThis method is deprecated. If you want to count the number of documents in a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](#Model.estimatedDocumentCount()) instead. Otherwise, use the [`countDocuments()`](#Model.countDocuments()) function instead.\n\n#### [Example:](#example)\n\n``` javascript\nconst count = await Adventure.count({ type: 'jungle' });\nconsole.log('there are %d jungle adventures', count);\n```\n\n### Model.countDocuments()\n\n##### Parameters:\n\n- `filter` «Object»\n\n##### Returns:\n\n- «Query»\n\nCounts number of documents matching `filter` in a database collection.\n\n#### [Example:](#example)\n\n``` javascript\nAdventure.countDocuments({ type: 'jungle' }, function (err, count) {\n  console.log('there are %d jungle adventures', count);\n});\n```\n\nIf you want to count all documents in a large collection, use the [`estimatedDocumentCount()` function](#Model.estimatedDocumentCount()) instead. If you call `countDocuments({})`, MongoDB will always execute a full collection scan and **not** use any indexes.\n\nThe `countDocuments()` function is similar to `count()`, but there are a [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments). Below are the operators that `count()` supports but `countDocuments()` does not, and the suggested replacement:\n\n- `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n- `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n- `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n\n### Model.create()\n\n##### Parameters:\n\n- `docs` «Array\\|Object» Documents to insert, as a spread or array\n- `[options]` «Object» Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](#Model.prototype.save()) for available options.\n\n&nbsp;\n\n- `[options.ordered]` «Boolean» saves the docs in series rather than parallel.\n\n&nbsp;\n\n- `[options.aggregateErrors]` «Boolean» Aggregate Errors instead of throwing the first one that occurs. Default: false\n\n##### Returns:\n\n- «Promise»\n\nShortcut for saving one or more documents to the database. `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in docs.\n\nThis function triggers the following middleware.\n\n- `save()`\n\n#### [Example:](#example)\n\n``` javascript\n// Insert one new `Character` document\nawait Character.create({ name: 'Jean-Luc Picard' });\n\n// Insert multiple new `Character` documents\nawait Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n\n// Create a new character within a transaction. Note that you **must**\n// pass an array as the first parameter to `create()` if you want to\n// specify options.\nawait Character.create([{ name: 'Jean-Luc Picard' }], { session });\n```\n\n### Model.createCollection()\n\n##### Parameters:\n\n- `[options]` «Object» see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n\nCreate the collection for this model. By default, if no indexes are specified, mongoose will not create the collection for the model until any documents are created. Use this method to create the collection explicitly.\n\nNote 1: You may need to call this before starting a transaction See <https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations>\n\nNote 2: You don't have to call this if your schema contains index or unique field. In that case, just use `Model.init()`\n\n#### [Example:](#example)\n\n``` javascript\nconst userSchema = new Schema({ name: String })\nconst User = mongoose.model('User', userSchema);\n\nUser.createCollection().then(function(collection) {\n  console.log('Collection is created!');\n});\n```\n\n### Model.createIndexes()\n\n##### Parameters:\n\n- `[options]` «Object» internal options\n\n##### Returns:\n\n- «Promise»\n\nSimilar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex) function.\n\n### Model.db\n\n##### Type:\n\n- «property»\n\nConnection instance the model uses.\n\n### Model.deleteMany()\n\n##### Parameters:\n\n- `conditions` «Object»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\nDeletes all of the documents that match `conditions` from the collection. It returns an object with the property `deletedCount` containing the number of documents deleted. Behaves like `remove()`, but deletes all documents that match `conditions` regardless of the `single` option.\n\n#### [Example:](#example)\n\n``` javascript\nawait Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n```\n\n#### [Note:](#note)\n\nThis function triggers `deleteMany` query hooks. Read the [middleware docs](../middleware#naming) to learn more.\n\n### Model.deleteOne()\n\n##### Parameters:\n\n- `conditions` «Object»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\nDeletes the first document that matches `conditions` from the collection. It returns an object with the property `deletedCount` indicating how many documents were deleted. Behaves like `remove()`, but deletes at most one document regardless of the `single` option.\n\n#### [Example:](#example)\n\n``` javascript\nawait Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n```\n\n#### [Note:](#note)\n\nThis function triggers `deleteOne` query hooks. Read the [middleware docs](../middleware#naming) to learn more.\n\n### Model.diffIndexes()\n\n##### Parameters:\n\n- `[options]` «Object»\n\nDoes a dry-run of Model.syncIndexes(), meaning that the result of this function would be the result of Model.syncIndexes().\n\n### Model.discriminator()\n\n##### Parameters:\n\n- `name` «String» discriminator model name\n- `schema` «Schema» discriminator model schema\n- `[options]` «Object\\|String» If string, same as `options.value`.\n\n&nbsp;\n\n- `[options.value]` «String» the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n\n&nbsp;\n\n- `[options.clone=true]` «Boolean» By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n\n&nbsp;\n\n- `[options.overwriteModels=false]` «Boolean» by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n\n&nbsp;\n\n- `[options.mergeHooks=true]` «Boolean» By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n\n&nbsp;\n\n- `[options.mergePlugins=true]` «Boolean» By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n\n##### Returns:\n\n- «Model» The newly created discriminator model\n\nAdds a discriminator type.\n\n#### [Example:](#example)\n\n``` javascript\nfunction BaseSchema() {\n  Schema.apply(this, arguments);\n\n  this.add({\n    name: String,\n    createdAt: Date\n  });\n}\nutil.inherits(BaseSchema, Schema);\n\nconst PersonSchema = new BaseSchema();\nconst BossSchema = new BaseSchema({ department: String });\n\nconst Person = mongoose.model('Person', PersonSchema);\nconst Boss = Person.discriminator('Boss', BossSchema);\nnew Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n\nconst employeeSchema = new Schema({ boss: ObjectId });\nconst Employee = Person.discriminator('Employee', employeeSchema, 'staff');\nnew Employee().__t; // \"staff\" because of 3rd argument above\n```\n\n### Model.distinct()\n\n##### Parameters:\n\n- `field` «String»\n- `[conditions]` «Object» optional\n\n##### Returns:\n\n- «Query»\n\nCreates a Query for a `distinct` operation.\n\n#### [Example:](#example)\n\n``` javascript\nconst query = Link.distinct('url');\nquery.exec();\n```\n\n### Model.ensureIndexes()\n\n##### Parameters:\n\n- `[options]` «Object» internal options\n\n##### Returns:\n\n- «Promise»\n\nSends `createIndex` commands to mongo for each index declared in the schema. The `createIndex` commands are sent in series.\n\n#### [Example:](#example)\n\n``` javascript\nEvent.ensureIndexes(function (err) {\n  if (err) return handleError(err);\n});\n```\n\nAfter completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n\n#### [Example:](#example-1)\n\n``` javascript\nconst eventSchema = new Schema({ thing: { type: 'string', unique: true } })\nconst Event = mongoose.model('Event', eventSchema);\n\nEvent.on('index', function (err) {\n  if (err) console.error(err); // error occurred during index creation\n})\n```\n\n*NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.*\n\n### Model.estimatedDocumentCount()\n\n##### Parameters:\n\n- `[options]` «Object»\n\n##### Returns:\n\n- «Query»\n\nEstimates the number of documents in the MongoDB collection. Faster than using `countDocuments()` for large collections because `estimatedDocumentCount()` uses collection metadata rather than scanning the entire collection.\n\n#### [Example:](#example)\n\n``` javascript\nconst numAdventures = await Adventure.estimatedDocumentCount();\n```\n\n### Model.events\n\n##### Type:\n\n- «property»\n\nEvent emitter that reports any errors that occurred. Useful for global error handling.\n\n#### [Example:](#example)\n\n``` javascript\nMyModel.events.on('error', err => console.log(err.message));\n\n// Prints a 'CastError' because of the above handler\nawait MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n```\n\n### Model.exists()\n\n##### Parameters:\n\n- `filter` «Object»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n##### Returns:\n\n- «Query»\n\nReturns a document with `_id` only if at least one document exists in the database that matches the given `filter`, and `null` otherwise.\n\nUnder the hood, `MyModel.exists({ answer: 42 })` is equivalent to `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n\n#### [Example:](#example)\n\n``` javascript\nawait Character.deleteMany({});\nawait Character.create({ name: 'Jean-Luc Picard' });\n\nawait Character.exists({ name: /picard/i }); // { _id: ... }\nawait Character.exists({ name: /riker/i }); // null\n```\n\nThis function triggers the following middleware.\n\n- `findOne()`\n\n### Model.find()\n\n##### Parameters:\n\n- `filter` «Object\\|ObjectId»\n- `[projection]` «Object\\|String\\|Array\\[String\\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [field selection](query#Query.prototype.select())\n- [query casting](../tutorials/query_casting)\n\nFinds documents.\n\nMongoose casts the `filter` to match the model's schema before the command is sent. See our [query casting tutorial](../tutorials/query_casting) for more information on how Mongoose casts `filter`.\n\n#### [Example:](#example)\n\n``` javascript\n// find all documents\nawait MyModel.find({});\n\n// find all documents named john and at least 18\nawait MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n\n// executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\nawait MyModel.find({ name: /john/i }, 'name friends').exec();\n\n// passing options\nawait MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n```\n\n### Model.findById()\n\n##### Parameters:\n\n- `id` «Any» value of `_id` to query by\n- `[projection]` «Object\\|String\\|Array\\[String\\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [field selection](query#Query.prototype.select())\n- [lean queries](../tutorials/lean)\n- [findById in Mongoose](https://masteringjs.io/tutorials/mongoose/find-by-id)\n\nFinds a single document by its \\_id field. `findById(id)` is almost\\* equivalent to `findOne({ _id: id })`. If you want to query by a document's `_id`, use `findById()` instead of `findOne()`.\n\nThe `id` is cast based on the Schema before sending the command.\n\nThis function triggers the following middleware.\n\n- `findOne()`\n\n\\* Except for how it treats `undefined`. If you use `findOne()`, you'll see that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent to `findOne({})` and return arbitrary documents. However, mongoose translates `findById(undefined)` into `findOne({ _id: null })`.\n\n#### [Example:](#example)\n\n``` javascript\n// Find the adventure with the given `id`, or `null` if not found\nawait Adventure.findById(id).exec();\n\n// select only the adventures name and length\nawait Adventure.findById(id, 'name length').exec();\n```\n\n### Model.findByIdAndDelete()\n\n##### Parameters:\n\n- `id` «Object\\|Number\\|String» value of `_id` to query by\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Model.findOneAndRemove](#Model.findOneAndRemove())\n- [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)\n\nIssue a MongoDB `findOneAndDelete()` command by a document's \\_id field. In other words, `findByIdAndDelete(id)` is a shorthand for `findOneAndDelete({ _id: id })`.\n\nThis function triggers the following middleware.\n\n- `findOneAndDelete()`\n\n### Model.findByIdAndRemove()\n\n##### Parameters:\n\n- `id` «Object\\|Number\\|String» value of `_id` to query by\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.projection=null]` «Object\\|String\\|Array\\[String\\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())\n\n&nbsp;\n\n- `[options.sort]` «Object\\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.select]` «Object\\|String» sets the document fields to return.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Model.findOneAndRemove](#Model.findOneAndRemove())\n- [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)\n\nIssue a mongodb findOneAndRemove command by a document's \\_id field. `findByIdAndRemove(id, ...)` is equivalent to `findOneAndRemove({ _id: id }, ...)`.\n\nFinds a matching document, removes it, and returns the found document (if any).\n\nThis function triggers the following middleware.\n\n- `findOneAndRemove()`\n\n#### [Example:](#example)\n\n``` javascript\nA.findByIdAndRemove(id, options)  // return Query\nA.findByIdAndRemove(id) // returns Query\nA.findByIdAndRemove()           // returns Query\n```\n\n### Model.findByIdAndUpdate()\n\n##### Parameters:\n\n- `id` «Object\\|Number\\|String» value of `_id` to query by\n- `[update]` «Object»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.returnDocument='before']` «String» Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n\n&nbsp;\n\n- `[options.lean]` «Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](query#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.overwrite=false]` «Boolean» By default, if you don't include any [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace({ \\_id: id }, update, options)](#Model.findOneAndReplace()).\n\n&nbsp;\n\n- `[options.sort]` «Object\\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n\n&nbsp;\n\n- `[options.runValidators]` «Boolean» if true, runs [update validators](../validation#update-validators) on this command. Update validators validate the update operation against the model's schema\n\n&nbsp;\n\n- `[options.setDefaultsOnInsert=true]` «Boolean» If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](../defaults) specified in the model's schema if a new document is created\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.upsert=false]` «Boolean» if true, and no documents found, insert a new document\n\n&nbsp;\n\n- `[options.new=false]` «Boolean» if true, return the modified document rather than the original\n\n&nbsp;\n\n- `[options.select]` «Object\\|String» sets the document fields to return.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Model.findOneAndUpdate](#Model.findOneAndUpdate())\n- [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)\n\nIssues a mongodb findOneAndUpdate command by a document's \\_id field. `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n\nFinds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).\n\nThis function triggers the following middleware.\n\n- `findOneAndUpdate()`\n\n#### [Example:](#example)\n\n``` javascript\nA.findByIdAndUpdate(id, update, options)  // returns Query\nA.findByIdAndUpdate(id, update)           // returns Query\nA.findByIdAndUpdate()                     // returns Query\n```\n\n#### [Note:](#note)\n\nAll top level update keys which are not `atomic` operation names are treated as set operations:\n\n#### [Example:](#example-1)\n\n``` javascript\nModel.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n\n// is sent as\nModel.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n```\n\nThis helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`. To prevent this behaviour, see the `overwrite` option\n\n#### [Note:](#note-1)\n\n`findOneAndX` and `findByIdAndX` functions support limited validation. You can enable validation by setting the `runValidators` option.\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n``` javascript\nconst doc = await Model.findById(id)\ndoc.name = 'jason bourne';\nawait doc.save();\n```\n\n### Model.findOne()\n\n##### Parameters:\n\n- `[conditions]` «Object»\n- `[projection]` «Object\\|String\\|Array\\[String\\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [field selection](query#Query.prototype.select())\n- [lean queries](../tutorials/lean)\n\nFinds one document.\n\nThe `conditions` are cast to their respective SchemaTypes before the command is sent.\n\n*Note:* `conditions` is optional, and if `conditions` is null or undefined, mongoose will send an empty `findOne` command to MongoDB, which will return an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n\n#### [Example:](#example)\n\n``` javascript\n// Find one adventure whose `country` is 'Croatia', otherwise `null`\nawait Adventure.findOne({ country: 'Croatia' }).exec();\n\n// Model.findOne() no longer accepts a callback\n\n// Select only the adventures name and length\nawait Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n```\n\n### Model.findOneAndDelete()\n\n##### Parameters:\n\n- `conditions` «Object»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.projection=null]` «Object\\|String\\|Array\\[String\\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.sort]` «Object\\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n\n&nbsp;\n\n- `[options.select]` «Object\\|String» sets the document fields to return.\n\n&nbsp;\n\n- `[options.maxTimeMS]` «Number» puts a time limit on the query - requires mongodb \\>= 2.6.0\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\nIssue a MongoDB `findOneAndDelete()` command.\n\nFinds a matching document, removes it, and returns the found document (if any).\n\nThis function triggers the following middleware.\n\n- `findOneAndDelete()`\n\nThis function differs slightly from `Model.findOneAndRemove()` in that `findOneAndRemove()` becomes a [MongoDB `findAndModify()` command](https://www.mongodb.com/docs/manual/reference/method/db.collection.findAndModify/), as opposed to a `findOneAndDelete()` command. For most mongoose use cases, this distinction is purely pedantic. You should use `findOneAndDelete()` unless you have a good reason not to.\n\n#### [Example:](#example)\n\n``` javascript\nA.findOneAndDelete(conditions, options)  // return Query\nA.findOneAndDelete(conditions) // returns Query\nA.findOneAndDelete()           // returns Query\n```\n\n`findOneAndX` and `findByIdAndX` functions support limited validation. You can enable validation by setting the `runValidators` option.\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n``` javascript\nconst doc = await Model.findById(id)\ndoc.name = 'jason bourne';\nawait doc.save();\n```\n\n### Model.findOneAndRemove()\n\n##### Parameters:\n\n- `conditions` «Object»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.projection=null]` «Object\\|String\\|Array\\[String\\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())\n\n&nbsp;\n\n- `[options.sort]` «Object\\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.select]` «Object\\|String» sets the document fields to return.\n\n&nbsp;\n\n- `[options.maxTimeMS]` «Number» puts a time limit on the query - requires mongodb \\>= 2.6.0\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)\n\nIssue a mongodb findOneAndRemove command.\n\nFinds a matching document, removes it, and returns the found document (if any).\n\nThis function triggers the following middleware.\n\n- `findOneAndRemove()`\n\n#### [Example:](#example)\n\n``` javascript\nA.findOneAndRemove(conditions, options)  // return Query\nA.findOneAndRemove(conditions) // returns Query\nA.findOneAndRemove()           // returns Query\n```\n\n`findOneAndX` and `findByIdAndX` functions support limited validation. You can enable validation by setting the `runValidators` option.\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n``` javascript\nconst doc = await Model.findById(id);\ndoc.name = 'jason bourne';\nawait doc.save();\n```\n\n### Model.findOneAndReplace()\n\n##### Parameters:\n\n- `filter` «Object» Replace the first document that matches this filter\n- `[replacement]` «Object» Replace with this document\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.returnDocument='before']` «String» Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n\n&nbsp;\n\n- `[options.lean]` «Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](query#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.projection=null]` «Object\\|String\\|Array\\[String\\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())\n\n&nbsp;\n\n- `[options.sort]` «Object\\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.select]` «Object\\|String» sets the document fields to return.\n\n&nbsp;\n\n- `[options.maxTimeMS]` «Number» puts a time limit on the query - requires mongodb \\>= 2.6.0\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\nIssue a MongoDB `findOneAndReplace()` command.\n\nFinds a matching document, replaces it with the provided doc, and returns the document.\n\nThis function triggers the following query middleware.\n\n- `findOneAndReplace()`\n\n#### [Example:](#example)\n\n``` javascript\nA.findOneAndReplace(filter, replacement, options)  // return Query\nA.findOneAndReplace(filter, replacement) // returns Query\nA.findOneAndReplace()                    // returns Query\n```\n\n### Model.findOneAndUpdate()\n\n##### Parameters:\n\n- `[conditions]` «Object»\n- `[update]` «Object»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.returnDocument='before']` «String» Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n\n&nbsp;\n\n- `[options.lean]` «Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](query#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.overwrite=false]` «Boolean» By default, if you don't include any [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace(conditions, update, options, callback)](#Model.findOneAndReplace()).\n\n&nbsp;\n\n- `[options.upsert=false]` «Boolean» if true, and no documents found, insert a new document\n\n&nbsp;\n\n- `[options.projection=null]` «Object\\|String\\|Array\\[String\\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())\n\n&nbsp;\n\n- `[options.new=false]` «Boolean» if true, return the modified document rather than the original\n\n&nbsp;\n\n- `[options.fields]` «Object\\|String» Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n\n&nbsp;\n\n- `[options.maxTimeMS]` «Number» puts a time limit on the query - requires mongodb \\>= 2.6.0\n\n&nbsp;\n\n- `[options.sort]` «Object\\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n\n&nbsp;\n\n- `[options.runValidators]` «Boolean» if true, runs [update validators](../validation#update-validators) on this command. Update validators validate the update operation against the model's schema\n\n&nbsp;\n\n- `[options.setDefaultsOnInsert=true]` «Boolean» If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](../defaults) specified in the model's schema if a new document is created\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Tutorial](../tutorials/findoneandupdate)\n- [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)\n\nIssues a mongodb findOneAndUpdate command.\n\nFinds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes if `callback` is passed else a Query object is returned.\n\n#### [Example:](#example)\n\n``` javascript\nA.findOneAndUpdate(conditions, update, options)  // returns Query\nA.findOneAndUpdate(conditions, update)           // returns Query\nA.findOneAndUpdate()                             // returns Query\n```\n\n#### [Note:](#note)\n\nAll top level update keys which are not `atomic` operation names are treated as set operations:\n\n#### [Example:](#example-1)\n\n``` javascript\nconst query = { name: 'borne' };\nModel.findOneAndUpdate(query, { name: 'jason bourne' }, options)\n\n// is sent as\nModel.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options)\n```\n\n#### [Note:](#note-1)\n\n`findOneAndX` and `findByIdAndX` functions support limited validation that you can enable by setting the `runValidators` option.\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n``` javascript\nconst doc = await Model.findById(id);\ndoc.name = 'jason bourne';\nawait doc.save();\n```\n\n### Model.hydrate()\n\n##### Parameters:\n\n- `obj` «Object»\n- `[projection]` «Object\\|String\\|Array\\[String\\]» optional projection containing which fields should be selected for this document\n- `[options]` «Object» optional options\n\n&nbsp;\n\n- `[options.setters=false]` «Boolean» if true, apply schema setters when hydrating\n\n##### Returns:\n\n- «Document» document instance\n\nShortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.\n\n#### [Example:](#example)\n\n``` javascript\n// hydrate previous data into a Mongoose document\nconst mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n```\n\n### Model.init()\n\nThis function is responsible for building [indexes](https://www.mongodb.com/docs/manual/indexes/), unless [`autoIndex`](../guide#autoIndex) is turned off.\n\nMongoose calls this function automatically when a model is created using [`mongoose.model()`](mongoose#Mongoose.prototype.model()) or [`connection.model()`](connection#Connection.prototype.model()), so you don't need to call `init()` to trigger index builds.\n\nHowever, you *may* need to call `init()` to get back a promise that will resolve when your indexes are finished. Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing. For example, if you want to wait for unique indexes to build before continuing with a test case.\n\n#### [Example:](#example)\n\n``` javascript\nconst eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n// This calls `Event.init()` implicitly, so you don't need to call\n// `Event.init()` on your own.\nconst Event = mongoose.model('Event', eventSchema);\n\nawait Event.init();\nconsole.log('Indexes are done building!');\n```\n\n### Model.insertMany()\n\n##### Parameters:\n\n- `doc(s)` «Array\\|Object\\|\\[object Object\\]»\n- `[options]` «Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n\n&nbsp;\n\n- `[options.ordered=true]` «Boolean» if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n\n&nbsp;\n\n- `[options.rawResult=false]` «Boolean» if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n\n&nbsp;\n\n- `[options.lean=false]` «Boolean» if `true`, skips hydrating and validating the documents. This option is useful if you need the extra performance, but Mongoose won't validate the documents before inserting.\n\n&nbsp;\n\n- `[options.limit=null]` «Number» this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n\n&nbsp;\n\n- `[options.populate=null]` «String\\|Object\\|Array» populates the result documents. This option is a no-op if `rawResult` is set.\n\n&nbsp;\n\n- `[options.throwOnValidationError=false]` «Boolean» If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n\n##### Returns:\n\n- «Promise» resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n\nShortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than `.create()` because it only sends one operation to the server, rather than one for each document.\n\nMongoose always validates each document **before** sending `insertMany` to MongoDB. So if one document has a validation error, no documents will be saved, unless you set [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n\nThis function does **not** trigger save middleware.\n\nThis function triggers the following middleware.\n\n- `insertMany()`\n\n#### [Example:](#example)\n\n``` javascript\nawait Movies.insertMany([\n  { name: 'Star Wars' },\n  { name: 'The Empire Strikes Back' }\n]);\n```\n\n### Model.inspect()\n\nHelper for console.log. Given a model named 'MyModel', returns the string `'Model { MyModel }'`.\n\n#### [Example:](#example)\n\n``` javascript\nconst MyModel = mongoose.model('Test', Schema({ name: String }));\nMyModel.inspect(); // 'Model { Test }'\nconsole.log(MyModel); // Prints 'Model { Test }'\n```\n\n### Model.listIndexes()\n\n##### Returns:\n\n- «Promise»\n\nLists the indexes currently defined in MongoDB. This may or may not be the same as the indexes defined in your schema depending on whether you use the [`autoIndex` option](../guide#autoIndex) and if you build indexes manually.\n\n### Model.populate()\n\n##### Parameters:\n\n- `docs` «Document\\|Array» Either a single document or array of documents to populate.\n- `options` «Object\\|String» Either the paths to populate or an object specifying all parameters\n\n&nbsp;\n\n- `[options.path=null]` «string» The path to populate.\n\n&nbsp;\n\n- `[options.populate=null]` «string\\|PopulateOptions» Recursively populate paths in the populated documents. See [deep populate docs](../populate#deep-populate).\n\n&nbsp;\n\n- `[options.retainNullValues=false]` «boolean» By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n\n&nbsp;\n\n- `[options.getters=false]` «boolean» If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](../schematypes#schematype-options).\n\n&nbsp;\n\n- `[options.clone=false]` «boolean» When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n\n&nbsp;\n\n- `[options.match=null]` «Object\\|Function» Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n\n&nbsp;\n\n- `[options.skipInvalidIds=false]` «Boolean» By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n\n&nbsp;\n\n- `[options.perDocumentLimit=null]` «Number» For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n\n&nbsp;\n\n- `[options.strictPopulate=true]` «Boolean» Set to false to allow populating paths that aren't defined in the given model's schema.\n\n&nbsp;\n\n- `[options.options=null]` «Object» Additional options like `limit` and `lean`.\n\n&nbsp;\n\n- `[options.transform=null]` «Function» Function that Mongoose will call on every populated document that allows you to transform the populated document.\n\n&nbsp;\n\n- `[callback(err,doc)]` «Function» Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n\n##### Returns:\n\n- «Promise»\n\nPopulates document references.\n\nChanged in Mongoose 6: the model you call `populate()` on should be the \"local field\" model, **not** the \"foreign field\" model.\n\n#### [Available top-level options:](#available-top-level-options)\n\n- path: space delimited path(s) to populate\n- select: optional fields to select\n- match: optional query conditions to match\n- model: optional name of the model to use for population\n- options: optional query options like sort, limit, etc\n- justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n- strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n\n#### [Example:](#example)\n\n``` javascript\nconst Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\nconst Person = mongoose.model('Person', new Schema({\n  name: String,\n  pet: { type: mongoose.ObjectId, ref: 'Dog' }\n}));\n\nconst pets = await Pet.create([\n  { name: 'Daisy', breed: 'Beagle' },\n  { name: 'Einstein', breed: 'Catalan Sheepdog' }\n]);\n\n// populate many plain objects\nconst users = [\n  { name: 'John Wick', dog: pets[0]._id },\n  { name: 'Doc Brown', dog: pets[1]._id }\n];\nawait User.populate(users, { path: 'dog', select: 'name' });\nusers[0].dog.name; // 'Daisy'\nusers[0].dog.breed; // undefined because of `select`\n```\n\n### Model.prototype.$model()\n\n##### Parameters:\n\n- `name` «String» model name\n\n##### Returns:\n\n- «Model»\n\nReturns another Model instance.\n\n#### [Example:](#example)\n\n``` javascript\nconst doc = new Tank;\nawait doc.model('User').findById(id);\n```\n\n### Model.prototype.$where\n\n##### Type:\n\n- «property»\n\nAdditional properties to attach to the query when calling `save()` and `isNew` is false.\n\n### Model.prototype.base\n\n##### Type:\n\n- «property»\n\nBase Mongoose instance the model uses.\n\n### Model.prototype.baseModelName\n\n##### Type:\n\n- «property»\n\nIf this is a discriminator model, `baseModelName` is the name of the base model.\n\n### Model.prototype.collection\n\n##### Type:\n\n- «property»\n\nThe collection instance this model uses. A Mongoose collection is a thin wrapper around a \\[MongoDB Node.js driver collection\\]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)). Using `Model.collection` means you bypass Mongoose middleware, validation, and casting.\n\nThis property is read-only. Modifying this property is a no-op.\n\n### Model.prototype.collection\n\n##### Type:\n\n- «property»\n\nCollection the model uses.\n\n### Model.prototype.db\n\n##### Type:\n\n- «property»\n\nConnection the model uses.\n\n### Model.prototype.deleteOne()\n\n##### Returns:\n\n- «Promise» Promise\n\nRemoves this document from the db. Equivalent to `.remove()`.\n\n#### [Example:](#example)\n\n``` javascript\nproduct = await product.deleteOne();\nawait Product.findById(product._id); // null\n```\n\n### Model.prototype.discriminators\n\n##### Type:\n\n- «property»\n\nRegistered discriminators for this model.\n\n### Model.prototype.increment()\n\n##### See:\n\n- [versionKeys](../guide#versionKey)\n\nSignal that we desire an increment of this documents version.\n\n#### [Example:](#example)\n\n``` javascript\nconst doc = await Model.findById(id);\ndoc.increment();\nawait doc.save();\n```\n\n### Model.prototype.model()\n\n##### Parameters:\n\n- `name` «String» model name\n\n##### Returns:\n\n- «Model»\n\nReturns another Model instance.\n\n#### [Example:](#example)\n\n``` javascript\nconst doc = new Tank;\nawait doc.model('User').findById(id);\n```\n\n### Model.prototype.modelName\n\n##### Type:\n\n- «property»\n\nThe name of the model\n\n### Model.prototype.save()\n\n##### Parameters:\n\n- `[options]` «Object» options optional options\n\n&nbsp;\n\n- `[options.session=null]` «Session» the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](document#Document.prototype.session()).\n\n&nbsp;\n\n- `[options.safe]` «Object» (DEPRECATED) overrides [schema's safe option](../guide#safe). Use the `w` option instead.\n\n&nbsp;\n\n- `[options.validateBeforeSave]` «Boolean» set to false to save without validating.\n\n&nbsp;\n\n- `[options.validateModifiedOnly=false]` «Boolean» if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n\n&nbsp;\n\n- `[options.w]` «Number\\|String» set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.j]` «Boolean» set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.wtimeout]` «Number» sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](../guide#writeConcern).\n\n&nbsp;\n\n- `[options.checkKeys=true]` «Boolean» the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n\n&nbsp;\n\n- `[options.timestamps=true]` «Boolean» if `false` and [timestamps](../guide#timestamps) are enabled, skip timestamps for this `save()`.\n\n##### Returns:\n\n- «Promise»\n\n##### See:\n\n- [middleware](../middleware)\n\nSaves this document by inserting a new document into the database if [document.isNew](document#Document.prototype.isNew) is `true`, or sends an [updateOne](document#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n\n#### [Example:](#example)\n\n``` javascript\nproduct.sold = Date.now();\nproduct = await product.save();\n```\n\nIf save is successful, the returned promise will fulfill with the document saved.\n\n#### [Example:](#example-1)\n\n``` javascript\nconst newProduct = await product.save();\nnewProduct === product; // true\n```\n\n### Model.replaceOne()\n\n##### Parameters:\n\n- `filter` «Object»\n- `doc` «Object»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.upsert=false]` «Boolean» if true, and no documents found, insert a new document\n\n&nbsp;\n\n- `[options.writeConcern=null]` «Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Query docs](../queries)\n- [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)\n\nReplace the existing document with the given document (no atomic operators like `$set`).\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\nres.matchedCount; // Number of documents matched\nres.modifiedCount; // Number of documents modified\nres.acknowledged; // Boolean indicating everything went smoothly.\nres.upsertedId; // null or an id containing a document that had to be upserted.\nres.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n```\n\nThis function triggers the following middleware.\n\n- `replaceOne()`\n\n### Model.schema\n\n##### Type:\n\n- «property»\n\nSchema the model uses.\n\n### Model.startSession()\n\n##### Parameters:\n\n- `[options]` «Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n\n&nbsp;\n\n- `[options.causalConsistency=true]` «Boolean» set to false to disable causal consistency\n\n##### Returns:\n\n- «Promise\\<ClientSession\\>» promise that resolves to a MongoDB driver `ClientSession`\n\n*Requires MongoDB \\>= 3.6.0.* Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions) for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/), and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n\nCalling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n\nThis function does not trigger any middleware.\n\n#### [Example:](#example)\n\n``` javascript\nconst session = await Person.startSession();\nlet doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\nawait doc.remove();\n// `doc` will always be null, even if reading from a replica set\n// secondary. Without causal consistency, it is possible to\n// get a doc back from the below query if the query reads from a\n// secondary that is experiencing replication lag.\ndoc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n```\n\n### Model.syncIndexes()\n\n##### Parameters:\n\n- `[options]` «Object» options to pass to `ensureIndexes()`\n\n&nbsp;\n\n- `[options.background=null]` «Boolean» if specified, overrides each index's `background` property\n\n##### Returns:\n\n- «Promise»\n\nMakes the indexes in MongoDB match the indexes defined in this model's schema. This function will drop any indexes that are not defined in the model's schema except the `_id` index, and build any indexes that are in your schema but not in MongoDB.\n\nSee the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes) for more information.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: { type: String, unique: true } });\nconst Customer = mongoose.model('Customer', schema);\nawait Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n// Will drop the 'age' index and create an index on `name`\nawait Customer.syncIndexes();\n```\n\n### Model.translateAliases()\n\n##### Parameters:\n\n- `fields` «Object» fields/conditions that may contain aliased keys\n- `[errorOnDuplicates]` «Boolean» if true, throw an error if there's both a key and an alias for that key in `fields`\n\n##### Returns:\n\n- «Object» the translated 'pure' fields/conditions\n\nTranslate any aliases fields/conditions so the final query or document object is pure\n\n#### [Example:](#example)\n\n``` javascript\nawait Character.find(Character.translateAliases({\n   '名': 'Eddard Stark' // Alias for 'name'\n});\n```\n\nBy default, `translateAliases()` overwrites raw fields with aliased fields. So if `n` is an alias for `name`, `{ n: 'alias', name: 'raw' }` will resolve to `{ name: 'alias' }`. However, you can set the `errorOnDuplicates` option to throw an error if there are potentially conflicting paths. The `translateAliases` option for queries uses `errorOnDuplicates`.\n\n#### [Note:](#note)\n\nOnly translate arguments of object type anything else is returned raw\n\n### Model.updateMany()\n\n##### Parameters:\n\n- `filter` «Object»\n- `update` «Object\\|Array»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.upsert=false]` «Boolean» if true, and no documents found, insert a new document\n\n&nbsp;\n\n- `[options.writeConcern=null]` «Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Query docs](../queries)\n- [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)\n- [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)\n\nSame as `updateOne()`, except MongoDB will update *all* documents that match `filter` (as opposed to just the first one) regardless of the value of the `multi` option.\n\n**Note** updateMany will *not* fire update middleware. Use `pre('updateMany')` and `post('updateMany')` instead.\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\nres.matchedCount; // Number of documents matched\nres.modifiedCount; // Number of documents modified\nres.acknowledged; // Boolean indicating everything went smoothly.\nres.upsertedId; // null or an id containing a document that had to be upserted.\nres.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n```\n\nThis function triggers the following middleware.\n\n- `updateMany()`\n\n### Model.updateOne()\n\n##### Parameters:\n\n- `filter` «Object»\n- `update` «Object\\|Array»\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.upsert=false]` «Boolean» if true, and no documents found, insert a new document\n\n&nbsp;\n\n- `[options.writeConcern=null]` «Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query»\n\n##### See:\n\n- [Query docs](../queries)\n- [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)\n- [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)\n\nUpdate *only* the first document that matches `filter`.\n\n- Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\nres.matchedCount; // Number of documents matched\nres.modifiedCount; // Number of documents modified\nres.acknowledged; // Boolean indicating everything went smoothly.\nres.upsertedId; // null or an id containing a document that had to be upserted.\nres.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n```\n\nThis function triggers the following middleware.\n\n- `updateOne()`\n\n### Model.validate()\n\n##### Parameters:\n\n- `obj` «Object»\n- `pathsToValidate` «Array\\|String»\n- `[context]` «Object»\n\n##### Returns:\n\n- «Promise,undefined,void»\n\nCasts and validates the given object against this model's schema, passing the given `context` to custom validators.\n\n#### [Example:](#example)\n\n``` javascript\nconst Model = mongoose.model('Test', Schema({\n  name: { type: String, required: true },\n  age: { type: Number, required: true }\n});\n\ntry {\n  await Model.validate({ name: null }, ['name'])\n} catch (err) {\n  err instanceof mongoose.Error.ValidationError; // true\n  Object.keys(err.errors); // ['name']\n}\n```\n\n### Model.watch()\n\n##### Parameters:\n\n- `[pipeline]` «Array»\n- `[options]` «Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n\n&nbsp;\n\n- `[options.hydrate=false]` «Boolean» if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n\n##### Returns:\n\n- «ChangeStream» mongoose-specific change stream wrapper, inherits from EventEmitter\n\n*Requires a replica set running MongoDB \\>= 3.6.0.* Watches the underlying collection for changes using [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n\nThis function does **not** trigger any middleware. In particular, it does **not** trigger aggregate middleware.\n\nThe ChangeStream object is an event emitter that emits the following events:\n\n- 'change': A change occurred, see below example\n- 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n- 'end': Emitted if the underlying stream is closed\n- 'close': Emitted if the underlying stream is closed\n\n#### [Example:](#example)\n\n``` javascript\nconst doc = await Person.create({ name: 'Ned Stark' });\nconst changeStream = Person.watch().on('change', change => console.log(change));\n// Will print from the above `console.log()`:\n// { _id: { _data: ... },\n//   operationType: 'delete',\n//   ns: { db: 'mydb', coll: 'Person' },\n//   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\nawait doc.remove();\n```\n\n### Model.where()\n\n##### Parameters:\n\n- `path` «String»\n- `[val]` «Object» optional value\n\n##### Returns:\n\n- «Query»\n\nCreates a Query, applies the passed conditions, and returns the Query.\n\nFor example, instead of writing:\n\n``` javascript\nUser.find({ age: { $gte: 21, $lte: 65 } });\n```\n\nwe can instead write:\n\n``` javascript\nUser.where('age').gte(21).lte(65).exec();\n```\n\nSince the Query class also supports `where` you can continue chaining\n\n``` javascript\nUser\n.where('age').gte(21).lte(65)\n.where('name', /^b/i)\n... etc\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/model.html](https://mongoosejs.com/docs/api/model.html)"
- name: Model()
  id: api/model#Model()
  summary: A Model is a class that's your primary tool for interacting with MongoDB
  belongs_to: Model
  description: |-
    ### Model()

    ##### Parameters:

    - `doc`«Object» values for initial set
    - `[fields]`«Object» optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](query#Query.prototype.select()).
    - `[skipId=false]`«Boolean» optional boolean. If true, mongoose doesn't add an `_id` field to the document.

    ##### Inherits:

    -  [«Document»](document)

    A Model is a class that's your primary tool for interacting with MongoDB. An instance of a Model is called a [Document](document#Document).

    In Mongoose, the term "Model" refers to subclasses of the `mongoose.Model` class. You should not use the `mongoose.Model` class directly. The [`mongoose.model()`](mongoose#Mongoose.prototype.model()) and [`connection.model()`](connection#Connection.prototype.model()) functions create subclasses of `mongoose.Model` as shown below.

    #### [Example:](#example)

    ``` javascript
    // `UserModel` is a "Model", a subclass of `mongoose.Model`.constUserModel = mongoose.model('User', new Schema({ name: String }));

    // You can use a Model to create new documents using `new`:
    const userDoc = new UserModel({ name: 'Foo' });
    await userDoc.save();

    // You also use a model to create queries:
    const userFromDb = await UserModel.findOne({ name: 'Foo' });
    ```
- name: Model.$where()
  id: api/model#Model.$where()
  summary: Creates a Query and specifies a $where condition
  belongs_to: Model
  description: |-
    ### Model.$where()

    ##### Parameters:

    - `argument`«String\|Function» is a javascript string or anonymous function

    ##### Returns:

    - «Query»

    ##### See:

    -  [Query.$where](query#Query.prototype.$where)

    Creates a `Query` and specifies a `$where` condition.

    Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.

    ``` javascript
    Blog.$where('this.username.indexOf("val") !== -1').exec(function (err, docs) {});
    ```
- name: Model.aggregate()
  id: api/model#Model.aggregate()
  summary: Performs aggregations on the models collection
  belongs_to: Model
  description: |-
    ### Model.aggregate()

    ##### Parameters:

    - `[pipeline]`«Array» aggregation pipeline as an array of objects
    - `[options]`«Object» aggregation options

    ##### Returns:

    - «Aggregate»

    ##### See:

    -  [Aggregate](aggregate#Aggregate())
    -  [MongoDB](https://www.mongodb.com/docs/manual/applications/aggregation/)

    Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.

    If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.

    This function triggers the following middleware.

    - `aggregate()`

    #### [Example:](#example)

    ``` javascript
    // Find the max balance of all accountsconst res = await Users.aggregate([
      { $group: { _id: null, maxBalance: { $max: '$balance' }}},
      { $project: { _id: 0, maxBalance: 1 }}
    ]);

    console.log(res); // [ { maxBalance: 98000 } ]

    // Or use the aggregation pipeline builder.
    const res = await Users.aggregate().
      group({ _id: null, maxBalance: { $max: '$balance' } }).
      project('-id maxBalance').
      exec();
    console.log(res); // [ { maxBalance: 98 } ]
    ```

    #### [Note:](#note)

    - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the "shape" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.
    - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).

    #### [More About Aggregations:](#more-about-aggregations)

    - [Mongoose `Aggregate`](aggregate)
    - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)
    - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)
- name: Model.applyDefaults()
  id: api/model#Model.applyDefaults()
  summary: Apply defaults to the given document or POJO
  belongs_to: Model
  description: |-
    ### Model.applyDefaults()

    ##### Parameters:

    - `obj`«Object\|Document» object or document to apply defaults on

    Apply defaults to the given document or POJO.
- name: Model.bulkSave()
  id: api/model#Model.bulkSave()
  summary: '[options.timestamps]«Boolean» defaults to null, when set to false, mongoose will not add/update timestamps to the documents'
  belongs_to: Model
  description: |-
    ### Model.bulkSave()

    ##### Parameters:

    - `documents` «Array\<Document\>»
    - `[options]`«Object» options passed to the underlying `bulkWrite()`

    - `[options.timestamps]`«Boolean» defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this bulk write. See [transactions docs](../transactions).

    &nbsp;

    - `[options.w=1]`«String\|number» The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](query#Query.prototype.w()) for more information.

    &nbsp;

    - `[options.wtimeout=null]`«number» The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).

    &nbsp;

    - `[options.j=true]`«Boolean» If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)

    takes an array of documents, gets the changes and inserts/updates documents in the database according to whether or not the document is new, or whether it has changes or not.

    `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)
- name: Model.bulkWrite()
  id: api/model#Model.bulkWrite()
  summary: Sends multiple insertOne, updateOne, updateMany, replaceOne, deleteOne, and/or deleteMany operations to the MongoDB server in one command
  belongs_to: Model
  description: |-
    ### Model.bulkWrite()

    ##### Parameters:

    - `ops` «Array»

    &nbsp;

    - `[ops.insertOne.document]`«Object» The document to insert

    &nbsp;

    - `[ops.updateOne.filter]`«Object» Update the first document that matches this filter

    &nbsp;

    - `[ops.updateOne.update]`«Object» An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)

    &nbsp;

    - `[ops.updateOne.upsert=false]`«Boolean» If true, insert a doc if none match

    &nbsp;

    - `[ops.updateOne.timestamps=true]`«Boolean» If false, do not apply [timestamps](../guide#timestamps) to the operation

    &nbsp;

    - `[ops.updateOne.collation]`«Object» The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use

    &nbsp;

    - `[ops.updateOne.arrayFilters]`«Array» The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`

    &nbsp;

    - `[ops.updateMany.filter]`«Object» Update all the documents that match this filter

    &nbsp;

    - `[ops.updateMany.update]`«Object» An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)

    &nbsp;

    - `[ops.updateMany.upsert=false]`«Boolean» If true, insert a doc if no documents match `filter`

    &nbsp;

    - `[ops.updateMany.timestamps=true]`«Boolean» If false, do not apply [timestamps](../guide#timestamps) to the operation

    &nbsp;

    - `[ops.updateMany.collation]`«Object» The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use

    &nbsp;

    - `[ops.updateMany.arrayFilters]`«Array» The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`

    &nbsp;

    - `[ops.deleteOne.filter]`«Object» Delete the first document that matches this filter

    &nbsp;

    - `[ops.deleteMany.filter]`«Object» Delete all documents that match this filter

    &nbsp;

    - `[ops.replaceOne.filter]`«Object» Replace the first document that matches this filter

    &nbsp;

    - `[ops.replaceOne.replacement]`«Object» The replacement document

    &nbsp;

    - `[ops.replaceOne.upsert=false]`«Boolean» If true, insert a doc if no documents match `filter`

    &nbsp;

    - `[options]` «Object»

    &nbsp;

    - `[options.ordered=true]`«Boolean» If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this bulk write. See [transactions docs](../transactions).

    &nbsp;

    - `[options.w=1]`«String\|number» The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](query#Query.prototype.w()) for more information.

    &nbsp;

    - `[options.wtimeout=null]`«number» The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).

    &nbsp;

    - `[options.j=true]`«Boolean» If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)

    &nbsp;

    - `[options.skipValidation=false]`«Boolean» Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.

    &nbsp;

    - `[options.bypassDocumentValidation=false]`«Boolean» If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.

    &nbsp;

    - `[options.throwOnValidationError=false]`«Boolean» If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.

    &nbsp;

    - `[options.strict=null]`«Boolean» Overwrites the [`strict` option](../guide#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.

    ##### Returns:

    - «Promise» resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds

    Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`, `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one command. This is faster than sending multiple independent operations (e.g. if you use `create()`) because with `bulkWrite()` there is only one round trip to MongoDB.

    Mongoose will perform casting on all operations you provide.

    This function does **not** trigger any middleware, neither `save()`, nor `update()`. If you need to trigger `save()` middleware for every document use [`create()`](#Model.create()) instead.

    #### [Example:](#example)

    ``` javascript
    Character.bulkWrite([
      {
        insertOne: {
          document: {
            name: 'Eddard Stark',
            title: 'Warden of the North'
          }
        }
      },
      {
        updateOne: {
          filter: { name: 'Eddard Stark' },
          // If you were using the MongoDB driver directly, you'd need to do
          // `update: { $set: { title: ... } }` but mongoose adds $set for
          // you.
          update: { title: 'Hand of the King' }
        }
      },
      {
        deleteOne: {
          filter: { name: 'Eddard Stark' }
        }
      }
    ]).then(res => {
     // Prints "1 1 1"
     console.log(res.insertedCount, res.modifiedCount, res.deletedCount);
    });
    ```

    The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:

    - `insertOne`
    - `updateOne`
    - `updateMany`
    - `deleteOne`
    - `deleteMany`
    - `replaceOne`
- name: Model.castObject()
  id: api/model#Model.castObject()
  summary: null
  belongs_to: Model
  description: |-
    ### Model.castObject()

    ##### Parameters:

    - `obj`«Object» object or document to cast
    - `options`«Object» options passed to castObject
    - `options.ignoreCastErrors`«Boolean» If set to `true` will not throw a ValidationError and only return values that were successfully cast.

    Cast the given POJO to the model's schema

    #### [Example:](#example)

    ``` javascript
    constTest = mongoose.model('Test', Schema({ num: Number }));

    const obj = Test.castObject({ num: '42' });
    obj.num; // 42 as a number

    Test.castObject({ num: 'not a number' }); // Throws a ValidationError
    ```
- name: Model.cleanIndexes()
  id: api/model#Model.cleanIndexes()
  summary: Deletes all indexes that aren't defined in this model's schema
  belongs_to: Model
  description: |-
    ### Model.cleanIndexes()

    ##### Parameters:

    - `[callback]`«Function» optional callback

    ##### Returns:

    - «Promise,undefined,void» Returns `undefined` if callback is specified, returns a promise if no callback.

    Deletes all indexes that aren't defined in this model's schema. Used by `syncIndexes()`.

    The returned promise resolves to a list of the dropped indexes' names as an array
- name: Model.count()
  id: api/model#Model.count()
  summary: Counts number of documents that match filter in a database collection
  belongs_to: Model
  description: |-
    ### Model.count()

    ~DEPRECATED~

    ##### Parameters:

    - `[filter]` «Object»

    ##### Returns:

    - «Query»

    Counts number of documents that match `filter` in a database collection.

    This method is deprecated. If you want to count the number of documents in a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](#Model.estimatedDocumentCount()) instead. Otherwise, use the [`countDocuments()`](#Model.countDocuments()) function instead.

    #### [Example:](#example)

    ``` javascript
    const count = await Adventure.count({ type: 'jungle' });
    console.log('there are %d jungle adventures', count);
    ```
- name: Model.countDocuments()
  id: api/model#Model.countDocuments()
  summary: Counts number of documents matching filter in a database collection
  belongs_to: Model
  description: |-
    ### Model.countDocuments()

    ##### Parameters:

    - `filter` «Object»

    ##### Returns:

    - «Query»

    Counts number of documents matching `filter` in a database collection.

    #### [Example:](#example)

    ``` javascript
    Adventure.countDocuments({ type: 'jungle' }, function (err, count) {
      console.log('there are %d jungle adventures', count);
    });
    ```

    If you want to count all documents in a large collection, use the [`estimatedDocumentCount()` function](#Model.estimatedDocumentCount()) instead. If you call `countDocuments({})`, MongoDB will always execute a full collection scan and **not** use any indexes.

    The `countDocuments()` function is similar to `count()`, but there are a [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments). Below are the operators that `count()` supports but `countDocuments()` does not, and the suggested replacement:

    - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)
    - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)
    - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)
- name: Model.create()
  id: api/model#Model.create()
  summary: Shortcut for saving one or more documents to the database
  belongs_to: Model
  description: |-
    ### Model.create()

    ##### Parameters:

    - `docs`«Array\|Object» Documents to insert, as a spread or array
    - `[options]`«Object» Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](#Model.prototype.save()) for available options.

    &nbsp;

    - `[options.ordered]`«Boolean» saves the docs in series rather than parallel.

    &nbsp;

    - `[options.aggregateErrors]`«Boolean» Aggregate Errors instead of throwing the first one that occurs. Default: false

    ##### Returns:

    - «Promise»

    Shortcut for saving one or more documents to the database. `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in docs.

    This function triggers the following middleware.

    - `save()`

    #### [Example:](#example)

    ``` javascript
    // Insert one new `Character` documentawaitCharacter.create({ name: 'Jean-Luc Picard' });

    // Insert multiple new `Character` documents
    await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);

    // Create a new character within a transaction. Note that you **must**
    // pass an array as the first parameter to `create()` if you want to
    // specify options.
    await Character.create([{ name: 'Jean-Luc Picard' }], { session });
    ```
- name: Model.createCollection()
  id: api/model#Model.createCollection()
  summary: Create the collection for this model
  belongs_to: Model
  description: |-
    ### Model.createCollection()

    ##### Parameters:

    - `[options]`«Object» see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)

    Create the collection for this model. By default, if no indexes are specified, mongoose will not create the collection for the model until any documents are created. Use this method to create the collection explicitly.

    Note 1: You may need to call this before starting a transaction See <https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations>

    Note 2: You don't have to call this if your schema contains index or unique field. In that case, just use `Model.init()`

    #### [Example:](#example)

    ``` javascript
    const userSchema = new Schema({ name: String })
    const User = mongoose.model('User', userSchema);

    User.createCollection().then(function(collection) {
      console.log('Collection is created!');
    });
    ```
- name: Model.createIndexes()
  id: api/model#Model.createIndexes()
  summary: Similar to ensureIndexes(), except for it uses the createIndex function
  belongs_to: Model
  description: |-
    ### Model.createIndexes()

    ##### Parameters:

    - `[options]`«Object» internal options

    ##### Returns:

    - «Promise»

    Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex) function.
- name: Model.db
  id: api/model#Model.db
  summary: Connection instance the model uses
  belongs_to: Model
  description: |-
    ### Model.db

    ##### Type:

    - «property»

    Connection instance the model uses.
- name: Model.deleteMany()
  id: api/model#Model.deleteMany()
  summary: Deletes all of the documents that match conditions from the collection
  belongs_to: Model
  description: |-
    ### Model.deleteMany()

    ##### Parameters:

    - `conditions` «Object»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    Deletes all of the documents that match `conditions` from the collection. It returns an object with the property `deletedCount` containing the number of documents deleted. Behaves like `remove()`, but deletes all documents that match `conditions` regardless of the `single` option.

    #### [Example:](#example)

    ``` javascript
    awaitCharacter.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.
    ```

    #### [Note:](#note)

    This function triggers `deleteMany` query hooks. Read the [middleware docs](../middleware#naming) to learn more.
- name: Model.deleteOne()
  id: api/model#Model.deleteOne()
  summary: Deletes the first document that matches conditions from the collection
  belongs_to: Model
  description: |-
    ### Model.deleteOne()

    ##### Parameters:

    - `conditions` «Object»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    Deletes the first document that matches `conditions` from the collection. It returns an object with the property `deletedCount` indicating how many documents were deleted. Behaves like `remove()`, but deletes at most one document regardless of the `single` option.

    #### [Example:](#example)

    ``` javascript
    awaitCharacter.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}
    ```

    #### [Note:](#note)

    This function triggers `deleteOne` query hooks. Read the [middleware docs](../middleware#naming) to learn more.
- name: Model.diffIndexes()
  id: api/model#Model.diffIndexes()
  summary: Does a dry-run of Model.syncIndexes(), meaning that the result of this function would be the result of Model.syncIndexes()
  belongs_to: Model
  description: |-
    ### Model.diffIndexes()

    ##### Parameters:

    - `[options]` «Object»

    Does a dry-run of Model.syncIndexes(), meaning that the result of this function would be the result of Model.syncIndexes().
- name: Model.discriminator()
  id: api/model#Model.discriminator()
  summary: Adds a discriminator type
  belongs_to: Model
  description: |-
    ### Model.discriminator()

    ##### Parameters:

    - `name`«String» discriminator model name
    - `schema`«Schema» discriminator model schema
    - `[options]`«Object\|String» If string, same as `options.value`.

    &nbsp;

    - `[options.value]`«String» the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.

    &nbsp;

    - `[options.clone=true]`«Boolean» By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.

    &nbsp;

    - `[options.overwriteModels=false]`«Boolean» by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.

    &nbsp;

    - `[options.mergeHooks=true]`«Boolean» By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.

    &nbsp;

    - `[options.mergePlugins=true]`«Boolean» By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.

    ##### Returns:

    - «Model» The newly created discriminator model

    Adds a discriminator type.

    #### [Example:](#example)

    ``` javascript
    functionBaseSchema() {
      Schema.apply(this, arguments);

      this.add({
        name: String,
        createdAt: Date
      });
    }
    util.inherits(BaseSchema, Schema);

    const PersonSchema = new BaseSchema();
    const BossSchema = new BaseSchema({ department: String });

    const Person = mongoose.model('Person', PersonSchema);
    const Boss = Person.discriminator('Boss', BossSchema);
    new Boss().__t; // "Boss". `__t` is the default `discriminatorKey`

    const employeeSchema = new Schema({ boss: ObjectId });
    const Employee = Person.discriminator('Employee', employeeSchema, 'staff');
    new Employee().__t; // "staff" because of 3rd argument above
    ```
- name: Model.distinct()
  id: api/model#Model.distinct()
  summary: Creates a Query for a distinct operation
  belongs_to: Model
  description: |-
    ### Model.distinct()

    ##### Parameters:

    - `field` «String»
    - `[conditions]`«Object» optional

    ##### Returns:

    - «Query»

    Creates a Query for a `distinct` operation.

    #### [Example:](#example)

    ``` javascript
    const query = Link.distinct('url');
    query.exec();
    ```
- name: Model.ensureIndexes()
  id: api/model#Model.ensureIndexes()
  summary: Sends createIndex commands to mongo for each index declared in the schema
  belongs_to: Model
  description: |-
    ### Model.ensureIndexes()

    ##### Parameters:

    - `[options]`«Object» internal options

    ##### Returns:

    - «Promise»

    Sends `createIndex` commands to mongo for each index declared in the schema. The `createIndex` commands are sent in series.

    #### [Example:](#example)

    ``` javascript
    Event.ensureIndexes(function (err) {
      if (err) return handleError(err);
    });
    ```

    After completion, an `index` event is emitted on this `Model` passing an error if one occurred.

    #### [Example:](#example-1)

    ``` javascript
    const eventSchema = new Schema({ thing: { type: 'string', unique: true } })
    const Event = mongoose.model('Event', eventSchema);

    Event.on('index', function (err) {
      if (err) console.error(err); // error occurred during index creation
    })
    ```

    *NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.*
- name: Model.estimatedDocumentCount()
  id: api/model#Model.estimatedDocumentCount()
  summary: Estimates the number of documents in the MongoDB collection
  belongs_to: Model
  description: |-
    ### Model.estimatedDocumentCount()

    ##### Parameters:

    - `[options]` «Object»

    ##### Returns:

    - «Query»

    Estimates the number of documents in the MongoDB collection. Faster than using `countDocuments()` for large collections because `estimatedDocumentCount()` uses collection metadata rather than scanning the entire collection.

    #### [Example:](#example)

    ``` javascript
    const numAdventures = await Adventure.estimatedDocumentCount();
    ```
- name: Model.events
  id: api/model#Model.events
  summary: Event emitter that reports any errors that occurred
  belongs_to: Model
  description: |-
    ### Model.events

    ##### Type:

    - «property»

    Event emitter that reports any errors that occurred. Useful for global error handling.

    #### [Example:](#example)

    ``` javascript
    MyModel.events.on('error', err =>console.log(err.message));

    // Prints a 'CastError' because of the above handlerawaitMyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);
    ```
- name: Model.exists()
  id: api/model#Model.exists()
  summary: Returns a document with _id only if at least one document exists in the database that matches the given filter, and null otherwise
  belongs_to: Model
  description: |-
    ### Model.exists()

    ##### Parameters:

    - `filter` «Object»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    ##### Returns:

    - «Query»

    Returns a document with `_id` only if at least one document exists in the database that matches the given `filter`, and `null` otherwise.

    Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`

    #### [Example:](#example)

    ``` javascript
    awaitCharacter.deleteMany({});
    awaitCharacter.create({ name: 'Jean-Luc Picard' });

    await Character.exists({ name: /picard/i }); // { _id: ... }
    await Character.exists({ name: /riker/i }); // null
    ```

    This function triggers the following middleware.

    - `findOne()`
- name: Model.find()
  id: api/model#Model.find()
  summary: Finds documents
  belongs_to: Model
  description: |-
    ### Model.find()

    ##### Parameters:

    - `filter` «Object\|ObjectId»
    - `[projection]`«Object\|String\|Array\[String\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [field selection](query#Query.prototype.select())
    -  [query casting](../tutorials/query_casting)

    Finds documents.

    Mongoose casts the `filter` to match the model's schema before the command is sent. See our [query casting tutorial](../tutorials/query_casting) for more information on how Mongoose casts `filter`.

    #### [Example:](#example)

    ``` javascript
    // find all documentsawaitMyModel.find({});

    // find all documents named john and at least 18awaitMyModel.find({ name: 'john', age: { $gte: 18 } }).exec();

    // executes, name LIKE john and only selecting the "name" and "friends" fields
    await MyModel.find({ name: /john/i }, 'name friends').exec();

    // passing options
    await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();
    ```
- name: Model.findById()
  id: api/model#Model.findById()
  summary: Finds a single document by its _id field
  belongs_to: Model
  description: |-
    ### Model.findById()

    ##### Parameters:

    - `id`«Any» value of `_id` to query by
    - `[projection]`«Object\|String\|Array\[String\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    ##### Returns:

    - «Query»

    ##### See:

    -  [field selection](query#Query.prototype.select())
    -  [lean queries](../tutorials/lean)
    -  [findById in Mongoose](https://masteringjs.io/tutorials/mongoose/find-by-id)

    Finds a single document by its \_id field. `findById(id)` is almost\* equivalent to `findOne({ _id: id })`. If you want to query by a document's `_id`, use `findById()` instead of `findOne()`.

    The `id` is cast based on the Schema before sending the command.

    This function triggers the following middleware.

    - `findOne()`

    \* Except for how it treats `undefined`. If you use `findOne()`, you'll see that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent to `findOne({})` and return arbitrary documents. However, mongoose translates `findById(undefined)` into `findOne({ _id: null })`.

    #### [Example:](#example)

    ``` javascript
    // Find the adventure with the given `id`, or `null` if not foundawaitAdventure.findById(id).exec();

    // select only the adventures name and lengthawaitAdventure.findById(id, 'name length').exec();
    ```
- name: Model.findByIdAndDelete()
  id: api/model#Model.findByIdAndDelete()
  summary: Issue a MongoDB findOneAndDelete() command by a document's _id field
  belongs_to: Model
  description: |-
    ### Model.findByIdAndDelete()

    ##### Parameters:

    - `id`«Object\|Number\|String» value of `_id` to query by
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [Model.findOneAndRemove](#Model.findOneAndRemove())
    -  [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)

    Issue a MongoDB `findOneAndDelete()` command by a document's \_id field. In other words, `findByIdAndDelete(id)` is a shorthand for `findOneAndDelete({ _id: id })`.

    This function triggers the following middleware.

    - `findOneAndDelete()`
- name: Model.findByIdAndRemove()
  id: api/model#Model.findByIdAndRemove()
  summary: Issue a mongodb findOneAndRemove command by a document's _id field
  belongs_to: Model
  description: |-
    ### Model.findByIdAndRemove()

    ##### Parameters:

    - `id`«Object\|Number\|String» value of `_id` to query by
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.projection=null]`«Object\|String\|Array\[String\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())

    &nbsp;

    - `[options.sort]`«Object\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.select]`«Object\|String» sets the document fields to return.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [Model.findOneAndRemove](#Model.findOneAndRemove())
    -  [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)

    Issue a mongodb findOneAndRemove command by a document's \_id field. `findByIdAndRemove(id, ...)` is equivalent to `findOneAndRemove({ _id: id }, ...)`.

    Finds a matching document, removes it, and returns the found document (if any).

    This function triggers the following middleware.

    - `findOneAndRemove()`

    #### [Example:](#example)

    ``` javascript
    A.findByIdAndRemove(id, options)  // return Query
    A.findByIdAndRemove(id) // returns Query
    A.findByIdAndRemove()           // returns Query
    ```
- name: Model.findByIdAndUpdate()
  id: api/model#Model.findByIdAndUpdate()
  summary: Issues a mongodb findOneAndUpdate command by a document's _id field
  belongs_to: Model
  description: |-
    ### Model.findByIdAndUpdate()

    ##### Parameters:

    - `id`«Object\|Number\|String» value of `_id` to query by
    - `[update]` «Object»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.returnDocument='before']`«String» Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.

    &nbsp;

    - `[options.lean]`«Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](query#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.overwrite=false]`«Boolean» By default, if you don't include any [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace({ \_id: id }, update, options)](#Model.findOneAndReplace()).

    &nbsp;

    - `[options.sort]`«Object\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.

    &nbsp;

    - `[options.runValidators]`«Boolean» if true, runs [update validators](../validation#update-validators) on this command. Update validators validate the update operation against the model's schema

    &nbsp;

    - `[options.setDefaultsOnInsert=true]`«Boolean» If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](../defaults) specified in the model's schema if a new document is created

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.upsert=false]`«Boolean» if true, and no documents found, insert a new document

    &nbsp;

    - `[options.new=false]`«Boolean» if true, return the modified document rather than the original

    &nbsp;

    - `[options.select]`«Object\|String» sets the document fields to return.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [Model.findOneAndUpdate](#Model.findOneAndUpdate())
    -  [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)

    Issues a mongodb findOneAndUpdate command by a document's \_id field. `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.

    Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).

    This function triggers the following middleware.

    - `findOneAndUpdate()`

    #### [Example:](#example)

    ``` javascript
    A.findByIdAndUpdate(id, update, options)  // returns Query
    A.findByIdAndUpdate(id, update)           // returns Query
    A.findByIdAndUpdate()                     // returns Query
    ```

    #### [Note:](#note)

    All top level update keys which are not `atomic` operation names are treated as set operations:

    #### [Example:](#example-1)

    ``` javascript
    Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)

    // is sent as
    Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)
    ```

    This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`. To prevent this behaviour, see the `overwrite` option

    #### [Note:](#note-1)

    `findOneAndX` and `findByIdAndX` functions support limited validation. You can enable validation by setting the `runValidators` option.

    If you need full-fledged validation, use the traditional approach of first retrieving the document.

    ``` javascript
    const doc = await Model.findById(id)
    doc.name = 'jason bourne';
    await doc.save();
    ```
- name: Model.findOne()
  id: api/model#Model.findOne()
  summary: Finds one document
  belongs_to: Model
  description: |-
    ### Model.findOne()

    ##### Parameters:

    - `[conditions]` «Object»
    - `[projection]`«Object\|String\|Array\[String\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [field selection](query#Query.prototype.select())
    -  [lean queries](../tutorials/lean)

    Finds one document.

    The `conditions` are cast to their respective SchemaTypes before the command is sent.

    *Note:*`conditions` is optional, and if `conditions` is null or undefined, mongoose will send an empty `findOne` command to MongoDB, which will return an arbitrary document. If you're querying by `_id`, use `findById()` instead.

    #### [Example:](#example)

    ``` javascript
    // Find one adventure whose `country` is 'Croatia', otherwise `null`awaitAdventure.findOne({ country: 'Croatia' }).exec();

    // Model.findOne() no longer accepts a callback

    // Select only the adventures name and length
    await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();
    ```
- name: Model.findOneAndDelete()
  id: api/model#Model.findOneAndDelete()
  summary: Issue a MongoDB findOneAndDelete() command
  belongs_to: Model
  description: |-
    ### Model.findOneAndDelete()

    ##### Parameters:

    - `conditions` «Object»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.projection=null]`«Object\|String\|Array\[String\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.sort]`«Object\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.

    &nbsp;

    - `[options.select]`«Object\|String» sets the document fields to return.

    &nbsp;

    - `[options.maxTimeMS]`«Number» puts a time limit on the query - requires mongodb \>= 2.6.0

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    Issue a MongoDB `findOneAndDelete()` command.

    Finds a matching document, removes it, and returns the found document (if any).

    This function triggers the following middleware.

    - `findOneAndDelete()`

    This function differs slightly from `Model.findOneAndRemove()` in that `findOneAndRemove()` becomes a [MongoDB `findAndModify()` command](https://www.mongodb.com/docs/manual/reference/method/db.collection.findAndModify/), as opposed to a `findOneAndDelete()` command. For most mongoose use cases, this distinction is purely pedantic. You should use `findOneAndDelete()` unless you have a good reason not to.

    #### [Example:](#example)

    ``` javascript
    A.findOneAndDelete(conditions, options)  // return Query
    A.findOneAndDelete(conditions) // returns Query
    A.findOneAndDelete()           // returns Query
    ```

    `findOneAndX` and `findByIdAndX` functions support limited validation. You can enable validation by setting the `runValidators` option.

    If you need full-fledged validation, use the traditional approach of first retrieving the document.

    ``` javascript
    const doc = await Model.findById(id)
    doc.name = 'jason bourne';
    await doc.save();
    ```
- name: Model.findOneAndRemove()
  id: api/model#Model.findOneAndRemove()
  summary: Issue a mongodb findOneAndRemove command
  belongs_to: Model
  description: |-
    ### Model.findOneAndRemove()

    ##### Parameters:

    - `conditions` «Object»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.projection=null]`«Object\|String\|Array\[String\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())

    &nbsp;

    - `[options.sort]`«Object\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.select]`«Object\|String» sets the document fields to return.

    &nbsp;

    - `[options.maxTimeMS]`«Number» puts a time limit on the query - requires mongodb \>= 2.6.0

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)

    Issue a mongodb findOneAndRemove command.

    Finds a matching document, removes it, and returns the found document (if any).

    This function triggers the following middleware.

    - `findOneAndRemove()`

    #### [Example:](#example)

    ``` javascript
    A.findOneAndRemove(conditions, options)  // return Query
    A.findOneAndRemove(conditions) // returns Query
    A.findOneAndRemove()           // returns Query
    ```

    `findOneAndX` and `findByIdAndX` functions support limited validation. You can enable validation by setting the `runValidators` option.

    If you need full-fledged validation, use the traditional approach of first retrieving the document.

    ``` javascript
    const doc = await Model.findById(id);
    doc.name = 'jason bourne';
    await doc.save();
    ```
- name: Model.findOneAndReplace()
  id: api/model#Model.findOneAndReplace()
  summary: Issue a MongoDB findOneAndReplace() command
  belongs_to: Model
  description: |-
    ### Model.findOneAndReplace()

    ##### Parameters:

    - `filter`«Object» Replace the first document that matches this filter
    - `[replacement]`«Object» Replace with this document
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.returnDocument='before']`«String» Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.

    &nbsp;

    - `[options.lean]`«Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](query#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.projection=null]`«Object\|String\|Array\[String\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())

    &nbsp;

    - `[options.sort]`«Object\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.select]`«Object\|String» sets the document fields to return.

    &nbsp;

    - `[options.maxTimeMS]`«Number» puts a time limit on the query - requires mongodb \>= 2.6.0

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    Issue a MongoDB `findOneAndReplace()` command.

    Finds a matching document, replaces it with the provided doc, and returns the document.

    This function triggers the following query middleware.

    - `findOneAndReplace()`

    #### [Example:](#example)

    ``` javascript
    A.findOneAndReplace(filter, replacement, options)  // return Query
    A.findOneAndReplace(filter, replacement) // returns Query
    A.findOneAndReplace()                    // returns Query
    ```
- name: Model.findOneAndUpdate()
  id: api/model#Model.findOneAndUpdate()
  summary: Issues a mongodb findOneAndUpdate command
  belongs_to: Model
  description: |-
    ### Model.findOneAndUpdate()

    ##### Parameters:

    - `[conditions]` «Object»
    - `[update]` «Object»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.returnDocument='before']`«String» Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.

    &nbsp;

    - `[options.lean]`«Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](query#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.overwrite=false]`«Boolean» By default, if you don't include any [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) in `update`, Mongoose will wrap `update` in `$set` for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding `$set`. An alternative to this would be using [Model.findOneAndReplace(conditions, update, options, callback)](#Model.findOneAndReplace()).

    &nbsp;

    - `[options.upsert=false]`«Boolean» if true, and no documents found, insert a new document

    &nbsp;

    - `[options.projection=null]`«Object\|String\|Array\[String\]» optional fields to return, see [`Query.prototype.select()`](query#Query.prototype.select())

    &nbsp;

    - `[options.new=false]`«Boolean» if true, return the modified document rather than the original

    &nbsp;

    - `[options.fields]`«Object\|String» Field selection. Equivalent to `.select(fields).findOneAndUpdate()`

    &nbsp;

    - `[options.maxTimeMS]`«Number» puts a time limit on the query - requires mongodb \>= 2.6.0

    &nbsp;

    - `[options.sort]`«Object\|String» if multiple docs are found by the conditions, sets the sort order to choose which doc to update.

    &nbsp;

    - `[options.runValidators]`«Boolean» if true, runs [update validators](../validation#update-validators) on this command. Update validators validate the update operation against the model's schema

    &nbsp;

    - `[options.setDefaultsOnInsert=true]`«Boolean» If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](../defaults) specified in the model's schema if a new document is created

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [Tutorial](../tutorials/findoneandupdate)
    -  [mongodb](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)

    Issues a mongodb findOneAndUpdate command.

    Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes if `callback` is passed else a Query object is returned.

    #### [Example:](#example)

    ``` javascript
    A.findOneAndUpdate(conditions, update, options)  // returns Query
    A.findOneAndUpdate(conditions, update)           // returns Query
    A.findOneAndUpdate()                             // returns Query
    ```

    #### [Note:](#note)

    All top level update keys which are not `atomic` operation names are treated as set operations:

    #### [Example:](#example-1)

    ``` javascript
    const query = { name: 'borne' };
    Model.findOneAndUpdate(query, { name: 'jason bourne' }, options)

    // is sent as
    Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options)
    ```

    #### [Note:](#note-1)

    `findOneAndX` and `findByIdAndX` functions support limited validation that you can enable by setting the `runValidators` option.

    If you need full-fledged validation, use the traditional approach of first retrieving the document.

    ``` javascript
    const doc = await Model.findById(id);
    doc.name = 'jason bourne';
    await doc.save();
    ```
- name: Model.hydrate()
  id: api/model#Model.hydrate()
  summary: Shortcut for creating a new Document from existing raw data, pre-saved in the DB
  belongs_to: Model
  description: |-
    ### Model.hydrate()

    ##### Parameters:

    - `obj` «Object»
    - `[projection]`«Object\|String\|Array\[String\]» optional projection containing which fields should be selected for this document
    - `[options]`«Object» optional options

    &nbsp;

    - `[options.setters=false]`«Boolean» if true, apply schema setters when hydrating

    ##### Returns:

    - «Document» document instance

    Shortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.

    #### [Example:](#example)

    ``` javascript
    // hydrate previous data into a Mongoose documentconst mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });
    ```
- name: Model.init()
  id: api/model#Model.init()
  summary: This function is responsible for building indexes, unless autoIndex is turned off
  belongs_to: Model
  description: |-
    ### Model.init()

    This function is responsible for building [indexes](https://www.mongodb.com/docs/manual/indexes/), unless [`autoIndex`](../guide#autoIndex) is turned off.

    Mongoose calls this function automatically when a model is created using [`mongoose.model()`](mongoose#Mongoose.prototype.model()) or [`connection.model()`](connection#Connection.prototype.model()), so you don't need to call `init()` to trigger index builds.

    However, you *may* need to call `init()` to get back a promise that will resolve when your indexes are finished. Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing. For example, if you want to wait for unique indexes to build before continuing with a test case.

    #### [Example:](#example)

    ``` javascript
    const eventSchema = new Schema({ thing: { type: 'string', unique: true } })
    // This calls `Event.init()` implicitly, so you don't need to call
    // `Event.init()` on your own.
    const Event = mongoose.model('Event', eventSchema);

    await Event.init();
    console.log('Indexes are done building!');
    ```
- name: Model.insertMany()
  id: api/model#Model.insertMany()
  summary: Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid
  belongs_to: Model
  description: |-
    ### Model.insertMany()

    ##### Parameters:

    - `doc(s)` «Array\|Object\|\[object Object\]»
    - `[options]`«Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)

    &nbsp;

    - `[options.ordered=true]`«Boolean» if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an "unordered" `insertMany()`.

    &nbsp;

    - `[options.rawResult=false]`«Boolean» if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.

    &nbsp;

    - `[options.lean=false]`«Boolean» if `true`, skips hydrating and validating the documents. This option is useful if you need the extra performance, but Mongoose won't validate the documents before inserting.

    &nbsp;

    - `[options.limit=null]`«Number» this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.

    &nbsp;

    - `[options.populate=null]`«String\|Object\|Array» populates the result documents. This option is a no-op if `rawResult` is set.

    &nbsp;

    - `[options.throwOnValidationError=false]`«Boolean» If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.

    ##### Returns:

    - «Promise» resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise

    Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than `.create()` because it only sends one operation to the server, rather than one for each document.

    Mongoose always validates each document **before** sending `insertMany` to MongoDB. So if one document has a validation error, no documents will be saved, unless you set [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).

    This function does **not** trigger save middleware.

    This function triggers the following middleware.

    - `insertMany()`

    #### [Example:](#example)

    ``` javascript
    awaitMovies.insertMany([
      { name: 'Star Wars' },
      { name: 'The Empire Strikes Back' }
    ]);
    ```
- name: Model.inspect()
  id: api/model#Model.inspect()
  summary: Helper for console.log
  belongs_to: Model
  description: |-
    ### Model.inspect()

    Helper for console.log. Given a model named 'MyModel', returns the string `'Model { MyModel }'`.

    #### [Example:](#example)

    ``` javascript
    constMyModel = mongoose.model('Test', Schema({ name: String }));
    MyModel.inspect(); // 'Model { Test }'
    console.log(MyModel); // Prints 'Model { Test }'
    ```
- name: Model.listIndexes()
  id: api/model#Model.listIndexes()
  summary: Lists the indexes currently defined in MongoDB
  belongs_to: Model
  description: |-
    ### Model.listIndexes()

    ##### Returns:

    - «Promise»

    Lists the indexes currently defined in MongoDB. This may or may not be the same as the indexes defined in your schema depending on whether you use the [`autoIndex` option](../guide#autoIndex) and if you build indexes manually.
- name: Model.populate()
  id: api/model#Model.populate()
  summary: Populates document references
  belongs_to: Model
  description: |-
    ### Model.populate()

    ##### Parameters:

    - `docs`«Document\|Array» Either a single document or array of documents to populate.
    - `options`«Object\|String» Either the paths to populate or an object specifying all parameters

    &nbsp;

    - `[options.path=null]`«string» The path to populate.

    &nbsp;

    - `[options.populate=null]`«string\|PopulateOptions» Recursively populate paths in the populated documents. See [deep populate docs](../populate#deep-populate).

    &nbsp;

    - `[options.retainNullValues=false]`«boolean» By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.

    &nbsp;

    - `[options.getters=false]`«boolean» If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](../schematypes#schematype-options).

    &nbsp;

    - `[options.clone=false]`«boolean» When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.

    &nbsp;

    - `[options.match=null]`«Object\|Function» Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.

    &nbsp;

    - `[options.skipInvalidIds=false]`«Boolean» By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.

    &nbsp;

    - `[options.perDocumentLimit=null]`«Number» For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.

    &nbsp;

    - `[options.strictPopulate=true]`«Boolean» Set to false to allow populating paths that aren't defined in the given model's schema.

    &nbsp;

    - `[options.options=null]`«Object» Additional options like `limit` and `lean`.

    &nbsp;

    - `[options.transform=null]`«Function» Function that Mongoose will call on every populated document that allows you to transform the populated document.

    &nbsp;

    - `[callback(err,doc)]`«Function» Optional callback, executed upon completion. Receives `err` and the `doc(s)`.

    ##### Returns:

    - «Promise»

    Populates document references.

    Changed in Mongoose 6: the model you call `populate()` on should be the "local field" model, **not** the "foreign field" model.

    #### [Available top-level options:](#available-top-level-options)

    - path: space delimited path(s) to populate
    - select: optional fields to select
    - match: optional query conditions to match
    - model: optional name of the model to use for population
    - options: optional query options like sort, limit, etc
    - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.
    - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.

    #### [Example:](#example)

    ``` javascript
    constDog = mongoose.model('Dog', new Schema({ name: String, breed: String }));
    const Person = mongoose.model('Person', new Schema({
      name: String,
      pet: { type: mongoose.ObjectId, ref: 'Dog' }
    }));

    const pets = await Pet.create([
      { name: 'Daisy', breed: 'Beagle' },
      { name: 'Einstein', breed: 'Catalan Sheepdog' }
    ]);

    // populate many plain objects
    const users = [
      { name: 'John Wick', dog: pets[0]._id },
      { name: 'Doc Brown', dog: pets[1]._id }
    ];
    await User.populate(users, { path: 'dog', select: 'name' });
    users[0].dog.name; // 'Daisy'
    users[0].dog.breed; // undefined because of `select`
    ```
- name: Model.prototype.$model()
  id: api/model#Model.prototype.$model()
  summary: Returns another Model instance
  belongs_to: Model
  description: |-
    ### Model.prototype.$model()

    ##### Parameters:

    - `name`«String» model name

    ##### Returns:

    - «Model»

    Returns another Model instance.

    #### [Example:](#example)

    ``` javascript
    const doc = new Tank;
    await doc.model('User').findById(id);
    ```
- name: Model.prototype.$where
  id: api/model#Model.prototype.$where
  summary: Additional properties to attach to the query when calling save() and isNew is false
  belongs_to: Model
  description: |-
    ### Model.prototype.$where

    ##### Type:

    - «property»

    Additional properties to attach to the query when calling `save()` and `isNew` is false.
- name: Model.prototype.base
  id: api/model#Model.prototype.base
  summary: Base Mongoose instance the model uses
  belongs_to: Model
  description: |-
    ### Model.prototype.base

    ##### Type:

    - «property»

    Base Mongoose instance the model uses.
- name: Model.prototype.baseModelName
  id: api/model#Model.prototype.baseModelName
  summary: If this is a discriminator model, baseModelName is the name of the base model
  belongs_to: Model
  description: |-
    ### Model.prototype.baseModelName

    ##### Type:

    - «property»

    If this is a discriminator model, `baseModelName` is the name of the base model.
- name: Model.prototype.collection
  id: api/model#Model.prototype.collection
  summary: The collection instance this model uses
  belongs_to: Model
  description: |-
    ### Model.prototype.collection

    ##### Type:

    - «property»

    The collection instance this model uses. A Mongoose collection is a thin wrapper around a \[MongoDB Node.js driver collection\]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)). Using `Model.collection` means you bypass Mongoose middleware, validation, and casting.

    This property is read-only. Modifying this property is a no-op.

    ### Model.prototype.collection

    ##### Type:

    - «property»

    Collection the model uses.
- name: Model.prototype.db
  id: api/model#Model.prototype.db
  summary: Connection the model uses
  belongs_to: Model
  description: |-
    ### Model.prototype.db

    ##### Type:

    - «property»

    Connection the model uses.
- name: Model.prototype.deleteOne()
  id: api/model#Model.prototype.deleteOne()
  summary: Removes this document from the db
  belongs_to: Model
  description: |-
    ### Model.prototype.deleteOne()

    ##### Returns:

    - «Promise» Promise

    Removes this document from the db. Equivalent to `.remove()`.

    #### [Example:](#example)

    ``` javascript
    product = await product.deleteOne();
    await Product.findById(product._id); // null
    ```
- name: Model.prototype.discriminators
  id: api/model#Model.prototype.discriminators
  summary: Registered discriminators for this model
  belongs_to: Model
  description: |-
    ### Model.prototype.discriminators

    ##### Type:

    - «property»

    Registered discriminators for this model.
- name: Model.prototype.increment()
  id: api/model#Model.prototype.increment()
  summary: Signal that we desire an increment of this documents version
  belongs_to: Model
  description: |-
    ### Model.prototype.increment()

    ##### See:

    -  [versionKeys](../guide#versionKey)

    Signal that we desire an increment of this documents version.

    #### [Example:](#example)

    ``` javascript
    const doc = await Model.findById(id);
    doc.increment();
    await doc.save();
    ```
- name: Model.prototype.model()
  id: api/model#Model.prototype.model()
  summary: Returns another Model instance
  belongs_to: Model
  description: |-
    ### Model.prototype.model()

    ##### Parameters:

    - `name`«String» model name

    ##### Returns:

    - «Model»

    Returns another Model instance.

    #### [Example:](#example)

    ``` javascript
    const doc = new Tank;
    await doc.model('User').findById(id);
    ```
- name: Model.prototype.modelName
  id: api/model#Model.prototype.modelName
  summary: null
  belongs_to: Model
  description: |-
    ### Model.prototype.modelName

    ##### Type:

    - «property»

    The name of the model
- name: Model.prototype.save()
  id: api/model#Model.prototype.save()
  summary: Saves this document by inserting a new document into the database if document.isNew is true, or sends an updateOne operation with just the modified paths if isNew is false
  belongs_to: Model
  description: |-
    ### Model.prototype.save()

    ##### Parameters:

    - `[options]`«Object» options optional options

    &nbsp;

    - `[options.session=null]`«Session» the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](document#Document.prototype.session()).

    &nbsp;

    - `[options.safe]`«Object» (DEPRECATED) overrides [schema's safe option](../guide#safe). Use the `w` option instead.

    &nbsp;

    - `[options.validateBeforeSave]`«Boolean» set to false to save without validating.

    &nbsp;

    - `[options.validateModifiedOnly=false]`«Boolean» if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.

    &nbsp;

    - `[options.w]`«Number\|String» set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](../guide#writeConcern)

    &nbsp;

    - `[options.j]`«Boolean» set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](../guide#writeConcern)

    &nbsp;

    - `[options.wtimeout]`«Number» sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](../guide#writeConcern).

    &nbsp;

    - `[options.checkKeys=true]`«Boolean» the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)

    &nbsp;

    - `[options.timestamps=true]`«Boolean» if `false` and [timestamps](../guide#timestamps) are enabled, skip timestamps for this `save()`.

    ##### Returns:

    - «Promise»

    ##### See:

    -  [middleware](../middleware)

    Saves this document by inserting a new document into the database if [document.isNew](document#Document.prototype.isNew) is `true`, or sends an [updateOne](document#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.

    #### [Example:](#example)

    ``` javascript
    product.sold = Date.now();
    product = await product.save();
    ```

    If save is successful, the returned promise will fulfill with the document saved.

    #### [Example:](#example-1)

    ``` javascript
    const newProduct = await product.save();
    newProduct === product; // true
    ```
- name: Model.replaceOne()
  id: api/model#Model.replaceOne()
  summary: Replace the existing document with the given document (no atomic operators like $set)
  belongs_to: Model
  description: |-
    ### Model.replaceOne()

    ##### Parameters:

    - `filter` «Object»
    - `doc` «Object»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.upsert=false]`«Boolean» if true, and no documents found, insert a new document

    &nbsp;

    - `[options.writeConcern=null]`«Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [Query docs](../queries)
    -  [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)

    Replace the existing document with the given document (no atomic operators like `$set`).

    #### [Example:](#example)

    ``` javascript
    const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });
    res.matchedCount; // Number of documents matched
    res.modifiedCount; // Number of documents modified
    res.acknowledged; // Boolean indicating everything went smoothly.
    res.upsertedId; // null or an id containing a document that had to be upserted.
    res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.
    ```

    This function triggers the following middleware.

    - `replaceOne()`
- name: Model.schema
  id: api/model#Model.schema
  summary: Schema the model uses
  belongs_to: Model
  description: |-
    ### Model.schema

    ##### Type:

    - «property»

    Schema the model uses.
- name: Model.startSession()
  id: api/model#Model.startSession()
  summary: Requires MongoDB >= 3.6.0
  belongs_to: Model
  description: |-
    ### Model.startSession()

    ##### Parameters:

    - `[options]`«Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)

    &nbsp;

    - `[options.causalConsistency=true]`«Boolean» set to false to disable causal consistency

    ##### Returns:

    - «Promise\<ClientSession\>» promise that resolves to a MongoDB driver `ClientSession`

    *Requires MongoDB \>= 3.6.0.* Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions) for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/), and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).

    Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.

    This function does not trigger any middleware.

    #### [Example:](#example)

    ``` javascript
    const session = await Person.startSession();
    let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });
    await doc.remove();
    // `doc` will always be null, even if reading from a replica set
    // secondary. Without causal consistency, it is possible to
    // get a doc back from the below query if the query reads from a
    // secondary that is experiencing replication lag.
    doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });
    ```
- name: Model.syncIndexes()
  id: api/model#Model.syncIndexes()
  summary: Makes the indexes in MongoDB match the indexes defined in this model's schema
  belongs_to: Model
  description: |-
    ### Model.syncIndexes()

    ##### Parameters:

    - `[options]`«Object» options to pass to `ensureIndexes()`

    &nbsp;

    - `[options.background=null]`«Boolean» if specified, overrides each index's `background` property

    ##### Returns:

    - «Promise»

    Makes the indexes in MongoDB match the indexes defined in this model's schema. This function will drop any indexes that are not defined in the model's schema except the `_id` index, and build any indexes that are in your schema but not in MongoDB.

    See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes) for more information.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ name: { type: String, unique: true } });
    const Customer = mongoose.model('Customer', schema);
    await Customer.collection.createIndex({ age: 1 }); // Index is not in schema
    // Will drop the 'age' index and create an index on `name`
    await Customer.syncIndexes();
    ```
- name: Model.translateAliases()
  id: api/model#Model.translateAliases()
  summary: By default, translateAliases() overwrites raw fields with aliased fields
  belongs_to: Model
  description: |-
    ### Model.translateAliases()

    ##### Parameters:

    - `fields`«Object» fields/conditions that may contain aliased keys
    - `[errorOnDuplicates]`«Boolean» if true, throw an error if there's both a key and an alias for that key in `fields`

    ##### Returns:

    - «Object» the translated 'pure' fields/conditions

    Translate any aliases fields/conditions so the final query or document object is pure

    #### [Example:](#example)

    ``` javascript
    awaitCharacter.find(Character.translateAliases({
       '名': 'Eddard Stark'// Alias for 'name'
    });
    ```

    By default, `translateAliases()` overwrites raw fields with aliased fields. So if `n` is an alias for `name`, `{ n: 'alias', name: 'raw' }` will resolve to `{ name: 'alias' }`. However, you can set the `errorOnDuplicates` option to throw an error if there are potentially conflicting paths. The `translateAliases` option for queries uses `errorOnDuplicates`.

    #### [Note:](#note)

    Only translate arguments of object type anything else is returned raw
- name: Model.updateMany()
  id: api/model#Model.updateMany()
  summary: Same as updateOne(), except MongoDB will update all documents that match filter (as opposed to just the first one) regardless of the value of the multi option
  belongs_to: Model
  description: |-
    ### Model.updateMany()

    ##### Parameters:

    - `filter` «Object»
    - `update` «Object\|Array»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.upsert=false]`«Boolean» if true, and no documents found, insert a new document

    &nbsp;

    - `[options.writeConcern=null]`«Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [Query docs](../queries)
    -  [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)
    -  [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)

    Same as `updateOne()`, except MongoDB will update *all* documents that match `filter` (as opposed to just the first one) regardless of the value of the `multi` option.

    **Note** updateMany will *not* fire update middleware. Use `pre('updateMany')` and `post('updateMany')` instead.

    #### [Example:](#example)

    ``` javascript
    const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });
    res.matchedCount; // Number of documents matched
    res.modifiedCount; // Number of documents modified
    res.acknowledged; // Boolean indicating everything went smoothly.
    res.upsertedId; // null or an id containing a document that had to be upserted.
    res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.
    ```

    This function triggers the following middleware.

    - `updateMany()`
- name: Model.updateOne()
  id: api/model#Model.updateOne()
  summary: Update only the first document that matches filter
  belongs_to: Model
  description: |-
    ### Model.updateOne()

    ##### Parameters:

    - `filter` «Object»
    - `update` «Object\|Array»
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](query#Query.prototype.setOptions())

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.upsert=false]`«Boolean» if true, and no documents found, insert a new document

    &nbsp;

    - `[options.writeConcern=null]`«Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query»

    ##### See:

    -  [Query docs](../queries)
    -  [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)
    -  [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)

    Update *only* the first document that matches `filter`.

    - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.

    #### [Example:](#example)

    ``` javascript
    const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });
    res.matchedCount; // Number of documents matched
    res.modifiedCount; // Number of documents modified
    res.acknowledged; // Boolean indicating everything went smoothly.
    res.upsertedId; // null or an id containing a document that had to be upserted.
    res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.
    ```

    This function triggers the following middleware.

    - `updateOne()`
- name: Model.validate()
  id: api/model#Model.validate()
  summary: Casts and validates the given object against this model's schema, passing the given context to custom validators
  belongs_to: Model
  description: |-
    ### Model.validate()

    ##### Parameters:

    - `obj` «Object»
    - `pathsToValidate` «Array\|String»
    - `[context]` «Object»

    ##### Returns:

    - «Promise,undefined,void»

    Casts and validates the given object against this model's schema, passing the given `context` to custom validators.

    #### [Example:](#example)

    ``` javascript
    constModel = mongoose.model('Test', Schema({
      name: { type: String, required: true },
      age: { type: Number, required: true }
    });

    try {
      await Model.validate({ name: null }, ['name'])
    } catch (err) {
      err instanceof mongoose.Error.ValidationError; // true
      Object.keys(err.errors); // ['name']
    }
    ```
- name: Model.watch()
  id: api/model#Model.watch()
  summary: Requires a replica set running MongoDB >= 3.6.0
  belongs_to: Model
  description: |-
    ### Model.watch()

    ##### Parameters:

    - `[pipeline]` «Array»
    - `[options]`«Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)

    &nbsp;

    - `[options.hydrate=false]`«Boolean» if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document

    ##### Returns:

    - «ChangeStream» mongoose-specific change stream wrapper, inherits from EventEmitter

    *Requires a replica set running MongoDB \>= 3.6.0.* Watches the underlying collection for changes using [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).

    This function does **not** trigger any middleware. In particular, it does **not** trigger aggregate middleware.

    The ChangeStream object is an event emitter that emits the following events:

    - 'change': A change occurred, see below example
    - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.
    - 'end': Emitted if the underlying stream is closed
    - 'close': Emitted if the underlying stream is closed

    #### [Example:](#example)

    ``` javascript
    const doc = await Person.create({ name: 'Ned Stark' });
    const changeStream = Person.watch().on('change', change => console.log(change));
    // Will print from the above `console.log()`:
    // { _id: { _data: ... },
    //   operationType: 'delete',
    //   ns: { db: 'mydb', coll: 'Person' },
    //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }
    await doc.remove();
    ```
- name: Model.where()
  id: api/model#Model.where()
  summary: Creates a Query, applies the passed conditions, and returns the Query
  belongs_to: Model
  description: "### Model.where()\n\n##### Parameters:\n\n- `path` «String»\n- `[val]`«Object» optional value\n\n##### Returns:\n\n- «Query»\n\nCreates a Query, applies the passed conditions, and returns the Query.\n\nFor example, instead of writing:\n\n``` javascript\nUser.find({ age: { $gte: 21, $lte: 65 } });\n```\n\nwe can instead write:\n\n``` javascript\nUser.where('age').gte(21).lte(65).exec();\n```\n\nSince the Query class also supports `where` you can continue chaining\n\n``` javascript\nUser\n.where('age').gte(21).lte(65)\n.where('name', /^b/i)\n... etc\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/model.html](https://mongoosejs.com/docs/api/model.html)"
- name: Models
  id: models
  summary: Models are fancy constructors compiled from Schema definitions
  description: "# Models\n\n[Models](api/model) are fancy constructors compiled from `Schema` definitions. An instance of a model is called a [document](documents). Models are responsible for creating and reading documents from the underlying MongoDB database.\n\n- [Compiling your first model](#compiling)\n- [Constructing Documents](#constructing-documents)\n- [Querying](#querying)\n- [Deleting](#deleting)\n- [Updating](#updating)\n- [Change Streams](#change-streams)\n- [Views](#views)\n\n## Compiling your first model\n\nWhen you call `mongoose.model()` on a schema, Mongoose *compiles* a model for you.\n\n``` javascript\nconst schema = new mongoose.Schema({ name: String, size: String });\nconst Tank = mongoose.model('Tank', schema);\n```\n\nThe first argument is the *singular* name of the collection your model is for. **Mongoose automatically looks for the plural, lowercased version of your model name.** Thus, for the example above, the model Tank is for the **tanks** collection in the database.\n\n**Note:** The `.model()` function makes a copy of `schema`. Make sure that you've added everything you want to `schema`, including hooks, before calling `.model()`!\n\n## Constructing Documents\n\nAn instance of a model is called a [document](documents). Creating them and saving to the database is easy.\n\n``` javascript\nconst Tank = mongoose.model('Tank', yourSchema);\n\nconst small = new Tank({ size: 'small' });\nawait small.save();\n\n// or\n\nawait Tank.create({ size: 'small' });\n\n// or, for inserting large batches of documents\nawait Tank.insertMany([{ size: 'small' }]);\n```\n\nNote that no tanks will be created/removed until the connection your model uses is open. Every model has an associated connection. When you use `mongoose.model()`, your model will use the default mongoose connection.\n\n``` javascript\nawait mongoose.connect('mongodb://127.0.0.1/gettingstarted');\n```\n\nIf you create a custom connection, use that connection's `model()` function instead.\n\n``` javascript\nconst connection = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\nconst Tank = connection.model('Tank', yourSchema);\n```\n\n## Querying\n\nFinding documents is easy with Mongoose, which supports the [rich](https://www.mongodb.com/docs/manual/reference/method/js-cursor/) query syntax of MongoDB. Documents can be retrieved using a `model`'s [find](api/model#model_Model-find), [findById](api/model#model_Model-findById), [findOne](api/model#model_Model-findOne), or [where](api/model#model_Model-where) static functions.\n\n``` javascript\nawait Tank.find({ size: 'small' }).where('createdDate').gt(oneYearAgo).exec();\n```\n\nSee the chapter on [queries](queries) for more details on how to use the [Query](api/query) api.\n\n## Deleting\n\nModels have static `deleteOne()` and `deleteMany()` functions for removing all documents matching the given `filter`.\n\n``` javascript\nawait Tank.deleteOne({ size: 'large' });\n```\n\n## Updating\n\nEach `model` has its own `update` method for modifying documents in the database without returning them to your application. See the [API](api/model#model_Model-updateOne) docs for more detail.\n\n``` javascript\n// Updated at most one doc, `res.nModified` contains the number\n// of docs that MongoDB updated\nawait Tank.updateOne({ size: 'large' }, { name: 'T-90' });\n```\n\n*If you want to update a single document in the db and return it to your application, use [findOneAndUpdate](api/model#model_Model-findOneAndUpdate) instead.*\n\n## Change Streams\n\n[Change streams](https://www.mongodb.com/docs/manual/changeStreams/) provide a way for you to listen to all inserts and updates going through your MongoDB database. Note that change streams do **not** work unless you're connected to a [MongoDB replica set](https://www.mongodb.com/docs/manual/replication/).\n\n``` javascript\nasync function run() {\n  // Create a new mongoose model\n  const personSchema = new mongoose.Schema({\n    name: String\n  });\n  const Person = mongoose.model('Person', personSchema);\n\n  // Create a change stream. The 'change' event gets emitted when there's a\n  // change in the database\n  Person.watch().\n    on('change', data => console.log(new Date(), data));\n\n  // Insert a doc, will trigger the change stream handler above\n  console.log(new Date(), 'Inserting doc');\n  await Person.create({ name: 'Axl Rose' });\n}\n```\n\nThe output from the above [async function](http://thecodebarbarian.com/80-20-guide-to-async-await-in-node.js.html) will look like what you see below.\n\n``` javascript\n2018-05-11T15:05:35.467Z 'Inserting doc'\n2018-05-11T15:05:35.487Z 'Inserted doc'\n2018-05-11T15:05:35.491Z { _id: { _data: ... },\n  operationType: 'insert',\n  fullDocument: { _id: 5af5b13fe526027666c6bf83, name: 'Axl Rose', __v: 0 },\n  ns: { db: 'test', coll: 'Person' },\n  documentKey: { _id: 5af5b13fe526027666c6bf83 } }\n```\n\nYou can read more about [change streams in mongoose in this blog post](http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-change-streams.html#change-streams-in-mongoose).\n\n## Views\n\n[MongoDB Views](https://www.mongodb.com/docs/manual/core/views) are essentially read-only collections that contain data computed from other collections using [aggregations](api/aggregate). In Mongoose, you should define a separate Model for each of your Views. You can also create a View using [`createCollection()`](api/model#model_Model-createCollection).\n\nThe following example shows how you can create a new `RedactedUser` View on a `User` Model that hides potentially sensitive information, like name and email.\n\n``` javascript\n// Make sure to disable `autoCreate` and `autoIndex` for Views,\n// because you want to create the collection manually.\nconst userSchema = new Schema({\n  name: String,\n  email: String,\n  roles: [String]\n}, { autoCreate: false, autoIndex: false });\nconst User = mongoose.model('User', userSchema);\n\nconst RedactedUser = mongoose.model('RedactedUser', userSchema);\n\n// First, create the User model's underlying collection...\nawait User.createCollection();\n// Then create the `RedactedUser` model's underlying collection\n// as a View.\nawait RedactedUser.createCollection({\n  viewOn: 'users', // Set `viewOn` to the collection name, **not** model name.\n  pipeline: [\n    {\n      $set: {\n        name: { $concat: [{ $substr: ['$name', 0, 3] }, '...'] },\n        email: { $concat: [{ $substr: ['$email', 0, 3] }, '...'] }\n      }\n    }\n  ]\n});\n\nawait User.create([\n  { name: 'John Smith', email: 'john.smith@gmail.com', roles: ['user'] },\n  { name: 'Bill James', email: 'bill@acme.co', roles: ['user', 'admin'] }\n]);\n\n// [{ _id: ..., name: 'Bil...', email: 'bil...', roles: ['user', 'admin'] }]\nconsole.log(await RedactedUser.find({ roles: 'admin' }));\n```\n\nNote that Mongoose does **not** currently enforce that Views are read-only. If you attempt to `save()` a document from a View, you will get an error from the MongoDB server.\n\n## Yet more\n\nThe [API docs](api/model#model_Model) cover many additional methods available like [count](api/model#model_Model-count), [mapReduce](api/model#model_Model-mapReduce), [aggregate](api/model#model_Model-aggregate), and [more](api/model#model_Model-findOneAndRemove).\n\n## Next Up\n\nNow that we've covered `Models`, let's take a look at [Documents](documents).\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/models.html](https://mongoosejs.com/docs/models.html)"
- name: Mongoose
  id: api/mongoose
  summary: Mongoose constructor
  description: "# Mongoose\n\n### Mongoose()\n\n##### Parameters:\n\n- `options` «Object» see [`Mongoose#set()` docs](#Mongoose.prototype.set())\n\nMongoose constructor.\n\nThe exports object of the `mongoose` module is an instance of this class. Most apps will only use this one instance.\n\n#### [Example:](#example)\n\n``` javascript\nconst mongoose = require('mongoose');\nmongoose instanceof mongoose.Mongoose; // true\n\n// Create a new Mongoose instance with its own `connect()`, `set()`, `model()`, etc.\nconst m = new mongoose.Mongoose();\n```\n\n### Mongoose.prototype.Aggregate()\n\nThe Mongoose Aggregate constructor\n\n### Mongoose.prototype.CastError()\n\n##### Parameters:\n\n- `type` «String» The name of the type\n- `value` «Any» The value that failed to cast\n- `path` «String» The path `a.b.c` in the doc where this cast error occurred\n- `[reason]` «Error» The original error that was thrown\n\nThe Mongoose CastError constructor\n\n### Mongoose.prototype.Collection()\n\nThe Mongoose Collection constructor\n\n### Mongoose.prototype.Connection()\n\nThe Mongoose [Connection](connection#Connection()) constructor\n\n### Mongoose.prototype.ConnectionStates\n\n##### Type:\n\n- «property»\n\nExpose connection states for user-land\n\n### Mongoose.prototype.Date\n\n##### Type:\n\n- «property»\n\nThe Mongoose Date [SchemaType](../schematypes).\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ test: Date });\nschema.path('test') instanceof mongoose.Date; // true\n```\n\n### Mongoose.prototype.Decimal128\n\n##### Type:\n\n- «property»\n\nThe Mongoose Decimal128 [SchemaType](../schematypes). Used for declaring paths in your schema that should be [128-bit decimal floating points](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html). Do not use this to create a new Decimal128 instance, use `mongoose.Types.Decimal128` instead.\n\n#### [Example:](#example)\n\n``` javascript\nconst vehicleSchema = new Schema({ fuelLevel: mongoose.Decimal128 });\n```\n\n### Mongoose.prototype.Document()\n\nThe Mongoose [Document](document#Document()) constructor.\n\n### Mongoose.prototype.DocumentProvider()\n\nThe Mongoose DocumentProvider constructor. Mongoose users should not have to use this directly\n\n### Mongoose.prototype.Error()\n\nThe [MongooseError](error#Error()) constructor.\n\n### Mongoose.prototype.Mixed\n\n##### Type:\n\n- «property»\n\nThe Mongoose Mixed [SchemaType](../schematypes). Used for declaring paths in your schema that Mongoose's change tracking, casting, and validation should ignore.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ arbitrary: mongoose.Mixed });\n```\n\n### Mongoose.prototype.Model()\n\nThe Mongoose [Model](model#Model()) constructor.\n\n### Mongoose.prototype.Mongoose()\n\nThe Mongoose constructor\n\nThe exports of the mongoose module is an instance of this class.\n\n#### [Example:](#example)\n\n``` javascript\nconst mongoose = require('mongoose');\nconst mongoose2 = new mongoose.Mongoose();\n```\n\n### Mongoose.prototype.Number\n\n##### Type:\n\n- «property»\n\nThe Mongoose Number [SchemaType](../schematypes). Used for declaring paths in your schema that Mongoose should cast to numbers.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ num: mongoose.Number });\n// Equivalent to:\nconst schema = new Schema({ num: 'number' });\n```\n\n### Mongoose.prototype.ObjectId\n\n##### Type:\n\n- «property»\n\nThe Mongoose ObjectId [SchemaType](../schematypes). Used for declaring paths in your schema that should be [MongoDB ObjectIds](https://www.mongodb.com/docs/manual/reference/method/ObjectId/). Do not use this to create a new ObjectId instance, use `mongoose.Types.ObjectId` instead.\n\n#### [Example:](#example)\n\n``` javascript\nconst childSchema = new Schema({ parentId: mongoose.ObjectId });\n```\n\n### Mongoose.prototype.Query()\n\nThe Mongoose [Query](query#Query()) constructor.\n\n### Mongoose.prototype.STATES\n\n##### Type:\n\n- «property»\n\nExpose connection states for user-land\n\n### Mongoose.prototype.Schema()\n\nThe Mongoose [Schema](schema#Schema()) constructor\n\n#### [Example:](#example)\n\n``` javascript\nconst mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\nconst CatSchema = new Schema(..);\n```\n\n### Mongoose.prototype.SchemaType()\n\nThe Mongoose [SchemaType](schematype#SchemaType()) constructor\n\n### Mongoose.prototype.SchemaTypeOptions()\n\nThe constructor used for schematype options\n\n### Mongoose.prototype.SchemaTypes\n\n##### Type:\n\n- «property»\n\n##### See:\n\n- [Schema.SchemaTypes](../schematypes)\n\nThe various Mongoose SchemaTypes.\n\n#### [Note:](#note)\n\n*Alias of mongoose.Schema.Types for backwards compatibility.*\n\n### Mongoose.prototype.Types\n\n##### Type:\n\n- «property»\n\nThe various Mongoose Types.\n\n#### [Example:](#example)\n\n``` javascript\nconst mongoose = require('mongoose');\nconst array = mongoose.Types.Array;\n```\n\n#### [Types:](#types)\n\n- [Array](../schematypes#arrays)\n- [Buffer](../schematypes#buffers)\n- [Embedded](../schematypes#schemas)\n- [DocumentArray](documentarraypath)\n- [Decimal128](#Mongoose.prototype.Decimal128)\n- [ObjectId](../schematypes#objectids)\n- [Map](../schematypes#maps)\n- [Subdocument](../schematypes#schemas)\n\nUsing this exposed access to the `ObjectId` type, we can construct ids on demand.\n\n``` javascript\nconst ObjectId = mongoose.Types.ObjectId;\nconst id1 = new ObjectId;\n```\n\n### Mongoose.prototype.VirtualType()\n\nThe Mongoose [VirtualType](virtualtype#VirtualType()) constructor\n\n### Mongoose.prototype.connect()\n\n##### Parameters:\n\n- `uri` «String» mongodb URI to connect to\n- `[options]` «Object» passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n\n- `[options.bufferCommands=true]` «Boolean» Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n\n&nbsp;\n\n- `[options.bufferTimeoutMS=10000]` «Number» Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n\n&nbsp;\n\n- `[options.dbName]` «String» The name of the database we want to use. If not provided, use database name from connection string.\n\n&nbsp;\n\n- `[options.user]` «String» username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n\n&nbsp;\n\n- `[options.pass]` «String» password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n\n&nbsp;\n\n- `[options.maxPoolSize=100]` «Number» The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n\n&nbsp;\n\n- `[options.minPoolSize=0]` «Number» The minimum number of sockets the MongoDB driver will keep open for this connection.\n\n&nbsp;\n\n- `[options.serverSelectionTimeoutMS]` «Number» If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n\n&nbsp;\n\n- `[options.heartbeatFrequencyMS]` «Number» If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n\n&nbsp;\n\n- `[options.autoIndex=true]` «Boolean» Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n\n&nbsp;\n\n- `[options.promiseLibrary]` «Class» Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n\n&nbsp;\n\n- `[options.socketTimeoutMS=0]` «Number» How long the MongoDB driver will wait before killing a socket due to inactivity *after initial connection*. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n\n&nbsp;\n\n- `[options.family=0]` «Number» Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n\n&nbsp;\n\n- `[options.autoCreate=false]` «Boolean» Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n\n&nbsp;\n\n- `[callback]` «Function»\n\n##### Returns:\n\n- «Promise» resolves to `this` if connection succeeded\n\n##### See:\n\n- [Mongoose#createConnection](#Mongoose.prototype.createConnection())\n\nOpens the default mongoose connection.\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.connect('mongodb://user:pass@127.0.0.1:port/database');\n\n// replica sets\nconst uri = 'mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/mydatabase';\nmongoose.connect(uri);\n\n// with options\nmongoose.connect(uri, options);\n\n// optional callback that gets fired when initial connection completed\nconst uri = 'mongodb://nonexistent.domain:27000';\nmongoose.connect(uri, function(error) {\n  // if error is truthy, the initial connection failed.\n})\n```\n\n### Mongoose.prototype.connection\n\n##### Type:\n\n- «Connection»\n\nThe Mongoose module's default connection. Equivalent to `mongoose.connections[0]`, see [`connections`](#Mongoose.prototype.connections).\n\n#### [Example:](#example)\n\n``` javascript\nconst mongoose = require('mongoose');\nmongoose.connect(...);\nmongoose.connection.on('error', cb);\n```\n\nThis is the connection used by default for every model created using [mongoose.model](#Mongoose.prototype.model()).\n\nTo create a new connection, use [`createConnection()`](#Mongoose.prototype.createConnection()).\n\n### Mongoose.prototype.connections\n\n##### Type:\n\n- «Array»\n\nAn array containing all [connections](connection) associated with this Mongoose instance. By default, there is 1 connection. Calling [`createConnection()`](#Mongoose.prototype.createConnection()) adds a connection to this array.\n\n#### [Example:](#example)\n\n``` javascript\nconst mongoose = require('mongoose');\nmongoose.connections.length; // 1, just the default connection\nmongoose.connections[0] === mongoose.connection; // true\n\nmongoose.createConnection('mongodb://127.0.0.1:27017/test');\nmongoose.connections.length; // 2\n```\n\n### Mongoose.prototype.createConnection()\n\n##### Parameters:\n\n- `uri` «String» mongodb URI to connect to\n- `[options]` «Object» passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n\n&nbsp;\n\n- `[options.bufferCommands=true]` «Boolean» Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n\n&nbsp;\n\n- `[options.dbName]` «String» The name of the database you want to use. If not provided, Mongoose uses the database name from connection string.\n\n&nbsp;\n\n- `[options.user]` «String» username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n\n&nbsp;\n\n- `[options.pass]` «String» password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n\n&nbsp;\n\n- `[options.autoIndex=true]` «Boolean» Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n\n&nbsp;\n\n- `[options.promiseLibrary]` «Class» Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n\n&nbsp;\n\n- `[options.maxPoolSize=5]` «Number» The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n\n&nbsp;\n\n- `[options.minPoolSize=1]` «Number» The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n\n&nbsp;\n\n- `[options.socketTimeoutMS=0]` «Number» How long the MongoDB driver will wait before killing a socket due to inactivity *after initial connection*. Defaults to 0, which means Node.js will not time out the socket due to inactivity. A socket may be inactive because of either no activity or a long-running operation. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n\n&nbsp;\n\n- `[options.family=0]` «Number» Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n\n##### Returns:\n\n- «Connection» the created Connection object. Connections are not thenable, so you can't do `await mongoose.createConnection()`. To await use `mongoose.createConnection(uri).asPromise()` instead.\n\nCreates a Connection instance.\n\nEach `connection` instance maps to a single database. This method is helpful when managing multiple db connections.\n\n*Options passed take precedence over options included in connection strings.*\n\n#### [Example:](#example)\n\n``` javascript\n// with mongodb:// URI\ndb = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database');\n\n// and options\nconst opts = { db: { native_parser: true }}\ndb = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database', opts);\n\n// replica sets\ndb = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database');\n\n// and options\nconst opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}\ndb = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database', opts);\n\n// initialize now, connect later\ndb = mongoose.createConnection();\ndb.openUri('127.0.0.1', 'database', port, [opts]);\n```\n\n### Mongoose.prototype.deleteModel()\n\n##### Parameters:\n\n- `name` «String\\|RegExp» if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n\n##### Returns:\n\n- «Mongoose» this\n\nRemoves the model named `name` from the default connection, if it exists. You can use this function to clean up any models you created in your tests to prevent OverwriteModelErrors.\n\nEquivalent to `mongoose.connection.deleteModel(name)`.\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.model('User', new Schema({ name: String }));\nconsole.log(mongoose.model('User')); // Model object\nmongoose.deleteModel('User');\nconsole.log(mongoose.model('User')); // undefined\n\n// Usually useful in a Mocha `afterEach()` hook\nafterEach(function() {\n  mongoose.deleteModel(/.+/); // Delete every model\n});\n```\n\n### Mongoose.prototype.disconnect()\n\n##### Returns:\n\n- «Promise» resolves when all connections are closed, or rejects with the first error that occurred.\n\nRuns `.close()` on all connections in parallel.\n\n### Mongoose.prototype.driver\n\n~DEPRECATED~\n\n##### Type:\n\n- «property»\n\nObject with `get()` and `set()` containing the underlying driver this Mongoose instance uses to communicate with the database. A driver is a Mongoose-specific interface that defines functions like `find()`.\n\n### Mongoose.prototype.get()\n\n##### Parameters:\n\n- `key` «String»\n\nGets mongoose options\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.get('test') // returns the 'test' value\n```\n\n### Mongoose.prototype.isObjectIdOrHexString()\n\n##### Parameters:\n\n- `v` «Any»\n\nReturns true if the given value is a Mongoose ObjectId (using `instanceof`) or if the given value is a 24 character hex string, which is the most commonly used string representation of an ObjectId.\n\nThis function is similar to `isValidObjectId()`, but considerably more strict, because `isValidObjectId()` will return `true` for *any* value that Mongoose can convert to an ObjectId. That includes Mongoose documents, any string of length 12, and any number. `isObjectIdOrHexString()` returns true only for `ObjectId` instances or 24 character hex strings, and will return false for numbers, documents, and strings of length 12.\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.isObjectIdOrHexString(new mongoose.Types.ObjectId()); // true\nmongoose.isObjectIdOrHexString('62261a65d66c6be0a63c051f'); // true\n\nmongoose.isObjectIdOrHexString('0123456789ab'); // false\nmongoose.isObjectIdOrHexString(6); // false\nmongoose.isObjectIdOrHexString(new User({ name: 'test' })); // false\nmongoose.isObjectIdOrHexString({ test: 42 }); // false\n```\n\n### Mongoose.prototype.isValidObjectId()\n\n##### Parameters:\n\n- `v` «Any»\n\nReturns true if Mongoose can cast the given value to an ObjectId, or false otherwise.\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.isValidObjectId(new mongoose.Types.ObjectId()); // true\nmongoose.isValidObjectId('0123456789ab'); // true\nmongoose.isValidObjectId(6); // true\nmongoose.isValidObjectId(new User({ name: 'test' })); // true\n\nmongoose.isValidObjectId({ test: 42 }); // false\n```\n\n### Mongoose.prototype.model()\n\n##### Parameters:\n\n- `name` «String\\|Function» model name or class extending Model\n- `[schema]` «Schema» the schema to use.\n- `[collection]` «String» name (optional, inferred from model name)\n\n##### Returns:\n\n- «Model» The model associated with `name`. Mongoose will create the model if it doesn't already exist.\n\nDefines a model or retrieves it.\n\nModels defined on the `mongoose` instance are available to all connection created by the same `mongoose` instance.\n\nIf you call `mongoose.model()` with twice the same name but a different schema, you will get an `OverwriteModelError`. If you call `mongoose.model()` with the same name and same schema, you'll get the same schema back.\n\n#### [Example:](#example)\n\n``` javascript\nconst mongoose = require('mongoose');\n\n// define an Actor model with this mongoose instance\nconst schema = new Schema({ name: String });\nmongoose.model('Actor', schema);\n\n// create a new connection\nconst conn = mongoose.createConnection(..);\n\n// create Actor model\nconst Actor = conn.model('Actor', schema);\nconn.model('Actor') === Actor; // true\nconn.model('Actor', schema) === Actor; // true, same schema\nconn.model('Actor', schema, 'actors') === Actor; // true, same schema and collection name\n\n// This throws an `OverwriteModelError` because the schema is different.\nconn.model('Actor', new Schema({ name: String }));\n```\n\n*When no `collection` argument is passed, Mongoose uses the model name. If you don't like this behavior, either pass a collection name, use `mongoose.pluralize()`, or set your schemas collection name option.*\n\n#### [Example:](#example-1)\n\n``` javascript\nconst schema = new Schema({ name: String }, { collection: 'actor' });\n\n// or\n\nschema.set('collection', 'actor');\n\n// or\n\nconst collectionName = 'actor'\nconst M = mongoose.model('Actor', schema, collectionName)\n```\n\n### Mongoose.prototype.modelNames()\n\n##### Returns:\n\n- «Array»\n\nReturns an array of model names created on this instance of Mongoose.\n\n#### [Note:](#note)\n\n*Does not include names of models created using `connection.model()`.*\n\n### Mongoose.prototype.mongo\n\n##### Type:\n\n- «property»\n\nThe [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver Mongoose uses.\n\n### Mongoose.prototype.mquery\n\n##### Type:\n\n- «property»\n\nThe [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.\n\n### Mongoose.prototype.now()\n\nMongoose uses this function to get the current time when setting [timestamps](../guide#timestamps). You may stub out this function using a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.\n\n### Mongoose.prototype.overwriteMiddlewareResult()\n\n##### Parameters:\n\n- `result` «any»\n\nUse this function in `post()` middleware to replace the result\n\n#### [Example:](#example)\n\n``` javascript\nschema.post('find', function(res) {\n  // Normally you have to modify `res` in place. But with\n  // `overwriteMiddlewarResult()`, you can make `find()` return a\n  // completely different value.\n  return mongoose.overwriteMiddlewareResult(res.filter(doc => !doc.isDeleted));\n});\n```\n\n### Mongoose.prototype.plugin()\n\n##### Parameters:\n\n- `fn` «Function» plugin callback\n- `[opts]` «Object» optional options\n\n##### Returns:\n\n- «Mongoose» this\n\n##### See:\n\n- [plugins](../plugins)\n\nDeclares a global plugin executed on all Schemas.\n\nEquivalent to calling `.plugin(fn)` on each Schema you create.\n\n### Mongoose.prototype.pluralize()\n\n##### Parameters:\n\n- `[fn]` «Function\\|null» overwrites the function used to pluralize collection names\n\n##### Returns:\n\n- «Function,null» the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.\n\nGetter/setter around function for pluralizing collection names.\n\n### Mongoose.prototype.sanitizeFilter()\n\n##### Parameters:\n\n- `filter` «Object»\n\nSanitizes query filters against [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html) by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n\n``` javascript\nconst obj = { username: 'val', pwd: { $ne: null } };\nsanitizeFilter(obj);\nobj; // { username: 'val', pwd: { $eq: { $ne: null } } });\n```\n\n### Mongoose.prototype.set()\n\n##### Parameters:\n\n- `key` «String\\|Object» The name of the option or a object of multiple key-value pairs\n- `value` «String\\|Function\\|Boolean» The value of the option, unused if \"key\" is a object\n\nSets mongoose options\n\n`key` can be used a object to set multiple options at once. If a error gets thrown for one option, other options will still be evaluated.\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.set('test', value) // sets the 'test' option to `value`\n\nmongoose.set('debug', true) // enable logging collection methods + arguments to the console/file\n\nmongoose.set('debug', function(collectionName, methodName, ...methodArgs) {}); // use custom function to log collection methods + arguments\n\nmongoose.set({ debug: true, autoIndex: false }); // set multiple options at once\n```\n\nCurrently supported options are:\n\n- `allowDiskUse`: Set to `true` to set `allowDiskUse` to true to all aggregation operations by default.\n- `applyPluginsToChildSchemas`: `true` by default. Set to false to skip applying global plugins to child schemas\n- `applyPluginsToDiscriminators`: `false` by default. Set to true to apply global plugins to discriminator schemas. This typically isn't necessary because plugins are applied to the base schema and discriminators copy all middleware, methods, statics, and properties from the base schema.\n- `autoCreate`: Set to `true` to make Mongoose call [`Model.createCollection()`](model#Model.createCollection()) automatically when you create a model with `mongoose.model()` or `conn.model()`. This is useful for testing transactions, change streams, and other features that require the collection to exist.\n- `autoIndex`: `true` by default. Set to false to disable automatic index creation for all models associated with this Mongoose instance.\n- `bufferCommands`: enable/disable mongoose's buffering mechanism for all connections and models\n- `bufferTimeoutMS`: If bufferCommands is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).\n- `cloneSchemas`: `false` by default. Set to `true` to `clone()` all schemas before compiling into a model.\n- `debug`: If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arguments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n- `id`: If `true`, adds a `id` virtual to all schemas unless overwritten on a per-schema basis.\n- `timestamps.createdAt.immutable`: `true` by default. If `false`, it will change the `createdAt` field to be [`immutable: false`](schematype#SchemaType.prototype.immutable) which means you can update the `createdAt`\n- `maxTimeMS`: If set, attaches [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/) to every query\n- `objectIdGetter`: `true` by default. Mongoose adds a getter to MongoDB ObjectId's called `_id` that returns `this` for convenience with populate. Set this to false to remove the getter.\n- `overwriteModels`: Set to `true` to default to overwriting models with the same name when calling `mongoose.model()`, as opposed to throwing an `OverwriteModelError`.\n- `returnOriginal`: If `false`, changes the default `returnOriginal` option to `findOneAndUpdate()`, `findByIdAndUpdate`, and `findOneAndReplace()` to false. This is equivalent to setting the `new` option to `true` for `findOneAndX()` calls by default. Read our [`findOneAndUpdate()` tutorial](../tutorials/findoneandupdate) for more information.\n- `runValidators`: `false` by default. Set to true to enable [update validators](../validation#update-validators) for all validators by default.\n- `sanitizeFilter`: `false` by default. Set to true to enable the [sanitization of the query filters](#Mongoose.prototype.sanitizeFilter()) against query selector injection attacks by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n- `selectPopulatedPaths`: `true` by default. Set to false to opt out of Mongoose adding all fields that you `populate()` to your `select()`. The schema-level option `selectPopulatedPaths` overwrites this one.\n- `strict`: `true` by default, may be `false`, `true`, or `'throw'`. Sets the default strict mode for schemas.\n- `strictQuery`: `false` by default. May be `false`, `true`, or `'throw'`. Sets the default [strictQuery](../guide#strictQuery) mode for schemas.\n- `toJSON`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toJSON()`](document#Document.prototype.toJSON()), for determining how Mongoose documents get serialized by `JSON.stringify()`\n- `toObject`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toObject()`](document#Document.prototype.toObject())\n\n### Mongoose.prototype.setDriver()\n\nOverwrites the current driver used by this Mongoose instance. A driver is a Mongoose-specific interface that defines functions like `find()`.\n\n### Mongoose.prototype.skipMiddlewareFunction()\n\n##### Parameters:\n\n- `result` «any»\n\nUse this function in `pre()` middleware to skip calling the wrapped function.\n\n#### [Example:](#example)\n\n``` javascript\nschema.pre('save', function() {\n  // Will skip executing `save()`, but will execute post hooks as if\n  // `save()` had executed with the result `{ matchedCount: 0 }`\n  return mongoose.skipMiddlewareFunction({ matchedCount: 0 });\n});\n```\n\n### Mongoose.prototype.startSession()\n\n##### Parameters:\n\n- `[options]` «Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n\n&nbsp;\n\n- `[options.causalConsistency=true]` «Boolean» set to false to disable causal consistency\n\n&nbsp;\n\n- `[callback]` «Function»\n\n##### Returns:\n\n- «Promise\\<ClientSession\\>» promise that resolves to a MongoDB driver `ClientSession`\n\n*Requires MongoDB \\>= 3.6.0.* Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions) for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/), and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n\nCalling `mongoose.startSession()` is equivalent to calling `mongoose.connection.startSession()`. Sessions are scoped to a connection, so calling `mongoose.startSession()` starts a session on the [default mongoose connection](#Mongoose.prototype.connection).\n\n### Mongoose.prototype.syncIndexes()\n\n##### Parameters:\n\n- `options` «Object»\n- `options.continueOnError` «Boolean» `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n\n##### Returns:\n\n- «Promise» Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n\nSyncs all the indexes for the models registered with this connection.\n\n### Mongoose.prototype.trusted()\n\n##### Parameters:\n\n- `obj` «Object»\n\nTells `sanitizeFilter()` to skip the given object when filtering out potential [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html). Use this method when you have a known query selector that you want to use.\n\n``` javascript\nconst obj = { username: 'val', pwd: trusted({ $type: 'string', $eq: 'my secret' }) };\nsanitizeFilter(obj);\n\n// Note that `sanitizeFilter()` did not add `$eq` around `$type`.\nobj; // { username: 'val', pwd: { $type: 'string', $eq: 'my secret' } });\n```\n\n### Mongoose.prototype.version\n\n##### Type:\n\n- «property»\n\nThe Mongoose version\n\n#### [Example:](#example)\n\n``` javascript\nconsole.log(mongoose.version); // '5.x.x'\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/mongoose.html](https://mongoosejs.com/docs/api/mongoose.html)"
- name: Mongoose Virtuals
  id: tutorials/virtuals
  summary: In Mongoose, a virtual is a property that is not stored in MongoDB
  description: "# Mongoose Virtuals\n\nIn Mongoose, a virtual is a property that is **not** stored in MongoDB. Virtuals are typically used for computed properties on documents.\n\n- [Your First Virtual](#your-first-virtual)\n- [Virtual Setters](#virtual-setters)\n- [Virtuals in JSON](#virtuals-in-json)\n- [Virtuals with Lean](#virtuals-with-lean)\n- [Limitations](#limitations)\n- [Populate](#populate)\n- [Virtuals via schema options](#virtuals-via-schema-options)\n- [Further Reading](#further-reading)\n\n## Your First Virtual\n\nSuppose you have a `User` model. Every user has an `email`, but you also want the email's domain. For example, the domain portion of '<test@gmail.com>' is 'gmail.com'.\n\nBelow is one way to implement the `domain` property using a virtual. You define virtuals on a schema using the [`Schema#virtual()` function](../api/schema#schema_Schema-virtual).\n\n``` javascript\nconst userSchema = mongoose.Schema({\n  email: String\n});\n// Create a virtual property `domain` that's computed from `email`.\nuserSchema.virtual('domain').get(function() {\n  return this.email.slice(this.email.indexOf('@') + 1);\n});\nconst User = mongoose.model('User', userSchema);\n\nconst doc = await User.create({ email: 'test@gmail.com' });\n// `domain` is now a property on User documents.\ndoc.domain; // 'gmail.com'\n```\n\nThe `Schema#virtual()` function returns a [`VirtualType` object](../api/virtualtype). Unlike normal document properties, virtuals do not have any underlying value and Mongoose does not do any type coercion on virtuals. However, virtuals do have [getters and setters](getters-setters), which make them ideal for computed properties, like the `domain` example above.\n\n## Virtual Setters\n\nYou can also use virtuals to set multiple properties at once as an alternative to [custom setters on normal properties](getters-setters#setters). For example, suppose you have two string properties: `firstName` and `lastName`. You can create a virtual property `fullName` that lets you set both of these properties at once. The key detail is that, in virtual getters and setters, `this` refers to the document the virtual is attached to.\n\n``` javascript\nconst userSchema = mongoose.Schema({\n  firstName: String,\n  lastName: String\n});\n// Create a virtual property `fullName` with a getter and setter.\nuserSchema.virtual('fullName').\n  get(function() { return `${this.firstName} ${this.lastName}`; }).\n  set(function(v) {\n    // `v` is the value being set, so use the value to set\n    // `firstName` and `lastName`.\n    const firstName = v.substring(0, v.indexOf(' '));\n    const lastName = v.substring(v.indexOf(' ') + 1);\n    this.set({ firstName, lastName });\n  });\nconst User = mongoose.model('User', userSchema);\n\nconst doc = new User();\n// Vanilla JavaScript assignment triggers the setter\ndoc.fullName = 'Jean-Luc Picard';\n\ndoc.fullName; // 'Jean-Luc Picard'\ndoc.firstName; // 'Jean-Luc'\ndoc.lastName; // 'Picard'\n```\n\n## Virtuals in JSON\n\nBy default, Mongoose does not include virtuals when you convert a document to JSON. For example, if you pass a document to [Express' `res.json()` function](http://expressjs.com/en/4x/api.html#res.json), virtuals will **not** be included by default.\n\nTo include virtuals in `res.json()`, you need to set the [`toJSON` schema option](../guide#toJSON) to `{ virtuals: true }`.\n\n``` javascript\nconst opts = { toJSON: { virtuals: true } };\nconst userSchema = mongoose.Schema({\n  _id: Number,\n  email: String\n}, opts);\n// Create a virtual property `domain` that's computed from `email`.\nuserSchema.virtual('domain').get(function() {\n  return this.email.slice(this.email.indexOf('@') + 1);\n});\nconst User = mongoose.model('User', userSchema);\n\nconst doc = new User({ _id: 1, email: 'test@gmail.com' });\n\ndoc.toJSON().domain; // 'gmail.com'\n// {\"_id\":1,\"email\":\"test@gmail.com\",\"domain\":\"gmail.com\",\"id\":\"1\"}\nJSON.stringify(doc);\n\n// To skip applying virtuals, pass `virtuals: false` to `toJSON()`\ndoc.toJSON({ virtuals: false }).domain; // undefined\n```\n\n## Virtuals in `console.log()`\n\nBy default, Mongoose does **not** include virtuals in `console.log()` output. To include virtuals in `console.log()`, you need to set the [`toObject` schema option](../guide#toObject) to `{ virtuals: true }`, or use `toObject()` before printing the object.\n\n``` javascript\nconsole.log(doc.toObject({ virtuals: true }));\n```\n\n## Virtuals with Lean\n\nVirtuals are properties on Mongoose documents. If you use the [lean option](lean), that means your queries return POJOs rather than full Mongoose documents. That means no virtuals if you use [`lean()`](../api/query#query_Query-lean).\n\n``` javascript\nconst fullDoc = await User.findOne();\nfullDoc.domain; // 'gmail.com'\n\nconst leanDoc = await User.findOne().lean();\nleanDoc.domain; // undefined\n```\n\nIf you use `lean()` for performance, but still need virtuals, Mongoose has an [officially supported `mongoose-lean-virtuals` plugin](https://plugins.mongoosejs.io/plugins/lean-virtuals) that decorates lean documents with virtuals.\n\n## Limitations\n\nMongoose virtuals are **not** stored in MongoDB, which means you can't query based on Mongoose virtuals.\n\n``` javascript\n// Will **not** find any results, because `domain` is not stored in\n// MongoDB.\nconst doc = await User.findOne({ domain: 'gmail.com' }, null, { strictQuery: false });\ndoc; // undefined\n```\n\nIf you want to query by a computed property, you should set the property using a [custom setter](getters-setters) or [pre save middleware](../middleware).\n\n## Populate\n\nMongoose also supports [populating virtuals](../populate). A populated virtual contains documents from another collection. To define a populated virtual, you need to specify:\n\n- The `ref` option, which tells Mongoose which model to populate documents from.\n- The `localField` and `foreignField` options. Mongoose will populate documents from the model in `ref` whose `foreignField` matches this document's `localField`.\n\n``` javascript\nconst userSchema = mongoose.Schema({ _id: Number, email: String });\nconst blogPostSchema = mongoose.Schema({\n  title: String,\n  authorId: Number\n});\n// When you `populate()` the `author` virtual, Mongoose will find the\n// first document in the User model whose `_id` matches this document's\n// `authorId` property.\nblogPostSchema.virtual('author', {\n  ref: 'User',\n  localField: 'authorId',\n  foreignField: '_id',\n  justOne: true\n});\nconst User = mongoose.model('User', userSchema);\nconst BlogPost = mongoose.model('BlogPost', blogPostSchema);\nawait BlogPost.create({ title: 'Introduction to Mongoose', authorId: 1 });\nawait User.create({ _id: 1, email: 'test@gmail.com' });\n\nconst doc = await BlogPost.findOne().populate('author');\ndoc.author.email; // 'test@gmail.com'\n```\n\n## Virtuals via schema options\n\nVirtuals can also be defined in the schema-options directly without having to use [`.virtual`](../api/schema#Schema.prototype.virtual):\n\n``` javascript\nconst userSchema = mongoose.Schema({\n  firstName: String,\n  lastName: String\n}, {\n  virtuals: {\n    // Create a virtual property `fullName` with a getter and setter\n    fullName: {\n      get() { return `${this.firstName} ${this.lastName}`; },\n      set(v) {\n        // `v` is the value being set, so use the value to set\n        // `firstName` and `lastName`.\n        const firstName = v.substring(0, v.indexOf(' '));\n        const lastName = v.substring(v.indexOf(' ') + 1);\n        this.set({ firstName, lastName });\n      }\n    }\n  }\n});\nconst User = mongoose.model('User', userSchema);\n\nconst doc = new User();\n// Vanilla JavaScript assignment triggers the setter\ndoc.fullName = 'Jean-Luc Picard';\n\ndoc.fullName; // 'Jean-Luc Picard'\ndoc.firstName; // 'Jean-Luc'\ndoc.lastName; // 'Picard'\n```\n\nThe same also goes for virtual options, like virtual populate:\n\n``` javascript\nconst userSchema = mongoose.Schema({ _id: Number, email: String });\nconst blogPostSchema = mongoose.Schema({\n  title: String,\n  authorId: Number\n}, {\n  virtuals: {\n    // When you `populate()` the `author` virtual, Mongoose will find the\n    // first document in the User model whose `_id` matches this document's\n    // `authorId` property.\n    author: {\n      options: {\n        ref: 'User',\n        localField: 'authorId',\n        foreignField: '_id',\n        justOne: true\n      }\n    }\n  }\n});\nconst User = mongoose.model('User', userSchema);\nconst BlogPost = mongoose.model('BlogPost', blogPostSchema);\nawait BlogPost.create({ title: 'Introduction to Mongoose', authorId: 1 });\nawait User.create({ _id: 1, email: 'test@gmail.com' });\n\nconst doc = await BlogPost.findOne().populate('author');\ndoc.author.email; // 'test@gmail.com'\n```\n\n## Further Reading\n\n- [Virtuals in Mongoose Schemas](../guide#virtuals)\n- [Populate Virtuals](../populate#populate-virtuals)\n- [Mongoose Lean Virtuals plugin](https://plugins.mongoosejs.io/plugins/lean-virtuals)\n- [Getting Started With Mongoose Virtuals](https://masteringjs.io/tutorials/mongoose/virtuals)\n- [Understanding Virtuals in Mongoose](https://futurestud.io/tutorials/understanding-virtuals-in-mongoose)\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/tutorials/virtuals.html](https://mongoosejs.com/docs/tutorials/virtuals.html)"
- name: Mongoose()
  id: api/mongoose#Mongoose()
  summary: Mongoose constructor
  belongs_to: Mongoose
  description: |-
    ### Mongoose()

    ##### Parameters:

    - `options`«Object» see [`Mongoose#set()` docs](#Mongoose.prototype.set())

    Mongoose constructor.

    The exports object of the `mongoose` module is an instance of this class. Most apps will only use this one instance.

    #### [Example:](#example)

    ``` javascript
    const mongoose = require('mongoose');
    mongoose instanceof mongoose.Mongoose; // true

    // Create a new Mongoose instance with its own `connect()`, `set()`, `model()`, etc.
    const m = new mongoose.Mongoose();
    ```
- name: Mongoose.prototype.Aggregate()
  id: api/mongoose#Mongoose.prototype.Aggregate()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Aggregate()

    The Mongoose Aggregate constructor
- name: Mongoose.prototype.CastError()
  id: api/mongoose#Mongoose.prototype.CastError()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.CastError()

    ##### Parameters:

    - `type`«String» The name of the type
    - `value`«Any» The value that failed to cast
    - `path`«String» The path `a.b.c` in the doc where this cast error occurred
    - `[reason]`«Error» The original error that was thrown

    The Mongoose CastError constructor
- name: Mongoose.prototype.Collection()
  id: api/mongoose#Mongoose.prototype.Collection()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Collection()

    The Mongoose Collection constructor
- name: Mongoose.prototype.connect()
  id: api/mongoose#Mongoose.prototype.connect()
  summary: '[options]«Object» passed down to the MongoDB driver''s connect() function, except for 4 mongoose-specific options explained below'
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.connect()

    ##### Parameters:

    - `uri`«String» mongodb URI to connect to
    - `[options]`«Object» passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.

    - `[options.bufferCommands=true]`«Boolean» Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.

    &nbsp;

    - `[options.bufferTimeoutMS=10000]`«Number» Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.

    &nbsp;

    - `[options.dbName]`«String» The name of the database we want to use. If not provided, use database name from connection string.

    &nbsp;

    - `[options.user]`«String» username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.

    &nbsp;

    - `[options.pass]`«String» password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.

    &nbsp;

    - `[options.maxPoolSize=100]`«Number» The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).

    &nbsp;

    - `[options.minPoolSize=0]`«Number» The minimum number of sockets the MongoDB driver will keep open for this connection.

    &nbsp;

    - `[options.serverSelectionTimeoutMS]`«Number» If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).

    &nbsp;

    - `[options.heartbeatFrequencyMS]`«Number» If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.

    &nbsp;

    - `[options.autoIndex=true]`«Boolean» Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.

    &nbsp;

    - `[options.promiseLibrary]`«Class» Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).

    &nbsp;

    - `[options.socketTimeoutMS=0]`«Number» How long the MongoDB driver will wait before killing a socket due to inactivity *after initial connection*. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.

    &nbsp;

    - `[options.family=0]`«Number» Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.

    &nbsp;

    - `[options.autoCreate=false]`«Boolean» Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.

    &nbsp;

    - `[callback]` «Function»

    ##### Returns:

    - «Promise» resolves to `this` if connection succeeded

    ##### See:

    -  [Mongoose#createConnection](#Mongoose.prototype.createConnection())

    Opens the default mongoose connection.

    #### [Example:](#example)

    ``` javascript
    mongoose.connect('mongodb://user:pass@127.0.0.1:port/database');

    // replica sets
    const uri = 'mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/mydatabase';
    mongoose.connect(uri);

    // with options
    mongoose.connect(uri, options);

    // optional callback that gets fired when initial connection completed
    const uri = 'mongodb://nonexistent.domain:27000';
    mongoose.connect(uri, function(error) {
      // if error is truthy, the initial connection failed.
    })
    ```
- name: Mongoose.prototype.connection
  id: api/mongoose#Mongoose.prototype.connection
  summary: The Mongoose module's default connection
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.connection

    ##### Type:

    - «Connection»

    The Mongoose module's default connection. Equivalent to `mongoose.connections[0]`, see [`connections`](#Mongoose.prototype.connections).

    #### [Example:](#example)

    ``` javascript
    const mongoose = require('mongoose');
    mongoose.connect(...);
    mongoose.connection.on('error', cb);
    ```

    This is the connection used by default for every model created using [mongoose.model](#Mongoose.prototype.model()).

    To create a new connection, use [`createConnection()`](#Mongoose.prototype.createConnection()).
- name: Mongoose.prototype.Connection()
  id: api/mongoose#Mongoose.prototype.Connection()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Connection()

    The Mongoose [Connection](connection#Connection()) constructor
- name: Mongoose.prototype.connections
  id: api/mongoose#Mongoose.prototype.connections
  summary: An array containing all connections associated with this Mongoose instance
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.connections

    ##### Type:

    - «Array»

    An array containing all [connections](connection) associated with this Mongoose instance. By default, there is 1 connection. Calling [`createConnection()`](#Mongoose.prototype.createConnection()) adds a connection to this array.

    #### [Example:](#example)

    ``` javascript
    const mongoose = require('mongoose');
    mongoose.connections.length; // 1, just the default connection
    mongoose.connections[0] === mongoose.connection; // true

    mongoose.createConnection('mongodb://127.0.0.1:27017/test');
    mongoose.connections.length; // 2
    ```
- name: Mongoose.prototype.ConnectionStates
  id: api/mongoose#Mongoose.prototype.ConnectionStates
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.ConnectionStates

    ##### Type:

    - «property»

    Expose connection states for user-land
- name: Mongoose.prototype.createConnection()
  id: api/mongoose#Mongoose.prototype.createConnection()
  summary: Creates a Connection instance
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.createConnection()

    ##### Parameters:

    - `uri`«String» mongodb URI to connect to
    - `[options]`«Object» passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.

    &nbsp;

    - `[options.bufferCommands=true]`«Boolean» Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.

    &nbsp;

    - `[options.dbName]`«String» The name of the database you want to use. If not provided, Mongoose uses the database name from connection string.

    &nbsp;

    - `[options.user]`«String» username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.

    &nbsp;

    - `[options.pass]`«String» password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.

    &nbsp;

    - `[options.autoIndex=true]`«Boolean» Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.

    &nbsp;

    - `[options.promiseLibrary]`«Class» Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).

    &nbsp;

    - `[options.maxPoolSize=5]`«Number» The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).

    &nbsp;

    - `[options.minPoolSize=1]`«Number» The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).

    &nbsp;

    - `[options.socketTimeoutMS=0]`«Number» How long the MongoDB driver will wait before killing a socket due to inactivity *after initial connection*. Defaults to 0, which means Node.js will not time out the socket due to inactivity. A socket may be inactive because of either no activity or a long-running operation. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.

    &nbsp;

    - `[options.family=0]`«Number» Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.

    ##### Returns:

    - «Connection» the created Connection object. Connections are not thenable, so you can't do `await mongoose.createConnection()`. To await use `mongoose.createConnection(uri).asPromise()` instead.

    Creates a Connection instance.

    Each `connection` instance maps to a single database. This method is helpful when managing multiple db connections.

    *Options passed take precedence over options included in connection strings.*

    #### [Example:](#example)

    ``` javascript
    // with mongodb:// URI
    db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database');

    // and options
    const opts = { db: { native_parser: true }}
    db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database', opts);

    // replica sets
    db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database');

    // and options
    const opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}
    db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database', opts);

    // initialize now, connect later
    db = mongoose.createConnection();
    db.openUri('127.0.0.1', 'database', port, [opts]);
    ```
- name: Mongoose.prototype.Date
  id: api/mongoose#Mongoose.prototype.Date
  summary: The Mongoose Date SchemaType
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Date

    ##### Type:

    - «property»

    The Mongoose Date [SchemaType](../schematypes).

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ test: Date });
    schema.path('test') instanceof mongoose.Date; // true
    ```
- name: Mongoose.prototype.Decimal128
  id: api/mongoose#Mongoose.prototype.Decimal128
  summary: The Mongoose Decimal128 SchemaType
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Decimal128

    ##### Type:

    - «property»

    The Mongoose Decimal128 [SchemaType](../schematypes). Used for declaring paths in your schema that should be [128-bit decimal floating points](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html). Do not use this to create a new Decimal128 instance, use `mongoose.Types.Decimal128` instead.

    #### [Example:](#example)

    ``` javascript
    const vehicleSchema = new Schema({ fuelLevel: mongoose.Decimal128 });
    ```
- name: Mongoose.prototype.deleteModel()
  id: api/mongoose#Mongoose.prototype.deleteModel()
  summary: Removes the model named name from the default connection, if it exists
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.deleteModel()

    ##### Parameters:

    - `name`«String\|RegExp» if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.

    ##### Returns:

    - «Mongoose» this

    Removes the model named `name` from the default connection, if it exists. You can use this function to clean up any models you created in your tests to prevent OverwriteModelErrors.

    Equivalent to `mongoose.connection.deleteModel(name)`.

    #### [Example:](#example)

    ``` javascript
    mongoose.model('User', new Schema({ name: String }));
    console.log(mongoose.model('User')); // Model object
    mongoose.deleteModel('User');
    console.log(mongoose.model('User')); // undefined

    // Usually useful in a Mocha `afterEach()` hook
    afterEach(function() {
      mongoose.deleteModel(/.+/); // Delete every model
    });
    ```
- name: Mongoose.prototype.disconnect()
  id: api/mongoose#Mongoose.prototype.disconnect()
  summary: Runs .close() on all connections in parallel
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.disconnect()

    ##### Returns:

    - «Promise» resolves when all connections are closed, or rejects with the first error that occurred.

    Runs `.close()` on all connections in parallel.
- name: Mongoose.prototype.Document()
  id: api/mongoose#Mongoose.prototype.Document()
  summary: The Mongoose Document constructor
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Document()

    The Mongoose [Document](document#Document()) constructor.
- name: Mongoose.prototype.DocumentProvider()
  id: api/mongoose#Mongoose.prototype.DocumentProvider()
  summary: The Mongoose DocumentProvider constructor
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.DocumentProvider()

    The Mongoose DocumentProvider constructor. Mongoose users should not have to use this directly
- name: Mongoose.prototype.driver
  id: api/mongoose#Mongoose.prototype.driver
  summary: Object with get() and set() containing the underlying driver this Mongoose instance uses to communicate with the database
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.driver

    ~DEPRECATED~

    ##### Type:

    - «property»

    Object with `get()` and `set()` containing the underlying driver this Mongoose instance uses to communicate with the database. A driver is a Mongoose-specific interface that defines functions like `find()`.
- name: Mongoose.prototype.Error()
  id: api/mongoose#Mongoose.prototype.Error()
  summary: The MongooseError constructor
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Error()

    The [MongooseError](error#Error()) constructor.
- name: Mongoose.prototype.get()
  id: api/mongoose#Mongoose.prototype.get()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.get()

    ##### Parameters:

    - `key` «String»

    Gets mongoose options

    #### [Example:](#example)

    ``` javascript
    mongoose.get('test') // returns the 'test' value
    ```
- name: Mongoose.prototype.isObjectIdOrHexString()
  id: api/mongoose#Mongoose.prototype.isObjectIdOrHexString()
  summary: Returns true if the given value is a Mongoose ObjectId (using instanceof) or if the given value is a 24 character hex string, which is the most commonly used string representation of an ObjectId
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.isObjectIdOrHexString()

    ##### Parameters:

    - `v` «Any»

    Returns true if the given value is a Mongoose ObjectId (using `instanceof`) or if the given value is a 24 character hex string, which is the most commonly used string representation of an ObjectId.

    This function is similar to `isValidObjectId()`, but considerably more strict, because `isValidObjectId()` will return `true` for *any* value that Mongoose can convert to an ObjectId. That includes Mongoose documents, any string of length 12, and any number. `isObjectIdOrHexString()` returns true only for `ObjectId` instances or 24 character hex strings, and will return false for numbers, documents, and strings of length 12.

    #### [Example:](#example)

    ``` javascript
    mongoose.isObjectIdOrHexString(new mongoose.Types.ObjectId()); // true
    mongoose.isObjectIdOrHexString('62261a65d66c6be0a63c051f'); // true

    mongoose.isObjectIdOrHexString('0123456789ab'); // false
    mongoose.isObjectIdOrHexString(6); // false
    mongoose.isObjectIdOrHexString(new User({ name: 'test' })); // false
    mongoose.isObjectIdOrHexString({ test: 42 }); // false
    ```
- name: Mongoose.prototype.isValidObjectId()
  id: api/mongoose#Mongoose.prototype.isValidObjectId()
  summary: Returns true if Mongoose can cast the given value to an ObjectId, or false otherwise
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.isValidObjectId()

    ##### Parameters:

    - `v` «Any»

    Returns true if Mongoose can cast the given value to an ObjectId, or false otherwise.

    #### [Example:](#example)

    ``` javascript
    mongoose.isValidObjectId(new mongoose.Types.ObjectId()); // true
    mongoose.isValidObjectId('0123456789ab'); // true
    mongoose.isValidObjectId(6); // true
    mongoose.isValidObjectId(new User({ name: 'test' })); // true

    mongoose.isValidObjectId({ test: 42 }); // false
    ```
- name: Mongoose.prototype.Mixed
  id: api/mongoose#Mongoose.prototype.Mixed
  summary: The Mongoose Mixed SchemaType
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Mixed

    ##### Type:

    - «property»

    The Mongoose Mixed [SchemaType](../schematypes). Used for declaring paths in your schema that Mongoose's change tracking, casting, and validation should ignore.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ arbitrary: mongoose.Mixed });
    ```
- name: Mongoose.prototype.Model()
  id: api/mongoose#Mongoose.prototype.Model()
  summary: The Mongoose Model constructor
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Model()

    The Mongoose [Model](model#Model()) constructor.
- name: Mongoose.prototype.model()
  id: api/mongoose#Mongoose.prototype.model()
  summary: The Mongoose Model constructor
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Model()

    The Mongoose [Model](model#Model()) constructor.
- name: Mongoose.prototype.modelNames()
  id: api/mongoose#Mongoose.prototype.modelNames()
  summary: Returns an array of model names created on this instance of Mongoose
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.modelNames()

    ##### Returns:

    - «Array»

    Returns an array of model names created on this instance of Mongoose.

    #### [Note:](#note)

    *Does not include names of models created using `connection.model()`.*
- name: Mongoose.prototype.mongo
  id: api/mongoose#Mongoose.prototype.mongo
  summary: The node-mongodb-native driver Mongoose uses
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.mongo

    ##### Type:

    - «property»

    The [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver Mongoose uses.
- name: Mongoose.prototype.Mongoose()
  id: api/mongoose#Mongoose.prototype.Mongoose()
  summary: The exports of the mongoose module is an instance of this class
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Mongoose()

    The Mongoose constructor

    The exports of the mongoose module is an instance of this class.

    #### [Example:](#example)

    ``` javascript
    const mongoose = require('mongoose');
    const mongoose2 = new mongoose.Mongoose();
    ```
- name: Mongoose.prototype.mquery
  id: api/mongoose#Mongoose.prototype.mquery
  summary: The mquery query builder Mongoose uses
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.mquery

    ##### Type:

    - «property»

    The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.
- name: Mongoose.prototype.now()
  id: api/mongoose#Mongoose.prototype.now()
  summary: Mongoose uses this function to get the current time when setting timestamps
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.now()

    Mongoose uses this function to get the current time when setting [timestamps](../guide#timestamps). You may stub out this function using a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.
- name: Mongoose.prototype.Number
  id: api/mongoose#Mongoose.prototype.Number
  summary: The Mongoose Number SchemaType
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Number

    ##### Type:

    - «property»

    The Mongoose Number [SchemaType](../schematypes). Used for declaring paths in your schema that Mongoose should cast to numbers.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ num: mongoose.Number });
    // Equivalent to:
    const schema = new Schema({ num: 'number' });
    ```
- name: Mongoose.prototype.ObjectId
  id: api/mongoose#Mongoose.prototype.ObjectId
  summary: The Mongoose ObjectId SchemaType
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.ObjectId

    ##### Type:

    - «property»

    The Mongoose ObjectId [SchemaType](../schematypes). Used for declaring paths in your schema that should be [MongoDB ObjectIds](https://www.mongodb.com/docs/manual/reference/method/ObjectId/). Do not use this to create a new ObjectId instance, use `mongoose.Types.ObjectId` instead.

    #### [Example:](#example)

    ``` javascript
    const childSchema = new Schema({ parentId: mongoose.ObjectId });
    ```
- name: Mongoose.prototype.overwriteMiddlewareResult()
  id: api/mongoose#Mongoose.prototype.overwriteMiddlewareResult()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.overwriteMiddlewareResult()

    ##### Parameters:

    - `result` «any»

    Use this function in `post()` middleware to replace the result

    #### [Example:](#example)

    ``` javascript
    schema.post('find', function(res) {
      // Normally you have to modify `res` in place. But with
      // `overwriteMiddlewarResult()`, you can make `find()` return a
      // completely different value.
      return mongoose.overwriteMiddlewareResult(res.filter(doc => !doc.isDeleted));
    });
    ```
- name: Mongoose.prototype.plugin()
  id: api/mongoose#Mongoose.prototype.plugin()
  summary: Declares a global plugin executed on all Schemas
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.plugin()

    ##### Parameters:

    - `fn`«Function» plugin callback
    - `[opts]`«Object» optional options

    ##### Returns:

    - «Mongoose» this

    ##### See:

    -  [plugins](../plugins)

    Declares a global plugin executed on all Schemas.

    Equivalent to calling `.plugin(fn)` on each Schema you create.
- name: Mongoose.prototype.pluralize()
  id: api/mongoose#Mongoose.prototype.pluralize()
  summary: Getter/setter around function for pluralizing collection names
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.pluralize()

    ##### Parameters:

    - `[fn]`«Function\|null» overwrites the function used to pluralize collection names

    ##### Returns:

    - «Function,null» the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.

    Getter/setter around function for pluralizing collection names.
- name: Mongoose.prototype.Query()
  id: api/mongoose#Mongoose.prototype.Query()
  summary: The Mongoose Query constructor
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Query()

    The Mongoose [Query](query#Query()) constructor.
- name: Mongoose.prototype.sanitizeFilter()
  id: api/mongoose#Mongoose.prototype.sanitizeFilter()
  summary: Sanitizes query filters against query selector injection attacks by wrapping any nested objects that have a property whose name starts with $ in a $eq
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.sanitizeFilter()

    ##### Parameters:

    - `filter` «Object»

    Sanitizes query filters against [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html) by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.

    ``` javascript
    const obj = { username: 'val', pwd: { $ne: null } };
    sanitizeFilter(obj);
    obj; // { username: 'val', pwd: { $eq: { $ne: null } } });
    ```
- name: Mongoose.prototype.Schema()
  id: api/mongoose#Mongoose.prototype.Schema()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Schema()

    The Mongoose [Schema](schema#Schema()) constructor

    #### [Example:](#example)

    ``` javascript
    const mongoose = require('mongoose');
    const Schema = mongoose.Schema;
    const CatSchema = new Schema(..);
    ```
- name: Mongoose.prototype.SchemaType()
  id: api/mongoose#Mongoose.prototype.SchemaType()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.SchemaType()

    The Mongoose [SchemaType](schematype#SchemaType()) constructor
- name: Mongoose.prototype.SchemaTypeOptions()
  id: api/mongoose#Mongoose.prototype.SchemaTypeOptions()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.SchemaTypeOptions()

    The constructor used for schematype options
- name: Mongoose.prototype.SchemaTypes
  id: api/mongoose#Mongoose.prototype.SchemaTypes
  summary: The various Mongoose SchemaTypes
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.SchemaTypes

    ##### Type:

    - «property»

    ##### See:

    -  [Schema.SchemaTypes](../schematypes)

    The various Mongoose SchemaTypes.

    #### [Note:](#note)

    *Alias of mongoose.Schema.Types for backwards compatibility.*
- name: Mongoose.prototype.set()
  id: api/mongoose#Mongoose.prototype.set()
  summary: key can be used a object to set multiple options at once
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.set()

    ##### Parameters:

    - `key`«String\|Object» The name of the option or a object of multiple key-value pairs
    - `value`«String\|Function\|Boolean» The value of the option, unused if "key" is a object

    Sets mongoose options

    `key` can be used a object to set multiple options at once. If a error gets thrown for one option, other options will still be evaluated.

    #### [Example:](#example)

    ``` javascript
    mongoose.set('test', value) // sets the 'test' option to `value`

    mongoose.set('debug', true) // enable logging collection methods + arguments to the console/file

    mongoose.set('debug', function(collectionName, methodName, ...methodArgs) {}); // use custom function to log collection methods + arguments

    mongoose.set({ debug: true, autoIndex: false }); // set multiple options at once
    ```

    Currently supported options are:

    - `allowDiskUse`: Set to `true` to set `allowDiskUse` to true to all aggregation operations by default.
    - `applyPluginsToChildSchemas`: `true` by default. Set to false to skip applying global plugins to child schemas
    - `applyPluginsToDiscriminators`: `false` by default. Set to true to apply global plugins to discriminator schemas. This typically isn't necessary because plugins are applied to the base schema and discriminators copy all middleware, methods, statics, and properties from the base schema.
    - `autoCreate`: Set to `true` to make Mongoose call [`Model.createCollection()`](model#Model.createCollection()) automatically when you create a model with `mongoose.model()` or `conn.model()`. This is useful for testing transactions, change streams, and other features that require the collection to exist.
    - `autoIndex`: `true` by default. Set to false to disable automatic index creation for all models associated with this Mongoose instance.
    - `bufferCommands`: enable/disable mongoose's buffering mechanism for all connections and models
    - `bufferTimeoutMS`: If bufferCommands is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).
    - `cloneSchemas`: `false` by default. Set to `true` to `clone()` all schemas before compiling into a model.
    - `debug`: If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arguments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.
    - `id`: If `true`, adds a `id` virtual to all schemas unless overwritten on a per-schema basis.
    - `timestamps.createdAt.immutable`: `true` by default. If `false`, it will change the `createdAt` field to be [`immutable: false`](schematype#SchemaType.prototype.immutable) which means you can update the `createdAt`
    - `maxTimeMS`: If set, attaches [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/) to every query
    - `objectIdGetter`: `true` by default. Mongoose adds a getter to MongoDB ObjectId's called `_id` that returns `this` for convenience with populate. Set this to false to remove the getter.
    - `overwriteModels`: Set to `true` to default to overwriting models with the same name when calling `mongoose.model()`, as opposed to throwing an `OverwriteModelError`.
    - `returnOriginal`: If `false`, changes the default `returnOriginal` option to `findOneAndUpdate()`, `findByIdAndUpdate`, and `findOneAndReplace()` to false. This is equivalent to setting the `new` option to `true` for `findOneAndX()` calls by default. Read our [`findOneAndUpdate()` tutorial](../tutorials/findoneandupdate) for more information.
    - `runValidators`: `false` by default. Set to true to enable [update validators](../validation#update-validators) for all validators by default.
    - `sanitizeFilter`: `false` by default. Set to true to enable the [sanitization of the query filters](#Mongoose.prototype.sanitizeFilter()) against query selector injection attacks by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.
    - `selectPopulatedPaths`: `true` by default. Set to false to opt out of Mongoose adding all fields that you `populate()` to your `select()`. The schema-level option `selectPopulatedPaths` overwrites this one.
    - `strict`: `true` by default, may be `false`, `true`, or `'throw'`. Sets the default strict mode for schemas.
    - `strictQuery`: `false` by default. May be `false`, `true`, or `'throw'`. Sets the default [strictQuery](../guide#strictQuery) mode for schemas.
    - `toJSON`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toJSON()`](document#Document.prototype.toJSON()), for determining how Mongoose documents get serialized by `JSON.stringify()`
    - `toObject`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toObject()`](document#Document.prototype.toObject())
- name: Mongoose.prototype.setDriver()
  id: api/mongoose#Mongoose.prototype.setDriver()
  summary: Overwrites the current driver used by this Mongoose instance
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.setDriver()

    Overwrites the current driver used by this Mongoose instance. A driver is a Mongoose-specific interface that defines functions like `find()`.
- name: Mongoose.prototype.skipMiddlewareFunction()
  id: api/mongoose#Mongoose.prototype.skipMiddlewareFunction()
  summary: Use this function in pre() middleware to skip calling the wrapped function
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.skipMiddlewareFunction()

    ##### Parameters:

    - `result` «any»

    Use this function in `pre()` middleware to skip calling the wrapped function.

    #### [Example:](#example)

    ``` javascript
    schema.pre('save', function() {
      // Will skip executing `save()`, but will execute post hooks as if
      // `save()` had executed with the result `{ matchedCount: 0 }`
      return mongoose.skipMiddlewareFunction({ matchedCount: 0 });
    });
    ```
- name: Mongoose.prototype.startSession()
  id: api/mongoose#Mongoose.prototype.startSession()
  summary: Requires MongoDB >= 3.6.0
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.startSession()

    ##### Parameters:

    - `[options]`«Object» see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)

    &nbsp;

    - `[options.causalConsistency=true]`«Boolean» set to false to disable causal consistency

    &nbsp;

    - `[callback]` «Function»

    ##### Returns:

    - «Promise\<ClientSession\>» promise that resolves to a MongoDB driver `ClientSession`

    *Requires MongoDB \>= 3.6.0.* Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions) for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/), and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).

    Calling `mongoose.startSession()` is equivalent to calling `mongoose.connection.startSession()`. Sessions are scoped to a connection, so calling `mongoose.startSession()` starts a session on the [default mongoose connection](#Mongoose.prototype.connection).
- name: Mongoose.prototype.STATES
  id: api/mongoose#Mongoose.prototype.STATES
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.STATES

    ##### Type:

    - «property»

    Expose connection states for user-land
- name: Mongoose.prototype.syncIndexes()
  id: api/mongoose#Mongoose.prototype.syncIndexes()
  summary: Syncs all the indexes for the models registered with this connection
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.syncIndexes()

    ##### Parameters:

    - `options` «Object»
    - `options.continueOnError`«Boolean»`false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.

    ##### Returns:

    - «Promise» Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.

    Syncs all the indexes for the models registered with this connection.
- name: Mongoose.prototype.trusted()
  id: api/mongoose#Mongoose.prototype.trusted()
  summary: Tells sanitizeFilter() to skip the given object when filtering out potential query selector injection attacks
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.trusted()

    ##### Parameters:

    - `obj` «Object»

    Tells `sanitizeFilter()` to skip the given object when filtering out potential [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html). Use this method when you have a known query selector that you want to use.

    ``` javascript
    const obj = { username: 'val', pwd: trusted({ $type: 'string', $eq: 'my secret' }) };
    sanitizeFilter(obj);

    // Note that `sanitizeFilter()` did not add `$eq` around `$type`.
    obj; // { username: 'val', pwd: { $type: 'string', $eq: 'my secret' } });
    ```
- name: Mongoose.prototype.Types
  id: api/mongoose#Mongoose.prototype.Types
  summary: The various Mongoose Types
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.Types

    ##### Type:

    - «property»

    The various Mongoose Types.

    #### [Example:](#example)

    ``` javascript
    const mongoose = require('mongoose');
    const array = mongoose.Types.Array;
    ```

    #### [Types:](#types)

    - [Array](../schematypes#arrays)
    - [Buffer](../schematypes#buffers)
    - [Embedded](../schematypes#schemas)
    - [DocumentArray](documentarraypath)
    - [Decimal128](#Mongoose.prototype.Decimal128)
    - [ObjectId](../schematypes#objectids)
    - [Map](../schematypes#maps)
    - [Subdocument](../schematypes#schemas)

    Using this exposed access to the `ObjectId` type, we can construct ids on demand.

    ``` javascript
    constObjectId = mongoose.Types.ObjectId;
    const id1 = new ObjectId;
    ```
- name: Mongoose.prototype.version
  id: api/mongoose#Mongoose.prototype.version
  summary: © 2010 LearnBoost Licensed under the MIT License
  belongs_to: Mongoose
  description: "### Mongoose.prototype.version\n\n##### Type:\n\n- «property»\n\nThe Mongoose version\n\n#### [Example:](#example)\n\n``` javascript\nconsole.log(mongoose.version); // '5.x.x'\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/mongoose.html](https://mongoosejs.com/docs/api/mongoose.html)"
- name: Mongoose.prototype.VirtualType()
  id: api/mongoose#Mongoose.prototype.VirtualType()
  summary: null
  belongs_to: Mongoose
  description: |-
    ### Mongoose.prototype.VirtualType()

    The Mongoose [VirtualType](virtualtype#VirtualType()) constructor
- name: MongooseArray.prototype.$pop()
  id: api/array#MongooseArray.prototype.$pop()
  summary: Pops the array atomically at most one time per document save()
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.$pop()

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/operator/update/pop/)

    Pops the array atomically at most one time per document `save()`.

    #### [NOTE:](#note)

    *Calling this multiple times on an array before saving sends the same command as calling it once.* *This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction.*

    ``` javascript
     doc.array = [1,2,3];

     const popped = doc.array.$pop();
     console.log(popped); // 3
     console.log(doc.array); // [1,2]

     // no affect
     popped = doc.array.$pop();
     console.log(doc.array); // [1,2]

     doc.save(function (err) {
       if (err) return handleError(err);

       // we saved, now $pop works again
       popped = doc.array.$pop();
       console.log(popped); // 2
       console.log(doc.array); // [1]
     })
    ```
- name: MongooseArray.prototype.$shift()
  id: api/array#MongooseArray.prototype.$shift()
  summary: Atomically shifts the array at most one time per document save()
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.$shift()

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/operator/update/pop/)

    Atomically shifts the array at most one time per document `save()`.

    #### [Note:](#note)

    *Calling this multiple times on an array before saving sends the same command as calling it once.* *This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction.*

    ``` javascript
     doc.array = [1,2,3];

     const shifted = doc.array.$shift();
     console.log(shifted); // 1
     console.log(doc.array); // [2,3]

     // no affect
     shifted = doc.array.$shift();
     console.log(doc.array); // [2,3]

     doc.save(function (err) {
       if (err) return handleError(err);

       // we saved, now $shift works again
       shifted = doc.array.$shift();
       console.log(shifted ); // 2
       console.log(doc.array); // [3]
     })
    ```
- name: MongooseArray.prototype.addToSet()
  id: api/array#MongooseArray.prototype.addToSet()
  summary: Adds values to the array if not already present
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.addToSet()

    ##### Parameters:

    - `[...args]` «any»

    ##### Returns:

    - «Array» the values that were added

    Adds values to the array if not already present.

    #### [Example:](#example)

    ``` javascript
    console.log(doc.array) // [2,3,4]const added = doc.array.addToSet(4,5);
    console.log(doc.array) // [2,3,4,5]
    console.log(added)     // [5]
    ```
- name: MongooseArray.prototype.includes()
  id: api/array#MongooseArray.prototype.includes()
  summary: Return whether or not the obj is included in the array
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.includes()

    ##### Parameters:

    - `obj`«Object» the item to check
    - `fromIndex` «Number»

    ##### Returns:

    - «Boolean»

    Return whether or not the `obj` is included in the array.
- name: MongooseArray.prototype.indexOf()
  id: api/array#MongooseArray.prototype.indexOf()
  summary: Return the index of obj or -1 if not found
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.indexOf()

    ##### Parameters:

    - `obj`«Object» the item to look for
    - `fromIndex` «Number»

    ##### Returns:

    - «Number»

    Return the index of `obj` or `-1` if not found.
- name: MongooseArray.prototype.inspect()
  id: api/array#MongooseArray.prototype.inspect()
  summary: null
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.inspect()

    Helper for console.log
- name: MongooseArray.prototype.nonAtomicPush()
  id: api/array#MongooseArray.prototype.nonAtomicPush()
  summary: Pushes items to the array non-atomically
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.nonAtomicPush()

    ##### Parameters:

    - `[...args]` «any»

    Pushes items to the array non-atomically.

    #### [Note:](#note)

    *marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.*
- name: MongooseArray.prototype.pop()
  id: api/array#MongooseArray.prototype.pop()
  summary: Wraps Array#pop with proper change tracking
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.pop()

    ##### See:

    -  [MongooseArray#$pop](#MongooseArray.prototype.$pop())

    Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.

    #### [Note:](#note)

    *marks the entire array as modified which will pass the entire thing to $set potentially overwriting any changes that happen between when you retrieved the object and when you save it.*
- name: MongooseArray.prototype.pull()
  id: api/array#MongooseArray.prototype.pull()
  summary: Pulls items from the array atomically
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.pull()

    ##### Parameters:

    - `[...args]` «any»

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/operator/update/pull/)

    Pulls items from the array atomically. Equality is determined by casting the provided value to an embedded document and comparing using [the `Document.equals()` function.](document#Document.prototype.equals())

    #### [Example:](#example)

    ``` javascript
    doc.array.pull(ObjectId)
    doc.array.pull({ _id: 'someId' })
    doc.array.pull(36)
    doc.array.pull('tag 1', 'tag 2')
    ```

    To remove a document from a subdocument array we may pass an object with a matching `_id`.

    ``` javascript
    doc.subdocs.push({ _id: 4815162342 })
    doc.subdocs.pull({ _id: 4815162342 }) // removed
    ```

    Or we may passing the \_id directly and let mongoose take care of it.

    ``` javascript
    doc.subdocs.push({ _id: 4815162342 })
    doc.subdocs.pull(4815162342); // works
    ```

    The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.
- name: MongooseArray.prototype.push()
  id: api/array#MongooseArray.prototype.push()
  summary: Wraps Array#push with proper change tracking
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.push()

    ##### Parameters:

    - `[...args]` «Object»

    Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.

    #### [Example:](#example)

    ``` javascript
    const schema = Schema({ nums: [Number] });
    const Model = mongoose.model('Test', schema);

    const doc = await Model.create({ nums: [3, 4] });
    doc.nums.push(5); // Add 5 to the end of the array
    await doc.save();

    // You can also pass an object with `$each` as the
    // first parameter to use MongoDB's `$position`
    doc.nums.push({
      $each: [1, 2],
      $position: 0
    });
    doc.nums; // [1, 2, 3, 4, 5]
    ```
- name: MongooseArray.prototype.remove()
  id: api/array#MongooseArray.prototype.remove()
  summary: null
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.remove()

    ##### See:

    -  [MongooseArray#pull](#MongooseArray.prototype.pull())
    -  [mongodb](https://www.mongodb.com/docs/manual/reference/operator/update/pull/)

    Alias of [pull](#MongooseArray.prototype.pull())
- name: MongooseArray.prototype.set()
  id: api/array#MongooseArray.prototype.set()
  summary: Sets the casted val at index i and marks the array modified
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.set()

    ##### Returns:

    - «Array» this

    Sets the casted `val` at index `i` and marks the array modified.

    #### [Example:](#example)

    ``` javascript
    // given documents based on the followingconstDoc = mongoose.model('Doc', new Schema({ array: [Number] }));

    const doc = new Doc({ array: [2,3,4] })

    console.log(doc.array) // [2,3,4]

    doc.array.set(1,"5");
    console.log(doc.array); // [2,5,4] // properly cast to number
    doc.save() // the change is saved

    // VS not using array#set
    doc.array[1] = "5";
    console.log(doc.array); // [2,"5",4] // no casting
    doc.save() // change is not saved
    ```
- name: MongooseArray.prototype.shift()
  id: api/array#MongooseArray.prototype.shift()
  summary: Wraps Array#shift with proper change tracking
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.shift()

    Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.

    #### [Example:](#example)

    ``` javascript
    doc.array = [2,3];
    const res = doc.array.shift();
    console.log(res) // 2
    console.log(doc.array) // [3]
    ```

    #### [Note:](#note)

    *marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.*
- name: MongooseArray.prototype.sort()
  id: api/array#MongooseArray.prototype.sort()
  summary: Wraps Array#sort with proper change tracking
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.sort()

    ##### See:

    -  [MasteringJS: Array sort](https://masteringjs.io/tutorials/fundamentals/array-sort)

    Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.

    #### [Note:](#note)

    *marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.*
- name: MongooseArray.prototype.splice()
  id: api/array#MongooseArray.prototype.splice()
  summary: Wraps Array#splice with proper change tracking and casting
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.splice()

    ##### See:

    -  [MasteringJS: Array splice](https://masteringjs.io/tutorials/fundamentals/array-splice)

    Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.

    #### [Note:](#note)

    *marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.*
- name: MongooseArray.prototype.toObject()
  id: api/array#MongooseArray.prototype.toObject()
  summary: Returns a native js Array
  belongs_to: Array
  description: |-
    ### MongooseArray.prototype.toObject()

    ##### Parameters:

    - `options` «Object»

    ##### Returns:

    - «Array»

    Returns a native js Array.
- name: MongooseArray.prototype.unshift()
  id: api/array#MongooseArray.prototype.unshift()
  summary: Wraps Array#unshift with proper change tracking
  belongs_to: Array
  description: "### MongooseArray.prototype.unshift()\n\nWraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n\n#### [Note:](#note)\n\n*marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwriting any changes that happen between when you retrieved the object and when you save it.*\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/array.html](https://mongoosejs.com/docs/api/array.html)"
- name: MongooseBuffer.mixin.copy()
  id: api/buffer#MongooseBuffer.mixin.copy()
  summary: Copies the buffer
  belongs_to: Buffer
  description: |-
    ### MongooseBuffer.mixin.copy()

    ##### Parameters:

    - `target` «Buffer»

    ##### Returns:

    - «Number» The number of bytes copied.

    ##### Type:

    - «property»

    Copies the buffer.

    #### [Note:](#note)

    `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.
- name: MongooseBuffer.mixin.equals()
  id: api/buffer#MongooseBuffer.mixin.equals()
  summary: null
  belongs_to: Buffer
  description: |-
    ### MongooseBuffer.mixin.equals()

    ##### Parameters:

    - `other` «Buffer»

    ##### Returns:

    - «Boolean»

    Determines if this buffer is equals to `other` buffer
- name: MongooseBuffer.mixin.subtype()
  id: api/buffer#MongooseBuffer.mixin.subtype()
  summary: Sets the subtype option and marks the buffer modified
  belongs_to: Buffer
  description: |-
    ### MongooseBuffer.mixin.subtype()

    ##### Parameters:

    - `subtype` «Hex»

    ##### See:

    -  [bsonspec](https://bsonspec.org/#/specification)

    Sets the subtype option and marks the buffer modified.

    #### [SubTypes:](#subtypes)

    ``` javascript
    const bson = require('bson')
    bson.BSON_BINARY_SUBTYPE_DEFAULT
    bson.BSON_BINARY_SUBTYPE_FUNCTION
    bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
    bson.BSON_BINARY_SUBTYPE_UUID
    bson.BSON_BINARY_SUBTYPE_MD5
    bson.BSON_BINARY_SUBTYPE_USER_DEFINED

    doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);
    ```
- name: MongooseBuffer.mixin.toBSON()
  id: api/buffer#MongooseBuffer.mixin.toBSON()
  summary: null
  belongs_to: Buffer
  description: |-
    ### MongooseBuffer.mixin.toBSON()

    ##### Returns:

    - «Binary»

    Converts this buffer for storage in MongoDB, including subtype
- name: MongooseBuffer.mixin.toObject()
  id: api/buffer#MongooseBuffer.mixin.toObject()
  summary: Converts this buffer to its Binary type representation
  belongs_to: Buffer
  description: |-
    ### MongooseBuffer.mixin.toObject()

    ##### Parameters:

    - `[subtype]` «Hex»

    ##### Returns:

    - «Binary»

    ##### See:

    -  [bsonspec](https://bsonspec.org/#/specification)

    Converts this buffer to its Binary type representation.

    #### [SubTypes:](#subtypes)

    ``` javascript
    const bson = require('bson')
    bson.BSON_BINARY_SUBTYPE_DEFAULT
    bson.BSON_BINARY_SUBTYPE_FUNCTION
    bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
    bson.BSON_BINARY_SUBTYPE_UUID
    bson.BSON_BINARY_SUBTYPE_MD5
    bson.BSON_BINARY_SUBTYPE_USER_DEFINED
    doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);
    ```
- name: MongooseBuffer.mixin.write()
  id: api/buffer#MongooseBuffer.mixin.write()
  summary: Writes the buffer
  belongs_to: Buffer
  description: "### MongooseBuffer.mixin.write()\n\n##### Type:\n\n- «property»\n\nWrites the buffer.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/buffer.html](https://mongoosejs.com/docs/api/buffer.html)"
- name: MongooseDocumentArray
  id: api/mongoosedocumentarray
  summary: Creates a subdocument casted to this schema
  description: "# MongooseDocumentArray\n\n### MongooseDocumentArray.prototype.create()\n\n##### Parameters:\n\n- `obj` «Object» the value to cast to this arrays SubDocument schema\n\nCreates a subdocument casted to this schema.\n\nThis is the same subdocument constructor used for casting.\n\n### MongooseDocumentArray.prototype.id()\n\n##### Parameters:\n\n- `id` «ObjectId\\|String\\|Number\\|Buffer»\n\n##### Returns:\n\n- «EmbeddedDocument,null» the subdocument or null if not found.\n\nSearches array items for the first document with a matching \\_id.\n\n#### [Example:](#example)\n\n``` javascript\nconst embeddedDoc = m.array.id(some_id);\n```\n\n### MongooseDocumentArray.prototype.inspect()\n\nHelper for console.log\n\n### MongooseDocumentArray.prototype.pull()\n\n##### Parameters:\n\n- `[...args]` «Object»\n\nPulls items from the array atomically.\n\n### MongooseDocumentArray.prototype.push()\n\n##### Parameters:\n\n- `[...args]` «Object»\n\nWraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n\n### MongooseDocumentArray.prototype.toObject()\n\n##### Parameters:\n\n- `[options]` «Object» optional options to pass to each documents `toObject` method call during conversion\n\n##### Returns:\n\n- «Array»\n\nReturns a native js Array of plain js objects\n\n#### [Note:](#note)\n\n*Each sub-document is converted to a plain object by calling its `#toObject` method.*\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/mongoosedocumentarray.html](https://mongoosejs.com/docs/api/mongoosedocumentarray.html)"
- name: MongooseDocumentArray.prototype.create()
  id: api/mongoosedocumentarray#MongooseDocumentArray.prototype.create()
  summary: Creates a subdocument casted to this schema
  belongs_to: MongooseDocumentArray
  description: |-
    ### MongooseDocumentArray.prototype.create()

    ##### Parameters:

    - `obj`«Object» the value to cast to this arrays SubDocument schema

    Creates a subdocument casted to this schema.

    This is the same subdocument constructor used for casting.
- name: MongooseDocumentArray.prototype.id()
  id: api/mongoosedocumentarray#MongooseDocumentArray.prototype.id()
  summary: Searches array items for the first document with a matching _id
  belongs_to: MongooseDocumentArray
  description: |-
    ### MongooseDocumentArray.prototype.id()

    ##### Parameters:

    - `id` «ObjectId\|String\|Number\|Buffer»

    ##### Returns:

    - «EmbeddedDocument,null» the subdocument or null if not found.

    Searches array items for the first document with a matching \_id.

    #### [Example:](#example)

    ``` javascript
    const embeddedDoc = m.array.id(some_id);
    ```
- name: MongooseDocumentArray.prototype.inspect()
  id: api/mongoosedocumentarray#MongooseDocumentArray.prototype.inspect()
  summary: null
  belongs_to: MongooseDocumentArray
  description: |-
    ### MongooseDocumentArray.prototype.inspect()

    Helper for console.log
- name: MongooseDocumentArray.prototype.pull()
  id: api/mongoosedocumentarray#MongooseDocumentArray.prototype.pull()
  summary: Pulls items from the array atomically
  belongs_to: MongooseDocumentArray
  description: |-
    ### MongooseDocumentArray.prototype.pull()

    ##### Parameters:

    - `[...args]` «Object»

    Pulls items from the array atomically.
- name: MongooseDocumentArray.prototype.push()
  id: api/mongoosedocumentarray#MongooseDocumentArray.prototype.push()
  summary: Wraps Array#push with proper change tracking
  belongs_to: MongooseDocumentArray
  description: |-
    ### MongooseDocumentArray.prototype.push()

    ##### Parameters:

    - `[...args]` «Object»

    Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
- name: MongooseDocumentArray.prototype.toObject()
  id: api/mongoosedocumentarray#MongooseDocumentArray.prototype.toObject()
  summary: 'Each sub-document is converted to a plain object by calling its #toObject method'
  belongs_to: MongooseDocumentArray
  description: "### MongooseDocumentArray.prototype.toObject()\n\n##### Parameters:\n\n- `[options]`«Object» optional options to pass to each documents `toObject` method call during conversion\n\n##### Returns:\n\n- «Array»\n\nReturns a native js Array of plain js objects\n\n#### [Note:](#note)\n\n*Each sub-document is converted to a plain object by calling its `#toObject` method.*\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/mongoosedocumentarray.html](https://mongoosejs.com/docs/api/mongoosedocumentarray.html)"
- name: MongooseMap.prototype.$isMongooseMap
  id: api/map#MongooseMap.prototype.$isMongooseMap
  summary: null
  belongs_to: Map
  description: |-
    ### MongooseMap.prototype.$isMongooseMap

    ##### Type:

    - «property»

    Set to `true` for all Mongoose map instances
- name: MongooseMap.prototype.clear()
  id: api/map#MongooseMap.prototype.clear()
  summary: Overwrites native Map's clear() function to support change tracking
  belongs_to: Map
  description: |-
    ### MongooseMap.prototype.clear()

    Overwrites native Map's `clear()` function to support change tracking.
- name: MongooseMap.prototype.delete()
  id: api/map#MongooseMap.prototype.delete()
  summary: Overwrites native Map's delete() function to support change tracking
  belongs_to: Map
  description: |-
    ### MongooseMap.prototype.delete()

    Overwrites native Map's `delete()` function to support change tracking.
- name: MongooseMap.prototype.get()
  id: api/map#MongooseMap.prototype.get()
  summary: Overwrites native Map's get() function to support Mongoose getters
  belongs_to: Map
  description: |-
    ### MongooseMap.prototype.get()

    Overwrites native Map's `get()` function to support Mongoose getters.
- name: MongooseMap.prototype.set()
  id: api/map#MongooseMap.prototype.set()
  summary: Overwrites native Map's set() function to support setters, populate(), and change tracking
  belongs_to: Map
  description: |-
    ### MongooseMap.prototype.set()

    Overwrites native Map's `set()` function to support setters, `populate()`, and change tracking. Note that Mongoose maps *only* support strings and ObjectIds as keys.

    #### [Example:](#example)

    ``` javascript
    doc.myMap.set('test', 42); // works
    doc.myMap.set({ obj: 42 }, 42); // Throws "Mongoose maps only support string keys"
    ```
- name: MongooseMap.prototype.toBSON()
  id: api/map#MongooseMap.prototype.toBSON()
  summary: Converts this map to a native JavaScript Map so the MongoDB driver can serialize it
  belongs_to: Map
  description: |-
    ### MongooseMap.prototype.toBSON()

    Converts this map to a native JavaScript Map so the MongoDB driver can serialize it.
- name: MongooseMap.prototype.toJSON()
  id: api/map#MongooseMap.prototype.toJSON()
  summary: Converts this map to a native JavaScript Map for JSON.stringify()
  belongs_to: Map
  description: "### MongooseMap.prototype.toJSON()\n\n##### Parameters:\n\n- `[options]` «Object»\n\n- `[options.flattenMaps=false]`«Boolean» set to `true` to convert the map to a POJO rather than a native JavaScript map\n\nConverts this map to a native JavaScript Map for `JSON.stringify()`. Set the `flattenMaps` option to convert this map to a POJO instead.\n\n#### [Example:](#example)\n\n``` javascript\ndoc.myMap.toJSON() instanceof Map; // true\ndoc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/map.html](https://mongoosejs.com/docs/api/map.html)"
- name: Number
  id: schematypes#number-validators
  summary: null
  belongs_to: SchemaTypes
  description: |-
    ### Number

    - `min`: Number, creates a [validator](validation) that checks if the value is greater than or equal to the given minimum.
    - `max`: Number, creates a [validator](validation) that checks if the value is less than or equal to the given maximum.
    - `enum`: Array, creates a [validator](validation) that checks if the value is strictly equal to one of the values in the given array.
    - `populate`: Object, sets default [populate options](populate#query-conditions)

    ### Date

    - `min`: Date, creates a [validator](validation) that checks if the value is greater than or equal to the given minimum.
    - `max`: Date, creates a [validator](validation) that checks if the value is less than or equal to the given maximum.
    - `expires`: Number or String, creates a TTL index with the value expressed in seconds.

    ### ObjectId

    - `populate`: Object, sets default [populate options](populate#query-conditions)

    ## Usage Notes
- name: Number
  id: schematypes#numbers
  summary: There are several types of values that will be successfully cast to a Number
  belongs_to: SchemaTypes
  description: |-
    ### Number

    To declare a path as a number, you may use either the `Number` global constructor or the string `'Number'`.

    ``` javascript
    const schema1 = new Schema({ age: Number }); // age will be cast to a Number
    const schema2 = new Schema({ age: 'Number' }); // Equivalent

    const Car = mongoose.model('Car', schema2);
    ```

    There are several types of values that will be successfully cast to a Number.

    ``` javascript
    newCar({ age: '15' }).age; // 15 as a Number
    new Car({ age: true }).age; // 1 as a Number
    new Car({ age: false }).age; // 0 as a Number
    new Car({ age: { valueOf: () => 83 } }).age; // 83 as a Number
    ```

    If you pass an object with a `valueOf()` function that returns a Number, Mongoose will call it and assign the returned value to the path.

    The values `null` and `undefined` are not cast.

    NaN, strings that cast to NaN, arrays, and objects that don't have a `valueOf()` function will all result in a [CastError](validation#cast-errors) once validated, meaning that it will not throw on initialization, only when validated.
- name: ObjectId()
  id: api/schemaobjectid#ObjectId()
  summary: ObjectId SchemaType constructor
  belongs_to: SchemaObjectid
  description: |-
    ### ObjectId()

    ##### Parameters:

    - `key` «String»
    - `options` «Object»

    ##### Inherits:

    -  [«SchemaType»](schematype)

    ObjectId SchemaType constructor.
- name: ObjectId.checkRequired()
  id: api/schemaobjectid#ObjectId.checkRequired()
  summary: Override the function the required validator uses to check whether a string passes the required check
  belongs_to: SchemaObjectid
  description: |-
    ### ObjectId.checkRequired()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «Function»

    ##### Type:

    - «property»

    Override the function the required validator uses to check whether a string passes the `required` check.

    #### [Example:](#example)

    ``` javascript
    // Allow empty strings to pass `required` check
    mongoose.Schema.Types.String.checkRequired(v => v != null);

    const M = mongoose.model({ str: { type: String, required: true } });
    new M({ str: '' }).validateSync(); // `null`, validation passes!
    ```
- name: ObjectId.get()
  id: api/schemaobjectid#ObjectId.get()
  summary: Get/set the function used to cast arbitrary values to objectids
  belongs_to: SchemaObjectid
  description: |-
    ### ObjectId.get()

    ##### Parameters:

    - `getter` «Function»

    ##### Returns:

    - «this»

    ##### Type:

    - «property»

    Attaches a getter for all ObjectId instances

    #### [Example:](#example)

    ``` javascript
    // Always convert to string when getting an ObjectId
    mongoose.ObjectId.get(v => v.toString());

    const Model = mongoose.model('Test', new Schema({}));
    typeof (new Model({})._id); // 'string'
    ```

    ### ObjectId.get()

    ##### Parameters:

    - `caster` «Function»

    ##### Returns:

    - «Function»

    ##### Type:

    - «property»

    Get/set the function used to cast arbitrary values to objectids.

    #### [Example:](#example)

    ``` javascript
    // Make Mongoose only try to cast length 24 strings. By default, any 12// char string is a valid ObjectId.const original = mongoose.ObjectId.cast();
    mongoose.ObjectId.cast(v => {
      assert.ok(typeof v !== 'string' || v.length === 24);
      return original(v);
    });

    // Or disable casting entirely
    mongoose.ObjectId.cast(false);
    ```
- name: ObjectId.prototype.auto()
  id: api/schemaobjectid#ObjectId.prototype.auto()
  summary: Adds an auto-generated ObjectId default if turnOn is true
  belongs_to: SchemaObjectid
  description: |-
    ### ObjectId.prototype.auto()

    ##### Parameters:

    - `turnOn`«Boolean» auto generated ObjectId defaults

    ##### Returns:

    - «SchemaType» this

    Adds an auto-generated ObjectId default if turnOn is true.
- name: ObjectId.prototype.checkRequired()
  id: api/schemaobjectid#ObjectId.prototype.checkRequired()
  summary: Check if the given value satisfies a required validator
  belongs_to: SchemaObjectid
  description: |-
    ### ObjectId.prototype.checkRequired()

    ##### Parameters:

    - `value` «Any»
    - `doc` «Document»

    ##### Returns:

    - «Boolean»

    Check if the given value satisfies a required validator.
- name: ObjectId.schemaName
  id: api/schemaobjectid#ObjectId.schemaName
  summary: This schema type's name, to defend against minifiers that mangle function names
  belongs_to: SchemaObjectid
  description: |-
    ### ObjectId.schemaName

    ##### Type:

    - «property»

    This schema type's name, to defend against minifiers that mangle function names.
- name: ObjectId.set()
  id: api/schemaobjectid#ObjectId.set()
  summary: Sets a default option for all ObjectId instances
  belongs_to: SchemaObjectid
  description: "### ObjectId.set()\n\n##### Parameters:\n\n- `option`«String» The option you'd like to set the value for\n- `value`«Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all ObjectId instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all object ids have option `required` equal to true.\nmongoose.Schema.ObjectId.set('required', true);\n\nconst Order = mongoose.model('Order', new Schema({ userId: ObjectId }));\nnew Order({ }).validateSync().errors.userId.message; // Path `userId` is required.\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemaobjectid.html](https://mongoosejs.com/docs/api/schemaobjectid.html)"
- name: ObjectIds
  id: schematypes#objectids
  summary: An ObjectId is a special type typically used for unique identifiers
  belongs_to: SchemaTypes
  description: |-
    ### ObjectIds

    An [ObjectId](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) is a special type typically used for unique identifiers. Here's how you declare a schema with a path `driver` that is an ObjectId:

    ``` javascript
    const mongoose = require('mongoose');
    const carSchema = new mongoose.Schema({ driver: mongoose.ObjectId });
    ```

    `ObjectId` is a class, and ObjectIds are objects. However, they are often represented as strings. When you convert an ObjectId to a string using `toString()`, you get a 24-character hexadecimal string:

    ``` javascript
    constCar = mongoose.model('Car', carSchema);

    const car = new Car();
    car.driver = new mongoose.Types.ObjectId();

    typeof car.driver; // 'object'
    car.driver instanceof mongoose.Types.ObjectId; // true

    car.driver.toString(); // Something like "5e1a0651741b255ddda996c4"
    ```
- name: Plugins
  id: plugins
  summary: Schemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality
  description: "# Plugins\n\nSchemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality. This is a very powerful feature.\n\n## Example\n\nPlugins are a tool for reusing logic in multiple schemas. Suppose you have several models in your database and want to add a `loadedAt` property to each one. Just create a plugin once and apply it to each `Schema`:\n\n``` javascript\n// loadedAt.js\nmodule.exports = function loadedAtPlugin(schema, options) {\n  schema.virtual('loadedAt').\n    get(function() { return this._loadedAt; }).\n    set(function(v) { this._loadedAt = v; });\n\n  schema.post(['find', 'findOne'], function(docs) {\n    if (!Array.isArray(docs)) {\n      docs = [docs];\n    }\n    const now = new Date();\n    for (const doc of docs) {\n      doc.loadedAt = now;\n    }\n  });\n};\n\n// game-schema.js\nconst loadedAtPlugin = require('./loadedAt');\nconst gameSchema = new Schema({ /* ... */ });\ngameSchema.plugin(loadedAtPlugin);\n\n// player-schema.js\nconst loadedAtPlugin = require('./loadedAt');\nconst playerSchema = new Schema({ /* ... */ });\nplayerSchema.plugin(loadedAtPlugin);\n```\n\nWe just added last-modified behavior to both our `Game` and `Player` schemas and declared an index on the `lastMod` path of our Games to boot. Not bad for a few lines of code.\n\n## Global Plugins\n\nWant to register a plugin for all schemas? The mongoose singleton has a `.plugin()` function that registers a plugin for every schema. For example:\n\n``` javascript\nconst mongoose = require('mongoose');\nmongoose.plugin(require('./loadedAt'));\n\nconst gameSchema = new Schema({ /* ... */ });\nconst playerSchema = new Schema({ /* ... */ });\n// `loadedAtPlugin` gets attached to both schemas\nconst Game = mongoose.model('Game', gameSchema);\nconst Player = mongoose.model('Player', playerSchema);\n```\n\n## Apply Plugins Before Compiling Models\n\nBecause many plugins rely on [middleware](middleware), you should make sure to apply plugins **before** you call `mongoose.model()` or `conn.model()`. Otherwise, [any middleware the plugin registers won't get applied](middleware#defining).\n\n``` javascript\n// loadedAt.js\nmodule.exports = function loadedAtPlugin(schema, options) {\n  schema.virtual('loadedAt').\n    get(function() { return this._loadedAt; }).\n    set(function(v) { this._loadedAt = v; });\n\n  schema.post(['find', 'findOne'], function(docs) {\n    if (!Array.isArray(docs)) {\n      docs = [docs];\n    }\n    const now = new Date();\n    for (const doc of docs) {\n      doc.loadedAt = now;\n    }\n  });\n};\n\n// game-schema.js\nconst loadedAtPlugin = require('./loadedAt');\nconst gameSchema = new Schema({ /* ... */ });\nconst Game = mongoose.model('Game', gameSchema);\n\n// `find()` and `findOne()` hooks from `loadedAtPlugin()` won't get applied\n// because `mongoose.model()` was already called!\ngameSchema.plugin(loadedAtPlugin);\n```\n\n## Officially Supported Plugins\n\nThe Mongoose team maintains several plugins that add cool new features to Mongoose. Here's a couple:\n\n- [mongoose-autopopulate](http://plugins.mongoosejs.io/plugins/autopopulate): Always [`populate()`](populate) certain fields in your Mongoose schemas.\n- [mongoose-lean-virtuals](http://plugins.mongoosejs.io/plugins/lean-virtuals): Attach virtuals to the results of Mongoose queries when using [`.lean()`](api/query#query_Query-lean).\n- [mongoose-cast-aggregation](https://www.npmjs.com/package/mongoose-cast-aggregation)\n\nYou can find a full list of officially supported plugins on [Mongoose's plugins search site](https://plugins.mongoosejs.io/).\n\n## Community\n\nNot only can you re-use schema functionality in your own projects, but you also reap the benefits of the Mongoose community as well. Any plugin published to [npm](https://npmjs.org/) and with 'mongoose' as an [npm keyword](https://docs.npmjs.com/files/package.json#keywords) will show up on our [search results](http://plugins.mongoosejs.io) page.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/plugins.html](https://mongoosejs.com/docs/plugins.html)"
- name: Populate
  id: populate
  summary: MongoDB has the join-like $lookup aggregation operator in versions >= 3.2
  description: "# Populate\n\nMongoDB has the join-like [$lookup](https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/) aggregation operator in versions \\>= 3.2. Mongoose has a more powerful alternative called `populate()`, which lets you reference documents in other collections.\n\nPopulation is the process of automatically replacing the specified paths in the document with document(s) from other collection(s). We may populate a single document, multiple documents, a plain object, multiple plain objects, or all objects returned from a query. Let's look at some examples.\n\n``` javascript\nconst mongoose = require('mongoose');\nconst { Schema } = mongoose;\n\nconst personSchema = Schema({\n  _id: Schema.Types.ObjectId,\n  name: String,\n  age: Number,\n  stories: [{ type: Schema.Types.ObjectId, ref: 'Story' }]\n});\n\nconst storySchema = Schema({\n  author: { type: Schema.Types.ObjectId, ref: 'Person' },\n  title: String,\n  fans: [{ type: Schema.Types.ObjectId, ref: 'Person' }]\n});\n\nconst Story = mongoose.model('Story', storySchema);\nconst Person = mongoose.model('Person', personSchema);\n```\n\nSo far we've created two [Models](models). Our `Person` model has its `stories` field set to an array of `ObjectId`s. The `ref` option is what tells Mongoose which model to use during population, in our case the `Story` model. All `_id`s we store here must be document `_id`s from the `Story` model.\n\n## Saving refs\n\nSaving refs to other documents works the same way you normally save properties, just assign the `_id` value:\n\n``` javascript\nconst author = new Person({\n  _id: new mongoose.Types.ObjectId(),\n  name: 'Ian Fleming',\n  age: 50\n});\n\nawait author.save();\n\nconst story1 = new Story({\n  title: 'Casino Royale',\n  author: author._id // assign the _id from the person\n});\n\nawait story1.save();\n// that's it!\n```\n\nYou can set the `ref` option on `ObjectId`, `Number`, `String`, and `Buffer` paths. `populate()` works with ObjectIds, numbers, strings, and buffers. However, we recommend using ObjectIds as `_id` properties (and thus ObjectIds for `ref` properties) unless you have a good reason not to. That is because MongoDB will set `_id` to an ObjectId if you create a new document without an `_id` property, so if you make your `_id` property a Number, you need to be extra careful not to insert a document without a numeric `_id`.\n\n## Population\n\nSo far we haven't done anything much different. We've merely created a `Person` and a `Story`. Now let's take a look at populating our story's `author` using the query builder:\n\n``` javascript\nconst story = await Story.\n  findOne({ title: 'Casino Royale' }).\n  populate('author').\n  exec();\n// prints \"The author is Ian Fleming\"\nconsole.log('The author is %s', story.author.name);\n```\n\nPopulated paths are no longer set to their original `_id` , their value is replaced with the mongoose document returned from the database by performing a separate query before returning the results.\n\nArrays of refs work the same way. Just call the [populate](api/query#query_Query-populate) method on the query and an array of documents will be returned *in place* of the original `_id`s.\n\n## Setting Populated Fields\n\nYou can manually populate a property by setting it to a document. The document must be an instance of the model your `ref` property refers to.\n\n``` javascript\nconst story = await Story.findOne({ title: 'Casino Royale' });\nstory.author = author;\nconsole.log(story.author.name); // prints \"Ian Fleming\"\n```\n\n## Checking Whether a Field is Populated\n\nYou can call the `populated()` function to check whether a field is populated. If `populated()` returns a [truthy value](https://masteringjs.io/tutorials/fundamentals/truthy), you can assume the field is populated.\n\n``` javascript\nstory.populated('author'); // truthy\n\nstory.depopulate('author'); // Make `author` not populated anymore\nstory.populated('author'); // undefined\n```\n\nA common reason for checking whether a path is populated is getting the `author` id. However, for your convenience, Mongoose adds a [`_id` getter to ObjectId instances](api/mongoose#mongoose_Mongoose-set) so you can use `story.author._id` regardless of whether `author` is populated.\n\n``` javascript\nstory.populated('author'); // truthy\nstory.author._id; // ObjectId\n\nstory.depopulate('author'); // Make `author` not populated anymore\nstory.populated('author'); // undefined\n\nstory.author instanceof ObjectId; // true\nstory.author._id; // ObjectId, because Mongoose adds a special getter\n```\n\n## What If There's No Foreign Document?\n\nMongoose populate doesn't behave like conventional [SQL joins](https://www.w3schools.com/sql/sql_join.asp). When there's no document, `story.author` will be `null`. This is analogous to a [left join](https://www.w3schools.com/sql/sql_join_left.asp) in SQL.\n\n``` javascript\nawait Person.deleteMany({ name: 'Ian Fleming' });\n\nconst story = await Story.findOne({ title: 'Casino Royale' }).populate('author');\nstory.author; // `null`\n```\n\nIf you have an array of `authors` in your `storySchema`, `populate()` will give you an empty array instead.\n\n``` javascript\nconst storySchema = Schema({\n  authors: [{ type: Schema.Types.ObjectId, ref: 'Person' }],\n  title: String\n});\n\n// Later\n\nconst story = await Story.findOne({ title: 'Casino Royale' }).populate('authors');\nstory.authors; // `[]`\n```\n\n## Field Selection\n\nWhat if we only want a few specific fields returned for the populated documents? This can be accomplished by passing the usual [field name syntax](api/query#query_Query-select) as the second argument to the populate method:\n\n``` javascript\nconst story = await Story.\n  findOne({ title: /casino royale/i }).\n  populate('author', 'name').\n  exec(); // only return the Persons name\n// prints \"The author is Ian Fleming\"\nconsole.log('The author is %s', story.author.name);\n// prints \"The authors age is null\"\nconsole.log('The authors age is %s', story.author.age);\n```\n\n## Populating Multiple Paths\n\nWhat if we wanted to populate multiple paths at the same time?\n\n``` javascript\nawait Story.\n  find({ /* ... */ }).\n  populate('fans').\n  populate('author').\n  exec();\n```\n\nIf you call `populate()` multiple times with the same path, only the last one will take effect.\n\n``` javascript\n// The 2nd `populate()` call below overwrites the first because they\n// both populate 'fans'.\nawait Story.\n  find().\n  populate({ path: 'fans', select: 'name' }).\n  populate({ path: 'fans', select: 'email' });\n// The above is equivalent to:\nawait Story.find().populate({ path: 'fans', select: 'email' });\n```\n\n## Query conditions and other options\n\nWhat if we wanted to populate our fans array based on their age and select just their names?\n\n``` javascript\nawait Story.\n  find().\n  populate({\n    path: 'fans',\n    match: { age: { $gte: 21 } },\n    // Explicitly exclude `_id`, see http://bit.ly/2aEfTdB\n    select: 'name -_id'\n  }).\n  exec();\n```\n\nThe `match` option doesn't filter out `Story` documents. If there are no documents that satisfy `match`, you'll get a `Story` document with an empty `fans` array.\n\nFor example, suppose you `populate()` a story's `author` and the `author` doesn't satisfy `match`. Then the story's `author` will be `null`.\n\n``` javascript\nconst story = await Story.\n  findOne({ title: 'Casino Royale' }).\n  populate({ path: 'author', name: { $ne: 'Ian Fleming' } }).\n  exec();\nstory.author; // `null`\n```\n\nIn general, there is no way to make `populate()` filter stories based on properties of the story's `author`. For example, the below query won't return any results, even though `author` is populated.\n\n``` javascript\nconst story = await Story.\n  findOne({ 'author.name': 'Ian Fleming' }).\n  populate('author').\n  exec();\nstory; // null\n```\n\nIf you want to filter stories by their author's name, you should use [denormalization](https://www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design-part-3).\n\n## `limit` vs. `perDocumentLimit`\n\nPopulate does support a `limit` option, however, it currently does **not** limit on a per-document basis for backwards compatibility. For example, suppose you have 2 stories:\n\n``` javascript\nawait Story.create([\n  { title: 'Casino Royale', fans: [1, 2, 3, 4, 5, 6, 7, 8] },\n  { title: 'Live and Let Die', fans: [9, 10] }\n]);\n```\n\nIf you were to `populate()` using the `limit` option, you would find that the 2nd story has 0 fans:\n\n``` javascript\nconst stories = await Story.find().populate({\n  path: 'fans',\n  options: { limit: 2 }\n});\n\nstories[0].name; // 'Casino Royale'\nstories[0].fans.length; // 2\n\n// 2nd story has 0 fans!\nstories[1].name; // 'Live and Let Die'\nstories[1].fans.length; // 0\n```\n\nThat's because, in order to avoid executing a separate query for each document, Mongoose instead queries for fans using `numDocuments * limit` as the limit. If you need the correct `limit`, you should use the `perDocumentLimit` option (new in Mongoose 5.9.0). Just keep in mind that `populate()` will execute a separate query for each story, which may cause `populate()` to be slower.\n\n``` javascript\nconst stories = await Story.find().populate({\n  path: 'fans',\n  // Special option that tells Mongoose to execute a separate query\n  // for each `story` to make sure we get 2 fans for each story.\n  perDocumentLimit: 2\n});\n\nstories[0].name; // 'Casino Royale'\nstories[0].fans.length; // 2\n\nstories[1].name; // 'Live and Let Die'\nstories[1].fans.length; // 2\n```\n\n## Refs to children\n\nWe may find however, if we use the `author` object, we are unable to get a list of the stories. This is because no `story` objects were ever 'pushed' onto `author.stories`.\n\nThere are two perspectives here. First, you may want the `author` to know which stories are theirs. Usually, your schema should resolve one-to-many relationships by having a parent pointer in the 'many' side. But, if you have a good reason to want an array of child pointers, you can `push()` documents onto the array as shown below.\n\n``` javascript\nawait story1.save();\n\nauthor.stories.push(story1);\nawait author.save();\n```\n\nThis allows us to perform a `find` and `populate` combo:\n\n``` javascript\nconst person = await Person.\n  findOne({ name: 'Ian Fleming' }).\n  populate('stories').\n  exec(); // only works if we pushed refs to children\nconsole.log(person);\n```\n\nIt is debatable that we really want two sets of pointers as they may get out of sync. Instead we could skip populating and directly `find()` the stories we are interested in.\n\n``` javascript\nconst stories = await Story.\n  find({ author: author._id }).\n  exec();\nconsole.log('The stories are an array: ', stories);\n```\n\nThe documents returned from [query population](api/query#query_Query-populate) become fully functional, `remove`able, `save`able documents unless the [lean](api/query#query_Query-lean) option is specified. Do not confuse them with [sub docs](subdocs). Take caution when calling its remove method because you'll be removing it from the database, not just the array.\n\n## Populating an existing document\n\nIf you have an existing mongoose document and want to populate some of its paths, you can use the [Document#populate()](api/document#document_Document-populate) method.\n\n``` javascript\nconst person = await Person.findOne({ name: 'Ian Fleming' });\n\nperson.populated('stories'); // null\n\n// Call the `populate()` method on a document to populate a path.\nawait person.populate('stories');\n\nperson.populated('stories'); // Array of ObjectIds\nperson.stories[0].name; // 'Casino Royale'\n```\n\nThe `Document#populate()` method does not support chaining. You need to call `populate()` multiple times, or with an array of paths, to populate multiple paths\n\n``` javascript\nawait person.populate(['stories', 'fans']);\nperson.populated('fans'); // Array of ObjectIds\n```\n\n## Populating multiple existing documents\n\nIf we have one or many mongoose documents or even plain objects (*like [mapReduce](api/model#model_Model-mapReduce) output*), we may populate them using the [Model.populate()](api/model#model_Model-populate) method. This is what `Document#populate()` and `Query#populate()` use to populate documents.\n\n## Populating across multiple levels\n\nSay you have a user schema which keeps track of the user's friends.\n\n``` javascript\nconst userSchema = new Schema({\n  name: String,\n  friends: [{ type: ObjectId, ref: 'User' }]\n});\n```\n\nPopulate lets you get a list of a user's friends, but what if you also wanted a user's friends of friends? Specify the `populate` option to tell mongoose to populate the `friends` array of all the user's friends:\n\n``` javascript\nawait User.\n  findOne({ name: 'Val' }).\n  populate({\n    path: 'friends',\n    // Get friends of friends - populate the 'friends' array for every friend\n    populate: { path: 'friends' }\n  });\n```\n\n## Cross Database Populate\n\nLet's say you have a schema representing events, and a schema representing conversations. Each event has a corresponding conversation thread.\n\n``` javascript\nconst db1 = mongoose.createConnection('mongodb://127.0.0.1:27000/db1');\nconst db2 = mongoose.createConnection('mongodb://127.0.0.1:27001/db2');\n\nconst conversationSchema = new Schema({ numMessages: Number });\nconst Conversation = db2.model('Conversation', conversationSchema);\n\nconst eventSchema = new Schema({\n  name: String,\n  conversation: {\n    type: ObjectId,\n    ref: Conversation // `ref` is a **Model class**, not a string\n  }\n});\nconst Event = db1.model('Event', eventSchema);\n```\n\nIn the above example, events and conversations are stored in separate MongoDB databases. String `ref` will not work in this situation, because Mongoose assumes a string `ref` refers to a model name on the same connection. In the above example, the conversation model is registered on `db2`, not `db1`.\n\n``` javascript\n// Works\nconst events = await Event.\n  find().\n  populate('conversation');\n```\n\nThis is known as a \"cross-database populate,\" because it enables you to populate across MongoDB databases and even across MongoDB instances.\n\nIf you don't have access to the model instance when defining your `eventSchema`, you can also pass [the model instance as an option to `populate()`](api/model#model_Model-populate).\n\n``` javascript\nconst events = await Event.\n  find().\n  // The `model` option specifies the model to use for populating.\n  populate({ path: 'conversation', model: Conversation });\n```\n\n## Dynamic References via `refPath`\n\nMongoose can also populate from multiple collections based on the value of a property in the document. Let's say you're building a schema for storing comments. A user may comment on either a blog post or a product.\n\n``` javascript\nconst commentSchema = new Schema({\n  body: { type: String, required: true },\n  doc: {\n    type: Schema.Types.ObjectId,\n    required: true,\n    // Instead of a hardcoded model name in `ref`, `refPath` means Mongoose\n    // will look at the `docModel` property to find the right model.\n    refPath: 'docModel'\n  },\n  docModel: {\n    type: String,\n    required: true,\n    enum: ['BlogPost', 'Product']\n  }\n});\n\nconst Product = mongoose.model('Product', new Schema({ name: String }));\nconst BlogPost = mongoose.model('BlogPost', new Schema({ title: String }));\nconst Comment = mongoose.model('Comment', commentSchema);\n```\n\nThe `refPath` option is a more sophisticated alternative to `ref`. If `ref` is a string, Mongoose will always query the same model to find the populated subdocs. With `refPath`, you can configure what model Mongoose uses for each document.\n\n``` javascript\nconst book = await Product.create({ name: 'The Count of Monte Cristo' });\nconst post = await BlogPost.create({ title: 'Top 10 French Novels' });\n\nconst commentOnBook = await Comment.create({\n  body: 'Great read',\n  doc: book._id,\n  docModel: 'Product'\n});\n\nconst commentOnPost = await Comment.create({\n  body: 'Very informative',\n  doc: post._id,\n  docModel: 'BlogPost'\n});\n\n// The below `populate()` works even though one comment references the\n// 'Product' collection and the other references the 'BlogPost' collection.\nconst comments = await Comment.find().populate('doc').sort({ body: 1 });\ncomments[0].doc.name; // \"The Count of Monte Cristo\"\ncomments[1].doc.title; // \"Top 10 French Novels\"\n```\n\nAn alternative approach is to define separate `blogPost` and `product` properties on `commentSchema`, and then `populate()` on both properties.\n\n``` javascript\nconst commentSchema = new Schema({\n  body: { type: String, required: true },\n  product: {\n    type: Schema.Types.ObjectId,\n    required: true,\n    ref: 'Product'\n  },\n  blogPost: {\n    type: Schema.Types.ObjectId,\n    required: true,\n    ref: 'BlogPost'\n  }\n});\n\n// ...\n\n// The below `populate()` is equivalent to the `refPath` approach, you\n// just need to make sure you `populate()` both `product` and `blogPost`.\nconst comments = await Comment.find().\n  populate('product').\n  populate('blogPost').\n  sort({ body: 1 });\ncomments[0].product.name; // \"The Count of Monte Cristo\"\ncomments[1].blogPost.title; // \"Top 10 French Novels\"\n```\n\nDefining separate `blogPost` and `product` properties works for this simple example. But, if you decide to allow users to also comment on articles or other comments, you'll need to add more properties to your schema. You'll also need an extra `populate()` call for every property, unless you use [mongoose-autopopulate](https://www.npmjs.com/package/mongoose-autopopulate). Using `refPath` means you only need 2 schema paths and one `populate()` call regardless of how many models your `commentSchema` can point to.\n\n## Populate Virtuals\n\nSo far you've only populated based on the `_id` field. However, that's sometimes not the right choice. For example, suppose you have 2 models: `Author` and `BlogPost`.\n\n``` javascript\nconst AuthorSchema = new Schema({\n  name: String,\n  posts: [{ type: mongoose.Schema.Types.ObjectId, ref: 'BlogPost' }]\n});\n\nconst BlogPostSchema = new Schema({\n  title: String,\n  comments: [{\n    author: { type: mongoose.Schema.Types.ObjectId, ref: 'Author' },\n    content: String\n  }]\n});\n\nconst Author = mongoose.model('Author', AuthorSchema, 'Author');\nconst BlogPost = mongoose.model('BlogPost', BlogPostSchema, 'BlogPost');\n```\n\nThe above is an example of **bad schema design**. Why? Suppose you have an extremely prolific author that writes over 10k blog posts. That `author` document will be huge, over 12kb, and large documents lead to performance issues on both server and client. The [Principle of Least Cardinality](https://dev.to/swyx/4-things-i-learned-from-mastering-mongoose-js-25e#4-principle-of-least-cardinality) states that one-to-many relationships, like author to blog post, should be stored on the \"many\" side. In other words, blog posts should store their `author`, authors should **not** store all their `posts`.\n\n``` javascript\nconst AuthorSchema = new Schema({\n  name: String\n});\n\nconst BlogPostSchema = new Schema({\n  title: String,\n  author: { type: mongoose.Schema.Types.ObjectId, ref: 'Author' },\n  comments: [{\n    author: { type: mongoose.Schema.Types.ObjectId, ref: 'Author' },\n    content: String\n  }]\n});\n```\n\nUnfortunately, these two schemas, as written, don't support populating an author's list of blog posts. That's where *virtual populate* comes in. Virtual populate means calling `populate()` on a virtual property that has a `ref` option as shown below.\n\n``` javascript\n// Specifying a virtual with a `ref` property is how you enable virtual\n// population\nAuthorSchema.virtual('posts', {\n  ref: 'BlogPost',\n  localField: '_id',\n  foreignField: 'author'\n});\n\nconst Author = mongoose.model('Author', AuthorSchema, 'Author');\nconst BlogPost = mongoose.model('BlogPost', BlogPostSchema, 'BlogPost');\n```\n\nYou can then `populate()` the author's `posts` as shown below.\n\n``` javascript\nconst author = await Author.findOne().populate('posts');\n\nauthor.posts[0].title; // Title of the first blog post\n```\n\nKeep in mind that virtuals are *not* included in `toJSON()` and `toObject()` output by default. If you want populate virtuals to show up when using functions like Express' [`res.json()` function](https://masteringjs.io/tutorials/express/json) or `console.log()`, set the `virtuals: true` option on your schema's `toJSON` and `toObject()` options.\n\n``` javascript\nconst authorSchema = new Schema({ name: String }, {\n  toJSON: { virtuals: true }, // So `res.json()` and other `JSON.stringify()` functions include virtuals\n  toObject: { virtuals: true } // So `console.log()` and other functions that use `toObject()` include virtuals\n});\n```\n\nIf you're using populate projections, make sure `foreignField` is included in the projection.\n\n``` javascript\nlet authors = await Author.\n  find({}).\n  // Won't work because the foreign field `author` is not selected\n  populate({ path: 'posts', select: 'title' }).\n  exec();\n\nauthors = await Author.\n  find({}).\n  // Works, foreign field `author` is selected\n  populate({ path: 'posts', select: 'title author' }).\n  exec();\n```\n\n## Populate Virtuals: The Count Option\n\nPopulate virtuals also support counting the number of documents with matching `foreignField` as opposed to the documents themselves. Set the `count` option on your virtual:\n\n``` javascript\nconst PersonSchema = new Schema({\n  name: String,\n  band: String\n});\n\nconst BandSchema = new Schema({\n  name: String\n});\nBandSchema.virtual('numMembers', {\n  ref: 'Person', // The model to use\n  localField: 'name', // Find people where `localField`\n  foreignField: 'band', // is equal to `foreignField`\n  count: true // And only get the number of docs\n});\n\n// Later\nconst doc = await Band.findOne({ name: 'Motley Crue' }).\n  populate('numMembers');\ndoc.numMembers; // 2\n```\n\n## Populate Virtuals: The Match Option\n\nAnother option for Populate virtuals is `match`. This option adds an extra filter condition to the query Mongoose uses to `populate()`:\n\n``` javascript\n// Same example as 'Populate Virtuals' section\nAuthorSchema.virtual('posts', {\n  ref: 'BlogPost',\n  localField: '_id',\n  foreignField: 'author',\n  match: { archived: false } // match option with basic query selector\n});\n\nconst Author = mongoose.model('Author', AuthorSchema, 'Author');\nconst BlogPost = mongoose.model('BlogPost', BlogPostSchema, 'BlogPost');\n\n// After population\nconst author = await Author.findOne().populate('posts');\n\nauthor.posts; // Array of not `archived` posts\n```\n\nYou can also set the `match` option to a function. That allows configuring the `match` based on the document being populated. For example, suppose you only want to populate blog posts whose `tags` contain one of the author's `favoriteTags`.\n\n``` javascript\nAuthorSchema.virtual('posts', {\n  ref: 'BlogPost',\n  localField: '_id',\n  foreignField: 'author',\n  // Add an additional filter `{ tags: author.favoriteTags }` to the populate query\n  // Mongoose calls the `match` function with the document being populated as the\n  // first argument.\n  match: author => ({ tags: author.favoriteTags })\n});\n```\n\nYou can overwrite the `match` option when calling `populate()` as follows.\n\n``` javascript\n// Overwrite the `match` option specified in `AuthorSchema.virtual()` for this\n// single `populate()` call.\nawait Author.findOne().populate({ path: posts, match: {} });\n```\n\nYou can also set the `match` option to a function in your `populate()` call. If you want to merge your `populate()` match option, rather than overwriting, use the following.\n\n``` javascript\nawait Author.findOne().populate({\n  path: posts,\n  // Add `isDeleted: false` to the virtual's default `match`, so the `match`\n  // option would be `{ tags: author.favoriteTags, isDeleted: false }`\n  match: (author, virtual) => ({\n    ...virtual.options.match(author),\n    isDeleted: false\n  })\n});\n```\n\n## Populating Maps\n\n[Maps](schematypes#maps) are a type that represents an object with arbitrary string keys. For example, in the below schema, `members` is a map from strings to ObjectIds.\n\n``` javascript\nconst BandSchema = new Schema({\n  name: String,\n  members: {\n    type: Map,\n    of: {\n      type: 'ObjectId',\n      ref: 'Person'\n    }\n  }\n});\nconst Band = mongoose.model('Band', bandSchema);\n```\n\nThis map has a `ref`, which means you can use `populate()` to populate all the ObjectIds in the map. Suppose you have the below `band` document:\n\n``` javascript\nconst person1 = new Person({ name: 'Vince Neil' });\nconst person2 = new Person({ name: 'Mick Mars' });\n\nconst band = new Band({\n  name: 'Motley Crue',\n  members: {\n    singer: person1._id,\n    guitarist: person2._id\n  }\n});\n```\n\nYou can `populate()` every element in the map by populating the special path `members.$*`. `$*` is a special syntax that tells Mongoose to look at every key in the map.\n\n``` javascript\nconst band = await Band.findOne({ name: 'Motley Crue' }).populate('members.$*');\n\nband.members.get('singer'); // { _id: ..., name: 'Vince Neil' }\n```\n\nYou can also populate paths in maps of subdocuments using `$*`. For example, suppose you have the below `librarySchema`:\n\n``` javascript\nconst librarySchema = new Schema({\n  name: String,\n  books: {\n    type: Map,\n    of: new Schema({\n      title: String,\n      author: {\n        type: 'ObjectId',\n        ref: 'Person'\n      }\n    })\n  }\n});\nconst Library = mongoose.model('Library', librarySchema);\n```\n\nYou can `populate()` every book's author by populating `books.$*.author`:\n\n``` javascript\nconst libraries = await Library.find().populate('books.$*.author');\n```\n\n## Populate in Middleware\n\nYou can populate in either pre or post [hooks](http://mongoosejs.com/docs/middleware.html). If you want to always populate a certain field, check out the [mongoose-autopopulate plugin](http://npmjs.com/package/mongoose-autopopulate).\n\n``` javascript\n// Always attach `populate()` to `find()` calls\nMySchema.pre('find', function() {\n  this.populate('user');\n});\n```\n\n``` javascript\n// Always `populate()` after `find()` calls. Useful if you want to selectively populate\n// based on the docs found.\nMySchema.post('find', async function(docs) {\n  for (const doc of docs) {\n    if (doc.isPublic) {\n      await doc.populate('user');\n    }\n  }\n});\n```\n\n``` javascript\n// `populate()` after saving. Useful for sending populated data back to the client in an\n// update API endpoint\nMySchema.post('save', function(doc, next) {\n  doc.populate('user').then(function() {\n    next();\n  });\n});\n```\n\n## Populating Multiple Paths in Middleware\n\nPopulating multiple paths in middleware can be helpful when you always want to populate some fields. But, the implementation is just a tiny bit trickier than what you may think. Here's how you may expect it to work:\n\n``` javascript\nconst userSchema = new Schema({\n  email: String,\n  password: String,\n  followers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],\n  following: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }]\n});\n\nuserSchema.pre('find', function(next) {\n  this.populate('followers following');\n  next();\n});\n\nconst User = mongoose.model('User', userSchema);\n```\n\nHowever, this will not work. By default, passing multiple paths to `populate()` in the middleware will trigger an infinite recursion, which means that it will basically trigger the same middleware for all of the paths provided to the `populate()` method - For example, `this.populate('followers following')` will trigger the same middleware for both `followers` and `following` fields and the request will just be left hanging in an infinite loop.\n\nTo avoid this, we have to add the `_recursed` option, so that our middleware will avoid populating recursively. The example below will make it work as expected.\n\n``` javascript\nuserSchema.pre('find', function(next) {\n  if (this.options._recursed) {\n    return next();\n  }\n  this.populate({ path: 'followers following', options: { _recursed: true } });\n  next();\n});\n```\n\nAlternatively, you can check out the [mongoose-autopopulate plugin](http://npmjs.com/package/mongoose-autopopulate).\n\n## Transform populated documents\n\nYou can manipulate populated documents using the `transform` option. If you specify a `transform` function, Mongoose will call this function on every populated document in the result with two arguments: the populated document, and the original id used to populate the document. This gives you more control over the result of the `populate()` execution. It is especially useful when you're populating multiple documents.\n\nThe [original motivation](https://github.com/Automattic/mongoose/issues/3775) for the `transform` option was to give the ability to leave the unpopulated `_id` if no document was found, instead of setting the value to `null`:\n\n``` javascript\n// With `transform`\ndoc = await Parent.findById(doc).populate([\n  {\n    path: 'child',\n    // If `doc` is null, use the original id instead\n    transform: (doc, id) => doc == null ? id : doc\n  }\n]);\n\ndoc.child; // 634d1a5744efe65ae09142f9\ndoc.children; // [ 634d1a67ac15090a0ca6c0ea, { _id: 634d1a4ddb804d17d95d1c7f, name: 'Luke', __v: 0 } ]\n```\n\nYou can return any value from `transform()`. For example, you can use `transform()` to \"flatten\" populated documents as follows.\n\n``` javascript\nlet doc = await Parent.create({ children: [{ name: 'Luke' }, { name: 'Leia' }] });\n\ndoc = await Parent.findById(doc).populate([{\n  path: 'children',\n  transform: doc => doc == null ? null : doc.name\n}]);\n\ndoc.children; // ['Luke', 'Leia']\n```\n\nAnother use case for `transform()` is setting `$locals` values on populated documents to pass parameters to getters and virtuals. For example, suppose you want to set a language code on your document for internationalization purposes as follows.\n\n``` javascript\nconst internationalizedStringSchema = new Schema({\n  en: String,\n  es: String\n});\n\nconst ingredientSchema = new Schema({\n  // Instead of setting `name` to just a string, set `name` to a map\n  // of language codes to strings.\n  name: {\n    type: internationalizedStringSchema,\n    // When you access `name`, pull the document's locale\n    get: function(value) {\n      return value[this.$locals.language || 'en'];\n    }\n  }\n});\n\nconst recipeSchema = new Schema({\n  ingredients: [{ type: mongoose.ObjectId, ref: 'Ingredient' }]\n});\n\nconst Ingredient = mongoose.model('Ingredient', ingredientSchema);\nconst Recipe = mongoose.model('Recipe', recipeSchema);\n```\n\nYou can set the language code on all populated exercises as follows:\n\n``` javascript\n// Create some sample data\nconst { _id } = await Ingredient.create({\n  name: {\n    en: 'Eggs',\n    es: 'Huevos'\n  }\n});\nawait Recipe.create({ ingredients: [_id] });\n\n// Populate with setting `$locals.language` for internationalization\nconst language = 'es';\nconst recipes = await Recipe.find().populate({\n  path: 'ingredients',\n  transform: function(doc) {\n    doc.$locals.language = language;\n    return doc;\n  }\n});\n\n// Gets the ingredient's name in Spanish `name.es`\nrecipes[0].ingredients[0].name; // 'Huevos'\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/populate.html](https://mongoosejs.com/docs/populate.html)"
- name: Promises
  id: promises
  summary: Mongoose async operations, like .save() and queries, return thenables
  description: "# Promises\n\n## Built-in Promises\n\nMongoose async operations, like `.save()` and queries, return thenables. This means that you can do things like `MyModel.findOne({}).then()` and `await MyModel.findOne({}).exec()` if you're using [async/await](http://thecodebarbarian.com/80-20-guide-to-async-await-in-node.js.html).\n\nYou can find the return type of specific operations [in the api docs](api/mongoose) You can also read more about [promises in Mongoose](https://masteringjs.io/tutorials/mongoose/promise).\n\n``` javascript\nconst gnr = new Band({\n  name: 'Guns N\\' Roses',\n  members: ['Axl', 'Slash']\n});\n\nconst promise = gnr.save();\nassert.ok(promise instanceof Promise);\n\npromise.then(function(doc) {\n  assert.equal(doc.name, 'Guns N\\' Roses');\n});\n```\n\n## Queries are not promises\n\n[Mongoose queries](http://mongoosejs.com/docs/queries.html) are **not** promises. They have a `.then()` function for [co](https://www.npmjs.com/package/co) and async/await as a convenience. If you need a fully-fledged promise, use the `.exec()` function.\n\n``` javascript\nconst query = Band.findOne({ name: 'Guns N\\' Roses' });\nassert.ok(!(query instanceof Promise));\n\n// A query is not a fully-fledged promise, but it does have a `.then()`.\nquery.then(function(doc) {\n  // use doc\n});\n\n// `.exec()` gives you a fully-fledged promise\nconst promise = Band.findOne({ name: 'Guns N\\' Roses' }).exec();\nassert.ok(promise instanceof Promise);\n\npromise.then(function(doc) {\n  // use doc\n});\n```\n\n## Queries are thenable\n\nAlthough queries are not promises, queries are [thenables](https://promisesaplus.com/#terminology). That means they have a `.then()` function, so you can use queries as promises with either promise chaining or [async await](https://asyncawait.net)\n\n``` javascript\nBand.findOne({ name: 'Guns N\\' Roses' }).then(function(doc) {\n  // use doc\n});\n```\n\n## Should You Use `exec()` With `await`?\n\nThere are two alternatives for using `await` with queries:\n\n- `await Band.findOne();`\n- `await Band.findOne().exec();`\n\nAs far as functionality is concerned, these two are equivalent. However, we recommend using `.exec()` because that gives you better stack traces.\n\n``` javascript\nconst doc = await Band.findOne({ name: 'Guns N\\' Roses' }); // works\n\nconst badId = 'this is not a valid id';\ntry {\n  await Band.findOne({ _id: badId });\n} catch (err) {\n  // Without `exec()`, the stack trace does **not** include the\n  // calling code. Below is the stack trace:\n  //\n  // CastError: Cast to ObjectId failed for value \"this is not a valid id\" at path \"_id\" for model \"band-promises\"\n  //   at new CastError (/app/node_modules/mongoose/lib/error/cast.js:29:11)\n  //   at model.Query.exec (/app/node_modules/mongoose/lib/query.js:4331:21)\n  //   at model.Query.Query.then (/app/node_modules/mongoose/lib/query.js:4423:15)\n  //   at process._tickCallback (internal/process/next_tick.js:68:7)\n  err.stack;\n}\n\ntry {\n  await Band.findOne({ _id: badId }).exec();\n} catch (err) {\n  // With `exec()`, the stack trace includes where in your code you\n  // called `exec()`. Below is the stack trace:\n  //\n  // CastError: Cast to ObjectId failed for value \"this is not a valid id\" at path \"_id\" for model \"band-promises\"\n  //   at new CastError (/app/node_modules/mongoose/lib/error/cast.js:29:11)\n  //   at model.Query.exec (/app/node_modules/mongoose/lib/query.js:4331:21)\n  //   at Context.<anonymous> (/app/test/index.test.js:138:42)\n  //   at process._tickCallback (internal/process/next_tick.js:68:7)\n  err.stack;\n}\n```\n\n*Want to learn how to check whether your favorite npm modules work with async/await without cobbling together contradictory answers from Google and Stack Overflow? Chapter 4 of Mastering Async/Await explains the basic principles for determining whether frameworks like React and Mongoose support async/await. [Get your copy!](http://asyncawait.net/?utm_source=mongoosejs&utm_campaign=promises)*  \n  \n[](http://asyncawait.net/?utm_source=mongoosejs&utm_campaign=promises)\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/promises.html](https://mongoosejs.com/docs/promises.html)"
- name: Queries
  id: queries
  summary: Mongoose models provide several static helper functions for CRUD operations
  description: "# Queries\n\nMongoose [models](models) provide several static helper functions for [CRUD operations](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete). Each of these functions returns a [mongoose `Query` object](api/query#Query).\n\n- [`Model.deleteMany()`](https://mongoosejs.com/docs/api.html#model_Model-deleteMany)\n- [`Model.deleteOne()`](https://mongoosejs.com/docs/api.html#model_Model-deleteOne)\n- [`Model.find()`](https://mongoosejs.com/docs/api.html#model_Model-find)\n- [`Model.findById()`](https://mongoosejs.com/docs/api.html#model_Model-findById)\n- [`Model.findByIdAndDelete()`](https://mongoosejs.com/docs/api.html#model_Model-findByIdAndDelete)\n- [`Model.findByIdAndRemove()`](https://mongoosejs.com/docs/api.html#model_Model-findByIdAndRemove)\n- [`Model.findByIdAndUpdate()`](https://mongoosejs.com/docs/api.html#model_Model-findByIdAndUpdate)\n- [`Model.findOne()`](https://mongoosejs.com/docs/api.html#model_Model-findOne)\n- [`Model.findOneAndDelete()`](https://mongoosejs.com/docs/api.html#model_Model-findOneAndDelete)\n- [`Model.findOneAndRemove()`](https://mongoosejs.com/docs/api.html#model_Model-findOneAndRemove)\n- [`Model.findOneAndReplace()`](https://mongoosejs.com/docs/api.html#model_Model-findOneAndReplace)\n- [`Model.findOneAndUpdate()`](https://mongoosejs.com/docs/api.html#model_Model-findOneAndUpdate)\n- [`Model.replaceOne()`](https://mongoosejs.com/docs/api.html#model_Model-replaceOne)\n- [`Model.updateMany()`](https://mongoosejs.com/docs/api.html#model_Model-updateMany)\n- [`Model.updateOne()`](https://mongoosejs.com/docs/api.html#model_Model-updateOne)\n\nA mongoose query can be executed in one of two ways. First, if you pass in a `callback` function, Mongoose will execute the query asynchronously and pass the results to the `callback`.\n\nA query also has a `.then()` function, and thus can be used as a promise.\n\n## Executing\n\nWhen executing a query, you specify your query as a JSON document. The JSON document's syntax is the same as the [MongoDB shell](http://www.mongodb.com/docs/manual/tutorial/query-documents/).\n\n``` javascript\nconst Person = mongoose.model('Person', yourSchema);\n\n// find each person with a last name matching 'Ghost', selecting the `name` and `occupation` fields\nconst person = await Person.findOne({ 'name.last': 'Ghost' }, 'name occupation');\n// Prints \"Space Ghost is a talk show host\".\nconsole.log('%s %s is a %s.', person.name.first, person.name.last, person.occupation);\n```\n\nWhat `person` is depends on the operation: For `findOne()` it is a [potentially-null single document](api/model#model_Model-findOne), `find()` a [list of documents](api/model#model_Model-find), `count()` [the number of documents](api/model#model_Model-count), `update()` the [number of documents affected](api/model#model_Model-update), etc. The [API docs for Models](api/model) provide more details.\n\nNow let's look at what happens when no `await` is used:\n\n``` javascript\n// find each person with a last name matching 'Ghost'\nconst query = Person.findOne({ 'name.last': 'Ghost' });\n\n// selecting the `name` and `occupation` fields\nquery.select('name occupation');\n\n// execute the query at a later time\nconst person = await query.exec();\n// Prints \"Space Ghost is a talk show host.\"\nconsole.log('%s %s is a %s.', person.name.first, person.name.last, person.occupation);\n```\n\nIn the above code, the `query` variable is of type [Query](api/query). A `Query` enables you to build up a query using chaining syntax, rather than specifying a JSON object. The below 2 examples are equivalent.\n\n``` javascript\n// With a JSON doc\nawait Person.\n  find({\n    occupation: /host/,\n    'name.last': 'Ghost',\n    age: { $gt: 17, $lt: 66 },\n    likes: { $in: ['vaporizing', 'talking'] }\n  }).\n  limit(10).\n  sort({ occupation: -1 }).\n  select({ name: 1, occupation: 1 }).\n  exec();\n\n// Using query builder\nawait Person.\n  find({ occupation: /host/ }).\n  where('name.last').equals('Ghost').\n  where('age').gt(17).lt(66).\n  where('likes').in(['vaporizing', 'talking']).\n  limit(10).\n  sort('-occupation').\n  select('name occupation').\n  exec();\n```\n\nA full list of [Query helper functions can be found in the API docs](api/query).\n\n## Queries are Not Promises\n\nMongoose queries are **not** promises. Queries are [thenables](https://masteringjs.io/tutorials/fundamentals/thenable), meaning they have a `.then()` method for [async/await](http://thecodebarbarian.com/common-async-await-design-patterns-in-node.js.html) as a convenience. However, unlike promises, calling a query's `.then()` executes the query, so calling `then()` multiple times will throw an error.\n\n``` javascript\nconst q = MyModel.updateMany({}, { isDeleted: true });\n\nawait q.then(() => console.log('Update 2'));\n// Throws \"Query was already executed: Test.updateMany({}, { isDeleted: true })\"\nawait q.then(() => console.log('Update 3'));\n```\n\n## References to other documents\n\nThere are no joins in MongoDB but sometimes we still want references to documents in other collections. This is where [population](populate) comes in. Read more about how to include documents from other collections in your query results [here](api/query#query_Query-populate).\n\n## Streaming\n\nYou can [stream](http://nodejs.org/api/stream.html) query results from MongoDB. You need to call the [Query#cursor()](api/query#query_Query-cursor) function to return an instance of [QueryCursor](api/query#query_Query-cursor).\n\n``` javascript\nconst cursor = Person.find({ occupation: /host/ }).cursor();\n\nfor (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {\n  console.log(doc); // Prints documents one at a time\n}\n```\n\nIterating through a Mongoose query using [async iterators](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js.html) also creates a cursor.\n\n``` javascript\nfor await (const doc of Person.find()) {\n  console.log(doc); // Prints documents one at a time\n}\n```\n\nCursors are subject to [cursor timeouts](https://stackoverflow.com/questions/21853178/when-a-mongodb-cursor-will-expire). By default, MongoDB will close your cursor after 10 minutes and subsequent `next()` calls will result in a `MongoServerError: cursor id 123 not found` error. To override this, set the `noCursorTimeout` option on your cursor.\n\n``` javascript\n// MongoDB won't automatically close this cursor after 10 minutes.\nconst cursor = Person.find().cursor().addCursorFlag('noCursorTimeout', true);\n```\n\nHowever, cursors can still time out because of [session idle timeouts](https://www.mongodb.com/docs/manual/reference/method/cursor.noCursorTimeout/#session-idle-timeout-overrides-nocursortimeout). So even a cursor with `noCursorTimeout` set will still time out after 30 minutes of inactivity. You can read more about working around session idle timeouts in the [MongoDB documentation](https://www.mongodb.com/docs/manual/reference/method/cursor.noCursorTimeout/#session-idle-timeout-overrides-nocursortimeout).\n\n## Versus Aggregation\n\n[Aggregation](api/aggregate#aggregate_Aggregate) can do many of the same things that queries can. For example, below is how you can use `aggregate()` to find docs where `name.last = 'Ghost'`:\n\n``` javascript\nconst docs = await Person.aggregate([{ $match: { 'name.last': 'Ghost' } }]);\n```\n\nHowever, just because you can use `aggregate()` doesn't mean you should. In general, you should use queries where possible, and only use `aggregate()` when you absolutely need to.\n\nUnlike query results, Mongoose does **not** [`hydrate()`](api/model#model_Model-hydrate) aggregation results. Aggregation results are always POJOs, not Mongoose documents.\n\n``` javascript\nconst docs = await Person.aggregate([{ $match: { 'name.last': 'Ghost' } }]);\n\ndocs[0] instanceof mongoose.Document; // false\n```\n\nAlso, unlike query filters, Mongoose also doesn't [cast](tutorials/query_casting) aggregation pipelines. That means you're responsible for ensuring the values you pass in to an aggregation pipeline have the correct type.\n\n``` javascript\nconst doc = await Person.findOne();\n\nconst idString = doc._id.toString();\n\n// Finds the `Person`, because Mongoose casts `idString` to an ObjectId\nconst queryRes = await Person.findOne({ _id: idString });\n\n// Does **not** find the `Person`, because Mongoose doesn't cast aggregation\n// pipelines.\nconst aggRes = await Person.aggregate([{ $match: { _id: idString } }]);\n```\n\n## Sorting\n\n[Sorting](https://mongoosejs.com/docs/api.html#query_Query-sort) is how you can ensure you query results come back in the desired order.\n\n``` javascript\nconst personSchema = new mongoose.Schema({\n  age: Number\n});\n\nconst Person = mongoose.model('Person', personSchema);\nfor (let i = 0; i < 10; i++) {\n  await Person.create({ age: i });\n}\n\nawait Person.find().sort({ age: -1 }); // returns age starting from 10 as the first entry\nawait Person.find().sort({ age: 1 }); // returns age starting from 0 as the first entry\n```\n\nWhen sorting with mutiple fields, the order of the sort keys determines what key MongoDB server sorts by first.\n\n``` javascript\nconst personSchema = new mongoose.Schema({\n  age: Number,\n  name: String,\n  weight: Number\n});\n\nconst Person = mongoose.model('Person', personSchema);\nconst iterations = 5;\nfor (let i = 0; i < iterations; i++) {\n  await Person.create({\n    age: Math.abs(2 - i),\n    name: 'Test' + i,\n    weight: Math.floor(Math.random() * 100) + 1\n  });\n}\n\nawait Person.find().sort({ age: 1, weight: -1 }); // returns age starting from 0, but while keeping that order will then sort by weight.\n```\n\nYou can view the output of a single run of this block below. As you can see, age is sorted from 0 to 2 but when age is equal, sorts by weight.\n\n``` javascript\n[\n  {\n    _id: new ObjectId('63a335a6b9b6a7bfc186cb37'),\n    age: 0,\n    name: 'Test2',\n    weight: 67,\n    __v: 0\n  },\n  {\n    _id: new ObjectId('63a335a6b9b6a7bfc186cb35'),\n    age: 1,\n    name: 'Test1',\n    weight: 99,\n    __v: 0\n  },\n  {\n    _id: new ObjectId('63a335a6b9b6a7bfc186cb39'),\n    age: 1,\n    name: 'Test3',\n    weight: 73,\n    __v: 0\n  },\n  {\n    _id: new ObjectId('63a335a6b9b6a7bfc186cb33'),\n    age: 2,\n    name: 'Test0',\n    weight: 65,\n    __v: 0\n  },\n  {\n    _id: new ObjectId('63a335a6b9b6a7bfc186cb3b'),\n    age: 2,\n    name: 'Test4',\n    weight: 62,\n    __v: 0\n  }\n];\n```\n\n## Next Up\n\nNow that we've covered `Queries`, let's take a look at [Validation](validation).\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/queries.html](https://mongoosejs.com/docs/queries.html)"
- name: Query
  id: api/query
  summary: Query constructor used for building queries
  description: "# Query\n\n### Query()\n\n##### Parameters:\n\n- `[options]` «Object»\n- `[model]` «Object»\n- `[conditions]` «Object»\n- `[collection]` «Object» Mongoose collection\n\nQuery constructor used for building queries. You do not need to instantiate a `Query` directly. Instead use Model functions like [`Model.find()`](model#Model.find()).\n\n#### [Example:](#example)\n\n``` javascript\nconst query = MyModel.find(); // `query` is an instance of `Query`\nquery.setOptions({ lean : true });\nquery.collection(MyModel.collection);\nquery.where('age').gte(21).exec(callback);\n\n// You can instantiate a query directly. There is no need to do\n// this unless you're an advanced user with a very good reason to.\nconst query = new mongoose.Query();\n```\n\n### Query.prototype.$where()\n\n##### Parameters:\n\n- `js` «String\\|Function» javascript string or function\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$where](https://www.mongodb.com/docs/manual/reference/operator/where/)\n\nSpecifies a javascript function or expression to pass to MongoDBs query system.\n\n#### [Example:](#example)\n\n``` javascript\nquery.$where('this.comments.length === 10 || this.name.length === 5')\n\n// or\n\nquery.$where(function () {\n  return this.comments.length === 10 || this.name.length === 5;\n})\n```\n\n#### [Note:](#note)\n\nOnly use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`. **Be sure to read about all of [its caveats](https://www.mongodb.com/docs/manual/reference/operator/where/) before using.**\n\n### Query.prototype.all()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Array»\n\n##### See:\n\n- [$all](https://www.mongodb.com/docs/manual/reference/operator/all/)\n\nSpecifies an `$all` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n#### [Example:](#example)\n\n``` javascript\nMyModel.find().where('pets').all(['dog', 'cat', 'ferret']);\n// Equivalent:\nMyModel.find().all('pets', ['dog', 'cat', 'ferret']);\n```\n\n### Query.prototype.allowDiskUse()\n\n##### Parameters:\n\n- `[v]` «Boolean» Enable/disable `allowDiskUse`. If called with 0 arguments, sets `allowDiskUse: true`\n\n##### Returns:\n\n- «Query» this\n\nSets the [`allowDiskUse` option](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/), which allows the MongoDB server to use more than 100 MB for this query's `sort()`. This option can let you work around `QueryExceededMemoryLimitNoDiskUseAllowed` errors from the MongoDB server.\n\nNote that this option requires MongoDB server \\>= 4.4. Setting this option is a no-op for MongoDB 4.2 and earlier.\n\nCalling `query.allowDiskUse(v)` is equivalent to `query.setOptions({ allowDiskUse: v })`\n\n#### [Example:](#example)\n\n``` javascript\nawait query.find().sort({ name: 1 }).allowDiskUse(true);\n// Equivalent:\nawait query.find().sort({ name: 1 }).allowDiskUse();\n```\n\n### Query.prototype.and()\n\n##### Parameters:\n\n- `array` «Array» array of conditions\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$and](https://www.mongodb.com/docs/manual/reference/operator/and/)\n\nSpecifies arguments for a `$and` condition.\n\n#### [Example:](#example)\n\n``` javascript\nquery.and([{ color: 'green' }, { status: 'ok' }])\n```\n\n### Query.prototype.batchSize()\n\n##### Parameters:\n\n- `val` «Number»\n\n##### See:\n\n- [batchSize](https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/)\n\nSpecifies the batchSize option.\n\n#### [Example:](#example)\n\n``` javascript\nquery.batchSize(100)\n```\n\n#### [Note:](#note)\n\nCannot be used with `distinct()`\n\n### Query.prototype.box()\n\n##### Parameters:\n\n- `val1` «Object\\|Array\\<Number\\>» Lower Left Coordinates OR a object of lower-left(ll) and upper-right(ur) Coordinates\n- `[val2]` «Array\\<Number\\>» Upper Right Coordinates\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$box](https://www.mongodb.com/docs/manual/reference/operator/box/)\n- [within() Query#within](#Query.prototype.within())\n- [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)\n\nSpecifies a `$box` condition\n\n#### [Example:](#example)\n\n``` javascript\nconst lowerLeft = [40.73083, -73.99756]\nconst upperRight= [40.741404,  -73.988135]\n\nquery.where('loc').within().box(lowerLeft, upperRight)\nquery.box({ ll : lowerLeft, ur : upperRight })\n```\n\n### Query.prototype.cast()\n\n##### Parameters:\n\n- `[model]` «Model» the model to cast to. If not set, defaults to `this.model`\n- `[obj]` «Object»\n\n##### Returns:\n\n- «Object»\n\nCasts this query to the schema of `model`\n\n#### [Note:](#note)\n\nIf `obj` is present, it is cast instead of this query.\n\n### Query.prototype.catch()\n\n##### Parameters:\n\n- `[reject]` «Function»\n\n##### Returns:\n\n- «Promise»\n\nExecutes the query returning a `Promise` which will be resolved with either the doc(s) or rejected with the error. Like `.then()`, but only takes a rejection handler.\n\nMore about [Promise `catch()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/catch).\n\n### Query.prototype.center()\n\n~DEPRECATED~\n\n*DEPRECATED* Alias for [circle](#Query.prototype.circle())\n\n**Deprecated.** Use [circle](#Query.prototype.circle()) instead.\n\n### Query.prototype.centerSphere()\n\n~DEPRECATED~\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Object»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)\n- [$centerSphere](https://www.mongodb.com/docs/manual/reference/operator/centerSphere/)\n\n*DEPRECATED* Specifies a `$centerSphere` condition\n\n**Deprecated.** Use [circle](#Query.prototype.circle()) instead.\n\n#### [Example:](#example)\n\n``` javascript\nconst area = { center: [50, 50], radius: 10 };\nquery.where('loc').within().centerSphere(area);\n```\n\n### Query.prototype.circle()\n\n##### Parameters:\n\n- `[path]` «String»\n- `area` «Object»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$center](https://www.mongodb.com/docs/manual/reference/operator/center/)\n- [$centerSphere](https://www.mongodb.com/docs/manual/reference/operator/centerSphere/)\n- [$geoWithin](https://www.mongodb.com/docs/manual/reference/operator/geoWithin/)\n- [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)\n\nSpecifies a `$center` or `$centerSphere` condition.\n\n#### [Example:](#example)\n\n``` javascript\nconst area = { center: [50, 50], radius: 10, unique: true }\nquery.where('loc').within().circle(area)\n// alternatively\nquery.circle('loc', area);\n\n// spherical calculations\nconst area = { center: [50, 50], radius: 10, unique: true, spherical: true }\nquery.where('loc').within().circle(area)\n// alternatively\nquery.circle('loc', area);\n```\n\n### Query.prototype.clone()\n\n##### Returns:\n\n- «Query» copy\n\nMake a copy of this query so you can re-execute it.\n\n#### [Example:](#example)\n\n``` javascript\nconst q = Book.findOne({ title: 'Casino Royale' });\nawait q.exec();\nawait q.exec(); // Throws an error because you can't execute a query twice\n\nawait q.clone().exec(); // Works\n```\n\n### Query.prototype.collation()\n\n##### Parameters:\n\n- `value` «Object»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [MongoDB docs](https://www.mongodb.com/docs/manual/reference/method/cursor.collation/#cursor.collation)\n\nAdds a collation to this op (MongoDB 3.4 and up)\n\n### Query.prototype.comment()\n\n##### Parameters:\n\n- `val` «String»\n\n##### See:\n\n- [comment](https://www.mongodb.com/docs/manual/reference/operator/comment/)\n\nSpecifies the `comment` option.\n\n#### [Example:](#example)\n\n``` javascript\nquery.comment('login query')\n```\n\n#### [Note:](#note)\n\nCannot be used with `distinct()`\n\n### Query.prototype.count()\n\n~DEPRECATED~\n\n##### Parameters:\n\n- `[filter]` «Object» count documents that match this object\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [count](https://www.mongodb.com/docs/manual/reference/method/db.collection.count/)\n\nSpecifies this query as a `count` query.\n\nThis method is deprecated. If you want to count the number of documents in a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](#Query.prototype.estimatedDocumentCount()) instead. Otherwise, use the [`countDocuments()`](#Query.prototype.countDocuments()) function instead.\n\nThis function triggers the following middleware.\n\n- `count()`\n\n#### [Example:](#example)\n\n``` javascript\nconst countQuery = model.where({ 'color': 'black' }).count();\n\nquery.count({ color: 'black' }).count().exec();\n\nawait query.count({ color: 'black' });\n\nquery.where('color', 'black').count();\n```\n\n### Query.prototype.countDocuments()\n\n##### Parameters:\n\n- `[filter]` «Object» mongodb selector\n- `[options]` «Object»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [countDocuments](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments)\n\nSpecifies this query as a `countDocuments()` query. Behaves like `count()`, except it always does a full collection scan when passed an empty filter `{}`.\n\nThere are also minor differences in how `countDocuments()` handles [`$where` and a couple geospatial operators](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments). versus `count()`.\n\nThis function triggers the following middleware.\n\n- `countDocuments()`\n\n#### [Example:](#example)\n\n``` javascript\nconst countQuery = model.where({ 'color': 'black' }).countDocuments();\n\nquery.countDocuments({ color: 'black' }).count().exec();\n\nawait query.countDocuments({ color: 'black' });\n\nquery.where('color', 'black').countDocuments().exec();\n```\n\nThe `countDocuments()` function is similar to `count()`, but there are a [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments). Below are the operators that `count()` supports but `countDocuments()` does not, and the suggested replacement:\n\n- `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n- `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n- `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n\n### Query.prototype.cursor()\n\n##### Parameters:\n\n- `[options]` «Object»\n\n##### Returns:\n\n- «QueryCursor»\n\n##### See:\n\n- [QueryCursor](querycursor)\n\nReturns a wrapper around a [mongodb driver cursor](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html). A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.\n\nThe `.cursor()` function triggers pre find hooks, but **not** post find hooks.\n\n#### [Example:](#example)\n\n``` javascript\n// There are 2 ways to use a cursor. First, as a stream:\nThing.\n  find({ name: /^hello/ }).\n  cursor().\n  on('data', function(doc) { console.log(doc); }).\n  on('end', function() { console.log('Done!'); });\n\n// Or you can use `.next()` to manually get the next doc in the stream.\n// `.next()` returns a promise, so you can use promises or callbacks.\nconst cursor = Thing.find({ name: /^hello/ }).cursor();\ncursor.next(function(error, doc) {\n  console.log(doc);\n});\n\n// Because `.next()` returns a promise, you can use co\n// to easily iterate through all documents without loading them\n// all into memory.\nconst cursor = Thing.find({ name: /^hello/ }).cursor();\nfor (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {\n  console.log(doc);\n}\n```\n\n#### [Valid options](#valid-options)\n\n- `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.\n\n### Query.prototype.deleteMany()\n\n##### Parameters:\n\n- `[filter]` «Object\\|Query» mongodb selector\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](#Query.prototype.setOptions())\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [DeleteResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html)\n- [deleteMany](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany)\n\nDeclare and/or execute this query as a `deleteMany()` operation. Works like remove, except it deletes *every* document that matches `filter` in the collection, regardless of the value of `single`.\n\nThis function triggers `deleteMany` middleware.\n\n#### [Example:](#example)\n\n``` javascript\nawait Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n```\n\nThis function calls the MongoDB driver's [`Collection#deleteMany()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany). The returned [promise](../queries) resolves to an object that contains 3 properties:\n\n- `ok`: `1` if no errors occurred\n- `deletedCount`: the number of documents deleted\n- `n`: the number of documents deleted. Equal to `deletedCount`.\n\n#### [Example:](#example-1)\n\n``` javascript\nconst res = await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n// `0` if no docs matched the filter, number of docs deleted otherwise\nres.deletedCount;\n```\n\n### Query.prototype.deleteOne()\n\n##### Parameters:\n\n- `[filter]` «Object\\|Query» mongodb selector\n- `[options]` «Object» optional see [`Query.prototype.setOptions()`](#Query.prototype.setOptions())\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [DeleteResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html)\n- [deleteOne](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne)\n\nDeclare and/or execute this query as a `deleteOne()` operation. Works like remove, except it deletes at most one document regardless of the `single` option.\n\nThis function triggers `deleteOne` middleware.\n\n#### [Example:](#example)\n\n``` javascript\nawait Character.deleteOne({ name: 'Eddard Stark' });\n```\n\nThis function calls the MongoDB driver's [`Collection#deleteOne()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne). The returned [promise](../queries) resolves to an object that contains 3 properties:\n\n- `ok`: `1` if no errors occurred\n- `deletedCount`: the number of documents deleted\n- `n`: the number of documents deleted. Equal to `deletedCount`.\n\n#### [Example:](#example-1)\n\n``` javascript\nconst res = await Character.deleteOne({ name: 'Eddard Stark' });\n// `1` if MongoDB deleted a doc, `0` if no docs matched the filter `{ name: ... }`\nres.deletedCount;\n```\n\n### Query.prototype.distinct()\n\n##### Parameters:\n\n- `[field]` «String»\n- `[filter]` «Object\\|Query»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [distinct](https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/)\n\nDeclares or executes a distinct() operation.\n\nThis function does not trigger any middleware.\n\n#### [Example:](#example)\n\n``` javascript\ndistinct(field, conditions)\ndistinct(field)\ndistinct()\n```\n\n### Query.prototype.elemMatch()\n\n##### Parameters:\n\n- `path` «String\\|Object\\|Function»\n- `filter` «Object\\|Function»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$elemMatch](https://www.mongodb.com/docs/manual/reference/operator/elemMatch/)\n\nSpecifies an `$elemMatch` condition\n\n#### [Example:](#example)\n\n``` javascript\nquery.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n\nquery.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n\nquery.elemMatch('comment', function (elem) {\n  elem.where('author').equals('autobot');\n  elem.where('votes').gte(5);\n})\n\nquery.where('comment').elemMatch(function (elem) {\n  elem.where({ author: 'autobot' });\n  elem.where('votes').gte(5);\n})\n```\n\n### Query.prototype.equals()\n\n##### Parameters:\n\n- `val` «Object»\n\n##### Returns:\n\n- «Query» this\n\nSpecifies the complementary comparison value for paths specified with `where()`\n\n#### [Example:](#example)\n\n``` javascript\nUser.where('age').equals(49);\n\n// is the same as\n\nUser.where('age', 49);\n```\n\n### Query.prototype.error()\n\n##### Parameters:\n\n- `err` «Error\\|null» if set, `exec()` will fail fast before sending the query to MongoDB\n\n##### Returns:\n\n- «Query» this\n\nGets/sets the error flag on this query. If this flag is not null or undefined, the `exec()` promise will reject without executing.\n\n#### [Example:](#example)\n\n``` javascript\nQuery().error(); // Get current error value\nQuery().error(null); // Unset the current error\nQuery().error(new Error('test')); // `exec()` will resolve with test\nSchema.pre('find', function() {\n  if (!this.getQuery().userId) {\n    this.error(new Error('Not allowed to query without setting userId'));\n  }\n});\n```\n\nNote that query casting runs **after** hooks, so cast errors will override custom errors.\n\n#### [Example:](#example-1)\n\n``` javascript\nconst TestSchema = new Schema({ num: Number });\nconst TestModel = db.model('Test', TestSchema);\nTestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {\n  // `error` will be a cast error because `num` failed to cast\n});\n```\n\n### Query.prototype.estimatedDocumentCount()\n\n##### Parameters:\n\n- `[options]` «Object» passed transparently to the [MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/EstimatedDocumentCountOptions.html)\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [estimatedDocumentCount](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount)\n\nSpecifies this query as a `estimatedDocumentCount()` query. Faster than using `countDocuments()` for large collections because `estimatedDocumentCount()` uses collection metadata rather than scanning the entire collection.\n\n`estimatedDocumentCount()` does **not** accept a filter. `Model.find({ foo: bar }).estimatedDocumentCount()` is equivalent to `Model.find().estimatedDocumentCount()`\n\nThis function triggers the following middleware.\n\n- `estimatedDocumentCount()`\n\n#### [Example:](#example)\n\n``` javascript\nawait Model.find().estimatedDocumentCount();\n```\n\n### Query.prototype.exec()\n\n##### Parameters:\n\n- `[operation]` «String\\|Function»\n\n##### Returns:\n\n- «Promise»\n\nExecutes the query\n\n#### [Example:](#example)\n\n``` javascript\nconst promise = query.exec();\nconst promise = query.exec('update');\n```\n\n### Query.prototype.exists()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Boolean»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$exists](https://www.mongodb.com/docs/manual/reference/operator/exists/)\n\nSpecifies an `$exists` condition\n\n#### [Example:](#example)\n\n``` javascript\n// { name: { $exists: true }}\nThing.where('name').exists()\nThing.where('name').exists(true)\nThing.find().exists('name')\n\n// { name: { $exists: false }}\nThing.where('name').exists(false);\nThing.find().exists('name', false);\n```\n\n### Query.prototype.explain()\n\n##### Parameters:\n\n- `[verbose]` «String» The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'\n\n##### Returns:\n\n- «Query» this\n\nSets the [`explain` option](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/), which makes this query return detailed execution stats instead of the actual query result. This method is useful for determining what index your queries use.\n\nCalling `query.explain(v)` is equivalent to `query.setOptions({ explain: v })`\n\n#### [Example:](#example)\n\n``` javascript\nconst query = new Query();\nconst res = await query.find({ a: 1 }).explain('queryPlanner');\nconsole.log(res);\n```\n\n### Query.prototype.finally()\n\n##### Parameters:\n\n- `[onFinally]` «Function»\n\n##### Returns:\n\n- «Promise»\n\nExecutes the query returning a `Promise` which will be resolved with `.finally()` chained.\n\nMore about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n\n### Query.prototype.find()\n\n##### Parameters:\n\n- `[filter]` «Object\\|ObjectId» mongodb filter. If not specified, returns all documents.\n\n##### Returns:\n\n- «Query» this\n\nFind all documents that match `selector`. The result will be an array of documents.\n\nIf there are too many documents in the result to fit in memory, use [`Query.prototype.cursor()`](#Query.prototype.cursor())\n\n#### [Example:](#example)\n\n``` javascript\nconst arr = await Movie.find({ year: { $gte: 1980, $lte: 1989 } });\n```\n\n### Query.prototype.findOne()\n\n##### Parameters:\n\n- `[filter]` «Object» mongodb selector\n- `[projection]` «Object» optional fields to return\n- `[options]` «Object» see [`setOptions()`](#Query.prototype.setOptions())\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [findOne](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/)\n- [Query.select](#Query.prototype.select())\n\nDeclares the query a findOne operation. When executed, the first found document is passed to the callback.\n\nThe result of the query is a single document, or `null` if no document was found.\n\n- *Note:* `conditions` is optional, and if `conditions` is null or undefined, mongoose will send an empty `findOne` command to MongoDB, which will return an arbitrary document. If you're querying by `_id`, use `Model.findById()` instead.\n\nThis function triggers the following middleware.\n\n- `findOne()`\n\n#### [Example:](#example)\n\n``` javascript\nconst query = Kitten.where({ color: 'white' });\nconst kitten = await query.findOne();\n```\n\n### Query.prototype.findOneAndDelete()\n\n##### Parameters:\n\n- `[filter]` «Object»\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [findAndModify command](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)\n\nIssues a MongoDB [findOneAndDelete](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndDelete/) command.\n\nFinds a matching document, removes it, and returns the found document (if any).\n\nThis function triggers the following middleware.\n\n- `findOneAndDelete()`\n\n#### [Available options](#available-options)\n\n- `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n- `maxTimeMS`: puts a time limit on the query - requires mongodb \\>= 2.6.0\n- `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n#### [Callback Signature](#callback-signature)\n\n``` javascript\nfunction(error, doc) {\n  // error: any errors that occurred\n  // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n}\n```\n\n#### [Example:](#example)\n\n``` javascript\nA.where().findOneAndDelete(conditions, options)  // return Query\nA.where().findOneAndDelete(conditions) // returns Query\nA.where().findOneAndDelete()           // returns Query\n```\n\n### Query.prototype.findOneAndRemove()\n\n##### Parameters:\n\n- `[conditions]` «Object»\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [findAndModify command](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)\n\nLegacy alias for `findOneAndDelete()`.\n\nFinds a matching document, removes it, returns the found document (if any).\n\nThis function triggers the following middleware.\n\n- `findOneAndRemove()`\n\n#### [Available options](#available-options)\n\n- `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n- `maxTimeMS`: puts a time limit on the query - requires mongodb \\>= 2.6.0\n- `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n#### [Example:](#example)\n\n``` javascript\nA.where().findOneAndRemove(conditions, options)  // return Query\nA.where().findOneAndRemove(conditions) // returns Query\nA.where().findOneAndRemove()           // returns Query\n```\n\n### Query.prototype.findOneAndReplace()\n\n##### Parameters:\n\n- `[filter]` «Object»\n- `[replacement]` «Object»\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.new=false]` «Boolean» By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n\n&nbsp;\n\n- `[options.lean]` «Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.returnOriginal=null]` «Boolean» An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query» this\n\nIssues a MongoDB [findOneAndReplace](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndReplace/) command.\n\nFinds a matching document, removes it, and returns the found document (if any).\n\nThis function triggers the following middleware.\n\n- `findOneAndReplace()`\n\n#### [Available options](#available-options)\n\n- `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n- `maxTimeMS`: puts a time limit on the query - requires mongodb \\>= 2.6.0\n- `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n#### [Callback Signature](#callback-signature)\n\n``` javascript\nfunction(error, doc) {\n  // error: any errors that occurred\n  // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n}\n```\n\n#### [Example:](#example)\n\n``` javascript\nA.where().findOneAndReplace(filter, replacement, options); // return Query\nA.where().findOneAndReplace(filter); // returns Query\nA.where().findOneAndReplace(); // returns Query\n```\n\n### Query.prototype.findOneAndUpdate()\n\n##### Parameters:\n\n- `[filter]` «Object\\|Query»\n- `[doc]` «Object»\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.rawResult]` «Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.multipleCastError]` «Boolean» by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n\n&nbsp;\n\n- `[options.new=false]` «Boolean» By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n\n&nbsp;\n\n- `[options.lean]` «Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).\n\n&nbsp;\n\n- `[options.session=null]` «ClientSession» The session associated with this query. See [transactions docs](../transactions).\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.returnOriginal=null]` «Boolean» An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [Tutorial](../tutorials/findoneandupdate)\n- [findAndModify command](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)\n- [ModifyResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n- [findOneAndUpdate](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#findOneAndUpdate)\n\nIssues a mongodb `findOneAndUpdate()` command.\n\nFinds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).\n\nThis function triggers the following middleware.\n\n- `findOneAndUpdate()`\n\n#### [Available options](#available-options)\n\n- `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n- `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n- `fields`: {Object\\|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n- `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n- `maxTimeMS`: puts a time limit on the query - requires mongodb \\>= 2.6.0\n- `runValidators`: if true, runs [update validators](../validation#update-validators) on this command. Update validators validate the update operation against the model's schema.\n- `setDefaultsOnInsert`: `true` by default. If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](../defaults) specified in the model's schema if a new document is created.\n- `rawResult`: if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n\n#### [Example:](#example)\n\n``` javascript\nquery.findOneAndUpdate(conditions, update, options)  // returns Query\nquery.findOneAndUpdate(conditions, update)           // returns Query\nquery.findOneAndUpdate(update)                       // returns Query\nquery.findOneAndUpdate()                             // returns Query\n```\n\n### Query.prototype.geometry()\n\n##### Parameters:\n\n- `object` «Object» Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$geometry](https://www.mongodb.com/docs/manual/reference/operator/geometry/)\n- [Geospatial Support Enhancements](https://www.mongodb.com/docs/manual/release-notes/2.4/#geospatial-support-enhancements)\n- [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)\n\nSpecifies a `$geometry` condition\n\n#### [Example:](#example)\n\n``` javascript\nconst polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\nquery.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n\n// or\nconst polyB = [[ 0, 0 ], [ 1, 1 ]]\nquery.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n\n// or\nconst polyC = [ 0, 0 ]\nquery.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n\n// or\nquery.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n```\n\nThe argument is assigned to the most recent path passed to `where()`.\n\n#### [Note:](#note)\n\n`geometry()` **must** come after either `intersects()` or `within()`.\n\nThe `object` argument must contain `type` and `coordinates` properties.\n\n- type {String}\n- coordinates {Array}\n\n### Query.prototype.get()\n\n##### Parameters:\n\n- `path` «String\\|Object» path or object of key/value pairs to get\n\n##### Returns:\n\n- «Query» this\n\nFor update operations, returns the value of a path in the update's `$set`. Useful for writing getters/setters that can work with both update operations and `save()`.\n\n#### [Example:](#example)\n\n``` javascript\nconst query = Model.updateOne({}, { $set: { name: 'Jean-Luc Picard' } });\nquery.get('name'); // 'Jean-Luc Picard'\n```\n\n### Query.prototype.getFilter()\n\n##### Returns:\n\n- «Object» current query filter\n\nReturns the current query filter (also known as conditions) as a [POJO](https://masteringjs.io/tutorials/fundamentals/pojo).\n\n#### [Example:](#example)\n\n``` javascript\nconst query = new Query();\nquery.find({ a: 1 }).where('b').gt(2);\nquery.getFilter(); // { a: 1, b: { $gt: 2 } }\n```\n\n### Query.prototype.getOptions()\n\n##### Returns:\n\n- «Object» the options\n\nGets query options.\n\n#### [Example:](#example)\n\n``` javascript\nconst query = new Query();\nquery.limit(10);\nquery.setOptions({ maxTimeMS: 1000 });\nquery.getOptions(); // { limit: 10, maxTimeMS: 1000 }\n```\n\n### Query.prototype.getPopulatedPaths()\n\n##### Returns:\n\n- «Array» an array of strings representing populated paths\n\nGets a list of paths to be populated by this query\n\n#### [Example:](#example)\n\n``` javascript\n bookSchema.pre('findOne', function() {\n   let keys = this.getPopulatedPaths(); // ['author']\n });\n ...\n Book.findOne({}).populate('author');\n```\n\n#### [Example:](#example-1)\n\n``` javascript\n // Deep populate\n const q = L1.find().populate({\n   path: 'level2',\n   populate: { path: 'level3' }\n });\n q.getPopulatedPaths(); // ['level2', 'level2.level3']\n```\n\n### Query.prototype.getQuery()\n\n##### Returns:\n\n- «Object» current query filter\n\nReturns the current query filter. Equivalent to `getFilter()`.\n\nYou should use `getFilter()` instead of `getQuery()` where possible. `getQuery()` will likely be deprecated in a future release.\n\n#### [Example:](#example)\n\n``` javascript\nconst query = new Query();\nquery.find({ a: 1 }).where('b').gt(2);\nquery.getQuery(); // { a: 1, b: { $gt: 2 } }\n```\n\n### Query.prototype.getUpdate()\n\n##### Returns:\n\n- «Object» current update operations\n\nReturns the current update operations as a JSON object.\n\n#### [Example:](#example)\n\n``` javascript\nconst query = new Query();\nquery.updateOne({}, { $set: { a: 5 } });\nquery.getUpdate(); // { $set: { a: 5 } }\n```\n\n### Query.prototype.gt()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Number»\n\n##### See:\n\n- [$gt](https://www.mongodb.com/docs/manual/reference/operator/gt/)\n\nSpecifies a `$gt` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n#### [Example:](#example)\n\n``` javascript\nThing.find().where('age').gt(21);\n\n// or\nThing.find().gt('age', 21);\n```\n\n### Query.prototype.gte()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Number»\n\n##### See:\n\n- [$gte](https://www.mongodb.com/docs/manual/reference/operator/gte/)\n\nSpecifies a `$gte` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n### Query.prototype.hint()\n\n##### Parameters:\n\n- `val` «Object» a hint object\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$hint](https://www.mongodb.com/docs/manual/reference/operator/hint/)\n\nSets query hints.\n\n#### [Example:](#example)\n\n``` javascript\nquery.hint({ indexA: 1, indexB: -1 });\n```\n\n#### [Note:](#note)\n\nCannot be used with `distinct()`\n\n### Query.prototype.in()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Array»\n\n##### See:\n\n- [$in](https://www.mongodb.com/docs/manual/reference/operator/in/)\n\nSpecifies an `$in` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n### Query.prototype.intersects()\n\n##### Parameters:\n\n- `[arg]` «Object»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$geometry](https://www.mongodb.com/docs/manual/reference/operator/geometry/)\n- [geoIntersects](https://www.mongodb.com/docs/manual/reference/operator/geoIntersects/)\n\nDeclares an intersects query for `geometry()`.\n\n#### [Example:](#example)\n\n``` javascript\nquery.where('path').intersects().geometry({\n  type: 'LineString',\n  coordinates: [[180.0, 11.0], [180, 9.0]]\n});\n\nquery.where('path').intersects({\n  type: 'LineString',\n  coordinates: [[180.0, 11.0], [180, 9.0]]\n});\n```\n\n#### [Note:](#note)\n\n**MUST** be used after `where()`.\n\n#### [Note:](#note-1)\n\nIn Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n\n### Query.prototype.isPathSelectedInclusive()\n\n##### Parameters:\n\n- `path` «String»\n\n##### Returns:\n\n- «Boolean»\n\nWrapper function to call isPathSelectedInclusive on a query.\n\n### Query.prototype.j()\n\n##### Parameters:\n\n- `val` «boolean»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n\nRequests acknowledgement that this operation has been persisted to MongoDB's on-disk journal. This option is only valid for operations that write to the database:\n\n- `deleteOne()`\n- `deleteMany()`\n- `findOneAndDelete()`\n- `findOneAndReplace()`\n- `findOneAndUpdate()`\n- `updateOne()`\n- `updateMany()`\n\nDefaults to the schema's [`writeConcern.j` option](../guide#writeConcern)\n\n#### [Example:](#example)\n\n``` javascript\nawait mongoose.model('Person').deleteOne({ name: 'Ned Stark' }).j(true);\n```\n\n### Query.prototype.lean()\n\n##### Parameters:\n\n- `bool` «Boolean\\|Object» defaults to true\n\n##### Returns:\n\n- «Query» this\n\nSets the lean option.\n\nDocuments returned from queries with the `lean` option enabled are plain javascript objects, not [Mongoose Documents](document). They have no `save` method, getters/setters, virtuals, or other Mongoose features.\n\n#### [Example:](#example)\n\n``` javascript\nnew Query().lean() // true\nnew Query().lean(true)\nnew Query().lean(false)\n\nconst docs = await Model.find().lean();\ndocs[0] instanceof mongoose.Document; // false\n```\n\n[Lean is great for high-performance, read-only cases](../tutorials/lean), especially when combined with [cursors](../queries#streaming).\n\nIf you need virtuals, getters/setters, or defaults with `lean()`, you need to use a plugin. See:\n\n- [mongoose-lean-virtuals](https://plugins.mongoosejs.io/plugins/lean-virtuals)\n- [mongoose-lean-getters](https://plugins.mongoosejs.io/plugins/lean-getters)\n- [mongoose-lean-defaults](https://www.npmjs.com/package/mongoose-lean-defaults)\n\n### Query.prototype.limit()\n\n##### Parameters:\n\n- `val` «Number»\n\nSpecifies the maximum number of documents the query will return.\n\n#### [Example:](#example)\n\n``` javascript\nquery.limit(20);\n```\n\n#### [Note:](#note)\n\nCannot be used with `distinct()`\n\n### Query.prototype.lt()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Number»\n\n##### See:\n\n- [$lt](https://www.mongodb.com/docs/manual/reference/operator/lt/)\n\nSpecifies a `$lt` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n### Query.prototype.lte()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Number»\n\n##### See:\n\n- [$lte](https://www.mongodb.com/docs/manual/reference/operator/lte/)\n\nSpecifies a `$lte` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n### Query.prototype.maxDistance()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Number»\n\n##### See:\n\n- [$maxDistance](https://www.mongodb.com/docs/manual/reference/operator/maxDistance/)\n\nSpecifies a `maxDistance` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n### Query.prototype.maxTimeMS()\n\n##### Parameters:\n\n- `[ms]` «Number» The number of milliseconds\n\n##### Returns:\n\n- «Query» this\n\nSets the [maxTimeMS](https://www.mongodb.com/docs/manual/reference/method/cursor.maxTimeMS/) option. This will tell the MongoDB server to abort if the query or write op has been running for more than `ms` milliseconds.\n\nCalling `query.maxTimeMS(v)` is equivalent to `query.setOptions({ maxTimeMS: v })`\n\n#### [Example:](#example)\n\n``` javascript\nconst query = new Query();\n// Throws an error 'operation exceeded time limit' as long as there's\n// >= 1 doc in the queried collection\nconst res = await query.find({ $where: 'sleep(1000) || true' }).maxTimeMS(100);\n```\n\n### Query.prototype.merge()\n\n##### Parameters:\n\n- `source` «Query\\|Object»\n\n##### Returns:\n\n- «Query» this\n\nMerges another Query or conditions object into this one.\n\nWhen a Query is passed, conditions, field selection and options are merged.\n\n### Query.prototype.mod()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Array» must be of length 2, first element is `divisor`, 2nd element is `remainder`.\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$mod](https://www.mongodb.com/docs/manual/reference/operator/mod/)\n\nSpecifies a `$mod` condition, filters documents for documents whose `path` property is a number that is equal to `remainder` modulo `divisor`.\n\n#### [Example:](#example)\n\n``` javascript\n// All find products whose inventory is odd\nProduct.find().mod('inventory', [2, 1]);\nProduct.find().where('inventory').mod([2, 1]);\n// This syntax is a little strange, but supported.\nProduct.find().where('inventory').mod(2, 1);\n```\n\n### Query.prototype.model\n\n##### Type:\n\n- «property»\n\nThe model this query is associated with.\n\n#### [Example:](#example)\n\n``` javascript\nconst q = MyModel.find();\nq.model === MyModel; // true\n```\n\n### Query.prototype.mongooseOptions()\n\n##### Parameters:\n\n- `options` «Object» if specified, overwrites the current options\n\n##### Returns:\n\n- «Object» the options\n\nGetter/setter around the current mongoose-specific options for this query Below are the current Mongoose-specific options.\n\n- `populate`: an array representing what paths will be populated. Should have one entry for each call to [`Query.prototype.populate()`](#Query.prototype.populate())\n- `lean`: if truthy, Mongoose will not [hydrate](model#Model.hydrate()) any documents that are returned from this query. See [`Query.prototype.lean()`](#Query.prototype.lean()) for more information.\n- `strict`: controls how Mongoose handles keys that aren't in the schema for updates. This option is `true` by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the [`strict` mode docs](../guide#strict) for more information.\n- `strictQuery`: controls how Mongoose handles keys that aren't in the schema for the query `filter`. This option is `false` by default, which means Mongoose will allow `Model.find({ foo: 'bar' })` even if `foo` is not in the schema. See the [`strictQuery` docs](../guide#strictQuery) for more information.\n- `nearSphere`: use `$nearSphere` instead of `near()`. See the [`Query.prototype.nearSphere()` docs](#Query.prototype.nearSphere())\n\nMongoose maintains a separate object for internal options because Mongoose sends `Query.prototype.options` to the MongoDB server, and the above options are not relevant for the MongoDB server.\n\n### Query.prototype.ne()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «any»\n\n##### See:\n\n- [$ne](https://www.mongodb.com/docs/manual/reference/operator/ne/)\n\nSpecifies a `$ne` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n### Query.prototype.near()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Object»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$near](https://www.mongodb.com/docs/manual/reference/operator/near/)\n- [$nearSphere](https://www.mongodb.com/docs/manual/reference/operator/nearSphere/)\n- [$maxDistance](https://www.mongodb.com/docs/manual/reference/operator/maxDistance/)\n- [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)\n\nSpecifies a `$near` or `$nearSphere` condition\n\nThese operators return documents sorted by distance.\n\n#### [Example:](#example)\n\n``` javascript\nquery.where('loc').near({ center: [10, 10] });\nquery.where('loc').near({ center: [10, 10], maxDistance: 5 });\nquery.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\nquery.near('loc', { center: [10, 10], maxDistance: 5 });\n```\n\n### Query.prototype.nearSphere()\n\n~DEPRECATED~\n\n##### See:\n\n- [near()](#Query.prototype.near())\n- [$near](https://www.mongodb.com/docs/manual/reference/operator/near/)\n- [$nearSphere](https://www.mongodb.com/docs/manual/reference/operator/nearSphere/)\n- [$maxDistance](https://www.mongodb.com/docs/manual/reference/operator/maxDistance/)\n\n*DEPRECATED* Specifies a `$nearSphere` condition\n\n#### [Example:](#example)\n\n``` javascript\nquery.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });\n```\n\n**Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.\n\n#### [Example:](#example-1)\n\n``` javascript\nquery.where('loc').near({ center: [10, 10], spherical: true });\n```\n\n### Query.prototype.nin()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Array»\n\n##### See:\n\n- [$nin](https://www.mongodb.com/docs/manual/reference/operator/nin/)\n\nSpecifies an `$nin` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n### Query.prototype.nor()\n\n##### Parameters:\n\n- `array` «Array» array of conditions\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$nor](https://www.mongodb.com/docs/manual/reference/operator/nor/)\n\nSpecifies arguments for a `$nor` condition.\n\n#### [Example:](#example)\n\n``` javascript\nquery.nor([{ color: 'green' }, { status: 'ok' }]);\n```\n\n### Query.prototype.or()\n\n##### Parameters:\n\n- `array` «Array» array of conditions\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$or](https://www.mongodb.com/docs/manual/reference/operator/or/)\n\nSpecifies arguments for an `$or` condition.\n\n#### [Example:](#example)\n\n``` javascript\nquery.or([{ color: 'red' }, { status: 'emergency' }]);\n```\n\n### Query.prototype.orFail()\n\n##### Parameters:\n\n- `[err]` «Function\\|Error» optional error to throw if no docs match `filter`. If not specified, `orFail()` will throw a `DocumentNotFoundError`\n\n##### Returns:\n\n- «Query» this\n\nMake this query throw an error if no documents match the given `filter`. This is handy for integrating with async/await, because `orFail()` saves you an extra `if` statement to check if no document was found.\n\n#### [Example:](#example)\n\n``` javascript\n// Throws if no doc returned\nawait Model.findOne({ foo: 'bar' }).orFail();\n\n// Throws if no document was updated. Note that `orFail()` will still\n// throw if the only document that matches is `{ foo: 'bar', name: 'test' }`,\n// because `orFail()` will throw if no document was _updated_, not\n// if no document was _found_.\nawait Model.updateOne({ foo: 'bar' }, { name: 'test' }).orFail();\n\n// Throws \"No docs found!\" error if no docs match `{ foo: 'bar' }`\nawait Model.find({ foo: 'bar' }).orFail(new Error('No docs found!'));\n\n// Throws \"Not found\" error if no document was found\nawait Model.findOneAndUpdate({ foo: 'bar' }, { name: 'test' }).\n  orFail(() => Error('Not found'));\n```\n\n### Query.prototype.polygon()\n\n##### Parameters:\n\n- `[path]` «String\\|Array»\n- `[...coordinatePairs]` «Array\\|Object»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$polygon](https://www.mongodb.com/docs/manual/reference/operator/polygon/)\n- [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)\n\nSpecifies a `$polygon` condition\n\n#### [Example:](#example)\n\n``` javascript\nquery.where('loc').within().polygon([10, 20], [13, 25], [7, 15]);\nquery.polygon('loc', [10, 20], [13, 25], [7, 15]);\n```\n\n### Query.prototype.populate()\n\n##### Parameters:\n\n- `path` «Object\\|String\\|Array\\[String\\]» either the path(s) to populate or an object specifying all parameters\n- `[select]` «Object\\|String» Field selection for the population query\n- `[model]` «Model» The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n- `[match]` «Object» Conditions for the population query\n- `[options]` «Object» Options for the population query (sort, etc)\n\n&nbsp;\n\n- `[options.path=null]` «String» The path to populate.\n\n&nbsp;\n\n- `[options.retainNullValues=false]` «boolean» by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n\n&nbsp;\n\n- `[options.getters=false]` «boolean» if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](../schematypes#schematype-options).\n\n&nbsp;\n\n- `[options.clone=false]` «boolean» When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n\n&nbsp;\n\n- `[options.match=null]` «Object\\|Function» Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n\n&nbsp;\n\n- `[options.transform=null]` «Function» Function that Mongoose will call on every populated document that allows you to transform the populated document.\n\n&nbsp;\n\n- `[options.options=null]` «Object» Additional options like `limit` and `lean`.\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [population](../populate)\n- [Query#select](#Query.prototype.select())\n- [Model.populate](model#Model.populate())\n\nSpecifies paths which should be populated with other documents.\n\n#### [Example:](#example)\n\n``` javascript\nlet book = await Book.findOne().populate('authors');\nbook.title; // 'Node.js in Action'\nbook.authors[0].name; // 'TJ Holowaychuk'\nbook.authors[1].name; // 'Nathan Rajlich'\n\nlet books = await Book.find().populate({\n  path: 'authors',\n  // `match` and `sort` apply to the Author model,\n  // not the Book model. These options do not affect\n  // which documents are in `books`, just the order and\n  // contents of each book document's `authors`.\n  match: { name: new RegExp('.*h.*', 'i') },\n  sort: { name: -1 }\n});\nbooks[0].title; // 'Node.js in Action'\n// Each book's `authors` are sorted by name, descending.\nbooks[0].authors[0].name; // 'TJ Holowaychuk'\nbooks[0].authors[1].name; // 'Marc Harter'\n\nbooks[1].title; // 'Professional AngularJS'\n// Empty array, no authors' name has the letter 'h'\nbooks[1].authors; // []\n```\n\nPaths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.\n\n### Query.prototype.post()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «Promise»\n\nAdd post [middleware](../middleware) to this query instance. Doesn't affect other queries.\n\n#### [Example:](#example)\n\n``` javascript\nconst q1 = Question.find({ answer: 42 });\nq1.post(function middleware() {\n  console.log(this.getFilter());\n});\nawait q1.exec(); // Prints \"{ answer: 42 }\"\n\n// Doesn't print anything, because `middleware()` is only\n// registered on `q1`.\nawait Question.find({ answer: 42 });\n```\n\n### Query.prototype.pre()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «Promise»\n\nAdd pre [middleware](../middleware) to this query instance. Doesn't affect other queries.\n\n#### [Example:](#example)\n\n``` javascript\nconst q1 = Question.find({ answer: 42 });\nq1.pre(function middleware() {\n  console.log(this.getFilter());\n});\nawait q1.exec(); // Prints \"{ answer: 42 }\"\n\n// Doesn't print anything, because `middleware()` is only\n// registered on `q1`.\nawait Question.find({ answer: 42 });\n```\n\n### Query.prototype.projection()\n\n##### Parameters:\n\n- `arg` «Object\\|null»\n\n##### Returns:\n\n- «Object» the current projection\n\nGet/set the current projection (AKA fields). Pass `null` to remove the current projection.\n\nUnlike `projection()`, the `select()` function modifies the current projection in place. This function overwrites the existing projection.\n\n#### [Example:](#example)\n\n``` javascript\nconst q = Model.find();\nq.projection(); // null\n\nq.select('a b');\nq.projection(); // { a: 1, b: 1 }\n\nq.projection({ c: 1 });\nq.projection(); // { c: 1 }\n\nq.projection(null);\nq.projection(); // null\n```\n\n### Query.prototype.read()\n\n##### Parameters:\n\n- `mode` «String» one of the listed preference options or aliases\n- `[tags]` «Array» optional tags for this query\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)\n\nDetermines the MongoDB nodes from which to read.\n\n#### [Preferences:](#preferences)\n\n``` javascript\nprimary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\nsecondary            Read from secondary if available, otherwise error.\nprimaryPreferred     Read from primary if available, otherwise a secondary.\nsecondaryPreferred   Read from a secondary if available, otherwise read from the primary.\nnearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n```\n\nAliases\n\n``` javascript\np   primary\npp  primaryPreferred\ns   secondary\nsp  secondaryPreferred\nn   nearest\n```\n\n#### [Example:](#example)\n\n``` javascript\nnew Query().read('primary')\nnew Query().read('p')  // same as primary\n\nnew Query().read('primaryPreferred')\nnew Query().read('pp') // same as primaryPreferred\n\nnew Query().read('secondary')\nnew Query().read('s')  // same as secondary\n\nnew Query().read('secondaryPreferred')\nnew Query().read('sp') // same as secondaryPreferred\n\nnew Query().read('nearest')\nnew Query().read('n')  // same as nearest\n\n// read from secondaries with matching tags\nnew Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])\n```\n\nRead more about how to use read preferences [here](https://www.mongodb.com/docs/manual/applications/replication/#read-preference).\n\n### Query.prototype.readConcern()\n\n##### Parameters:\n\n- `level` «String» one of the listed read concern level or their aliases\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/read-concern/)\n\nSets the readConcern option for the query.\n\n#### [Example:](#example)\n\n``` javascript\nnew Query().readConcern('local')\nnew Query().readConcern('l')  // same as local\n\nnew Query().readConcern('available')\nnew Query().readConcern('a')  // same as available\n\nnew Query().readConcern('majority')\nnew Query().readConcern('m')  // same as majority\n\nnew Query().readConcern('linearizable')\nnew Query().readConcern('lz') // same as linearizable\n\nnew Query().readConcern('snapshot')\nnew Query().readConcern('s')  // same as snapshot\n```\n\n#### [Read Concern Level:](#read-concern-level)\n\n``` javascript\nlocal         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\navailable     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\nmajority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\nlinearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\nsnapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n```\n\nAliases\n\n``` javascript\nl   local\na   available\nm   majority\nlz  linearizable\ns   snapshot\n```\n\nRead more about how to use read concern [here](https://www.mongodb.com/docs/manual/reference/read-concern/).\n\n### Query.prototype.regex()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «String\\|RegExp»\n\n##### See:\n\n- [$regex](https://www.mongodb.com/docs/manual/reference/operator/regex/)\n\nSpecifies a `$regex` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n### Query.prototype.replaceOne()\n\n##### Parameters:\n\n- `[filter]` «Object»\n- `[doc]` «Object» the update command\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.multipleCastError]` «Boolean» by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.upsert=false]` «Boolean» if true, and no documents found, insert a new document\n\n&nbsp;\n\n- `[options.writeConcern=null]` «Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n&nbsp;\n\n- `[callback]` «Function» params are (error, writeOpResult)\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [Model.update](model#Model.update())\n- [Query docs](../queries)\n- [update](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n- [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)\n- [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)\n\nDeclare and/or execute this query as a replaceOne() operation. MongoDB will replace the existing document and will not accept any [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) (`$set`, etc.)\n\n**Note** replaceOne will *not* fire update middleware. Use `pre('replaceOne')` and `post('replaceOne')` instead.\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\nres.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\nres.matchedCount; // Number of documents that matched the filter\nres.modifiedCount; // Number of documents that were modified\nres.upsertedCount; // Number of documents that were upserted\nres.upsertedId; // Identifier of the inserted document (if an upsert took place)\n```\n\nThis function triggers the following middleware.\n\n- `replaceOne()`\n\n### Query.prototype.select()\n\n##### Parameters:\n\n- `arg` «Object\\|String\\|Array\\[String\\]»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [SchemaType](schematype)\n\nSpecifies which document fields to include or exclude (also known as the query \"projection\")\n\nWhen using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](schematype#SchemaType.prototype.select()).\n\nA projection *must* be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The [`_id` field is the only exception because MongoDB includes it by default](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/#suppress-id-field).\n\n#### [Example:](#example)\n\n``` javascript\n// include a and b, exclude other fields\nquery.select('a b');\n// Equivalent syntaxes:\nquery.select(['a', 'b']);\nquery.select({ a: 1, b: 1 });\n\n// exclude c and d, include other fields\nquery.select('-c -d');\n\n// Use `+` to override schema-level `select: false` without making the\n// projection inclusive.\nconst schema = new Schema({\n  foo: { type: String, select: false },\n  bar: String\n});\n// ...\nquery.select('+foo'); // Override foo's `select: false` without excluding `bar`\n\n// or you may use object notation, useful when\n// you have keys already prefixed with a \"-\"\nquery.select({ a: 1, b: 1 });\nquery.select({ c: 0, d: 0 });\n\nAdditional calls to select can override the previous selection:\nquery.select({ a: 1, b: 1 }).select({ b: 0 }); // selection is now { a: 1 }\nquery.select({ a: 0, b: 0 }).select({ b: 1 }); // selection is now { a: 0 }\n```\n\n### Query.prototype.selected()\n\n##### Returns:\n\n- «Boolean»\n\nDetermines if field selection has been made.\n\n### Query.prototype.selectedExclusively()\n\n##### Returns:\n\n- «Boolean»\n\nDetermines if exclusive field selection has been made.\n\n``` javascript\nquery.selectedExclusively(); // false\nquery.select('-name');\nquery.selectedExclusively(); // true\nquery.selectedInclusively(); // false\n```\n\n### Query.prototype.selectedInclusively()\n\n##### Returns:\n\n- «Boolean»\n\nDetermines if inclusive field selection has been made.\n\n``` javascript\nquery.selectedInclusively(); // false\nquery.select('name');\nquery.selectedInclusively(); // true\n```\n\n### Query.prototype.session()\n\n##### Parameters:\n\n- `[session]` «ClientSession» from `await conn.startSession()`\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [Connection.prototype.startSession()](connection#Connection.prototype.startSession())\n- [mongoose.startSession()](mongoose#Mongoose.prototype.startSession())\n\nSets the [MongoDB session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this query. Sessions are how you mark a query as part of a [transaction](../transactions).\n\nCalling `session(null)` removes the session from this query.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = await mongoose.startSession();\nawait mongoose.model('Person').findOne({ name: 'Axl Rose' }).session(s);\n```\n\n### Query.prototype.set()\n\n##### Parameters:\n\n- `path` «String\\|Object» path or object of key/value pairs to set\n- `[val]` «Any» the value to set\n\n##### Returns:\n\n- «Query» this\n\nAdds a `$set` to this query's update without changing the operation. This is useful for query middleware so you can add an update regardless of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.\n\n#### [Example:](#example)\n\n``` javascript\n// Updates `{ $set: { updatedAt: new Date() } }`\nnew Query().updateOne({}, {}).set('updatedAt', new Date());\nnew Query().updateMany({}, {}).set({ updatedAt: new Date() });\n```\n\n### Query.prototype.setOptions()\n\n##### Parameters:\n\n- `options` «Object»\n\n##### Returns:\n\n- «Query» this\n\nSets query options. Some options only make sense for certain operations.\n\n#### [Options:](#options)\n\nThe following options are only for `find()`:\n\n- [tailable](https://www.mongodb.com/docs/manual/core/tailable-cursors/)\n- [limit](https://www.mongodb.com/docs/manual/reference/method/cursor.limit/)\n- [skip](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/)\n- [allowDiskUse](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/)\n- [batchSize](https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/)\n- [readPreference](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)\n- [hint](https://www.mongodb.com/docs/manual/reference/method/cursor.hint/)\n- [comment](https://www.mongodb.com/docs/manual/reference/method/cursor.comment/)\n\nThe following options are only for write operations: `updateOne()`, `updateMany()`, `replaceOne()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:\n\n- [upsert](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n- [writeConcern](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n- [timestamps](../guide#timestamps): If `timestamps` is set in the schema, set this option to `false` to skip timestamps for that particular update. Has no effect if `timestamps` is not enabled in the schema options.\n- overwriteDiscriminatorKey: allow setting the discriminator key in the update. Will use the correct discriminator schema if the update changes the discriminator key.\n\nThe following options are only for `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, `findOneAndReplace()`, `findOneAndDelete()`, and `findByIdAndUpdate()`:\n\n- [lean](#Query.prototype.lean())\n- [populate](../populate)\n- [projection](#Query.prototype.projection())\n- sanitizeProjection\n- useBigInt64\n\nThe following options are only for all operations **except** `updateOne()`, `updateMany()`, `deleteOne()`, and `deleteMany()`:\n\n- [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n\nThe following options are for `find()`, `findOne()`, `findOneAndUpdate()`, `findOneAndRemove()`, `findOneAndDelete()`, `updateOne()`, and `deleteOne()`:\n\n- [sort](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/)\n\nThe following options are for `findOneAndUpdate()` and `findOneAndRemove()`\n\n- rawResult\n\nThe following options are for all operations:\n\n- [strict](../guide#strict)\n- [collation](https://www.mongodb.com/docs/manual/reference/collation/)\n- [session](https://www.mongodb.com/docs/manual/reference/server-sessions/)\n- [explain](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/)\n\n### Query.prototype.setQuery()\n\n##### Parameters:\n\n- `new` «Object» query conditions\n\n##### Returns:\n\n- «undefined,void»\n\nSets the query conditions to the provided JSON object.\n\n#### [Example:](#example)\n\n``` javascript\nconst query = new Query();\nquery.find({ a: 1 })\nquery.setQuery({ a: 2 });\nquery.getQuery(); // { a: 2 }\n```\n\n### Query.prototype.setUpdate()\n\n##### Parameters:\n\n- `new` «Object» update operation\n\n##### Returns:\n\n- «undefined,void»\n\nSets the current update operation to new value.\n\n#### [Example:](#example)\n\n``` javascript\nconst query = new Query();\nquery.updateOne({}, { $set: { a: 5 } });\nquery.setUpdate({ $set: { b: 6 } });\nquery.getUpdate(); // { $set: { b: 6 } }\n```\n\n### Query.prototype.size()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Number»\n\n##### See:\n\n- [$size](https://www.mongodb.com/docs/manual/reference/operator/size/)\n\nSpecifies a `$size` query condition.\n\nWhen called with one argument, the most recent path passed to `where()` is used.\n\n#### [Example:](#example)\n\n``` javascript\nconst docs = await MyModel.where('tags').size(0).exec();\nassert(Array.isArray(docs));\nconsole.log('documents with 0 tags', docs);\n```\n\n### Query.prototype.skip()\n\n##### Parameters:\n\n- `val` «Number»\n\n##### See:\n\n- [cursor.skip](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/)\n\nSpecifies the number of documents to skip.\n\n#### [Example:](#example)\n\n``` javascript\nquery.skip(100).limit(20);\n```\n\n#### [Note:](#note)\n\nCannot be used with `distinct()`\n\n### Query.prototype.slice()\n\n##### Parameters:\n\n- `[path]` «String»\n- `val` «Number\\|Array» number of elements to slice or array with number of elements to skip and number of elements to slice\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/tutorial/query-documents/#projection)\n- [$slice](https://www.mongodb.com/docs/manual/reference/projection/slice/#prj._S_slice)\n\nSpecifies a `$slice` projection for an array.\n\n#### [Example:](#example)\n\n``` javascript\nquery.slice('comments', 5); // Returns the first 5 comments\nquery.slice('comments', -5); // Returns the last 5 comments\nquery.slice('comments', [10, 5]); // Returns the first 5 comments after the 10-th\nquery.where('comments').slice(5); // Returns the first 5 comments\nquery.where('comments').slice([-10, 5]); // Returns the first 5 comments after the 10-th to last\n```\n\n**Note:** If the absolute value of the number of elements to be sliced is greater than the number of elements in the array, all array elements will be returned.\n\n``` javascript\n // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n query.slice('arr', 20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n query.slice('arr', -20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n**Note:** If the number of elements to skip is positive and greater than the number of elements in the array, an empty array will be returned.\n\n``` javascript\n // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n query.slice('arr', [20, 5]); // Returns []\n```\n\n**Note:** If the number of elements to skip is negative and its absolute value is greater than the number of elements in the array, the starting position is the start of the array.\n\n``` javascript\n // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n query.slice('arr', [-20, 5]); // Returns [1, 2, 3, 4, 5]\n```\n\n### Query.prototype.sort()\n\n##### Parameters:\n\n- `arg` «Object\\|String\\|Array\\<Array\\<string\\|number\\>\\>»\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [cursor.sort](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/)\n\nSets the sort order\n\nIf an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n\nIf a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n\n#### [Example:](#example)\n\n``` javascript\n// sort by \"field\" ascending and \"test\" descending\nquery.sort({ field: 'asc', test: -1 });\n\n// equivalent\nquery.sort('field -test');\n\n// also possible is to use a array with array key-value pairs\nquery.sort([['field', 'asc']]);\n```\n\n#### [Note:](#note)\n\nCannot be used with `distinct()`\n\n### Query.prototype.tailable()\n\n##### Parameters:\n\n- `bool` «Boolean» defaults to true\n- `[opts]` «Object» options to set\n\n&nbsp;\n\n- `[opts.awaitData]` «Boolean» false by default. Set to true to keep the cursor open even if there's no data.\n\n&nbsp;\n\n- `[opts.maxAwaitTimeMS]` «Number» the maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true\n\n##### See:\n\n- [tailable](https://www.mongodb.com/docs/manual/tutorial/create-tailable-cursor/)\n\nSets the tailable option (for use with capped collections).\n\n#### [Example:](#example)\n\n``` javascript\nquery.tailable(); // true\nquery.tailable(true);\nquery.tailable(false);\n\n// Set both `tailable` and `awaitData` options\nquery.tailable({ awaitData: true });\n```\n\n#### [Note:](#note)\n\nCannot be used with `distinct()`\n\n### Query.prototype.then()\n\n##### Parameters:\n\n- `[resolve]` «Function»\n- `[reject]` «Function»\n\n##### Returns:\n\n- «Promise»\n\nExecutes the query returning a `Promise` which will be resolved with either the doc(s) or rejected with the error.\n\nMore about [`then()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/then).\n\n### Query.prototype.toConstructor()\n\n##### Returns:\n\n- «Query» subclass-of-Query\n\nConverts this query to a customized, reusable query constructor with all arguments and options retained.\n\n#### [Example:](#example)\n\n``` javascript\n// Create a query for adventure movies and read from the primary\n// node in the replica-set unless it is down, in which case we'll\n// read from a secondary node.\nconst query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');\n\n// create a custom Query constructor based off these settings\nconst Adventure = query.toConstructor();\n\n// further narrow down our query results while still using the previous settings\nawait Adventure().where({ name: /^Life/ }).exec();\n\n// since Adventure is a stand-alone constructor we can also add our own\n// helper methods and getters without impacting global queries\nAdventure.prototype.startsWith = function (prefix) {\n  this.where({ name: new RegExp('^' + prefix) })\n  return this;\n}\nObject.defineProperty(Adventure.prototype, 'highlyRated', {\n  get: function () {\n    this.where({ rating: { $gt: 4.5 }});\n    return this;\n  }\n})\nawait Adventure().highlyRated.startsWith('Life').exec();\n```\n\n### Query.prototype.transform()\n\n##### Parameters:\n\n- `fn` «Function» function to run to transform the query result\n\n##### Returns:\n\n- «Query» this\n\nRuns a function `fn` and treats the return value of `fn` as the new value for the query to resolve to.\n\nAny functions you pass to `transform()` will run **after** any post hooks.\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await MyModel.findOne().transform(res => {\n  // Sets a `loadedAt` property on the doc that tells you the time the\n  // document was loaded.\n  return res == null ?\n    res :\n    Object.assign(res, { loadedAt: new Date() });\n});\n```\n\n### Query.prototype.updateMany()\n\n##### Parameters:\n\n- `[filter]` «Object»\n- `[update]` «Object\\|Array» the update command\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.multipleCastError]` «Boolean» by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.upsert=false]` «Boolean» if true, and no documents found, insert a new document\n\n&nbsp;\n\n- `[options.writeConcern=null]` «Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n&nbsp;\n\n- `[callback]` «Function» params are (error, writeOpResult)\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [Model.update](model#Model.update())\n- [Query docs](../queries)\n- [update](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n- [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)\n- [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)\n\nDeclare and/or execute this query as an updateMany() operation. MongoDB will update *all* documents that match `filter` (as opposed to just the first one).\n\n**Note** updateMany will *not* fire update middleware. Use `pre('updateMany')` and `post('updateMany')` instead.\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\nres.n; // Number of documents matched\nres.nModified; // Number of documents modified\n```\n\nThis function triggers the following middleware.\n\n- `updateMany()`\n\n### Query.prototype.updateOne()\n\n##### Parameters:\n\n- `[filter]` «Object»\n- `[update]` «Object\\|Array» the update command\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.multipleCastError]` «Boolean» by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n\n&nbsp;\n\n- `[options.strict]` «Boolean\\|String» overwrites the schema's [strict mode option](../guide#strict)\n\n&nbsp;\n\n- `[options.upsert=false]` «Boolean» if true, and no documents found, insert a new document\n\n&nbsp;\n\n- `[options.writeConcern=null]` «Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)\n\n&nbsp;\n\n- `[options.timestamps=null]` «Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n\n&nbsp;\n\n- `[options.translateAliases=null]` «Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n\n&nbsp;\n\n- `[callback]` «Function» params are (error, writeOpResult)\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [Model.update](model#Model.update())\n- [Query docs](../queries)\n- [update](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n- [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)\n- [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)\n\nDeclare and/or execute this query as an updateOne() operation. MongoDB will update *only* the first document that matches `filter`.\n\n- Use `replaceOne()` if you want to overwrite an entire document rather than using [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) like `$set`.\n\n**Note** updateOne will *not* fire update middleware. Use `pre('updateOne')` and `post('updateOne')` instead.\n\n#### [Example:](#example)\n\n``` javascript\nconst res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\nres.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\nres.matchedCount; // Number of documents that matched the filter\nres.modifiedCount; // Number of documents that were modified\nres.upsertedCount; // Number of documents that were upserted\nres.upsertedId; // Identifier of the inserted document (if an upsert took place)\n```\n\nThis function triggers the following middleware.\n\n- `updateOne()`\n\n### Query.prototype.w()\n\n##### Parameters:\n\n- `val` «String\\|number» 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option).\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option)\n\nSets the specified number of `mongod` servers, or tag set of `mongod` servers, that must acknowledge this write before this write is considered successful. This option is only valid for operations that write to the database:\n\n- `deleteOne()`\n- `deleteMany()`\n- `findOneAndDelete()`\n- `findOneAndReplace()`\n- `findOneAndUpdate()`\n- `updateOne()`\n- `updateMany()`\n\nDefaults to the schema's [`writeConcern.w` option](../guide#writeConcern)\n\n#### [Example:](#example)\n\n``` javascript\n// The 'majority' option means the `deleteOne()` promise won't resolve\n// until the `deleteOne()` has propagated to the majority of the replica set\nawait mongoose.model('Person').\n  deleteOne({ name: 'Ned Stark' }).\n  w('majority');\n```\n\n### Query.prototype.where()\n\n##### Parameters:\n\n- `[path]` «String\\|Object»\n- `[val]` «any»\n\n##### Returns:\n\n- «Query» this\n\nSpecifies a `path` for use with chaining.\n\n#### [Example:](#example)\n\n``` javascript\n// instead of writing:\nUser.find({age: {$gte: 21, $lte: 65}});\n\n// we can instead write:\nUser.where('age').gte(21).lte(65);\n\n// passing query conditions is permitted\nUser.find().where({ name: 'vonderful' })\n\n// chaining\nUser\n.where('age').gte(21).lte(65)\n.where('name', /^vonderful/i)\n.where('friends').slice(10)\n.exec()\n```\n\n### Query.prototype.within()\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [$polygon](https://www.mongodb.com/docs/manual/reference/operator/polygon/)\n- [$box](https://www.mongodb.com/docs/manual/reference/operator/box/)\n- [$geometry](https://www.mongodb.com/docs/manual/reference/operator/geometry/)\n- [$center](https://www.mongodb.com/docs/manual/reference/operator/center/)\n- [$centerSphere](https://www.mongodb.com/docs/manual/reference/operator/centerSphere/)\n\nDefines a `$within` or `$geoWithin` argument for geo-spatial queries.\n\n#### [Example:](#example)\n\n``` javascript\nquery.where(path).within().box()\nquery.where(path).within().circle()\nquery.where(path).within().geometry()\n\nquery.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\nquery.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\nquery.where('loc').within({ polygon: [[],[],[],[]] });\n\nquery.where('loc').within([], [], []) // polygon\nquery.where('loc').within([], []) // box\nquery.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n```\n\n**MUST** be used after `where()`.\n\n#### [Note:](#note)\n\nAs of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](#Query.prototype.use$geoWithin).\n\n#### [Note:](#note-1)\n\nIn Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n\n### Query.prototype.writeConcern()\n\n##### Parameters:\n\n- `writeConcern` «Object» the write concern value to set\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [WriteConcernSettings](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/WriteConcernSettings.html)\n\nSets the 3 write concern parameters for this query:\n\n- `w`: Sets the specified number of `mongod` servers, or tag set of `mongod` servers, that must acknowledge this write before this write is considered successful.\n- `j`: Boolean, set to `true` to request acknowledgement that this operation has been persisted to MongoDB's on-disk journal.\n- `wtimeout`: If [`w > 1`](#Query.prototype.w()), the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is `0`, which means no timeout.\n\nThis option is only valid for operations that write to the database:\n\n- `deleteOne()`\n- `deleteMany()`\n- `findOneAndDelete()`\n- `findOneAndReplace()`\n- `findOneAndUpdate()`\n- `updateOne()`\n- `updateMany()`\n\nDefaults to the schema's [`writeConcern` option](../guide#writeConcern)\n\n#### [Example:](#example)\n\n``` javascript\n// The 'majority' option means the `deleteOne()` promise won't resolve\n// until the `deleteOne()` has propagated to the majority of the replica set\nawait mongoose.model('Person').\n  deleteOne({ name: 'Ned Stark' }).\n  writeConcern({ w: 'majority' });\n```\n\n### Query.prototype.wtimeout()\n\n##### Parameters:\n\n- `ms` «number» number of milliseconds to wait\n\n##### Returns:\n\n- «Query» this\n\n##### See:\n\n- [mongodb](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout)\n\nIf [`w > 1`](#Query.prototype.w()), the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is `0`, which means no timeout.\n\nThis option is only valid for operations that write to the database:\n\n- `deleteOne()`\n- `deleteMany()`\n- `findOneAndDelete()`\n- `findOneAndReplace()`\n- `findOneAndUpdate()`\n- `updateOne()`\n- `updateMany()`\n\nDefaults to the schema's [`writeConcern.wtimeout` option](../guide#writeConcern)\n\n#### [Example:](#example)\n\n``` javascript\n// The `deleteOne()` promise won't resolve until this `deleteOne()` has\n// propagated to at least `w = 2` members of the replica set. If it takes\n// longer than 1 second, this `deleteOne()` will fail.\nawait mongoose.model('Person').\n  deleteOne({ name: 'Ned Stark' }).\n  w(2).\n  wtimeout(1000);\n```\n\n### Query.prototype\\[Symbol.asyncIterator\\]()\n\nReturns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js) This function *only* works for `find()` queries. You do not need to call this function explicitly, the JavaScript runtime will call it for you.\n\n#### [Example:](#example)\n\n``` javascript\nfor await (const doc of Model.aggregate([{ $sort: { name: 1 } }])) {\n  console.log(doc.name);\n}\n```\n\nNode.js 10.x supports async iterators natively without any flags. You can enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n\n**Note:** This function is not if `Symbol.asyncIterator` is undefined. If `Symbol.asyncIterator` is undefined, that means your Node.js version does not support async iterators.\n\n### Query.prototype\\[Symbol.toStringTag\\]()\n\n##### Returns:\n\n- «String»\n\nReturns a string representation of this query.\n\nMore about [`toString()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/tostring).\n\n#### [Example:](#example)\n\n``` javascript\nconst q = Model.find();\nconsole.log(q); // Prints \"Query { find }\"\n```\n\n### Query.use$geoWithin\n\n##### Type:\n\n- «property»\n\n##### See:\n\n- [geoWithin](https://www.mongodb.com/docs/manual/reference/operator/geoWithin/)\n\nFlag to opt out of using `$geoWithin`.\n\n``` javascript\nmongoose.Query.use$geoWithin = false;\n```\n\nMongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with `$within`). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/query.html](https://mongoosejs.com/docs/api/query.html)"
- name: Query Casting
  id: tutorials/query_casting
  summary: The first parameter to Model.find(), Query#find(), Model.findOne(), etc
  description: "# Query Casting\n\nThe first parameter to [`Model.find()`](../api/model#model_Model-find), [`Query#find()`](../api/query#query_Query-find), [`Model.findOne()`](../api/model#model_Model-findOne), etc. is called `filter`. In older content this parameter is sometimes called `query` or `conditions`. For example:\n\n``` javascript\nconst query = Character.find({ name: 'Jean-Luc Picard' });\nquery.getFilter(); // `{ name: 'Jean-Luc Picard' }`\n\n// Subsequent chained calls merge new properties into the filter\nquery.find({ age: { $gt: 50 } });\nquery.getFilter(); // `{ name: 'Jean-Luc Picard', age: { $gt: 50 } }`\n```\n\nWhen you execute the query using [`Query#exec()`](../api/query#query_Query-exec) or [`Query#then()`](../api/query#query_Query-then), Mongoose *casts* the filter to match your schema.\n\n``` javascript\n// Note that `_id` and `age` are strings. Mongoose will cast `_id` to\n// a MongoDB ObjectId and `age.$gt` to a number.\nconst query = Character.findOne({\n  _id: '5cdc267dd56b5662b7b7cc0c',\n  age: { $gt: '50' }\n});\n\n// `{ _id: '5cdc267dd56b5662b7b7cc0c', age: { $gt: '50' } }`\n// Query hasn't been executed yet, so Mongoose hasn't casted the filter.\nquery.getFilter();\n\nconst doc = await query.exec();\ndoc.name; // \"Jean-Luc Picard\"\n\n// Mongoose casted the filter, so `_id` became an ObjectId and `age.$gt`\n// became a number.\nquery.getFilter()._id instanceof mongoose.Types.ObjectId; // true\ntypeof query.getFilter().age.$gt === 'number'; // true\n```\n\nIf Mongoose fails to cast the filter to your schema, your query will throw a `CastError`.\n\n``` javascript\nconst query = Character.findOne({ age: { $lt: 'not a number' } });\n\nconst err = await query.exec().then(() => null, err => err);\nerr instanceof mongoose.CastError; // true\n// Cast to number failed for value \"not a number\" at path \"age\" for\n// model \"Character\"\nerr.message;\n```\n\n## The `strictQuery` Option\n\nBy default, Mongoose does **not** cast filter properties that aren't in your schema.\n\n``` javascript\nconst query = Character.findOne({ notInSchema: { $lt: 'not a number' } });\n\n// No error because `notInSchema` is not defined in the schema\nawait query.exec();\n```\n\nYou can configure this behavior using the [`strictQuery` option for schemas](../guide#strictQuery). This option is analogous to the [`strict` option](../guide#strict). Setting `strictQuery` to `true` removes non-schema properties from the filter:\n\n``` javascript\nmongoose.deleteModel('Character');\nconst schema = new mongoose.Schema({ name: String, age: Number }, {\n  strictQuery: true\n});\nCharacter = mongoose.model('Character', schema);\n\nconst query = Character.findOne({ notInSchema: { $lt: 'not a number' } });\n\nawait query.exec();\nquery.getFilter(); // Empty object `{}`, Mongoose removes `notInSchema`\n```\n\nTo make Mongoose throw an error if your `filter` has a property that isn't in the schema, set `strictQuery` to `'throw'`:\n\n``` javascript\nmongoose.deleteModel('Character');\nconst schema = new mongoose.Schema({ name: String, age: Number }, {\n  strictQuery: 'throw'\n});\nCharacter = mongoose.model('Character', schema);\n\nconst query = Character.findOne({ notInSchema: { $lt: 'not a number' } });\n\nconst err = await query.exec().then(() => null, err => err);\nerr.name; // 'StrictModeError'\n// Path \"notInSchema\" is not in schema and strictQuery is 'throw'.\nerr.message;\n```\n\n## Implicit `$in`\n\nBecause of schemas, Mongoose knows what types fields should be, so it can provide some neat syntactic sugar. For example, if you forget to put [`$in`](https://www.mongodb.com/docs/manual/reference/operator/query/in/) on a non-array field, Mongoose will add `$in` for you.\n\n``` javascript\n// Normally wouldn't find anything because `name` is a string, but\n// Mongoose automatically inserts `$in`\nconst query = Character.findOne({ name: ['Jean-Luc Picard', 'Will Riker'] });\n\nconst doc = await query.exec();\ndoc.name; // \"Jean-Luc Picard\"\n\n// `{ name: { $in: ['Jean-Luc Picard', 'Will Riker'] } }`\nquery.getFilter();\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/tutorials/query_casting.html](https://mongoosejs.com/docs/tutorials/query_casting.html)"
- name: Query()
  id: api/query#Query()
  summary: Query constructor used for building queries
  belongs_to: Query
  description: |-
    ### Query()

    ##### Parameters:

    - `[options]` «Object»
    - `[model]` «Object»
    - `[conditions]` «Object»
    - `[collection]`«Object» Mongoose collection

    Query constructor used for building queries. You do not need to instantiate a `Query` directly. Instead use Model functions like [`Model.find()`](model#Model.find()).

    #### [Example:](#example)

    ``` javascript
    const query = MyModel.find(); // `query` is an instance of `Query`
    query.setOptions({ lean : true });
    query.collection(MyModel.collection);
    query.where('age').gte(21).exec(callback);

    // You can instantiate a query directly. There is no need to do
    // this unless you're an advanced user with a very good reason to.
    const query = new mongoose.Query();
    ```
- name: Query.prototype.$where()
  id: api/query#Query.prototype.$where()
  summary: Specifies a javascript function or expression to pass to MongoDBs query system
  belongs_to: Query
  description: |-
    ### Query.prototype.$where()

    ##### Parameters:

    - `js`«String\|Function» javascript string or function

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$where](https://www.mongodb.com/docs/manual/reference/operator/where/)

    Specifies a javascript function or expression to pass to MongoDBs query system.

    #### [Example:](#example)

    ``` javascript
    query.$where('this.comments.length === 10 || this.name.length === 5')

    // or

    query.$where(function () {
      return this.comments.length === 10 || this.name.length === 5;
    })
    ```

    #### [Note:](#note)

    Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`. **Be sure to read about all of [its caveats](https://www.mongodb.com/docs/manual/reference/operator/where/) before using.**
- name: Query.prototype.all()
  id: api/query#Query.prototype.all()
  summary: Specifies an $all query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.all()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Array»

    ##### See:

    -  [$all](https://www.mongodb.com/docs/manual/reference/operator/all/)

    Specifies an `$all` query condition.

    When called with one argument, the most recent path passed to `where()` is used.

    #### [Example:](#example)

    ``` javascript
    MyModel.find().where('pets').all(['dog', 'cat', 'ferret']);
    // Equivalent:MyModel.find().all('pets', ['dog', 'cat', 'ferret']);
    ```
- name: Query.prototype.allowDiskUse()
  id: api/query#Query.prototype.allowDiskUse()
  summary: Sets the allowDiskUse option, which allows the MongoDB server to use more than 100 MB for this query's sort()
  belongs_to: Query
  description: |-
    ### Query.prototype.allowDiskUse()

    ##### Parameters:

    - `[v]`«Boolean» Enable/disable `allowDiskUse`. If called with 0 arguments, sets `allowDiskUse: true`

    ##### Returns:

    - «Query» this

    Sets the [`allowDiskUse` option](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/), which allows the MongoDB server to use more than 100 MB for this query's `sort()`. This option can let you work around `QueryExceededMemoryLimitNoDiskUseAllowed` errors from the MongoDB server.

    Note that this option requires MongoDB server \>= 4.4. Setting this option is a no-op for MongoDB 4.2 and earlier.

    Calling `query.allowDiskUse(v)` is equivalent to `query.setOptions({ allowDiskUse: v })`

    #### [Example:](#example)

    ``` javascript
    await query.find().sort({ name: 1 }).allowDiskUse(true);
    // Equivalent:
    await query.find().sort({ name: 1 }).allowDiskUse();
    ```
- name: Query.prototype.and()
  id: api/query#Query.prototype.and()
  summary: Specifies arguments for a $and condition
  belongs_to: Query
  description: |-
    ### Query.prototype.and()

    ##### Parameters:

    - `array`«Array» array of conditions

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$and](https://www.mongodb.com/docs/manual/reference/operator/and/)

    Specifies arguments for a `$and` condition.

    #### [Example:](#example)

    ``` javascript
    query.and([{ color: 'green' }, { status: 'ok' }])
    ```
- name: Query.prototype.batchSize()
  id: api/query#Query.prototype.batchSize()
  summary: Specifies the batchSize option
  belongs_to: Query
  description: |-
    ### Query.prototype.batchSize()

    ##### Parameters:

    - `val` «Number»

    ##### See:

    -  [batchSize](https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/)

    Specifies the batchSize option.

    #### [Example:](#example)

    ``` javascript
    query.batchSize(100)
    ```

    #### [Note:](#note)

    Cannot be used with `distinct()`
- name: Query.prototype.box()
  id: api/query#Query.prototype.box()
  summary: null
  belongs_to: Query
  description: |-
    ### Query.prototype.box()

    ##### Parameters:

    - `val1`«Object\|Array\<Number\>» Lower Left Coordinates OR a object of lower-left(ll) and upper-right(ur) Coordinates
    - `[val2]`«Array\<Number\>» Upper Right Coordinates

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$box](https://www.mongodb.com/docs/manual/reference/operator/box/)
    -  [within() Query#within](#Query.prototype.within())
    -  [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)

    Specifies a `$box` condition

    #### [Example:](#example)

    ``` javascript
    const lowerLeft = [40.73083, -73.99756]
    const upperRight= [40.741404,  -73.988135]

    query.where('loc').within().box(lowerLeft, upperRight)
    query.box({ ll : lowerLeft, ur : upperRight })
    ```
- name: Query.prototype.cast()
  id: api/query#Query.prototype.cast()
  summary: If obj is present, it is cast instead of this query
  belongs_to: Query
  description: |-
    ### Query.prototype.cast()

    ##### Parameters:

    - `[model]`«Model» the model to cast to. If not set, defaults to `this.model`
    - `[obj]` «Object»

    ##### Returns:

    - «Object»

    Casts this query to the schema of `model`

    #### [Note:](#note)

    If `obj` is present, it is cast instead of this query.
- name: Query.prototype.catch()
  id: api/query#Query.prototype.catch()
  summary: Executes the query returning a Promise which will be resolved with either the doc(s) or rejected with the error
  belongs_to: Query
  description: |-
    ### Query.prototype.catch()

    ##### Parameters:

    - `[reject]` «Function»

    ##### Returns:

    - «Promise»

    Executes the query returning a `Promise` which will be resolved with either the doc(s) or rejected with the error. Like `.then()`, but only takes a rejection handler.

    More about [Promise `catch()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/catch).
- name: Query.prototype.center()
  id: api/query#Query.prototype.center()
  summary: Deprecated
  belongs_to: Query
  description: |-
    ### Query.prototype.center()

    ~DEPRECATED~

    *DEPRECATED* Alias for [circle](#Query.prototype.circle())

    **Deprecated.** Use [circle](#Query.prototype.circle()) instead.
- name: Query.prototype.centerSphere()
  id: api/query#Query.prototype.centerSphere()
  summary: Deprecated
  belongs_to: Query
  description: |-
    ### Query.prototype.centerSphere()

    ~DEPRECATED~

    ##### Parameters:

    - `[path]` «String»
    - `val` «Object»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)
    -  [$centerSphere](https://www.mongodb.com/docs/manual/reference/operator/centerSphere/)

    *DEPRECATED* Specifies a `$centerSphere` condition

    **Deprecated.** Use [circle](#Query.prototype.circle()) instead.

    #### [Example:](#example)

    ``` javascript
    const area = { center: [50, 50], radius: 10 };
    query.where('loc').within().centerSphere(area);
    ```
- name: Query.prototype.circle()
  id: api/query#Query.prototype.circle()
  summary: Specifies a $center or $centerSphere condition
  belongs_to: Query
  description: |-
    ### Query.prototype.circle()

    ##### Parameters:

    - `[path]` «String»
    - `area` «Object»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$center](https://www.mongodb.com/docs/manual/reference/operator/center/)
    -  [$centerSphere](https://www.mongodb.com/docs/manual/reference/operator/centerSphere/)
    -  [$geoWithin](https://www.mongodb.com/docs/manual/reference/operator/geoWithin/)
    -  [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)

    Specifies a `$center` or `$centerSphere` condition.

    #### [Example:](#example)

    ``` javascript
    const area = { center: [50, 50], radius: 10, unique: true }
    query.where('loc').within().circle(area)
    // alternatively
    query.circle('loc', area);

    // spherical calculations
    const area = { center: [50, 50], radius: 10, unique: true, spherical: true }
    query.where('loc').within().circle(area)
    // alternatively
    query.circle('loc', area);
    ```
- name: Query.prototype.clone()
  id: api/query#Query.prototype.clone()
  summary: Make a copy of this query so you can re-execute it
  belongs_to: Query
  description: |-
    ### Query.prototype.clone()

    ##### Returns:

    - «Query» copy

    Make a copy of this query so you can re-execute it.

    #### [Example:](#example)

    ``` javascript
    const q = Book.findOne({ title: 'Casino Royale' });
    await q.exec();
    await q.exec(); // Throws an error because you can't execute a query twice

    await q.clone().exec(); // Works
    ```
- name: Query.prototype.collation()
  id: api/query#Query.prototype.collation()
  summary: null
  belongs_to: Query
  description: |-
    ### Query.prototype.collation()

    ##### Parameters:

    - `value` «Object»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [MongoDB docs](https://www.mongodb.com/docs/manual/reference/method/cursor.collation/#cursor.collation)

    Adds a collation to this op (MongoDB 3.4 and up)
- name: Query.prototype.comment()
  id: api/query#Query.prototype.comment()
  summary: Specifies the comment option
  belongs_to: Query
  description: |-
    ### Query.prototype.comment()

    ##### Parameters:

    - `val` «String»

    ##### See:

    -  [comment](https://www.mongodb.com/docs/manual/reference/operator/comment/)

    Specifies the `comment` option.

    #### [Example:](#example)

    ``` javascript
    query.comment('login query')
    ```

    #### [Note:](#note)

    Cannot be used with `distinct()`
- name: Query.prototype.count()
  id: api/query#Query.prototype.count()
  summary: Specifies this query as a count query
  belongs_to: Query
  description: |-
    ### Query.prototype.count()

    ~DEPRECATED~

    ##### Parameters:

    - `[filter]`«Object» count documents that match this object

    ##### Returns:

    - «Query» this

    ##### See:

    -  [count](https://www.mongodb.com/docs/manual/reference/method/db.collection.count/)

    Specifies this query as a `count` query.

    This method is deprecated. If you want to count the number of documents in a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](#Query.prototype.estimatedDocumentCount()) instead. Otherwise, use the [`countDocuments()`](#Query.prototype.countDocuments()) function instead.

    This function triggers the following middleware.

    - `count()`

    #### [Example:](#example)

    ``` javascript
    const countQuery = model.where({ 'color': 'black' }).count();

    query.count({ color: 'black' }).count().exec();

    await query.count({ color: 'black' });

    query.where('color', 'black').count();
    ```
- name: Query.prototype.countDocuments()
  id: api/query#Query.prototype.countDocuments()
  summary: Specifies this query as a countDocuments() query
  belongs_to: Query
  description: |-
    ### Query.prototype.countDocuments()

    ##### Parameters:

    - `[filter]`«Object» mongodb selector
    - `[options]` «Object»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [countDocuments](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments)

    Specifies this query as a `countDocuments()` query. Behaves like `count()`, except it always does a full collection scan when passed an empty filter `{}`.

    There are also minor differences in how `countDocuments()` handles [`$where` and a couple geospatial operators](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments). versus `count()`.

    This function triggers the following middleware.

    - `countDocuments()`

    #### [Example:](#example)

    ``` javascript
    const countQuery = model.where({ 'color': 'black' }).countDocuments();

    query.countDocuments({ color: 'black' }).count().exec();

    await query.countDocuments({ color: 'black' });

    query.where('color', 'black').countDocuments().exec();
    ```

    The `countDocuments()` function is similar to `count()`, but there are a [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments). Below are the operators that `count()` supports but `countDocuments()` does not, and the suggested replacement:

    - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)
    - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)
    - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)
- name: Query.prototype.cursor()
  id: api/query#Query.prototype.cursor()
  summary: Returns a wrapper around a mongodb driver cursor
  belongs_to: Query
  description: |-
    ### Query.prototype.cursor()

    ##### Parameters:

    - `[options]` «Object»

    ##### Returns:

    - «QueryCursor»

    ##### See:

    -  [QueryCursor](querycursor)

    Returns a wrapper around a [mongodb driver cursor](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html). A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.

    The `.cursor()` function triggers pre find hooks, but **not** post find hooks.

    #### [Example:](#example)

    ``` javascript
    // There are 2 ways to use a cursor. First, as a stream:Thing.
      find({ name: /^hello/ }).
      cursor().
      on('data', function(doc) { console.log(doc); }).
      on('end', function() { console.log('Done!'); });

    // Or you can use `.next()` to manually get the next doc in the stream.
    // `.next()` returns a promise, so you can use promises or callbacks.
    const cursor = Thing.find({ name: /^hello/ }).cursor();
    cursor.next(function(error, doc) {
      console.log(doc);
    });

    // Because `.next()` returns a promise, you can use co
    // to easily iterate through all documents without loading them
    // all into memory.
    const cursor = Thing.find({ name: /^hello/ }).cursor();
    for (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {
      console.log(doc);
    }
    ```

    #### [Valid options](#valid-options)

    - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.
- name: Query.prototype.deleteMany()
  id: api/query#Query.prototype.deleteMany()
  summary: Declare and/or execute this query as a deleteMany() operation
  belongs_to: Query
  description: |-
    ### Query.prototype.deleteMany()

    ##### Parameters:

    - `[filter]`«Object\|Query» mongodb selector
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](#Query.prototype.setOptions())

    ##### Returns:

    - «Query» this

    ##### See:

    -  [DeleteResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html)
    -  [deleteMany](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany)

    Declare and/or execute this query as a `deleteMany()` operation. Works like remove, except it deletes *every* document that matches `filter` in the collection, regardless of the value of `single`.

    This function triggers `deleteMany` middleware.

    #### [Example:](#example)

    ``` javascript
    awaitCharacter.deleteMany({ name: /Stark/, age: { $gte: 18 } });
    ```

    This function calls the MongoDB driver's [`Collection#deleteMany()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany). The returned [promise](../queries) resolves to an object that contains 3 properties:

    - `ok`: `1` if no errors occurred
    - `deletedCount`: the number of documents deleted
    - `n`: the number of documents deleted. Equal to `deletedCount`.

    #### [Example:](#example-1)

    ``` javascript
    const res = await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });
    // `0` if no docs matched the filter, number of docs deleted otherwise
    res.deletedCount;
    ```
- name: Query.prototype.deleteOne()
  id: api/query#Query.prototype.deleteOne()
  summary: Declare and/or execute this query as a deleteOne() operation
  belongs_to: Query
  description: |-
    ### Query.prototype.deleteOne()

    ##### Parameters:

    - `[filter]`«Object\|Query» mongodb selector
    - `[options]`«Object» optional see [`Query.prototype.setOptions()`](#Query.prototype.setOptions())

    ##### Returns:

    - «Query» this

    ##### See:

    -  [DeleteResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html)
    -  [deleteOne](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne)

    Declare and/or execute this query as a `deleteOne()` operation. Works like remove, except it deletes at most one document regardless of the `single` option.

    This function triggers `deleteOne` middleware.

    #### [Example:](#example)

    ``` javascript
    awaitCharacter.deleteOne({ name: 'Eddard Stark' });
    ```

    This function calls the MongoDB driver's [`Collection#deleteOne()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne). The returned [promise](../queries) resolves to an object that contains 3 properties:

    - `ok`: `1` if no errors occurred
    - `deletedCount`: the number of documents deleted
    - `n`: the number of documents deleted. Equal to `deletedCount`.

    #### [Example:](#example-1)

    ``` javascript
    const res = await Character.deleteOne({ name: 'Eddard Stark' });
    // `1` if MongoDB deleted a doc, `0` if no docs matched the filter `{ name: ... }`
    res.deletedCount;
    ```
- name: Query.prototype.distinct()
  id: api/query#Query.prototype.distinct()
  summary: Declares or executes a distinct() operation
  belongs_to: Query
  description: |-
    ### Query.prototype.distinct()

    ##### Parameters:

    - `[field]` «String»
    - `[filter]` «Object\|Query»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [distinct](https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/)

    Declares or executes a distinct() operation.

    This function does not trigger any middleware.

    #### [Example:](#example)

    ``` javascript
    distinct(field, conditions)
    distinct(field)
    distinct()
    ```
- name: Query.prototype.elemMatch()
  id: api/query#Query.prototype.elemMatch()
  summary: null
  belongs_to: Query
  description: |-
    ### Query.prototype.elemMatch()

    ##### Parameters:

    - `path` «String\|Object\|Function»
    - `filter` «Object\|Function»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$elemMatch](https://www.mongodb.com/docs/manual/reference/operator/elemMatch/)

    Specifies an `$elemMatch` condition

    #### [Example:](#example)

    ``` javascript
    query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})

    query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})

    query.elemMatch('comment', function (elem) {
      elem.where('author').equals('autobot');
      elem.where('votes').gte(5);
    })

    query.where('comment').elemMatch(function (elem) {
      elem.where({ author: 'autobot' });
      elem.where('votes').gte(5);
    })
    ```
- name: Query.prototype.equals()
  id: api/query#Query.prototype.equals()
  summary: null
  belongs_to: Query
  description: |-
    ### Query.prototype.equals()

    ##### Parameters:

    - `val` «Object»

    ##### Returns:

    - «Query» this

    Specifies the complementary comparison value for paths specified with `where()`

    #### [Example:](#example)

    ``` javascript
    User.where('age').equals(49);

    // is the same asUser.where('age', 49);
    ```
- name: Query.prototype.error()
  id: api/query#Query.prototype.error()
  summary: Gets/sets the error flag on this query
  belongs_to: Query
  description: |-
    ### Query.prototype.error()

    ##### Parameters:

    - `err`«Error\|null» if set, `exec()` will fail fast before sending the query to MongoDB

    ##### Returns:

    - «Query» this

    Gets/sets the error flag on this query. If this flag is not null or undefined, the `exec()` promise will reject without executing.

    #### [Example:](#example)

    ``` javascript
    Query().error(); // Get current error valueQuery().error(null); // Unset the current errorQuery().error(newError('test')); // `exec()` will resolve with testSchema.pre('find', function() {
      if (!this.getQuery().userId) {
        this.error(new Error('Not allowed to query without setting userId'));
      }
    });
    ```

    Note that query casting runs **after** hooks, so cast errors will override custom errors.

    #### [Example:](#example-1)

    ``` javascript
    constTestSchema = new Schema({ num: Number });
    const TestModel = db.model('Test', TestSchema);
    TestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {
      // `error` will be a cast error because `num` failed to cast
    });
    ```
- name: Query.prototype.estimatedDocumentCount()
  id: api/query#Query.prototype.estimatedDocumentCount()
  summary: Specifies this query as a estimatedDocumentCount() query
  belongs_to: Query
  description: |-
    ### Query.prototype.estimatedDocumentCount()

    ##### Parameters:

    - `[options]`«Object» passed transparently to the [MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/EstimatedDocumentCountOptions.html)

    ##### Returns:

    - «Query» this

    ##### See:

    -  [estimatedDocumentCount](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount)

    Specifies this query as a `estimatedDocumentCount()` query. Faster than using `countDocuments()` for large collections because `estimatedDocumentCount()` uses collection metadata rather than scanning the entire collection.

    `estimatedDocumentCount()` does **not** accept a filter. `Model.find({ foo: bar }).estimatedDocumentCount()` is equivalent to `Model.find().estimatedDocumentCount()`

    This function triggers the following middleware.

    - `estimatedDocumentCount()`

    #### [Example:](#example)

    ``` javascript
    awaitModel.find().estimatedDocumentCount();
    ```
- name: Query.prototype.exec()
  id: api/query#Query.prototype.exec()
  summary: null
  belongs_to: Query
  description: |-
    ### Query.prototype.exec()

    ##### Parameters:

    - `[operation]` «String\|Function»

    ##### Returns:

    - «Promise»

    Executes the query

    #### [Example:](#example)

    ``` javascript
    const promise = query.exec();
    const promise = query.exec('update');
    ```
- name: Query.prototype.exists()
  id: api/query#Query.prototype.exists()
  summary: null
  belongs_to: Query
  description: |-
    ### Query.prototype.exists()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Boolean»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$exists](https://www.mongodb.com/docs/manual/reference/operator/exists/)

    Specifies an `$exists` condition

    #### [Example:](#example)

    ``` javascript
    // { name: { $exists: true }}Thing.where('name').exists()
    Thing.where('name').exists(true)
    Thing.find().exists('name')

    // { name: { $exists: false }}Thing.where('name').exists(false);
    Thing.find().exists('name', false);
    ```
- name: Query.prototype.explain()
  id: api/query#Query.prototype.explain()
  summary: Sets the explain option, which makes this query return detailed execution stats instead of the actual query result
  belongs_to: Query
  description: |-
    ### Query.prototype.explain()

    ##### Parameters:

    - `[verbose]`«String» The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'

    ##### Returns:

    - «Query» this

    Sets the [`explain` option](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/), which makes this query return detailed execution stats instead of the actual query result. This method is useful for determining what index your queries use.

    Calling `query.explain(v)` is equivalent to `query.setOptions({ explain: v })`

    #### [Example:](#example)

    ``` javascript
    const query = new Query();
    const res = await query.find({ a: 1 }).explain('queryPlanner');
    console.log(res);
    ```
- name: Query.prototype.finally()
  id: api/query#Query.prototype.finally()
  summary: Executes the query returning a Promise which will be resolved with .finally() chained
  belongs_to: Query
  description: |-
    ### Query.prototype.finally()

    ##### Parameters:

    - `[onFinally]` «Function»

    ##### Returns:

    - «Promise»

    Executes the query returning a `Promise` which will be resolved with `.finally()` chained.

    More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).
- name: Query.prototype.find()
  id: api/query#Query.prototype.find()
  summary: Find all documents that match selector
  belongs_to: Query
  description: |-
    ### Query.prototype.find()

    ##### Parameters:

    - `[filter]`«Object\|ObjectId» mongodb filter. If not specified, returns all documents.

    ##### Returns:

    - «Query» this

    Find all documents that match `selector`. The result will be an array of documents.

    If there are too many documents in the result to fit in memory, use [`Query.prototype.cursor()`](#Query.prototype.cursor())

    #### [Example:](#example)

    ``` javascript
    const arr = await Movie.find({ year: { $gte: 1980, $lte: 1989 } });
    ```
- name: Query.prototype.findOne()
  id: api/query#Query.prototype.findOne()
  summary: '[options.translateAliases=null]«Boolean» If set to true, translates any schema-defined aliases in filter, projection, update, and distinct'
  belongs_to: Query
  description: |-
    ### Query.prototype.findOne()

    ##### Parameters:

    - `[filter]`«Object» mongodb selector
    - `[projection]`«Object» optional fields to return
    - `[options]`«Object» see [`setOptions()`](#Query.prototype.setOptions())

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query» this

    ##### See:

    -  [findOne](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/)
    -  [Query.select](#Query.prototype.select())

    Declares the query a findOne operation. When executed, the first found document is passed to the callback.

    The result of the query is a single document, or `null` if no document was found.

    - *Note:*`conditions` is optional, and if `conditions` is null or undefined, mongoose will send an empty `findOne` command to MongoDB, which will return an arbitrary document. If you're querying by `_id`, use `Model.findById()` instead.

    This function triggers the following middleware.

    - `findOne()`

    #### [Example:](#example)

    ``` javascript
    const query = Kitten.where({ color: 'white' });
    const kitten = await query.findOne();
    ```
- name: Query.prototype.findOneAndDelete()
  id: api/query#Query.prototype.findOneAndDelete()
  summary: Issues a MongoDB findOneAndDelete command
  belongs_to: Query
  description: |-
    ### Query.prototype.findOneAndDelete()

    ##### Parameters:

    - `[filter]` «Object»
    - `[options]` «Object»

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    ##### Returns:

    - «Query» this

    ##### See:

    -  [findAndModify command](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)

    Issues a MongoDB [findOneAndDelete](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndDelete/) command.

    Finds a matching document, removes it, and returns the found document (if any).

    This function triggers the following middleware.

    - `findOneAndDelete()`

    #### [Available options](#available-options)

    - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
    - `maxTimeMS`: puts a time limit on the query - requires mongodb \>= 2.6.0
    - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    #### [Callback Signature](#callback-signature)

    ``` javascript
    function(error, doc) {
      // error: any errors that occurred// doc: the document before updates are applied if `new: false`, or after updates if `new = true`
    }
    ```

    #### [Example:](#example)

    ``` javascript
    A.where().findOneAndDelete(conditions, options)  // return Query
    A.where().findOneAndDelete(conditions) // returns Query
    A.where().findOneAndDelete()           // returns Query
    ```
- name: Query.prototype.findOneAndRemove()
  id: api/query#Query.prototype.findOneAndRemove()
  summary: Legacy alias for findOneAndDelete()
  belongs_to: Query
  description: |-
    ### Query.prototype.findOneAndRemove()

    ##### Parameters:

    - `[conditions]` «Object»
    - `[options]` «Object»

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    ##### Returns:

    - «Query» this

    ##### See:

    -  [findAndModify command](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)

    Legacy alias for `findOneAndDelete()`.

    Finds a matching document, removes it, returns the found document (if any).

    This function triggers the following middleware.

    - `findOneAndRemove()`

    #### [Available options](#available-options)

    - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
    - `maxTimeMS`: puts a time limit on the query - requires mongodb \>= 2.6.0
    - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    #### [Example:](#example)

    ``` javascript
    A.where().findOneAndRemove(conditions, options)  // return Query
    A.where().findOneAndRemove(conditions) // returns Query
    A.where().findOneAndRemove()           // returns Query
    ```
- name: Query.prototype.findOneAndReplace()
  id: api/query#Query.prototype.findOneAndReplace()
  summary: Issues a MongoDB findOneAndReplace command
  belongs_to: Query
  description: |-
    ### Query.prototype.findOneAndReplace()

    ##### Parameters:

    - `[filter]` «Object»
    - `[replacement]` «Object»
    - `[options]` «Object»

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.new=false]`«Boolean» By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.

    &nbsp;

    - `[options.lean]`«Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.returnOriginal=null]`«Boolean» An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query» this

    Issues a MongoDB [findOneAndReplace](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndReplace/) command.

    Finds a matching document, removes it, and returns the found document (if any).

    This function triggers the following middleware.

    - `findOneAndReplace()`

    #### [Available options](#available-options)

    - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
    - `maxTimeMS`: puts a time limit on the query - requires mongodb \>= 2.6.0
    - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    #### [Callback Signature](#callback-signature)

    ``` javascript
    function(error, doc) {
      // error: any errors that occurred// doc: the document before updates are applied if `new: false`, or after updates if `new = true`
    }
    ```

    #### [Example:](#example)

    ``` javascript
    A.where().findOneAndReplace(filter, replacement, options); // return Query
    A.where().findOneAndReplace(filter); // returns Query
    A.where().findOneAndReplace(); // returns Query
    ```
- name: Query.prototype.findOneAndUpdate()
  id: api/query#Query.prototype.findOneAndUpdate()
  summary: Issues a mongodb findOneAndUpdate() command
  belongs_to: Query
  description: |-
    ### Query.prototype.findOneAndUpdate()

    ##### Parameters:

    - `[filter]` «Object\|Query»
    - `[doc]` «Object»
    - `[options]` «Object»

    &nbsp;

    - `[options.rawResult]`«Boolean» if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.multipleCastError]`«Boolean» by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.

    &nbsp;

    - `[options.new=false]`«Boolean» By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.

    &nbsp;

    - `[options.lean]`«Object» if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](#Query.prototype.lean()) and [the Mongoose lean tutorial](../tutorials/lean).

    &nbsp;

    - `[options.session=null]`«ClientSession» The session associated with this query. See [transactions docs](../transactions).

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.returnOriginal=null]`«Boolean» An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    ##### Returns:

    - «Query» this

    ##### See:

    -  [Tutorial](../tutorials/findoneandupdate)
    -  [findAndModify command](https://www.mongodb.com/docs/manual/reference/command/findAndModify/)
    -  [ModifyResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)
    -  [findOneAndUpdate](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#findOneAndUpdate)

    Issues a mongodb `findOneAndUpdate()` command.

    Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any).

    This function triggers the following middleware.

    - `findOneAndUpdate()`

    #### [Available options](#available-options)

    - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)
    - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
    - `fields`: {Object\|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`
    - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
    - `maxTimeMS`: puts a time limit on the query - requires mongodb \>= 2.6.0
    - `runValidators`: if true, runs [update validators](../validation#update-validators) on this command. Update validators validate the update operation against the model's schema.
    - `setDefaultsOnInsert`: `true` by default. If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](../defaults) specified in the model's schema if a new document is created.
    - `rawResult`: if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)

    #### [Example:](#example)

    ``` javascript
    query.findOneAndUpdate(conditions, update, options)  // returns Query
    query.findOneAndUpdate(conditions, update)           // returns Query
    query.findOneAndUpdate(update)                       // returns Query
    query.findOneAndUpdate()                             // returns Query
    ```
- name: Query.prototype.geometry()
  id: api/query#Query.prototype.geometry()
  summary: The argument is assigned to the most recent path passed to where()
  belongs_to: Query
  description: |-
    ### Query.prototype.geometry()

    ##### Parameters:

    - `object`«Object» Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$geometry](https://www.mongodb.com/docs/manual/reference/operator/geometry/)
    -  [Geospatial Support Enhancements](https://www.mongodb.com/docs/manual/release-notes/2.4/#geospatial-support-enhancements)
    -  [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)

    Specifies a `$geometry` condition

    #### [Example:](#example)

    ``` javascript
    const polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
    query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })

    // or
    const polyB = [[ 0, 0 ], [ 1, 1 ]]
    query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })

    // or
    const polyC = [ 0, 0 ]
    query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })

    // or
    query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })
    ```

    The argument is assigned to the most recent path passed to `where()`.

    #### [Note:](#note)

    `geometry()`**must** come after either `intersects()` or `within()`.

    The `object` argument must contain `type` and `coordinates` properties.

    - type {String}
    - coordinates {Array}
- name: Query.prototype.get()
  id: api/query#Query.prototype.get()
  summary: For update operations, returns the value of a path in the update's $set
  belongs_to: Query
  description: |-
    ### Query.prototype.get()

    ##### Parameters:

    - `path`«String\|Object» path or object of key/value pairs to get

    ##### Returns:

    - «Query» this

    For update operations, returns the value of a path in the update's `$set`. Useful for writing getters/setters that can work with both update operations and `save()`.

    #### [Example:](#example)

    ``` javascript
    const query = Model.updateOne({}, { $set: { name: 'Jean-Luc Picard' } });
    query.get('name'); // 'Jean-Luc Picard'
    ```
- name: Query.prototype.getFilter()
  id: api/query#Query.prototype.getFilter()
  summary: Returns the current query filter (also known as conditions) as a POJO
  belongs_to: Query
  description: |-
    ### Query.prototype.getFilter()

    ##### Returns:

    - «Object» current query filter

    Returns the current query filter (also known as conditions) as a [POJO](https://masteringjs.io/tutorials/fundamentals/pojo).

    #### [Example:](#example)

    ``` javascript
    const query = new Query();
    query.find({ a: 1 }).where('b').gt(2);
    query.getFilter(); // { a: 1, b: { $gt: 2 } }
    ```
- name: Query.prototype.getOptions()
  id: api/query#Query.prototype.getOptions()
  summary: Gets query options
  belongs_to: Query
  description: |-
    ### Query.prototype.getOptions()

    ##### Returns:

    - «Object» the options

    Gets query options.

    #### [Example:](#example)

    ``` javascript
    const query = new Query();
    query.limit(10);
    query.setOptions({ maxTimeMS: 1000 });
    query.getOptions(); // { limit: 10, maxTimeMS: 1000 }
    ```
- name: Query.prototype.getPopulatedPaths()
  id: api/query#Query.prototype.getPopulatedPaths()
  summary: null
  belongs_to: Query
  description: |-
    ### Query.prototype.getPopulatedPaths()

    ##### Returns:

    - «Array» an array of strings representing populated paths

    Gets a list of paths to be populated by this query

    #### [Example:](#example)

    ``` javascript
     bookSchema.pre('findOne', function() {
       let keys = this.getPopulatedPaths(); // ['author']
     });
     ...
     Book.findOne({}).populate('author');
    ```

    #### [Example:](#example-1)

    ``` javascript
    // Deep populateconst q = L1.find().populate({
       path: 'level2',
       populate: { path: 'level3' }
     });
     q.getPopulatedPaths(); // ['level2', 'level2.level3']
    ```
- name: Query.prototype.getQuery()
  id: api/query#Query.prototype.getQuery()
  summary: Returns the current query filter
  belongs_to: Query
  description: |-
    ### Query.prototype.getQuery()

    ##### Returns:

    - «Object» current query filter

    Returns the current query filter. Equivalent to `getFilter()`.

    You should use `getFilter()` instead of `getQuery()` where possible. `getQuery()` will likely be deprecated in a future release.

    #### [Example:](#example)

    ``` javascript
    const query = new Query();
    query.find({ a: 1 }).where('b').gt(2);
    query.getQuery(); // { a: 1, b: { $gt: 2 } }
    ```
- name: Query.prototype.getUpdate()
  id: api/query#Query.prototype.getUpdate()
  summary: Returns the current update operations as a JSON object
  belongs_to: Query
  description: |-
    ### Query.prototype.getUpdate()

    ##### Returns:

    - «Object» current update operations

    Returns the current update operations as a JSON object.

    #### [Example:](#example)

    ``` javascript
    const query = new Query();
    query.updateOne({}, { $set: { a: 5 } });
    query.getUpdate(); // { $set: { a: 5 } }
    ```
- name: Query.prototype.gt()
  id: api/query#Query.prototype.gt()
  summary: Specifies a $gt query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.gt()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Number»

    ##### See:

    -  [$gt](https://www.mongodb.com/docs/manual/reference/operator/gt/)

    Specifies a `$gt` query condition.

    When called with one argument, the most recent path passed to `where()` is used.

    #### [Example:](#example)

    ``` javascript
    Thing.find().where('age').gt(21);

    // orThing.find().gt('age', 21);
    ```
- name: Query.prototype.gte()
  id: api/query#Query.prototype.gte()
  summary: Specifies a $gte query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.gte()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Number»

    ##### See:

    -  [$gte](https://www.mongodb.com/docs/manual/reference/operator/gte/)

    Specifies a `$gte` query condition.

    When called with one argument, the most recent path passed to `where()` is used.
- name: Query.prototype.hint()
  id: api/query#Query.prototype.hint()
  summary: Sets query hints
  belongs_to: Query
  description: |-
    ### Query.prototype.hint()

    ##### Parameters:

    - `val`«Object» a hint object

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$hint](https://www.mongodb.com/docs/manual/reference/operator/hint/)

    Sets query hints.

    #### [Example:](#example)

    ``` javascript
    query.hint({ indexA: 1, indexB: -1 });
    ```

    #### [Note:](#note)

    Cannot be used with `distinct()`
- name: Query.prototype.in()
  id: api/query#Query.prototype.in()
  summary: Specifies an $in query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.in()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Array»

    ##### See:

    -  [$in](https://www.mongodb.com/docs/manual/reference/operator/in/)

    Specifies an `$in` query condition.

    When called with one argument, the most recent path passed to `where()` is used.
- name: Query.prototype.intersects()
  id: api/query#Query.prototype.intersects()
  summary: Declares an intersects query for geometry()
  belongs_to: Query
  description: |-
    ### Query.prototype.intersects()

    ##### Parameters:

    - `[arg]` «Object»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$geometry](https://www.mongodb.com/docs/manual/reference/operator/geometry/)
    -  [geoIntersects](https://www.mongodb.com/docs/manual/reference/operator/geoIntersects/)

    Declares an intersects query for `geometry()`.

    #### [Example:](#example)

    ``` javascript
    query.where('path').intersects().geometry({
      type: 'LineString',
      coordinates: [[180.0, 11.0], [180, 9.0]]
    });

    query.where('path').intersects({
      type: 'LineString',
      coordinates: [[180.0, 11.0], [180, 9.0]]
    });
    ```

    #### [Note:](#note)

    **MUST** be used after `where()`.

    #### [Note:](#note-1)

    In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).
- name: Query.prototype.isPathSelectedInclusive()
  id: api/query#Query.prototype.isPathSelectedInclusive()
  summary: Wrapper function to call isPathSelectedInclusive on a query
  belongs_to: Query
  description: |-
    ### Query.prototype.isPathSelectedInclusive()

    ##### Parameters:

    - `path` «String»

    ##### Returns:

    - «Boolean»

    Wrapper function to call isPathSelectedInclusive on a query.
- name: Query.prototype.j()
  id: api/query#Query.prototype.j()
  summary: Requests acknowledgement that this operation has been persisted to MongoDB's on-disk journal
  belongs_to: Query
  description: |-
    ### Query.prototype.j()

    ##### Parameters:

    - `val` «boolean»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)

    Requests acknowledgement that this operation has been persisted to MongoDB's on-disk journal. This option is only valid for operations that write to the database:

    - `deleteOne()`
    - `deleteMany()`
    - `findOneAndDelete()`
    - `findOneAndReplace()`
    - `findOneAndUpdate()`
    - `updateOne()`
    - `updateMany()`

    Defaults to the schema's [`writeConcern.j` option](../guide#writeConcern)

    #### [Example:](#example)

    ``` javascript
    await mongoose.model('Person').deleteOne({ name: 'Ned Stark' }).j(true);
    ```
- name: Query.prototype.lean()
  id: api/query#Query.prototype.lean()
  summary: Sets the lean option
  belongs_to: Query
  description: |-
    ### Query.prototype.lean()

    ##### Parameters:

    - `bool`«Boolean\|Object» defaults to true

    ##### Returns:

    - «Query» this

    Sets the lean option.

    Documents returned from queries with the `lean` option enabled are plain javascript objects, not [Mongoose Documents](document). They have no `save` method, getters/setters, virtuals, or other Mongoose features.

    #### [Example:](#example)

    ``` javascript
    newQuery().lean() // truenewQuery().lean(true)
    newQuery().lean(false)

    const docs = await Model.find().lean();
    docs[0] instanceof mongoose.Document; // false
    ```

    [Lean is great for high-performance, read-only cases](../tutorials/lean), especially when combined with [cursors](../queries#streaming).

    If you need virtuals, getters/setters, or defaults with `lean()`, you need to use a plugin. See:

    - [mongoose-lean-virtuals](https://plugins.mongoosejs.io/plugins/lean-virtuals)
    - [mongoose-lean-getters](https://plugins.mongoosejs.io/plugins/lean-getters)
    - [mongoose-lean-defaults](https://www.npmjs.com/package/mongoose-lean-defaults)
- name: Query.prototype.limit()
  id: api/query#Query.prototype.limit()
  summary: Specifies the maximum number of documents the query will return
  belongs_to: Query
  description: |-
    ### Query.prototype.limit()

    ##### Parameters:

    - `val` «Number»

    Specifies the maximum number of documents the query will return.

    #### [Example:](#example)

    ``` javascript
    query.limit(20);
    ```

    #### [Note:](#note)

    Cannot be used with `distinct()`
- name: Query.prototype.lt()
  id: api/query#Query.prototype.lt()
  summary: Specifies a $lt query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.lt()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Number»

    ##### See:

    -  [$lt](https://www.mongodb.com/docs/manual/reference/operator/lt/)

    Specifies a `$lt` query condition.

    When called with one argument, the most recent path passed to `where()` is used.
- name: Query.prototype.lte()
  id: api/query#Query.prototype.lte()
  summary: Specifies a $lte query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.lte()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Number»

    ##### See:

    -  [$lte](https://www.mongodb.com/docs/manual/reference/operator/lte/)

    Specifies a `$lte` query condition.

    When called with one argument, the most recent path passed to `where()` is used.
- name: Query.prototype.maxDistance()
  id: api/query#Query.prototype.maxDistance()
  summary: Specifies a maxDistance query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.maxDistance()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Number»

    ##### See:

    -  [$maxDistance](https://www.mongodb.com/docs/manual/reference/operator/maxDistance/)

    Specifies a `maxDistance` query condition.

    When called with one argument, the most recent path passed to `where()` is used.
- name: Query.prototype.maxTimeMS()
  id: api/query#Query.prototype.maxTimeMS()
  summary: Sets the maxTimeMS option
  belongs_to: Query
  description: |-
    ### Query.prototype.maxTimeMS()

    ##### Parameters:

    - `[ms]`«Number» The number of milliseconds

    ##### Returns:

    - «Query» this

    Sets the [maxTimeMS](https://www.mongodb.com/docs/manual/reference/method/cursor.maxTimeMS/) option. This will tell the MongoDB server to abort if the query or write op has been running for more than `ms` milliseconds.

    Calling `query.maxTimeMS(v)` is equivalent to `query.setOptions({ maxTimeMS: v })`

    #### [Example:](#example)

    ``` javascript
    const query = new Query();
    // Throws an error 'operation exceeded time limit' as long as there's
    // >= 1 doc in the queried collection
    const res = await query.find({ $where: 'sleep(1000) || true' }).maxTimeMS(100);
    ```
- name: Query.prototype.merge()
  id: api/query#Query.prototype.merge()
  summary: Merges another Query or conditions object into this one
  belongs_to: Query
  description: |-
    ### Query.prototype.merge()

    ##### Parameters:

    - `source` «Query\|Object»

    ##### Returns:

    - «Query» this

    Merges another Query or conditions object into this one.

    When a Query is passed, conditions, field selection and options are merged.
- name: Query.prototype.mod()
  id: api/query#Query.prototype.mod()
  summary: Specifies a $mod condition, filters documents for documents whose path property is a number that is equal to remainder modulo divisor
  belongs_to: Query
  description: |-
    ### Query.prototype.mod()

    ##### Parameters:

    - `[path]` «String»
    - `val`«Array» must be of length 2, first element is `divisor`, 2nd element is `remainder`.

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$mod](https://www.mongodb.com/docs/manual/reference/operator/mod/)

    Specifies a `$mod` condition, filters documents for documents whose `path` property is a number that is equal to `remainder` modulo `divisor`.

    #### [Example:](#example)

    ``` javascript
    // All find products whose inventory is oddProduct.find().mod('inventory', [2, 1]);
    Product.find().where('inventory').mod([2, 1]);
    // This syntax is a little strange, but supported.Product.find().where('inventory').mod(2, 1);
    ```
- name: Query.prototype.model
  id: api/query#Query.prototype.model
  summary: The model this query is associated with
  belongs_to: Query
  description: |-
    ### Query.prototype.model

    ##### Type:

    - «property»

    The model this query is associated with.

    #### [Example:](#example)

    ``` javascript
    const q = MyModel.find();
    q.model === MyModel; // true
    ```
- name: Query.prototype.mongooseOptions()
  id: api/query#Query.prototype.mongooseOptions()
  summary: Getter/setter around the current mongoose-specific options for this query Below are the current Mongoose-specific options
  belongs_to: Query
  description: |-
    ### Query.prototype.mongooseOptions()

    ##### Parameters:

    - `options`«Object» if specified, overwrites the current options

    ##### Returns:

    - «Object» the options

    Getter/setter around the current mongoose-specific options for this query Below are the current Mongoose-specific options.

    - `populate`: an array representing what paths will be populated. Should have one entry for each call to [`Query.prototype.populate()`](#Query.prototype.populate())
    - `lean`: if truthy, Mongoose will not [hydrate](model#Model.hydrate()) any documents that are returned from this query. See [`Query.prototype.lean()`](#Query.prototype.lean()) for more information.
    - `strict`: controls how Mongoose handles keys that aren't in the schema for updates. This option is `true` by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the [`strict` mode docs](../guide#strict) for more information.
    - `strictQuery`: controls how Mongoose handles keys that aren't in the schema for the query `filter`. This option is `false` by default, which means Mongoose will allow `Model.find({ foo: 'bar' })` even if `foo` is not in the schema. See the [`strictQuery` docs](../guide#strictQuery) for more information.
    - `nearSphere`: use `$nearSphere` instead of `near()`. See the [`Query.prototype.nearSphere()` docs](#Query.prototype.nearSphere())

    Mongoose maintains a separate object for internal options because Mongoose sends `Query.prototype.options` to the MongoDB server, and the above options are not relevant for the MongoDB server.
- name: Query.prototype.ne()
  id: api/query#Query.prototype.ne()
  summary: Specifies a $ne query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.ne()

    ##### Parameters:

    - `[path]` «String»
    - `val` «any»

    ##### See:

    -  [$ne](https://www.mongodb.com/docs/manual/reference/operator/ne/)

    Specifies a `$ne` query condition.

    When called with one argument, the most recent path passed to `where()` is used.
- name: Query.prototype.near()
  id: api/query#Query.prototype.near()
  summary: These operators return documents sorted by distance
  belongs_to: Query
  description: |-
    ### Query.prototype.near()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Object»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$near](https://www.mongodb.com/docs/manual/reference/operator/near/)
    -  [$nearSphere](https://www.mongodb.com/docs/manual/reference/operator/nearSphere/)
    -  [$maxDistance](https://www.mongodb.com/docs/manual/reference/operator/maxDistance/)
    -  [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)

    Specifies a `$near` or `$nearSphere` condition

    These operators return documents sorted by distance.

    #### [Example:](#example)

    ``` javascript
    query.where('loc').near({ center: [10, 10] });
    query.where('loc').near({ center: [10, 10], maxDistance: 5 });
    query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });
    query.near('loc', { center: [10, 10], maxDistance: 5 });
    ```
- name: Query.prototype.nearSphere()
  id: api/query#Query.prototype.nearSphere()
  summary: Deprecated
  belongs_to: Query
  description: |-
    ### Query.prototype.nearSphere()

    ~DEPRECATED~

    ##### See:

    -  [near()](#Query.prototype.near())
    -  [$near](https://www.mongodb.com/docs/manual/reference/operator/near/)
    -  [$nearSphere](https://www.mongodb.com/docs/manual/reference/operator/nearSphere/)
    -  [$maxDistance](https://www.mongodb.com/docs/manual/reference/operator/maxDistance/)

    *DEPRECATED* Specifies a `$nearSphere` condition

    #### [Example:](#example)

    ``` javascript
    query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });
    ```

    **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.

    #### [Example:](#example-1)

    ``` javascript
    query.where('loc').near({ center: [10, 10], spherical: true });
    ```
- name: Query.prototype.nin()
  id: api/query#Query.prototype.nin()
  summary: Specifies an $nin query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.nin()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Array»

    ##### See:

    -  [$nin](https://www.mongodb.com/docs/manual/reference/operator/nin/)

    Specifies an `$nin` query condition.

    When called with one argument, the most recent path passed to `where()` is used.
- name: Query.prototype.nor()
  id: api/query#Query.prototype.nor()
  summary: Specifies arguments for a $nor condition
  belongs_to: Query
  description: |-
    ### Query.prototype.nor()

    ##### Parameters:

    - `array`«Array» array of conditions

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$nor](https://www.mongodb.com/docs/manual/reference/operator/nor/)

    Specifies arguments for a `$nor` condition.

    #### [Example:](#example)

    ``` javascript
    query.nor([{ color: 'green' }, { status: 'ok' }]);
    ```
- name: Query.prototype.or()
  id: api/query#Query.prototype.or()
  summary: Specifies arguments for an $or condition
  belongs_to: Query
  description: |-
    ### Query.prototype.or()

    ##### Parameters:

    - `array`«Array» array of conditions

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$or](https://www.mongodb.com/docs/manual/reference/operator/or/)

    Specifies arguments for an `$or` condition.

    #### [Example:](#example)

    ``` javascript
    query.or([{ color: 'red' }, { status: 'emergency' }]);
    ```
- name: Query.prototype.orFail()
  id: api/query#Query.prototype.orFail()
  summary: Make this query throw an error if no documents match the given filter
  belongs_to: Query
  description: |-
    ### Query.prototype.orFail()

    ##### Parameters:

    - `[err]`«Function\|Error» optional error to throw if no docs match `filter`. If not specified, `orFail()` will throw a `DocumentNotFoundError`

    ##### Returns:

    - «Query» this

    Make this query throw an error if no documents match the given `filter`. This is handy for integrating with async/await, because `orFail()` saves you an extra `if` statement to check if no document was found.

    #### [Example:](#example)

    ``` javascript
    // Throws if no doc returnedawaitModel.findOne({ foo: 'bar' }).orFail();

    // Throws if no document was updated. Note that `orFail()` will still
    // throw if the only document that matches is `{ foo: 'bar', name: 'test' }`,
    // because `orFail()` will throw if no document was _updated_, not
    // if no document was _found_.
    await Model.updateOne({ foo: 'bar' }, { name: 'test' }).orFail();

    // Throws "No docs found!" error if no docs match `{ foo: 'bar' }`
    await Model.find({ foo: 'bar' }).orFail(new Error('No docs found!'));

    // Throws "Not found" error if no document was found
    await Model.findOneAndUpdate({ foo: 'bar' }, { name: 'test' }).
      orFail(() => Error('Not found'));
    ```
- name: Query.prototype.polygon()
  id: api/query#Query.prototype.polygon()
  summary: null
  belongs_to: Query
  description: |-
    ### Query.prototype.polygon()

    ##### Parameters:

    - `[path]` «String\|Array»
    - `[...coordinatePairs]` «Array\|Object»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$polygon](https://www.mongodb.com/docs/manual/reference/operator/polygon/)
    -  [MongoDB Geospatial Indexing](https://www.mongodb.com/docs/manual/core/geospatial-indexes/)

    Specifies a `$polygon` condition

    #### [Example:](#example)

    ``` javascript
    query.where('loc').within().polygon([10, 20], [13, 25], [7, 15]);
    query.polygon('loc', [10, 20], [13, 25], [7, 15]);
    ```
- name: Query.prototype.populate()
  id: api/query#Query.prototype.populate()
  summary: Specifies paths which should be populated with other documents
  belongs_to: Query
  description: |-
    ### Query.prototype.populate()

    ##### Parameters:

    - `path`«Object\|String\|Array\[String\]» either the path(s) to populate or an object specifying all parameters
    - `[select]`«Object\|String» Field selection for the population query
    - `[model]`«Model» The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.
    - `[match]`«Object» Conditions for the population query
    - `[options]`«Object» Options for the population query (sort, etc)

    &nbsp;

    - `[options.path=null]`«String» The path to populate.

    &nbsp;

    - `[options.retainNullValues=false]`«boolean» by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.

    &nbsp;

    - `[options.getters=false]`«boolean» if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](../schematypes#schematype-options).

    &nbsp;

    - `[options.clone=false]`«boolean» When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.

    &nbsp;

    - `[options.match=null]`«Object\|Function» Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.

    &nbsp;

    - `[options.transform=null]`«Function» Function that Mongoose will call on every populated document that allows you to transform the populated document.

    &nbsp;

    - `[options.options=null]`«Object» Additional options like `limit` and `lean`.

    ##### Returns:

    - «Query» this

    ##### See:

    -  [population](../populate)
    -  [Query#select](#Query.prototype.select())
    -  [Model.populate](model#Model.populate())

    Specifies paths which should be populated with other documents.

    #### [Example:](#example)

    ``` javascript
    let book = await Book.findOne().populate('authors');
    book.title; // 'Node.js in Action'
    book.authors[0].name; // 'TJ Holowaychuk'
    book.authors[1].name; // 'Nathan Rajlich'

    let books = await Book.find().populate({
      path: 'authors',
      // `match` and `sort` apply to the Author model,
      // not the Book model. These options do not affect
      // which documents are in `books`, just the order and
      // contents of each book document's `authors`.
      match: { name: new RegExp('.*h.*', 'i') },
      sort: { name: -1 }
    });
    books[0].title; // 'Node.js in Action'
    // Each book's `authors` are sorted by name, descending.
    books[0].authors[0].name; // 'TJ Holowaychuk'
    books[0].authors[1].name; // 'Marc Harter'

    books[1].title; // 'Professional AngularJS'
    // Empty array, no authors' name has the letter 'h'
    books[1].authors; // []
    ```

    Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.
- name: Query.prototype.post()
  id: api/query#Query.prototype.post()
  summary: Add post middleware to this query instance
  belongs_to: Query
  description: |-
    ### Query.prototype.post()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «Promise»

    Add post [middleware](../middleware) to this query instance. Doesn't affect other queries.

    #### [Example:](#example)

    ``` javascript
    const q1 = Question.find({ answer: 42 });
    q1.post(function middleware() {
      console.log(this.getFilter());
    });
    await q1.exec(); // Prints "{ answer: 42 }"

    // Doesn't print anything, because `middleware()` is only
    // registered on `q1`.
    await Question.find({ answer: 42 });
    ```
- name: Query.prototype.pre()
  id: api/query#Query.prototype.pre()
  summary: Add pre middleware to this query instance
  belongs_to: Query
  description: |-
    ### Query.prototype.pre()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «Promise»

    Add pre [middleware](../middleware) to this query instance. Doesn't affect other queries.

    #### [Example:](#example)

    ``` javascript
    const q1 = Question.find({ answer: 42 });
    q1.pre(function middleware() {
      console.log(this.getFilter());
    });
    await q1.exec(); // Prints "{ answer: 42 }"

    // Doesn't print anything, because `middleware()` is only
    // registered on `q1`.
    await Question.find({ answer: 42 });
    ```
- name: Query.prototype.projection()
  id: api/query#Query.prototype.projection()
  summary: Get/set the current projection (AKA fields)
  belongs_to: Query
  description: |-
    ### Query.prototype.projection()

    ##### Parameters:

    - `arg` «Object\|null»

    ##### Returns:

    - «Object» the current projection

    Get/set the current projection (AKA fields). Pass `null` to remove the current projection.

    Unlike `projection()`, the `select()` function modifies the current projection in place. This function overwrites the existing projection.

    #### [Example:](#example)

    ``` javascript
    const q = Model.find();
    q.projection(); // null

    q.select('a b');
    q.projection(); // { a: 1, b: 1 }

    q.projection({ c: 1 });
    q.projection(); // { c: 1 }

    q.projection(null);
    q.projection(); // null
    ```
- name: Query.prototype.read()
  id: api/query#Query.prototype.read()
  summary: Determines the MongoDB nodes from which to read
  belongs_to: Query
  description: |-
    ### Query.prototype.read()

    ##### Parameters:

    - `mode`«String» one of the listed preference options or aliases
    - `[tags]`«Array» optional tags for this query

    ##### Returns:

    - «Query» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)

    Determines the MongoDB nodes from which to read.

    #### [Preferences:](#preferences)

    ``` javascript
    primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
    secondary            Read from secondary if available, otherwise error.
    primaryPreferred     Read from primary if available, otherwise a secondary.
    secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
    nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
    ```

    Aliases

    ``` javascript
    p   primary
    pp  primaryPreferred
    s   secondary
    sp  secondaryPreferred
    n   nearest
    ```

    #### [Example:](#example)

    ``` javascript
    newQuery().read('primary')
    newQuery().read('p')  // same as primarynewQuery().read('primaryPreferred')
    newQuery().read('pp') // same as primaryPreferrednewQuery().read('secondary')
    newQuery().read('s')  // same as secondarynewQuery().read('secondaryPreferred')
    newQuery().read('sp') // same as secondaryPreferrednewQuery().read('nearest')
    newQuery().read('n')  // same as nearest// read from secondaries with matching tagsnewQuery().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])
    ```

    Read more about how to use read preferences [here](https://www.mongodb.com/docs/manual/applications/replication/#read-preference).
- name: Query.prototype.readConcern()
  id: api/query#Query.prototype.readConcern()
  summary: Sets the readConcern option for the query
  belongs_to: Query
  description: |-
    ### Query.prototype.readConcern()

    ##### Parameters:

    - `level`«String» one of the listed read concern level or their aliases

    ##### Returns:

    - «Query» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/read-concern/)

    Sets the readConcern option for the query.

    #### [Example:](#example)

    ``` javascript
    newQuery().readConcern('local')
    newQuery().readConcern('l')  // same as localnewQuery().readConcern('available')
    newQuery().readConcern('a')  // same as availablenewQuery().readConcern('majority')
    newQuery().readConcern('m')  // same as majoritynewQuery().readConcern('linearizable')
    newQuery().readConcern('lz') // same as linearizablenewQuery().readConcern('snapshot')
    newQuery().readConcern('s')  // same as snapshot
    ```

    #### [Read Concern Level:](#read-concern-level)

    ``` javascript
    local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
    available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).
    majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.
    linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.
    snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern "majority", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.
    ```

    Aliases

    ``` javascript
    l   local
    a   available
    m   majority
    lz  linearizable
    s   snapshot
    ```

    Read more about how to use read concern [here](https://www.mongodb.com/docs/manual/reference/read-concern/).
- name: Query.prototype.regex()
  id: api/query#Query.prototype.regex()
  summary: Specifies a $regex query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.regex()

    ##### Parameters:

    - `[path]` «String»
    - `val` «String\|RegExp»

    ##### See:

    -  [$regex](https://www.mongodb.com/docs/manual/reference/operator/regex/)

    Specifies a `$regex` query condition.

    When called with one argument, the most recent path passed to `where()` is used.
- name: Query.prototype.replaceOne()
  id: api/query#Query.prototype.replaceOne()
  summary: Declare and/or execute this query as a replaceOne() operation
  belongs_to: Query
  description: |-
    ### Query.prototype.replaceOne()

    ##### Parameters:

    - `[filter]` «Object»
    - `[doc]`«Object» the update command
    - `[options]` «Object»

    &nbsp;

    - `[options.multipleCastError]`«Boolean» by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.upsert=false]`«Boolean» if true, and no documents found, insert a new document

    &nbsp;

    - `[options.writeConcern=null]`«Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    &nbsp;

    - `[callback]`«Function» params are (error, writeOpResult)

    ##### Returns:

    - «Query» this

    ##### See:

    -  [Model.update](model#Model.update())
    -  [Query docs](../queries)
    -  [update](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)
    -  [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)
    -  [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)

    Declare and/or execute this query as a replaceOne() operation. MongoDB will replace the existing document and will not accept any [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) (`$set`, etc.)

    **Note** replaceOne will *not* fire update middleware. Use `pre('replaceOne')` and `post('replaceOne')` instead.

    #### [Example:](#example)

    ``` javascript
    const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });
    res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.
    res.matchedCount; // Number of documents that matched the filter
    res.modifiedCount; // Number of documents that were modified
    res.upsertedCount; // Number of documents that were upserted
    res.upsertedId; // Identifier of the inserted document (if an upsert took place)
    ```

    This function triggers the following middleware.

    - `replaceOne()`
- name: Query.prototype.select()
  id: api/query#Query.prototype.select()
  summary: When using string syntax, prefixing a path with - will flag that path as excluded
  belongs_to: Query
  description: |-
    ### Query.prototype.select()

    ##### Parameters:

    - `arg` «Object\|String\|Array\[String\]»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [SchemaType](schematype)

    Specifies which document fields to include or exclude (also known as the query "projection")

    When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](schematype#SchemaType.prototype.select()).

    A projection *must* be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The [`_id` field is the only exception because MongoDB includes it by default](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/#suppress-id-field).

    #### [Example:](#example)

    ``` javascript
    // include a and b, exclude other fields
    query.select('a b');
    // Equivalent syntaxes:
    query.select(['a', 'b']);
    query.select({ a: 1, b: 1 });

    // exclude c and d, include other fields
    query.select('-c -d');

    // Use `+` to override schema-level `select: false` without making the
    // projection inclusive.
    const schema = new Schema({
      foo: { type: String, select: false },
      bar: String
    });
    // ...
    query.select('+foo'); // Override foo's `select: false` without excluding `bar`

    // or you may use object notation, useful when
    // you have keys already prefixed with a "-"
    query.select({ a: 1, b: 1 });
    query.select({ c: 0, d: 0 });

    Additional calls to select can override the previous selection:
    query.select({ a: 1, b: 1 }).select({ b: 0 }); // selection is now { a: 1 }
    query.select({ a: 0, b: 0 }).select({ b: 1 }); // selection is now { a: 0 }
    ```
- name: Query.prototype.selected()
  id: api/query#Query.prototype.selected()
  summary: Determines if field selection has been made
  belongs_to: Query
  description: |-
    ### Query.prototype.selected()

    ##### Returns:

    - «Boolean»

    Determines if field selection has been made.
- name: Query.prototype.selectedExclusively()
  id: api/query#Query.prototype.selectedExclusively()
  summary: Determines if exclusive field selection has been made
  belongs_to: Query
  description: |-
    ### Query.prototype.selectedExclusively()

    ##### Returns:

    - «Boolean»

    Determines if exclusive field selection has been made.

    ``` javascript
    query.selectedExclusively(); // false
    query.select('-name');
    query.selectedExclusively(); // true
    query.selectedInclusively(); // false
    ```
- name: Query.prototype.selectedInclusively()
  id: api/query#Query.prototype.selectedInclusively()
  summary: Determines if inclusive field selection has been made
  belongs_to: Query
  description: |-
    ### Query.prototype.selectedInclusively()

    ##### Returns:

    - «Boolean»

    Determines if inclusive field selection has been made.

    ``` javascript
    query.selectedInclusively(); // false
    query.select('name');
    query.selectedInclusively(); // true
    ```
- name: Query.prototype.session()
  id: api/query#Query.prototype.session()
  summary: Sets the MongoDB session associated with this query
  belongs_to: Query
  description: |-
    ### Query.prototype.session()

    ##### Parameters:

    - `[session]`«ClientSession» from `await conn.startSession()`

    ##### Returns:

    - «Query» this

    ##### See:

    -  [Connection.prototype.startSession()](connection#Connection.prototype.startSession())
    -  [mongoose.startSession()](mongoose#Mongoose.prototype.startSession())

    Sets the [MongoDB session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this query. Sessions are how you mark a query as part of a [transaction](../transactions).

    Calling `session(null)` removes the session from this query.

    #### [Example:](#example)

    ``` javascript
    const s = await mongoose.startSession();
    await mongoose.model('Person').findOne({ name: 'Axl Rose' }).session(s);
    ```
- name: Query.prototype.set()
  id: api/query#Query.prototype.set()
  summary: Adds a $set to this query's update without changing the operation
  belongs_to: Query
  description: |-
    ### Query.prototype.set()

    ##### Parameters:

    - `path`«String\|Object» path or object of key/value pairs to set
    - `[val]`«Any» the value to set

    ##### Returns:

    - «Query» this

    Adds a `$set` to this query's update without changing the operation. This is useful for query middleware so you can add an update regardless of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.

    #### [Example:](#example)

    ``` javascript
    // Updates `{ $set: { updatedAt: new Date() } }`newQuery().updateOne({}, {}).set('updatedAt', newDate());
    newQuery().updateMany({}, {}).set({ updatedAt: newDate() });
    ```
- name: Query.prototype.setOptions()
  id: api/query#Query.prototype.setOptions()
  summary: Sets query options
  belongs_to: Query
  description: |-
    ### Query.prototype.setOptions()

    ##### Parameters:

    - `options` «Object»

    ##### Returns:

    - «Query» this

    Sets query options. Some options only make sense for certain operations.

    #### [Options:](#options)

    The following options are only for `find()`:

    - [tailable](https://www.mongodb.com/docs/manual/core/tailable-cursors/)
    - [limit](https://www.mongodb.com/docs/manual/reference/method/cursor.limit/)
    - [skip](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/)
    - [allowDiskUse](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/)
    - [batchSize](https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/)
    - [readPreference](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)
    - [hint](https://www.mongodb.com/docs/manual/reference/method/cursor.hint/)
    - [comment](https://www.mongodb.com/docs/manual/reference/method/cursor.comment/)

    The following options are only for write operations: `updateOne()`, `updateMany()`, `replaceOne()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:

    - [upsert](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)
    - [writeConcern](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)
    - [timestamps](../guide#timestamps): If `timestamps` is set in the schema, set this option to `false` to skip timestamps for that particular update. Has no effect if `timestamps` is not enabled in the schema options.
    - overwriteDiscriminatorKey: allow setting the discriminator key in the update. Will use the correct discriminator schema if the update changes the discriminator key.

    The following options are only for `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, `findOneAndReplace()`, `findOneAndDelete()`, and `findByIdAndUpdate()`:

    - [lean](#Query.prototype.lean())
    - [populate](../populate)
    - [projection](#Query.prototype.projection())
    - sanitizeProjection
    - useBigInt64

    The following options are only for all operations **except** `updateOne()`, `updateMany()`, `deleteOne()`, and `deleteMany()`:

    - [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)

    The following options are for `find()`, `findOne()`, `findOneAndUpdate()`, `findOneAndRemove()`, `findOneAndDelete()`, `updateOne()`, and `deleteOne()`:

    - [sort](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/)

    The following options are for `findOneAndUpdate()` and `findOneAndRemove()`

    - rawResult

    The following options are for all operations:

    - [strict](../guide#strict)
    - [collation](https://www.mongodb.com/docs/manual/reference/collation/)
    - [session](https://www.mongodb.com/docs/manual/reference/server-sessions/)
    - [explain](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/)
- name: Query.prototype.setQuery()
  id: api/query#Query.prototype.setQuery()
  summary: Sets the query conditions to the provided JSON object
  belongs_to: Query
  description: |-
    ### Query.prototype.setQuery()

    ##### Parameters:

    - `new`«Object» query conditions

    ##### Returns:

    - «undefined,void»

    Sets the query conditions to the provided JSON object.

    #### [Example:](#example)

    ``` javascript
    const query = new Query();
    query.find({ a: 1 })
    query.setQuery({ a: 2 });
    query.getQuery(); // { a: 2 }
    ```
- name: Query.prototype.setUpdate()
  id: api/query#Query.prototype.setUpdate()
  summary: Sets the current update operation to new value
  belongs_to: Query
  description: |-
    ### Query.prototype.setUpdate()

    ##### Parameters:

    - `new`«Object» update operation

    ##### Returns:

    - «undefined,void»

    Sets the current update operation to new value.

    #### [Example:](#example)

    ``` javascript
    const query = new Query();
    query.updateOne({}, { $set: { a: 5 } });
    query.setUpdate({ $set: { b: 6 } });
    query.getUpdate(); // { $set: { b: 6 } }
    ```
- name: Query.prototype.size()
  id: api/query#Query.prototype.size()
  summary: Specifies a $size query condition
  belongs_to: Query
  description: |-
    ### Query.prototype.size()

    ##### Parameters:

    - `[path]` «String»
    - `val` «Number»

    ##### See:

    -  [$size](https://www.mongodb.com/docs/manual/reference/operator/size/)

    Specifies a `$size` query condition.

    When called with one argument, the most recent path passed to `where()` is used.

    #### [Example:](#example)

    ``` javascript
    const docs = await MyModel.where('tags').size(0).exec();
    assert(Array.isArray(docs));
    console.log('documents with 0 tags', docs);
    ```
- name: Query.prototype.skip()
  id: api/query#Query.prototype.skip()
  summary: Specifies the number of documents to skip
  belongs_to: Query
  description: |-
    ### Query.prototype.skip()

    ##### Parameters:

    - `val` «Number»

    ##### See:

    -  [cursor.skip](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/)

    Specifies the number of documents to skip.

    #### [Example:](#example)

    ``` javascript
    query.skip(100).limit(20);
    ```

    #### [Note:](#note)

    Cannot be used with `distinct()`
- name: Query.prototype.slice()
  id: api/query#Query.prototype.slice()
  summary: Specifies a $slice projection for an array
  belongs_to: Query
  description: |-
    ### Query.prototype.slice()

    ##### Parameters:

    - `[path]` «String»
    - `val`«Number\|Array» number of elements to slice or array with number of elements to skip and number of elements to slice

    ##### Returns:

    - «Query» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/tutorial/query-documents/#projection)
    -  [$slice](https://www.mongodb.com/docs/manual/reference/projection/slice/#prj._S_slice)

    Specifies a `$slice` projection for an array.

    #### [Example:](#example)

    ``` javascript
    query.slice('comments', 5); // Returns the first 5 comments
    query.slice('comments', -5); // Returns the last 5 comments
    query.slice('comments', [10, 5]); // Returns the first 5 comments after the 10-th
    query.where('comments').slice(5); // Returns the first 5 comments
    query.where('comments').slice([-10, 5]); // Returns the first 5 comments after the 10-th to last
    ```

    **Note:** If the absolute value of the number of elements to be sliced is greater than the number of elements in the array, all array elements will be returned.

    ``` javascript
    // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     query.slice('arr', 20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     query.slice('arr', -20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    ```

    **Note:** If the number of elements to skip is positive and greater than the number of elements in the array, an empty array will be returned.

    ``` javascript
    // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     query.slice('arr', [20, 5]); // Returns []
    ```

    **Note:** If the number of elements to skip is negative and its absolute value is greater than the number of elements in the array, the starting position is the start of the array.

    ``` javascript
    // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     query.slice('arr', [-20, 5]); // Returns [1, 2, 3, 4, 5]
    ```
- name: Query.prototype.sort()
  id: api/query#Query.prototype.sort()
  summary: If an object is passed, values allowed are asc, desc, ascending, descending, 1, and -1
  belongs_to: Query
  description: |-
    ### Query.prototype.sort()

    ##### Parameters:

    - `arg` «Object\|String\|Array\<Array\<string\|number\>\>»

    ##### Returns:

    - «Query» this

    ##### See:

    -  [cursor.sort](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/)

    Sets the sort order

    If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.

    If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.

    #### [Example:](#example)

    ``` javascript
    // sort by "field" ascending and "test" descending
    query.sort({ field: 'asc', test: -1 });

    // equivalent
    query.sort('field -test');

    // also possible is to use a array with array key-value pairs
    query.sort([['field', 'asc']]);
    ```

    #### [Note:](#note)

    Cannot be used with `distinct()`
- name: Query.prototype.tailable()
  id: api/query#Query.prototype.tailable()
  summary: Sets the tailable option (for use with capped collections)
  belongs_to: Query
  description: |-
    ### Query.prototype.tailable()

    ##### Parameters:

    - `bool`«Boolean» defaults to true
    - `[opts]`«Object» options to set

    &nbsp;

    - `[opts.awaitData]`«Boolean» false by default. Set to true to keep the cursor open even if there's no data.

    &nbsp;

    - `[opts.maxAwaitTimeMS]`«Number» the maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true

    ##### See:

    -  [tailable](https://www.mongodb.com/docs/manual/tutorial/create-tailable-cursor/)

    Sets the tailable option (for use with capped collections).

    #### [Example:](#example)

    ``` javascript
    query.tailable(); // true
    query.tailable(true);
    query.tailable(false);

    // Set both `tailable` and `awaitData` options
    query.tailable({ awaitData: true });
    ```

    #### [Note:](#note)

    Cannot be used with `distinct()`
- name: Query.prototype.then()
  id: api/query#Query.prototype.then()
  summary: Executes the query returning a Promise which will be resolved with either the doc(s) or rejected with the error
  belongs_to: Query
  description: |-
    ### Query.prototype.then()

    ##### Parameters:

    - `[resolve]` «Function»
    - `[reject]` «Function»

    ##### Returns:

    - «Promise»

    Executes the query returning a `Promise` which will be resolved with either the doc(s) or rejected with the error.

    More about [`then()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/then).
- name: Query.prototype.toConstructor()
  id: api/query#Query.prototype.toConstructor()
  summary: Converts this query to a customized, reusable query constructor with all arguments and options retained
  belongs_to: Query
  description: |-
    ### Query.prototype.toConstructor()

    ##### Returns:

    - «Query» subclass-of-Query

    Converts this query to a customized, reusable query constructor with all arguments and options retained.

    #### [Example:](#example)

    ``` javascript
    // Create a query for adventure movies and read from the primary// node in the replica-set unless it is down, in which case we'll// read from a secondary node.const query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');

    // create a custom Query constructor based off these settings
    const Adventure = query.toConstructor();

    // further narrow down our query results while still using the previous settings
    await Adventure().where({ name: /^Life/ }).exec();

    // since Adventure is a stand-alone constructor we can also add our own
    // helper methods and getters without impacting global queries
    Adventure.prototype.startsWith = function (prefix) {
      this.where({ name: new RegExp('^' + prefix) })
      return this;
    }
    Object.defineProperty(Adventure.prototype, 'highlyRated', {
      get: function () {
        this.where({ rating: { $gt: 4.5 }});
        return this;
      }
    })
    await Adventure().highlyRated.startsWith('Life').exec();
    ```
- name: Query.prototype.transform()
  id: api/query#Query.prototype.transform()
  summary: Runs a function fn and treats the return value of fn as the new value for the query to resolve to
  belongs_to: Query
  description: |-
    ### Query.prototype.transform()

    ##### Parameters:

    - `fn`«Function» function to run to transform the query result

    ##### Returns:

    - «Query» this

    Runs a function `fn` and treats the return value of `fn` as the new value for the query to resolve to.

    Any functions you pass to `transform()` will run **after** any post hooks.

    #### [Example:](#example)

    ``` javascript
    const res = await MyModel.findOne().transform(res => {
      // Sets a `loadedAt` property on the doc that tells you the time the
      // document was loaded.
      return res == null ?
        res :
        Object.assign(res, { loadedAt: new Date() });
    });
    ```
- name: Query.prototype.updateMany()
  id: api/query#Query.prototype.updateMany()
  summary: Declare and/or execute this query as an updateMany() operation
  belongs_to: Query
  description: |-
    ### Query.prototype.updateMany()

    ##### Parameters:

    - `[filter]` «Object»
    - `[update]`«Object\|Array» the update command
    - `[options]` «Object»

    &nbsp;

    - `[options.multipleCastError]`«Boolean» by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.upsert=false]`«Boolean» if true, and no documents found, insert a new document

    &nbsp;

    - `[options.writeConcern=null]`«Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    &nbsp;

    - `[callback]`«Function» params are (error, writeOpResult)

    ##### Returns:

    - «Query» this

    ##### See:

    -  [Model.update](model#Model.update())
    -  [Query docs](../queries)
    -  [update](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)
    -  [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)
    -  [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)

    Declare and/or execute this query as an updateMany() operation. MongoDB will update *all* documents that match `filter` (as opposed to just the first one).

    **Note** updateMany will *not* fire update middleware. Use `pre('updateMany')` and `post('updateMany')` instead.

    #### [Example:](#example)

    ``` javascript
    const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });
    res.n; // Number of documents matched
    res.nModified; // Number of documents modified
    ```

    This function triggers the following middleware.

    - `updateMany()`
- name: Query.prototype.updateOne()
  id: api/query#Query.prototype.updateOne()
  summary: Declare and/or execute this query as an updateOne() operation
  belongs_to: Query
  description: |-
    ### Query.prototype.updateOne()

    ##### Parameters:

    - `[filter]` «Object»
    - `[update]`«Object\|Array» the update command
    - `[options]` «Object»

    &nbsp;

    - `[options.multipleCastError]`«Boolean» by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.

    &nbsp;

    - `[options.strict]`«Boolean\|String» overwrites the schema's [strict mode option](../guide#strict)

    &nbsp;

    - `[options.upsert=false]`«Boolean» if true, and no documents found, insert a new document

    &nbsp;

    - `[options.writeConcern=null]`«Object» sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](../guide#writeConcern)

    &nbsp;

    - `[options.timestamps=null]`«Boolean» If set to `false` and [schema-level timestamps](../guide#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.

    &nbsp;

    - `[options.translateAliases=null]`«Boolean» If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.

    &nbsp;

    - `[callback]`«Function» params are (error, writeOpResult)

    ##### Returns:

    - «Query» this

    ##### See:

    -  [Model.update](model#Model.update())
    -  [Query docs](../queries)
    -  [update](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)
    -  [UpdateResult](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html)
    -  [MongoDB docs](https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output)

    Declare and/or execute this query as an updateOne() operation. MongoDB will update *only* the first document that matches `filter`.

    - Use `replaceOne()` if you want to overwrite an entire document rather than using [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) like `$set`.

    **Note** updateOne will *not* fire update middleware. Use `pre('updateOne')` and `post('updateOne')` instead.

    #### [Example:](#example)

    ``` javascript
    const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });
    res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.
    res.matchedCount; // Number of documents that matched the filter
    res.modifiedCount; // Number of documents that were modified
    res.upsertedCount; // Number of documents that were upserted
    res.upsertedId; // Identifier of the inserted document (if an upsert took place)
    ```

    This function triggers the following middleware.

    - `updateOne()`
- name: Query.prototype.w()
  id: api/query#Query.prototype.w()
  summary: Sets the specified number of mongod servers, or tag set of mongod servers, that must acknowledge this write before this write is considered successful
  belongs_to: Query
  description: |-
    ### Query.prototype.w()

    ##### Parameters:

    - `val`«String\|number» 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option).

    ##### Returns:

    - «Query» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option)

    Sets the specified number of `mongod` servers, or tag set of `mongod` servers, that must acknowledge this write before this write is considered successful. This option is only valid for operations that write to the database:

    - `deleteOne()`
    - `deleteMany()`
    - `findOneAndDelete()`
    - `findOneAndReplace()`
    - `findOneAndUpdate()`
    - `updateOne()`
    - `updateMany()`

    Defaults to the schema's [`writeConcern.w` option](../guide#writeConcern)

    #### [Example:](#example)

    ``` javascript
    // The 'majority' option means the `deleteOne()` promise won't resolve// until the `deleteOne()` has propagated to the majority of the replica setawait mongoose.model('Person').
      deleteOne({ name: 'Ned Stark' }).
      w('majority');
    ```
- name: Query.prototype.where()
  id: api/query#Query.prototype.where()
  summary: Specifies a path for use with chaining
  belongs_to: Query
  description: |-
    ### Query.prototype.where()

    ##### Parameters:

    - `[path]` «String\|Object»
    - `[val]` «any»

    ##### Returns:

    - «Query» this

    Specifies a `path` for use with chaining.

    #### [Example:](#example)

    ``` javascript
    // instead of writing:User.find({age: {$gte: 21, $lte: 65}});

    // we can instead write:User.where('age').gte(21).lte(65);

    // passing query conditions is permittedUser.find().where({ name: 'vonderful' })

    // chaining
    User
    .where('age').gte(21).lte(65)
    .where('name', /^vonderful/i)
    .where('friends').slice(10)
    .exec()
    ```
- name: Query.prototype.within()
  id: api/query#Query.prototype.within()
  summary: Defines a $within or $geoWithin argument for geo-spatial queries
  belongs_to: Query
  description: |-
    ### Query.prototype.within()

    ##### Returns:

    - «Query» this

    ##### See:

    -  [$polygon](https://www.mongodb.com/docs/manual/reference/operator/polygon/)
    -  [$box](https://www.mongodb.com/docs/manual/reference/operator/box/)
    -  [$geometry](https://www.mongodb.com/docs/manual/reference/operator/geometry/)
    -  [$center](https://www.mongodb.com/docs/manual/reference/operator/center/)
    -  [$centerSphere](https://www.mongodb.com/docs/manual/reference/operator/centerSphere/)

    Defines a `$within` or `$geoWithin` argument for geo-spatial queries.

    #### [Example:](#example)

    ``` javascript
    query.where(path).within().box()
    query.where(path).within().circle()
    query.where(path).within().geometry()

    query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });
    query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });
    query.where('loc').within({ polygon: [[],[],[],[]] });

    query.where('loc').within([], [], []) // polygon
    query.where('loc').within([], []) // box
    query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry
    ```

    **MUST** be used after `where()`.

    #### [Note:](#note)

    As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](#Query.prototype.use$geoWithin).

    #### [Note:](#note-1)

    In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).
- name: Query.prototype.writeConcern()
  id: api/query#Query.prototype.writeConcern()
  summary: null
  belongs_to: Query
  description: |-
    ### Query.prototype.writeConcern()

    ##### Parameters:

    - `writeConcern`«Object» the write concern value to set

    ##### Returns:

    - «Query» this

    ##### See:

    -  [WriteConcernSettings](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/WriteConcernSettings.html)

    Sets the 3 write concern parameters for this query:

    - `w`: Sets the specified number of `mongod` servers, or tag set of `mongod` servers, that must acknowledge this write before this write is considered successful.
    - `j`: Boolean, set to `true` to request acknowledgement that this operation has been persisted to MongoDB's on-disk journal.
    - `wtimeout`: If [`w > 1`](#Query.prototype.w()), the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is `0`, which means no timeout.

    This option is only valid for operations that write to the database:

    - `deleteOne()`
    - `deleteMany()`
    - `findOneAndDelete()`
    - `findOneAndReplace()`
    - `findOneAndUpdate()`
    - `updateOne()`
    - `updateMany()`

    Defaults to the schema's [`writeConcern` option](../guide#writeConcern)

    #### [Example:](#example)

    ``` javascript
    // The 'majority' option means the `deleteOne()` promise won't resolve// until the `deleteOne()` has propagated to the majority of the replica setawait mongoose.model('Person').
      deleteOne({ name: 'Ned Stark' }).
      writeConcern({ w: 'majority' });
    ```
- name: Query.prototype.wtimeout()
  id: api/query#Query.prototype.wtimeout()
  summary: If w > 1, the maximum amount of time to wait for this write to propagate through the replica set before this operation fails
  belongs_to: Query
  description: |-
    ### Query.prototype.wtimeout()

    ##### Parameters:

    - `ms`«number» number of milliseconds to wait

    ##### Returns:

    - «Query» this

    ##### See:

    -  [mongodb](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout)

    If [`w > 1`](#Query.prototype.w()), the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is `0`, which means no timeout.

    This option is only valid for operations that write to the database:

    - `deleteOne()`
    - `deleteMany()`
    - `findOneAndDelete()`
    - `findOneAndReplace()`
    - `findOneAndUpdate()`
    - `updateOne()`
    - `updateMany()`

    Defaults to the schema's [`writeConcern.wtimeout` option](../guide#writeConcern)

    #### [Example:](#example)

    ``` javascript
    // The `deleteOne()` promise won't resolve until this `deleteOne()` has// propagated to at least `w = 2` members of the replica set. If it takes// longer than 1 second, this `deleteOne()` will fail.await mongoose.model('Person').
      deleteOne({ name: 'Ned Stark' }).
      w(2).
      wtimeout(1000);
    ```
- name: Query.prototype[Symbol.asyncIterator]()
  id: api/query#Query.prototype[Symbol.asyncIterator]()
  summary: Returns an asyncIterator for use with for/await/of loops This function only works for find() queries
  belongs_to: Query
  description: |-
    ### Query.prototype\[Symbol.asyncIterator\]()

    Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js) This function *only* works for `find()` queries. You do not need to call this function explicitly, the JavaScript runtime will call it for you.

    #### [Example:](#example)

    ``` javascript
    forawait (const doc of Model.aggregate([{ $sort: { name: 1 } }])) {
      console.log(doc.name);
    }
    ```

    Node.js 10.x supports async iterators natively without any flags. You can enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).

    **Note:** This function is not if `Symbol.asyncIterator` is undefined. If `Symbol.asyncIterator` is undefined, that means your Node.js version does not support async iterators.
- name: Query.prototype[Symbol.toStringTag]()
  id: api/query#Query.prototype[Symbol.toStringTag]()
  summary: Returns a string representation of this query
  belongs_to: Query
  description: |-
    ### Query.prototype\[Symbol.toStringTag\]()

    ##### Returns:

    - «String»

    Returns a string representation of this query.

    More about [`toString()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/tostring).

    #### [Example:](#example)

    ``` javascript
    const q = Model.find();
    console.log(q); // Prints "Query { find }"
    ```
- name: Query.use$geoWithin
  id: api/query#Query.use$geoWithin
  summary: Flag to opt out of using $geoWithin
  belongs_to: Query
  description: "### Query.use$geoWithin\n\n##### Type:\n\n- «property»\n\n##### See:\n\n-  [geoWithin](https://www.mongodb.com/docs/manual/reference/operator/geoWithin/)\n\nFlag to opt out of using `$geoWithin`.\n\n``` javascript\nmongoose.Query.use$geoWithin = false;\n```\n\nMongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with `$within`). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/query.html](https://mongoosejs.com/docs/api/query.html)"
- name: QueryCursor
  id: api/querycursor
  summary: A QueryCursor is a concurrency primitive for processing query results one document at a time
  description: "# QueryCursor\n\n### QueryCursor()\n\n##### Parameters:\n\n- `query` «Query»\n- `options` «Object» query options passed to `.find()`\n\n##### Inherits:\n\n- [«Readable»](https://nodejs.org/api/stream.html#class-streamreadable)\n\nA QueryCursor is a concurrency primitive for processing query results one document at a time. A QueryCursor fulfills the Node.js streams3 API, in addition to several other mechanisms for loading documents from MongoDB one at a time.\n\nQueryCursors execute the model's pre `find` hooks before loading any documents from MongoDB, and the model's post `find` hooks after loading each document.\n\nUnless you're an advanced user, do **not** instantiate this class directly. Use [`Query#cursor()`](query#Query.prototype.cursor()) instead.\n\n### QueryCursor.prototype.addCursorFlag()\n\n##### Parameters:\n\n- `flag` «String»\n- `value` «Boolean»\n\n##### Returns:\n\n- «AggregationCursor» this\n\nAdds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag). Useful for setting the `noCursorTimeout` and `tailable` flags.\n\n### QueryCursor.prototype.close()\n\n##### Returns:\n\n- «Promise»\n\n##### See:\n\n- [AggregationCursor.close](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close)\n\nMarks this cursor as closed. Will stop streaming and subsequent calls to `next()` will error.\n\n### QueryCursor.prototype.eachAsync()\n\n##### Parameters:\n\n- `fn` «Function»\n- `[options]` «Object»\n\n- `[options.parallel]` «Number» the number of promises to execute in parallel. Defaults to 1.\n\n&nbsp;\n\n- `[options.batchSize]` «Number» if set, will call `fn()` with arrays of documents with length at most `batchSize`\n\n&nbsp;\n\n- `[options.continueOnError=false]` «Boolean» if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n\n&nbsp;\n\n- `[callback]` «Function» executed when all docs have been processed\n\n##### Returns:\n\n- «Promise»\n\nExecute `fn` for every document in the cursor. If `fn` returns a promise, will wait for the promise to resolve before iterating on to the next one. Returns a promise that resolves when done.\n\n#### [Example:](#example)\n\n``` javascript\n// Iterate over documents asynchronously\nThing.\n  find({ name: /^hello/ }).\n  cursor().\n  eachAsync(async function (doc, i) {\n    doc.foo = doc.bar + i;\n    await doc.save();\n  })\n```\n\n### QueryCursor.prototype.map()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «QueryCursor»\n\nRegisters a transform function which subsequently maps documents retrieved via the streams interface or `.next()`\n\n#### [Example:](#example)\n\n``` javascript\n// Map documents returned by `data` events\nThing.\n  find({ name: /^hello/ }).\n  cursor().\n  map(function (doc) {\n   doc.foo = \"bar\";\n   return doc;\n  })\n  on('data', function(doc) { console.log(doc.foo); });\n\n// Or map documents returned by `.next()`\nconst cursor = Thing.find({ name: /^hello/ }).\n  cursor().\n  map(function (doc) {\n    doc.foo = \"bar\";\n    return doc;\n  });\ncursor.next(function(error, doc) {\n  console.log(doc.foo);\n});\n```\n\n### QueryCursor.prototype.next()\n\n##### Returns:\n\n- «Promise»\n\nGet the next document from this cursor. Will return `null` when there are no documents left.\n\n### QueryCursor.prototype.options\n\n##### Type:\n\n- «property»\n\nThe `options` passed in to the `QueryCursor` constructor.\n\n### QueryCursor.prototype.rewind()\n\n##### Returns:\n\n- «AggregationCursor» this\n\nRewind this cursor to its uninitialized state. Any options that are present on the cursor will remain in effect. Iterating this cursor will cause new queries to be sent to the server, even if the resultant data has already been retrieved by this cursor.\n\n### QueryCursor.prototype\\[Symbol.asyncIterator\\]()\n\nReturns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js). You do not need to call this function explicitly, the JavaScript runtime will call it for you.\n\n#### [Example:](#example)\n\n``` javascript\n// Works without using `cursor()`\nfor await (const doc of Model.find([{ $sort: { name: 1 } }])) {\n  console.log(doc.name);\n}\n\n// Can also use `cursor()`\nfor await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n  console.log(doc.name);\n}\n```\n\nNode.js 10.x supports async iterators natively without any flags. You can enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n\n**Note:** This function is not if `Symbol.asyncIterator` is undefined. If `Symbol.asyncIterator` is undefined, that means your Node.js version does not support async iterators.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/querycursor.html](https://mongoosejs.com/docs/api/querycursor.html)"
- name: QueryCursor()
  id: api/querycursor#QueryCursor()
  summary: A QueryCursor is a concurrency primitive for processing query results one document at a time
  belongs_to: QueryCursor
  description: |-
    ### QueryCursor()

    ##### Parameters:

    - `query` «Query»
    - `options`«Object» query options passed to `.find()`

    ##### Inherits:

    -  [«Readable»](https://nodejs.org/api/stream.html#class-streamreadable)

    A QueryCursor is a concurrency primitive for processing query results one document at a time. A QueryCursor fulfills the Node.js streams3 API, in addition to several other mechanisms for loading documents from MongoDB one at a time.

    QueryCursors execute the model's pre `find` hooks before loading any documents from MongoDB, and the model's post `find` hooks after loading each document.

    Unless you're an advanced user, do **not** instantiate this class directly. Use [`Query#cursor()`](query#Query.prototype.cursor()) instead.
- name: QueryCursor.prototype.addCursorFlag()
  id: api/querycursor#QueryCursor.prototype.addCursorFlag()
  summary: Adds a cursor flag
  belongs_to: QueryCursor
  description: |-
    ### QueryCursor.prototype.addCursorFlag()

    ##### Parameters:

    - `flag` «String»
    - `value` «Boolean»

    ##### Returns:

    - «AggregationCursor» this

    Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag). Useful for setting the `noCursorTimeout` and `tailable` flags.
- name: QueryCursor.prototype.close()
  id: api/querycursor#QueryCursor.prototype.close()
  summary: Marks this cursor as closed
  belongs_to: QueryCursor
  description: |-
    ### QueryCursor.prototype.close()

    ##### Returns:

    - «Promise»

    ##### See:

    -  [AggregationCursor.close](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close)

    Marks this cursor as closed. Will stop streaming and subsequent calls to `next()` will error.
- name: QueryCursor.prototype.eachAsync()
  id: api/querycursor#QueryCursor.prototype.eachAsync()
  summary: '[options.parallel]«Number» the number of promises to execute in parallel'
  belongs_to: QueryCursor
  description: |-
    ### QueryCursor.prototype.eachAsync()

    ##### Parameters:

    - `fn` «Function»
    - `[options]` «Object»

    - `[options.parallel]`«Number» the number of promises to execute in parallel. Defaults to 1.

    &nbsp;

    - `[options.batchSize]`«Number» if set, will call `fn()` with arrays of documents with length at most `batchSize`

    &nbsp;

    - `[options.continueOnError=false]`«Boolean» if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.

    &nbsp;

    - `[callback]`«Function» executed when all docs have been processed

    ##### Returns:

    - «Promise»

    Execute `fn` for every document in the cursor. If `fn` returns a promise, will wait for the promise to resolve before iterating on to the next one. Returns a promise that resolves when done.

    #### [Example:](#example)

    ``` javascript
    // Iterate over documents asynchronouslyThing.
      find({ name: /^hello/ }).
      cursor().
      eachAsync(async function (doc, i) {
        doc.foo = doc.bar + i;
        await doc.save();
      })
    ```
- name: QueryCursor.prototype.map()
  id: api/querycursor#QueryCursor.prototype.map()
  summary: null
  belongs_to: QueryCursor
  description: |-
    ### QueryCursor.prototype.map()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «QueryCursor»

    Registers a transform function which subsequently maps documents retrieved via the streams interface or `.next()`

    #### [Example:](#example)

    ``` javascript
    // Map documents returned by `data` eventsThing.
      find({ name: /^hello/ }).
      cursor().
      map(function (doc) {
       doc.foo = "bar";
       return doc;
      })
      on('data', function(doc) { console.log(doc.foo); });

    // Or map documents returned by `.next()`
    const cursor = Thing.find({ name: /^hello/ }).
      cursor().
      map(function (doc) {
        doc.foo = "bar";
        return doc;
      });
    cursor.next(function(error, doc) {
      console.log(doc.foo);
    });
    ```
- name: QueryCursor.prototype.next()
  id: api/querycursor#QueryCursor.prototype.next()
  summary: Get the next document from this cursor
  belongs_to: QueryCursor
  description: |-
    ### QueryCursor.prototype.next()

    ##### Returns:

    - «Promise»

    Get the next document from this cursor. Will return `null` when there are no documents left.
- name: QueryCursor.prototype.options
  id: api/querycursor#QueryCursor.prototype.options
  summary: The options passed in to the QueryCursor constructor
  belongs_to: QueryCursor
  description: |-
    ### QueryCursor.prototype.options

    ##### Type:

    - «property»

    The `options` passed in to the `QueryCursor` constructor.
- name: QueryCursor.prototype.rewind()
  id: api/querycursor#QueryCursor.prototype.rewind()
  summary: Rewind this cursor to its uninitialized state
  belongs_to: QueryCursor
  description: |-
    ### QueryCursor.prototype.rewind()

    ##### Returns:

    - «AggregationCursor» this

    Rewind this cursor to its uninitialized state. Any options that are present on the cursor will remain in effect. Iterating this cursor will cause new queries to be sent to the server, even if the resultant data has already been retrieved by this cursor.
- name: QueryCursor.prototype[Symbol.asyncIterator]()
  id: api/querycursor#QueryCursor.prototype[Symbol.asyncIterator]()
  summary: Returns an asyncIterator for use with for/await/of loops
  belongs_to: QueryCursor
  description: "### QueryCursor.prototype\\[Symbol.asyncIterator\\]()\n\nReturns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js). You do not need to call this function explicitly, the JavaScript runtime will call it for you.\n\n#### [Example:](#example)\n\n``` javascript\n// Works without using `cursor()`forawait (const doc of Model.find([{ $sort: { name: 1 } }])) {\n  console.log(doc.name);\n}\n\n// Can also use `cursor()`\nfor await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n  console.log(doc.name);\n}\n```\n\nNode.js 10.x supports async iterators natively without any flags. You can enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n\n**Note:** This function is not if `Symbol.asyncIterator` is undefined. If `Symbol.asyncIterator` is undefined, that means your Node.js version does not support async iterators.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/querycursor.html](https://mongoosejs.com/docs/api/querycursor.html)"
- name: Schema
  id: api/schema
  summary: Schema constructor
  description: "# Schema\n\n### Schema()\n\n##### Parameters:\n\n- `[definition]` «Object\\|Schema\\|Array» Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n- `[options]` «Object»\n\n##### Inherits:\n\n- [«NodeJS EventEmitter»](https://nodejs.org/api/events.html#class-eventemitter)\n\nSchema constructor.\n\n#### [Example:](#example)\n\n``` javascript\nconst child = new Schema({ name: String });\nconst schema = new Schema({ name: String, age: Number, children: [child] });\nconst Tree = mongoose.model('Tree', schema);\n\n// setting schema options\nnew Schema({ name: String }, { _id: false, autoIndex: false })\n```\n\n#### [Options:](#options)\n\n- [autoIndex](../guide#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n- [autoCreate](../guide#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n- [bufferCommands](../guide#bufferCommands): bool - defaults to true\n- [bufferTimeoutMS](../guide#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n- [capped](../guide#capped): bool \\| number \\| object - defaults to false\n- [collection](../guide#collection): string - no default\n- [discriminatorKey](../guide#discriminatorKey): string - defaults to `__t`\n- [id](../guide#id): bool - defaults to true\n- [\\_id](../guide#_id): bool - defaults to true\n- [minimize](../guide#minimize): bool - controls [document#toObject](document#Document.prototype.toObject()) behavior when called manually - defaults to true\n- [read](../guide#read): string\n- [writeConcern](../guide#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://www.mongodb.com/docs/manual/reference/write-concern/)\n- [shardKey](../guide#shardKey): object - defaults to `null`\n- [strict](../guide#strict): bool - defaults to true\n- [strictQuery](../guide#strictQuery): bool - defaults to false\n- [toJSON](../guide#toJSON) - object - no default\n- [toObject](../guide#toObject) - object - no default\n- [typeKey](../guide#typeKey) - string - defaults to 'type'\n- [validateBeforeSave](../guide#validateBeforeSave) - bool - defaults to `true`\n- [validateModifiedOnly](document#Document.prototype.validate()) - bool - defaults to `false`\n- [versionKey](../guide#versionKey): string or object - defaults to \"\\_\\_v\"\n- [optimisticConcurrency](../guide#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\n- [collation](../guide#collation): object - defaults to null (which means use no collation)\n- [timeseries](../guide#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n- [selectPopulatedPaths](../guide#selectPopulatedPaths): boolean - defaults to `true`\n- [skipVersioning](../guide#skipVersioning): object - paths to exclude from versioning\n- [timestamps](../guide#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n- [pluginTags](../guide#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n- [virtuals](../tutorials/virtuals#virtuals-via-schema-options): object - virtuals to define, alias for [`.virtual`](#Schema.prototype.virtual())\n- \\[collectionOptions\\]: object with options passed to [`createCollection()`](https://www.mongodb.com/docs/manual/reference/method/db.createCollection/) when calling `Model.createCollection()` or `autoCreate` set to true.\n\n#### [Options for Nested Schemas:](#options-for-nested-schemas)\n\n- `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n\n#### [Note:](#note)\n\n*When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent.*\n\n### Schema.Types\n\n##### Type:\n\n- «property»\n\nThe various built-in Mongoose Schema Types.\n\n#### [Example:](#example)\n\n``` javascript\nconst mongoose = require('mongoose');\nconst ObjectId = mongoose.Schema.Types.ObjectId;\n```\n\n#### [Types:](#types)\n\n- [String](../schematypes#strings)\n- [Number](../schematypes#numbers)\n- [Boolean](../schematypes#booleans) \\| Bool\n- [Array](../schematypes#arrays)\n- [Buffer](../schematypes#buffers)\n- [Date](../schematypes#dates)\n- [ObjectId](../schematypes#objectids) \\| Oid\n- [Mixed](../schematypes#mixed)\n- [UUID](../schematypes#uuid)\n- [BigInt](../schematypes#bigint)\n\nUsing this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n\n``` javascript\nconst Mixed = mongoose.Schema.Types.Mixed;\nnew mongoose.Schema({ _user: Mixed })\n```\n\n### Schema.indexTypes\n\n##### Type:\n\n- «property»\n\nThe allowed index types\n\n### Schema.prototype.add()\n\n##### Parameters:\n\n- `obj` «Object\\|Schema» plain object with paths to add, or another schema\n- `[prefix]` «String» path to prefix the newly added paths with\n\n##### Returns:\n\n- «Schema» the Schema instance\n\nAdds key path / schema type pairs to this schema.\n\n#### [Example:](#example)\n\n``` javascript\nconst ToySchema = new Schema();\nToySchema.add({ name: 'string', color: 'string', price: 'number' });\n\nconst TurboManSchema = new Schema();\n// You can also `add()` another schema and copy over all paths, virtuals,\n// getters, setters, indexes, methods, and statics.\nTurboManSchema.add(ToySchema).add({ year: Number });\n```\n\n### Schema.prototype.alias()\n\n##### Parameters:\n\n- `path` «String» real path to alias\n- `alias` «String\\|Array\\[String\\]» the path(s) to use as an alias for `path`\n\n##### Returns:\n\n- «Schema» the Schema instance\n\nAdd an alias for `path`. This means getting or setting the `alias` is equivalent to getting or setting the `path`.\n\n#### [Example:](#example)\n\n``` javascript\nconst toySchema = new Schema({ n: String });\n\n// Make 'name' an alias for 'n'\ntoySchema.alias('n', 'name');\n\nconst Toy = mongoose.model('Toy', toySchema);\nconst turboMan = new Toy({ n: 'Turbo Man' });\n\nturboMan.name; // 'Turbo Man'\nturboMan.n; // 'Turbo Man'\n\nturboMan.name = 'Turbo Man Action Figure';\nturboMan.n; // 'Turbo Man Action Figure'\n\nawait turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }\n```\n\n### Schema.prototype.childSchemas\n\n##### Type:\n\n- «property»\n\nArray of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties: `schema` and `model`.\n\nThis property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.\n\n### Schema.prototype.clearIndexes()\n\n##### Returns:\n\n- «Schema» the Schema instance\n\nRemove all indexes from this schema.\n\nclearIndexes only removes indexes from your schema object. Does **not** affect the indexes in MongoDB.\n\n#### [Example:](#example)\n\n``` javascript\nconst ToySchema = new Schema({ name: String, color: String, price: Number });\nToySchema.index({ name: 1 });\nToySchema.index({ color: 1 });\n\n// Remove all indexes on this schema\nToySchema.clearIndexes();\n\nToySchema.indexes(); // []\n```\n\n### Schema.prototype.clone()\n\n##### Returns:\n\n- «Schema» the cloned schema\n\nReturns a deep copy of the schema\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: String });\nconst clone = schema.clone();\nclone === schema; // false\nclone.path('name'); // SchemaString { ... }\n```\n\n### Schema.prototype.discriminator()\n\n##### Parameters:\n\n- `name` «String» the name of the discriminator\n- `schema` «Schema» the discriminated Schema\n\n##### Returns:\n\n- «Schema» the Schema instance\n\nInherit a Schema by applying a discriminator on an existing Schema.\n\n#### [Example:](#example)\n\n``` javascript\nconst eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });\n\nconst clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });\nconst ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);\n\nconst Event = mongoose.model('Event', eventSchema);\n\nEvent.discriminators['clicked']; // Model { clicked }\n\nconst doc = await Event.create({ kind: 'clicked', element: '#hero' });\ndoc.element; // '#hero'\ndoc instanceof ClickedModel; // true\n```\n\n### Schema.prototype.eachPath()\n\n##### Parameters:\n\n- `fn` «Function» callback function\n\n##### Returns:\n\n- «Schema» this\n\nIterates the schemas paths similar to Array#forEach.\n\nThe callback is passed the pathname and the schemaType instance.\n\n#### [Example:](#example)\n\n``` javascript\nconst userSchema = new Schema({ name: String, registeredAt: Date });\nuserSchema.eachPath((pathname, schematype) => {\n  // Prints twice:\n  // name SchemaString { ... }\n  // registeredAt SchemaDate { ... }\n  console.log(pathname, schematype);\n});\n```\n\n### Schema.prototype.get()\n\n##### Parameters:\n\n- `key` «String» The name of the Option to get the current value for\n\n##### Returns:\n\n- «Any» the option's value\n\nGets a schema option.\n\n#### [Example:](#example)\n\n``` javascript\nschema.get('strict'); // true\nschema.set('strict', false);\nschema.get('strict'); // false\n```\n\n### Schema.prototype.index()\n\n##### Parameters:\n\n- `fields` «Object» The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\n- `[options]` «Object» Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)\n\n- `[options.expires=null]` «String\\|number» Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n\n&nbsp;\n\n- `[options.language_override=null]` «String» Tells mongodb to use the specified field instead of `language` for parsing text indexes.\n\nDefines an index (most likely compound) for this schema.\n\n#### [Example:](#example)\n\n``` javascript\nschema.index({ first: 1, last: -1 })\n```\n\n### Schema.prototype.indexes()\n\n##### Returns:\n\n- «Array» list of indexes defined in the schema\n\nReturns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options. Indexes are expressed as an array `[spec, options]`.\n\n#### [Example:](#example)\n\n``` javascript\nconst userSchema = new Schema({\n  email: { type: String, required: true, unique: true },\n  registeredAt: { type: Date, index: true }\n});\n\n// [ [ { email: 1 }, { unique: true, background: true } ],\n//   [ { registeredAt: 1 }, { background: true } ] ]\nuserSchema.indexes();\n```\n\n[Plugins](../plugins) can use the return value of this function to modify a schema's indexes. For example, the below plugin makes every index unique by default.\n\n``` javascript\nfunction myPlugin(schema) {\n  for (const index of schema.indexes()) {\n    if (index[1].unique === undefined) {\n      index[1].unique = true;\n    }\n  }\n}\n```\n\n### Schema.prototype.loadClass()\n\n##### Parameters:\n\n- `model` «Function» The Class to load\n- `[virtualsOnly]` «Boolean» if truthy, only pulls virtuals from the class, not methods or statics\n\nLoads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static), and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions) to schema [virtuals](../guide#virtuals), [statics](../guide#statics), and [methods](../guide#methods).\n\n#### [Example:](#example)\n\n``` javascript\nconst md5 = require('md5');\nconst userSchema = new Schema({ email: String });\nclass UserClass {\n  // `gravatarImage` becomes a virtual\n  get gravatarImage() {\n    const hash = md5(this.email.toLowerCase());\n    return `https://www.gravatar.com/avatar/${hash}`;\n  }\n\n  // `getProfileUrl()` becomes a document method\n  getProfileUrl() {\n    return `https://mysite.com/${this.email}`;\n  }\n\n  // `findByEmail()` becomes a static\n  static findByEmail(email) {\n    return this.findOne({ email });\n  }\n}\n\n// `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n// and a `findByEmail()` static\nuserSchema.loadClass(UserClass);\n```\n\n### Schema.prototype.method()\n\n##### Parameters:\n\n- `name` «String\\|Object» The Method Name for a single function, or a Object of \"string-function\" pairs.\n- `[fn]` «Function» The Function in a single-function definition.\n\nAdds an instance method to documents constructed from Models compiled from this schema.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = kittySchema = new Schema(..);\n\nschema.method('meow', function () {\n  console.log('meeeeeoooooooooooow');\n})\n\nconst Kitty = mongoose.model('Kitty', schema);\n\nconst fizz = new Kitty;\nfizz.meow(); // meeeeeooooooooooooow\n```\n\nIf a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n\n``` javascript\nschema.method({\n    purr: function () {}\n  , scratch: function () {}\n});\n\n// later\nconst fizz = new Kitty;\nfizz.purr();\nfizz.scratch();\n```\n\nNOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](../guide#methods)\n\n### Schema.prototype.obj\n\n##### Type:\n\n- «property»\n\nThe original object passed to the schema constructor\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ a: String }).add({ b: String });\nschema.obj; // { a: String }\n```\n\n### Schema.prototype.omit()\n\n##### Parameters:\n\n- `paths` «Array\\[String\\]» List of Paths to omit for the new Schema\n- `[options]` «Object» Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n\n##### Returns:\n\n- «Schema»\n\nReturns a new schema that has the `paths` from the original schema, minus the omitted ones.\n\nThis method is analagous to [Lodash's `omit()` function](https://lodash.com/docs/#omit) for Mongoose schemas.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = Schema({ name: String, age: Number });\n// Creates a new schema omitting the `age` path\nconst newSchema = schema.omit(['age']);\n\nnewSchema.path('name'); // SchemaString { ... }\nnewSchema.path('age'); // undefined\n```\n\n### Schema.prototype.path()\n\n##### Parameters:\n\n- `path` «String» The name of the Path to get / set\n- `[obj]` «Object» The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n\nGets/sets schema paths.\n\nSets a path (if arity 2) Gets a path (if arity 1)\n\n#### [Example:](#example)\n\n``` javascript\nschema.path('name') // returns a SchemaType\nschema.path('name', Number) // changes the schemaType of `name` to Number\n```\n\n### Schema.prototype.pathType()\n\n##### Parameters:\n\n- `path` «String»\n\n##### Returns:\n\n- «String»\n\nReturns the pathType of `path` for this schema.\n\nGiven a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ name: String, nested: { foo: String } });\ns.virtual('foo').get(() => 42);\ns.pathType('name'); // \"real\"\ns.pathType('nested'); // \"nested\"\ns.pathType('foo'); // \"virtual\"\ns.pathType('fail'); // \"adhocOrUndefined\"\n```\n\n### Schema.prototype.paths\n\n##### Type:\n\n- «property»\n\nThe paths defined on this schema. The keys are the top-level paths in this schema, and the values are instances of the SchemaType class.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: String }, { _id: false });\nschema.paths; // { name: SchemaString { ... } }\n\nschema.add({ age: Number });\nschema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n```\n\n### Schema.prototype.pick()\n\n##### Parameters:\n\n- `paths` «Array\\[String\\]» List of Paths to pick for the new Schema\n- `[options]` «Object» Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n\n##### Returns:\n\n- «Schema»\n\nReturns a new schema that has the picked `paths` from this schema.\n\nThis method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = Schema({ name: String, age: Number });\n// Creates a new schema with the same `name` path as `schema`,\n// but no `age` path.\nconst newSchema = schema.pick(['name']);\n\nnewSchema.path('name'); // SchemaString { ... }\nnewSchema.path('age'); // undefined\n```\n\n### Schema.prototype.plugin()\n\n##### Parameters:\n\n- `plugin` «Function» The Plugin's callback\n- `[opts]` «Object» Options to pass to the plugin\n\n&nbsp;\n\n- `[opts.deduplicate=false]` «Boolean» If true, ignore duplicate plugins (same `fn` argument using `===`)\n\n##### See:\n\n- [plugins](../plugins)\n\nRegisters a plugin for this schema.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ name: String });\ns.plugin(schema => console.log(schema.path('name').path));\nmongoose.model('Test', s); // Prints 'name'\n```\n\nOr with Options:\n\n``` javascript\nconst s = new Schema({ name: String });\ns.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\nmongoose.model('Test', s); // Prints 'Schema Path Name: name'\n```\n\n### Schema.prototype.post()\n\n##### Parameters:\n\n- `methodName` «String\\|RegExp\\|Array\\[String\\]» The method name or regular expression to match method name\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.document]` «Boolean» If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n\n&nbsp;\n\n- `[options.query]` «Boolean» If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n\n&nbsp;\n\n- `fn` «Function» callback\n\n##### See:\n\n- [middleware](../middleware)\n- [kareem](https://npmjs.org/package/kareem)\n\nDefines a post hook for the document\n\n``` javascript\nconst schema = new Schema(..);\nschema.post('save', function (doc) {\n  console.log('this fired after a document was saved');\n});\n\nschema.post('find', function(docs) {\n  console.log('this fired after you ran a find query');\n});\n\nschema.post(/Many$/, function(res) {\n  console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n});\n\nconst Model = mongoose.model('Model', schema);\n\nconst m = new Model(..);\nm.save(function(err) {\n  console.log('this fires after the `post` hook');\n});\n\nm.find(function(err, docs) {\n  console.log('this fires after the post find hook');\n});\n```\n\n### Schema.prototype.pre()\n\n##### Parameters:\n\n- `methodName` «String\\|RegExp\\|Array\\[String\\]» The method name or regular expression to match method name\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.document]` «Boolean» If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n\n&nbsp;\n\n- `[options.query]` «Boolean» If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n\n&nbsp;\n\n- `callback` «Function»\n\nDefines a pre hook for the model.\n\n#### [Example:](#example)\n\n``` javascript\nconst toySchema = new Schema({ name: String, created: Date });\n\ntoySchema.pre('save', function(next) {\n  if (!this.created) this.created = new Date;\n  next();\n});\n\ntoySchema.pre('validate', function(next) {\n  if (this.name !== 'Woody') this.name = 'Woody';\n  next();\n});\n\n// Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\ntoySchema.pre(/^find/, function(next) {\n  console.log(this.getFilter());\n});\n\n// Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\ntoySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n  console.log(this.getFilter());\n});\n\ntoySchema.pre('deleteOne', function() {\n  // Runs when you call `Toy.deleteOne()`\n});\n\ntoySchema.pre('deleteOne', { document: true }, function() {\n  // Runs when you call `doc.deleteOne()`\n});\n```\n\n### Schema.prototype.queue()\n\n##### Parameters:\n\n- `name` «String» name of the document method to call later\n- `args` «Array» arguments to pass to the method\n\nAdds a method call to the queue.\n\n#### [Example:](#example)\n\n``` javascript\nschema.methods.print = function() { console.log(this); };\nschema.queue('print', []); // Print the doc every one is instantiated\n\nconst Model = mongoose.model('Test', schema);\nnew Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n```\n\n### Schema.prototype.remove()\n\n##### Parameters:\n\n- `path` «String\\|Array» The Path(s) to remove\n\n##### Returns:\n\n- «Schema» the Schema instance\n\nRemoves the given `path` (or \\[`paths`\\]).\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: String, age: Number });\nschema.remove('name');\nschema.path('name'); // Undefined\nschema.path('age'); // SchemaNumber { ... }\n```\n\nOr as a Array:\n\n``` javascript\nschema.remove(['name', 'age']);\nschema.path('name'); // Undefined\nschema.path('age'); // Undefined\n```\n\n### Schema.prototype.removeIndex()\n\n##### Parameters:\n\n- `index` «Object\\|string» name or index specification\n\n##### Returns:\n\n- «Schema» the Schema instance\n\nRemove an index by name or index specification.\n\nremoveIndex only removes indexes from your schema object. Does **not** affect the indexes in MongoDB.\n\n#### [Example:](#example)\n\n``` javascript\nconst ToySchema = new Schema({ name: String, color: String, price: Number });\n\n// Add a new index on { name, color }\nToySchema.index({ name: 1, color: 1 });\n\n// Remove index on { name, color }\n// Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\nToySchema.removeIndex({ name: 1, color: 1 });\n\n// Add an index with a custom name\nToySchema.index({ color: 1 }, { name: 'my custom index name' });\n// Remove index by name\nToySchema.removeIndex('my custom index name');\n```\n\n### Schema.prototype.removeVirtual()\n\n##### Parameters:\n\n- `path` «String\\|Array» The virutal path(s) to remove.\n\nRemoves the given virtual or virtuals from the schema.\n\n### Schema.prototype.requiredPaths()\n\n##### Parameters:\n\n- `invalidate` «Boolean» Refresh the cache\n\n##### Returns:\n\n- «Array»\n\nReturns an Array of path strings that are required by this schema.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({\n  name: { type: String, required: true },\n  age: { type: String, required: true },\n  notes: String\n});\ns.requiredPaths(); // [ 'age', 'name' ]\n```\n\n### Schema.prototype.set()\n\n##### Parameters:\n\n- `key` «String» The name of the option to set the value to\n- `[value]` «Object» The value to set the option to, if not passed, the option will be reset to default\n- `[tags]` «Array\\<string\\>» tags to add to read preference if key === 'read'\n\n##### See:\n\n- [Schema](#Schema())\n\nSets a schema option.\n\n#### [Example:](#example)\n\n``` javascript\nschema.set('strict'); // 'true' by default\nschema.set('strict', false); // Sets 'strict' to false\nschema.set('strict'); // 'false'\n```\n\n### Schema.prototype.static()\n\n##### Parameters:\n\n- `name` «String\\|Object» The Method Name for a single function, or a Object of \"string-function\" pairs.\n- `[fn]` «Function» The Function in a single-function definition.\n\n##### See:\n\n- [Statics](../guide#statics)\n\nAdds static \"class\" methods to Models compiled from this schema.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema(..);\n// Equivalent to `schema.statics.findByName = function(name) {}`;\nschema.static('findByName', function(name) {\n  return this.find({ name: name });\n});\n\nconst Drink = mongoose.model('Drink', schema);\nawait Drink.findByName('LaCroix');\n```\n\nIf a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n\n``` javascript\nschema.static({\n    findByName: function () {..}\n  , findByCost: function () {..}\n});\n\nconst Drink = mongoose.model('Drink', schema);\nawait Drink.findByName('LaCroix');\nawait Drink.findByCost(3);\n```\n\nIf a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n\n### Schema.prototype.virtual()\n\n##### Parameters:\n\n- `name` «String» The name of the Virtual\n- `[options]` «Object»\n\n&nbsp;\n\n- `[options.ref]` «String\\|Model» model name or model instance. Marks this as a [populate virtual](../populate#populate-virtuals).\n\n&nbsp;\n\n- `[options.localField]` «String\\|Function» Required for populate virtuals. See [populate virtual docs](../populate#populate-virtuals) for more information.\n\n&nbsp;\n\n- `[options.foreignField]` «String\\|Function» Required for populate virtuals. See [populate virtual docs](../populate#populate-virtuals) for more information.\n\n&nbsp;\n\n- `[options.justOne=false]` «Boolean\\|Function» Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n\n&nbsp;\n\n- `[options.count=false]` «Boolean» Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n\n&nbsp;\n\n- `[options.get=null]` «Function\\|null» Adds a [getter](../tutorials/getters-setters) to this virtual to transform the populated doc.\n\n&nbsp;\n\n- `[options.match=null]` «Object\\|Function» Apply a default [`match` option to populate](../populate#match), adding an additional filter to the populate query.\n\n##### Returns:\n\n- «VirtualType»\n\nCreates a virtual type with the given name.\n\n### Schema.prototype.virtualpath()\n\n##### Parameters:\n\n- `name` «String» The name of the Virtual to get\n\n##### Returns:\n\n- «VirtualType,null»\n\nReturns the virtual type with the given `name`.\n\n### Schema.prototype.virtuals\n\n##### Type:\n\n- «property»\n\nObject containing all virtuals defined on this schema. The objects' keys are the virtual paths and values are instances of `VirtualType`.\n\nThis property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({});\nschema.virtual('answer').get(() => 42);\n\nconsole.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\nconsole.log(schema.virtuals['answer'].getters[0].call()); // 42\n```\n\n### Schema.reserved\n\n##### Type:\n\n- «property»\n\nReserved document keys.\n\nKeys in this object are names that are warned in schema declarations because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema using `new Schema()` with one of these property names, Mongoose will log a warning.\n\n- \\_posts\n- \\_pres\n- collection\n- emit\n- errors\n- get\n- init\n- isModified\n- isNew\n- listeners\n- modelName\n- on\n- once\n- populated\n- prototype\n- remove\n- removeListener\n- save\n- schema\n- toObject\n- validate\n\n*NOTE:* Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n\n``` javascript\n const schema = new Schema(..);\n schema.methods.init = function () {} // potentially breaking\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schema.html](https://mongoosejs.com/docs/api/schema.html)"
- name: Schema()
  id: api/schema#Schema()
  summary: Schema constructor
  belongs_to: Schema
  description: |-
    ### Schema()

    ##### Parameters:

    - `[definition]`«Object\|Schema\|Array» Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas
    - `[options]` «Object»

    ##### Inherits:

    -  [«NodeJS EventEmitter»](https://nodejs.org/api/events.html#class-eventemitter)

    Schema constructor.

    #### [Example:](#example)

    ``` javascript
    const child = new Schema({ name: String });
    const schema = new Schema({ name: String, age: Number, children: [child] });
    const Tree = mongoose.model('Tree', schema);

    // setting schema options
    new Schema({ name: String }, { _id: false, autoIndex: false })
    ```

    #### [Options:](#options)

    - [autoIndex](../guide#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)
    - [autoCreate](../guide#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)
    - [bufferCommands](../guide#bufferCommands): bool - defaults to true
    - [bufferTimeoutMS](../guide#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.
    - [capped](../guide#capped): bool \| number \| object - defaults to false
    - [collection](../guide#collection): string - no default
    - [discriminatorKey](../guide#discriminatorKey): string - defaults to `__t`
    - [id](../guide#id): bool - defaults to true
    - [\_id](../guide#_id): bool - defaults to true
    - [minimize](../guide#minimize): bool - controls [document#toObject](document#Document.prototype.toObject()) behavior when called manually - defaults to true
    - [read](../guide#read): string
    - [writeConcern](../guide#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://www.mongodb.com/docs/manual/reference/write-concern/)
    - [shardKey](../guide#shardKey): object - defaults to `null`
    - [strict](../guide#strict): bool - defaults to true
    - [strictQuery](../guide#strictQuery): bool - defaults to false
    - [toJSON](../guide#toJSON) - object - no default
    - [toObject](../guide#toObject) - object - no default
    - [typeKey](../guide#typeKey) - string - defaults to 'type'
    - [validateBeforeSave](../guide#validateBeforeSave) - bool - defaults to `true`
    - [validateModifiedOnly](document#Document.prototype.validate()) - bool - defaults to `false`
    - [versionKey](../guide#versionKey): string or object - defaults to "\_\_v"
    - [optimisticConcurrency](../guide#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).
    - [collation](../guide#collation): object - defaults to null (which means use no collation)
    - [timeseries](../guide#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)
    - [selectPopulatedPaths](../guide#selectPopulatedPaths): boolean - defaults to `true`
    - [skipVersioning](../guide#skipVersioning): object - paths to exclude from versioning
    - [timestamps](../guide#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.
    - [pluginTags](../guide#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.
    - [virtuals](../tutorials/virtuals#virtuals-via-schema-options): object - virtuals to define, alias for [`.virtual`](#Schema.prototype.virtual())
    - \[collectionOptions\]: object with options passed to [`createCollection()`](https://www.mongodb.com/docs/manual/reference/method/db.createCollection/) when calling `Model.createCollection()` or `autoCreate` set to true.

    #### [Options for Nested Schemas:](#options-for-nested-schemas)

    - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.

    #### [Note:](#note)

    *When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent.*
- name: Schema.indexTypes
  id: api/schema#Schema.indexTypes
  summary: null
  belongs_to: Schema
  description: |-
    ### Schema.indexTypes

    ##### Type:

    - «property»

    The allowed index types
- name: Schema.prototype.add()
  id: api/schema#Schema.prototype.add()
  summary: Adds key path / schema type pairs to this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.add()

    ##### Parameters:

    - `obj`«Object\|Schema» plain object with paths to add, or another schema
    - `[prefix]`«String» path to prefix the newly added paths with

    ##### Returns:

    - «Schema» the Schema instance

    Adds key path / schema type pairs to this schema.

    #### [Example:](#example)

    ``` javascript
    constToySchema = new Schema();
    ToySchema.add({ name: 'string', color: 'string', price: 'number' });

    const TurboManSchema = new Schema();
    // You can also `add()` another schema and copy over all paths, virtuals,
    // getters, setters, indexes, methods, and statics.
    TurboManSchema.add(ToySchema).add({ year: Number });
    ```
- name: Schema.prototype.alias()
  id: api/schema#Schema.prototype.alias()
  summary: Add an alias for path
  belongs_to: Schema
  description: |-
    ### Schema.prototype.alias()

    ##### Parameters:

    - `path`«String» real path to alias
    - `alias`«String\|Array\[String\]» the path(s) to use as an alias for `path`

    ##### Returns:

    - «Schema» the Schema instance

    Add an alias for `path`. This means getting or setting the `alias` is equivalent to getting or setting the `path`.

    #### [Example:](#example)

    ``` javascript
    const toySchema = new Schema({ n: String });

    // Make 'name' an alias for 'n'
    toySchema.alias('n', 'name');

    const Toy = mongoose.model('Toy', toySchema);
    const turboMan = new Toy({ n: 'Turbo Man' });

    turboMan.name; // 'Turbo Man'
    turboMan.n; // 'Turbo Man'

    turboMan.name = 'Turbo Man Action Figure';
    turboMan.n; // 'Turbo Man Action Figure'

    await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }
    ```
- name: Schema.prototype.childSchemas
  id: api/schema#Schema.prototype.childSchemas
  summary: Array of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models
  belongs_to: Schema
  description: |-
    ### Schema.prototype.childSchemas

    ##### Type:

    - «property»

    Array of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties: `schema` and `model`.

    This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.
- name: Schema.prototype.clearIndexes()
  id: api/schema#Schema.prototype.clearIndexes()
  summary: Remove all indexes from this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.clearIndexes()

    ##### Returns:

    - «Schema» the Schema instance

    Remove all indexes from this schema.

    clearIndexes only removes indexes from your schema object. Does **not** affect the indexes in MongoDB.

    #### [Example:](#example)

    ``` javascript
    constToySchema = new Schema({ name: String, color: String, price: Number });
    ToySchema.index({ name: 1 });
    ToySchema.index({ color: 1 });

    // Remove all indexes on this schema
    ToySchema.clearIndexes();

    ToySchema.indexes(); // []
    ```
- name: Schema.prototype.clone()
  id: api/schema#Schema.prototype.clone()
  summary: null
  belongs_to: Schema
  description: |-
    ### Schema.prototype.clone()

    ##### Returns:

    - «Schema» the cloned schema

    Returns a deep copy of the schema

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ name: String });
    const clone = schema.clone();
    clone === schema; // false
    clone.path('name'); // SchemaString { ... }
    ```
- name: Schema.prototype.discriminator()
  id: api/schema#Schema.prototype.discriminator()
  summary: Inherit a Schema by applying a discriminator on an existing Schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.discriminator()

    ##### Parameters:

    - `name`«String» the name of the discriminator
    - `schema`«Schema» the discriminated Schema

    ##### Returns:

    - «Schema» the Schema instance

    Inherit a Schema by applying a discriminator on an existing Schema.

    #### [Example:](#example)

    ``` javascript
    const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });

    const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });
    const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);

    const Event = mongoose.model('Event', eventSchema);

    Event.discriminators['clicked']; // Model { clicked }

    const doc = await Event.create({ kind: 'clicked', element: '#hero' });
    doc.element; // '#hero'
    doc instanceof ClickedModel; // true
    ```
- name: Schema.prototype.eachPath()
  id: api/schema#Schema.prototype.eachPath()
  summary: Iterates the schemas paths similar to Array#forEach
  belongs_to: Schema
  description: |-
    ### Schema.prototype.eachPath()

    ##### Parameters:

    - `fn`«Function» callback function

    ##### Returns:

    - «Schema» this

    Iterates the schemas paths similar to Array#forEach.

    The callback is passed the pathname and the schemaType instance.

    #### [Example:](#example)

    ``` javascript
    const userSchema = new Schema({ name: String, registeredAt: Date });
    userSchema.eachPath((pathname, schematype) => {
      // Prints twice:
      // name SchemaString { ... }
      // registeredAt SchemaDate { ... }
      console.log(pathname, schematype);
    });
    ```
- name: Schema.prototype.get()
  id: api/schema#Schema.prototype.get()
  summary: Gets a schema option
  belongs_to: Schema
  description: |-
    ### Schema.prototype.get()

    ##### Parameters:

    - `key`«String» The name of the Option to get the current value for

    ##### Returns:

    - «Any» the option's value

    Gets a schema option.

    #### [Example:](#example)

    ``` javascript
    schema.get('strict'); // true
    schema.set('strict', false);
    schema.get('strict'); // false
    ```
- name: Schema.prototype.index()
  id: api/schema#Schema.prototype.index()
  summary: '[options.expires=null]«String|number» Mongoose-specific syntactic sugar, uses ms to convert expires option into seconds for the expireAfterSeconds in the above link'
  belongs_to: Schema
  description: |-
    ### Schema.prototype.index()

    ##### Parameters:

    - `fields`«Object» The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`
    - `[options]`«Object» Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)

    - `[options.expires=null]`«String\|number» Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.

    &nbsp;

    - `[options.language_override=null]`«String» Tells mongodb to use the specified field instead of `language` for parsing text indexes.

    Defines an index (most likely compound) for this schema.

    #### [Example:](#example)

    ``` javascript
    schema.index({ first: 1, last: -1 })
    ```
- name: Schema.prototype.indexes()
  id: api/schema#Schema.prototype.indexes()
  summary: 'Returns a list of indexes that this schema declares, via schema.index() or by index: true in a path''s options'
  belongs_to: Schema
  description: |-
    ### Schema.prototype.indexes()

    ##### Returns:

    - «Array» list of indexes defined in the schema

    Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options. Indexes are expressed as an array `[spec, options]`.

    #### [Example:](#example)

    ``` javascript
    const userSchema = new Schema({
      email: { type: String, required: true, unique: true },
      registeredAt: { type: Date, index: true }
    });

    // [ [ { email: 1 }, { unique: true, background: true } ],
    //   [ { registeredAt: 1 }, { background: true } ] ]
    userSchema.indexes();
    ```

    [Plugins](../plugins) can use the return value of this function to modify a schema's indexes. For example, the below plugin makes every index unique by default.

    ``` javascript
    functionmyPlugin(schema) {
      for (const index of schema.indexes()) {
        if (index[1].unique === undefined) {
          index[1].unique = true;
        }
      }
    }
    ```
- name: Schema.prototype.loadClass()
  id: api/schema#Schema.prototype.loadClass()
  summary: Loads an ES6 class into a schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.loadClass()

    ##### Parameters:

    - `model`«Function» The Class to load
    - `[virtualsOnly]`«Boolean» if truthy, only pulls virtuals from the class, not methods or statics

    Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static), and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions) to schema [virtuals](../guide#virtuals), [statics](../guide#statics), and [methods](../guide#methods).

    #### [Example:](#example)

    ``` javascript
    const md5 = require('md5');
    const userSchema = new Schema({ email: String });
    class UserClass {
      // `gravatarImage` becomes a virtual
      get gravatarImage() {
        const hash = md5(this.email.toLowerCase());
        return `https://www.gravatar.com/avatar/${hash}`;
      }

      // `getProfileUrl()` becomes a document method
      getProfileUrl() {
        return `https://mysite.com/${this.email}`;
      }

      // `findByEmail()` becomes a static
      static findByEmail(email) {
        return this.findOne({ email });
      }
    }

    // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,
    // and a `findByEmail()` static
    userSchema.loadClass(UserClass);
    ```
- name: Schema.prototype.method()
  id: api/schema#Schema.prototype.method()
  summary: Adds an instance method to documents constructed from Models compiled from this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.method()

    ##### Parameters:

    - `name`«String\|Object» The Method Name for a single function, or a Object of "string-function" pairs.
    - `[fn]`«Function» The Function in a single-function definition.

    Adds an instance method to documents constructed from Models compiled from this schema.

    #### [Example:](#example)

    ``` javascript
    const schema = kittySchema = new Schema(..);

    schema.method('meow', function () {
      console.log('meeeeeoooooooooooow');
    })

    const Kitty = mongoose.model('Kitty', schema);

    const fizz = new Kitty;
    fizz.meow(); // meeeeeooooooooooooow
    ```

    If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.

    ``` javascript
    schema.method({
        purr: function () {}
      , scratch: function () {}
    });

    // later
    const fizz = new Kitty;
    fizz.purr();
    fizz.scratch();
    ```

    NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](../guide#methods)
- name: Schema.prototype.obj
  id: api/schema#Schema.prototype.obj
  summary: null
  belongs_to: Schema
  description: |-
    ### Schema.prototype.obj

    ##### Type:

    - «property»

    The original object passed to the schema constructor

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ a: String }).add({ b: String });
    schema.obj; // { a: String }
    ```
- name: Schema.prototype.omit()
  id: api/schema#Schema.prototype.omit()
  summary: Returns a new schema that has the paths from the original schema, minus the omitted ones
  belongs_to: Schema
  description: |-
    ### Schema.prototype.omit()

    ##### Parameters:

    - `paths`«Array\[String\]» List of Paths to omit for the new Schema
    - `[options]`«Object» Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.

    ##### Returns:

    - «Schema»

    Returns a new schema that has the `paths` from the original schema, minus the omitted ones.

    This method is analagous to [Lodash's `omit()` function](https://lodash.com/docs/#omit) for Mongoose schemas.

    #### [Example:](#example)

    ``` javascript
    const schema = Schema({ name: String, age: Number });
    // Creates a new schema omitting the `age` path
    const newSchema = schema.omit(['age']);

    newSchema.path('name'); // SchemaString { ... }
    newSchema.path('age'); // undefined
    ```
- name: Schema.prototype.path()
  id: api/schema#Schema.prototype.path()
  summary: Gets/sets schema paths
  belongs_to: Schema
  description: |-
    ### Schema.prototype.path()

    ##### Parameters:

    - `path`«String» The name of the Path to get / set
    - `[obj]`«Object» The Type to set the path to, if provided the path will be SET, otherwise the path will be GET

    Gets/sets schema paths.

    Sets a path (if arity 2) Gets a path (if arity 1)

    #### [Example:](#example)

    ``` javascript
    schema.path('name') // returns a SchemaType
    schema.path('name', Number) // changes the schemaType of `name` to Number
    ```
- name: Schema.prototype.paths
  id: api/schema#Schema.prototype.paths
  summary: The paths defined on this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.paths

    ##### Type:

    - «property»

    The paths defined on this schema. The keys are the top-level paths in this schema, and the values are instances of the SchemaType class.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ name: String }, { _id: false });
    schema.paths; // { name: SchemaString { ... } }

    schema.add({ age: Number });
    schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }
    ```
- name: Schema.prototype.pathType()
  id: api/schema#Schema.prototype.pathType()
  summary: Returns the pathType of path for this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.pathType()

    ##### Parameters:

    - `path` «String»

    ##### Returns:

    - «String»

    Returns the pathType of `path` for this schema.

    Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ name: String, nested: { foo: String } });
    s.virtual('foo').get(() => 42);
    s.pathType('name'); // "real"
    s.pathType('nested'); // "nested"
    s.pathType('foo'); // "virtual"
    s.pathType('fail'); // "adhocOrUndefined"
    ```
- name: Schema.prototype.pick()
  id: api/schema#Schema.prototype.pick()
  summary: Returns a new schema that has the picked paths from this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.pick()

    ##### Parameters:

    - `paths`«Array\[String\]» List of Paths to pick for the new Schema
    - `[options]`«Object» Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.

    ##### Returns:

    - «Schema»

    Returns a new schema that has the picked `paths` from this schema.

    This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.

    #### [Example:](#example)

    ``` javascript
    const schema = Schema({ name: String, age: Number });
    // Creates a new schema with the same `name` path as `schema`,
    // but no `age` path.
    const newSchema = schema.pick(['name']);

    newSchema.path('name'); // SchemaString { ... }
    newSchema.path('age'); // undefined
    ```
- name: Schema.prototype.plugin()
  id: api/schema#Schema.prototype.plugin()
  summary: Registers a plugin for this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.plugin()

    ##### Parameters:

    - `plugin`«Function» The Plugin's callback
    - `[opts]`«Object» Options to pass to the plugin

    &nbsp;

    - `[opts.deduplicate=false]`«Boolean» If true, ignore duplicate plugins (same `fn` argument using `===`)

    ##### See:

    -  [plugins](../plugins)

    Registers a plugin for this schema.

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ name: String });
    s.plugin(schema => console.log(schema.path('name').path));
    mongoose.model('Test', s); // Prints 'name'
    ```

    Or with Options:

    ``` javascript
    const s = new Schema({ name: String });
    s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: "Schema Path Name:" });
    mongoose.model('Test', s); // Prints 'Schema Path Name: name'
    ```
- name: Schema.prototype.post()
  id: api/schema#Schema.prototype.post()
  summary: null
  belongs_to: Schema
  description: |-
    ### Schema.prototype.post()

    ##### Parameters:

    - `methodName`«String\|RegExp\|Array\[String\]» The method name or regular expression to match method name
    - `[options]` «Object»

    &nbsp;

    - `[options.document]`«Boolean» If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.

    &nbsp;

    - `[options.query]`«Boolean» If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.

    &nbsp;

    - `fn`«Function» callback

    ##### See:

    -  [middleware](../middleware)
    -  [kareem](https://npmjs.org/package/kareem)

    Defines a post hook for the document

    ``` javascript
    const schema = new Schema(..);
    schema.post('save', function (doc) {
      console.log('this fired after a document was saved');
    });

    schema.post('find', function(docs) {
      console.log('this fired after you ran a find query');
    });

    schema.post(/Many$/, function(res) {
      console.log('this fired after you ran `updateMany()` or `deleteMany()`');
    });

    const Model = mongoose.model('Model', schema);

    const m = new Model(..);
    m.save(function(err) {
      console.log('this fires after the `post` hook');
    });

    m.find(function(err, docs) {
      console.log('this fires after the post find hook');
    });
    ```
- name: Schema.prototype.pre()
  id: api/schema#Schema.prototype.pre()
  summary: Defines a pre hook for the model
  belongs_to: Schema
  description: |-
    ### Schema.prototype.pre()

    ##### Parameters:

    - `methodName`«String\|RegExp\|Array\[String\]» The method name or regular expression to match method name
    - `[options]` «Object»

    &nbsp;

    - `[options.document]`«Boolean» If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.

    &nbsp;

    - `[options.query]`«Boolean» If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.

    &nbsp;

    - `callback` «Function»

    Defines a pre hook for the model.

    #### [Example:](#example)

    ``` javascript
    const toySchema = new Schema({ name: String, created: Date });

    toySchema.pre('save', function(next) {
      if (!this.created) this.created = new Date;
      next();
    });

    toySchema.pre('validate', function(next) {
      if (this.name !== 'Woody') this.name = 'Woody';
      next();
    });

    // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.
    toySchema.pre(/^find/, function(next) {
      console.log(this.getFilter());
    });

    // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.
    toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {
      console.log(this.getFilter());
    });

    toySchema.pre('deleteOne', function() {
      // Runs when you call `Toy.deleteOne()`
    });

    toySchema.pre('deleteOne', { document: true }, function() {
      // Runs when you call `doc.deleteOne()`
    });
    ```
- name: Schema.prototype.queue()
  id: api/schema#Schema.prototype.queue()
  summary: Adds a method call to the queue
  belongs_to: Schema
  description: |-
    ### Schema.prototype.queue()

    ##### Parameters:

    - `name`«String» name of the document method to call later
    - `args`«Array» arguments to pass to the method

    Adds a method call to the queue.

    #### [Example:](#example)

    ``` javascript
    schema.methods.print = function() { console.log(this); };
    schema.queue('print', []); // Print the doc every one is instantiated

    const Model = mongoose.model('Test', schema);
    new Model({ name: 'test' }); // Prints '{"_id": ..., "name": "test" }'
    ```
- name: Schema.prototype.remove()
  id: api/schema#Schema.prototype.remove()
  summary: Removes the given path (or [paths])
  belongs_to: Schema
  description: |-
    ### Schema.prototype.remove()

    ##### Parameters:

    - `path`«String\|Array» The Path(s) to remove

    ##### Returns:

    - «Schema» the Schema instance

    Removes the given `path` (or \[`paths`\]).

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ name: String, age: Number });
    schema.remove('name');
    schema.path('name'); // Undefined
    schema.path('age'); // SchemaNumber { ... }
    ```

    Or as a Array:

    ``` javascript
    schema.remove(['name', 'age']);
    schema.path('name'); // Undefined
    schema.path('age'); // Undefined
    ```
- name: Schema.prototype.removeIndex()
  id: api/schema#Schema.prototype.removeIndex()
  summary: Remove an index by name or index specification
  belongs_to: Schema
  description: |-
    ### Schema.prototype.removeIndex()

    ##### Parameters:

    - `index`«Object\|string» name or index specification

    ##### Returns:

    - «Schema» the Schema instance

    Remove an index by name or index specification.

    removeIndex only removes indexes from your schema object. Does **not** affect the indexes in MongoDB.

    #### [Example:](#example)

    ``` javascript
    constToySchema = new Schema({ name: String, color: String, price: Number });

    // Add a new index on { name, color }
    ToySchema.index({ name: 1, color: 1 });

    // Remove index on { name, color }
    // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index
    ToySchema.removeIndex({ name: 1, color: 1 });

    // Add an index with a custom name
    ToySchema.index({ color: 1 }, { name: 'my custom index name' });
    // Remove index by name
    ToySchema.removeIndex('my custom index name');
    ```
- name: Schema.prototype.removeVirtual()
  id: api/schema#Schema.prototype.removeVirtual()
  summary: Removes the given virtual or virtuals from the schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.removeVirtual()

    ##### Parameters:

    - `path`«String\|Array» The virutal path(s) to remove.

    Removes the given virtual or virtuals from the schema.
- name: Schema.prototype.requiredPaths()
  id: api/schema#Schema.prototype.requiredPaths()
  summary: Returns an Array of path strings that are required by this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.requiredPaths()

    ##### Parameters:

    - `invalidate`«Boolean» Refresh the cache

    ##### Returns:

    - «Array»

    Returns an Array of path strings that are required by this schema.

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({
      name: { type: String, required: true },
      age: { type: String, required: true },
      notes: String
    });
    s.requiredPaths(); // [ 'age', 'name' ]
    ```
- name: Schema.prototype.set()
  id: api/schema#Schema.prototype.set()
  summary: Sets a schema option
  belongs_to: Schema
  description: |-
    ### Schema.prototype.set()

    ##### Parameters:

    - `key`«String» The name of the option to set the value to
    - `[value]`«Object» The value to set the option to, if not passed, the option will be reset to default
    - `[tags]`«Array\<string\>» tags to add to read preference if key === 'read'

    ##### See:

    -  [Schema](#Schema())

    Sets a schema option.

    #### [Example:](#example)

    ``` javascript
    schema.set('strict'); // 'true' by default
    schema.set('strict', false); // Sets 'strict' to false
    schema.set('strict'); // 'false'
    ```
- name: Schema.prototype.static()
  id: api/schema#Schema.prototype.static()
  summary: Adds static "class" methods to Models compiled from this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.static()

    ##### Parameters:

    - `name`«String\|Object» The Method Name for a single function, or a Object of "string-function" pairs.
    - `[fn]`«Function» The Function in a single-function definition.

    ##### See:

    -  [Statics](../guide#statics)

    Adds static "class" methods to Models compiled from this schema.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema(..);
    // Equivalent to `schema.statics.findByName = function(name) {}`;
    schema.static('findByName', function(name) {
      return this.find({ name: name });
    });

    const Drink = mongoose.model('Drink', schema);
    await Drink.findByName('LaCroix');
    ```

    If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.

    ``` javascript
    schema.static({
        findByName: function () {..}
      , findByCost: function () {..}
    });

    const Drink = mongoose.model('Drink', schema);
    await Drink.findByName('LaCroix');
    await Drink.findByCost(3);
    ```

    If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.
- name: Schema.prototype.virtual()
  id: api/schema#Schema.prototype.virtual()
  summary: Creates a virtual type with the given name
  belongs_to: Schema
  description: |-
    ### Schema.prototype.virtual()

    ##### Parameters:

    - `name`«String» The name of the Virtual
    - `[options]` «Object»

    &nbsp;

    - `[options.ref]`«String\|Model» model name or model instance. Marks this as a [populate virtual](../populate#populate-virtuals).

    &nbsp;

    - `[options.localField]`«String\|Function» Required for populate virtuals. See [populate virtual docs](../populate#populate-virtuals) for more information.

    &nbsp;

    - `[options.foreignField]`«String\|Function» Required for populate virtuals. See [populate virtual docs](../populate#populate-virtuals) for more information.

    &nbsp;

    - `[options.justOne=false]`«Boolean\|Function» Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.

    &nbsp;

    - `[options.count=false]`«Boolean» Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.

    &nbsp;

    - `[options.get=null]`«Function\|null» Adds a [getter](../tutorials/getters-setters) to this virtual to transform the populated doc.

    &nbsp;

    - `[options.match=null]`«Object\|Function» Apply a default [`match` option to populate](../populate#match), adding an additional filter to the populate query.

    ##### Returns:

    - «VirtualType»

    Creates a virtual type with the given name.
- name: Schema.prototype.virtualpath()
  id: api/schema#Schema.prototype.virtualpath()
  summary: Returns the virtual type with the given name
  belongs_to: Schema
  description: |-
    ### Schema.prototype.virtualpath()

    ##### Parameters:

    - `name`«String» The name of the Virtual to get

    ##### Returns:

    - «VirtualType,null»

    Returns the virtual type with the given `name`.
- name: Schema.prototype.virtuals
  id: api/schema#Schema.prototype.virtuals
  summary: Object containing all virtuals defined on this schema
  belongs_to: Schema
  description: |-
    ### Schema.prototype.virtuals

    ##### Type:

    - «property»

    Object containing all virtuals defined on this schema. The objects' keys are the virtual paths and values are instances of `VirtualType`.

    This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({});
    schema.virtual('answer').get(() => 42);

    console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }
    console.log(schema.virtuals['answer'].getters[0].call()); // 42
    ```
- name: Schema.reserved
  id: api/schema#Schema.reserved
  summary: Reserved document keys
  belongs_to: Schema
  description: "### Schema.reserved\n\n##### Type:\n\n- «property»\n\nReserved document keys.\n\nKeys in this object are names that are warned in schema declarations because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema using `new Schema()` with one of these property names, Mongoose will log a warning.\n\n- \\_posts\n- \\_pres\n- collection\n- emit\n- errors\n- get\n- init\n- isModified\n- isNew\n- listeners\n- modelName\n- on\n- once\n- populated\n- prototype\n- remove\n- removeListener\n- save\n- schema\n- toObject\n- validate\n\n*NOTE:* Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n\n``` javascript\nconst schema = new Schema(..);\n schema.methods.init = function () {} // potentially breaking\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schema.html](https://mongoosejs.com/docs/api/schema.html)"
- name: Schema.Types
  id: api/schema#Schema.Types
  summary: The various built-in Mongoose Schema Types
  belongs_to: Schema
  description: |-
    ### Schema.Types

    ##### Type:

    - «property»

    The various built-in Mongoose Schema Types.

    #### [Example:](#example)

    ``` javascript
    const mongoose = require('mongoose');
    const ObjectId = mongoose.Schema.Types.ObjectId;
    ```

    #### [Types:](#types)

    - [String](../schematypes#strings)
    - [Number](../schematypes#numbers)
    - [Boolean](../schematypes#booleans) \| Bool
    - [Array](../schematypes#arrays)
    - [Buffer](../schematypes#buffers)
    - [Date](../schematypes#dates)
    - [ObjectId](../schematypes#objectids) \| Oid
    - [Mixed](../schematypes#mixed)
    - [UUID](../schematypes#uuid)
    - [BigInt](../schematypes#bigint)

    Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.

    ``` javascript
    constMixed = mongoose.Schema.Types.Mixed;
    new mongoose.Schema({ _user: Mixed })
    ```
- name: SchemaArray
  id: api/schemaarray
  summary: Override the function the required validator uses to check whether an array passes the required check
  description: "# SchemaArray\n\n### SchemaArray()\n\n##### Parameters:\n\n- `key` «String»\n- `cast` «SchemaType»\n- `options` «Object»\n- `schemaOptions` «Object»\n\n##### Inherits:\n\n- [«SchemaType»](schematype)\n\nArray SchemaType constructor\n\n### SchemaArray.checkRequired()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «Function»\n\nOverride the function the required validator uses to check whether an array passes the `required` check.\n\n#### [Example:](#example)\n\n``` javascript\n// Require non-empty array to pass `required` check\nmongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n\nconst M = mongoose.model({ arr: { type: Array, required: true } });\nnew M({ arr: [] }).validateSync(); // `null`, validation fails!\n```\n\n### SchemaArray.get()\n\n##### Parameters:\n\n- `getter` «Function»\n\n##### Returns:\n\n- «this»\n\n##### Type:\n\n- «property»\n\nAttaches a getter for all Array instances\n\n### SchemaArray.options\n\n##### Type:\n\n- «property»\n\nOptions for all arrays.\n\n- `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n\n### SchemaArray.prototype.checkRequired()\n\n##### Parameters:\n\n- `value` «Any»\n- `doc` «Document»\n\n##### Returns:\n\n- «Boolean»\n\nCheck if the given value satisfies the `required` validator.\n\n### SchemaArray.prototype.enum()\n\n##### Parameters:\n\n- `[...args]` «String\\|Object» enumeration values\n\n##### Returns:\n\n- «SchemaArray» this\n\nAdds an enum validator if this is an array of strings or numbers. Equivalent to `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n\n### SchemaArray.schemaName\n\n##### Type:\n\n- «property»\n\nThis schema type's name, to defend against minifiers that mangle function names.\n\n### SchemaArray.set()\n\n##### Parameters:\n\n- `option` «String» The option you'd like to set the value for\n- `value` «Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\nSets a default option for all Array instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all Array instances have `required` of true by default.\nmongoose.Schema.Array.set('required', true);\n\nconst User = mongoose.model('User', new Schema({ test: Array }));\nnew User({ }).validateSync().errors.test.message; // Path `test` is required.\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemaarray.html](https://mongoosejs.com/docs/api/schemaarray.html)"
- name: SchemaArray()
  id: api/schemaarray#SchemaArray()
  summary: null
  belongs_to: SchemaArray
  description: |-
    ### SchemaArray()

    ##### Parameters:

    - `key` «String»
    - `cast` «SchemaType»
    - `options` «Object»
    - `schemaOptions` «Object»

    ##### Inherits:

    -  [«SchemaType»](schematype)

    Array SchemaType constructor
- name: SchemaArray.checkRequired()
  id: api/schemaarray#SchemaArray.checkRequired()
  summary: Override the function the required validator uses to check whether an array passes the required check
  belongs_to: SchemaArray
  description: |-
    ### SchemaArray.checkRequired()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «Function»

    Override the function the required validator uses to check whether an array passes the `required` check.

    #### [Example:](#example)

    ``` javascript
    // Require non-empty array to pass `required` check
    mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);

    const M = mongoose.model({ arr: { type: Array, required: true } });
    new M({ arr: [] }).validateSync(); // `null`, validation fails!
    ```
- name: SchemaArray.get()
  id: api/schemaarray#SchemaArray.get()
  summary: null
  belongs_to: SchemaArray
  description: |-
    ### SchemaArray.get()

    ##### Parameters:

    - `getter` «Function»

    ##### Returns:

    - «this»

    ##### Type:

    - «property»

    Attaches a getter for all Array instances
- name: SchemaArray.options
  id: api/schemaarray#SchemaArray.options
  summary: Options for all arrays
  belongs_to: SchemaArray
  description: |-
    ### SchemaArray.options

    ##### Type:

    - «property»

    Options for all arrays.

    - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.
- name: SchemaArray.prototype.checkRequired()
  id: api/schemaarray#SchemaArray.prototype.checkRequired()
  summary: Check if the given value satisfies the required validator
  belongs_to: SchemaArray
  description: |-
    ### SchemaArray.prototype.checkRequired()

    ##### Parameters:

    - `value` «Any»
    - `doc` «Document»

    ##### Returns:

    - «Boolean»

    Check if the given value satisfies the `required` validator.
- name: SchemaArray.prototype.enum()
  id: api/schemaarray#SchemaArray.prototype.enum()
  summary: Adds an enum validator if this is an array of strings or numbers
  belongs_to: SchemaArray
  description: |-
    ### SchemaArray.prototype.enum()

    ##### Parameters:

    - `[...args]`«String\|Object» enumeration values

    ##### Returns:

    - «SchemaArray» this

    Adds an enum validator if this is an array of strings or numbers. Equivalent to `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`
- name: SchemaArray.schemaName
  id: api/schemaarray#SchemaArray.schemaName
  summary: This schema type's name, to defend against minifiers that mangle function names
  belongs_to: SchemaArray
  description: |-
    ### SchemaArray.schemaName

    ##### Type:

    - «property»

    This schema type's name, to defend against minifiers that mangle function names.
- name: SchemaArray.set()
  id: api/schemaarray#SchemaArray.set()
  summary: Sets a default option for all Array instances
  belongs_to: SchemaArray
  description: "### SchemaArray.set()\n\n##### Parameters:\n\n- `option`«String» The option you'd like to set the value for\n- `value`«Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\nSets a default option for all Array instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all Array instances have `required` of true by default.\nmongoose.Schema.Array.set('required', true);\n\nconst User = mongoose.model('User', new Schema({ test: Array }));\nnew User({ }).validateSync().errors.test.message; // Path `test` is required.\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemaarray.html](https://mongoosejs.com/docs/api/schemaarray.html)"
- name: SchemaBoolean
  id: api/schemaboolean
  summary: Boolean SchemaType constructor
  description: "# SchemaBoolean\n\n### SchemaBoolean()\n\n##### Parameters:\n\n- `path` «String»\n- `options` «Object»\n\n##### Inherits:\n\n- [«SchemaType»](schematype)\n\nBoolean SchemaType constructor.\n\n### SchemaBoolean.checkRequired()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «Function»\n\n##### Type:\n\n- «property»\n\nOverride the function the required validator uses to check whether a boolean passes the `required` check.\n\n### SchemaBoolean.convertToFalse\n\n##### Type:\n\n- «Set»\n\nConfigure which values get casted to `false`.\n\n#### [Example:](#example)\n\n``` javascript\nconst M = mongoose.model('Test', new Schema({ b: Boolean }));\nnew M({ b: 'nay' }).b; // undefined\nmongoose.Schema.Types.Boolean.convertToFalse.add('nay');\nnew M({ b: 'nay' }).b; // false\n```\n\n### SchemaBoolean.convertToTrue\n\n##### Type:\n\n- «Set»\n\nConfigure which values get casted to `true`.\n\n#### [Example:](#example)\n\n``` javascript\nconst M = mongoose.model('Test', new Schema({ b: Boolean }));\nnew M({ b: 'affirmative' }).b; // undefined\nmongoose.Schema.Boolean.convertToTrue.add('affirmative');\nnew M({ b: 'affirmative' }).b; // true\n```\n\n### SchemaBoolean.get()\n\n##### Parameters:\n\n- `getter` «Function»\n\n##### Returns:\n\n- «this»\n\n##### Type:\n\n- «property»\n\nAttaches a getter for all Boolean instances\n\n#### [Example:](#example)\n\n``` javascript\nmongoose.Schema.Boolean.get(v => v === true ? 'yes' : 'no');\n\nconst Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\nnew Order({ isPaid: false }).isPaid; // 'no'\n```\n\n### SchemaBoolean.get()\n\n##### Parameters:\n\n- `caster` «Function»\n\n##### Returns:\n\n- «Function»\n\n##### Type:\n\n- «property»\n\nGet/set the function used to cast arbitrary values to booleans.\n\n#### [Example:](#example)\n\n``` javascript\n// Make Mongoose cast empty string '' to false.\nconst original = mongoose.Schema.Boolean.cast();\nmongoose.Schema.Boolean.cast(v => {\n  if (v === '') {\n    return false;\n  }\n  return original(v);\n});\n\n// Or disable casting entirely\nmongoose.Schema.Boolean.cast(false);\n```\n\n### SchemaBoolean.prototype.checkRequired()\n\n##### Parameters:\n\n- `value` «Any»\n\n##### Returns:\n\n- «Boolean»\n\nCheck if the given value satisfies a required validator. For a boolean to satisfy a required validator, it must be strictly equal to true or to false.\n\n### SchemaBoolean.schemaName\n\n##### Type:\n\n- «property»\n\nThis schema type's name, to defend against minifiers that mangle function names.\n\n### SchemaBoolean.set()\n\n##### Parameters:\n\n- `option` «String» The option you'd like to set the value for\n- `value` «Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all Boolean instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all booleans have `default` of false.\nmongoose.Schema.Boolean.set('default', false);\n\nconst Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\nnew Order({ }).isPaid; // false\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemaboolean.html](https://mongoosejs.com/docs/api/schemaboolean.html)"
- name: SchemaBoolean()
  id: api/schemaboolean#SchemaBoolean()
  summary: Boolean SchemaType constructor
  belongs_to: SchemaBoolean
  description: |-
    ### SchemaBoolean()

    ##### Parameters:

    - `path` «String»
    - `options` «Object»

    ##### Inherits:

    -  [«SchemaType»](schematype)

    Boolean SchemaType constructor.
- name: SchemaBoolean.checkRequired()
  id: api/schemaboolean#SchemaBoolean.checkRequired()
  summary: Override the function the required validator uses to check whether a boolean passes the required check
  belongs_to: SchemaBoolean
  description: |-
    ### SchemaBoolean.checkRequired()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «Function»

    ##### Type:

    - «property»

    Override the function the required validator uses to check whether a boolean passes the `required` check.
- name: SchemaBoolean.convertToFalse
  id: api/schemaboolean#SchemaBoolean.convertToFalse
  summary: Configure which values get casted to false
  belongs_to: SchemaBoolean
  description: |-
    ### SchemaBoolean.convertToFalse

    ##### Type:

    - «Set»

    Configure which values get casted to `false`.

    #### [Example:](#example)

    ``` javascript
    const M = mongoose.model('Test', new Schema({ b: Boolean }));
    new M({ b: 'nay' }).b; // undefined
    mongoose.Schema.Types.Boolean.convertToFalse.add('nay');
    new M({ b: 'nay' }).b; // false
    ```
- name: SchemaBoolean.convertToTrue
  id: api/schemaboolean#SchemaBoolean.convertToTrue
  summary: Configure which values get casted to true
  belongs_to: SchemaBoolean
  description: |-
    ### SchemaBoolean.convertToTrue

    ##### Type:

    - «Set»

    Configure which values get casted to `true`.

    #### [Example:](#example)

    ``` javascript
    const M = mongoose.model('Test', new Schema({ b: Boolean }));
    new M({ b: 'affirmative' }).b; // undefined
    mongoose.Schema.Boolean.convertToTrue.add('affirmative');
    new M({ b: 'affirmative' }).b; // true
    ```
- name: SchemaBoolean.get()
  id: api/schemaboolean#SchemaBoolean.get()
  summary: Get/set the function used to cast arbitrary values to booleans
  belongs_to: SchemaBoolean
  description: |-
    ### SchemaBoolean.get()

    ##### Parameters:

    - `getter` «Function»

    ##### Returns:

    - «this»

    ##### Type:

    - «property»

    Attaches a getter for all Boolean instances

    #### [Example:](#example)

    ``` javascript
    mongoose.Schema.Boolean.get(v => v === true ? 'yes' : 'no');

    const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));
    new Order({ isPaid: false }).isPaid; // 'no'
    ```

    ### SchemaBoolean.get()

    ##### Parameters:

    - `caster` «Function»

    ##### Returns:

    - «Function»

    ##### Type:

    - «property»

    Get/set the function used to cast arbitrary values to booleans.

    #### [Example:](#example)

    ``` javascript
    // Make Mongoose cast empty string '' to false.const original = mongoose.Schema.Boolean.cast();
    mongoose.Schema.Boolean.cast(v => {
      if (v === '') {
        return false;
      }
      return original(v);
    });

    // Or disable casting entirely
    mongoose.Schema.Boolean.cast(false);
    ```
- name: SchemaBoolean.prototype.checkRequired()
  id: api/schemaboolean#SchemaBoolean.prototype.checkRequired()
  summary: Check if the given value satisfies a required validator
  belongs_to: SchemaBoolean
  description: |-
    ### SchemaBoolean.prototype.checkRequired()

    ##### Parameters:

    - `value` «Any»

    ##### Returns:

    - «Boolean»

    Check if the given value satisfies a required validator. For a boolean to satisfy a required validator, it must be strictly equal to true or to false.
- name: SchemaBoolean.schemaName
  id: api/schemaboolean#SchemaBoolean.schemaName
  summary: This schema type's name, to defend against minifiers that mangle function names
  belongs_to: SchemaBoolean
  description: |-
    ### SchemaBoolean.schemaName

    ##### Type:

    - «property»

    This schema type's name, to defend against minifiers that mangle function names.
- name: SchemaBoolean.set()
  id: api/schemaboolean#SchemaBoolean.set()
  summary: Sets a default option for all Boolean instances
  belongs_to: SchemaBoolean
  description: "### SchemaBoolean.set()\n\n##### Parameters:\n\n- `option`«String» The option you'd like to set the value for\n- `value`«Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all Boolean instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all booleans have `default` of false.\nmongoose.Schema.Boolean.set('default', false);\n\nconst Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\nnew Order({ }).isPaid; // false\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemaboolean.html](https://mongoosejs.com/docs/api/schemaboolean.html)"
- name: SchemaBuffer
  id: api/schemabuffer
  summary: Override the function the required validator uses to check whether a string passes the required check
  description: "# SchemaBuffer\n\n### SchemaBuffer()\n\n##### Parameters:\n\n- `key` «String»\n- `options` «Object»\n\n##### Inherits:\n\n- [«SchemaType»](schematype)\n\nBuffer SchemaType constructor\n\n### SchemaBuffer.checkRequired()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «Function»\n\n##### Type:\n\n- «property»\n\nOverride the function the required validator uses to check whether a string passes the `required` check.\n\n#### [Example:](#example)\n\n``` javascript\n// Allow empty strings to pass `required` check\nmongoose.Schema.Types.String.checkRequired(v => v != null);\n\nconst M = mongoose.model({ buf: { type: Buffer, required: true } });\nnew M({ buf: Buffer.from('') }).validateSync(); // validation passes!\n```\n\n### SchemaBuffer.get()\n\n##### Parameters:\n\n- `getter` «Function»\n\n##### Returns:\n\n- «this»\n\n##### Type:\n\n- «property»\n\nAttaches a getter for all Buffer instances\n\n#### [Example:](#example)\n\n``` javascript\n// Always convert to string when getting an ObjectId\nmongoose.Schema.Types.Buffer.get(v => v.toString('hex'));\n\nconst Model = mongoose.model('Test', new Schema({ buf: Buffer } }));\ntypeof (new Model({ buf: Buffer.fromString('hello') }).buf); // 'string'\n```\n\n### SchemaBuffer.prototype.checkRequired()\n\n##### Parameters:\n\n- `value` «Any»\n- `doc` «Document»\n\n##### Returns:\n\n- «Boolean»\n\nCheck if the given value satisfies a required validator. To satisfy a required validator, a buffer must not be null or undefined and have non-zero length.\n\n### SchemaBuffer.prototype.subtype()\n\n##### Parameters:\n\n- `subtype` «Number» the default subtype\n\n##### Returns:\n\n- «SchemaType» this\n\nSets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/) for this buffer. You can find a [list of allowed subtypes here](https://api.mongodb.com/python/current/api/bson/binary.html).\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ uuid: { type: Buffer, subtype: 4 });\nconst M = db.model('M', s);\nconst m = new M({ uuid: 'test string' });\nm.uuid._subtype; // 4\n```\n\n### SchemaBuffer.schemaName\n\n##### Type:\n\n- «property»\n\nThis schema type's name, to defend against minifiers that mangle function names.\n\n### SchemaBuffer.set()\n\n##### Parameters:\n\n- `option` «String» The option you'd like to set the value for\n- `value` «Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all Buffer instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all buffers have `required` of true by default.\nmongoose.Schema.Buffer.set('required', true);\n\nconst User = mongoose.model('User', new Schema({ test: Buffer }));\nnew User({ }).validateSync().errors.test.message; // Path `test` is required.\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemabuffer.html](https://mongoosejs.com/docs/api/schemabuffer.html)"
- name: SchemaBuffer()
  id: api/schemabuffer#SchemaBuffer()
  summary: null
  belongs_to: SchemaBuffer
  description: |-
    ### SchemaBuffer()

    ##### Parameters:

    - `key` «String»
    - `options` «Object»

    ##### Inherits:

    -  [«SchemaType»](schematype)

    Buffer SchemaType constructor
- name: SchemaBuffer.checkRequired()
  id: api/schemabuffer#SchemaBuffer.checkRequired()
  summary: Override the function the required validator uses to check whether a string passes the required check
  belongs_to: SchemaBuffer
  description: |-
    ### SchemaBuffer.checkRequired()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «Function»

    ##### Type:

    - «property»

    Override the function the required validator uses to check whether a string passes the `required` check.

    #### [Example:](#example)

    ``` javascript
    // Allow empty strings to pass `required` check
    mongoose.Schema.Types.String.checkRequired(v => v != null);

    const M = mongoose.model({ buf: { type: Buffer, required: true } });
    new M({ buf: Buffer.from('') }).validateSync(); // validation passes!
    ```
- name: SchemaBuffer.get()
  id: api/schemabuffer#SchemaBuffer.get()
  summary: null
  belongs_to: SchemaBuffer
  description: |-
    ### SchemaBuffer.get()

    ##### Parameters:

    - `getter` «Function»

    ##### Returns:

    - «this»

    ##### Type:

    - «property»

    Attaches a getter for all Buffer instances

    #### [Example:](#example)

    ``` javascript
    // Always convert to string when getting an ObjectId
    mongoose.Schema.Types.Buffer.get(v => v.toString('hex'));

    const Model = mongoose.model('Test', new Schema({ buf: Buffer } }));
    typeof (new Model({ buf: Buffer.fromString('hello') }).buf); // 'string'
    ```
- name: SchemaBuffer.prototype.checkRequired()
  id: api/schemabuffer#SchemaBuffer.prototype.checkRequired()
  summary: Check if the given value satisfies a required validator
  belongs_to: SchemaBuffer
  description: |-
    ### SchemaBuffer.prototype.checkRequired()

    ##### Parameters:

    - `value` «Any»
    - `doc` «Document»

    ##### Returns:

    - «Boolean»

    Check if the given value satisfies a required validator. To satisfy a required validator, a buffer must not be null or undefined and have non-zero length.
- name: SchemaBuffer.prototype.subtype()
  id: api/schemabuffer#SchemaBuffer.prototype.subtype()
  summary: Sets the default subtype for this buffer
  belongs_to: SchemaBuffer
  description: |-
    ### SchemaBuffer.prototype.subtype()

    ##### Parameters:

    - `subtype`«Number» the default subtype

    ##### Returns:

    - «SchemaType» this

    Sets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/) for this buffer. You can find a [list of allowed subtypes here](https://api.mongodb.com/python/current/api/bson/binary.html).

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ uuid: { type: Buffer, subtype: 4 });
    const M = db.model('M', s);
    const m = new M({ uuid: 'test string' });
    m.uuid._subtype; // 4
    ```
- name: SchemaBuffer.schemaName
  id: api/schemabuffer#SchemaBuffer.schemaName
  summary: This schema type's name, to defend against minifiers that mangle function names
  belongs_to: SchemaBuffer
  description: |-
    ### SchemaBuffer.schemaName

    ##### Type:

    - «property»

    This schema type's name, to defend against minifiers that mangle function names.
- name: SchemaBuffer.set()
  id: api/schemabuffer#SchemaBuffer.set()
  summary: Sets a default option for all Buffer instances
  belongs_to: SchemaBuffer
  description: "### SchemaBuffer.set()\n\n##### Parameters:\n\n- `option`«String» The option you'd like to set the value for\n- `value`«Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all Buffer instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all buffers have `required` of true by default.\nmongoose.Schema.Buffer.set('required', true);\n\nconst User = mongoose.model('User', new Schema({ test: Buffer }));\nnew User({ }).validateSync().errors.test.message; // Path `test` is required.\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemabuffer.html](https://mongoosejs.com/docs/api/schemabuffer.html)"
- name: SchemaDateOptions
  id: api/schemadateoptions
  summary: The options defined on a Date schematype
  description: "# SchemaDateOptions\n\n### SchemaDateOptions()\n\n##### Type:\n\n- «constructor»\n\n##### Inherits:\n\n- [«SchemaTypeOptions»](schematypeoptions)\n\nThe options defined on a Date schematype.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ startedAt: Date });\nschema.path('startedAt').options; // SchemaDateOptions instance\n```\n\n### SchemaDateOptions.prototype.expires\n\n##### Type:\n\n- «Date»\n\nIf set, Mongoose creates a TTL index on this path.\n\nmongo TTL index `expireAfterSeconds` value will take 'expires' value expressed in seconds.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ \"expireAt\": { type: Date,  expires: 11 } });\n// if 'expireAt' is set, then document expires at expireAt + 11 seconds\n```\n\n### SchemaDateOptions.prototype.max\n\n##### Type:\n\n- «Date»\n\nIf set, Mongoose adds a validator that checks that this path is before the given `max`.\n\n### SchemaDateOptions.prototype.min\n\n##### Type:\n\n- «Date»\n\nIf set, Mongoose adds a validator that checks that this path is after the given `min`.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemadateoptions.html](https://mongoosejs.com/docs/api/schemadateoptions.html)"
- name: SchemaDateOptions()
  id: api/schemadateoptions#SchemaDateOptions()
  summary: The options defined on a Date schematype
  belongs_to: SchemaDateOptions
  description: |-
    ### SchemaDateOptions()

    ##### Type:

    - «constructor»

    ##### Inherits:

    -  [«SchemaTypeOptions»](schematypeoptions)

    The options defined on a Date schematype.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ startedAt: Date });
    schema.path('startedAt').options; // SchemaDateOptions instance
    ```
- name: SchemaDateOptions.prototype.expires
  id: api/schemadateoptions#SchemaDateOptions.prototype.expires
  summary: If set, Mongoose creates a TTL index on this path
  belongs_to: SchemaDateOptions
  description: |-
    ### SchemaDateOptions.prototype.expires

    ##### Type:

    - «Date»

    If set, Mongoose creates a TTL index on this path.

    mongo TTL index `expireAfterSeconds` value will take 'expires' value expressed in seconds.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ "expireAt": { type: Date,  expires: 11 } });
    // if 'expireAt' is set, then document expires at expireAt + 11 seconds
    ```
- name: SchemaDateOptions.prototype.max
  id: api/schemadateoptions#SchemaDateOptions.prototype.max
  summary: If set, Mongoose adds a validator that checks that this path is before the given max
  belongs_to: SchemaDateOptions
  description: |-
    ### SchemaDateOptions.prototype.max

    ##### Type:

    - «Date»

    If set, Mongoose adds a validator that checks that this path is before the given `max`.
- name: SchemaDateOptions.prototype.min
  id: api/schemadateoptions#SchemaDateOptions.prototype.min
  summary: If set, Mongoose adds a validator that checks that this path is after the given min
  belongs_to: SchemaDateOptions
  description: "### SchemaDateOptions.prototype.min\n\n##### Type:\n\n- «Date»\n\nIf set, Mongoose adds a validator that checks that this path is after the given `min`.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemadateoptions.html](https://mongoosejs.com/docs/api/schemadateoptions.html)"
- name: SchemaNumber
  id: api/schemanumber
  summary: Number SchemaType constructor
  description: "# SchemaNumber\n\n### SchemaNumber()\n\n##### Parameters:\n\n- `key` «String»\n- `options` «Object»\n\n##### Inherits:\n\n- [«SchemaType»](schematype)\n\nNumber SchemaType constructor.\n\n### SchemaNumber.checkRequired()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «Function»\n\n##### Type:\n\n- «property»\n\nOverride the function the required validator uses to check whether a string passes the `required` check.\n\n### SchemaNumber.get()\n\n##### Parameters:\n\n- `getter` «Function»\n\n##### Returns:\n\n- «this»\n\n##### Type:\n\n- «property»\n\nAttaches a getter for all Number instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all numbers round down\nmongoose.Number.get(function(v) { return Math.floor(v); });\n\nconst Model = mongoose.model('Test', new Schema({ test: Number }));\nnew Model({ test: 3.14 }).test; // 3\n```\n\n### SchemaNumber.get()\n\n##### Parameters:\n\n- `caster` «Function»\n\n##### Returns:\n\n- «Function»\n\n##### Type:\n\n- «property»\n\nGet/set the function used to cast arbitrary values to numbers.\n\n#### [Example:](#example)\n\n``` javascript\n// Make Mongoose cast empty strings '' to 0 for paths declared as numbers\nconst original = mongoose.Number.cast();\nmongoose.Number.cast(v => {\n  if (v === '') { return 0; }\n  return original(v);\n});\n\n// Or disable casting entirely\nmongoose.Number.cast(false);\n```\n\n### SchemaNumber.prototype.checkRequired()\n\n##### Parameters:\n\n- `value` «Any»\n- `doc` «Document»\n\n##### Returns:\n\n- «Boolean»\n\nCheck if the given value satisfies a required validator.\n\n### SchemaNumber.prototype.enum()\n\n##### Parameters:\n\n- `values` «Array» allowed values\n- `[message]` «String» optional custom error message\n\n##### Returns:\n\n- «SchemaType» this\n\n##### See:\n\n- [Customized Error Messages](error#Error.messages)\n\nSets a enum validator\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ n: { type: Number, enum: [1, 2, 3] });\nconst M = db.model('M', s);\n\nconst m = new M({ n: 4 });\nawait m.save(); // throws validation error\n\nm.n = 3;\nawait m.save(); // succeeds\n```\n\n### SchemaNumber.prototype.max()\n\n##### Parameters:\n\n- `maximum` «Number» number\n- `[message]` «String» optional custom error message\n\n##### Returns:\n\n- «SchemaType» this\n\n##### See:\n\n- [Customized Error Messages](error#Error.messages)\n\nSets a maximum number validator.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ n: { type: Number, max: 10 })\nconst M = db.model('M', s)\nconst m = new M({ n: 11 })\nm.save(function (err) {\n  console.error(err) // validator error\n  m.n = 10;\n  m.save() // success\n})\n\n// custom error messages\n// We can also use the special {MAX} token which will be replaced with the invalid value\nconst max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\nconst schema = new Schema({ n: { type: Number, max: max })\nconst M = mongoose.model('Measurement', schema);\nconst s= new M({ n: 4 });\ns.validate(function (err) {\n  console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n})\n```\n\n### SchemaNumber.prototype.min()\n\n##### Parameters:\n\n- `value` «Number» minimum number\n- `[message]` «String» optional custom error message\n\n##### Returns:\n\n- «SchemaType» this\n\n##### See:\n\n- [Customized Error Messages](error#Error.messages)\n\nSets a minimum number validator.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ n: { type: Number, min: 10 })\nconst M = db.model('M', s)\nconst m = new M({ n: 9 })\nm.save(function (err) {\n  console.error(err) // validator error\n  m.n = 10;\n  m.save() // success\n})\n\n// custom error messages\n// We can also use the special {MIN} token which will be replaced with the invalid value\nconst min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\nconst schema = new Schema({ n: { type: Number, min: min })\nconst M = mongoose.model('Measurement', schema);\nconst s= new M({ n: 4 });\ns.validate(function (err) {\n  console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n})\n```\n\n### SchemaNumber.schemaName\n\n##### Type:\n\n- «property»\n\nThis schema type's name, to defend against minifiers that mangle function names.\n\n### SchemaNumber.set()\n\n##### Parameters:\n\n- `option` «String» The option you'd like to set the value for\n- `value` «Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all Number instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all numbers have option `min` equal to 0.\nmongoose.Schema.Number.set('min', 0);\n\nconst Order = mongoose.model('Order', new Schema({ amount: Number }));\nnew Order({ amount: -10 }).validateSync().errors.amount.message; // Path `amount` must be larger than 0.\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemanumber.html](https://mongoosejs.com/docs/api/schemanumber.html)"
- name: SchemaNumber()
  id: api/schemanumber#SchemaNumber()
  summary: Number SchemaType constructor
  belongs_to: SchemaNumber
  description: |-
    ### SchemaNumber()

    ##### Parameters:

    - `key` «String»
    - `options` «Object»

    ##### Inherits:

    -  [«SchemaType»](schematype)

    Number SchemaType constructor.
- name: SchemaNumber.checkRequired()
  id: api/schemanumber#SchemaNumber.checkRequired()
  summary: Override the function the required validator uses to check whether a string passes the required check
  belongs_to: SchemaNumber
  description: |-
    ### SchemaNumber.checkRequired()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «Function»

    ##### Type:

    - «property»

    Override the function the required validator uses to check whether a string passes the `required` check.
- name: SchemaNumber.get()
  id: api/schemanumber#SchemaNumber.get()
  summary: Attaches a getter for all Number instances
  belongs_to: SchemaNumber
  description: |-
    ### SchemaNumber.get()

    ##### Parameters:

    - `getter` «Function»

    ##### Returns:

    - «this»

    ##### Type:

    - «property»

    Attaches a getter for all Number instances.

    #### [Example:](#example)

    ``` javascript
    // Make all numbers round down
    mongoose.Number.get(function(v) { return Math.floor(v); });

    const Model = mongoose.model('Test', new Schema({ test: Number }));
    new Model({ test: 3.14 }).test; // 3
    ```

    ### SchemaNumber.get()

    ##### Parameters:

    - `caster` «Function»

    ##### Returns:

    - «Function»

    ##### Type:

    - «property»

    Get/set the function used to cast arbitrary values to numbers.

    #### [Example:](#example)

    ``` javascript
    // Make Mongoose cast empty strings '' to 0 for paths declared as numbersconst original = mongoose.Number.cast();
    mongoose.Number.cast(v => {
      if (v === '') { return 0; }
      return original(v);
    });

    // Or disable casting entirely
    mongoose.Number.cast(false);
    ```
- name: SchemaNumber.prototype.checkRequired()
  id: api/schemanumber#SchemaNumber.prototype.checkRequired()
  summary: Check if the given value satisfies a required validator
  belongs_to: SchemaNumber
  description: |-
    ### SchemaNumber.prototype.checkRequired()

    ##### Parameters:

    - `value` «Any»
    - `doc` «Document»

    ##### Returns:

    - «Boolean»

    Check if the given value satisfies a required validator.
- name: SchemaNumber.prototype.enum()
  id: api/schemanumber#SchemaNumber.prototype.enum()
  summary: null
  belongs_to: SchemaNumber
  description: |-
    ### SchemaNumber.prototype.enum()

    ##### Parameters:

    - `values`«Array» allowed values
    - `[message]`«String» optional custom error message

    ##### Returns:

    - «SchemaType» this

    ##### See:

    -  [Customized Error Messages](error#Error.messages)

    Sets a enum validator

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ n: { type: Number, enum: [1, 2, 3] });
    const M = db.model('M', s);

    const m = new M({ n: 4 });
    await m.save(); // throws validation error

    m.n = 3;
    await m.save(); // succeeds
    ```
- name: SchemaNumber.prototype.max()
  id: api/schemanumber#SchemaNumber.prototype.max()
  summary: Sets a maximum number validator
  belongs_to: SchemaNumber
  description: |-
    ### SchemaNumber.prototype.max()

    ##### Parameters:

    - `maximum`«Number» number
    - `[message]`«String» optional custom error message

    ##### Returns:

    - «SchemaType» this

    ##### See:

    -  [Customized Error Messages](error#Error.messages)

    Sets a maximum number validator.

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ n: { type: Number, max: 10 })
    const M = db.model('M', s)
    const m = new M({ n: 11 })
    m.save(function (err) {
      console.error(err) // validator error
      m.n = 10;
      m.save() // success
    })

    // custom error messages
    // We can also use the special {MAX} token which will be replaced with the invalid value
    const max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];
    const schema = new Schema({ n: { type: Number, max: max })
    const M = mongoose.model('Measurement', schema);
    const s= new M({ n: 4 });
    s.validate(function (err) {
      console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).
    })
    ```
- name: SchemaNumber.prototype.min()
  id: api/schemanumber#SchemaNumber.prototype.min()
  summary: Sets a minimum number validator
  belongs_to: SchemaNumber
  description: |-
    ### SchemaNumber.prototype.min()

    ##### Parameters:

    - `value`«Number» minimum number
    - `[message]`«String» optional custom error message

    ##### Returns:

    - «SchemaType» this

    ##### See:

    -  [Customized Error Messages](error#Error.messages)

    Sets a minimum number validator.

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ n: { type: Number, min: 10 })
    const M = db.model('M', s)
    const m = new M({ n: 9 })
    m.save(function (err) {
      console.error(err) // validator error
      m.n = 10;
      m.save() // success
    })

    // custom error messages
    // We can also use the special {MIN} token which will be replaced with the invalid value
    const min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];
    const schema = new Schema({ n: { type: Number, min: min })
    const M = mongoose.model('Measurement', schema);
    const s= new M({ n: 4 });
    s.validate(function (err) {
      console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).
    })
    ```
- name: SchemaNumber.schemaName
  id: api/schemanumber#SchemaNumber.schemaName
  summary: This schema type's name, to defend against minifiers that mangle function names
  belongs_to: SchemaNumber
  description: |-
    ### SchemaNumber.schemaName

    ##### Type:

    - «property»

    This schema type's name, to defend against minifiers that mangle function names.
- name: SchemaNumber.set()
  id: api/schemanumber#SchemaNumber.set()
  summary: Sets a default option for all Number instances
  belongs_to: SchemaNumber
  description: "### SchemaNumber.set()\n\n##### Parameters:\n\n- `option`«String» The option you'd like to set the value for\n- `value`«Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all Number instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all numbers have option `min` equal to 0.\nmongoose.Schema.Number.set('min', 0);\n\nconst Order = mongoose.model('Order', new Schema({ amount: Number }));\nnew Order({ amount: -10 }).validateSync().errors.amount.message; // Path `amount` must be larger than 0.\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemanumber.html](https://mongoosejs.com/docs/api/schemanumber.html)"
- name: SchemaObjectid
  id: api/schemaobjectid
  summary: ObjectId SchemaType constructor
  description: "# SchemaObjectid\n\n### ObjectId()\n\n##### Parameters:\n\n- `key` «String»\n- `options` «Object»\n\n##### Inherits:\n\n- [«SchemaType»](schematype)\n\nObjectId SchemaType constructor.\n\n### ObjectId.checkRequired()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «Function»\n\n##### Type:\n\n- «property»\n\nOverride the function the required validator uses to check whether a string passes the `required` check.\n\n#### [Example:](#example)\n\n``` javascript\n// Allow empty strings to pass `required` check\nmongoose.Schema.Types.String.checkRequired(v => v != null);\n\nconst M = mongoose.model({ str: { type: String, required: true } });\nnew M({ str: '' }).validateSync(); // `null`, validation passes!\n```\n\n### ObjectId.get()\n\n##### Parameters:\n\n- `getter` «Function»\n\n##### Returns:\n\n- «this»\n\n##### Type:\n\n- «property»\n\nAttaches a getter for all ObjectId instances\n\n#### [Example:](#example)\n\n``` javascript\n// Always convert to string when getting an ObjectId\nmongoose.ObjectId.get(v => v.toString());\n\nconst Model = mongoose.model('Test', new Schema({}));\ntypeof (new Model({})._id); // 'string'\n```\n\n### ObjectId.get()\n\n##### Parameters:\n\n- `caster` «Function»\n\n##### Returns:\n\n- «Function»\n\n##### Type:\n\n- «property»\n\nGet/set the function used to cast arbitrary values to objectids.\n\n#### [Example:](#example)\n\n``` javascript\n// Make Mongoose only try to cast length 24 strings. By default, any 12\n// char string is a valid ObjectId.\nconst original = mongoose.ObjectId.cast();\nmongoose.ObjectId.cast(v => {\n  assert.ok(typeof v !== 'string' || v.length === 24);\n  return original(v);\n});\n\n// Or disable casting entirely\nmongoose.ObjectId.cast(false);\n```\n\n### ObjectId.prototype.auto()\n\n##### Parameters:\n\n- `turnOn` «Boolean» auto generated ObjectId defaults\n\n##### Returns:\n\n- «SchemaType» this\n\nAdds an auto-generated ObjectId default if turnOn is true.\n\n### ObjectId.prototype.checkRequired()\n\n##### Parameters:\n\n- `value` «Any»\n- `doc` «Document»\n\n##### Returns:\n\n- «Boolean»\n\nCheck if the given value satisfies a required validator.\n\n### ObjectId.schemaName\n\n##### Type:\n\n- «property»\n\nThis schema type's name, to defend against minifiers that mangle function names.\n\n### ObjectId.set()\n\n##### Parameters:\n\n- `option` «String» The option you'd like to set the value for\n- `value` «Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all ObjectId instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all object ids have option `required` equal to true.\nmongoose.Schema.ObjectId.set('required', true);\n\nconst Order = mongoose.model('Order', new Schema({ userId: ObjectId }));\nnew Order({ }).validateSync().errors.userId.message; // Path `userId` is required.\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemaobjectid.html](https://mongoosejs.com/docs/api/schemaobjectid.html)"
- name: Schemas
  id: guide
  summary: If you haven't yet done so, please take a minute to read the quickstart to get an idea of how Mongoose works
  description: "# Schemas\n\nIf you haven't yet done so, please take a minute to read the [quickstart](index) to get an idea of how Mongoose works. If you are migrating from 6.x to 7.x please take a moment to read the [migration guide](migrating_to_7).\n\n## Defining your schema\n\nEverything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.\n\n``` javascript\nimport mongoose from 'mongoose';\nconst { Schema } = mongoose;\n\nconst blogSchema = new Schema({\n  title: String, // String is shorthand for {type: String}\n  author: String,\n  body: String,\n  comments: [{ body: String, date: Date }],\n  date: { type: Date, default: Date.now },\n  hidden: Boolean,\n  meta: {\n    votes: Number,\n    favs: Number\n  }\n});\n```\n\nIf you want to add additional keys later, use the [Schema#add](api/schema#schema_Schema-add) method.\n\nEach key in our code `blogSchema` defines a property in our documents which will be cast to its associated [SchemaType](api/schematype#schematype_SchemaType). For example, we've defined a property `title` which will be cast to the [String](schematypes#strings) SchemaType and property `date` which will be cast to a `Date` SchemaType.\n\nNotice above that if a property only requires a type, it can be specified using a shorthand notation (contrast the `title` property above with the `date` property).\n\nKeys may also be assigned nested objects containing further key/type definitions like the `meta` property above. This will happen whenever a key's value is a POJO that doesn't have a `type` property.\n\nIn these cases, Mongoose only creates actual schema paths for leaves in the tree. (like `meta.votes` and `meta.favs` above), and the branches do not have actual paths. A side-effect of this is that `meta` above cannot have its own validation. If validation is needed up the tree, a path needs to be created up the tree - see the [Subdocuments](subdocs) section for more information on how to do this. Also read the [Mixed](schematypes) subsection of the SchemaTypes guide for some gotchas.\n\nThe permitted SchemaTypes are:\n\n- [String](schematypes#strings)\n- [Number](schematypes#numbers)\n- [Date](schematypes#dates)\n- [Buffer](schematypes#buffers)\n- [Boolean](schematypes#booleans)\n- [Mixed](schematypes#mixed)\n- [ObjectId](schematypes#objectids)\n- [Array](schematypes#arrays)\n- [Decimal128](api/mongoose#mongoose_Mongoose-Decimal128)\n- [Map](schematypes#maps)\n- [UUID](schematypes#uuid)\n\nRead more about [SchemaTypes here](schematypes).\n\nSchemas not only define the structure of your document and casting of properties, they also define document [instance methods](#methods), [static Model methods](#statics), [compound indexes](#indexes), and document lifecycle hooks called [middleware](middleware).\n\n## Creating a model\n\nTo use our schema definition, we need to convert our `blogSchema` into a [Model](models) we can work with. To do so, we pass it into `mongoose.model(modelName, schema)`:\n\n``` javascript\nconst Blog = mongoose.model('Blog', blogSchema);\n// ready to go!\n```\n\n## Ids\n\nBy default, Mongoose adds an `_id` property to your schemas.\n\n``` javascript\nconst schema = new Schema();\n\nschema.path('_id'); // ObjectId { ... }\n```\n\nWhen you create a new document with the automatically added `_id` property, Mongoose creates a new [`_id` of type ObjectId](https://masteringjs.io/tutorials/mongoose/objectid) to your document.\n\n``` javascript\nconst Model = mongoose.model('Test', schema);\n\nconst doc = new Model();\ndoc._id instanceof mongoose.Types.ObjectId; // true\n```\n\nYou can also overwrite Mongoose's default `_id` with your own `_id`. Just be careful: Mongoose will refuse to save a document that doesn't have an `_id`, so you're responsible for setting `_id` if you define your own `_id` path.\n\n``` javascript\nconst schema = new Schema({ _id: Number });\nconst Model = mongoose.model('Test', schema);\n\nconst doc = new Model();\nawait doc.save(); // Throws \"document must have an _id before saving\"\n\ndoc._id = 1;\nawait doc.save(); // works\n```\n\n## Instance methods\n\nInstances of `Models` are [documents](documents). Documents have many of their own [built-in instance methods](api/document). We may also define our own custom document instance methods.\n\n``` javascript\n// define a schema\nconst animalSchema = new Schema({ name: String, type: String },\n  {\n  // Assign a function to the \"methods\" object of our animalSchema through schema options.\n  // By following this approach, there is no need to create a separate TS type to define the type of the instance functions.\n    methods: {\n      findSimilarTypes(cb) {\n        return mongoose.model('Animal').find({ type: this.type }, cb);\n      }\n    }\n  });\n\n// Or, assign a function to the \"methods\" object of our animalSchema\nanimalSchema.methods.findSimilarTypes = function(cb) {\n  return mongoose.model('Animal').find({ type: this.type }, cb);\n};\n```\n\nNow all of our `animal` instances have a `findSimilarTypes` method available to them.\n\n``` javascript\nconst Animal = mongoose.model('Animal', animalSchema);\nconst dog = new Animal({ type: 'dog' });\n\ndog.findSimilarTypes((err, dogs) => {\n  console.log(dogs); // woof\n});\n```\n\n- Overwriting a default mongoose document method may lead to unpredictable results. See [this](api/schema#schema_Schema-reserved) for more details.\n- The example above uses the `Schema.methods` object directly to save an instance method. You can also use the `Schema.method()` helper as described [here](api/schema#schema_Schema-method).\n- Do **not** declare methods using ES6 arrow functions (`=>`). Arrow functions [explicitly prevent binding `this`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this), so your method will **not** have access to the document and the above examples will not work.\n\n## Statics\n\nYou can also add static functions to your model. There are three equivalent ways to add a static:\n\n- Add a function property to the second argument of the schema-constructor (`statics`)\n- Add a function property to `schema.statics`\n- Call the [`Schema#static()` function](api/schema#schema_Schema-static)\n\n``` javascript\n// define a schema\nconst animalSchema = new Schema({ name: String, type: String },\n  {\n  // Assign a function to the \"statics\" object of our animalSchema through schema options.\n  // By following this approach, there is no need to create a separate TS type to define the type of the statics functions.\n    statics: {\n      findByName(name) {\n        return this.find({ name: new RegExp(name, 'i') });\n      }\n    }\n  });\n\n// Or, Assign a function to the \"statics\" object of our animalSchema\nanimalSchema.statics.findByName = function(name) {\n  return this.find({ name: new RegExp(name, 'i') });\n};\n// Or, equivalently, you can call `animalSchema.static()`.\nanimalSchema.static('findByBreed', function(breed) { return this.find({ breed }); });\n\nconst Animal = mongoose.model('Animal', animalSchema);\nlet animals = await Animal.findByName('fido');\nanimals = animals.concat(await Animal.findByBreed('Poodle'));\n```\n\nDo **not** declare statics using ES6 arrow functions (`=>`). Arrow functions [explicitly prevent binding `this`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this), so the above examples will not work because of the value of `this`.\n\n## Query Helpers\n\nYou can also add query helper functions, which are like instance methods but for mongoose queries. Query helper methods let you extend mongoose's [chainable query builder API](queries).\n\n``` javascript\n// define a schema\nconst animalSchema = new Schema({ name: String, type: String },\n  {\n  // Assign a function to the \"query\" object of our animalSchema through schema options.\n  // By following this approach, there is no need to create a separate TS type to define the type of the query functions.\n    query: {\n      byName(name) {\n        return this.where({ name: new RegExp(name, 'i') });\n      }\n    }\n  });\n\n// Or, Assign a function to the \"query\" object of our animalSchema\nanimalSchema.query.byName = function(name) {\n  return this.where({ name: new RegExp(name, 'i') });\n};\n\nconst Animal = mongoose.model('Animal', animalSchema);\n\nAnimal.find().byName('fido').exec((err, animals) => {\n  console.log(animals);\n});\n\nAnimal.findOne().byName('fido').exec((err, animal) => {\n  console.log(animal);\n});\n```\n\n## Indexes\n\nMongoDB supports [secondary indexes](http://www.mongodb.com/docs/manual/indexes/). With mongoose, we define these indexes within our `Schema` [at](api/schematype#schematype_SchemaType-index) [the](api/schematype#schematype_SchemaType-unique) [path](api/schematype#schematype_SchemaType-sparse) [level](api/schemadateoptions#schemadateoptions_SchemaDateOptions-expires) or the `schema` level. Defining indexes at the schema level is necessary when creating [compound indexes](https://www.mongodb.com/docs/manual/core/index-compound/).\n\n``` javascript\nconst animalSchema = new Schema({\n  name: String,\n  type: String,\n  tags: { type: [String], index: true } // path level\n});\n\nanimalSchema.index({ name: 1, type: -1 }); // schema level\n```\n\nSee [SchemaType#index()](api/schematype#schematype_SchemaType-index) for other index options.\n\nWhen your application starts up, Mongoose automatically calls [`createIndex`](https://www.mongodb.com/docs/manual/reference/method/db.collection.createIndex/#db.collection.createIndex) for each defined index in your schema. Mongoose will call `createIndex` for each index sequentially, and emit an 'index' event on the model when all the `createIndex` calls succeeded or when there was an error. While nice for development, it is recommended this behavior be disabled in production since index creation can cause a [significant performance impact](https://www.mongodb.com/docs/manual/core/index-creation/#index-build-impact-on-database-performance). Disable the behavior by setting the `autoIndex` option of your schema to `false`, or globally on the connection by setting the option `autoIndex` to `false`.\n\n``` javascript\nmongoose.connect('mongodb://user:pass@127.0.0.1:port/database', { autoIndex: false });\n// or\nmongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database', { autoIndex: false });\n// or\nmongoose.set('autoIndex', false);\n// or\nanimalSchema.set('autoIndex', false);\n// or\nnew Schema({ /* ... */ }, { autoIndex: false });\n```\n\nMongoose will emit an `index` event on the model when indexes are done building or an error occurred.\n\n``` javascript\n// Will cause an error because mongodb has an _id index by default that\n// is not sparse\nanimalSchema.index({ _id: 1 }, { sparse: true });\nconst Animal = mongoose.model('Animal', animalSchema);\n\nAnimal.on('index', error => {\n  // \"_id index cannot be sparse\"\n  console.log(error.message);\n});\n```\n\nSee also the [Model#ensureIndexes](api/model#model_Model-ensureIndexes) method.\n\n## Virtuals\n\n[Virtuals](api/schema#schema_Schema-virtual) are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage.\n\n``` javascript\n// define a schema\nconst personSchema = new Schema({\n  name: {\n    first: String,\n    last: String\n  }\n});\n\n// compile our model\nconst Person = mongoose.model('Person', personSchema);\n\n// create a document\nconst axl = new Person({\n  name: { first: 'Axl', last: 'Rose' }\n});\n```\n\nSuppose you want to print out the person's full name. You could do it yourself:\n\n``` javascript\nconsole.log(axl.name.first + ' ' + axl.name.last); // Axl Rose\n```\n\nBut [concatenating](https://masteringjs.io/tutorials/fundamentals/string-concat) the first and last name every time can get cumbersome. And what if you want to do some extra processing on the name, like [removing diacritics](https://www.npmjs.com/package/diacritics)? A [virtual property getter](api/virtualtype#virtualtype_VirtualType-get) lets you define a `fullName` property that won't get persisted to MongoDB.\n\n``` javascript\n// That can be done either by adding it to schema options:\nconst personSchema = new Schema({\n  name: {\n    first: String,\n    last: String\n  }\n}, {\n  virtuals: {\n    fullName: {\n      get() {\n        return this.name.first + ' ' + this.name.last;\n      }\n    }\n  }\n});\n\n// Or by using the virtual method as following:\npersonSchema.virtual('fullName').get(function() {\n  return this.name.first + ' ' + this.name.last;\n});\n```\n\nNow, mongoose will call your getter function every time you access the `fullName` property:\n\n``` javascript\nconsole.log(axl.fullName); // Axl Rose\n```\n\nIf you use `toJSON()` or `toObject()` Mongoose will *not* include virtuals by default. Pass `{ virtuals: true }` to [`toJSON()`](api/document#document_Document-toJSON) or `toObject()` to include virtuals.\n\n``` javascript\n// Convert `doc` to a POJO, with virtuals attached\ndoc.toObject({ virtuals: true });\n\n// Equivalent:\ndoc.toJSON({ virtuals: true });\n```\n\nThe above caveat for `toJSON()` also includes the output of calling [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) on a Mongoose document, because [`JSON.stringify()` calls `toJSON()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description). To include virtuals in `JSON.stringify()` output, you can either call `toObject({ virtuals: true })` on the document before calling `JSON.stringify()`, or set the `toJSON: { virtuals: true }` option on your schema.\n\n``` javascript\n// Explicitly add virtuals to `JSON.stringify()` output\nJSON.stringify(doc.toObject({ virtuals: true }));\n\n// Or, to automatically attach virtuals to `JSON.stringify()` output:\nconst personSchema = new Schema({\n  name: {\n    first: String,\n    last: String\n  }\n}, {\n  toJSON: { virtuals: true } // <-- include virtuals in `JSON.stringify()`\n});\n```\n\nYou can also add a custom setter to your virtual that will let you set both first name and last name via the `fullName` virtual.\n\n``` javascript\n// Again that can be done either by adding it to schema options:\nconst personSchema = new Schema({\n  name: {\n    first: String,\n    last: String\n  }\n}, {\n  virtuals: {\n    fullName: {\n      get() {\n        return this.name.first + ' ' + this.name.last;\n      },\n      set(v) {\n        this.name.first = v.substr(0, v.indexOf(' '));\n        this.name.last = v.substr(v.indexOf(' ') + 1);\n      }\n    }\n  }\n});\n\n// Or by using the virtual method as following:\npersonSchema.virtual('fullName').\n  get(function() {\n    return this.name.first + ' ' + this.name.last;\n  }).\n  set(function(v) {\n    this.name.first = v.substr(0, v.indexOf(' '));\n    this.name.last = v.substr(v.indexOf(' ') + 1);\n  });\n\naxl.fullName = 'William Rose'; // Now `axl.name.first` is \"William\"\n```\n\nVirtual property setters are applied before other validation. So the example above would still work even if the `first` and `last` name fields were required.\n\nOnly non-virtual properties work as part of queries and for field selection. Since virtuals are not stored in MongoDB, you can't query with them.\n\nYou can [learn more about virtuals here](https://masteringjs.io/tutorials/mongoose/virtuals).\n\n## Aliases\n\nAliases are a particular type of virtual where the getter and setter seamlessly get and set another property. This is handy for saving network bandwidth, so you can convert a short property name stored in the database into a longer name for code readability.\n\n``` javascript\nconst personSchema = new Schema({\n  n: {\n    type: String,\n    // Now accessing `name` will get you the value of `n`, and setting `name` will set the value of `n`\n    alias: 'name'\n  }\n});\n\n// Setting `name` will propagate to `n`\nconst person = new Person({ name: 'Val' });\nconsole.log(person); // { n: 'Val' }\nconsole.log(person.toObject({ virtuals: true })); // { n: 'Val', name: 'Val' }\nconsole.log(person.name); // \"Val\"\n\nperson.name = 'Not Val';\nconsole.log(person); // { n: 'Not Val' }\n```\n\nYou can also declare aliases on nested paths. It is easier to use nested schemas and [subdocuments](subdocs), but you can also declare nested path aliases inline as long as you use the full nested path `nested.myProp` as the alias.\n\n``` javascript\nconst childSchema = new Schema({\n  n: {\n    type: String,\n    alias: 'name'\n  }\n}, { _id: false });\n\nconst parentSchema = new Schema({\n  // If in a child schema, alias doesn't need to include the full nested path\n  c: childSchema,\n  name: {\n    f: {\n      type: String,\n      // Alias needs to include the full nested path if declared inline\n      alias: 'name.first'\n    }\n  }\n});\n```\n\n## Options\n\nSchemas have a few configurable options which can be passed to the constructor or to the `set` method:\n\n``` javascript\nnew Schema({ /* ... */ }, options);\n\n// or\n\nconst schema = new Schema({ /* ... */ });\nschema.set(option, value);\n```\n\nValid options:\n\n- [autoIndex](#autoIndex)\n- [autoCreate](#autoCreate)\n- [bufferCommands](#bufferCommands)\n- [bufferTimeoutMS](#bufferTimeoutMS)\n- [capped](#capped)\n- [collection](#collection)\n- [discriminatorKey](#discriminatorKey)\n- [excludeIndexes](#excludeIndexes)\n- [id](#id)\n- [\\_id](#_id)\n- [minimize](#minimize)\n- [read](#read)\n- [writeConcern](#writeConcern)\n- [shardKey](#shardKey)\n- [statics](#statics)\n- [strict](#strict)\n- [strictQuery](#strictQuery)\n- [toJSON](#toJSON)\n- [toObject](#toObject)\n- [typeKey](#typeKey)\n- [validateBeforeSave](#validateBeforeSave)\n- [versionKey](#versionKey)\n- [optimisticConcurrency](#optimisticConcurrency)\n- [collation](#collation)\n- [timeseries](#timeseries)\n- [selectPopulatedPaths](#selectPopulatedPaths)\n- [skipVersioning](#skipVersioning)\n- [timestamps](#timestamps)\n- [storeSubdocValidationError](#storeSubdocValidationError)\n- [collectionOptions](#collectionOptions)\n- [methods](#methods)\n- [query](#query-helpers)\n\n## option: autoIndex\n\nBy default, Mongoose's [`init()` function](api/model#model_Model-init) creates all the indexes defined in your model's schema by calling [`Model.createIndexes()`](api/model#model_Model-createIndexes) after you successfully connect to MongoDB. Creating indexes automatically is great for development and test environments. But index builds can also create significant load on your production database. If you want to manage indexes carefully in production, you can set `autoIndex` to false.\n\n``` javascript\nconst schema = new Schema({ /* ... */ }, { autoIndex: false });\nconst Clock = mongoose.model('Clock', schema);\nClock.ensureIndexes(callback);\n```\n\nThe `autoIndex` option is set to `true` by default. You can change this default by setting [`mongoose.set('autoIndex', false);`](api/mongoose#mongoose_Mongoose-set)\n\n## option: autoCreate\n\nBefore Mongoose builds indexes, it calls `Model.createCollection()` to create the underlying collection in MongoDB by default. Calling `createCollection()` sets the [collection's default collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) based on the [collation option](#collation) and establishes the collection as a capped collection if you set the [`capped` schema option](#capped).\n\nYou can disable this behavior by setting `autoCreate` to `false` using [`mongoose.set('autoCreate', false)`](api/mongoose#mongoose_Mongoose-set). Like `autoIndex`, `autoCreate` is helpful for development and test environments, but you may want to disable it for production to avoid unnecessary database calls.\n\nUnfortunately, `createCollection()` cannot change an existing collection. For example, if you add `capped: { size: 1024 }` to your schema and the existing collection is not capped, `createCollection()` will **not** overwrite the existing collection. That is because the MongoDB server does not allow changing a collection's options without dropping the collection first.\n\n``` javascript\nconst schema = new Schema({ name: String }, {\n  autoCreate: false,\n  capped: { size: 1024 }\n});\nconst Test = mongoose.model('Test', schema);\n\n// No-op if collection already exists, even if the collection is not capped.\n// This means that `capped` won't be applied if the 'tests' collection already exists.\nawait Test.createCollection();\n```\n\n## option: bufferCommands\n\nBy default, mongoose buffers commands when the connection goes down until the driver manages to reconnect. To disable buffering, set `bufferCommands` to false.\n\n``` javascript\nconst schema = new Schema({ /* ... */ }, { bufferCommands: false });\n```\n\nThe schema `bufferCommands` option overrides the global `bufferCommands` option.\n\n``` javascript\nmongoose.set('bufferCommands', true);\n// Schema option below overrides the above, if the schema option is set.\nconst schema = new Schema({ /* ... */ }, { bufferCommands: false });\n```\n\n## option: bufferTimeoutMS\n\nIf `bufferCommands` is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).\n\n``` javascript\n// If an operation is buffered for more than 1 second, throw an error.\nconst schema = new Schema({ /* ... */ }, { bufferTimeoutMS: 1000 });\n```\n\n## option: capped\n\nMongoose supports MongoDBs [capped](https://www.mongodb.com/docs/manual/core/capped-collections/) collections. To specify the underlying MongoDB collection be `capped`, set the `capped` option to the maximum size of the collection in [bytes](https://www.mongodb.com/docs/manual/core/capped-collections/#create-a-capped-collection).\n\n``` javascript\nnew Schema({ /* ... */ }, { capped: 1024 });\n```\n\nThe `capped` option may also be set to an object if you want to pass additional options like [max](https://www.mongodb.com/docs/manual/core/capped-collections/#change-the-maximum-number-of-documents-in-a-capped-collection). In this case you must explicitly pass the `size` option, which is required.\n\n``` javascript\nnew Schema({ /* ... */ }, { capped: { size: 1024, max: 1000, autoIndexId: true } });\n```\n\n## option: collection\n\nMongoose by default produces a collection name by passing the model name to the `utils.toCollectionName` method. This method pluralizes the name. Set this option if you need a different name for your collection.\n\n``` javascript\nconst dataSchema = new Schema({ /* ... */ }, { collection: 'data' });\n```\n\n## option: discriminatorKey\n\nWhen you define a [discriminator](discriminators), Mongoose adds a path to your schema that stores which discriminator a document is an instance of. By default, Mongoose adds an `__t` path, but you can set `discriminatorKey` to overwrite this default.\n\n``` javascript\nconst baseSchema = new Schema({}, { discriminatorKey: 'type' });\nconst BaseModel = mongoose.model('Test', baseSchema);\n\nconst personSchema = new Schema({ name: String });\nconst PersonModel = BaseModel.discriminator('Person', personSchema);\n\nconst doc = new PersonModel({ name: 'James T. Kirk' });\n// Without `discriminatorKey`, Mongoose would store the discriminator\n// key in `__t` instead of `type`\ndoc.type; // 'Person'\n```\n\n## option: excludeIndexes\n\nWhen `excludeIndexes` is `true`, Mongoose will not create indexes from the given subdocument schema. This option only works when the schema is used in a subdocument path or document array path, Mongoose ignores this option if set on the top-level schema for a model. Defaults to `false`.\n\n``` javascript\nconst childSchema1 = Schema({\n  name: { type: String, index: true }\n});\n\nconst childSchema2 = Schema({\n  name: { type: String, index: true }\n}, { excludeIndexes: true });\n\n// Mongoose will create an index on `child1.name`, but **not** `child2.name`, because `excludeIndexes`\n// is true on `childSchema2`\nconst User = new Schema({\n  name: { type: String, index: true },\n  child1: childSchema1,\n  child2: childSchema2\n});\n```\n\n## option: id\n\nMongoose assigns each of your schemas an `id` virtual getter by default which returns the document's `_id` field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an `id` getter added to your schema, you may disable it by passing this option at schema construction time.\n\n``` javascript\n// default behavior\nconst schema = new Schema({ name: String });\nconst Page = mongoose.model('Page', schema);\nconst p = new Page({ name: 'mongodb.org' });\nconsole.log(p.id); // '50341373e894ad16347efe01'\n\n// disabled id\nconst schema = new Schema({ name: String }, { id: false });\nconst Page = mongoose.model('Page', schema);\nconst p = new Page({ name: 'mongodb.org' });\nconsole.log(p.id); // undefined\n```\n\n## option: \\_id\n\nMongoose assigns each of your schemas an `_id` field by default if one is not passed into the [Schema](api/schema#schema_Schema) constructor. The type assigned is an [ObjectId](api/schema#schema_Schema-Types) to coincide with MongoDB's default behavior. If you don't want an `_id` added to your schema at all, you may disable it using this option.\n\nYou can **only** use this option on subdocuments. Mongoose can't save a document without knowing its id, so you will get an error if you try to save a document without an `_id`.\n\n``` javascript\n// default behavior\nconst schema = new Schema({ name: String });\nconst Page = mongoose.model('Page', schema);\nconst p = new Page({ name: 'mongodb.org' });\nconsole.log(p); // { _id: '50341373e894ad16347efe01', name: 'mongodb.org' }\n\n// disabled _id\nconst childSchema = new Schema({ name: String }, { _id: false });\nconst parentSchema = new Schema({ children: [childSchema] });\n\nconst Model = mongoose.model('Model', parentSchema);\n\nModel.create({ children: [{ name: 'Luke' }] }, (error, doc) => {\n  // doc.children[0]._id will be undefined\n});\n```\n\n## option: minimize\n\nMongoose will, by default, \"minimize\" schemas by removing empty objects.\n\n``` javascript\nconst schema = new Schema({ name: String, inventory: {} });\nconst Character = mongoose.model('Character', schema);\n\n// will store `inventory` field if it is not empty\nconst frodo = new Character({ name: 'Frodo', inventory: { ringOfPower: 1 } });\nawait frodo.save();\nlet doc = await Character.findOne({ name: 'Frodo' }).lean();\ndoc.inventory; // { ringOfPower: 1 }\n\n// will not store `inventory` field if it is empty\nconst sam = new Character({ name: 'Sam', inventory: {} });\nawait sam.save();\ndoc = await Character.findOne({ name: 'Sam' }).lean();\ndoc.inventory; // undefined\n```\n\nThis behavior can be overridden by setting `minimize` option to `false`. It will then store empty objects.\n\n``` javascript\nconst schema = new Schema({ name: String, inventory: {} }, { minimize: false });\nconst Character = mongoose.model('Character', schema);\n\n// will store `inventory` if empty\nconst sam = new Character({ name: 'Sam', inventory: {} });\nawait sam.save();\ndoc = await Character.findOne({ name: 'Sam' }).lean();\ndoc.inventory; // {}\n```\n\nTo check whether an object is empty, you can use the `$isEmpty()` helper:\n\n``` javascript\nconst sam = new Character({ name: 'Sam', inventory: {} });\nsam.$isEmpty('inventory'); // true\n\nsam.inventory.barrowBlade = 1;\nsam.$isEmpty('inventory'); // false\n```\n\n## option: read\n\nAllows setting [query#read](api/query#query_Query-read) options at the schema level, providing us a way to apply default [ReadPreferences](http://www.mongodb.com/docs/manual/applications/replication/#replica-set-read-preference) to all queries derived from a model.\n\n``` javascript\nconst schema = new Schema({ /* ... */ }, { read: 'primary' });            // also aliased as 'p'\nconst schema = new Schema({ /* ... */ }, { read: 'primaryPreferred' });   // aliased as 'pp'\nconst schema = new Schema({ /* ... */ }, { read: 'secondary' });          // aliased as 's'\nconst schema = new Schema({ /* ... */ }, { read: 'secondaryPreferred' }); // aliased as 'sp'\nconst schema = new Schema({ /* ... */ }, { read: 'nearest' });            // aliased as 'n'\n```\n\nThe alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'.\n\nThe read option also allows us to specify *tag sets*. These tell the [driver](https://github.com/mongodb/node-mongodb-native/) from which members of the replica-set it should attempt to read. Read more about tag sets [here](http://www.mongodb.com/docs/manual/applications/replication/#tag-sets) and [here](https://www.mongodb.com/docs/manual/core/read-preference).\n\n*NOTE: you may also specify the driver read preference [strategy](https://www.mongodb.com/docs/manual/core/read-preference/#read-preference-modes) option when connecting:*\n\n``` javascript\n// pings the replset members periodically to track network latency\nconst options = { replset: { strategy: 'ping' } };\nmongoose.connect(uri, options);\n\nconst schema = new Schema({ /* ... */ }, { read: ['nearest', { disk: 'ssd' }] });\nmongoose.model('JellyBean', schema);\n```\n\n## option: writeConcern\n\nAllows setting [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) at the schema level.\n\n``` javascript\nconst schema = new Schema({ name: String }, {\n  writeConcern: {\n    w: 'majority',\n    j: true,\n    wtimeout: 1000\n  }\n});\n```\n\n## option: shardKey\n\nThe `shardKey` option is used when we have a [sharded MongoDB architecture](https://www.mongodb.com/docs/manual/sharding/). Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and we’ll be all set.\n\n``` javascript\nnew Schema({ /* ... */ }, { shardKey: { tag: 1, name: 1 } });\n```\n\n*Note that Mongoose does not send the `shardcollection` command for you. You must configure your shards yourself.*\n\n## option: strict\n\nThe strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db.\n\n``` javascript\nconst thingSchema = new Schema({ /* ... */ })\nconst Thing = mongoose.model('Thing', thingSchema);\nconst thing = new Thing({ iAmNotInTheSchema: true });\nthing.save(); // iAmNotInTheSchema is not saved to the db\n\n// set to false..\nconst thingSchema = new Schema({ /* ... */ }, { strict: false });\nconst thing = new Thing({ iAmNotInTheSchema: true });\nthing.save(); // iAmNotInTheSchema is now saved to the db!!\n```\n\nThis also affects the use of `doc.set()` to set a property value.\n\n``` javascript\nconst thingSchema = new Schema({ /* ... */ });\nconst Thing = mongoose.model('Thing', thingSchema);\nconst thing = new Thing;\nthing.set('iAmNotInTheSchema', true);\nthing.save(); // iAmNotInTheSchema is not saved to the db\n```\n\nThis value can be overridden at the model instance level by passing a second boolean argument:\n\n``` javascript\nconst Thing = mongoose.model('Thing');\nconst thing = new Thing(doc, true);  // enables strict mode\nconst thing = new Thing(doc, false); // disables strict mode\n```\n\nThe `strict` option may also be set to `\"throw\"` which will cause errors to be produced instead of dropping the bad data.\n\n*NOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option.*\n\n``` javascript\nconst thingSchema = new Schema({ /* ... */ });\nconst Thing = mongoose.model('Thing', thingSchema);\nconst thing = new Thing;\nthing.iAmNotInTheSchema = true;\nthing.save(); // iAmNotInTheSchema is never saved to the db\n```\n\n## option: strictQuery\n\nMongoose supports a separate `strictQuery` option to avoid strict mode for query filters. This is because empty query filters cause Mongoose to return all documents in the model, which can cause issues.\n\n``` javascript\nconst mySchema = new Schema({ field: Number }, { strict: true });\nconst MyModel = mongoose.model('Test', mySchema);\n// Mongoose will filter out `notInSchema: 1` because `strict: true`, meaning this query will return\n// _all_ documents in the 'tests' collection\nMyModel.find({ notInSchema: 1 });\n```\n\nThe `strict` option does apply to updates. The `strictQuery` option is **just** for query filters.\n\n``` javascript\n// Mongoose will strip out `notInSchema` from the update if `strict` is\n// not `false`\nMyModel.updateMany({}, { $set: { notInSchema: 1 } });\n```\n\nMongoose has a separate `strictQuery` option to toggle strict mode for the `filter` parameter to queries.\n\n``` javascript\nconst mySchema = new Schema({ field: Number }, {\n  strict: true,\n  strictQuery: false // Turn off strict mode for query filters\n});\nconst MyModel = mongoose.model('Test', mySchema);\n// Mongoose will not strip out `notInSchema: 1` because `strictQuery` is false\nMyModel.find({ notInSchema: 1 });\n```\n\nIn general, we do **not** recommend passing user-defined objects as query filters:\n\n``` javascript\n// Don't do this!\nconst docs = await MyModel.find(req.query);\n\n// Do this instead:\nconst docs = await MyModel.find({ name: req.query.name, age: req.query.age }).setOptions({ sanitizeFilter: true });\n```\n\nIn Mongoose 7, `strictQuery` is `false` by default. However, you can override this behavior globally:\n\n``` javascript\n// Set `strictQuery` to `true` to omit unknown fields in queries.\nmongoose.set('strictQuery', true);\n```\n\n## option: toJSON\n\nExactly the same as the [toObject](#toObject) option but only applies when the document's [`toJSON` method](https://thecodebarbarian.com/what-is-the-tojson-function-in-javascript.html) is called.\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.path('name').get(function(v) {\n  return v + ' is my name';\n});\nschema.set('toJSON', { getters: true, virtuals: false });\nconst M = mongoose.model('Person', schema);\nconst m = new M({ name: 'Max Headroom' });\nconsole.log(m.toObject()); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' }\nconsole.log(m.toJSON()); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }\n// since we know toJSON is called whenever a js object is stringified:\nconsole.log(JSON.stringify(m)); // { \"_id\": \"504e0cd7dd992d9be2f20b6f\", \"name\": \"Max Headroom is my name\" }\n```\n\nTo see all available `toJSON/toObject` options, read [this](api/document#document_Document-toObject).\n\n## option: toObject\n\nDocuments have a [toObject](api/document#document_Document-toObject) method which converts the mongoose document into a plain JavaScript object. This method accepts a few options. Instead of applying these options on a per-document basis, we may declare the options at the schema level and have them applied to all of the schema's documents by default.\n\nTo have all virtuals show up in your `console.log` output, set the `toObject` option to `{ getters: true }`:\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.path('name').get(function(v) {\n  return v + ' is my name';\n});\nschema.set('toObject', { getters: true });\nconst M = mongoose.model('Person', schema);\nconst m = new M({ name: 'Max Headroom' });\nconsole.log(m); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }\n```\n\nTo see all available `toObject` options, read [this](api/document#document_Document-toObject).\n\n## option: typeKey\n\nBy default, if you have an object with key 'type' in your schema, mongoose will interpret it as a type declaration.\n\n``` javascript\n// Mongoose interprets this as 'loc is a String'\nconst schema = new Schema({ loc: { type: String, coordinates: [Number] } });\n```\n\nHowever, for applications like [geoJSON](http://www.mongodb.com/docs/manual/reference/geojson/), the 'type' property is important. If you want to control which key mongoose uses to find type declarations, set the 'typeKey' schema option.\n\n``` javascript\nconst schema = new Schema({\n  // Mongoose interprets this as 'loc is an object with 2 keys, type and coordinates'\n  loc: { type: String, coordinates: [Number] },\n  // Mongoose interprets this as 'name is a String'\n  name: { $type: String }\n}, { typeKey: '$type' }); // A '$type' key means this object is a type declaration\n```\n\n## option: validateBeforeSave\n\nBy default, documents are automatically validated before they are saved to the database. This is to prevent saving an invalid document. If you want to handle validation manually, and be able to save objects which don't pass validation, you can set `validateBeforeSave` to false.\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.set('validateBeforeSave', false);\nschema.path('name').validate(function(value) {\n  return value != null;\n});\nconst M = mongoose.model('Person', schema);\nconst m = new M({ name: null });\nm.validate(function(err) {\n  console.log(err); // Will tell you that null is not allowed.\n});\nm.save(); // Succeeds despite being invalid\n```\n\n## option: versionKey\n\nThe `versionKey` is a property set on each document when first created by Mongoose. This keys value contains the internal [revision](http://aaronheckmann.blogspot.com/2012/06/mongoose-v3-part-1-versioning.html) of the document. The `versionKey` option is a string that represents the path to use for versioning. The default is `__v`. If this conflicts with your application you can configure as such:\n\n``` javascript\nconst schema = new Schema({ name: 'string' });\nconst Thing = mongoose.model('Thing', schema);\nconst thing = new Thing({ name: 'mongoose v3' });\nawait thing.save(); // { __v: 0, name: 'mongoose v3' }\n\n// customized versionKey\nnew Schema({ /* ... */ }, { versionKey: '_somethingElse' })\nconst Thing = mongoose.model('Thing', schema);\nconst thing = new Thing({ name: 'mongoose v3' });\nthing.save(); // { _somethingElse: 0, name: 'mongoose v3' }\n```\n\nNote that Mongoose's default versioning is **not** a full [optimistic concurrency](https://en.wikipedia.org/wiki/Optimistic_concurrency_control) solution. Mongoose's default versioning only operates on arrays as shown below.\n\n``` javascript\n// 2 copies of the same document\nconst doc1 = await Model.findOne({ _id });\nconst doc2 = await Model.findOne({ _id });\n\n// Delete first 3 comments from `doc1`\ndoc1.comments.splice(0, 3);\nawait doc1.save();\n\n// The below `save()` will throw a VersionError, because you're trying to\n// modify the comment at index 1, and the above `splice()` removed that\n// comment.\ndoc2.set('comments.1.body', 'new comment');\nawait doc2.save();\n```\n\nIf you need optimistic concurrency support for `save()`, you can set the [`optimisticConcurrency` option](#optimisticConcurrency)\n\nDocument versioning can also be disabled by setting the `versionKey` to `false`. *DO NOT disable versioning unless you [know what you are doing](http://aaronheckmann.blogspot.com/2012/06/mongoose-v3-part-1-versioning.html).*\n\n``` javascript\nnew Schema({ /* ... */ }, { versionKey: false });\nconst Thing = mongoose.model('Thing', schema);\nconst thing = new Thing({ name: 'no versioning please' });\nthing.save(); // { name: 'no versioning please' }\n```\n\nMongoose *only* updates the version key when you use [`save()`](api/document#document_Document-save). If you use `update()`, `findOneAndUpdate()`, etc. Mongoose will **not** update the version key. As a workaround, you can use the below middleware.\n\n``` javascript\nschema.pre('findOneAndUpdate', function() {\n  const update = this.getUpdate();\n  if (update.__v != null) {\n    delete update.__v;\n  }\n  const keys = ['$set', '$setOnInsert'];\n  for (const key of keys) {\n    if (update[key] != null && update[key].__v != null) {\n      delete update[key].__v;\n      if (Object.keys(update[key]).length === 0) {\n        delete update[key];\n      }\n    }\n  }\n  update.$inc = update.$inc || {};\n  update.$inc.__v = 1;\n});\n```\n\n## option: optimisticConcurrency\n\n[Optimistic concurrency](https://en.wikipedia.org/wiki/Optimistic_concurrency_control) is a strategy to ensure the document you're updating didn't change between when you loaded it using `find()` or `findOne()`, and when you update it using `save()`.\n\nFor example, suppose you have a `House` model that contains a list of `photos`, and a `status` that represents whether this house shows up in searches. Suppose that a house that has status `'APPROVED'` must have at least two `photos`. You might implement the logic of approving a house document as shown below:\n\n``` javascript\nasync function markApproved(id) {\n  const house = await House.findOne({ _id });\n  if (house.photos.length < 2) {\n    throw new Error('House must have at least two photos!');\n  }\n\n  house.status = 'APPROVED';\n  await house.save();\n}\n```\n\nThe `markApproved()` function looks right in isolation, but there might be a potential issue: what if another function removes the house's photos between the `findOne()` call and the `save()` call? For example, the below code will succeed:\n\n``` javascript\nconst house = await House.findOne({ _id });\nif (house.photos.length < 2) {\n  throw new Error('House must have at least two photos!');\n}\n\nconst house2 = await House.findOne({ _id });\nhouse2.photos = [];\nawait house2.save();\n\n// Marks the house as 'APPROVED' even though it has 0 photos!\nhouse.status = 'APPROVED';\nawait house.save();\n```\n\nIf you set the `optimisticConcurrency` option on the `House` model's schema, the above script will throw an error.\n\n``` javascript\nconst House = mongoose.model('House', Schema({\n  status: String,\n  photos: [String]\n}, { optimisticConcurrency: true }));\n\nconst house = await House.findOne({ _id });\nif (house.photos.length < 2) {\n  throw new Error('House must have at least two photos!');\n}\n\nconst house2 = await House.findOne({ _id });\nhouse2.photos = [];\nawait house2.save();\n\n// Throws 'VersionError: No matching document found for id \"...\" version 0'\nhouse.status = 'APPROVED';\nawait house.save();\n```\n\n## option: collation\n\nSets a default [collation](https://www.mongodb.com/docs/manual/reference/collation/) for every query and aggregation. [Here's a beginner-friendly overview of collations](http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations).\n\n``` javascript\nconst schema = new Schema({\n  name: String\n}, { collation: { locale: 'en_US', strength: 1 } });\n\nconst MyModel = db.model('MyModel', schema);\n\nMyModel.create([{ name: 'val' }, { name: 'Val' }]).\n  then(() => {\n    return MyModel.find({ name: 'val' });\n  }).\n  then((docs) => {\n    // `docs` will contain both docs, because `strength: 1` means\n    // MongoDB will ignore case when matching.\n  });\n```\n\n## option: timeseries\n\nIf you set the `timeseries` option on a schema, Mongoose will create a [timeseries collection](https://www.mongodb.com/docs/manual/core/timeseries-collections/) for any model that you create from that schema.\n\n``` javascript\nconst schema = Schema({ name: String, timestamp: Date, metadata: Object }, {\n  timeseries: {\n    timeField: 'timestamp',\n    metaField: 'metadata',\n    granularity: 'hours'\n  },\n  autoCreate: false,\n  expireAfterSeconds: 86400\n});\n\n// `Test` collection will be a timeseries collection\nconst Test = db.model('Test', schema);\n```\n\n## option: skipVersioning\n\n`skipVersioning` allows excluding paths from versioning (i.e., the internal revision will not be incremented even if these paths are updated). DO NOT do this unless you know what you're doing. For subdocuments, include this on the parent document using the fully qualified path.\n\n``` javascript\nnew Schema({ /* ... */ }, { skipVersioning: { dontVersionMe: true } });\nthing.dontVersionMe.push('hey');\nthing.save(); // version is not incremented\n```\n\n## option: timestamps\n\nThe `timestamps` option tells Mongoose to assign `createdAt` and `updatedAt` fields to your schema. The type assigned is [Date](schematypes#dates).\n\nBy default, the names of the fields are `createdAt` and `updatedAt`. Customize the field names by setting `timestamps.createdAt` and `timestamps.updatedAt`.\n\nThe way `timestamps` works under the hood is:\n\n- If you create a new document, mongoose simply sets `createdAt`, and `updatedAt` to the time of creation.\n- If you update a document, mongoose will add `updatedAt` to the `$set` object.\n- If you set `upsert: true` on an update operation, mongoose will use [`$setOnInsert`](https://www.mongodb.com/docs/manual/reference/operator/update/setOnInsert/) operator to add `createdAt` to the document in case the `upsert` operation resulted into a new inserted document.\n\n``` javascript\nconst thingSchema = new Schema({ /* ... */ }, { timestamps: { createdAt: 'created_at' } });\nconst Thing = mongoose.model('Thing', thingSchema);\nconst thing = new Thing();\nawait thing.save(); // `created_at` & `updatedAt` will be included\n\n// With updates, Mongoose will add `updatedAt` to `$set`\nawait Thing.updateOne({}, { $set: { name: 'Test' } });\n\n// If you set upsert: true, Mongoose will add `created_at` to `$setOnInsert` as well\nawait Thing.findOneAndUpdate({}, { $set: { name: 'Test2' } });\n\n// Mongoose also adds timestamps to bulkWrite() operations\n// See https://mongoosejs.com/docs/api/model.html#model_Model-bulkWrite\nawait Thing.bulkWrite([\n  {\n    insertOne: {\n      document: {\n        name: 'Jean-Luc Picard',\n        ship: 'USS Stargazer'\n      // Mongoose will add `created_at` and `updatedAt`\n      }\n    }\n  },\n  {\n    updateOne: {\n      filter: { name: 'Jean-Luc Picard' },\n      update: {\n        $set: {\n          ship: 'USS Enterprise'\n        // Mongoose will add `updatedAt`\n        }\n      }\n    }\n  }\n]);\n```\n\nBy default, Mongoose uses `new Date()` to get the current time. If you want to overwrite the function Mongoose uses to get the current time, you can set the `timestamps.currentTime` option. Mongoose will call the `timestamps.currentTime` function whenever it needs to get the current time.\n\n``` javascript\nconst schema = Schema({\n  createdAt: Number,\n  updatedAt: Number,\n  name: String\n}, {\n  // Make Mongoose use Unix time (seconds since Jan 1, 1970)\n  timestamps: { currentTime: () => Math.floor(Date.now() / 1000) }\n});\n```\n\n## option: pluginTags\n\nMongoose supports defining global plugins, plugins that apply to all schemas.\n\n``` javascript\n// Add a `meta` property to all schemas\nmongoose.plugin(function myPlugin(schema) {\n  schema.add({ meta: {} });\n});\n```\n\nSometimes, you may only want to apply a given plugin to some schemas. In that case, you can add `pluginTags` to a schema:\n\n``` javascript\nconst schema1 = new Schema({\n  name: String\n}, { pluginTags: ['useMetaPlugin'] });\n\nconst schema2 = new Schema({\n  name: String\n});\n```\n\nIf you call `plugin()` with a `tags` option, Mongoose will only apply that plugin to schemas that have a matching entry in `pluginTags`.\n\n``` javascript\n// Add a `meta` property to all schemas\nmongoose.plugin(function myPlugin(schema) {\n  schema.add({ meta: {} });\n}, { tags: ['useMetaPlugin'] });\n```\n\n## option: selectPopulatedPaths\n\nBy default, Mongoose will automatically `select()` any populated paths for you, unless you explicitly exclude them.\n\n``` javascript\nconst bookSchema = new Schema({\n  title: 'String',\n  author: { type: 'ObjectId', ref: 'Person' }\n});\nconst Book = mongoose.model('Book', bookSchema);\n\n// By default, Mongoose will add `author` to the below `select()`.\nawait Book.find().select('title').populate('author');\n\n// In other words, the below query is equivalent to the above\nawait Book.find().select('title author').populate('author');\n```\n\nTo opt out of selecting populated fields by default, set `selectPopulatedPaths` to `false` in your schema.\n\n``` javascript\nconst bookSchema = new Schema({\n  title: 'String',\n  author: { type: 'ObjectId', ref: 'Person' }\n}, { selectPopulatedPaths: false });\nconst Book = mongoose.model('Book', bookSchema);\n\n// Because `selectPopulatedPaths` is false, the below doc will **not**\n// contain an `author` property.\nconst doc = await Book.findOne().select('title').populate('author');\n```\n\n## option: storeSubdocValidationError\n\nFor legacy reasons, when there is a validation error in subpath of a single nested schema, Mongoose will record that there was a validation error in the single nested schema path as well. For example:\n\n``` javascript\nconst childSchema = new Schema({ name: { type: String, required: true } });\nconst parentSchema = new Schema({ child: childSchema });\n\nconst Parent = mongoose.model('Parent', parentSchema);\n\n// Will contain an error for both 'child.name' _and_ 'child'\nnew Parent({ child: {} }).validateSync().errors;\n```\n\nSet the `storeSubdocValidationError` to `false` on the child schema to make Mongoose only reports the parent error.\n\n``` javascript\nconst childSchema = new Schema({\n  name: { type: String, required: true }\n}, { storeSubdocValidationError: false }); // <-- set on the child schema\nconst parentSchema = new Schema({ child: childSchema });\n\nconst Parent = mongoose.model('Parent', parentSchema);\n\n// Will only contain an error for 'child.name'\nnew Parent({ child: {} }).validateSync().errors;\n```\n\n## option: collectionOptions\n\nOptions like [`collation`](#collation) and [`capped`](#capped) affect the options Mongoose passes to MongoDB when creating a new collection. Mongoose schemas support most [MongoDB `createCollection()` options](https://www.mongodb.com/docs/manual/reference/method/db.createCollection/), but not all. You can use the `collectionOptions` option to set any `createCollection()` options; Mongoose will use `collectionOptions` as the default values when calling `createCollection()` for your schema.\n\n``` javascript\nconst schema = new Schema({ name: String }, {\n  autoCreate: false,\n  collectionOptions: {\n    capped: true,\n    max: 1000\n  }\n});\nconst Test = mongoose.model('Test', schema);\n\n// Equivalent to `createCollection({ capped: true, max: 1000 })`\nawait Test.createCollection();\n```\n\n## With ES6 Classes\n\nSchemas have a [`loadClass()` method](api/schema#schema_Schema-loadClass) that you can use to create a Mongoose schema from an [ES6 class](https://thecodebarbarian.com/an-overview-of-es6-classes):\n\n- [ES6 class methods](https://masteringjs.io/tutorials/fundamentals/class#methods) become [Mongoose methods](guide#methods)\n- [ES6 class statics](https://masteringjs.io/tutorials/fundamentals/class#statics) become [Mongoose statics](guide#statics)\n- [ES6 getters and setters](https://masteringjs.io/tutorials/fundamentals/class#getterssetters) become [Mongoose virtuals](tutorials/virtuals)\n\nHere's an example of using `loadClass()` to create a schema from an ES6 class:\n\n``` javascript\nclass MyClass {\n  myMethod() { return 42; }\n  static myStatic() { return 42; }\n  get myVirtual() { return 42; }\n}\n\nconst schema = new mongoose.Schema();\nschema.loadClass(MyClass);\n\nconsole.log(schema.methods); // { myMethod: [Function: myMethod] }\nconsole.log(schema.statics); // { myStatic: [Function: myStatic] }\nconsole.log(schema.virtuals); // { myVirtual: VirtualType { ... } }\n```\n\n## Pluggable\n\nSchemas are also [pluggable](plugins) which allows us to package up reusable features into plugins that can be shared with the community or just between your projects.\n\n## Further Reading\n\nHere's an [alternative introduction to Mongoose schemas](https://masteringjs.io/tutorials/mongoose/schema).\n\nTo get the most out of MongoDB, you need to learn the basics of MongoDB schema design. SQL schema design (third normal form) was designed to [minimize storage costs](https://en.wikipedia.org/wiki/Third_normal_form), whereas MongoDB schema design is about making common queries as fast as possible. The [*6 Rules of Thumb for MongoDB Schema Design* blog series](https://www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design-part-1) is an excellent resource for learning the basic rules for making your queries fast.\n\nUsers looking to master MongoDB schema design in Node.js should look into [*The Little MongoDB Schema Design Book*](http://bit.ly/mongodb-schema-design) by Christian Kvalheim, the original author of the [MongoDB Node.js driver](http://npmjs.com/package/mongodb). This book shows you how to implement performant schemas for a laundry list of use cases, including e-commerce, wikis, and appointment bookings.\n\n## Next Up\n\nNow that we've covered `Schemas`, let's take a look at [SchemaTypes](schematypes).\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/guide.html](https://mongoosejs.com/docs/guide.html)"
- name: SchemaString
  id: api/schemastring
  summary: String SchemaType constructor
  description: "# SchemaString\n\n### SchemaString()\n\n##### Parameters:\n\n- `key` «String»\n- `options` «Object»\n\n##### Inherits:\n\n- [«SchemaType»](schematype)\n\nString SchemaType constructor.\n\n### SchemaString.checkRequired()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «Function»\n\n##### Type:\n\n- «property»\n\nOverride the function the required validator uses to check whether a string passes the `required` check.\n\n#### [Example:](#example)\n\n``` javascript\n// Allow empty strings to pass `required` check\nmongoose.Schema.Types.String.checkRequired(v => v != null);\n\nconst M = mongoose.model({ str: { type: String, required: true } });\nnew M({ str: '' }).validateSync(); // `null`, validation passes!\n```\n\n### SchemaString.get()\n\n##### Parameters:\n\n- `caster` «Function»\n\n##### Returns:\n\n- «Function»\n\n##### Type:\n\n- «property»\n\nGet/set the function used to cast arbitrary values to strings.\n\n#### [Example:](#example)\n\n``` javascript\n// Throw an error if you pass in an object. Normally, Mongoose allows\n// objects with custom `toString()` functions.\nconst original = mongoose.Schema.Types.String.cast();\nmongoose.Schema.Types.String.cast(v => {\n  assert.ok(v == null || typeof v !== 'object');\n  return original(v);\n});\n\n// Or disable casting entirely\nmongoose.Schema.Types.String.cast(false);\n```\n\n### SchemaString.get()\n\n##### Parameters:\n\n- `getter` «Function»\n\n##### Returns:\n\n- «this»\n\n##### Type:\n\n- «property»\n\nAttaches a getter for all String instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all numbers round down\nmongoose.Schema.String.get(v => v.toLowerCase());\n\nconst Model = mongoose.model('Test', new Schema({ test: String }));\nnew Model({ test: 'FOO' }).test; // 'foo'\n```\n\n### SchemaString.prototype.checkRequired()\n\n##### Parameters:\n\n- `value` «Any»\n- `doc` «Document»\n\n##### Returns:\n\n- «Boolean»\n\nCheck if the given value satisfies the `required` validator. The value is considered valid if it is a string (that is, not `null` or `undefined`) and has positive length. The `required` validator **will** fail for empty strings.\n\n### SchemaString.prototype.enum()\n\n##### Parameters:\n\n- `[...args]` «String\\|Object» enumeration values\n\n##### Returns:\n\n- «SchemaType» this\n\n##### See:\n\n- [Customized Error Messages](error#Error.messages)\n- [Enums in JavaScript](https://masteringjs.io/tutorials/fundamentals/enum)\n\nAdds an enum validator\n\n#### [Example:](#example)\n\n``` javascript\nconst states = ['opening', 'open', 'closing', 'closed']\nconst s = new Schema({ state: { type: String, enum: states }})\nconst M = db.model('M', s)\nconst m = new M({ state: 'invalid' })\nm.save(function (err) {\n  console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n  m.state = 'open'\n  m.save(callback) // success\n})\n\n// or with custom error messages\nconst enum = {\n  values: ['opening', 'open', 'closing', 'closed'],\n  message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n}\nconst s = new Schema({ state: { type: String, enum: enum })\nconst M = db.model('M', s)\nconst m = new M({ state: 'invalid' })\nm.save(function (err) {\n  console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n  m.state = 'open'\n  m.save(callback) // success\n})\n```\n\n### SchemaString.prototype.lowercase()\n\n##### Returns:\n\n- «SchemaType» this\n\nAdds a lowercase [setter](schematype#SchemaType.prototype.set()).\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ email: { type: String, lowercase: true }})\nconst M = db.model('M', s);\nconst m = new M({ email: 'SomeEmail@example.COM' });\nconsole.log(m.email) // someemail@example.com\nM.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'\n```\n\nNote that `lowercase` does **not** affect regular expression queries:\n\n#### [Example:](#example-1)\n\n``` javascript\n// Still queries for documents whose `email` matches the regular\n// expression /SomeEmail/. Mongoose does **not** convert the RegExp\n// to lowercase.\nM.find({ email: /SomeEmail/ });\n```\n\n### SchemaString.prototype.match()\n\n##### Parameters:\n\n- `regExp` «RegExp» regular expression to test against\n- `[message]` «String» optional custom error message\n\n##### Returns:\n\n- «SchemaType» this\n\n##### See:\n\n- [Customized Error Messages](error#Error.messages)\n\nSets a regexp validator.\n\nAny value that does not pass `regExp`.test(val) will fail validation.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ name: { type: String, match: /^a/ }})\nconst M = db.model('M', s)\nconst m = new M({ name: 'I am invalid' })\nm.validate(function (err) {\n  console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n  m.name = 'apples'\n  m.validate(function (err) {\n    assert.ok(err) // success\n  })\n})\n\n// using a custom error message\nconst match = [ /\\.html$/, \"That file doesn't end in .html ({VALUE})\" ];\nconst s = new Schema({ file: { type: String, match: match }})\nconst M = db.model('M', s);\nconst m = new M({ file: 'invalid' });\nm.validate(function (err) {\n  console.log(String(err)) // \"ValidationError: That file doesn't end in .html (invalid)\"\n})\n```\n\nEmpty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.\n\n``` javascript\nconst s = new Schema({ name: { type: String, match: /^a/, required: true }})\n```\n\n### SchemaString.prototype.maxlength()\n\n##### Parameters:\n\n- `value` «Number» maximum string length\n- `[message]` «String» optional custom error message\n\n##### Returns:\n\n- «SchemaType» this\n\n##### See:\n\n- [Customized Error Messages](error#Error.messages)\n\nSets a maximum length validator.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ postalCode: { type: String, maxlength: 9 })\nconst Address = db.model('Address', schema)\nconst address = new Address({ postalCode: '9512512345' })\naddress.save(function (err) {\n  console.error(err) // validator error\n  address.postalCode = '95125';\n  address.save() // success\n})\n\n// custom error messages\n// We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length\nconst maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\nconst schema = new Schema({ postalCode: { type: String, maxlength: maxlength })\nconst Address = mongoose.model('Address', schema);\nconst address = new Address({ postalCode: '9512512345' });\naddress.validate(function (err) {\n  console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).\n})\n```\n\n### SchemaString.prototype.minlength()\n\n##### Parameters:\n\n- `value` «Number» minimum string length\n- `[message]` «String» optional custom error message\n\n##### Returns:\n\n- «SchemaType» this\n\n##### See:\n\n- [Customized Error Messages](error#Error.messages)\n\nSets a minimum length validator.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ postalCode: { type: String, minlength: 5 })\nconst Address = db.model('Address', schema)\nconst address = new Address({ postalCode: '9512' })\naddress.save(function (err) {\n  console.error(err) // validator error\n  address.postalCode = '95125';\n  address.save() // success\n})\n\n// custom error messages\n// We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length\nconst minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];\nconst schema = new Schema({ postalCode: { type: String, minlength: minlength })\nconst Address = mongoose.model('Address', schema);\nconst address = new Address({ postalCode: '9512' });\naddress.validate(function (err) {\n  console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n})\n```\n\n### SchemaString.prototype.trim()\n\n##### Returns:\n\n- «SchemaType» this\n\nAdds a trim [setter](schematype#SchemaType.prototype.set()).\n\nThe string value will be [trimmed](https://masteringjs.io/tutorials/fundamentals/trim-string) when set.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ name: { type: String, trim: true }});\nconst M = db.model('M', s);\nconst string = ' some name ';\nconsole.log(string.length); // 11\nconst m = new M({ name: string });\nconsole.log(m.name.length); // 9\n\n// Equivalent to `findOne({ name: string.trim() })`\nM.findOne({ name: string });\n```\n\nNote that `trim` does **not** affect regular expression queries:\n\n#### [Example:](#example-1)\n\n``` javascript\n// Mongoose does **not** trim whitespace from the RegExp.\nM.find({ name: / some name / });\n```\n\n### SchemaString.prototype.uppercase()\n\n##### Returns:\n\n- «SchemaType» this\n\nAdds an uppercase [setter](schematype#SchemaType.prototype.set()).\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ caps: { type: String, uppercase: true }})\nconst M = db.model('M', s);\nconst m = new M({ caps: 'an example' });\nconsole.log(m.caps) // AN EXAMPLE\nM.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'\n```\n\nNote that `uppercase` does **not** affect regular expression queries:\n\n#### [Example:](#example-1)\n\n``` javascript\n// Mongoose does **not** convert the RegExp to uppercase.\nM.find({ email: /an example/ });\n```\n\n### SchemaString.schemaName\n\n##### Type:\n\n- «property»\n\nThis schema type's name, to defend against minifiers that mangle function names.\n\n### SchemaString.set()\n\n##### Parameters:\n\n- `option` «String» The option you'd like to set the value for\n- `value` «Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all String instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all strings have option `trim` equal to true.\nmongoose.Schema.String.set('trim', true);\n\nconst User = mongoose.model('User', new Schema({ name: String }));\nnew User({ name: '   John Doe   ' }).name; // 'John Doe'\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemastring.html](https://mongoosejs.com/docs/api/schemastring.html)"
- name: SchemaString()
  id: api/schemastring#SchemaString()
  summary: String SchemaType constructor
  belongs_to: SchemaString
  description: |-
    ### SchemaString()

    ##### Parameters:

    - `key` «String»
    - `options` «Object»

    ##### Inherits:

    -  [«SchemaType»](schematype)

    String SchemaType constructor.
- name: SchemaString.checkRequired()
  id: api/schemastring#SchemaString.checkRequired()
  summary: Override the function the required validator uses to check whether a string passes the required check
  belongs_to: SchemaString
  description: |-
    ### SchemaString.checkRequired()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «Function»

    ##### Type:

    - «property»

    Override the function the required validator uses to check whether a string passes the `required` check.

    #### [Example:](#example)

    ``` javascript
    // Allow empty strings to pass `required` check
    mongoose.Schema.Types.String.checkRequired(v => v != null);

    const M = mongoose.model({ str: { type: String, required: true } });
    new M({ str: '' }).validateSync(); // `null`, validation passes!
    ```
- name: SchemaString.get()
  id: api/schemastring#SchemaString.get()
  summary: Get/set the function used to cast arbitrary values to strings
  belongs_to: SchemaString
  description: |-
    ### SchemaString.get()

    ##### Parameters:

    - `caster` «Function»

    ##### Returns:

    - «Function»

    ##### Type:

    - «property»

    Get/set the function used to cast arbitrary values to strings.

    #### [Example:](#example)

    ``` javascript
    // Throw an error if you pass in an object. Normally, Mongoose allows// objects with custom `toString()` functions.const original = mongoose.Schema.Types.String.cast();
    mongoose.Schema.Types.String.cast(v => {
      assert.ok(v == null || typeof v !== 'object');
      return original(v);
    });

    // Or disable casting entirely
    mongoose.Schema.Types.String.cast(false);
    ```

    ### SchemaString.get()

    ##### Parameters:

    - `getter` «Function»

    ##### Returns:

    - «this»

    ##### Type:

    - «property»

    Attaches a getter for all String instances.

    #### [Example:](#example)

    ``` javascript
    // Make all numbers round down
    mongoose.Schema.String.get(v => v.toLowerCase());

    const Model = mongoose.model('Test', new Schema({ test: String }));
    new Model({ test: 'FOO' }).test; // 'foo'
    ```
- name: SchemaString.prototype.checkRequired()
  id: api/schemastring#SchemaString.prototype.checkRequired()
  summary: Check if the given value satisfies the required validator
  belongs_to: SchemaString
  description: |-
    ### SchemaString.prototype.checkRequired()

    ##### Parameters:

    - `value` «Any»
    - `doc` «Document»

    ##### Returns:

    - «Boolean»

    Check if the given value satisfies the `required` validator. The value is considered valid if it is a string (that is, not `null` or `undefined`) and has positive length. The `required` validator **will** fail for empty strings.
- name: SchemaString.prototype.enum()
  id: api/schemastring#SchemaString.prototype.enum()
  summary: null
  belongs_to: SchemaString
  description: |-
    ### SchemaString.prototype.enum()

    ##### Parameters:

    - `[...args]`«String\|Object» enumeration values

    ##### Returns:

    - «SchemaType» this

    ##### See:

    -  [Customized Error Messages](error#Error.messages)
    -  [Enums in JavaScript](https://masteringjs.io/tutorials/fundamentals/enum)

    Adds an enum validator

    #### [Example:](#example)

    ``` javascript
    const states = ['opening', 'open', 'closing', 'closed']
    const s = new Schema({ state: { type: String, enum: states }})
    const M = db.model('M', s)
    const m = new M({ state: 'invalid' })
    m.save(function (err) {
      console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.
      m.state = 'open'
      m.save(callback) // success
    })

    // or with custom error messages
    const enum = {
      values: ['opening', 'open', 'closing', 'closed'],
      message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'
    }
    const s = new Schema({ state: { type: String, enum: enum })
    const M = db.model('M', s)
    const m = new M({ state: 'invalid' })
    m.save(function (err) {
      console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`
      m.state = 'open'
      m.save(callback) // success
    })
    ```
- name: SchemaString.prototype.lowercase()
  id: api/schemastring#SchemaString.prototype.lowercase()
  summary: Adds a lowercase setter
  belongs_to: SchemaString
  description: |-
    ### SchemaString.prototype.lowercase()

    ##### Returns:

    - «SchemaType» this

    Adds a lowercase [setter](schematype#SchemaType.prototype.set()).

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ email: { type: String, lowercase: true }})
    const M = db.model('M', s);
    const m = new M({ email: 'SomeEmail@example.COM' });
    console.log(m.email) // someemail@example.com
    M.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'
    ```

    Note that `lowercase` does **not** affect regular expression queries:

    #### [Example:](#example-1)

    ``` javascript
    // Still queries for documents whose `email` matches the regular// expression /SomeEmail/. Mongoose does **not** convert the RegExp// to lowercase.
    M.find({ email: /SomeEmail/ });
    ```
- name: SchemaString.prototype.match()
  id: api/schemastring#SchemaString.prototype.match()
  summary: Sets a regexp validator
  belongs_to: SchemaString
  description: |-
    ### SchemaString.prototype.match()

    ##### Parameters:

    - `regExp`«RegExp» regular expression to test against
    - `[message]`«String» optional custom error message

    ##### Returns:

    - «SchemaType» this

    ##### See:

    -  [Customized Error Messages](error#Error.messages)

    Sets a regexp validator.

    Any value that does not pass `regExp`.test(val) will fail validation.

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ name: { type: String, match: /^a/ }})
    const M = db.model('M', s)
    const m = new M({ name: 'I am invalid' })
    m.validate(function (err) {
      console.error(String(err)) // "ValidationError: Path `name` is invalid (I am invalid)."
      m.name = 'apples'
      m.validate(function (err) {
        assert.ok(err) // success
      })
    })

    // using a custom error message
    const match = [ /\.html$/, "That file doesn't end in .html ({VALUE})" ];
    const s = new Schema({ file: { type: String, match: match }})
    const M = db.model('M', s);
    const m = new M({ file: 'invalid' });
    m.validate(function (err) {
      console.log(String(err)) // "ValidationError: That file doesn't end in .html (invalid)"
    })
    ```

    Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.

    ``` javascript
    const s = new Schema({ name: { type: String, match: /^a/, required: true }})
    ```
- name: SchemaString.prototype.maxlength()
  id: api/schemastring#SchemaString.prototype.maxlength()
  summary: Sets a maximum length validator
  belongs_to: SchemaString
  description: |-
    ### SchemaString.prototype.maxlength()

    ##### Parameters:

    - `value`«Number» maximum string length
    - `[message]`«String» optional custom error message

    ##### Returns:

    - «SchemaType» this

    ##### See:

    -  [Customized Error Messages](error#Error.messages)

    Sets a maximum length validator.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ postalCode: { type: String, maxlength: 9 })
    const Address = db.model('Address', schema)
    const address = new Address({ postalCode: '9512512345' })
    address.save(function (err) {
      console.error(err) // validator error
      address.postalCode = '95125';
      address.save() // success
    })

    // custom error messages
    // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length
    const maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];
    const schema = new Schema({ postalCode: { type: String, maxlength: maxlength })
    const Address = mongoose.model('Address', schema);
    const address = new Address({ postalCode: '9512512345' });
    address.validate(function (err) {
      console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).
    })
    ```
- name: SchemaString.prototype.minlength()
  id: api/schemastring#SchemaString.prototype.minlength()
  summary: Sets a minimum length validator
  belongs_to: SchemaString
  description: |-
    ### SchemaString.prototype.minlength()

    ##### Parameters:

    - `value`«Number» minimum string length
    - `[message]`«String» optional custom error message

    ##### Returns:

    - «SchemaType» this

    ##### See:

    -  [Customized Error Messages](error#Error.messages)

    Sets a minimum length validator.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ postalCode: { type: String, minlength: 5 })
    const Address = db.model('Address', schema)
    const address = new Address({ postalCode: '9512' })
    address.save(function (err) {
      console.error(err) // validator error
      address.postalCode = '95125';
      address.save() // success
    })

    // custom error messages
    // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length
    const minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];
    const schema = new Schema({ postalCode: { type: String, minlength: minlength })
    const Address = mongoose.model('Address', schema);
    const address = new Address({ postalCode: '9512' });
    address.validate(function (err) {
      console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).
    })
    ```
- name: SchemaString.prototype.trim()
  id: api/schemastring#SchemaString.prototype.trim()
  summary: Adds a trim setter
  belongs_to: SchemaString
  description: |-
    ### SchemaString.prototype.trim()

    ##### Returns:

    - «SchemaType» this

    Adds a trim [setter](schematype#SchemaType.prototype.set()).

    The string value will be [trimmed](https://masteringjs.io/tutorials/fundamentals/trim-string) when set.

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ name: { type: String, trim: true }});
    const M = db.model('M', s);
    const string = ' some name ';
    console.log(string.length); // 11
    const m = new M({ name: string });
    console.log(m.name.length); // 9

    // Equivalent to `findOne({ name: string.trim() })`
    M.findOne({ name: string });
    ```

    Note that `trim` does **not** affect regular expression queries:

    #### [Example:](#example-1)

    ``` javascript
    // Mongoose does **not** trim whitespace from the RegExp.
    M.find({ name: / some name / });
    ```
- name: SchemaString.prototype.uppercase()
  id: api/schemastring#SchemaString.prototype.uppercase()
  summary: Adds an uppercase setter
  belongs_to: SchemaString
  description: |-
    ### SchemaString.prototype.uppercase()

    ##### Returns:

    - «SchemaType» this

    Adds an uppercase [setter](schematype#SchemaType.prototype.set()).

    #### [Example:](#example)

    ``` javascript
    const s = new Schema({ caps: { type: String, uppercase: true }})
    const M = db.model('M', s);
    const m = new M({ caps: 'an example' });
    console.log(m.caps) // AN EXAMPLE
    M.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'
    ```

    Note that `uppercase` does **not** affect regular expression queries:

    #### [Example:](#example-1)

    ``` javascript
    // Mongoose does **not** convert the RegExp to uppercase.
    M.find({ email: /an example/ });
    ```
- name: SchemaString.schemaName
  id: api/schemastring#SchemaString.schemaName
  summary: This schema type's name, to defend against minifiers that mangle function names
  belongs_to: SchemaString
  description: |-
    ### SchemaString.schemaName

    ##### Type:

    - «property»

    This schema type's name, to defend against minifiers that mangle function names.
- name: SchemaString.set()
  id: api/schemastring#SchemaString.set()
  summary: Sets a default option for all String instances
  belongs_to: SchemaString
  description: "### SchemaString.set()\n\n##### Parameters:\n\n- `option`«String» The option you'd like to set the value for\n- `value`«Any» value for option\n\n##### Returns:\n\n- «undefined,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all String instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all strings have option `trim` equal to true.\nmongoose.Schema.String.set('trim', true);\n\nconst User = mongoose.model('User', new Schema({ name: String }));\nnew User({ name: '   John Doe   ' }).name; // 'John Doe'\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schemastring.html](https://mongoosejs.com/docs/api/schemastring.html)"
- name: Schematype
  id: api/schematype
  summary: SchemaType constructor
  description: "# Schematype\n\n### SchemaType()\n\n##### Parameters:\n\n- `path` «String»\n- `[options]` «SchemaTypeOptions» See [SchemaTypeOptions docs](schematypeoptions)\n- `[instance]` «String»\n\nSchemaType constructor. Do **not** instantiate `SchemaType` directly. Mongoose converts your schema paths into SchemaTypes automatically.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.path('name') instanceof SchemaType; // true\n```\n\n### SchemaType.cast()\n\n##### Parameters:\n\n- `caster` «Function\\|false» Function that casts arbitrary values to this type, or throws an error if casting failed\n\n##### Returns:\n\n- «Function»\n\nGet/set the function used to cast arbitrary values to this type.\n\n#### [Example:](#example)\n\n``` javascript\n// Disallow `null` for numbers, and don't try to cast any values to\n// numbers, so even strings like '123' will cause a CastError.\nmongoose.Number.cast(function(v) {\n  assert.ok(v === undefined || typeof v === 'number');\n  return v;\n});\n```\n\n### SchemaType.checkRequired()\n\n##### Parameters:\n\n- `[fn]` «Function» If set, will overwrite the current set function\n\n##### Returns:\n\n- «Function» The input `fn` or the already set function\n\nSet & Get the `checkRequired` function Override the function the required validator uses to check whether a value passes the `required` check. Override this on the individual SchemaType.\n\n#### [Example:](#example)\n\n``` javascript\n// Use this to allow empty strings to pass the `required` validator\nmongoose.Schema.Types.String.checkRequired(v => typeof v === 'string');\n```\n\n### SchemaType.get()\n\n##### Parameters:\n\n- `getter` «Function»\n\n##### Returns:\n\n- «this»\n\nAttaches a getter for all instances of this schema type.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all numbers round down\nmongoose.Number.get(function(v) { return Math.floor(v); });\n```\n\n### SchemaType.prototype.cast()\n\n##### Parameters:\n\n- `value` «Object» value to cast\n- `doc` «Document» document that triggers the casting\n- `init` «Boolean»\n\nThe function that Mongoose calls to cast arbitrary values to this SchemaType.\n\n### SchemaType.prototype.castFunction()\n\n##### Parameters:\n\n- `caster` «Function\\|false» Function that casts arbitrary values to this type, or throws an error if casting failed\n\n##### Returns:\n\n- «Function»\n\nGet/set the function used to cast arbitrary values to this particular schematype instance. Overrides `SchemaType.cast()`.\n\n#### [Example:](#example)\n\n``` javascript\n// Disallow `null` for numbers, and don't try to cast any values to\n// numbers, so even strings like '123' will cause a CastError.\nconst number = new mongoose.Number('mypath', {});\nnumber.cast(function(v) {\n  assert.ok(v === undefined || typeof v === 'number');\n  return v;\n});\n```\n\n### SchemaType.prototype.default()\n\n##### Parameters:\n\n- `val` «Function\\|any» The default value to set\n\n##### Returns:\n\n- «Any,undefined,void» Returns the set default value.\n\nSets a default value for this SchemaType.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ n: { type: Number, default: 10 })\nconst M = db.model('M', schema)\nconst m = new M;\nconsole.log(m.n) // 10\n```\n\nDefaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n\n#### [Example:](#example-1)\n\n``` javascript\n// values are cast:\nconst schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})\nconst M = db.model('M', schema)\nconst m = new M;\nconsole.log(m.aNumber) // 4.815162342\n\n// default unique objects for Mixed types:\nconst schema = new Schema({ mixed: Schema.Types.Mixed });\nschema.path('mixed').default(function () {\n  return {};\n});\n\n// if we don't use a function to return object literals for Mixed defaults,\n// each document will receive a reference to the same object literal creating\n// a \"shared\" object instance:\nconst schema = new Schema({ mixed: Schema.Types.Mixed });\nschema.path('mixed').default({});\nconst M = db.model('M', schema);\nconst m1 = new M;\nm1.mixed.added = 1;\nconsole.log(m1.mixed); // { added: 1 }\nconst m2 = new M;\nconsole.log(m2.mixed); // { added: 1 }\n```\n\n### SchemaType.prototype.doValidate()\n\n##### Parameters:\n\n- `value` «Any»\n- `callback` «Function»\n- `scope` «Object»\n- `[options]` «Object»\n\n- `[options.path]` «String»\n\n##### Returns:\n\n- «Any» If no validators, returns the output from calling `fn`, otherwise no return\n\nPerforms a validation of `value` using the validators declared for this SchemaType.\n\n### SchemaType.prototype.get()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «SchemaType» this\n\nAdds a getter to this schematype.\n\n#### [Example:](#example)\n\n``` javascript\nfunction dob (val) {\n  if (!val) return val;\n  return (val.getMonth() + 1) + \"/\" + val.getDate() + \"/\" + val.getFullYear();\n}\n\n// defining within the schema\nconst s = new Schema({ born: { type: Date, get: dob })\n\n// or by retreiving its SchemaType\nconst s = new Schema({ born: Date })\ns.path('born').get(dob)\n```\n\nGetters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n\nSuppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n\n``` javascript\nfunction obfuscate (cc) {\n  return '****-****-****-' + cc.slice(cc.length-4, cc.length);\n}\n\nconst AccountSchema = new Schema({\n  creditCardNumber: { type: String, get: obfuscate }\n});\n\nconst Account = db.model('Account', AccountSchema);\n\nAccount.findById(id, function (err, found) {\n  console.log(found.creditCardNumber); // '****-****-****-1234'\n});\n```\n\nGetters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n\n``` javascript\nfunction inspector (val, priorValue, schematype) {\n  if (schematype.options.required) {\n    return schematype.path + ' is required';\n  } else {\n    return schematype.path + ' is not';\n  }\n}\n\nconst VirusSchema = new Schema({\n  name: { type: String, required: true, get: inspector },\n  taxonomy: { type: String, get: inspector }\n})\n\nconst Virus = db.model('Virus', VirusSchema);\n\nVirus.findById(id, function (err, virus) {\n  console.log(virus.name);     // name is required\n  console.log(virus.taxonomy); // taxonomy is not\n})\n```\n\n### SchemaType.prototype.immutable()\n\n##### Parameters:\n\n- `bool` «Boolean»\n\n##### Returns:\n\n- «SchemaType» this\n\n##### See:\n\n- [isNew](document#Document.prototype.isNew())\n\nDefines this path as immutable. Mongoose prevents you from changing immutable paths unless the parent document has [`isNew: true`](document#Document.prototype.isNew()).\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({\n  name: { type: String, immutable: true },\n  age: Number\n});\nconst Model = mongoose.model('Test', schema);\n\nawait Model.create({ name: 'test' });\nconst doc = await Model.findOne();\n\ndoc.isNew; // false\ndoc.name = 'new name';\ndoc.name; // 'test', because `name` is immutable\n```\n\nMongoose also prevents changing immutable properties using `updateOne()` and `updateMany()` based on [strict mode](../guide#strict).\n\n#### [Example:](#example-1)\n\n``` javascript\n// Mongoose will strip out the `name` update, because `name` is immutable\nModel.updateOne({}, { $set: { name: 'test2' }, $inc: { age: 1 } });\n\n// If `strict` is set to 'throw', Mongoose will throw an error if you\n// update `name`\nconst err = await Model.updateOne({}, { name: 'test2' }, { strict: 'throw' }).\n  then(() => null, err => err);\nerr.name; // StrictModeError\n\n// If `strict` is `false`, Mongoose allows updating `name` even though\n// the property is immutable.\nModel.updateOne({}, { name: 'test2' }, { strict: false });\n```\n\n### SchemaType.prototype.index()\n\n##### Parameters:\n\n- `options` «Object\\|Boolean\\|String\\|Number»\n\n##### Returns:\n\n- «SchemaType» this\n\nDeclares the index options for this schematype.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ name: { type: String, index: true })\nconst s = new Schema({ name: { type: String, index: -1 })\nconst s = new Schema({ loc: { type: [Number], index: 'hashed' })\nconst s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })\nconst s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})\nconst s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})\ns.path('my.path').index(true);\ns.path('my.date').index({ expires: 60 });\ns.path('my.path').index({ unique: true, sparse: true });\n```\n\n#### [Note:](#note)\n\n*Indexes are created [in the background](https://www.mongodb.com/docs/manual/core/index-creation/#index-creation-background) by default. If `background` is set to `false`, MongoDB will not execute any read/write operations you send until the index build. Specify `background: false` to override Mongoose's default.*\n\n### SchemaType.prototype.isRequired\n\n##### Type:\n\n- «property»\n\nTrue if this SchemaType has a required validator. False otherwise.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: { type: String, required: true } });\nschema.path('name').isRequired; // true\n\nschema.path('name').required(false);\nschema.path('name').isRequired; // false\n```\n\n### SchemaType.prototype.path\n\n##### Type:\n\n- «property»\n\nThe path to this SchemaType in a Schema.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.path('name').path; // 'name'\n```\n\n### SchemaType.prototype.ref()\n\n##### Parameters:\n\n- `ref` «String\\|Model\\|Function» either a model name, a [Model](../models), or a function that returns a model name or model.\n\n##### Returns:\n\n- «SchemaType» this\n\nSet the model that this path refers to. This is the option that [populate](../populate) looks at to determine the foreign collection it should query.\n\n#### [Example:](#example)\n\n``` javascript\nconst userSchema = new Schema({ name: String });\nconst User = mongoose.model('User', userSchema);\n\nconst postSchema = new Schema({ user: mongoose.ObjectId });\npostSchema.path('user').ref('User'); // Can set ref to a model name\npostSchema.path('user').ref(User); // Or a model class\npostSchema.path('user').ref(() => 'User'); // Or a function that returns the model name\npostSchema.path('user').ref(() => User); // Or a function that returns the model class\n\n// Or you can just declare the `ref` inline in your schema\nconst postSchema2 = new Schema({\n  user: { type: mongoose.ObjectId, ref: User }\n});\n```\n\n### SchemaType.prototype.required()\n\n##### Parameters:\n\n- `required` «Boolean\\|Function\\|Object» enable/disable the validator, or function that returns required boolean, or options object\n\n&nbsp;\n\n- `[options.isRequired]` «Boolean\\|Function» enable/disable the validator, or function that returns required boolean\n\n&nbsp;\n\n- `[options.ErrorConstructor]` «Function» custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.\n\n&nbsp;\n\n- `[message]` «String» optional custom error message\n\n##### Returns:\n\n- «SchemaType» this\n\n##### See:\n\n- [Customized Error Messages](error#Error.messages)\n- [SchemaArray#checkRequired](schemaarray#SchemaArray.prototype.checkRequired())\n- [SchemaBoolean#checkRequired](schemaboolean#SchemaBoolean.prototype.checkRequired())\n- [SchemaBuffer#checkRequired](schemabuffer#SchemaBuffer.prototype.checkRequired())\n- [SchemaNumber#checkRequired](schemanumber#SchemaNumber.prototype.checkRequired())\n- [SchemaObjectId#checkRequired](schemaobjectid#ObjectId.prototype.checkRequired())\n- [SchemaString#checkRequired](schemastring#SchemaString.prototype.checkRequired())\n\nAdds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using `unshift()`.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ born: { type: Date, required: true })\n\n// or with custom error message\n\nconst s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n\n// or with a function\n\nconst s = new Schema({\n  userId: ObjectId,\n  username: {\n    type: String,\n    required: function() { return this.userId != null; }\n  }\n})\n\n// or with a function and a custom message\nconst s = new Schema({\n  userId: ObjectId,\n  username: {\n    type: String,\n    required: [\n      function() { return this.userId != null; },\n      'username is required if id is specified'\n    ]\n  }\n})\n\n// or through the path API\n\ns.path('name').required(true);\n\n// with custom error messaging\n\ns.path('name').required(true, 'grrr :( ');\n\n// or make a path conditionally required based on a function\nconst isOver18 = function() { return this.age >= 18; };\ns.path('voterRegistrationId').required(isOver18);\n```\n\nThe required validator uses the SchemaType's `checkRequired` function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if `val != null` (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default `checkRequired` function:\n\n### SchemaType.prototype.select()\n\n##### Parameters:\n\n- `val` «Boolean»\n\n##### Returns:\n\n- «SchemaType» this\n\nSets default `select()` behavior for this path.\n\nSet to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.\n\n#### [Example:](#example)\n\n``` javascript\nT = db.model('T', new Schema({ x: { type: String, select: true }}));\nT.find(..); // field x will always be selected ..\n// .. unless overridden;\nT.find().select('-x').exec(callback);\n```\n\n### SchemaType.prototype.set()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «SchemaType» this\n\nAdds a setter to this schematype.\n\n#### [Example:](#example)\n\n``` javascript\nfunction capitalize (val) {\n  if (typeof val !== 'string') val = '';\n  return val.charAt(0).toUpperCase() + val.substring(1);\n}\n\n// defining within the schema\nconst s = new Schema({ name: { type: String, set: capitalize }});\n\n// or with the SchemaType\nconst s = new Schema({ name: String })\ns.path('name').set(capitalize);\n```\n\nSetters allow you to transform the data before it gets to the raw mongodb document or query.\n\nSuppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, <avenue@q.com> can be registered for 2 accounts via <avenue@q.com> and <AvEnUe@Q.CoM>.\n\nYou can set up email lower case normalization easily via a Mongoose setter.\n\n``` javascript\nfunction toLower(v) {\n  return v.toLowerCase();\n}\n\nconst UserSchema = new Schema({\n  email: { type: String, set: toLower }\n});\n\nconst User = db.model('User', UserSchema);\n\nconst user = new User({email: 'AVENUE@Q.COM'});\nconsole.log(user.email); // 'avenue@q.com'\n\n// or\nconst user = new User();\nuser.email = 'Avenue@Q.com';\nconsole.log(user.email); // 'avenue@q.com'\nUser.updateOne({ _id: _id }, { $set: { email: 'AVENUE@Q.COM' } }); // update to 'avenue@q.com'\n```\n\nAs you can see above, setters allow you to transform the data before it stored in MongoDB, or before executing a query.\n\n*NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function.*\n\n``` javascript\nnew Schema({ email: { type: String, lowercase: true }})\n```\n\nSetters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n\n``` javascript\nfunction inspector (val, priorValue, schematype) {\n  if (schematype.options.required) {\n    return schematype.path + ' is required';\n  } else {\n    return val;\n  }\n}\n\nconst VirusSchema = new Schema({\n  name: { type: String, required: true, set: inspector },\n  taxonomy: { type: String, set: inspector }\n})\n\nconst Virus = db.model('Virus', VirusSchema);\nconst v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });\n\nconsole.log(v.name);     // name is required\nconsole.log(v.taxonomy); // Parvovirinae\n```\n\nYou can also use setters to modify other properties on the document. If you're setting a property `name` on a document, the setter will run with `this` as the document. Be careful, in mongoose 5 setters will also run when querying by `name` with `this` as the query.\n\n``` javascript\nconst nameSchema = new Schema({ name: String, keywords: [String] });\nnameSchema.path('name').set(function(v) {\n  // Need to check if `this` is a document, because in mongoose 5\n  // setters will also run on queries, in which case `this` will be a\n  // mongoose query object.\n  if (this instanceof Document && v != null) {\n    this.keywords = v.split(' ');\n  }\n  return v;\n});\n```\n\n### SchemaType.prototype.sparse()\n\n##### Parameters:\n\n- `bool` «Boolean»\n\n##### Returns:\n\n- «SchemaType» this\n\nDeclares a sparse index.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ name: { type: String, sparse: true } });\ns.path('name').index({ sparse: true });\n```\n\n### SchemaType.prototype.text()\n\n##### Parameters:\n\n- `bool` «Boolean»\n\n##### Returns:\n\n- «SchemaType» this\n\nDeclares a full text index.\n\n### Example:\n\n``` javascript\n const s = new Schema({ name : { type: String, text : true } })\n s.path('name').index({ text : true });\n```\n\n### SchemaType.prototype.transform()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «SchemaType» this\n\nDefines a custom function for transforming this path when converting a document to JSON.\n\nMongoose calls this function with one parameter: the current `value` of the path. Mongoose then uses the return value in the JSON output.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({\n  date: { type: Date, transform: v => v.getFullYear() }\n});\nconst Model = mongoose.model('Test', schema);\n\nawait Model.create({ date: new Date('2016-06-01') });\nconst doc = await Model.findOne();\n\ndoc.date instanceof Date; // true\n\ndoc.toJSON().date; // 2016 as a number\nJSON.stringify(doc); // '{\"_id\":...,\"date\":2016}'\n```\n\n### SchemaType.prototype.unique()\n\n##### Parameters:\n\n- `bool` «Boolean»\n\n##### Returns:\n\n- «SchemaType» this\n\nDeclares an unique index.\n\n#### [Example:](#example)\n\n``` javascript\nconst s = new Schema({ name: { type: String, unique: true } });\ns.path('name').index({ unique: true });\n```\n\n*NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error.*\n\n### SchemaType.prototype.validate()\n\n##### Parameters:\n\n- `obj` «RegExp\\|Function\\|Object» validator function, or hash describing options\n\n&nbsp;\n\n- `[obj.validator]` «Function» validator function. If the validator function returns `undefined` or a truthy value, validation succeeds. If it returns [falsy](https://masteringjs.io/tutorials/fundamentals/falsy) (except `undefined`) or throws an error, validation fails.\n\n&nbsp;\n\n- `[obj.message]` «String\\|Function» optional error message. If function, should return the error message as a string\n\n&nbsp;\n\n- `[obj.propsParameter=false]` «Boolean» If true, Mongoose will pass the validator properties object (with the `validator` function, `message`, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators [rely on positional args](https://github.com/chriso/validator.js#validators), so turning this on may cause unpredictable behavior in external validators.\n\n&nbsp;\n\n- `[errorMsg]` «String\\|Function» optional error message. If function, should return the error message as a string\n- `[type]` «String» optional validator type\n\n##### Returns:\n\n- «SchemaType» this\n\nAdds validator(s) for this document path.\n\nValidators always receive the value to validate as their first argument and must return `Boolean`. Returning `false` or throwing an error means validation failed.\n\nThe error message argument is optional. If not passed, the [default generic error message template](error#Error.messages) will be used.\n\n#### [Example:](#example)\n\n``` javascript\n// make sure every value is equal to \"something\"\nfunction validator (val) {\n  return val === 'something';\n}\nnew Schema({ name: { type: String, validate: validator }});\n\n// with a custom error message\n\nconst custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\nnew Schema({ name: { type: String, validate: custom }});\n\n// adding many validators at a time\n\nconst many = [\n    { validator: validator, message: 'uh oh' }\n  , { validator: anotherValidator, message: 'failed' }\n]\nnew Schema({ name: { type: String, validate: many }});\n\n// or utilizing SchemaType methods directly:\n\nconst schema = new Schema({ name: 'string' });\nschema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n```\n\n#### [Error message templates:](#error-message-templates)\n\nBelow is a list of supported template keywords:\n\n- PATH: The schema path where the error is being triggered.\n- VALUE: The value assigned to the PATH that is triggering the error.\n- KIND: The validation property that triggered the error i.e. required.\n- REASON: The error object that caused this error if there was one.\n\nIf Mongoose's built-in error message templating isn't enough, Mongoose supports setting the `message` property to a function.\n\n``` javascript\nschema.path('name').validate({\n  validator: function(v) { return v.length > 5; },\n  // `errors['name']` will be \"name must have length 5, got 'foo'\"\n  message: function(props) {\n    return `${props.path} must have length 5, got '${props.value}'`;\n  }\n});\n```\n\nTo bypass Mongoose's error messages and just copy the error message that the validator throws, do this:\n\n``` javascript\nschema.path('name').validate({\n  validator: function() { throw new Error('Oops!'); },\n  // `errors['name']` will be \"Oops!\"\n  message: function(props) { return props.reason.message; }\n});\n```\n\n#### [Asynchronous validation:](#asynchronous-validation)\n\nMongoose supports validators that return a promise. A validator that returns a promise is called an *async validator*. Async validators run in parallel, and `validate()` will wait until all async validators have settled.\n\n``` javascript\nschema.path('name').validate({\n  validator: function (value) {\n    return new Promise(function (resolve, reject) {\n      resolve(false); // validation failed\n    });\n  }\n});\n```\n\nYou might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n\nValidation occurs `pre('save')` or whenever you manually execute [document#validate](document#Document.prototype.validate()).\n\nIf validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](connection#Connection()), passing the validation error object along.\n\n``` javascript\nconst conn = mongoose.createConnection(..);\nconn.on('error', handleError);\n\nconst Product = conn.model('Product', yourSchema);\nconst dvd = new Product(..);\ndvd.save(); // emits error on the `conn` above\n```\n\nIf you want to handle these errors at the Model level, add an `error` listener to your Model as shown below.\n\n``` javascript\n// registering an error listener on the Model lets us handle errors more locally\nProduct.on('error', handleError);\n```\n\n### SchemaType.prototype.validators\n\n##### Type:\n\n- «property»\n\nThe validators that Mongoose should run to validate properties at this SchemaType's path.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: { type: String, required: true } });\nschema.path('name').validators.length; // 1, the `required` validator\n```\n\n### SchemaType.set()\n\n##### Parameters:\n\n- `option` «String» The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n- `value` «Any» The value of the option you'd like to set.\n\n##### Returns:\n\n- «void,void»\n\nSets a default option for this schema type.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all strings be trimmed by default\nmongoose.SchemaTypes.String.set('trim', true);\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schematype.html](https://mongoosejs.com/docs/api/schematype.html)"
- name: SchemaType()
  id: api/schematype#SchemaType()
  summary: SchemaType constructor
  belongs_to: Schematype
  description: |-
    ### SchemaType()

    ##### Parameters:

    - `path` «String»
    - `[options]`«SchemaTypeOptions» See [SchemaTypeOptions docs](schematypeoptions)
    - `[instance]` «String»

    SchemaType constructor. Do **not** instantiate `SchemaType` directly. Mongoose converts your schema paths into SchemaTypes automatically.
- name: SchemaType.cast()
  id: api/schematype#SchemaType.cast()
  summary: Get/set the function used to cast arbitrary values to this type
  belongs_to: Schematype
  description: |-
    ### SchemaType.cast()

    ##### Parameters:

    - `caster`«Function\|false» Function that casts arbitrary values to this type, or throws an error if casting failed

    ##### Returns:

    - «Function»

    Get/set the function used to cast arbitrary values to this type.
- name: SchemaType.checkRequired()
  id: api/schematype#SchemaType.checkRequired()
  summary: Set & Get the checkRequired function Override the function the required validator uses to check whether a value passes the required check
  belongs_to: Schematype
  description: |-
    ### SchemaType.checkRequired()

    ##### Parameters:

    - `[fn]`«Function» If set, will overwrite the current set function

    ##### Returns:

    - «Function» The input `fn` or the already set function

    Set & Get the `checkRequired` function Override the function the required validator uses to check whether a value passes the `required` check. Override this on the individual SchemaType.
- name: SchemaType.get()
  id: api/schematype#SchemaType.get()
  summary: Attaches a getter for all instances of this schema type
  belongs_to: Schematype
  description: |-
    ### SchemaType.get()

    ##### Parameters:

    - `getter` «Function»

    ##### Returns:

    - «this»

    Attaches a getter for all instances of this schema type.
- name: SchemaType.prototype.cast()
  id: api/schematype#SchemaType.prototype.cast()
  summary: The function that Mongoose calls to cast arbitrary values to this SchemaType
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.cast()

    ##### Parameters:

    - `value`«Object» value to cast
    - `doc`«Document» document that triggers the casting
    - `init` «Boolean»

    The function that Mongoose calls to cast arbitrary values to this SchemaType.
- name: SchemaType.prototype.castFunction()
  id: api/schematype#SchemaType.prototype.castFunction()
  summary: Get/set the function used to cast arbitrary values to this particular schematype instance
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.castFunction()

    ##### Parameters:

    - `caster`«Function\|false» Function that casts arbitrary values to this type, or throws an error if casting failed

    ##### Returns:

    - «Function»

    Get/set the function used to cast arbitrary values to this particular schematype instance. Overrides `SchemaType.cast()`.
- name: SchemaType.prototype.default()
  id: api/schematype#SchemaType.prototype.default()
  summary: Sets a default value for this SchemaType
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.default()

    ##### Parameters:

    - `val`«Function\|any» The default value to set

    ##### Returns:

    - «Any,undefined,void» Returns the set default value.

    Sets a default value for this SchemaType.
- name: SchemaType.prototype.doValidate()
  id: api/schematype#SchemaType.prototype.doValidate()
  summary: Performs a validation of value using the validators declared for this SchemaType
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.doValidate()

    ##### Parameters:

    - `value` «Any»
    - `callback` «Function»
    - `scope` «Object»
    - `[options]` «Object»

    - `[options.path]` «String»

    ##### Returns:

    - «Any» If no validators, returns the output from calling `fn`, otherwise no return

    Performs a validation of `value` using the validators declared for this SchemaType.
- name: SchemaType.prototype.get()
  id: api/schematype#SchemaType.prototype.get()
  summary: Adds a getter to this schematype
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.get()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «SchemaType» this

    Adds a getter to this schematype.
- name: SchemaType.prototype.immutable()
  id: api/schematype#SchemaType.prototype.immutable()
  summary: Defines this path as immutable
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.immutable()

    ##### Parameters:

    - `bool` «Boolean»

    ##### Returns:

    - «SchemaType» this

    ##### See:

    -  [isNew](document#Document.prototype.isNew())

    Defines this path as immutable. Mongoose prevents you from changing immutable paths unless the parent document has [`isNew: true`](document#Document.prototype.isNew()).
- name: SchemaType.prototype.index()
  id: api/schematype#SchemaType.prototype.index()
  summary: Declares the index options for this schematype
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.index()

    ##### Parameters:

    - `options` «Object\|Boolean\|String\|Number»

    ##### Returns:

    - «SchemaType» this

    Declares the index options for this schematype.
- name: SchemaType.prototype.isRequired
  id: api/schematype#SchemaType.prototype.isRequired
  summary: True if this SchemaType has a required validator
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.isRequired

    ##### Type:

    - «property»

    True if this SchemaType has a required validator. False otherwise.
- name: SchemaType.prototype.path
  id: api/schematype#SchemaType.prototype.path
  summary: The path to this SchemaType in a Schema
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.path

    ##### Type:

    - «property»

    The path to this SchemaType in a Schema.
- name: SchemaType.prototype.ref()
  id: api/schematype#SchemaType.prototype.ref()
  summary: Set the model that this path refers to
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.ref()

    ##### Parameters:

    - `ref`«String\|Model\|Function» either a model name, a [Model](../models), or a function that returns a model name or model.

    ##### Returns:

    - «SchemaType» this

    Set the model that this path refers to. This is the option that [populate](../populate) looks at to determine the foreign collection it should query.
- name: SchemaType.prototype.required()
  id: api/schematype#SchemaType.prototype.required()
  summary: Adds a required validator to this SchemaType
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.required()

    ##### Parameters:

    - `required`«Boolean\|Function\|Object» enable/disable the validator, or function that returns required boolean, or options object

    &nbsp;

    - `[options.isRequired]`«Boolean\|Function» enable/disable the validator, or function that returns required boolean

    &nbsp;

    - `[options.ErrorConstructor]`«Function» custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.

    &nbsp;

    - `[message]`«String» optional custom error message

    ##### Returns:

    - «SchemaType» this

    ##### See:

    -  [Customized Error Messages](error#Error.messages)
    -  [SchemaArray#checkRequired](schemaarray#SchemaArray.prototype.checkRequired())
    -  [SchemaBoolean#checkRequired](schemaboolean#SchemaBoolean.prototype.checkRequired())
    -  [SchemaBuffer#checkRequired](schemabuffer#SchemaBuffer.prototype.checkRequired())
    -  [SchemaNumber#checkRequired](schemanumber#SchemaNumber.prototype.checkRequired())
    -  [SchemaObjectId#checkRequired](schemaobjectid#ObjectId.prototype.checkRequired())
    -  [SchemaString#checkRequired](schemastring#SchemaString.prototype.checkRequired())

    Adds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using `unshift()`.
- name: SchemaType.prototype.select()
  id: api/schematype#SchemaType.prototype.select()
  summary: Sets default select() behavior for this path
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.select()

    ##### Parameters:

    - `val` «Boolean»

    ##### Returns:

    - «SchemaType» this

    Sets default `select()` behavior for this path.

    Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.
- name: SchemaType.prototype.set()
  id: api/schematype#SchemaType.prototype.set()
  summary: Adds a setter to this schematype
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.set()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «SchemaType» this

    Adds a setter to this schematype.
- name: SchemaType.prototype.sparse()
  id: api/schematype#SchemaType.prototype.sparse()
  summary: Declares a sparse index
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.sparse()

    ##### Parameters:

    - `bool` «Boolean»

    ##### Returns:

    - «SchemaType» this

    Declares a sparse index.
- name: SchemaType.prototype.text()
  id: api/schematype#SchemaType.prototype.text()
  summary: Declares a full text index
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.text()

    ##### Parameters:

    - `bool` «Boolean»

    ##### Returns:

    - «SchemaType» this

    Declares a full text index.
- name: SchemaType.prototype.transform()
  id: api/schematype#SchemaType.prototype.transform()
  summary: Defines a custom function for transforming this path when converting a document to JSON
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.transform()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «SchemaType» this

    Defines a custom function for transforming this path when converting a document to JSON.

    Mongoose calls this function with one parameter: the current `value` of the path. Mongoose then uses the return value in the JSON output.
- name: SchemaType.prototype.unique()
  id: api/schematype#SchemaType.prototype.unique()
  summary: Declares an unique index
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.unique()

    ##### Parameters:

    - `bool` «Boolean»

    ##### Returns:

    - «SchemaType» this

    Declares an unique index.
- name: SchemaType.prototype.validate()
  id: api/schematype#SchemaType.prototype.validate()
  summary: Adds validator(s) for this document path
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.validate()

    ##### Parameters:

    - `obj`«RegExp\|Function\|Object» validator function, or hash describing options

    &nbsp;

    - `[obj.validator]`«Function» validator function. If the validator function returns `undefined` or a truthy value, validation succeeds. If it returns [falsy](https://masteringjs.io/tutorials/fundamentals/falsy) (except `undefined`) or throws an error, validation fails.

    &nbsp;

    - `[obj.message]`«String\|Function» optional error message. If function, should return the error message as a string

    &nbsp;

    - `[obj.propsParameter=false]`«Boolean» If true, Mongoose will pass the validator properties object (with the `validator` function, `message`, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators [rely on positional args](https://github.com/chriso/validator.js#validators), so turning this on may cause unpredictable behavior in external validators.

    &nbsp;

    - `[errorMsg]`«String\|Function» optional error message. If function, should return the error message as a string
    - `[type]`«String» optional validator type

    ##### Returns:

    - «SchemaType» this

    Adds validator(s) for this document path.

    Validators always receive the value to validate as their first argument and must return `Boolean`. Returning `false` or throwing an error means validation failed.

    The error message argument is optional. If not passed, the [default generic error message template](error#Error.messages) will be used.
- name: SchemaType.prototype.validators
  id: api/schematype#SchemaType.prototype.validators
  summary: The validators that Mongoose should run to validate properties at this SchemaType's path
  belongs_to: Schematype
  description: |-
    ### SchemaType.prototype.validators

    ##### Type:

    - «property»

    The validators that Mongoose should run to validate properties at this SchemaType's path.
- name: SchemaType.set()
  id: api/schematype#SchemaType.set()
  summary: Sets a default option for this schema type
  belongs_to: Schematype
  description: |-
    ### SchemaType.set()

    ##### Parameters:

    - `option`«String» The name of the option you'd like to set (e.g. trim, lowercase, etc...)
    - `value`«Any» The value of the option you'd like to set.

    ##### Returns:

    - «void,void»

    Sets a default option for this schema type.
- name: SchemaTypeOptions
  id: api/schematypeoptions
  summary: The options defined on a schematype
  description: "# SchemaTypeOptions\n\n### SchemaTypeOptions()\n\n##### Type:\n\n- «constructor»\n\nThe options defined on a schematype.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.path('name').options instanceof mongoose.SchemaTypeOptions; // true\n```\n\n### SchemaTypeOptions.prototype.cast\n\n##### Type:\n\n- «String»\n\nAllows overriding casting logic for this individual path. If a string, the given string overwrites Mongoose's default cast error message.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = new Schema({\n  num: {\n    type: Number,\n    cast: '{VALUE} is not a valid number'\n  }\n});\n\n// Throws 'CastError: \"bad\" is not a valid number'\nschema.path('num').cast('bad');\n\nconst Model = mongoose.model('Test', schema);\nconst doc = new Model({ num: 'fail' });\nconst err = doc.validateSync();\n\nerr.errors['num']; // 'CastError: \"fail\" is not a valid number'\n```\n\n### SchemaTypeOptions.prototype.default\n\n##### Type:\n\n- «Function\\|Any»\n\nThe default value for this path. If a function, Mongoose executes the function and uses the return value as the default.\n\n### SchemaTypeOptions.prototype.immutable\n\n##### Type:\n\n- «Function\\|Boolean»\n\nIf [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will disallow changes to this path once the document is saved to the database for the first time. Read more about [immutability in Mongoose here](https://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).\n\n### SchemaTypeOptions.prototype.index\n\n##### Type:\n\n- «Boolean\\|Number\\|Object»\n\nIf [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will build an index on this path when the model is compiled.\n\n### SchemaTypeOptions.prototype.ref\n\n##### Type:\n\n- «Function\\|String»\n\nThe model that `populate()` should use if populating this path.\n\n### SchemaTypeOptions.prototype.ref\n\n##### Type:\n\n- «Function\\|String»\n\nThe path in the document that `populate()` should use to find the model to use.\n\n### SchemaTypeOptions.prototype.required\n\n##### Type:\n\n- «Function\\|Boolean»\n\nIf true, attach a required validator to this path, which ensures this path cannot be set to a nullish value. If a function, Mongoose calls the function and only checks for nullish values if the function returns a truthy value.\n\n### SchemaTypeOptions.prototype.select\n\n##### Type:\n\n- «Boolean\\|Number»\n\nWhether to include or exclude this path by default when loading documents using `find()`, `findOne()`, etc.\n\n### SchemaTypeOptions.prototype.sparse\n\n##### Type:\n\n- «Boolean\\|Number»\n\nIf [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will build a sparse index on this path.\n\n### SchemaTypeOptions.prototype.text\n\n##### Type:\n\n- «Boolean\\|Number\\|Object»\n\nIf [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will build a text index on this path.\n\n### SchemaTypeOptions.prototype.transform\n\n##### Type:\n\n- «Function»\n\nDefine a transform function for this individual schema type. Only called when calling `toJSON()` or `toObject()`.\n\n#### [Example:](#example)\n\n``` javascript\nconst schema = Schema({\n  myDate: {\n    type: Date,\n    transform: v => v.getFullYear()\n  }\n});\nconst Model = mongoose.model('Test', schema);\n\nconst doc = new Model({ myDate: new Date('2019/06/01') });\ndoc.myDate instanceof Date; // true\n\nconst res = doc.toObject({ transform: true });\nres.myDate; // 2019\n```\n\n### SchemaTypeOptions.prototype.type\n\n##### Type:\n\n- «Function\\|String\\|Object»\n\nThe type to cast this path to.\n\n### SchemaTypeOptions.prototype.unique\n\n##### Type:\n\n- «Boolean\\|Number»\n\nIf [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will build a unique index on this path when the model is compiled. [The `unique` option is **not** a validator](../validation#the-unique-option-is-not-a-validator).\n\n### SchemaTypeOptions.prototype.validate\n\n##### Type:\n\n- «Function\\|Object»\n\nFunction or object describing how to validate this schematype.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schematypeoptions.html](https://mongoosejs.com/docs/api/schematypeoptions.html)"
- name: SchemaTypeOptions()
  id: api/schematypeoptions#SchemaTypeOptions()
  summary: The options defined on a schematype
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions()

    ##### Type:

    - «constructor»

    The options defined on a schematype.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({ name: String });
    schema.path('name').options instanceof mongoose.SchemaTypeOptions; // true
    ```
- name: SchemaTypeOptions.prototype.cast
  id: api/schematypeoptions#SchemaTypeOptions.prototype.cast
  summary: Allows overriding casting logic for this individual path
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.cast

    ##### Type:

    - «String»

    Allows overriding casting logic for this individual path. If a string, the given string overwrites Mongoose's default cast error message.

    #### [Example:](#example)

    ``` javascript
    const schema = new Schema({
      num: {
        type: Number,
        cast: '{VALUE} is not a valid number'
      }
    });

    // Throws 'CastError: "bad" is not a valid number'
    schema.path('num').cast('bad');

    const Model = mongoose.model('Test', schema);
    const doc = new Model({ num: 'fail' });
    const err = doc.validateSync();

    err.errors['num']; // 'CastError: "fail" is not a valid number'
    ```
- name: SchemaTypeOptions.prototype.default
  id: api/schematypeoptions#SchemaTypeOptions.prototype.default
  summary: The default value for this path
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.default

    ##### Type:

    - «Function\|Any»

    The default value for this path. If a function, Mongoose executes the function and uses the return value as the default.
- name: SchemaTypeOptions.prototype.immutable
  id: api/schematypeoptions#SchemaTypeOptions.prototype.immutable
  summary: If truthy, Mongoose will disallow changes to this path once the document is saved to the database for the first time
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.immutable

    ##### Type:

    - «Function\|Boolean»

    If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will disallow changes to this path once the document is saved to the database for the first time. Read more about [immutability in Mongoose here](https://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).
- name: SchemaTypeOptions.prototype.index
  id: api/schematypeoptions#SchemaTypeOptions.prototype.index
  summary: If truthy, Mongoose will build an index on this path when the model is compiled
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.index

    ##### Type:

    - «Boolean\|Number\|Object»

    If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will build an index on this path when the model is compiled.
- name: SchemaTypeOptions.prototype.ref
  id: api/schematypeoptions#SchemaTypeOptions.prototype.ref
  summary: The model that populate() should use if populating this path
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.ref

    ##### Type:

    - «Function\|String»

    The model that `populate()` should use if populating this path.

    ### SchemaTypeOptions.prototype.ref

    ##### Type:

    - «Function\|String»

    The path in the document that `populate()` should use to find the model to use.
- name: SchemaTypeOptions.prototype.required
  id: api/schematypeoptions#SchemaTypeOptions.prototype.required
  summary: If true, attach a required validator to this path, which ensures this path cannot be set to a nullish value
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.required

    ##### Type:

    - «Function\|Boolean»

    If true, attach a required validator to this path, which ensures this path cannot be set to a nullish value. If a function, Mongoose calls the function and only checks for nullish values if the function returns a truthy value.
- name: SchemaTypeOptions.prototype.select
  id: api/schematypeoptions#SchemaTypeOptions.prototype.select
  summary: Whether to include or exclude this path by default when loading documents using find(), findOne(), etc
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.select

    ##### Type:

    - «Boolean\|Number»

    Whether to include or exclude this path by default when loading documents using `find()`, `findOne()`, etc.
- name: SchemaTypeOptions.prototype.sparse
  id: api/schematypeoptions#SchemaTypeOptions.prototype.sparse
  summary: If truthy, Mongoose will build a sparse index on this path
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.sparse

    ##### Type:

    - «Boolean\|Number»

    If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will build a sparse index on this path.
- name: SchemaTypeOptions.prototype.text
  id: api/schematypeoptions#SchemaTypeOptions.prototype.text
  summary: If truthy, Mongoose will build a text index on this path
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.text

    ##### Type:

    - «Boolean\|Number\|Object»

    If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will build a text index on this path.
- name: SchemaTypeOptions.prototype.transform
  id: api/schematypeoptions#SchemaTypeOptions.prototype.transform
  summary: Define a transform function for this individual schema type
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.transform

    ##### Type:

    - «Function»

    Define a transform function for this individual schema type. Only called when calling `toJSON()` or `toObject()`.

    #### [Example:](#example)

    ``` javascript
    const schema = Schema({
      myDate: {
        type: Date,
        transform: v => v.getFullYear()
      }
    });
    const Model = mongoose.model('Test', schema);

    const doc = new Model({ myDate: new Date('2019/06/01') });
    doc.myDate instanceof Date; // true

    const res = doc.toObject({ transform: true });
    res.myDate; // 2019
    ```
- name: SchemaTypeOptions.prototype.type
  id: api/schematypeoptions#SchemaTypeOptions.prototype.type
  summary: The type to cast this path to
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.type

    ##### Type:

    - «Function\|String\|Object»

    The type to cast this path to.
- name: SchemaTypeOptions.prototype.unique
  id: api/schematypeoptions#SchemaTypeOptions.prototype.unique
  summary: If truthy, Mongoose will build a unique index on this path when the model is compiled
  belongs_to: SchemaTypeOptions
  description: |-
    ### SchemaTypeOptions.prototype.unique

    ##### Type:

    - «Boolean\|Number»

    If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will build a unique index on this path when the model is compiled. [The `unique` option is **not** a validator](../validation#the-unique-option-is-not-a-validator).
- name: SchemaTypeOptions.prototype.validate
  id: api/schematypeoptions#SchemaTypeOptions.prototype.validate
  summary: Function or object describing how to validate this schematype
  belongs_to: SchemaTypeOptions
  description: "### SchemaTypeOptions.prototype.validate\n\n##### Type:\n\n- «Function\\|Object»\n\nFunction or object describing how to validate this schematype.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/schematypeoptions.html](https://mongoosejs.com/docs/api/schematypeoptions.html)"
- name: SchemaTypes
  id: schematypes
  summary: SchemaTypes handle definition of path defaults, validation, getters, setters, field selection defaults for queries, and other general characteristics for Mongoose document properties
  description: "# SchemaTypes\n\nSchemaTypes handle definition of path [defaults](api/schematype#schematype_SchemaType-default), [validation](api/schematype#schematype_SchemaType-validate), [getters](#getters), [setters](api/schematype#schematype_SchemaType-set), [field selection defaults](api/schematype#schematype_SchemaType-select) for [queries](api/query), and other general characteristics for Mongoose document properties.\n\n- [What is a SchemaType?](#what-is-a-schematype)\n- [The `type` Key](#type-key)\n- [SchemaType Options](#schematype-options)\n- [Usage Notes](#usage-notes)\n- [Getters](#getters)\n- [Custom Types](#customtypes)\n- [The `schema.path()` Function](#path)\n- [Further Reading](#further-reading)\n\n## What is a SchemaType?\n\nYou can think of a Mongoose schema as the configuration object for a Mongoose model. A SchemaType is then a configuration object for an individual property. A SchemaType says what type a given path should have, whether it has any getters/setters, and what values are valid for that path.\n\n``` javascript\nconst schema = new Schema({ name: String });\nschema.path('name') instanceof mongoose.SchemaType; // true\nschema.path('name') instanceof mongoose.Schema.Types.String; // true\nschema.path('name').instance; // 'String'\n```\n\nA SchemaType is different from a type. In other words, `mongoose.ObjectId !== mongoose.Types.ObjectId`. A SchemaType is just a configuration object for Mongoose. An instance of the `mongoose.ObjectId` SchemaType doesn't actually create MongoDB ObjectIds, it is just a configuration for a path in a schema.\n\nThe following are all the valid SchemaTypes in Mongoose. Mongoose plugins can also add custom SchemaTypes like [int32](http://plugins.mongoosejs.io/plugins/int32). Check out [Mongoose's plugins search](http://plugins.mongoosejs.io) to find plugins.\n\n- [String](#strings)\n- [Number](#numbers)\n- [Date](#dates)\n- [Buffer](#buffers)\n- [Boolean](#booleans)\n- [Mixed](#mixed)\n- [ObjectId](#objectids)\n- [Array](#arrays)\n- [Decimal128](api/mongoose#mongoose_Mongoose-Decimal128)\n- [Map](#maps)\n- [Schema](#schemas)\n- [UUID](#uuid)\n- [BigInt](#bigint)\n\n### Example\n\n``` javascript\nconst schema = new Schema({\n  name: String,\n  binary: Buffer,\n  living: Boolean,\n  updated: { type: Date, default: Date.now },\n  age: { type: Number, min: 18, max: 65 },\n  mixed: Schema.Types.Mixed,\n  _someId: Schema.Types.ObjectId,\n  decimal: Schema.Types.Decimal128,\n  array: [],\n  ofString: [String],\n  ofNumber: [Number],\n  ofDates: [Date],\n  ofBuffer: [Buffer],\n  ofBoolean: [Boolean],\n  ofMixed: [Schema.Types.Mixed],\n  ofObjectId: [Schema.Types.ObjectId],\n  ofArrays: [[]],\n  ofArrayOfNumbers: [[Number]],\n  nested: {\n    stuff: { type: String, lowercase: true, trim: true }\n  },\n  map: Map,\n  mapOfString: {\n    type: Map,\n    of: String\n  }\n});\n\n// example use\n\nconst Thing = mongoose.model('Thing', schema);\n\nconst m = new Thing;\nm.name = 'Statue of Liberty';\nm.age = 125;\nm.updated = new Date;\nm.binary = Buffer.alloc(0);\nm.living = false;\nm.mixed = { any: { thing: 'i want' } };\nm.markModified('mixed');\nm._someId = new mongoose.Types.ObjectId;\nm.array.push(1);\nm.ofString.push('strings!');\nm.ofNumber.unshift(1, 2, 3, 4);\nm.ofDates.addToSet(new Date);\nm.ofBuffer.pop();\nm.ofMixed = [1, [], 'three', { four: 5 }];\nm.nested.stuff = 'good';\nm.map = new Map([['key', 'value']]);\nm.save(callback);\n```\n\n## The `type` Key\n\n`type` is a special property in Mongoose schemas. When Mongoose finds a nested property named `type` in your schema, Mongoose assumes that it needs to define a SchemaType with the given type.\n\n``` javascript\n// 3 string SchemaTypes: 'name', 'nested.firstName', 'nested.lastName'\nconst schema = new Schema({\n  name: { type: String },\n  nested: {\n    firstName: { type: String },\n    lastName: { type: String }\n  }\n});\n```\n\nAs a consequence, [you need a little extra work to define a property named `type` in your schema](https://mongoosejs.com/docs/faq.html#type-key). For example, suppose you're building a stock portfolio app, and you want to store the asset's `type` (stock, bond, ETF, etc.). Naively, you might define your schema as shown below:\n\n``` javascript\nconst holdingSchema = new Schema({\n  // You might expect `asset` to be an object that has 2 properties,\n  // but unfortunately `type` is special in Mongoose so mongoose\n  // interprets this schema to mean that `asset` is a string\n  asset: {\n    type: String,\n    ticker: String\n  }\n});\n```\n\nHowever, when Mongoose sees `type: String`, it assumes that you mean `asset` should be a string, not an object with a property `type`. The correct way to define an object with a property `type` is shown below.\n\n``` javascript\nconst holdingSchema = new Schema({\n  asset: {\n    // Workaround to make sure Mongoose knows `asset` is an object\n    // and `asset.type` is a string, rather than thinking `asset`\n    // is a string.\n    type: { type: String },\n    ticker: String\n  }\n});\n```\n\n## SchemaType Options\n\nYou can declare a schema type using the type directly, or an object with a `type` property.\n\n``` javascript\nconst schema1 = new Schema({\n  test: String // `test` is a path of type String\n});\n\nconst schema2 = new Schema({\n  // The `test` object contains the \"SchemaType options\"\n  test: { type: String } // `test` is a path of type string\n});\n```\n\nIn addition to the type property, you can specify additional properties for a path. For example, if you want to lowercase a string before saving:\n\n``` javascript\nconst schema2 = new Schema({\n  test: {\n    type: String,\n    lowercase: true // Always convert `test` to lowercase\n  }\n});\n```\n\nYou can add any property you want to your SchemaType options. Many plugins rely on custom SchemaType options. For example, the [mongoose-autopopulate](http://plugins.mongoosejs.io/plugins/autopopulate) plugin automatically populates paths if you set `autopopulate: true` in your SchemaType options. Mongoose comes with support for several built-in SchemaType options, like `lowercase` in the above example.\n\nThe `lowercase` option only works for strings. There are certain options which apply for all schema types, and some that apply for specific schema types.\n\n### All Schema Types\n\n- `required`: boolean or function, if true adds a [required validator](validation#built-in-validators) for this property\n- `default`: Any or function, sets a default value for the path. If the value is a function, the return value of the function is used as the default.\n- `select`: boolean, specifies default [projections](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/) for queries\n- `validate`: function, adds a [validator function](validation#built-in-validators) for this property\n- `get`: function, defines a custom getter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n- `set`: function, defines a custom setter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n- `alias`: string, mongoose \\>= 4.10.0 only. Defines a [virtual](guide#virtuals) with the given name that gets/sets this path.\n- `immutable`: boolean, defines path as immutable. Mongoose prevents you from changing immutable paths unless the parent document has `isNew: true`.\n- `transform`: function, Mongoose calls this function when you call [`Document#toJSON()`](api/document#document_Document-toJSON) function, including when you [`JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript) a document.\n\n``` javascript\nconst numberSchema = new Schema({\n  integerOnly: {\n    type: Number,\n    get: v => Math.round(v),\n    set: v => Math.round(v),\n    alias: 'i'\n  }\n});\n\nconst Number = mongoose.model('Number', numberSchema);\n\nconst doc = new Number();\ndoc.integerOnly = 2.001;\ndoc.integerOnly; // 2\ndoc.i; // 2\ndoc.i = 3.001;\ndoc.integerOnly; // 3\ndoc.i; // 3\n```\n\n### Indexes\n\nYou can also define [MongoDB indexes](https://www.mongodb.com/docs/manual/indexes/) using schema type options.\n\n- `index`: boolean, whether to define an [index](https://www.mongodb.com/docs/manual/indexes/) on this property.\n- `unique`: boolean, whether to define a [unique index](https://www.mongodb.com/docs/manual/core/index-unique/) on this property.\n- `sparse`: boolean, whether to define a [sparse index](https://www.mongodb.com/docs/manual/core/index-sparse/) on this property.\n\n``` javascript\nconst schema2 = new Schema({\n  test: {\n    type: String,\n    index: true,\n    unique: true // Unique index. If you specify `unique: true`\n    // specifying `index: true` is optional if you do `unique: true`\n  }\n});\n```\n\n### String\n\n- `lowercase`: boolean, whether to always call `.toLowerCase()` on the value\n- `uppercase`: boolean, whether to always call `.toUpperCase()` on the value\n- `trim`: boolean, whether to always call [`.trim()`](https://masteringjs.io/tutorials/fundamentals/trim-string) on the value\n- `match`: RegExp, creates a [validator](validation) that checks if the value matches the given regular expression\n- `enum`: Array, creates a [validator](validation) that checks if the value is in the given array.\n- `minLength`: Number, creates a [validator](validation) that checks if the value length is not less than the given number\n- `maxLength`: Number, creates a [validator](validation) that checks if the value length is not greater than the given number\n- `populate`: Object, sets default [populate options](populate#query-conditions)\n\n### Number\n\n- `min`: Number, creates a [validator](validation) that checks if the value is greater than or equal to the given minimum.\n- `max`: Number, creates a [validator](validation) that checks if the value is less than or equal to the given maximum.\n- `enum`: Array, creates a [validator](validation) that checks if the value is strictly equal to one of the values in the given array.\n- `populate`: Object, sets default [populate options](populate#query-conditions)\n\n### Date\n\n- `min`: Date, creates a [validator](validation) that checks if the value is greater than or equal to the given minimum.\n- `max`: Date, creates a [validator](validation) that checks if the value is less than or equal to the given maximum.\n- `expires`: Number or String, creates a TTL index with the value expressed in seconds.\n\n### ObjectId\n\n- `populate`: Object, sets default [populate options](populate#query-conditions)\n\n## Usage Notes\n\n### String\n\nTo declare a path as a string, you may use either the `String` global constructor or the string `'String'`.\n\n``` javascript\nconst schema1 = new Schema({ name: String }); // name will be cast to string\nconst schema2 = new Schema({ name: 'String' }); // Equivalent\n\nconst Person = mongoose.model('Person', schema2);\n```\n\nIf you pass an element that has a `toString()` function, Mongoose will call it, unless the element is an array or the `toString()` function is strictly equal to `Object.prototype.toString()`.\n\n``` javascript\nnew Person({ name: 42 }).name; // \"42\" as a string\nnew Person({ name: { toString: () => 42 } }).name; // \"42\" as a string\n\n// \"undefined\", will get a cast error if you `save()` this document\nnew Person({ name: { foo: 42 } }).name;\n```\n\n### Number\n\nTo declare a path as a number, you may use either the `Number` global constructor or the string `'Number'`.\n\n``` javascript\nconst schema1 = new Schema({ age: Number }); // age will be cast to a Number\nconst schema2 = new Schema({ age: 'Number' }); // Equivalent\n\nconst Car = mongoose.model('Car', schema2);\n```\n\nThere are several types of values that will be successfully cast to a Number.\n\n``` javascript\nnew Car({ age: '15' }).age; // 15 as a Number\nnew Car({ age: true }).age; // 1 as a Number\nnew Car({ age: false }).age; // 0 as a Number\nnew Car({ age: { valueOf: () => 83 } }).age; // 83 as a Number\n```\n\nIf you pass an object with a `valueOf()` function that returns a Number, Mongoose will call it and assign the returned value to the path.\n\nThe values `null` and `undefined` are not cast.\n\nNaN, strings that cast to NaN, arrays, and objects that don't have a `valueOf()` function will all result in a [CastError](validation#cast-errors) once validated, meaning that it will not throw on initialization, only when validated.\n\n### Dates\n\n[Built-in `Date` methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) are [**not** hooked into](https://github.com/Automattic/mongoose/issues/1598) the mongoose change tracking logic which in English means that if you use a `Date` in your document and modify it with a method like `setMonth()`, mongoose will be unaware of this change and `doc.save()` will not persist this modification. If you must modify `Date` types using built-in methods, tell mongoose about the change with `doc.markModified('pathToYourDate')` before saving.\n\n``` javascript\nconst Assignment = mongoose.model('Assignment', { dueDate: Date });\nconst doc = await Assignment.findOne();\ndoc.dueDate.setMonth(3);\nawait doc.save(); // THIS DOES NOT SAVE YOUR CHANGE\n\ndoc.markModified('dueDate');\nawait doc.save(); // works\n```\n\n### Buffer\n\nTo declare a path as a Buffer, you may use either the `Buffer` global constructor or the string `'Buffer'`.\n\n``` javascript\nconst schema1 = new Schema({ binData: Buffer }); // binData will be cast to a Buffer\nconst schema2 = new Schema({ binData: 'Buffer' }); // Equivalent\n\nconst Data = mongoose.model('Data', schema2);\n```\n\nMongoose will successfully cast the below values to buffers.\n\n``` javascript\nconst file1 = new Data({ binData: 'test'}); // {\"type\":\"Buffer\",\"data\":[116,101,115,116]}\nconst file2 = new Data({ binData: 72987 }); // {\"type\":\"Buffer\",\"data\":[27]}\nconst file4 = new Data({ binData: { type: 'Buffer', data: [1, 2, 3]}}); // {\"type\":\"Buffer\",\"data\":[1,2,3]}\n```\n\n### Mixed\n\nAn \"anything goes\" SchemaType. Mongoose will not do any casting on mixed paths. You can define a mixed path using `Schema.Types.Mixed` or by passing an empty object literal. The following are equivalent.\n\n``` javascript\nconst Any = new Schema({ any: {} });\nconst Any = new Schema({ any: Object });\nconst Any = new Schema({ any: Schema.Types.Mixed });\nconst Any = new Schema({ any: mongoose.Mixed });\n```\n\nSince Mixed is a schema-less type, you can change the value to anything else you like, but Mongoose loses the ability to auto detect and save those changes. To tell Mongoose that the value of a Mixed type has changed, you need to call `doc.markModified(path)`, passing the path to the Mixed type you just changed.\n\nTo avoid these side-effects, a [Subdocument](subdocs) path may be used instead.\n\n``` javascript\nperson.anything = { x: [3, 4, { y: 'changed' }] };\nperson.markModified('anything');\nperson.save(); // Mongoose will save changes to `anything`.\n```\n\n### ObjectIds\n\nAn [ObjectId](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) is a special type typically used for unique identifiers. Here's how you declare a schema with a path `driver` that is an ObjectId:\n\n``` javascript\nconst mongoose = require('mongoose');\nconst carSchema = new mongoose.Schema({ driver: mongoose.ObjectId });\n```\n\n`ObjectId` is a class, and ObjectIds are objects. However, they are often represented as strings. When you convert an ObjectId to a string using `toString()`, you get a 24-character hexadecimal string:\n\n``` javascript\nconst Car = mongoose.model('Car', carSchema);\n\nconst car = new Car();\ncar.driver = new mongoose.Types.ObjectId();\n\ntypeof car.driver; // 'object'\ncar.driver instanceof mongoose.Types.ObjectId; // true\n\ncar.driver.toString(); // Something like \"5e1a0651741b255ddda996c4\"\n```\n\n### Boolean\n\nBooleans in Mongoose are [plain JavaScript booleans](https://www.w3schools.com/js/js_booleans.asp). By default, Mongoose casts the below values to `true`:\n\n- `true`\n- `'true'`\n- `1`\n- `'1'`\n- `'yes'`\n\nMongoose casts the below values to `false`:\n\n- `false`\n- `'false'`\n- `0`\n- `'0'`\n- `'no'`\n\nAny other value causes a [CastError](validation#cast-errors). You can modify what values Mongoose converts to true or false using the `convertToTrue` and `convertToFalse` properties, which are [JavaScript sets](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set).\n\n``` javascript\nconst M = mongoose.model('Test', new Schema({ b: Boolean }));\nconsole.log(new M({ b: 'nay' }).b); // undefined\n\n// Set { false, 'false', 0, '0', 'no' }\nconsole.log(mongoose.Schema.Types.Boolean.convertToFalse);\n\nmongoose.Schema.Types.Boolean.convertToFalse.add('nay');\nconsole.log(new M({ b: 'nay' }).b); // false\n```\n\n### Arrays\n\nMongoose supports arrays of [SchemaTypes](api/schema#schema_Schema-Types) and arrays of [subdocuments](subdocs). Arrays of SchemaTypes are also called *primitive arrays*, and arrays of subdocuments are also called *document arrays*.\n\n``` javascript\nconst ToySchema = new Schema({ name: String });\nconst ToyBoxSchema = new Schema({\n  toys: [ToySchema],\n  buffers: [Buffer],\n  strings: [String],\n  numbers: [Number]\n  // ... etc\n});\n```\n\nArrays are special because they implicitly have a default value of `[]` (empty array).\n\n``` javascript\nconst ToyBox = mongoose.model('ToyBox', ToyBoxSchema);\nconsole.log((new ToyBox()).toys); // []\n```\n\nTo overwrite this default, you need to set the default value to `undefined`\n\n``` javascript\nconst ToyBoxSchema = new Schema({\n  toys: {\n    type: [ToySchema],\n    default: undefined\n  }\n});\n```\n\nNote: specifying an empty array is equivalent to `Mixed`. The following all create arrays of `Mixed`:\n\n``` javascript\nconst Empty1 = new Schema({ any: [] });\nconst Empty2 = new Schema({ any: Array });\nconst Empty3 = new Schema({ any: [Schema.Types.Mixed] });\nconst Empty4 = new Schema({ any: [{}] });\n```\n\n### Maps\n\nA `MongooseMap` is a subclass of [JavaScript's `Map` class](http://thecodebarbarian.com/the-80-20-guide-to-maps-in-javascript.html). In these docs, we'll use the terms 'map' and `MongooseMap` interchangeably. In Mongoose, maps are how you create a nested document with arbitrary keys.\n\n**Note**: In Mongoose Maps, keys must be strings in order to store the document in MongoDB.\n\n``` javascript\nconst userSchema = new Schema({\n  // `socialMediaHandles` is a map whose values are strings. A map's\n  // keys are always strings. You specify the type of values using `of`.\n  socialMediaHandles: {\n    type: Map,\n    of: String\n  }\n});\n\nconst User = mongoose.model('User', userSchema);\n// Map { 'github' => 'vkarpov15', 'twitter' => '@code_barbarian' }\nconsole.log(new User({\n  socialMediaHandles: {\n    github: 'vkarpov15',\n    twitter: '@code_barbarian'\n  }\n}).socialMediaHandles);\n```\n\nThe above example doesn't explicitly declare `github` or `twitter` as paths, but, since `socialMediaHandles` is a map, you can store arbitrary key/value pairs. However, since `socialMediaHandles` is a map, you **must** use `.get()` to get the value of a key and `.set()` to set the value of a key.\n\n``` javascript\nconst user = new User({\n  socialMediaHandles: {}\n});\n\n// Good\nuser.socialMediaHandles.set('github', 'vkarpov15');\n// Works too\nuser.set('socialMediaHandles.twitter', '@code_barbarian');\n// Bad, the `myspace` property will **not** get saved\nuser.socialMediaHandles.myspace = 'fail';\n\n// 'vkarpov15'\nconsole.log(user.socialMediaHandles.get('github'));\n// '@code_barbarian'\nconsole.log(user.get('socialMediaHandles.twitter'));\n// undefined\nuser.socialMediaHandles.github;\n\n// Will only save the 'github' and 'twitter' properties\nuser.save();\n```\n\nMap types are stored as [BSON objects in MongoDB](https://en.wikipedia.org/wiki/BSON#Data_types_and_syntax). Keys in a BSON object are ordered, so this means the [insertion order](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Description) property of maps is maintained.\n\nMongoose supports a special `$*` syntax to [populate](populate) all elements in a map. For example, suppose your `socialMediaHandles` map contains a `ref`:\n\n``` javascript\nconst userSchema = new Schema({\n  socialMediaHandles: {\n    type: Map,\n    of: new Schema({\n      handle: String,\n      oauth: {\n        type: ObjectId,\n        ref: 'OAuth'\n      }\n    })\n  }\n});\nconst User = mongoose.model('User', userSchema);\n```\n\nTo populate every `socialMediaHandles` entry's `oauth` property, you should populate on `socialMediaHandles.$*.oauth`:\n\n``` javascript\nconst user = await User.findOne().populate('socialMediaHandles.$*.oauth');\n```\n\n### UUID\n\nMongoose also supports a UUID type that stores UUID instances as [Node.js buffers](https://thecodebarbarian.com/an-overview-of-buffers-in-node-js.html). We recommend using [ObjectIds](#objectids) rather than UUIDs for unique document ids in Mongoose, but you may use UUIDs if you need to.\n\nIn Node.js, a UUID is represented as an instance of `bson.Binary` type with a [getter](tutorials/getters-setters) that converts the binary to a string when you access it. Mongoose stores UUIDs as [binary data with subtype 4 in MongoDB](https://www.mongodb.com/docs/manual/reference/bson-types/#binary-data).\n\n``` javascript\nconst authorSchema = new Schema({\n  _id: Schema.Types.UUID, // Can also do `_id: 'UUID'`\n  name: String\n});\n\nconst Author = mongoose.model('Author', authorSchema);\n\nconst bookSchema = new Schema({\n  authorId: { type: Schema.Types.UUID, ref: 'Author' }\n});\nconst Book = mongoose.model('Book', bookSchema);\n\nconst author = new Author({ name: 'Martin Fowler' });\nconsole.log(typeof author._id); // 'string'\nconsole.log(author.toObject()._id instanceof mongoose.mongo.BSON.Binary); // true\n\nconst book = new Book({ authorId: '09190f70-3d30-11e5-8814-0f4df9a59c41' });\n```\n\nTo create UUIDs, we recommend using [Node's built-in UUIDv4 generator](https://nodejs.org/api/crypto.html#cryptorandomuuidoptions).\n\n``` javascript\nconst { randomUUID } = require('crypto');\n\nconst schema = new mongoose.Schema({\n  docId: {\n    type: 'UUID',\n    default: () => randomUUID()\n  }\n});\n```\n\n### BigInt\n\nMongoose supports [JavaScript BigInts](https://thecodebarbarian.com/an-overview-of-bigint-in-node-js.html) as a SchemaType. BigInts are stored as [64-bit integers in MongoDB (BSON type \"long\")](https://www.mongodb.com/docs/manual/reference/bson-types/).\n\n``` javascript\nconst questionSchema = new Schema({\n  answer: BigInt\n});\nconst Question = mongoose.model('Question', questionSchema);\n\nconst question = new Question({ answer: 42n });\ntypeof question.answer; // 'bigint'\n```\n\n## Getters\n\nGetters are like virtuals for paths defined in your schema. For example, let's say you wanted to store user profile pictures as relative paths and then add the hostname in your application. Below is how you would structure your `userSchema`:\n\n``` javascript\nconst root = 'https://s3.amazonaws.com/mybucket';\n\nconst userSchema = new Schema({\n  name: String,\n  picture: {\n    type: String,\n    get: v => `${root}${v}`\n  }\n});\n\nconst User = mongoose.model('User', userSchema);\n\nconst doc = new User({ name: 'Val', picture: '/123.png' });\ndoc.picture; // 'https://s3.amazonaws.com/mybucket/123.png'\ndoc.toObject({ getters: false }).picture; // '/123.png'\n```\n\nGenerally, you only use getters on primitive paths as opposed to arrays or subdocuments. Because getters override what accessing a Mongoose path returns, declaring a getter on an object may remove Mongoose change tracking for that path.\n\n``` javascript\nconst schema = new Schema({\n  arr: [{ url: String }]\n});\n\nconst root = 'https://s3.amazonaws.com/mybucket';\n\n// Bad, don't do this!\nschema.path('arr').get(v => {\n  return v.map(el => Object.assign(el, { url: root + el.url }));\n});\n\n// Later\ndoc.arr.push({ key: String });\ndoc.arr[0]; // 'undefined' because every `doc.arr` creates a new array!\n```\n\nInstead of declaring a getter on the array as shown above, you should declare a getter on the `url` string as shown below. If you need to declare a getter on a nested document or array, be very careful!\n\n``` javascript\nconst schema = new Schema({\n  arr: [{ url: String }]\n});\n\nconst root = 'https://s3.amazonaws.com/mybucket';\n\n// Good, do this instead of declaring a getter on `arr`\nschema.path('arr.0.url').get(v => `${root}${v}`);\n```\n\n## Schemas\n\nTo declare a path as another [schema](guide#definition), set `type` to the sub-schema's instance.\n\nTo set a default value based on the sub-schema's shape, simply set a default value, and the value will be cast based on the sub-schema's definition before being set during document creation.\n\n``` javascript\nconst subSchema = new mongoose.Schema({\n  // some schema definition here\n});\n\nconst schema = new mongoose.Schema({\n  data: {\n    type: subSchema,\n    default: {}\n  }\n});\n```\n\n## Creating Custom Types\n\nMongoose can also be extended with [custom SchemaTypes](customschematypes). Search the [plugins](http://plugins.mongoosejs.io) site for compatible types like [mongoose-long](https://github.com/aheckmann/mongoose-long), [mongoose-int32](https://github.com/vkarpov15/mongoose-int32), and [mongoose-function](https://github.com/aheckmann/mongoose-function).\n\nRead more about creating custom SchemaTypes [here](customschematypes).\n\n## The \\`schema.path()\\` Function\n\nThe `schema.path()` function returns the instantiated schema type for a given path.\n\n``` javascript\nconst sampleSchema = new Schema({ name: { type: String, required: true } });\nconsole.log(sampleSchema.path('name'));\n// Output looks like:\n/**\n * SchemaString {\n *   enumValues: [],\n  *   regExp: null,\n  *   path: 'name',\n  *   instance: 'String',\n  *   validators: ...\n  */\n```\n\nYou can use this function to inspect the schema type for a given path, including what validators it has and what the type is.\n\n## Further Reading\n\n- [An Introduction to Mongoose SchemaTypes](https://masteringjs.io/tutorials/mongoose/schematype)\n- [Mongoose Schema Types](https://kb.objectrocket.com/mongo-db/mongoose-schema-types-1418)\n\n## Next Up\n\nNow that we've covered `SchemaTypes`, let's take a look at [Connections](connections).\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/schematypes.html](https://mongoosejs.com/docs/schematypes.html)"
- name: String
  id: schematypes#string-validators
  summary: null
  belongs_to: SchemaTypes
  description: |-
    ### String

    - `lowercase`: boolean, whether to always call `.toLowerCase()` on the value
    - `uppercase`: boolean, whether to always call `.toUpperCase()` on the value
    - `trim`: boolean, whether to always call [`.trim()`](https://masteringjs.io/tutorials/fundamentals/trim-string) on the value
    - `match`: RegExp, creates a [validator](validation) that checks if the value matches the given regular expression
    - `enum`: Array, creates a [validator](validation) that checks if the value is in the given array.
    - `minLength`: Number, creates a [validator](validation) that checks if the value length is not less than the given number
    - `maxLength`: Number, creates a [validator](validation) that checks if the value length is not greater than the given number
    - `populate`: Object, sets default [populate options](populate#query-conditions)
- name: String
  id: schematypes#strings
  summary: If you pass an element that has a toString() function, Mongoose will call it, unless the element is an array or the toString() function is strictly equal to Object.prototype.toString()
  belongs_to: SchemaTypes
  description: |-
    ### String

    To declare a path as a string, you may use either the `String` global constructor or the string `'String'`.

    ``` javascript
    const schema1 = new Schema({ name: String }); // name will be cast to string
    const schema2 = new Schema({ name: 'String' }); // Equivalent

    const Person = mongoose.model('Person', schema2);
    ```

    If you pass an element that has a `toString()` function, Mongoose will call it, unless the element is an array or the `toString()` function is strictly equal to `Object.prototype.toString()`.

    ``` javascript
    newPerson({ name: 42 }).name; // "42" as a string
    new Person({ name: { toString: () => 42 } }).name; // "42" as a string

    // "undefined", will get a cast error if you `save()` this document
    new Person({ name: { foo: 42 } }).name;
    ```
- name: Subdocument
  id: api/subdocument
  summary: Returns this sub-documents parent document
  description: "# Subdocument\n\n### Subdocument.prototype.$parent()\n\nReturns this sub-documents parent document.\n\n### Subdocument.prototype.deleteOne()\n\n##### Parameters:\n\n- `[options]` «Object»\n- `[callback]` «Function» optional callback for compatibility with Document.prototype.remove\n\nNull-out this subdoc\n\n### Subdocument.prototype.inspect()\n\nHelper for console.log\n\n### Subdocument.prototype.ownerDocument()\n\n##### Returns:\n\n- «Document»\n\nReturns the top level document of this sub-document.\n\n### Subdocument.prototype.parent()\n\nReturns this sub-documents parent document.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/subdocument.html](https://mongoosejs.com/docs/api/subdocument.html)"
- name: Subdocument.prototype.$parent()
  id: api/subdocument#Subdocument.prototype.$parent()
  summary: Returns this sub-documents parent document
  belongs_to: Subdocument
  description: |-
    ### Subdocument.prototype.$parent()

    Returns this sub-documents parent document.
- name: Subdocument.prototype.deleteOne()
  id: api/subdocument#Subdocument.prototype.deleteOne()
  summary: null
  belongs_to: Subdocument
  description: |-
    ### Subdocument.prototype.deleteOne()

    ##### Parameters:

    - `[options]` «Object»
    - `[callback]`«Function» optional callback for compatibility with Document.prototype.remove

    Null-out this subdoc
- name: Subdocument.prototype.inspect()
  id: api/subdocument#Subdocument.prototype.inspect()
  summary: null
  belongs_to: Subdocument
  description: |-
    ### Subdocument.prototype.inspect()

    Helper for console.log
- name: Subdocument.prototype.ownerDocument()
  id: api/subdocument#Subdocument.prototype.ownerDocument()
  summary: Returns the top level document of this sub-document
  belongs_to: Subdocument
  description: |-
    ### Subdocument.prototype.ownerDocument()

    ##### Returns:

    - «Document»

    Returns the top level document of this sub-document.
- name: Subdocument.prototype.parent()
  id: api/subdocument#Subdocument.prototype.parent()
  summary: Returns this sub-documents parent document
  belongs_to: Subdocument
  description: "### Subdocument.prototype.parent()\n\nReturns this sub-documents parent document.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/subdocument.html](https://mongoosejs.com/docs/api/subdocument.html)"
- name: SubdocumentPath
  id: api/subdocumentpath
  summary: Single nested subdocument SchemaType constructor
  description: "# SubdocumentPath\n\n### SubdocumentPath()\n\n##### Parameters:\n\n- `schema` «Schema»\n- `path` «String»\n- `options` «Object»\n\n##### Inherits:\n\n- [«SchemaType»](schematype)\n\nSingle nested subdocument SchemaType constructor.\n\n### SubdocumentPath.get()\n\n##### Parameters:\n\n- `getter` «Function»\n\n##### Returns:\n\n- «this»\n\n##### Type:\n\n- «property»\n\nAttaches a getter for all SubdocumentPath instances\n\n### SubdocumentPath.prototype.discriminator()\n\n##### Parameters:\n\n- `name` «String»\n- `schema` «Schema» fields to add to the schema for instances of this sub-class\n- `[options]` «Object\\|string» If string, same as `options.value`.\n\n- `[options.value]` «String» the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n\n&nbsp;\n\n- `[options.clone=true]` «Boolean» By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n\n##### Returns:\n\n- «Function» the constructor Mongoose will use for creating instances of this discriminator model\n\n##### See:\n\n- [discriminators](../discriminators)\n\nAdds a discriminator to this single nested subdocument.\n\n#### [Example:](#example)\n\n``` javascript\nconst shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\nconst schema = Schema({ shape: shapeSchema });\n\nconst singleNestedPath = parentSchema.path('shape');\nsingleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n```\n\n### SubdocumentPath.set()\n\n##### Parameters:\n\n- `option` «String» The option you'd like to set the value for\n- `value` «Any» value for option\n\n##### Returns:\n\n- «void,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all SubdocumentPath instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all numbers have option `min` equal to 0.\nmongoose.Schema.SubdocumentPath.set('required', true);\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/subdocumentpath.html](https://mongoosejs.com/docs/api/subdocumentpath.html)"
- name: SubdocumentPath()
  id: api/subdocumentpath#SubdocumentPath()
  summary: Single nested subdocument SchemaType constructor
  belongs_to: SubdocumentPath
  description: |-
    ### SubdocumentPath()

    ##### Parameters:

    - `schema` «Schema»
    - `path` «String»
    - `options` «Object»

    ##### Inherits:

    -  [«SchemaType»](schematype)

    Single nested subdocument SchemaType constructor.
- name: SubdocumentPath.get()
  id: api/subdocumentpath#SubdocumentPath.get()
  summary: null
  belongs_to: SubdocumentPath
  description: |-
    ### SubdocumentPath.get()

    ##### Parameters:

    - `getter` «Function»

    ##### Returns:

    - «this»

    ##### Type:

    - «property»

    Attaches a getter for all SubdocumentPath instances
- name: SubdocumentPath.prototype.discriminator()
  id: api/subdocumentpath#SubdocumentPath.prototype.discriminator()
  summary: '[options]«Object|string» If string, same as options.value'
  belongs_to: SubdocumentPath
  description: |-
    ### SubdocumentPath.prototype.discriminator()

    ##### Parameters:

    - `name` «String»
    - `schema`«Schema» fields to add to the schema for instances of this sub-class
    - `[options]`«Object\|string» If string, same as `options.value`.

    - `[options.value]`«String» the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.

    &nbsp;

    - `[options.clone=true]`«Boolean» By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.

    ##### Returns:

    - «Function» the constructor Mongoose will use for creating instances of this discriminator model

    ##### See:

    -  [discriminators](../discriminators)

    Adds a discriminator to this single nested subdocument.

    #### [Example:](#example)

    ``` javascript
    const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });
    const schema = Schema({ shape: shapeSchema });

    const singleNestedPath = parentSchema.path('shape');
    singleNestedPath.discriminator('Circle', Schema({ radius: Number }));
    ```
- name: SubdocumentPath.set()
  id: api/subdocumentpath#SubdocumentPath.set()
  summary: Sets a default option for all SubdocumentPath instances
  belongs_to: SubdocumentPath
  description: "### SubdocumentPath.set()\n\n##### Parameters:\n\n- `option`«String» The option you'd like to set the value for\n- `value`«Any» value for option\n\n##### Returns:\n\n- «void,void»\n\n##### Type:\n\n- «property»\n\nSets a default option for all SubdocumentPath instances.\n\n#### [Example:](#example)\n\n``` javascript\n// Make all numbers have option `min` equal to 0.\nmongoose.Schema.SubdocumentPath.set('required', true);\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/subdocumentpath.html](https://mongoosejs.com/docs/api/subdocumentpath.html)"
- name: Subdocuments
  id: subdocs
  summary: Subdocuments are documents embedded in other documents
  description: "# Subdocuments\n\nSubdocuments are documents embedded in other documents. In Mongoose, this means you can nest schemas in other schemas. Mongoose has two distinct notions of subdocuments: [arrays of subdocuments](https://masteringjs.io/tutorials/mongoose/array#document-arrays) and single nested subdocuments.\n\n``` javascript\nconst childSchema = new Schema({ name: 'string' });\n\nconst parentSchema = new Schema({\n  // Array of subdocuments\n  children: [childSchema],\n  // Single nested subdocuments\n  child: childSchema\n});\n```\n\nNote that populated documents are **not** subdocuments in Mongoose. Subdocument data is embedded in the top-level document. Referenced documents are separate top-level documents.\n\n``` javascript\nconst childSchema = new Schema({ name: 'string' });\nconst Child = mongoose.model('Child', childSchema);\n\nconst parentSchema = new Schema({\n  child: {\n    type: mongoose.ObjectId,\n    ref: 'Child'\n  }\n});\nconst Parent = mongoose.model('Parent', parentSchema);\n\nconst doc = await Parent.findOne().populate('child');\n// NOT a subdocument. `doc.child` is a separate top-level document.\ndoc.child;\n```\n\n## What is a Subdocument?\n\nSubdocuments are similar to normal documents. Nested schemas can have [middleware](middleware), [custom validation logic](validation), virtuals, and any other feature top-level schemas can use. The major difference is that subdocuments are not saved individually, they are saved whenever their top-level parent document is saved.\n\n``` javascript\nconst Parent = mongoose.model('Parent', parentSchema);\nconst parent = new Parent({ children: [{ name: 'Matt' }, { name: 'Sarah' }] });\nparent.children[0].name = 'Matthew';\n\n// `parent.children[0].save()` is a no-op, it triggers middleware but\n// does **not** actually save the subdocument. You need to save the parent\n// doc.\nawait parent.save();\n```\n\nSubdocuments have `save` and `validate` [middleware](middleware) just like top-level documents. Calling `save()` on the parent document triggers the `save()` middleware for all its subdocuments, and the same for `validate()` middleware.\n\n``` javascript\nchildSchema.pre('save', function(next) {\n  if ('invalid' == this.name) {\n    return next(new Error('#sadpanda'));\n  }\n  next();\n});\n\nconst parent = new Parent({ children: [{ name: 'invalid' }] });\ntry {\n  await parent.save();\n} catch (err) {\n  err.message; // '#sadpanda'\n}\n```\n\nSubdocuments' `pre('save')` and `pre('validate')` middleware execute **before** the top-level document's `pre('save')` but **after** the top-level document's `pre('validate')` middleware. This is because validating before `save()` is actually a piece of built-in middleware.\n\n``` javascript\n// Below code will print out 1-4 in order\nconst childSchema = new mongoose.Schema({ name: 'string' });\n\nchildSchema.pre('validate', function(next) {\n  console.log('2');\n  next();\n});\n\nchildSchema.pre('save', function(next) {\n  console.log('3');\n  next();\n});\n\nconst parentSchema = new mongoose.Schema({\n  child: childSchema\n});\n\nparentSchema.pre('validate', function(next) {\n  console.log('1');\n  next();\n});\n\nparentSchema.pre('save', function(next) {\n  console.log('4');\n  next();\n});\n```\n\n## Subdocuments versus Nested Paths\n\nIn Mongoose, nested paths are subtly different from subdocuments. For example, below are two schemas: one with `child` as a subdocument, and one with `child` as a nested path.\n\n``` javascript\n// Subdocument\nconst subdocumentSchema = new mongoose.Schema({\n  child: new mongoose.Schema({ name: String, age: Number })\n});\nconst Subdoc = mongoose.model('Subdoc', subdocumentSchema);\n\n// Nested path\nconst nestedSchema = new mongoose.Schema({\n  child: { name: String, age: Number }\n});\nconst Nested = mongoose.model('Nested', nestedSchema);\n```\n\nThese two schemas look similar, and the documents in MongoDB will have the same structure with both schemas. But there are a few Mongoose-specific differences:\n\nFirst, instances of `Nested` never have `child === undefined`. You can always set subproperties of `child`, even if you don't set the `child` property. But instances of `Subdoc` can have `child === undefined`.\n\n``` javascript\nconst doc1 = new Subdoc({});\ndoc1.child === undefined; // true\ndoc1.child.name = 'test'; // Throws TypeError: cannot read property...\n\nconst doc2 = new Nested({});\ndoc2.child === undefined; // false\nconsole.log(doc2.child); // Prints 'MongooseDocument { undefined }'\ndoc2.child.name = 'test'; // Works\n```\n\n## Subdocument Defaults\n\nSubdocument paths are undefined by default, and Mongoose does not apply subdocument defaults unless you set the subdocument path to a non-nullish value.\n\n``` javascript\nconst subdocumentSchema = new mongoose.Schema({\n  child: new mongoose.Schema({\n    name: String,\n    age: {\n      type: Number,\n      default: 0\n    }\n  })\n});\nconst Subdoc = mongoose.model('Subdoc', subdocumentSchema);\n\n// Note that the `age` default has no effect, because `child`\n// is `undefined`.\nconst doc = new Subdoc();\ndoc.child; // undefined\n```\n\nHowever, if you set `doc.child` to any object, Mongoose will apply the `age` default if necessary.\n\n``` javascript\ndoc.child = {};\n// Mongoose applies the `age` default:\ndoc.child.age; // 0\n```\n\nMongoose applies defaults recursively, which means there's a nice workaround if you want to make sure Mongoose applies subdocument defaults: make the subdocument path default to an empty object.\n\n``` javascript\nconst childSchema = new mongoose.Schema({\n  name: String,\n  age: {\n    type: Number,\n    default: 0\n  }\n});\nconst subdocumentSchema = new mongoose.Schema({\n  child: {\n    type: childSchema,\n    default: () => ({})\n  }\n});\nconst Subdoc = mongoose.model('Subdoc', subdocumentSchema);\n\n// Note that Mongoose sets `age` to its default value 0, because\n// `child` defaults to an empty object and Mongoose applies\n// defaults to that empty object.\nconst doc = new Subdoc();\ndoc.child; // { age: 0 }\n```\n\n## Finding a Subdocument\n\nEach subdocument has an `_id` by default. Mongoose document arrays have a special [id](api/mongoosedocumentarray#mongoosedocumentarray_MongooseDocumentArray-id) method for searching a document array to find a document with a given `_id`.\n\n``` javascript\nconst doc = parent.children.id(_id);\n```\n\n## Adding Subdocs to Arrays\n\nMongooseArray methods such as `push`, `unshift`, `addToSet`, and others cast arguments to their proper types transparently:\n\n``` javascript\nconst Parent = mongoose.model('Parent');\nconst parent = new Parent();\n\n// create a comment\nparent.children.push({ name: 'Liesl' });\nconst subdoc = parent.children[0];\nconsole.log(subdoc); // { _id: '501d86090d371bab2c0341c5', name: 'Liesl' }\nsubdoc.isNew; // true\n\nawait parent.save();\nconsole.log('Success!');\n```\n\nYou can also create a subdocument without adding it to an array by using the [`create()` method](api/mongoosedocumentarray#mongoosedocumentarray_MongooseDocumentArray-create) of Document Arrays.\n\n``` javascript\nconst newdoc = parent.children.create({ name: 'Aaron' });\n```\n\n## Removing Subdocs\n\nEach subdocument has its own [deleteOne](api/subdocument#Subdocument.prototype.deleteOne()) method. For an array subdocument, this is equivalent to calling `.pull()` on the subdocument. For a single nested subdocument, `deleteOne()` is equivalent to setting the subdocument to [`null`](https://masteringjs.io/tutorials/fundamentals/null).\n\n``` javascript\n// Equivalent to `parent.children.pull(_id)`\nparent.children.id(_id).deleteOne();\n// Equivalent to `parent.child = null`\nparent.child.deleteOne();\n\nawait parent.save();\nconsole.log('the subdocs were removed');\n```\n\n## Parents of Subdocs\n\nSometimes, you need to get the parent of a subdoc. You can access the parent using the `parent()` function.\n\n``` javascript\nconst schema = new Schema({\n  docArr: [{ name: String }],\n  singleNested: new Schema({ name: String })\n});\nconst Model = mongoose.model('Test', schema);\n\nconst doc = new Model({\n  docArr: [{ name: 'foo' }],\n  singleNested: { name: 'bar' }\n});\n\ndoc.singleNested.parent() === doc; // true\ndoc.docArr[0].parent() === doc; // true\n```\n\nIf you have a deeply nested subdoc, you can access the top-level document using the `ownerDocument()` function.\n\n``` javascript\nconst schema = new Schema({\n  level1: new Schema({\n    level2: new Schema({\n      test: String\n    })\n  })\n});\nconst Model = mongoose.model('Test', schema);\n\nconst doc = new Model({ level1: { level2: 'test' } });\n\ndoc.level1.level2.parent() === doc; // false\ndoc.level1.level2.parent() === doc.level1; // true\ndoc.level1.level2.ownerDocument() === doc; // true\n```\n\n### Alternate declaration syntax for arrays\n\nIf you create a schema with an array of objects, Mongoose will automatically convert the object to a schema for you:\n\n``` javascript\nconst parentSchema = new Schema({\n  children: [{ name: 'string' }]\n});\n// Equivalent\nconst parentSchema = new Schema({\n  children: [new Schema({ name: 'string' })]\n});\n```\n\n### Next Up\n\nNow that we've covered Subdocuments, let's take a look at [querying](queries).\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/subdocs.html](https://mongoosejs.com/docs/subdocs.html)"
- name: Transactions in Mongoose
  id: transactions
  summary: Transactions are new in MongoDB 4.0 and Mongoose 5.2.0
  description: "# Transactions in Mongoose\n\n[Transactions](https://www.mongodb.com/transactions) are new in MongoDB 4.0 and Mongoose 5.2.0. Transactions let you execute multiple operations in isolation and potentially undo all the operations if one of them fails. This guide will get you started using transactions with Mongoose.\n\n## Getting Started with Transactions\n\nIf you haven't already, import mongoose:\n\n``` javascript\nimport mongoose from 'mongoose';\n```\n\nTo create a transaction, you first need to create a session using [`Mongoose#startSession`](api/mongoose#mongoose_Mongoose-startSession) or [`Connection#startSession()`](api/connection#connection_Connection-startSession).\n\n``` javascript\n// Using Mongoose's default connection\nconst session = await mongoose.startSession();\n\n// Using custom connection\nconst db = await mongoose.createConnection(mongodbUri).asPromise();\nconst session = await db.startSession();\n```\n\nIn practice, you should use either the [`session.withTransaction()` helper](https://mongodb.github.io/node-mongodb-native/3.2/api/ClientSession.html#withTransaction) or Mongoose's `Connection#transaction()` function to run a transaction. The `session.withTransaction()` helper handles:\n\n- Creating a transaction\n- Committing the transaction if it succeeds\n- Aborting the transaction if your operation throws\n- Retrying in the event of a [transient transaction error](https://stackoverflow.com/questions/52153538/what-is-a-transienttransactionerror-in-mongoose-or-mongodb).\n\n``` javascript\nlet session = null;\nreturn Customer.createCollection().\n  then(() => Customer.startSession()).\n  // The `withTransaction()` function's first parameter is a function\n  // that returns a promise.\n  then(_session => {\n    session = _session;\n    return session.withTransaction(() => {\n      return Customer.create([{ name: 'Test' }], { session: session });\n    });\n  }).\n  then(() => Customer.countDocuments()).\n  then(count => assert.strictEqual(count, 1)).\n  then(() => session.endSession());\n```\n\nFor more information on the `ClientSession#withTransaction()` function, please see [the MongoDB Node.js driver docs](https://mongodb.github.io/node-mongodb-native/3.2/api/ClientSession.html#withTransaction).\n\nMongoose's `Connection#transaction()` function is a wrapper around `withTransaction()` that integrates Mongoose change tracking with transactions. For example, suppose you `save()` a document in a transaction that later fails. The changes in that document are not persisted to MongoDB. The `Connection#transaction()` function informs Mongoose change tracking that the `save()` was rolled back, and marks all fields that were changed in the transaction as modified.\n\n``` javascript\nconst doc = new Person({ name: 'Will Riker' });\n\nawait db.transaction(async function setRank(session) {\n  doc.name = 'Captain';\n  await doc.save({ session });\n  doc.isNew; // false\n\n  // Throw an error to abort the transaction\n  throw new Error('Oops!');\n}, { readPreference: 'primary' }).catch(() => {});\n\n// true, `transaction()` reset the document's state because the\n// transaction was aborted.\ndoc.isNew;\n```\n\n## With Mongoose Documents and `save()`\n\nIf you get a [Mongoose document](documents) from [`findOne()`](api/model#model_Model-findOne) or [`find()`](api/model#model_Model-find) using a session, the document will keep a reference to the session and use that session for [`save()`](api/document#document_Document-save).\n\nTo get/set the session associated with a given document, use [`doc.$session()`](api/document#document_Document-$session).\n\n``` javascript\nconst User = db.model('User', new Schema({ name: String }));\n\nlet session = null;\nreturn User.createCollection().\n  then(() => db.startSession()).\n  then(_session => {\n    session = _session;\n    return User.create({ name: 'foo' });\n  }).\n  then(() => {\n    session.startTransaction();\n    return User.findOne({ name: 'foo' }).session(session);\n  }).\n  then(user => {\n    // Getter/setter for the session associated with this document.\n    assert.ok(user.$session());\n    user.name = 'bar';\n    // By default, `save()` uses the associated session\n    return user.save();\n  }).\n  then(() => User.findOne({ name: 'bar' })).\n  // Won't find the doc because `save()` is part of an uncommitted transaction\n  then(doc => assert.ok(!doc)).\n  then(() => session.commitTransaction()).\n  then(() => session.endSession()).\n  then(() => User.findOne({ name: 'bar' })).\n  then(doc => assert.ok(doc));\n```\n\n## With the Aggregation Framework\n\nThe `Model.aggregate()` function also supports transactions. Mongoose aggregations have a [`session()` helper](api/aggregate#aggregate_Aggregate-session) that sets the [`session` option](api/aggregate#aggregate_Aggregate-option). Below is an example of executing an aggregation within a transaction.\n\n``` javascript\nconst Event = db.model('Event', new Schema({ createdAt: Date }), 'Event');\n\nlet session = null;\nreturn Event.createCollection().\n  then(() => db.startSession()).\n  then(_session => {\n    session = _session;\n    session.startTransaction();\n    return Event.insertMany([\n      { createdAt: new Date('2018-06-01') },\n      { createdAt: new Date('2018-06-02') },\n      { createdAt: new Date('2017-06-01') },\n      { createdAt: new Date('2017-05-31') }\n    ], { session: session });\n  }).\n  then(() => Event.aggregate([\n    {\n      $group: {\n        _id: {\n          month: { $month: '$createdAt' },\n          year: { $year: '$createdAt' }\n        },\n        count: { $sum: 1 }\n      }\n    },\n    { $sort: { count: -1, '_id.year': -1, '_id.month': -1 } }\n  ]).session(session)).\n  then(res => assert.deepEqual(res, [\n    { _id: { month: 6, year: 2018 }, count: 2 },\n    { _id: { month: 6, year: 2017 }, count: 1 },\n    { _id: { month: 5, year: 2017 }, count: 1 }\n  ])).\n  then(() => session.commitTransaction()).\n  then(() => session.endSession());\n```\n\n## Advanced Usage\n\nAdvanced users who want more fine-grained control over when they commit or abort transactions can use `session.startTransaction()` to start a transaction:\n\n``` javascript\nconst Customer = db.model('Customer', new Schema({ name: String }));\n\nlet session = null;\nreturn Customer.createCollection().\n  then(() => db.startSession()).\n  then(_session => {\n    session = _session;\n    // Start a transaction\n    session.startTransaction();\n    // This `create()` is part of the transaction because of the `session`\n    // option.\n    return Customer.create([{ name: 'Test' }], { session: session });\n  }).\n  // Transactions execute in isolation, so unless you pass a `session`\n  // to `findOne()` you won't see the document until the transaction\n  // is committed.\n  then(() => Customer.findOne({ name: 'Test' })).\n  then(doc => assert.ok(!doc)).\n  // This `findOne()` will return the doc, because passing the `session`\n  // means this `findOne()` will run as part of the transaction.\n  then(() => Customer.findOne({ name: 'Test' }).session(session)).\n  then(doc => assert.ok(doc)).\n  // Once the transaction is committed, the write operation becomes\n  // visible outside of the transaction.\n  then(() => session.commitTransaction()).\n  then(() => Customer.findOne({ name: 'Test' })).\n  then(doc => assert.ok(doc)).\n  then(() => session.endSession());\n```\n\nYou can also use `session.abortTransaction()` to abort a transaction:\n\n``` javascript\nlet session = null;\nreturn Customer.createCollection().\n  then(() => Customer.startSession()).\n  then(_session => {\n    session = _session;\n    session.startTransaction();\n    return Customer.create([{ name: 'Test' }], { session: session });\n  }).\n  then(() => Customer.create([{ name: 'Test2' }], { session: session })).\n  then(() => session.abortTransaction()).\n  then(() => Customer.countDocuments()).\n  then(count => assert.strictEqual(count, 0)).\n  then(() => session.endSession());\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/transactions.html](https://mongoosejs.com/docs/transactions.html)"
- name: Using Mongoose With AWS Lambda
  id: lambda
  summary: AWS Lambda is a popular service for running arbitrary functions without managing individual servers
  description: "# Using Mongoose With AWS Lambda\n\n[AWS Lambda](https://aws.amazon.com/lambda/) is a popular service for running arbitrary functions without managing individual servers. Using Mongoose in your AWS Lambda functions is easy. Here's a sample function that connects to a MongoDB instance and finds a single document:\n\n``` javascript\nconst mongoose = require('mongoose');\n\nlet conn = null;\n\nconst uri = 'YOUR CONNECTION STRING HERE';\n\nexports.handler = async function(event, context) {\n  // Make sure to add this so you can re-use `conn` between function calls.\n  // See https://www.mongodb.com/blog/post/serverless-development-with-nodejs-aws-lambda-mongodb-atlas\n  context.callbackWaitsForEmptyEventLoop = false;\n\n  // Because `conn` is in the global scope, Lambda may retain it between\n  // function calls thanks to `callbackWaitsForEmptyEventLoop`.\n  // This means your Lambda function doesn't have to go through the\n  // potentially expensive process of connecting to MongoDB every time.\n  if (conn == null) {\n    conn = mongoose.createConnection(uri, {\n      // and tell the MongoDB driver to not wait more than 5 seconds\n      // before erroring out if it isn't connected\n      serverSelectionTimeoutMS: 5000\n    });\n\n    // `await`ing connection after assigning to the `conn` variable\n    // to avoid multiple function calls creating new connections\n    await conn.asPromise();\n    conn.model('Test', new mongoose.Schema({ name: String }));\n  }\n\n  const M = conn.model('Test');\n\n  const doc = await M.findOne();\n  console.log(doc);\n\n  return doc;\n};\n```\n\n## Connection Helper\n\nThe above code works fine for a single Lambda function, but what if you want to reuse the same connection logic in multiple Lambda functions? You can export the below function.\n\n``` javascript\nconst mongoose = require('mongoose');\n\nlet conn = null;\n\nconst uri = 'YOUR CONNECTION STRING HERE';\n\nexports.connect = async function() {\n  if (conn == null) {\n    conn = mongoose.createConnection(uri, {\n      serverSelectionTimeoutMS: 5000\n    });\n\n    // `await`ing connection after assigning to the `conn` variable\n    // to avoid multiple function calls creating new connections\n    await conn.asPromise();\n  }\n\n  return conn;\n};\n```\n\n## Using `mongoose.connect()`\n\nYou can also use `mongoose.connect()`, so you can use `mongoose.model()` to create models.\n\n``` javascript\nconst mongoose = require('mongoose');\n\nlet conn = null;\n\nconst uri = 'YOUR CONNECTION STRING HERE';\n\nexports.connect = async function() {\n  if (conn == null) {\n    conn = mongoose.connect(uri, {\n      serverSelectionTimeoutMS: 5000\n    }).then(() => mongoose);\n\n    // `await`ing connection after assigning to the `conn` variable\n    // to avoid multiple function calls creating new connections\n    await conn;\n  }\n\n  return conn;\n};\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/lambda.html](https://mongoosejs.com/docs/lambda.html)"
- name: UUID
  id: schematypes#uuid
  summary: Mongoose also supports a UUID type that stores UUID instances as Node.js buffers
  belongs_to: SchemaTypes
  description: |-
    ### UUID

    Mongoose also supports a UUID type that stores UUID instances as [Node.js buffers](https://thecodebarbarian.com/an-overview-of-buffers-in-node-js.html). We recommend using [ObjectIds](#objectids) rather than UUIDs for unique document ids in Mongoose, but you may use UUIDs if you need to.

    In Node.js, a UUID is represented as an instance of `bson.Binary` type with a [getter](tutorials/getters-setters) that converts the binary to a string when you access it. Mongoose stores UUIDs as [binary data with subtype 4 in MongoDB](https://www.mongodb.com/docs/manual/reference/bson-types/#binary-data).

    ``` javascript
    const authorSchema = new Schema({
      _id: Schema.Types.UUID, // Can also do `_id: 'UUID'`
      name: String
    });

    const Author = mongoose.model('Author', authorSchema);

    const bookSchema = new Schema({
      authorId: { type: Schema.Types.UUID, ref: 'Author' }
    });
    const Book = mongoose.model('Book', bookSchema);

    const author = new Author({ name: 'Martin Fowler' });
    console.log(typeof author._id); // 'string'
    console.log(author.toObject()._id instanceof mongoose.mongo.BSON.Binary); // true

    const book = new Book({ authorId: '09190f70-3d30-11e5-8814-0f4df9a59c41' });
    ```

    To create UUIDs, we recommend using [Node's built-in UUIDv4 generator](https://nodejs.org/api/crypto.html#cryptorandomuuidoptions).

    ``` javascript
    const { randomUUID } = require('crypto');

    const schema = new mongoose.Schema({
      docId: {
        type: 'UUID',
        default: () => randomUUID()
      }
    });
    ```
- name: Validation
  id: validation
  summary: Mongoose has several built-in validators
  description: "# Validation\n\nBefore we get into the specifics of validation syntax, please keep the following rules in mind:\n\n- Validation is defined in the [SchemaType](schematypes)\n- Validation is [middleware](middleware). Mongoose registers validation as a `pre('save')` hook on every schema by default.\n- Validation always runs as the **first** `pre('save')` hook. This means that validation doesn't run on any changes you make in `pre('save')` hooks.\n- You can disable automatic validation before save by setting the [validateBeforeSave](guide#validateBeforeSave) option\n- You can manually run validation using `doc.validate()` or `doc.validateSync()`\n- You can manually mark a field as invalid (causing validation to fail) by using [`doc.invalidate(...)`](api/document#document_Document-invalidate)\n- Validators are not run on undefined values. The only exception is the [`required` validator](api/schematype#schematype_SchemaType-required).\n- When you call [Model#save](api/model#model_Model-save), Mongoose also runs subdocument validation. If an error occurs, your [Model#save](api/model#model_Model-save) promise rejects\n- Validation is customizable\n\n``` javascript\nconst schema = new Schema({\n  name: {\n    type: String,\n    required: true\n  }\n});\nconst Cat = db.model('Cat', schema);\n\n// This cat has no name :(\nconst cat = new Cat();\n\nlet error;\ntry {\n  await cat.save();\n} catch (err) {\n  error = err;\n}\n\nassert.equal(error.errors['name'].message,\n  'Path `name` is required.');\n\nerror = cat.validateSync();\nassert.equal(error.errors['name'].message,\n  'Path `name` is required.');\n```\n\n- [Built-in Validators](#built-in-validators)\n- [Custom Error Messages](#custom-error-messages)\n- [The `unique` Option is Not a Validator](#the-unique-option-is-not-a-validator)\n- [Custom Validators](#custom-validators)\n- [Async Custom Validators](#async-custom-validators)\n- [Validation Errors](#validation-errors)\n- [Cast Errors](#cast-errors)\n- [Global SchemaType Validation](#global-schematype-validation)\n- [Required Validators On Nested Objects](#required-validators-on-nested-objects)\n- [Update Validators](#update-validators)\n- [Update Validators and `this`](#update-validators-and-this)\n- [Update Validators Only Run On Updated Paths](#update-validators-only-run-on-updated-paths)\n- [Update Validators Only Run For Some Operations](#update-validators-only-run-for-some-operations)\n\n## Built-in Validators\n\nMongoose has several built-in validators.\n\n- All [SchemaTypes](schematypes) have the built-in [required](api/schematype#schematype_SchemaType-required) validator. The required validator uses the [SchemaType's `checkRequired()` function](api/schematype#schematype_SchemaType-checkRequired) to determine if the value satisfies the required validator.\n- [Numbers](schematypes#numbers) have [`min` and `max`](schematypes#number-validators) validators.\n- [Strings](schematypes#strings) have [`enum`, `match`, `minLength`, and `maxLength`](schematypes#string-validators) validators.\n\nEach of the validator links above provide more information about how to enable them and customize their error messages.\n\n``` javascript\nconst breakfastSchema = new Schema({\n  eggs: {\n    type: Number,\n    min: [6, 'Too few eggs'],\n    max: 12\n  },\n  bacon: {\n    type: Number,\n    required: [true, 'Why no bacon?']\n  },\n  drink: {\n    type: String,\n    enum: ['Coffee', 'Tea'],\n    required: function() {\n      return this.bacon > 3;\n    }\n  }\n});\nconst Breakfast = db.model('Breakfast', breakfastSchema);\n\nconst badBreakfast = new Breakfast({\n  eggs: 2,\n  bacon: 0,\n  drink: 'Milk'\n});\nlet error = badBreakfast.validateSync();\nassert.equal(error.errors['eggs'].message,\n  'Too few eggs');\nassert.ok(!error.errors['bacon']);\nassert.equal(error.errors['drink'].message,\n  '`Milk` is not a valid enum value for path `drink`.');\n\nbadBreakfast.bacon = 5;\nbadBreakfast.drink = null;\n\nerror = badBreakfast.validateSync();\nassert.equal(error.errors['drink'].message, 'Path `drink` is required.');\n\nbadBreakfast.bacon = null;\nerror = badBreakfast.validateSync();\nassert.equal(error.errors['bacon'].message, 'Why no bacon?');\n```\n\n## Custom Error Messages\n\nYou can configure the error message for individual validators in your schema. There are two equivalent ways to set the validator error message:\n\n- Array syntax: `min: [6, 'Must be at least 6, got {VALUE}']`\n- Object syntax: `enum: { values: ['Coffee', 'Tea'], message: '{VALUE} is not supported' }`\n\nMongoose also supports rudimentary templating for error messages. Mongoose replaces `{VALUE}` with the value being validated.\n\n``` javascript\nconst breakfastSchema = new Schema({\n  eggs: {\n    type: Number,\n    min: [6, 'Must be at least 6, got {VALUE}'],\n    max: 12\n  },\n  drink: {\n    type: String,\n    enum: {\n      values: ['Coffee', 'Tea'],\n      message: '{VALUE} is not supported'\n    }\n  }\n});\nconst Breakfast = db.model('Breakfast', breakfastSchema);\n\nconst badBreakfast = new Breakfast({\n  eggs: 2,\n  drink: 'Milk'\n});\nconst error = badBreakfast.validateSync();\nassert.equal(error.errors['eggs'].message,\n  'Must be at least 6, got 2');\nassert.equal(error.errors['drink'].message, 'Milk is not supported');\n```\n\n## The `unique` Option is Not a Validator\n\nA common gotcha for beginners is that the `unique` option for schemas is *not* a validator. It's a convenient helper for building [MongoDB unique indexes](https://www.mongodb.com/docs/manual/core/index-unique/). See the [FAQ](https://mongoosejs.com/docs/faq.html) for more information.\n\n``` javascript\nconst uniqueUsernameSchema = new Schema({\n  username: {\n    type: String,\n    unique: true\n  }\n});\nconst U1 = db.model('U1', uniqueUsernameSchema);\nconst U2 = db.model('U2', uniqueUsernameSchema);\n\nconst dup = [{ username: 'Val' }, { username: 'Val' }];\n// Race condition! This may save successfully, depending on whether\n// MongoDB built the index before writing the 2 docs.\nU1.create(dup).\n  then(() => {\n  }).\n  catch(err => {\n  });\n\n// You need to wait for Mongoose to finish building the `unique`\n// index before writing. You only need to build indexes once for\n// a given collection, so you normally don't need to do this\n// in production. But, if you drop the database between tests,\n// you will need to use `init()` to wait for the index build to finish.\nU2.init().\n  then(() => U2.create(dup)).\n  catch(error => {\n    // `U2.create()` will error, but will *not* be a mongoose validation error, it will be\n    // a duplicate key error.\n    // See: https://masteringjs.io/tutorials/mongoose/e11000-duplicate-key\n    assert.ok(error);\n    assert.ok(!error.errors);\n    assert.ok(error.message.indexOf('duplicate key error') !== -1);\n  });\n```\n\n## Custom Validators\n\nIf the built-in validators aren't enough, you can define custom validators to suit your needs.\n\nCustom validation is declared by passing a validation function. You can find detailed instructions on how to do this in the [`SchemaType#validate()` API docs](api/schematype#schematype_SchemaType-validate).\n\n``` javascript\nconst userSchema = new Schema({\n  phone: {\n    type: String,\n    validate: {\n      validator: function(v) {\n        return /\\d{3}-\\d{3}-\\d{4}/.test(v);\n      },\n      message: props => `${props.value} is not a valid phone number!`\n    },\n    required: [true, 'User phone number required']\n  }\n});\n\nconst User = db.model('user', userSchema);\nconst user = new User();\nlet error;\n\nuser.phone = '555.0123';\nerror = user.validateSync();\nassert.equal(error.errors['phone'].message,\n  '555.0123 is not a valid phone number!');\n\nuser.phone = '';\nerror = user.validateSync();\nassert.equal(error.errors['phone'].message,\n  'User phone number required');\n\nuser.phone = '201-555-0123';\n// Validation succeeds! Phone number is defined\n// and fits `DDD-DDD-DDDD`\nerror = user.validateSync();\nassert.equal(error, null);\n```\n\n## Async Custom Validators\n\nCustom validators can also be asynchronous. If your validator function returns a promise (like an `async` function), mongoose will wait for that promise to settle. If the returned promise rejects, or fulfills with the value `false`, Mongoose will consider that a validation error.\n\n``` javascript\nconst userSchema = new Schema({\n  name: {\n    type: String,\n    // You can also make a validator async by returning a promise.\n    validate: () => Promise.reject(new Error('Oops!'))\n  },\n  email: {\n    type: String,\n    // There are two ways for an promise-based async validator to fail:\n    // 1) If the promise rejects, Mongoose assumes the validator failed with the given error.\n    // 2) If the promise resolves to `false`, Mongoose assumes the validator failed and creates an error with the given `message`.\n    validate: {\n      validator: () => Promise.resolve(false),\n      message: 'Email validation failed'\n    }\n  }\n});\n\nconst User = db.model('User', userSchema);\nconst user = new User();\n\nuser.email = 'test@test.co';\nuser.name = 'test';\n\nlet error;\ntry {\n  await user.validate();\n} catch (err) {\n  error = err;\n}\nassert.ok(error);\nassert.equal(error.errors['name'].message, 'Oops!');\nassert.equal(error.errors['email'].message, 'Email validation failed');\n```\n\n## Validation Errors\n\nErrors returned after failed validation contain an `errors` object whose values are `ValidatorError` objects. Each [ValidatorError](api/error#error_Error-ValidatorError) has `kind`, `path`, `value`, and `message` properties. A ValidatorError also may have a `reason` property. If an error was thrown in the validator, this property will contain the error that was thrown.\n\n``` javascript\nconst toySchema = new Schema({\n  color: String,\n  name: String\n});\n\nconst validator = function(value) {\n  return /red|white|gold/i.test(value);\n};\ntoySchema.path('color').validate(validator,\n  'Color `{VALUE}` not valid', 'Invalid color');\ntoySchema.path('name').validate(function(v) {\n  if (v !== 'Turbo Man') {\n    throw new Error('Need to get a Turbo Man for Christmas');\n  }\n  return true;\n}, 'Name `{VALUE}` is not valid');\n\nconst Toy = db.model('Toy', toySchema);\n\nconst toy = new Toy({ color: 'Green', name: 'Power Ranger' });\n\nlet error;\ntry {\n  await toy.save();\n} catch (err) {\n  error = err;\n}\n\n// `error` is a ValidationError object\n// `error.errors.color` is a ValidatorError object\nassert.equal(error.errors.color.message, 'Color `Green` not valid');\nassert.equal(error.errors.color.kind, 'Invalid color');\nassert.equal(error.errors.color.path, 'color');\nassert.equal(error.errors.color.value, 'Green');\n\n// If your validator throws an exception, mongoose will use the error\n// message. If your validator returns `false`,\n// mongoose will use the 'Name `Power Ranger` is not valid' message.\nassert.equal(error.errors.name.message,\n  'Need to get a Turbo Man for Christmas');\nassert.equal(error.errors.name.value, 'Power Ranger');\n// If your validator threw an error, the `reason` property will contain\n// the original error thrown, including the original stack trace.\nassert.equal(error.errors.name.reason.message,\n  'Need to get a Turbo Man for Christmas');\n\nassert.equal(error.name, 'ValidationError');\n```\n\n## Cast Errors\n\nBefore running validators, Mongoose attempts to coerce values to the correct type. This process is called *casting* the document. If casting fails for a given path, the `error.errors` object will contain a `CastError` object.\n\nCasting runs before validation, and validation does not run if casting fails. That means your custom validators may assume `v` is `null`, `undefined`, or an instance of the type specified in your schema.\n\n``` javascript\nconst vehicleSchema = new mongoose.Schema({\n  numWheels: { type: Number, max: 18 }\n});\nconst Vehicle = db.model('Vehicle', vehicleSchema);\n\nconst doc = new Vehicle({ numWheels: 'not a number' });\nconst err = doc.validateSync();\n\nerr.errors['numWheels'].name; // 'CastError'\n// 'Cast to Number failed for value \"not a number\" at path \"numWheels\"'\nerr.errors['numWheels'].message;\n```\n\nBy default, Mongoose cast error messages look like `Cast to Number failed for value \"pie\" at path \"numWheels\"`. You can overwrite Mongoose's default cast error message by the `cast` option on your SchemaType to a string as follows.\n\n``` javascript\nconst vehicleSchema = new mongoose.Schema({\n  numWheels: {\n    type: Number,\n    cast: '{VALUE} is not a number'\n  }\n});\nconst Vehicle = db.model('Vehicle', vehicleSchema);\n\nconst doc = new Vehicle({ numWheels: 'pie' });\nconst err = doc.validateSync();\n\nerr.errors['numWheels'].name; // 'CastError'\n// \"pie\" is not a number\nerr.errors['numWheels'].message;\n```\n\nMongoose's cast error message templating supports the following parameters:\n\n- `{PATH}`: the path that failed to cast\n- `{VALUE}`: a string representation of the value that failed to cast\n- `{KIND}`: the type that Mongoose attempted to cast to, like `'String'` or `'Number'`\n\nYou can also define a function that Mongoose will call to get the cast error message as follows.\n\n``` javascript\nconst vehicleSchema = new mongoose.Schema({\n  numWheels: {\n    type: Number,\n    cast: [null, (value, path, model, kind) => `\"${value}\" is not a number`]\n  }\n});\nconst Vehicle = db.model('Vehicle', vehicleSchema);\n\nconst doc = new Vehicle({ numWheels: 'pie' });\nconst err = doc.validateSync();\n\nerr.errors['numWheels'].name; // 'CastError'\n// \"pie\" is not a number\nerr.errors['numWheels'].message;\n```\n\n## Global SchemaType Validation\n\nIn addition to defining custom validators on individual schema paths, you can also configure a custom validator to run on every instance of a given `SchemaType`. For example, the following code demonstrates how to make empty string `''` an invalid value for *all* string paths.\n\n``` javascript\n// Add a custom validator to all strings\nmongoose.Schema.Types.String.set('validate', v => v == null || v > 0);\n\nconst userSchema = new Schema({\n  name: String,\n  email: String\n});\nconst User = db.model('User', userSchema);\n\nconst user = new User({ name: '', email: '' });\n\nconst err = await user.validate().then(() => null, err => err);\nerr.errors['name']; // ValidatorError\nerr.errors['email']; // ValidatorError\n```\n\n## Required Validators On Nested Objects\n\nDefining validators on nested objects in mongoose is tricky, because nested objects are not fully fledged paths.\n\n``` javascript\nlet personSchema = new Schema({\n  name: {\n    first: String,\n    last: String\n  }\n});\n\nassert.throws(function() {\n  // This throws an error, because 'name' isn't a full fledged path\n  personSchema.path('name').required(true);\n}, /Cannot.*'required'/);\n\n// To make a nested object required, use a single nested schema\nconst nameSchema = new Schema({\n  first: String,\n  last: String\n});\n\npersonSchema = new Schema({\n  name: {\n    type: nameSchema,\n    required: true\n  }\n});\n\nconst Person = db.model('Person', personSchema);\n\nconst person = new Person();\nconst error = person.validateSync();\nassert.ok(error.errors['name']);\n```\n\n## Update Validators\n\nIn the above examples, you learned about document validation. Mongoose also supports validation for [`update()`](api/query#query_Query-update), [`updateOne()`](api/query#query_Query-updateOne), [`updateMany()`](api/query#query_Query-updateMany), and [`findOneAndUpdate()`](api/query#query_Query-findOneAndUpdate) operations. Update validators are off by default - you need to specify the `runValidators` option.\n\nTo turn on update validators, set the `runValidators` option for `update()`, `updateOne()`, `updateMany()`, or `findOneAndUpdate()`. Be careful: update validators are off by default because they have several caveats.\n\n``` javascript\nconst toySchema = new Schema({\n  color: String,\n  name: String\n});\n\nconst Toy = db.model('Toys', toySchema);\n\nToy.schema.path('color').validate(function(value) {\n  return /red|green|blue/i.test(value);\n}, 'Invalid color');\n\nconst opts = { runValidators: true };\n\nlet error;\ntry {\n  await Toy.updateOne({}, { color: 'not a color' }, opts);\n} catch (err) {\n  error = err;\n}\n\nassert.equal(error.errors.color.message, 'Invalid color');\n```\n\n## Update Validators and `this`\n\nThere are a couple of key differences between update validators and document validators. In the color validation function below, `this` refers to the document being validated when using document validation. However, when running update validators, `this` refers to the query object instead of the document. Because queries have a neat `.get()` function, you can get the updated value of the property you want.\n\n``` javascript\nconst toySchema = new Schema({\n  color: String,\n  name: String\n});\n\ntoySchema.path('color').validate(function(value) {\n  // When running in `validate()` or `validateSync()`, the\n  // validator can access the document using `this`.\n  // When running with update validators, `this` is the Query,\n  // **not** the document being updated!\n  // Queries have a `get()` method that lets you get the\n  // updated value.\n  if (this.get('name') && this.get('name').toLowerCase().indexOf('red') !== -1) {\n    return value === 'red';\n  }\n  return true;\n});\n\nconst Toy = db.model('ActionFigure', toySchema);\n\nconst toy = new Toy({ color: 'green', name: 'Red Power Ranger' });\n// Validation failed: color: Validator failed for path `color` with value `green`\nlet error = toy.validateSync();\nassert.ok(error.errors['color']);\n\nconst update = { color: 'green', name: 'Red Power Ranger' };\nconst opts = { runValidators: true };\n\nerror = null;\ntry {\n  await Toy.updateOne({}, update, opts);\n} catch (err) {\n  error = err;\n}\n// Validation failed: color: Validator failed for path `color` with value `green`\nassert.ok(error);\n```\n\n## Update Validators Only Run On Updated Paths\n\nThe other key difference is that update validators only run on the paths specified in the update. For instance, in the below example, because 'name' is not specified in the update operation, update validation will succeed.\n\nWhen using update validators, `required` validators **only** fail when you try to explicitly `$unset` the key.\n\n``` javascript\nconst kittenSchema = new Schema({\n  name: { type: String, required: true },\n  age: Number\n});\n\nconst Kitten = db.model('Kitten', kittenSchema);\n\nconst update = { color: 'blue' };\nconst opts = { runValidators: true };\n// Operation succeeds despite the fact that 'name' is not specified\nawait Kitten.updateOne({}, update, opts);\n\nconst unset = { $unset: { name: 1 } };\n// Operation fails because 'name' is required\nconst err = await Kitten.updateOne({}, unset, opts).then(() => null, err => err);\nassert.ok(err);\nassert.ok(err.errors['name']);\n```\n\n## Update Validators Only Run For Some Operations\n\nOne final detail worth noting: update validators **only** run on the following update operators:\n\n- `$set`\n- `$unset`\n- `$push`\n- `$addToSet`\n- `$pull`\n- `$pullAll`\n\nFor instance, the below update will succeed, regardless of the value of `number`, because update validators ignore `$inc`.\n\nAlso, `$push`, `$addToSet`, `$pull`, and `$pullAll` validation does **not** run any validation on the array itself, only individual elements of the array.\n\n``` javascript\nconst testSchema = new Schema({\n  number: { type: Number, max: 0 },\n  arr: [{ message: { type: String, maxlength: 10 } }]\n});\n\n// Update validators won't check this, so you can still `$push` 2 elements\n// onto the array, so long as they don't have a `message` that's too long.\ntestSchema.path('arr').validate(function(v) {\n  return v.length < 2;\n});\n\nconst Test = db.model('Test', testSchema);\n\nlet update = { $inc: { number: 1 } };\nconst opts = { runValidators: true };\n\n// There will never be a validation error here\nawait Test.updateOne({}, update, opts);\n\n// This will never error either even though the array will have at\n// least 2 elements.\nupdate = { $push: [{ message: 'hello' }, { message: 'world' }] };\nawait Test.updateOne({}, update, opts);\n```\n\n## Next Up\n\nNow that we've covered `Validation`, let's take a look at [Middleware](middleware).\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/validation.html](https://mongoosejs.com/docs/validation.html)"
- name: Version Support
  id: version-support
  summary: Mongoose 7.x (released February 27, 2023) is the current Mongoose major version
  description: "# Version Support\n\nMongoose 7.x (released February 27, 2023) is the current Mongoose major version. We ship all new bug fixes and features to 7.x.\n\n## Mongoose 6\n\nMongoose 6.x (released August 24, 2021) is currently in legacy support. We will continue to ship bug fixes to Mongoose 6 until August 24, 2023. After August 24, 2023, we will only ship security fixes, and backport requested fixes to Mongoose 6. Please open a [bug report on GitHub](https://github.com/Automattic/mongoose/issues/new?assignees=&labels=&template=bug.yml) to request backporting a fix to Mongoose 6.\n\nWe are **not** actively backporting any new features from Mongoose 7 into Mongoose 6. Until August 24, 2023, we will backport requested features into Mongoose 6; please open a [feature request on GitHub](https://github.com/Automattic/mongoose/issues/new?assignees=&labels=enhancement%2Cnew+feature&template=feature.yml) to request backporting a feature into Mongoose 6. After August 24, 2023, we will not backport any new features into Mongoose 6.\n\nWe do not currently have a formal end of life (EOL) date for Mongoose 6. However, we will not end support for Mongoose 6 until at least January 1, 2024.\n\n## Mongoose 5\n\nMongoose 5.x (released January 17, 2018) is currently only receiving security fixes and requested bug fixes. Please open a [bug report on GitHub](https://github.com/Automattic/mongoose/issues/new?assignees=&labels=&template=bug.yml) to request backporting a fix to Mongoose 5. We will **not** backport any new features from Mongoose 6 or Mongoose 7 into Mongoose 5.\n\nMongoose 5.x end of life (EOL) is March 1, 2024. Mongoose 5.x will no longer receive any updates, security or otherwise, after that date.\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/version-support.html](https://mongoosejs.com/docs/version-support.html)"
- name: Virtualtype
  id: api/virtualtype
  summary: This is what mongoose uses to define virtual attributes via Schema.prototype.virtual
  description: "# Virtualtype\n\n### VirtualType()\n\n##### Parameters:\n\n- `options` «Object»\n\n- `[options.ref]` «String\\|Function» if `ref` is not nullish, this becomes a [populated virtual](../populate#populate-virtuals)\n\n&nbsp;\n\n- `[options.localField]` «String\\|Function» the local field to populate on if this is a populated virtual.\n\n&nbsp;\n\n- `[options.foreignField]` «String\\|Function» the foreign field to populate on if this is a populated virtual.\n\n&nbsp;\n\n- `[options.justOne=false]` «Boolean» by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.\n\n&nbsp;\n\n- `[options.getters=false]` «Boolean» if you set this to `true`, Mongoose will call any custom getters you defined on this virtual\n\n&nbsp;\n\n- `[options.count=false]` «Boolean» if you set this to `true`, `populate()` will set this virtual to the number of populated documents, as opposed to the documents themselves, using [`Query#countDocuments()`](query#Query.prototype.countDocuments())\n\n&nbsp;\n\n- `[options.match=null]` «Object\\|Function» add an extra match condition to `populate()`\n\n&nbsp;\n\n- `[options.limit=null]` «Number» add a default `limit` to the `populate()` query\n\n&nbsp;\n\n- `[options.skip=null]` «Number» add a default `skip` to the `populate()` query\n\n&nbsp;\n\n- `[options.perDocumentLimit=null]` «Number» For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n\n&nbsp;\n\n- `[options.options=null]` «Object» Additional options like `limit` and `lean`.\n\n&nbsp;\n\n- `name` «String»\n\nVirtualType constructor\n\nThis is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\n\n#### [Example:](#example)\n\n``` javascript\nconst fullname = schema.virtual('fullname');\nfullname instanceof mongoose.VirtualType // true\n```\n\n### VirtualType.prototype.applyGetters()\n\n##### Parameters:\n\n- `value` «Object»\n- `doc` «Document» The document this virtual is attached to\n\n##### Returns:\n\n- «Any» the value after applying all getters\n\nApplies getters to `value`.\n\n### VirtualType.prototype.applySetters()\n\n##### Parameters:\n\n- `value` «Object»\n- `doc` «Document»\n\n##### Returns:\n\n- «Any» the value after applying all setters\n\nApplies setters to `value`.\n\n### VirtualType.prototype.get()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «VirtualType» this\n\nAdds a custom getter to this virtual.\n\nMongoose calls the getter function with the below 3 parameters.\n\n- `value`: the value returned by the previous getter. If there is only one getter, `value` will be `undefined`.\n- `virtual`: the virtual object you called `.get()` on.\n- `doc`: the document this virtual is attached to. Equivalent to `this`.\n\n#### [Example:](#example)\n\n``` javascript\nconst virtual = schema.virtual('fullname');\nvirtual.get(function(value, virtual, doc) {\n  return this.name.first + ' ' + this.name.last;\n});\n```\n\n### VirtualType.prototype.set()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «VirtualType» this\n\nAdds a custom setter to this virtual.\n\nMongoose calls the setter function with the below 3 parameters.\n\n- `value`: the value being set.\n- `virtual`: the virtual object you're calling `.set()` on.\n- `doc`: the document this virtual is attached to. Equivalent to `this`.\n\n#### [Example:](#example)\n\n``` javascript\nconst virtual = schema.virtual('fullname');\nvirtual.set(function(value, virtual, doc) {\n  const parts = value.split(' ');\n  this.name.first = parts[0];\n  this.name.last = parts[1];\n});\n\nconst Model = mongoose.model('Test', schema);\nconst doc = new Model();\n// Calls the setter with `value = 'Jean-Luc Picard'`\ndoc.fullname = 'Jean-Luc Picard';\ndoc.name.first; // 'Jean-Luc'\ndoc.name.last; // 'Picard'\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/virtualtype.html](https://mongoosejs.com/docs/api/virtualtype.html)"
- name: VirtualType()
  id: api/virtualtype#VirtualType()
  summary: This is what mongoose uses to define virtual attributes via Schema.prototype.virtual
  belongs_to: Virtualtype
  description: |-
    ### VirtualType()

    ##### Parameters:

    - `options` «Object»

    - `[options.ref]`«String\|Function» if `ref` is not nullish, this becomes a [populated virtual](../populate#populate-virtuals)

    &nbsp;

    - `[options.localField]`«String\|Function» the local field to populate on if this is a populated virtual.

    &nbsp;

    - `[options.foreignField]`«String\|Function» the foreign field to populate on if this is a populated virtual.

    &nbsp;

    - `[options.justOne=false]`«Boolean» by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.

    &nbsp;

    - `[options.getters=false]`«Boolean» if you set this to `true`, Mongoose will call any custom getters you defined on this virtual

    &nbsp;

    - `[options.count=false]`«Boolean» if you set this to `true`, `populate()` will set this virtual to the number of populated documents, as opposed to the documents themselves, using [`Query#countDocuments()`](query#Query.prototype.countDocuments())

    &nbsp;

    - `[options.match=null]`«Object\|Function» add an extra match condition to `populate()`

    &nbsp;

    - `[options.limit=null]`«Number» add a default `limit` to the `populate()` query

    &nbsp;

    - `[options.skip=null]`«Number» add a default `skip` to the `populate()` query

    &nbsp;

    - `[options.perDocumentLimit=null]`«Number» For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.

    &nbsp;

    - `[options.options=null]`«Object» Additional options like `limit` and `lean`.

    &nbsp;

    - `name` «String»

    VirtualType constructor

    This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.

    #### [Example:](#example)

    ``` javascript
    const fullname = schema.virtual('fullname');
    fullname instanceof mongoose.VirtualType // true
    ```
- name: VirtualType.prototype.applyGetters()
  id: api/virtualtype#VirtualType.prototype.applyGetters()
  summary: Applies getters to value
  belongs_to: Virtualtype
  description: |-
    ### VirtualType.prototype.applyGetters()

    ##### Parameters:

    - `value` «Object»
    - `doc`«Document» The document this virtual is attached to

    ##### Returns:

    - «Any» the value after applying all getters

    Applies getters to `value`.
- name: VirtualType.prototype.applySetters()
  id: api/virtualtype#VirtualType.prototype.applySetters()
  summary: Applies setters to value
  belongs_to: Virtualtype
  description: |-
    ### VirtualType.prototype.applySetters()

    ##### Parameters:

    - `value` «Object»
    - `doc` «Document»

    ##### Returns:

    - «Any» the value after applying all setters

    Applies setters to `value`.
- name: VirtualType.prototype.get()
  id: api/virtualtype#VirtualType.prototype.get()
  summary: Adds a custom getter to this virtual
  belongs_to: Virtualtype
  description: |-
    ### VirtualType.prototype.get()

    ##### Parameters:

    - `fn` «Function»

    ##### Returns:

    - «VirtualType» this

    Adds a custom getter to this virtual.

    Mongoose calls the getter function with the below 3 parameters.

    - `value`: the value returned by the previous getter. If there is only one getter, `value` will be `undefined`.
    - `virtual`: the virtual object you called `.get()` on.
    - `doc`: the document this virtual is attached to. Equivalent to `this`.

    #### [Example:](#example)

    ``` javascript
    const virtual = schema.virtual('fullname');
    virtual.get(function(value, virtual, doc) {
      return this.name.first + ' ' + this.name.last;
    });
    ```
- name: VirtualType.prototype.set()
  id: api/virtualtype#VirtualType.prototype.set()
  summary: Adds a custom setter to this virtual
  belongs_to: Virtualtype
  description: "### VirtualType.prototype.set()\n\n##### Parameters:\n\n- `fn` «Function»\n\n##### Returns:\n\n- «VirtualType» this\n\nAdds a custom setter to this virtual.\n\nMongoose calls the setter function with the below 3 parameters.\n\n- `value`: the value being set.\n- `virtual`: the virtual object you're calling `.set()` on.\n- `doc`: the document this virtual is attached to. Equivalent to `this`.\n\n#### [Example:](#example)\n\n``` javascript\nconst virtual = schema.virtual('fullname');\nvirtual.set(function(value, virtual, doc) {\n  const parts = value.split(' ');\n  this.name.first = parts[0];\n  this.name.last = parts[1];\n});\n\nconst Model = mongoose.model('Test', schema);\nconst doc = new Model();\n// Calls the setter with `value = 'Jean-Luc Picard'`\ndoc.fullname = 'Jean-Luc Picard';\ndoc.name.first; // 'Jean-Luc'\ndoc.name.last; // 'Picard'\n```\n\n© 2010 LearnBoost  \nLicensed under the MIT License.  \n[https://mongoosejs.com/docs/api/virtualtype.html](https://mongoosejs.com/docs/api/virtualtype.html)"
